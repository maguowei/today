[
  {
    "title": "所有主流浏览器都支持新的JavaScript集合方法",
    "url": "https://www.infoq.cn/article/BXCwkECbShAAe1hGYwdj",
    "summary": "<p>随着Firefox 127的发布，现在所有主流浏览器引擎都全面支持新的<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set#Set_methods?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MjQ3MjQ3OTEsImZpbGVHVUlEIjoiZ08zb2RNWVlKWHNuT09xRCIsImlhdCI6MTcyNDcyNDQ5MSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo1MDA3OTA2fQ.b5qKNZ2C82AbROURfTZxso_SxxHGVUN-AWDuyBPm2zk\">JavaScript集合方法</a>\"，包括intersection()、union()、difference()、symmetricDifference()、isSubsetOf()、isSupersetOf()和isDisjointFrom()。这意味着开发者们不再需要依赖polyfill来确保这些方法在不同环境中的兼容性。这些新加入的特性提供了一套便捷的内置工具来操作和比较集合，不仅简化了开发，还提升了程序的性能。</p><p></p><p>JavaScript中的Set与Array类似，但它可以确保集合中的每个元素都是唯一的。这种自动除重的特性使得Set成为创建唯一元素集合的理想选择。下面是一个简单的例子，展示了如何创建一个Set并向其添加元素：</p><p></p><p><code lang=\"javascript\">const users = new Set();\n\nconst alice = { id: 1, name: \"Alice\" };\n\nusers.add(alice);\n\nusers.forEach(user =&gt; { console.log(user) });</code></p><p></p><p>在检查元素是否存在时， Set通常比Array更加高效，这一特性使得它对于性能要求较高的应用程序来说非常有价值。</p><p></p><p>union()方法返回一个新Set，包含原始Set和给定Set中的元素。这个方法在合并集合时极为有用，同时确保结果集中不包含重复项：</p><p></p><p><code lang=\"javascript\">const set1 = new Set([\"Alice\", \"Bob\", \"Charlie\"]);\n\nconst set2 = new Set([\"Bob\", \"Charlie\", \"David\"]);\n\nconst unionSet = set1.union(set2);\n\nunionSet.forEach(name =&gt; {\n\n&nbsp; console.log(name); // 输出: Alice, Bob, Charlie, David\n\n});</code></p><p></p><p>intersection()方法返回一个新Set，只包含两个Set共有的元素。这个方法在识别两个集合共同元素时非常有用：</p><p></p><p><code lang=\"javascript\">const intersectionSet = set1.intersection(set2);\n\nintersectionSet.forEach(name =&gt; {\n\n&nbsp; console.log(name); // 输出: Bob, Charlie\n\n});</code></p><p></p><p>symmetricDifference()方法返回一个新Set，包含只在其中一个Set中出现的元素，不包含两个Set共有的元素。这个方法在识别两个集合各自的不同元素时非常有用：</p><p></p><p><code lang=\"javascript\">const symmetricDifferenceSet = set1.symmetricDifference(set2);\n\nsymmetricDifferenceSet.forEach(name =&gt; {\n\n&nbsp; console.log(name); // 输出: Alice, David\n\n});</code></p><p></p><p>difference()方法返回一个新Set，包含了原始Set中有而给定Set中没有的元素。这在需要从集合中排除某些元素时非常有用：</p><p></p><p><code lang=\"javascript\">const set1Only = set1.difference(set2);\n\nset1Only.forEach(name =&gt; {\n\n&nbsp; console.log(name); // 输出: Alice\n\n});</code></p><p></p><p>isSubsetOf()和isSupersetOf()方法根据两个Set之间的包含关系返回一个布尔值。isSubsetOf()方法检查一个Set的所有元素是否都包含在另一个Set中，而isSupersetOf()方法检查一个Set是否包含了另一个Set的所有元素。</p><p><code lang=\"javascript\">const subset = new Set([\"Alice\", \"Bob\"]);\n\nconst superset = new Set([\"Alice\", \"Bob\", \"Charlie\"]);\n\nif (subset.isSubsetOf(superset)) {\n\n&nbsp; console.log(\"subset is a subset of superset\"); // 这将被打印出来，因为subset的所有元素也都在superset中。\n\n} else {\n\n&nbsp; console.log(\"subset is not a subset of superset\");\n\n}\n\nif (superset.isSupersetOf(subset)) {\n\n&nbsp; console.log(\"superset is a superset of subset\"); // 这将被打印出来，因为subset中的所有元素也都在superset中。\n\n} else {\n\n&nbsp; console.log(\"superset is not a superset of subset\");\n\n}\n</code></p><p></p><p>isDisjointFrom()方法检查两个Set是否有共同元素：</p><p><code lang=\"javascript\">const set3 = new Set([\"Eve\", \"Frank\", \"Gina\"]);\n\nif (set1.isDisjointFrom(set2)) {\n  console.log(\"Set1 and Set2 are disjoint\"); // 这将被打印出来，因为集合set1和集合set2没有共同元素\n} else {\n  console.log(\"Set1 and Set2 are not disjoint\");\n}\n\nif (set1.isDisjointFrom(set3)) {\n  console.log(\"Set1 and Set3 are disjoint\");\n} else {\n  console.log(\"Set1 and Set3 are not disjoint\"); // 这将被打印出来，因为集合set1和集合set3有一个共同的元素“Charlie”</code></p><p>社区对这些新方法反响热烈。在<a href=\"https://www.reddit.com/r/javascript/comments/1dzqmj6/new_javascript_set_methods?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MjQ3MjQ3OTEsImZpbGVHVUlEIjoiZ08zb2RNWVlKWHNuT09xRCIsImlhdCI6MTcyNDcyNDQ5MSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo1MDA3OTA2fQ.b5qKNZ2C82AbROURfTZxso_SxxHGVUN-AWDuyBPm2zk\">Reddit的一个讨论帖</a>\"中，用户peterlinddk表示：</p><p></p><p></p><blockquote>“太好了，我们终于可以用Set做更多的事情，不仅仅是‘重复项检测器’。我还希望有一种方法，允许对象在不必是完全相同的实例的情况下也能被认为是‘相等’的，有点像Java的.equals和.hashCode方法。”</blockquote><p></p><p></p><p>另一位用户Pelopida92对这些新方法在性能上带来的提升表示赞赏，并表示：</p><p></p><p></p><blockquote>“Set太棒了。我在一些处理大数据量的脚本中广泛使用了这些Set方法，因为它们不仅在性能上优于数组，使用起来也非常简便和直观。”</blockquote><p></p><p></p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2024/07/javascript-set-methods/\">https://www.infoq.com/news/2024/07/javascript-set-methods/</a>\"</p>",
    "publish_time": "2024-08-29 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "AI技术如何深入各行各业？Intel AI Summit专场全栈落地实践分享丨AICon",
    "url": "https://www.infoq.cn/article/40q0yogaX2i13pOKQQar",
    "summary": "<p>在当今时代，人工智能技术正以前所未有的速度迅猛发展，企业落地人工智能应用已成为不可逆转的趋势。然而，这一过程中也伴随着诸多挑战和问题。如何助力企业加速人工智能的落地进程，如何最大限度地提升 IT 系统的资源利用率，以及如何有效增强计算效能，并便捷、稳定地部署应用 AI，都已成为整个行业关注的焦点。</p><p></p><p>8 月 18 日至 8 月 19 日，在上海举办的 AICon 2024 全球人工智能开发与应用大会上，诸多讨论都聚焦于这些问题。其中的 Intel AI Summit 「AI 全栈解决方案及行业实践」专场，来自英特尔及其合作伙伴的四位行业专家就 AI 应用落地的全栈解决方案，以及医疗领域的应用案例进行了深入探讨。</p><p></p><p></p><h2>激发 AI 潜能：xFT 助力算力解锁，最大化提升计算效能</h2><p></p><p></p><p>尽管“AI 赋能”具有巨大吸引力，但在资源有限的条件下，企业必须确保每一项投入都能获得最大化的效益，这对应用落地的成本和利用率提出了严格的要求。特别是在计算效能提升方面，需要硬件、软件、算法等多个层面的协同优化。高效的计算能力能够加速数据处理、模型训练和推理速度，使企业更迅速地做出明智决策，推出创新产品和服务。</p><p></p><p>为了解决算力对 AI 落地的限制，英特尔一直走在行业前列，力求为企业推出实用可靠的计算资源方案，通过技术优化最大化提升算力，推动大模型应用的落地，充分释放 AI 潜能。在本次会议上，英特尔数据中心和 AI 事业部首席工程师何普江带来了主题为《xFT 解锁至强算力，释放 AI 潜能》的演讲。</p><p></p><p>何普江认为，AI 的未来将由算力的突破来定义，而第五代英特尔®️&nbsp;至强®️&nbsp;可扩展处理器及其内置的英特尔®️&nbsp;AMX 技术正是这一突破的关键。英特尔®️ AMX 通过深度优化矩阵运算，为算力释放提供了坚实的硬件基础。</p><p></p><p>在演讲中，何普江分享了 xFT（xFasterTransformer）技术的设计理念：这是一个专为 AMX 优化的开源项目，不仅支持广泛的 AI 模型和数据类型，更通过软硬件的深度融合，显著加速了 AI 大模型推理。何普江也在分享中提到，与传统方法相比，目前通过 xFT 技术，可以在第五代处理器上面用 48 核跑出高达 1300 的 CRGPU 吞吐量，这一数字远超行业标准，在处理大规模数据集和复杂运算时表现出色。</p><p></p><p>在算法层面，何普江深入分享了 xFT 技术的多项创新，包括对 oneDNN 库的优化使用，以及针对不同 token size 优化的 Slim attention 机制。这些创新不仅提升了 xFT 技术的性能，也为 AI 社区提供了宝贵的实践经验。</p><p></p><p>探讨大模型与小模型的未来发展时，何普江指出，两者各有优势，将共同推动 AI 技术进步。他强调了多模态和 RAG 技术的重要性，并预测开源与闭源模型间差距将缩小。何普江还提到了 KV Cache 的关键作用，以及它对未来 AI 系统设计的影响。</p><p></p><p>他认为，随着硬件和软件的不断进步，大语言模型的成本将大幅降低，推动 AI 技术的更广泛应用和深入发展。开源与闭源模型间的差距正在缩小，未来开源模型将在 AI 领域扮演更加重要的角色。</p><p></p><p></p><h2>GenAI 开放平台 OPEA：一站式助力大模型应用，企业 AI 落地加速器？</h2><p></p><p></p><p>除了底层算力效能提升之外，在目前企业的 AI 应用实践中，还存在着训推优化、基础设施扩展、数据传输安全、应用碎片化等诸多环节。企业需要一个能够全栈助力落地 AI 应用的方案与平台，一站式解决生成式 AI 的落地问题，在性能优化、可扩展性、安全等角度为企业保驾护航。</p><p></p><p>在本次会议上，英特尔 AI 首席工程师吴震华围绕 OPEA 开放平台进行了分享。作为人工智能建模、特征工程、效果分析以及推荐增强等领域的资深专家，他在演讲《基于检索增强的企业 GenAI 开放平台落地实践》中详细梳理了 AI 技术的发展历程，并深入解析了英特尔企业 GenAI 开放平台（OPEA）的架构与底层技术。</p><p></p><p>吴震华认为，尽管基于检索增强的 RAG 技术并非新生事物，但其在企业中的应用潜力正随着大语言模型的能力而日益凸显。在吴震华看来，企业 AI 落地面临的挑战与机遇并存，特别是在生成式 AI 技术，如 ChatGPT 引爆市场之后，行业关注的焦点已从模型预训练的竞争转向了具体的应用落地。</p><p></p><p>OPEA 开放平台是一个由英特尔推动、捐赠给 Linux 基金会的开源项目。OPEA 旨在构建一个开放的生态系统，使企业能够快速利用大语言模型和 AI 技术带来的创新优势。吴震华详细介绍了 OPEA 的全栈架构，从基础设施层到平台集成层，再到面向用户的服务层，展示了一个多层次、模块化的 AI 应用平台。</p><p></p><p>展望未来，吴震华预计到 2028 年，80% 以上的商用 PC 将被新形态的 AIPC 所替代。他将企业 AI 应用的发展分为三个阶段：今天，AI 助手如 CO-Pilot 和 RAG 正在提升数据检索和编程流程的效率；明天，智能体将拥有更大的自主权，利用 AI 的推理能力完成特定任务；未来，AI 将深入企业流程的每个环节，优化每个生产要素。</p><p></p><p>吴震华还提出了企业 AI 应用的四个关键方向：易用性、开放性、安全性、负责任的使用，以及平台的可扩展性和参考实践的提供。他希望通过这些方向的努力，使企业 AI 快速享受到生成式 AI 革命的技术成果。</p><p></p><p>在演讲的最后，吴震华通过一个应用 demo 展示了低代码的基于至强®️&nbsp;微服务实现生成 AI 服务功能，他期待通过不断的迭代和更新，OPEA 能够推动企业 AI 方案的发展，方便快速地帮助企业用户解决实际的问题，让企业真正享受到生成式 AI 技术带来的红利。</p><p></p><p></p><h2>AI+ 医疗：大模型在病历质控中的应用实践</h2><p></p><p></p><p>生成式 AI、大模型技术正在为各行各业带来革命性的变化，医疗领域也不例外。在医院、健康机构等场景下，AI 辅助诊疗、病历质控等应用将成为未来技术趋势。惠每科技致力于通过人工智能解决方案提升医疗质量，守卫患者安全，在智能化诊疗、病历质控等技术领域不断创新大模型技术应用，推动医疗行业的数智化发展。在 Intel AI Summit 专场上，惠每科技算法专家凌鸿顺以《破解病历质控难题：医疗大模型质控优化策略》为主题，分享了惠每科技在病历质控领域的成功实践。</p><p></p><p>病历质控作为医疗质量评估的核心，直接影响医疗服务水平和患者安全。面对病历书写的及时性、规范性和完整性问题，惠每科技采用了大模型技术，利用其强大的文本理解和知识推理能力，有效提升了病历质控的效率和准确性。大模型基于 Transformer 架构，通过持续预训练和任务对齐，以及直接偏好优化，显著提高了对病历中关键信息的提取和分析能力。</p><p></p><p>凌鸿顺还提到，在模型训练优化方面，惠每科技采取了基座模型优化和大模型 prompt 工程优化的策略。通过知识注入、指令跟随和直接偏好学习，模型能够更好地理解和执行医疗领域特定的任务。特别是在处理病历中的矛盾和不规范问题时，大模型展现了其跨字段理解和医疗知识对比的优势。</p><p></p><p>惠每科技还制定了自动化 Few-shot 示例的方案，通过初始化阶段的 badcase 识别和迭代优化，以及相似度计算和多样性 prompt 的加入，进一步提升了模型的预测效果和泛化能力。这一策略不仅减轻了筛选 Few-shot prompt 的工作量，也为不同医院的特殊 case 提供了快速修复的可能。</p><p></p><p>凌鸿顺还提到，在大模型部署推理的实践中，惠每科技与英特尔的合作成果显著。通过xFasterTransformer、BigDL 量化方案和&nbsp;OpenVINO™️&nbsp;非量化方案，实现了医疗模型私有化部署的优化，解决了大模型在硬件资源和计算效率上的挑战。特别是英特尔®️&nbsp;AMX 技术的应用，为大模型的推理性能带来了质的飞跃。</p><p></p><p>展望未来，凌鸿顺对医疗大模型的应用持乐观态度。模型蒸馏技术有望将大模型的效果转移到更小、更易于部署的模型上。自动化 Few-shot 的进一步优化，将实现更高效、更准确的病历质控。同时，惠每科技也将与英特尔展开持续合作，进一步推动医疗 AI 技术的创新和应用，为医疗行业带来更多的价值和可能性。</p><p></p><p></p><h2>医疗 AI 革新：大模型技术深度融合与应用实践</h2><p></p><p></p><p>人工智能技术的发展对医疗行业的信息化升级和数智化变革具有重大意义。以国内医疗场景为例，大量专业化数据和对信息化处理的精准度要求极高，这些都是信息化过程中需要解决的实际问题。垂直领域的大语言模型将成为新一代医疗信息化系统的有力助手，帮助解决医疗系统中的诸多问题。然而，如何让医疗大模型真正可用、易用，仍需解决模型构建、集成、系统结合和应用设计的一系列问题。</p><p></p><p>在 Intel AI Summit 专场上，卫宁健康研发总监刘鸣谦带来了题为《大语言模型在医疗场景的落地实践》的分享，深入探讨了大模型技术如何深刻影响医疗信息化的发展和临床应用。</p><p></p><p>刘鸣谦首先回顾了医疗系统的发展历程，从早期的专家系统、本体推理到现代基于 AI 的图像辅助诊断和自然语言处理。她认为，自 OpenAI GPT3.5 发布以来，基于 Transformer 的大模型已成为医疗领域开发和应用的新范式。大模型的文本生成能力、推理能力和交互能力，为医疗领域带来了前所未有的创新潜力。</p><p></p><p>在数据工程方面，刘鸣谦分享了卫宁健康如何通过高质量的数据集和场景化处理来优化大模型的训练效果。通过上下文学习、RAG（Retrieval-Augmented Generation）和 Agent 方式，进一步提升了模型的效果和适应性。此外，通过直接偏好优化（DPO）和提示工程，模型在医疗场景中的适用性得到了显著提升。</p><p></p><p>卫宁健康的大模型训练采用了多轮迭代，结合了开源数据和自身积累的医疗知识，形成了强大的模型能力。刘鸣谦提到，卫宁健康开源了多款垂直领域大模型，以促进社区的交流和发展，并与英特尔合作，优化了基于英特尔®️&nbsp;AMX 技术的本地化部署方案，有效降低了成本同时保证了高性能。</p><p></p><p>卫宁团队开发的 Copilot，作为信息化系统和 AI 模型之间的桥梁，通过 API 插件等多种形式，实现了不同应用场景下的模型管理和服务。Copilot 的应用，使得医务人员能够无缝地体验到 AI 带来的便利。</p><p></p><p>在医疗应用场景方面，刘鸣谦详细介绍了大模型在医技、临床和管理场景下的实际应用案例。例如，在影像科中，大模型辅助医生快速生成报告，提高了工作效率；在超声科中，实现了实时报告质控，提升了医疗质量；在临床辅助诊断中，通过增强型 CDSS 系统，提供了更加精准的辅助决策支持。</p><p></p><p>此外，大模型还在病历文书助手和智能语言查房助手中发挥了重要作用，通过语音识别和自然语言处理技术，实现了医生口述内容的自动结构化输出，极大地提高了医生的工作效率。</p><p></p><p></p><h2>AI 企业落地，从概念走向现实</h2><p></p><p></p><p>随着人工智能技术的不断成熟和创新，其在企业中的应用已不再是遥远的梦想，而是触手可及的现实。英特尔 AI 全栈解决方案的提出和实践，为企业智能化转型提供了一个清晰的路径：从底层硬件的优化到顶层应用的创新，从单一技术的突破到全栈生态的构建，每一步需要关注企业实实在在的效益，才能让 AI 发挥出真正的价值。</p><p></p><p>未来，随着技术的进一步发展和应用的不断深入，AI 必将成为推动企业创新和增长的关键力量，开启一个全新的智能化时代。让我们拭目以待，共同见证 AI 技术如何助力企业实现跨越式发展，引领行业变革。</p>",
    "publish_time": "2024-08-29 11:16:31",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]