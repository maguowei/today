[
  {
    "title": "操作系统的下一次跨越式发展将是量子计算｜独家专访SUSE首席技术与产品官Thomas",
    "url": "https://www.infoq.cn/article/HmppHMJseJVj7sZkR7Te",
    "summary": "<p></p><blockquote>采访嘉宾 | Thomas Di Giacomo 博士作者 | 凌敏</blockquote><p></p><p>&nbsp;</p><p>1946 年 2 月，在美国费城，自动计算机 ENIAC 面世，现代计算机的序幕也由此拉开。彼时，还未出现操作系统，用户直接与计算机硬件打交道。20 世纪 50 年代，第二代计算机出现了早期的单道批处理系统。此后，陆续出现了多道批处理系统、分时操作系统和实时操作系统，而分时操作系统也最终演变成更为人熟知的 Unix 操作系统。</p><p>&nbsp;</p><p>1991 年，Linus Torvalds 为尝试在英特尔 x86 架构上提供自由的类 Unix 操作系统，开发出了 Linux 内核，并开放源代码。此后，涌现出了一批基于 Linux 内核的 Linux 发行版，如 SUSE Linux、Ubuntu Linux、Red Hat Linux 等。2007 年，谷歌更是基于 Linux 内核发布了 Android 操作系统。</p><p>&nbsp;</p><p>31 年后的今天，Linux 无处不在。在企业中，无论是云部署、Web 基础设施，还是企业业务后端服务，都有 Linux 的身影。</p><p>&nbsp;</p><p>近日，InfoQ 有幸对全球开源软件巨头 <a href=\"https://www.suse.com/\">SUSE</a>\" 首席技术与产品官 Thomas Di Giacomo 博士进行了专访，围绕操作系统的持续演进、Linux 发展、开源、SUSE 的实践经验与产品技术战略等话题，Thomas Di Giacomo 博士分享了自己的洞察与见解。</p><p>&nbsp;</p><p>SUSE 是企业级开源解决方案领导者，公司创立于 1992 年，专注于企业级 Linux、Kubernetes 管理平台和边缘解决方案。2021 年，SUSE 在法兰克福证券交易所的监管市场（Prime Standard）上市。&nbsp;</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/65/3d/6513d582694344be4702bdbb7f90653d.jpg\" /></p><p></p><h2>持续演进的操作系统</h2><p></p><p>&nbsp;</p><p>在整个软件生态中，操作系统起到了重要的承上启下作用，是计算机系统的核心与基石。</p><p>&nbsp;</p><p>不过，由于操作系统长期处于底层，用户对于操作系统的发展变化感知得不如应用软件那样明显。但实际上，即便是已经十分成熟的操作系统，也仍在持续迭代和演进。</p><p>&nbsp;</p><p>在学术界，有一种观点认为，操作系统每过二十年左右会出现一次跨越式发展机遇。如果从上世纪六十年代出现真正具有现代意义的操作系统算起，操作系统已然经历了三个时代的发展。从大型机/主机时代到个人计算机时代，再到互联网时代，操作系统不断向前演进。</p><p>&nbsp;</p><p>近几年，操作系统领域也涌现出了很多值得关注的技术趋势，如容器化操作系统、基础镜像、实时补丁等等。“我认为，最近几年，操作系统领域出现的最超乎预期的技术趋势是实时补丁，因为它已经相当成熟而且在内核层面得到了一段时间的实际应用。现在，实时补丁开始进入用户领域，有望在未来进一步为提高灵活性、保障安全性贡献力量。”Thomas 对 InfoQ 说道。</p><p>&nbsp;</p><p>在 Thomas 看来，操作系统的整个演进历程出现了关注重点的转移以及关注维度的变化。例如，从上世纪六十年代，物理系统与虚拟机间的二元区分塑造出新的维度，到上世纪八十年代出现的集中化（主机、云）与独立计算，再到现在的边缘计算，以及随着网络的兴起，功能性、安全性和易用性各自开辟出了自己的维度。</p><p>&nbsp;</p><p>“现在，我们正处在易用性发展的高峰，客户要求在保障业务安全运营的同时，立足任意位置——本地、云端、边缘——开展创新，这就是将易用性和安全性结合起来。容器技术的普及体现的就是各行业对于易用性的明确要求，但付出的却往往是安全的代价。我们希望集 SUSE Linux Enterprise、SUSE Rancher 企业级 Kubernetes 管理平台、SUSE NeuVector 容器安全平台乃至未来的边缘解决方案之力，可以攻克这道难关。”Thomas 说道。</p><p>&nbsp;</p><p>至于操作系统的下一次跨越式发展将走向何方，Thomas 认为很可能是量子计算。量子计算是一种不同于经典计算的革命性计算技术。相比经典计算机，量子计算机具备强大的算力，并需要专门的操作系统对其进行调配和管理。</p><p>&nbsp;</p><p>目前，量子计算机操作系统还处于发展初期阶段，全球数量屈指可数。随着操作系统的持续演进，未来的操作系统也许还会为 IT 领域带来新的惊喜。</p><p></p><h2>无处不在的 Linux 与开源</h2><p></p><p></p><h4>“Linux 可以说是整个 IT 领域中最大、最成功的案例之一”</h4><p></p><p>&nbsp;</p><p>回顾操作系统的整个发展历程，半个多世纪来涌现出了大量成熟的操作系统，并覆盖在人们生活的方方面面。在手机操作系统领域，Android、iOS 龙头地位稳固；在桌面操作系统领域，Windows 多年保持近乎垄断的地位；在服务器操作系统领域，Linux 常年占据主流地位。</p><p>&nbsp;</p><p>“Linux 可以说是整个 IT 领域中最大、最成功的案例之一。”Thomas 如此评价道。</p><p>&nbsp;</p><p>在其看来，Linux 从早期的纯“业务爱好”起步，如今已经成为云和边缘环境下的首选标准兼终极驱动力。追根溯源，Kubernetes 同样是以 Linux 为基础。Linux 不仅彻底改变了企业计算，同时也改变了整个开发模式。目前，全球开源社区正持续为各类不同项目做出贡献，帮助解决人类面临的种种紧迫问题。</p><p>&nbsp;</p><p>在 Linux 的发展和应用历程中，各种 Linux 发行版起到了极大的促进作用。</p><p>&nbsp;</p><p>早期，Linux 只是 Linus Torvalds 出于业余爱好开发的一款操作系统，主要依靠“早期使用者”进行传播，影响范围主要集中在高校，很少触及关键业务用例。1992 年，市场上陆续出现了各种商业 Linux 发行版。</p><p>&nbsp;</p><p>“从这里开始，Linux 逐渐成为 IT 世界中的一位重要成员，HP、IBM、SGI、AMD 和英特尔等厂商也发现了 Linux 的潜力并参与进来。因此，Linux 很快开始全面取代经典的 Unix 系统，新的用例也在快速增加。”Thomas 介绍道。</p><p>&nbsp;</p><p>此前曾有数据显示，Linux 在超过 20 亿的设备上运行。世界上几乎所有的主要网站，包括谷歌、Facebook 以及维基百科，都运行在 Linux 之上。云也是一样，即使是在微软自己的 Azure 当中，最受欢迎的操作系统仍然是 Linux。全球五百强超级计算机大多数采用的也是 Linux。另外，得益于 Android 不俗的市场表现，Linux 还成为最受欢迎的终端用户操作系统。</p><p>&nbsp;</p><p>“在如今这个云和容器的时代，Linux 与开源早已无处不在，从地球上最强大的超算到太空中的卫星都有它的身影。”Thomas 说道。</p><p>&nbsp;</p><p>31 岁的 Linux 仍在持续演进，从技术层面上来看，Linux 要想再进一步发展，Thomas 认为需要解决通用性和在特定用例上实现最优效果这两种需求。</p><p>&nbsp;</p><p>“其实保证通用性和在特定用例上实现最优效果，这两者本身就有一定矛盾。但这种矛盾是健康合理的，随着容器化应用程序的兴起，Linux 必须想办法支持并实现这两种需求。</p><p>&nbsp;</p><p>大家不妨带着这个念头继续关注 SUSE，我们正在开发一款 Linux 操作系统，它将具备高易用性，提供零接触、自管理式运营，并能实现系统核心的自我调整与优化。默认情况下，这款按需操作系统将带来出色的自动化水平，借 DevOps、DevSecOps 和 GitOps 之力将生产效率提升至最高点。我们正在为这个目标而努力，包括云优先、边缘优先，同时针对数据中心进行优化，确保新系统能够随处使用并继续延续目前的 SLE Micro 小型核心。”</p><p></p><h4>拥抱开源，走向更远</h4><p></p><p>&nbsp;</p><p>Linux 之所以经久不衰，与其长期贯彻的开源理念密不可分。依托开源特性，越来越多的公司及个人开发者参与到 Linux 的构建中。最终，Linux 用 10 年名扬天下，20 年统治服务器领域。</p><p>&nbsp;</p><p>作为第一家企业 Linux 发行版供应商，SUSE 也是开源理念的践行者，同时也是全球最大的独立开源公司。</p><p>&nbsp;</p><p>在 Thomas 看来，开源始于开放、终于协作，二者彼此影响、互为始终。</p><p>&nbsp;</p><p>“开源要求我们立足全球社区无边界地共享知识，与合作伙伴共同创新。开放一直是 SUSE 的指导原则，我们也希望自己的解决方案能够尽可能开放、提供更好的互操作性和安全性，这样客户才能安心在内部堆栈中随意运行 SUSE 产品，而非被牢牢锁定在号称‘开源’、实则封闭的单一供应商身上。”</p><p>&nbsp;</p><p>开源不易，开源的商业化成功更是难上加难。如何才能站在开源的肩膀上，走向更远？刚迎来 30 周岁生日的 SUSE 蹚出了自己的一条开源成功路。</p><p>&nbsp;</p><p>同开源社区及合作伙伴携手并进</p><p>&nbsp;</p><p>Thomas 认为，SUSE 能走这么远的关键在于公司在立项之初，就专注于同开源社区及各位合作伙伴携手并进。“在 SUSE 的诸多成就当中，最亮眼的就是建立起业内独一无二的合作伙伴生态系统。”</p><p>&nbsp;</p><p>在 Linux 刚刚起步的 1999 年，SUSE 就已经在与 IBM、甲骨文和 SAP 合作，发布了第一款 Enterprise Linux——SUSE Linux Enterprise Server（用于 IBM S/390）。此外还有其他重要合作伙伴，包括英特尔、AMD、HP(E) 以及富士通。</p><p>&nbsp;</p><p>关注社区中每个参与者的声音</p><p>&nbsp;</p><p>开源是一个“多对多”的世界，有多个角色参与进来，也就意味着你要面对多个角色，处理不同的声音。</p><p>&nbsp;</p><p>“社区永远不是唯一的。我们面对的是多个社区，包括开源社区、客户社区以及合作伙伴社区。但与此同时，这些社区之间又彼此重叠，比如我们和合作伙伴就往往属于同一个开源社区。”</p><p>&nbsp;</p><p>Thomas 表示，问题的关键不在于是否跟合作伙伴意见统一，而是要意识到社区中的每个参与者都有意见、都值得关注，这样才能出于项目繁荣和大多数成员的利益做出最好的社区决策。“SUSE 重视社区独立性，我们也需要立足各个层面为社区做出贡献，这里包括业务层面、社群层面和文化层面，当然也涉及技术层面。”</p><p>&nbsp;</p><p>安全是重中之重</p><p>&nbsp;</p><p>随着越来越多的开源软件在千行百业中得到广泛应用，安全问题日益凸显，供应链安全攻击和容器安全威胁问题日益严峻。而在基础软件领域，安全更是无法避开的话题，并成为决定企业市场命运的重中之重。</p><p>&nbsp;</p><p>“开源的下一阶段发展趋势一定与安全有关”，Thomas 认为，客户将专注于在基础设施的各个层面（本地、云端和边缘）实施严格的安全准则和保护方案。不关注安全，就无法继续讨论数字商业模式。而自动化机制的引入将成为灵活性保障，以全面覆盖的方式为关键业务 Linux、容器管理乃至边缘解决方案提供无处不在的基础设施安全保护。</p><p>&nbsp;</p><p>数据显示，预计到 2025 年，全球联网设备将多达 750 亿台，其中大多数为微型边缘设备或工业物联网装置。</p><p>&nbsp;</p><p>Thomas 认为，尽管不少企业已经开始探索边缘创新，但大量设备的入网必然会带来更广泛的攻击面。无论是在数据中心、云端还是边缘，这种潜在攻击威胁的增加将迫使企业重新评估、进而加强自身基础设施的安全水平。</p><p>&nbsp;</p><p>此外，2021 年末的 Apache Log4j2 安全漏洞事件也让大家意识到了开源软件供应链治理的重要性。要想建立起安全可靠的弹性系统，最重要的就是将零信任安全控制引入到供应链的全生命周期和运行时应用当中。</p><p>&nbsp;</p><p>在安全方面，SUSE 的经验是：保护基础、保护产品、保护供应链。</p><p>&nbsp;</p><p>“长期以来，我们一直使用 FIPS 认证加密，同时将 DISA STIG 强化指南作为最佳实践与行为准则，确保客户一次点击即可完成系统安全强化。”Thomas 说道。</p><p>&nbsp;</p><p>对于企业而言，如何建立起多层保护，防止安全事件发生，SUSE 的实践经验是在管道和容器 repo 中建立起自动化安全扫描机制，强化容器平台。使用准入控制规则保护部署与生产环境，深入剖析运行中的容器、特别是其网络通信行为，对 L7 层上的容器工作负载进行自动拆分，并通过安全策略锁定、限制并验证容器活动是否合法，同时对实时环境开展持续合规审计。</p><p></p><h2>SUSE 的实践经验与产品技术战略</h2><p></p><p>&nbsp;</p><p>在采访中，Thomas 还分享了 SUSE 的实践经验、产品战略与技术创新。</p><p>&nbsp;</p><p>当前，SUSE 专注于企业级 Linux、Kubernetes 管理平台和边缘解决方案，目标是帮助客户随处开展业务创新。</p><p>&nbsp;</p><p>“要达成这个目标，首先要建立起一套能够随处运作的系统平台——它必须基于通用代码库且采取模块化设计，保证可以在整个 IT 资产（核心、云乃至边缘）范围内稳定一致地运行。”</p><p>&nbsp;</p><p>Thomas 表示，众多用例的运行基础依靠的都是同一套 SUSE Linux Enterprise 通用代码库——这套代码库高度模块化、可扩展且极为灵活，其复杂性不会随使用量的增加而等比上升。所有以“SUSE Linux Enterprise”命名的产品都基于同一套通用代码库，它们的代码是相同的，甚至不同硬件架构中都有大量相同的源代码。</p><p>&nbsp;</p><p>另外，SUSE 还开发了其他一些工具，帮助团队创建、测试并维护这些代码。这些代码不仅能够跨越多种硬件架构和部署路径，同时也能长期维持稳定有效。</p><p>&nbsp;</p><p>以 Open Build Service（OBS，<a href=\"https://openbuildservice.org/\">https://openbuildservice.org/</a>\"）为例，这是一套通用系统，能够以自动、一致且可重复的方式通过源代码构建并分发二进制软件包。如此一来，每个人都能面向不同操作系统和硬件架构发布相应的软件包、更新、附加组件、功能乃至整个发行版。此外，还有一款重要工具是 OpenQA (<a href=\"https://open.qa/\">https://open.qa/</a>\")，能够自动测试各类操作系统。</p><p>&nbsp;</p><p>值得一提的是，这些工具都是开源的，也被越来越多的公司用于改进自己的流程和软件成果。</p><p>&nbsp;</p><p>“我们也一直在利用这些工具、功能（例如可重复 Builds）和流程，建立并强化 SUSE Linux Enterprise 的供应链安全。这一基本理念不仅让我们的开发和支持工作变得更简单，也把同样简单高效的开发与运营优势带给了我们的客户。”Thomas 说道。</p><p>&nbsp;</p><p>全球迎来后疫情时代，企业正在迅速转向数字化、始终在线的新型商业模式。为了满足下一代客户的期望、从容应对竞争威胁，IT 团队必须想办法解决由现代化架构、基础设施和应用程序带来的现实挑战。</p><p>&nbsp;</p><p>Thomas 表示，SUSE 的产品战略是简化、统一、安全的分布式企业 IT 运营，而这一切首先得从跨核心、跨云和跨边缘位置的一致操作系统入手。“我们既要加快企业客户进军云原生征程的脚步，又不能破坏原本的关键业务应用程序”。</p><p>&nbsp;</p><p>产品布局方面，SUSE 近两年动作不断。2020 年 12 月，SUSE 完成了对Kubernetes 管理领域市场领导者 Rancher Labs 的收购。</p><p>&nbsp;</p><p>目前，SUSE Rancher 提供的单一平台能够托管容器化应用程序、并管理任何规模的各类 Kubernetes 发行版，完全不受具体服务商或运行位置的影响。这样的单一平台既能简化开发者和运营人员的工作，也有助于缓和全球范围内愈发严峻的 IT 技能与人才短缺挑战。</p><p>&nbsp;</p><p>2021 年 10 月，SUSE 完成了对全生命周期容器安全领域企业 NeuVector 的收购。2022 年 1 月，SUSE 宣布 NeuVector 代码库已在 GitHub 上开放。5 月，SUSE 发布了NeuVector 5.0，并集成到 SUSE Rancher 2.6.5 中。</p><p>&nbsp;</p><p>NeuVector 5.0 在 Rancher 的多集群管理中增加了多集群安全管理，可以通过 Rancher Apps 和 Marketplace 部署，像 Rancher 管理的其他工作负载一样进行监控和管理；并且提供单点登录体验，Rancher 管理员可以直接从 Rancher UI 访问 NeuVector 控制台，无需单独登录。</p><p>&nbsp;</p><p>在今年 6 月 7 日举办的 SUSECON Digital 2022 大会上，包括 Thomas 在内的众多高管、技术专家分享了 SUSE 关键业务 Linux、企业容器管理和边缘解决方案的最新技术实践。</p><p>&nbsp;</p><p>在关键业务 Linux 方面，SUSE 发布了 SUSE Linux Enterprise 15 Service Pack 4（SLE 15 SP4）。据悉，SLE 15 SP4 实现了 Google SLSA 4 供应链合规性，增加了对 AMD 安全加密虚拟化加密状态（SEV-ES）的支持，使用了开源的英伟达 GPU 内核驱动程序，并为 SLES for SAP Applications 引入了 Trento 这一新功能。</p><p>&nbsp;</p><p>Thomas 在接受采访时表示，SLE 15 SP4 增加 SLS 4 级合规供应链，有助于防止日益蔓延的软件安全与供应链威胁。“我们还为机密计算设定了新标准，借此改变云端数据保护方法。通过云端机密计算，SUSE、AMD 和 Google Cloud 将帮助客户安全处理数据、加快迁移速度，并确保云工作负载免受远程攻击、权限提升及恶意内部攻击。我们还与英伟达合作，希望简化面向云原生和边缘场景的负载扩展过程，同时提高性能和可用性。”</p><p>&nbsp;</p><p>随着 SUSE Linux Enterprise、SUSE Manager、Rancher 以及 NeuVector 等产品的不断革新，下一步，SUSE 计划利用新型开源云原生解决方案增强企业安全。</p><p></p><h2>“开源没有边界”</h2><p></p><p>&nbsp;</p><p>InfoQ：您在 IT 行业拥有超过 20 年的经验，在您的职业生涯中，遇到过最大的挑战是什么？</p><p>&nbsp;</p><p>Thomas：不管是什么样的 IT 技术挑战，都有办法、甚至总有很多办法来解决。我觉得最大的挑战在于，怎么立足流程、业务和心态做出重大变革，再跟团队和其他人员共同把这些变革理论转化成现实。</p><p>&nbsp;</p><p>InfoQ：操作系统学习曲线陡峭，很多年轻人可能学着学着就放弃了，您能给这些年轻人提供一些学习经验或建议吗？</p><p>&nbsp;</p><p>Thomas：在开源世界，回馈是很重要的一环。回馈贡献的方式有很多种，不一定非要编写代码，也可以是撰写说明文档、上报测试发现、提交设计思路和参与社区支持等等。</p><p>&nbsp;</p><p>但我认为，最好能多花时间观察和倾听特定社群与项目的动态、关注观点趋势。可以多接触一些社区成员，通过讨论理解项目的动向和机制，这些都是不错的办法。</p><p>&nbsp;</p><p>InfoQ：在中国也有很多操作系统厂商，对于这些公司的管理者和开发者，您会给他们哪些建议？</p><p>&nbsp;</p><p>Thomas：多年以来，中国开发者一直在为开源项目做出巨大且卓越的贡献！实际上，开源的一大优势就是没有边界的束缚，可以让世界上的每一个人都参与到贡献和创新中来。总之一句话，大家多团结、多交流，一起研究技术就对了！</p><p>&nbsp;</p><p>受访嘉宾：</p><p>&nbsp;</p><p>Thomas Di Giacomo 博士是 SUSE 的首席技术和产品官，负责领导 SUSE 全球首席技术官办公室以及产品和解决方案团队。他的团队涵盖了 SUSE 的整个产品组合，驱动着未来创新。他还负责指导和推动 SUSE 当前和未来的技术革新和解决方案发展，并与客户、合作伙伴以及其他相关人员分享 SUSE 的愿景。在此之前，Thomas 曾担任 SUSE 的工程与创新总裁。他在 IT 行业拥有超过 20 年的经验，曾在工程和产品创新领域担任过各种全球领导和执行职务。Thomas 毕业于日内瓦大学计算机科学专业，拥有博士学位。</p>",
    "publish_time": "2022-07-05 09:26:09",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "开发容器：可重用的开发环境",
    "url": "https://www.infoq.cn/article/U3uzsa3z03t92JB8p0iv",
    "summary": "<p></p><h2>拿着Chromebook在洗车房做开发</h2><p></p><p>&nbsp;</p><p>那天，我把车开到了洗车场。这是一个高级洗车场，你把车交给工作人员，然后等着他们把车里里外外清洗干净。</p><p>&nbsp;</p><p>我要做的就是打发时间了。我还有一些代码要写，但当时我只有一台装在包里的小Chromebook和WiFi连接。</p><p>&nbsp;</p><p>于是，我在<a href=\"https://github.com/features/codespaces\">GitHub Codespaces</a>\"中打开了这个项目，然后在上次停下的地方继续，在云端运行我的开发环境。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/06/06b7b9a2d866a529bb1b84dbdd9f9ed4.png\" /></p><p></p><p>&nbsp;</p><p>不只是编辑器，而是整个为我的项目定制的虚拟机。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/8d/8dcc4519027397e00bd00de901288d15.png\" /></p><p></p><p>&nbsp;</p><p>我继续开发我的项目。在一台新的（云）机器上配置开发环境所花费的时间：可能只有5分钟。</p><p>&nbsp;</p><p>现在的CodeSpaces太酷了，但本文实际上不是关于它们，甚至不是关于基于云的开发环境。本文将介绍一些技术和实践，让开发人员能够在几秒钟或几分钟内从零开始完成整个项目定制开发环境，例如：</p><p>&nbsp;</p><p>在新员工第一天上班的笔记本电脑上；在第二台旅行用的笔记本电脑上；在一个设计师的工作站上，他需要在不熟悉后端技术栈的情况下，尝试在本地跨多个内部代码库做出视觉变更；在一个顾问的笔记本电脑上，同时托管着十几个不相关的代码库；或者是托管在云端的共享实例中。</p><p>&nbsp;</p><p>如果项目的初始设置从一个小小的挑战变成一件轻松自如的事会怎样？如果你可以将开发环境与代码一起打包会怎样？如果你可以在团队中将开发环境标准化，让每一个人都能从中受益，会怎样？如果因为在开发人员的笔记本电脑上项目构建失败而导致的摩擦已经成为过去，会怎样？</p><p>&nbsp;</p><p>如果你在洗车时感到无聊，顺便写几行代码呢？</p><p>&nbsp;</p><p>这就是开发者体验的未来，而你现在就可以开始感受。实现这一体验的方式就是使用容器进行开发，这些容器有时也被称为开发容器。</p><p></p><h2>什么是开发容器</h2><p></p><p>&nbsp;</p><p>当我们说到“容器”，通常指的是使用Docker运行的容器。这也意味着项目可以在Linux环境中。当今的大多数Web应用程序开发都是这样的。但如果你的项目目标是iOS，或Windows桌面，或其他非Unix平台，那么下面的内容可能不太适用于你的项目。</p><p>&nbsp;</p><p>这不是一篇介绍Docker的文章。由于篇幅的原因，我将假设你对容器化有一定的了解。</p><p>&nbsp;</p><p>不过，我们还是有必要简单地讨论一下为什么容器比一些老旧的虚拟化技术（如Parallels、VirtualBox或Vagrant）更适合作为开发环境。</p><p>&nbsp;</p><p>简单地说，这是因为容器并不是虚拟化。是的，容器为我们提供了一种看起来像是运行在电脑上的微型电脑的东西。但容器并没有试图模拟计算机，而是通过创建一组独立的命名空间来发挥作用，包括文件系统命名空间、网络端口、进程表和运行操作系统所需的其他命名空间。</p><p>&nbsp;</p><p>与虚拟化不同，容器有可能按照原生的速度运行项目代码和工具，而不会让开发机器瘫痪。因为宿主操作系统可以将文件映射到容器命名空间，所以我们可以在容器运行代码的同时使用原生工具编辑源代码。</p><p>&nbsp;</p><p>另外，与大多数虚拟化技术不同的是，容器并不是不透明的二进制镜像。我们使用人类可读的配置文件来决定开发容器将包含哪些Linux版本、系统包和库、实用程序、文件系统映射、开放端口和支持服务，而且这些配置文件与项目的源代码一起进行版本控制。</p><p>&nbsp;</p><p>实际上，开发容器是一种功能齐全的开发环境，它可以被共享、进行版本控制、可重复使用、自文档化，并且只要在使用中，它就是最新的。开发容器就像拉面：只要加入热水就可以吃了。</p><p>&nbsp;</p><p>本文也不是教程。构建一个完整的开发容器是一个持续迭代的过程，取决于具体的项目。相反，我将向读者介绍什么是开发容器、开发容器的使用，以及借助开发容器为团队构建可重用的开发环境是一种怎样的体验。</p><p></p><h2>体验开发容器</h2><p></p><p>&nbsp;</p><p>为什么说容器是开发环境的未来？让我们来看一些可以体现开发容器优势的例子。</p><p></p><h4>快速上手</h4><p></p><p>&nbsp;</p><p>最近，我加入了一个为期6个月的客户项目。像大多数开发大型旧项目的团队一样，他们在README和Wiki页上有一系列冗长的初始设置说明和脚本。和往常一样，部分指南的内容要么过时，要么自相矛盾。设置脚本的前提是它们要运行在一台特定时期推出的MacBook上，需要安装特定版本的MacOS，并且这台笔记本将专门用于这个项目的开发。</p><p>&nbsp;</p><p>这种令人困惑的、冗长的、过时的初始设置是我见过的大多数团队的常态。在加入项目的第一周，如果你能够运行项目的一部分测试套件，就算很好了！</p><p>&nbsp;</p><p>在我加入这个团队的第一个项目中，我创建了一个开发容器配置，将所有这些文档的内容转化为可执行的配置。</p><p>&nbsp;</p><p>为此，我创建了一些专门的Docker配置文件，与用于创建部署容器的Docker配置文件分开。它们位于项目代码库的.devcontainer目录中。</p><p><code lang=\"null\">.devcontainer/\n├── Dockerfile\n├── README.md\n├── devcontainer-load-profile.sh\n├── devcontainer.json\n├── docker-compose.yml\n├── entrypoint.sh\n├── init-once.sh\n├── init.sh\n└── profile.sh</code></p><p>&nbsp;</p><p>这里通常会包含一个docker-compose配置文件，定义了要启动哪些容器，以及它们如何相互连接并连接到宿主。</p><p><code lang=\"null\">version: \"3.2\"\nservices:\napp:\n  user: developer\n  build:\n    context: .\n    dockerfile: Dockerfile\n  volumes:\n    - type: bind\n      source: ..\n      target: /workspace\n    - type: bind\n      source: ${HOME}${USERPROFILE}/.ssh\n      target: /home/developer/.ssh\n  working_dir: /workspace\n  command: sleep infinity\n  environment:\n    BUNDLE_PATH: vendor/bundle\n    INTERFACE: \"0.0.0.0\"\n  ports:\n    - \"3000:3000\"</code></p><p>&nbsp;</p><p>通常还有一个Dockerfile文件，用于定制应用程序开发容器。</p><p><code lang=\"null\">FROM ruby:2.7.2\nRUN apt-get update \\\n&amp;&amp; apt-get install -y yarnpkg vim lsof \\\n&amp;&amp; ln -s /usr/bin/yarnpkg /usr/local/bin/yarn \\\n&amp;&amp; rm -rf /var/lib/apt/lists/*\n\n\nCOPY sixmilebridge-load-profile.sh /etc/profile.d/\n\n\nARG USERNAME=developer\nARG USER_UID=1000\nARG USER_GID=$USER_UID\n\n\nRUN groupadd --gid $USER_GID $USERNAME \\\n  &amp;&amp; useradd -s /bin/bash --uid $USER_UID --gid $USER_GID -m $USERNAME</code></p><p>&nbsp;</p><p>如果我们使用的是VS Code，可以配置devcontainer.json文件。开发容器里还会有一些脚本文件，在容器生命周期的各个阶段发挥作用。</p><p><code lang=\"null\">.devcontainer/\n├── Dockerfile\n├── README.md\n├── devcontainer-load-profile.sh\n├── devcontainer.json\n├── docker-compose.yml\n├── entrypoint.sh\n├── init-once.sh\n├── init.sh\n└── profile.sh</code></p><p>&nbsp;</p><p>在完成这个开发容器的定义后，我就把它全部提交到项目代码库中。</p><p>&nbsp;</p><p>一开始，团队中的一些人说：“我们永远不会用它……你忙你的！”</p><p>&nbsp;</p><p>然后，一件有趣的事情发生了。一些新员工用了开发容器，很快就上手开发了。来自另一个团队的一些人用开发容器在他们通常不参与的代码库上创建PR，再也不需要花一周时间去设置开发环境了。慢慢地，开发容器已经成为我最受夸赞的贡献之一。</p><p>&nbsp;</p><p>使用开发容器最明显和最直接的好处之一是简化了项目启动流程，而且并不只是对新员工来说是这样的，甚至连前端团队的员工都能够参与调整后端的应用程序代码。这可能意味着，在三年后，你能够快速修复Bug。</p><p></p><h4>共享基础工具</h4><p></p><p>&nbsp;</p><p>项目的配置检查清单和脚本很快就会过时，因为一旦我们在一台机器上设置好了项目，就会把它们忘得一干二净。而开发容器会定期进行重新构建。开发容器是可执行的文档，它包含了项目日常开发使用的库、服务、系统配置、开放端口、实用工具等。</p><p>&nbsp;</p><p>例如，你的团队是否会使用ngrok将本地开发机器开发给远程用户？不要把这个设置说明些在Wiki页上，而是将它添加到开发容器中。</p><p><code lang=\"null\">RUN wget https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-amd64.zip \\\n  &amp;&amp; unzip ngrok-stable-linux-amd64.zip \\\n  &amp;&amp; mv ngrok /usr/local/bin \\\n  &amp;&amp; rm ngrok-stable-linux-amd64.zip</code></p><p>&nbsp;</p><p>这样，所有使用开发容器的人都能在需要时获取到合适的工具。</p><p><code lang=\"null\">vscode ➜ /workspace (main ✗) $ ngrok --version\nngrok version 2.3.40</code></p><p></p><h4>任何人都可以随时运行所有的测试</h4><p></p><p>&nbsp;</p><p>在很多项目中，如果你能在本地运行单元测试，就会被认为做得很好——但只有CI系统能够提供运行集成测试所需的支持服务。在极端情况下，只有少数基础设施人员知道如何在系统测试失败时修复它们，而开发人员在这个时候却什么也做不了。</p><p>&nbsp;</p><p>每个人都可以共享开发容器，也可以在CI中使用，我们可以提升我们的期望：每个人都可以随时运行所有的测试。虽然它们在CI管道中可能执行地更快，但保持集成测试通过率变成了每个人的事情。</p><p>&nbsp;</p><p>开发容器能够为整个测试周期提供支持，因为它们能打包所有东西，不仅包括用于开发应用程序的虚拟微型计算机，还包括运行应用程序所需的支持服务。应用程序需要Redis服务器和安装了特定扩展的特定版本的PostgreSQL？docker-compose配置文件可以确保在开发容器启动时，这些组件都已经是可用的。</p><p>&nbsp;</p><p>它甚至可以将Postgres专家对数据库的优化变成编码，这些优化可以提升开发数据库的响应性而非可靠性。</p><p><code lang=\"null\">redis:\n  image: redis:${REDIS_VERSION:-6.0.9}\npostgres:\n  image: mdillon/postgis:${POSTGRES_VERSION:-9.6}\n  command: [\"-c\", \"fsync=off\", \"-c\", \"full_page_writes=off\", \"-c\", \"synchronous_commit=off\"]\n  environment:\n    POSTGRES_USER: ${POSTGRES_USER:-postgres}\n    POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-password}</code></p><p></p><h4>在项目之间进行干净的切换</h4><p></p><p>&nbsp;</p><p>说到这里，你是否曾经安装过特定的系统库或PostgreSQL版本来满足一个应用程序，结果却破坏了你正在开发的另一个应用程序？有了开发容器，你就可以在一台机器上的多个项目之间进行干净的切换。这对于顾问来说是必不可少的，但也适用于任何拥有多个项目代码库的组织。</p><p>&nbsp;</p><p>说到项目切换，如果你习惯使用Python、Ruby或JavaScript等编程语言，就也习惯了使用VirtualEnv、RVM或NVM等版本管理器。这些工具可以同时构建、安装和管理多个版本的Python、Ruby或Node，并确保每个项目使用正确的语言运行时版本。在这个过程中，它们增加了一个额外的间接层。它们会成为一个麻烦，因为当你需要应对一个你不熟悉的语言生态系统，它们可能会成为生产力障碍。</p><p>&nbsp;</p><p>开发容器消除了对这些工具的依赖。因为一个开发容器专门用于一个项目，所以它可以全局安装指定版本的Ruby、Python或JavaScript。如果运行时是从源代码编译的，那就可以将其整合到开发容器的Dockerfile文件中。自从我开始使用开发容器以来，还没有用过语言版本管理器，而且我并不怀念它们！</p><p></p><h4>共享快捷技巧</h4><p></p><p>&nbsp;</p><p>随着时间的推移，许多项目团队发展出了一套“标准”的shell和git别名，缩短了常见操作命令的长度。其中一些是基本的别名，适用于所有项目，但有一些与一个团队如何开发应用程序有关。</p><p><code lang=\"null\">alias gs=\"git status\"\nalias be=\"bundle exec\"</code></p><p>&nbsp;</p><p>通常情况下，这些东西由团队中的某些人分享出来，然后其他人慢慢采用它们。他们先是匹配代码，然后发现他们习惯使用的快捷技巧并不存在，这可能会令人感到不快。</p><p>&nbsp;</p><p>这些快捷技巧的存在或不存在也可能导致团队微妙地分化为“酷孩子”（他们总是有最好的shell别名）和“不酷的孩子”。</p><p>&nbsp;</p><p>如果任何人都可以立即为其他人添加有用的shell别名，会怎样？这个使用开发容器就能做到。我们不用在Slack中发布shell别名的清单，而是创建一个PR，演示如何在Slack中使用它们。因为开发容器包含了一个共享的UNIX用户空间，所以你可以确保这些快捷技巧对每个人都有效。</p><p></p><h4>更有效地调试</h4><p></p><p>&nbsp;</p><p>开发容器还提供了一些不太明显的好处。根据定义，容器是一个高度可控的环境，就像是显微镜下有一个微小的计算机网络。本文没有足够的篇幅来详细讨论，但我想说得是，开发容器让调试变得更加容易：监控应用程序的文件写入、网络I/O，甚至是系统调用，这样就可以准确地了解它在干什么。</p><p></p><h4>重现问题</h4><p></p><p>&nbsp;</p><p>当团队中的大多数人都在使用开发容器时，它的最大好处就会显现出来。你是否曾经遇到过团队中某个开发人员突然遇到了别人都没注意到的问题？最终，在进行了大量的故障排除之后，发现他收到的系统更新与项目所依赖的某个库不兼容。没有人知道怎样帮助他，因为其他人的电脑上没有这个问题！</p><p>&nbsp;</p><p>开发容器可以大大减少这种“在我的电脑上没问题”的现象。没有什么东西可以保持每个开发人员的开发环境完全相同，但一个公共的容器定义可以消除大量潜在的变化。在知道了是哪个库更新破坏了项目，就可以很容易地修复它。因为在使用容器时，你可以根据需要获取工具和系统库的版本。</p><p></p><h4>在云端编码</h4><p></p><p>&nbsp;</p><p>在有了开发容器的定义后，你就不局限于在“我的机器”上开发了！</p><p>&nbsp;</p><p>使用<a href=\"https://www.gitpod.io/\">Gitpod</a>\"、Amazon <a href=\"https://aws.amazon.com/cloud9/\">Cloud 9</a>\"、<a href=\"https://www.jetbrains.com/space/\">JetBrains Space</a>\"或<a href=\"https://github.com/features/codespaces\">GitHub Codespaces</a>\"等工具进行基于云的开发已经成为一种趋势，而且这种趋势只会越来越明显。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/3b/3bbadfb923fbb46c757ed92ed3c29346.png\" /></p><p></p><p>&nbsp;</p><p>基于云的开发环境支持远程结对编程。只要有浏览器，你就能够在任何地方编写代码，即使你不小心把手提电脑包忘在火车上了。如果你有一个可以在本地执行的开发容器定义，也可以用它在云端启动一个IDE。</p><p>&nbsp;</p><p>开发容器也非常适用于开源工作。你有没有想过为开源项目做一点小小的贡献？但是，在拉取代码时，你意识到运行单元测试需要一个漫长而复杂的设置过程。于是，你放弃了，只能在他们的问题追踪器里提了个建议。</p><p>&nbsp;</p><p>如果开源项目附带的开发容器可以立即提升业余贡献者的生产力，那会怎样？这可能会更容易吸引到业余贡献者！</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/2f/2f89a6ed5ed2f42020800116a215bebe.png\" /></p><p></p><p></p><h2>VS Code中的开发容器</h2><p></p><p>&nbsp;</p><p>让我们来讨论一下编辑器和IDE。</p><p>&nbsp;</p><p>IDE开始添加一些特性来支持基于容器的开发。微软的开源编辑器VS Code绝对是这一趋势的领头羊。事实上，我对开发容器的很多想法，包括“开发容器”这个术语，都是受VS Code提供容器支持的方式的启发。越来越多的编辑器和IDE都添加了容器感知功能。</p><p>&nbsp;</p><p>开发容器与支持开发容器的IDE的紧密集成可以帮助开发人员在开始项目时提升效率。例如，现在的项目中一般都会有针对代码库定制的Lint或格式化规则。在以前，新加入的开发人员需要自己安装Lint工具，并确保编辑器做了正确的配置。有了容器感知的编辑器配置，开发人员在第一次启动项目时Lint和代码格式化就已经可用了。</p><p>&nbsp;</p><p>这并不是说开发容器就这样将你与使用完全相同的编辑器配置锁定在一起了。事实并非如此！例如，在使用VS Code时，开发容器可以包含一个基础的特定于项目的设置和插件，但你也可以在此基础上添加自己的设置、插件、配色方案、按键映射等。</p><p>&nbsp;</p><p>这并不是说团队就只能使用一种编辑器。一个项目可以有支持多个支持开发容器的IDE的配置。你可以在开发容器中包含完整的VIM设置，包括编辑器本身！</p><p></p><h2>开发容器不是部署容器</h2><p></p><p>&nbsp;</p><p>现在，没有什么工具或技术是万能的。稍后我将讨论一些你可能不想使用开发容器的情况。但在此之前，我想分享关于使用开发容器的一个最大的转折点。</p><p>&nbsp;</p><p>我经常会听到这样的建议：“我们已经有了容器定义，为什么不能重用它?”或者完全相反：“开发容器这个东西并不适合我们，因为我们没有使用容器来部署我们的应用程序。”</p><p>&nbsp;</p><p>我认为这两个观点都有同一个错误的前提：容器是用来部署的。这种误解是可以理解的。如果你已经在项目中使用了容器，这可能是因为这是你部署应用程序的一种方式。你甚至可能在持续集成基础设施中使用了容器。容器不就是用来装东西的吗？</p><p>&nbsp;</p><p>的确，使用容器来部署应用程序是促进容器普及的一个应用场景。但是，不管你是否用容器来部署应用程序，开发容器都很有用！事实上，如果你只是将开发容器视为部署容器，会很容易错过它强大的功能。</p><p>&nbsp;</p><p>事情是这样的：用于部署的容器与用于开发的容器有着非常不同的需求。事实上，针对部署容器的许多要求几乎与开发容器完全相反。</p><p>&nbsp;</p><p>我们希望部署容器尽可能地小和精简。我们希望它们精简、快速和安全。这意味着要尽量减少不必要的库和工具，所以尽量使用基础镜像，如Debian Slim，甚至是Alpine Linux，它们去掉了普通Linux发行版中常见的glibc库。但是对于开发容器来说，它们需要提供一个完整、舒适的开发环境。这意味着一个像Ubuntu这样的Linux发行版，需要包含命令行工具、编译器、帮助文档和整个工具包！</p><p>&nbsp;</p><p>对于部署，你希望最小化安全横截面。对于开发，你需要打开更多的端口来支持调试！对于部署，不得不与Honeycomb或New Relic这样的可观测服务通信。对于开发，你不希望向这些服务发送消息，你可能希望“伪造”或模拟一些外部服务。在部署过程中，你想要减少Docker构建的层数，而在开发过程中，你可能希望在不需要完全重建镜像的情况下快速添加增量的变更。</p><p>&nbsp;</p><p>在很多方面，部署容器和开发容器的目标是相互对立的。这就是为什么当我面对一个新客户并开始构建一个开发容器时，通常会从头开始。我会构建一套全新的容器配置文件，从项目设置指令而不是从已有的Dockerfile开始。这为我提供了一个可移植的、可复制的开发环境，但不是为了部署。</p><p>&nbsp;</p><p>但这并不意味着开发容器和部署容器的配置就不能共享一些共同的部分。因为本文的篇幅所限，这里不能再展开描述了。不过这里有一个提示：你可以从开发容器开始，并将其简化为部署容器，这比从部署容器开始并将其变成开发环境要容易得多。</p><p></p><h2>关于开发容器的注意事项</h2><p></p><p>&nbsp;</p><p>综上所述，开发容器并不适用于所有项目。</p><p>&nbsp;</p><p>我们所讨论的一切都是基于用Docker运行的容器。目前，大多数Web和企业应用程序都部署在基于Linux的服务器上，因此使用开发容器就等于是在接近生产环境的环境中做开发。Android开发也是如此。但是，如果你的部署目标不是Linux或类似Linux的系统，你可能就不会想这么做。如果你的目标是iOS设备或Windows桌面，那么容器开发可能不是最佳选择。</p><p>&nbsp;</p><p>此外，到2021年，基于Docker的桌面开发平台已经有了明显的发展。</p><p>&nbsp;</p><p>在基于Linux的机器上运行Docker可能有着最好的体验，因为Linux是容器的原生主机。</p><p>&nbsp;</p><p>但令人感到惊讶的是，现在的次优选择是Windows。这是因为随着Windows的Linux子系统2（或“WSL2”）的出现，Windows现在可以原生运行Linux。实际上，你可以直接从Windows存储库中选择你需要的Linux发行版，并直接从Debian或Fedora存储库中运行Linux二进制文件，不需要进行任何重新编译或模拟。</p><p>&nbsp;</p><p>Docker Desktop on Windows使用WSL2作为后端。这意味着Windows上的Docker容器可以有效地运行在原生Linux环境中，没有虚拟化性能损失。在我的使用过程中，它们很稳定，能够以原生的速度运行Rails项目。</p><p>&nbsp;</p><p>MacOS是以BSD为基础构建的，并不是Linux，而且它没有与WSL2等价的工具。这意味着为了运行Docker，需要进行一定程度的虚拟化。我不再用Mac做开发，但我从朋友那里听说，他们在使用Docker时遇到了一些古怪的问题，尤其是在文件I/O方面。</p><p>&nbsp;</p><p>这该怎么办呢？幸运的是，这是一个众所周知的问题，Docker和苹果公司都有意要去解决。事实上，在我写这篇文章时，Docker宣布了一些针对MacOS性能的重大更新。如果幸运的话，这个问题将很快成为本文最过时的部分！</p><p></p><h2>我们在容器里写代码</h2><p></p><p>&nbsp;</p><p>有一些技术，一旦成熟了，就会永久地改变技术的发展状态。</p><p>&nbsp;</p><p>在我编程时，版本控制还没有被普遍接受。一些项目仍然通过定期压缩的代码副本来记录历史。在我后来的职业生涯中，版本控制变得越来越普遍。然后，持续集成从一种新颖的想法变成了一种行业标准。现在，分布式版本控制和持续集成成了桌面开发的筹码：我们几乎无法想象没有它们的软件项目会是什么样子。</p><p>&nbsp;</p><p>2021年，我们正处于容器发展的拐点。五年后，我们会对过去认为在第一次提交代码之前花几天时间安装开发者笔记本电脑是多么正常的事情而嗤之以鼻。但你不需要等那么久，只要稍加努力，你就可以让自己和团队从开发容器中获得好处。</p><p>&nbsp;</p><p>你可以有一个可移植的、可复制的开发环境，它可以跟随你从一台机器搬到另一台机器，甚至到云端。你可以在一小时内让新员工上手，而不是几天。你可以更容易地为开源项目做出贡献。你可以确保在CI系统中运行的每一个测试也都可以在本地运行。你可以通过GitHub与你的队友分享你的开发配置和脚本。你可以通过将开发容器作为项目开发工作流程的一部分来实现这一切。</p><p></p><h2>结论</h2><p></p><p>&nbsp;</p><p>所以，这就是为什么我认为你应该放下一切，为你当前的项目创建一个开发容器定义。不仅如此，你还应该使用开发容器并完善它，直到它变得像家一样舒适。你的合作者会感谢你，未来的你也会感谢现在的你。</p><p></p><p>作者简介：</p><p>&nbsp;</p><p>Avdi Grimm是一名程序员，著有几本颇受欢迎的Ruby编程书籍，并因对Ruby社区的贡献而获得Ruby Hero奖。他在Graceful.Dev上开设了面向对象设计、测试、重构、项目自动化等课程。</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/devcontainers/\">Reproducible Development with Devcontainers</a>\"</p>",
    "publish_time": "2022-07-05 09:35:01",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "CubeFS 进入 CNCF 孵化阶段，国产分布式存储的新里程碑！",
    "url": "https://www.infoq.cn/article/xDMtUJC6EwCKhef6KKWK",
    "summary": "<p>CubeFS是国内首个云原生开源分布式存储产品，2019年开源并捐赠托管至云原生计算基金会(CNCF)，2020年10&nbsp;月OPPO开始主导CubeFS社区运营与版本迭代，累计发布7个release版本。在OPPO的全力推进下，CubeFS于2022年6月进入CNCF孵化阶段。</p><p>&nbsp;</p><p>本文，我们与CubeFS Maintainer OPPO的何小春进行了对话，共同探讨CubeFS的技术演进及云原生存储技术的发展方向。</p><p>&nbsp;</p><p></p><h2>云原生存储技术“越来越分布式”</h2><p></p><p>&nbsp;</p><p>随着云计算时代的到来，5G等场景下的大规模数据存储成为常态，超大容量、快速变化的I/O需求，对存储的弹性、运维及TCO都提出了更高要求。传统存储的紧耦合特点、烟囱式架构以及高昂的价格愈来愈无法满足企业的发展需要，于是基于分布式架构的软件定义存储（SDS）登上舞台。</p><p>&nbsp;</p><p>我们从SNIA提出的SDS应具备的特性可以看出，其最大优势是实现软硬件的解耦，能够打破对于存储或传统存储的硬件依赖。而分布式存储系统采用可扩展的系统结构，利用多台存储服务器分担存储负荷，既可提高系统的可靠性、可用性和存取效率，还易于扩展，能很好满足SDS的需求。</p><p>&nbsp;</p><p>据IDC预测，2017—2022年全球SDS市场规模平均增速达到14.7%，国内SDS市场规模平均增速为32.5%。我们可以清楚看到，SDS呈现了从集中式逐渐过渡到分布式的趋势。</p><p>&nbsp;</p><p>智研咨询发布的《2021-2027年中国分布式存储行业市场研究分析及投资战略规划报告》显示，2020年我国分布式存储行业市场规模102.9亿元，同比增长47%，其中分布式文件规模48.36亿元，成为市场主导。</p><p>&nbsp;</p><p>行业趋势已然明了，但业内鲜有已投入生产且历经大规模流量考验的分布式存储系统可供选择，CubeFS是其中一个。</p><p>&nbsp;</p><p></p><h2>存储技术革新：CubeFS正式进入孵化阶段</h2><p></p><p>&nbsp;</p><p>CubeFS作为国内首个开源分布式存储系统，2019年由京东捐赠给云原生计算基金会，同期OPPO在大规模机器学习、大数据存储和其他传统的IT应用方面，对文件以及对象存储有强烈的需求，在经历Ceph、HDFS等多次技术选型后，OPPO引入CubeFS并于2020年10&nbsp;月起，开始大量投入并全面主导CubeFS的社区运营与版本迭代。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/08/11/0831f4d025a6591034d2602963c95911.png\" /></p><p></p><p>何小春谈起OPPO的存储系统选型时说道，“我们需要一个在生产上真正好用的产品，一个在系统稳定性、可扩展性、IO性能以及可维护性方面都表现优秀的产品，我们当时调研了许多行业里的产品，发现CubeFS最符合我们的业务需求，于是把产品引进来，并且投入了大量的研发人力，和社区伙伴一起共建CubeFS。”</p><p>&nbsp;</p><p>CubeFS在进入孵化阶段之前，OPPO在对产品的稳定性夯实、代码规范、社区治理、用户及开发者支持等方面做了很多工作。2020年10&nbsp;月至今，OPPO持续组织了多场社区例会，公布开发计划、认真听取了社区用户的建议。同时，OPPO在整个产品文档建设方面也投入了许多精力，外部伙伴拥有更好的使用体验。</p><p>&nbsp;</p><p>历经2年，CubeFS正式进入孵化阶段。CubeFS在产品成熟度、项目采用率以及社区持续性等方面取得一系列进展，目前已在OPPO、京东、网易、360等企业内被大量应用。历经多家公司多类业务负载的长期考验，CubeFS的稳定性、扩展性、易运维性、性能、成本优势等各项数据都可以证明，其已是一款真正实现“生产可用”的产品：</p><p>&nbsp;</p><p>稳定性：CubeFS目前支撑着OPPO大数据、AI、云相册等各个业务累计EB级数据的存储；在其他公司的业务实践中，存储量也已达到数十PB~百PB级；CubeFS稳定性得到有效的验证。高性能：在大/小文件读写、超大目录访问等场景都有优秀的解决方案，具体可参考<a href=\"https://cubefs.readthedocs.io/zh_CN/latest/evaluation.html#io\">https://cubefs.readthedocs.io/zh_CN/latest/evaluation.html#io</a>\"可运维性：CubeFS提供了易用的节点上下架、完整的指标监控、详细的Log以及配套的运维工具，让运维工作变得更简单高效；高性价比：V3.0.0版本发布的“在线纠删码”功能，对比之前的三副本存储，可有效降低存储成本。OPPO在使用EC引擎后，业务整体TCO下降超60%；CubeFS可以直接支持高精尖的芯片业务，比如支撑马里亚纳芯片设计的存储系统就是CubeFS，维护成本高、响应不及时、个性化需求难以满足的问题都得到了解决。</p><p>&nbsp;</p><p>对在分布式存储方面有需求的企业和开发者而言，无论是底层引擎能力、元数据系统设计还是业务场景支撑维度上看，CubeFS都可以很好的满足。</p><p>&nbsp;</p><p>在整个CubeFS项目的开发过程中，作为Maintainer的何小春有许多启发，他认为，在做存储系统的技术选型时，企业除了需要考虑系统的稳定性、性能外，还要考虑成本与业务改造难度。“存储迁移的成本和风险都比较高，所以（某个系统）如果能够做到业务改造尽量小的话，用户就能很好地做出选型决策。”</p><p>&nbsp;</p><p>何小春的这些考虑也都被纳入了CubeFS的设计之中。CubeFS架构设计简洁，对代码质量有良好把控，二次开发成本更低；采用存算分离架构设计，支持可水平扩展的强一致性的元数据服务，数据存储支持多副本和纠删码两种引擎。此外，CubeFS还支持多级智能加速能力，支持标准S3、POSIX、HDFS三种访问协议，与K8s、容器生态有良好的兼容性。</p><p>&nbsp;</p><p>CubeFS的开发者文档十分丰富，大大降低了企业和开发者的使用门槛。四个模块+三个节点便可以将整个存储集群搭建起来。如果使用“纠删码引擎”，模块会多一些，但CubeFS开发团队也正在对纠删码架构做进一步优化；从文档方面针对存储集群部署为运维者提供了丰富易用的操作文档。对于内部已经在运行CEPH、HDFS或其他主流开源分布式存储系统的企业，CubeFS同样可以做到几乎零改动接入。</p><p>&nbsp;</p><p><img src=\"https://static001.infoq.cn/resource/image/4c/6f/4c7b7yy135b07f3c07acd1de8bff566f.png\" /></p><p></p><p></p><h2>OPPO的技术探索：亿级数据湖背后的存储技术</h2><p></p><p>&nbsp;</p><p>很多人都认为“数据湖”是下一代大数据平台，各大云厂商也都陆续提出了自己的数据湖解决方案，而从OPPO也从主导CubeFS项目后，就基于CubeFS对数据湖存储技术进行了探索。</p><p>&nbsp;</p><p>数据湖最早是在2010年10月纽约Hadoop World大会上提出来的，在这样的大背景下，数据湖与Hadoop总是要一起被提起的。在Hadoop这个原生生态下，数据湖技术目前主要存在三个问题，第一是存储成本；第二是性能；第三个是业务侧的使用体验，于是CubeFS基于此提出了解决方案。</p><p>&nbsp;</p><p>从成本方面，CubeFS采存算分离的架构设计，各子系统可独立扩容；同时“在线纠删码引擎”可有效降低数据冗余度，节约存储成本，还能有效提升数据的耐久度。在未来，CubeFS还将提供更智能的冷热分层能力，实现业务对对性能和成本双重需求。</p><p>&nbsp;</p><p>从性能方面，CubeFS针对小文件做了许多针对性优化，能够提供很好的小文件读写性能。CubeFS支持多种访问协议，不同类型业务可以共享同一个存储集群，结合精细化租户隔离策略及不同租户间潮汐访问的特点，可有效提升存储集群关键资源( IO和带宽)利用率，降低运营成本。</p><p>&nbsp;</p><p>至于用户体验，用户通常指两类人员。一类是运维人员，从之前的要维护多套存储集群变成只维护CubeFS这一套集群，工作量大大降低，扩容、缩容过程也更加智能自动化，保证系统稳定性的同时，运维工作也变得更便捷。另一类是终端用户，CubeFS提供的是统一数据底座和元数据管理，支持多种协议，极大程度上避免了用户对底层数据做多次拷贝，大幅提升数据复用效率。</p><p>&nbsp;</p><p><img src=\"https://static001.infoq.cn/resource/image/6d/14/6d9250878a6c72fe37027b2bcb594914.png\" /></p><p></p><p>整体而言，CubeFS对于数据湖的探索，主要集中在元数据管理、纠删码存储与数据湖访问加速。从元数据管理方面，CubeFS内存元数据分片通过snapshot方式持久化到磁盘以作备份及恢复使用。目前CubeFS单个目录支持百万级别容量，元数据全内存化，保证优秀的读写性能。</p><p>&nbsp;</p><p>纠删码存储技术（EC）作为CubeFS的核心技术，目前已在3.0版本支持了，可有效降低海量数据的存储成本。CubeFS单集群支持EB规模，相比传统的多副本存储，EC的数据冗余度更低。其实现方式有多种，大多数是基于异或运算或RS编码。EC的底层原理是“将K份原始数据，通过编码计算得到新的M份数据，当K+M份数据丢失任意的不多于M份时，通过解码可还原出原始数据”，有效地实现故障容灾。</p><p>&nbsp;</p><p><img src=\"https://static001.infoq.cn/resource/image/30/c7/302efac23a9110ba5682b15225f62cc7.png\" /></p><p></p><p>CubeFS在数据湖访问加速问题上提出了跨区域跨云的“多级缓存能力”和“谓词下推操作”两个解决方案。目前多级加速功能已上线，一级本地缓存与计算节点同机部署，支持元数据和数据缓存，支持内存、PMem、NVme、HDD不同类型介质，访问时延低但容量少；二级全部分布式缓存副本数目弹性可变，提供机房位置感知能力，支持用户/桶/对象级的主动预热和被动缓存，数据淘汰策略也可配置。谓语下推操作策略显著减少了存储与计算节点间大量的数据流动，降低了资源开销并提升计算性能。</p><p>&nbsp;</p><p><img src=\"https://static001.infoq.cn/resource/image/eb/33/eb4a48d7aa5675d2e059a2f35d83be33.png\" /></p><p></p><p>谈至此，何小春说到，“目前我们正在考虑解决“异构存储编排管理”问题，如把存量的文件或对象存储集群统一纳入管理，减少数据搬迁，该特点预计年底发布。”</p><p>&nbsp;</p><p>其实CubeFS对于数据湖存储的探索不仅如此，除了以上三个核心技术，CubeFS还正在设计一个基于混合云业务场景的架构；在产品特性方面推出了许多重要功能，如多版本快照、智能生命周期管理、数据容灾方面的跨区复制功能等。</p><p>&nbsp;</p><p></p><h2>关于CubeFS的未来，OPPO有自己的想法</h2><p></p><p>&nbsp;</p><p>OPPO CubeFS项目的Maintainer何小春提到CubeFS的未来规划，“全力推动并争取在2年内在CNCF毕业。”</p><p>&nbsp;</p><p>为了顺利从CNCF毕业，CubeFS将在核心重要特性、业务支撑范围、低成本运维能力建设等方面持续迭代与夯实。技术层面上主要进行三大技术演进，第一，在数据湖与AI领域，持续优化CubeFS的性能，为大数据及AI场景提供整体的存储及加速能力；第二，CubeFS将逐步从数据中心向边缘设备进行扩展；第三，在混合云管理方面，结合私有云和公共云优势，提供具备高可扩展性、灵活性及成本优势，同时兼具数据安全性和隐私性的混合云存储能力。</p><p>&nbsp;</p><p>一个优秀开源产品的发展需要更多社区力量的支持，OPPO将在未来为社区共建做出更多努力，让更多用户和开发者参与到产品的建设中来，在一些关键场景上，共同开发出更多产品新特性。OPPO CubeFS项目组目前也制定了一些比较明确的社区共建计划，除了之前已有的社区例会、文档更新外，还将组织系列技术沙龙，邀请社区伙伴共同分享CubeFS在公司业务场景中的详细实践。未来CubeFS将会和开源社区做进一步的融合，比如打通其他技术生态等，之后社区伙伴们可以直接在CubeFS官方技术公众号看到CubeFS项目的一些技术架构解析及运维心得。</p><p>&nbsp;</p><p>“希望CubeFS能够被更多用户在生产中使用，能有更多的用户参与到产品建设中来。”何小春给了想要快速参与进CubeFS项目共建者3条建议：</p><p>1.&nbsp;先阅读官网文档，了解CubeFS整体设计，不要一开始就扎到代码里面去；</p><p>2.&nbsp;根据CubeFS的操作文档尝试搭建一个集群，看看它到底是有怎样的表现；</p><p>3.&nbsp;自己去提一些Issue，或去承接一些Issue相关的任务，通过简单特性开发或Bug修复逐步了解系统。</p><p>&nbsp;</p><p>在未来，CubeFS作为一个成熟的开源项目，何小春说出了CubeFS研发团队对项目的期待，“当前，真正完整的开源分布式存储产品其实是非常稀缺的，我希望CubeFS能够填补分布式存储产品市场的“空白”，CubeFS的目标就是成为具有全球影响力的分布式存储。”</p><p>&nbsp;</p><p></p><h2>写在最后</h2><p></p><p>&nbsp;</p><p>在存储层面，我们看到整体都在朝着越来越分布式的方向发展，这一切都是因为传统存储的扩展性受限，当下环境下日益增长的数据存储容量需求，对存储系统稳定性、性能及成本的要求越高，“云原生分布式存储”的呼声就会越热。</p><p>&nbsp;</p><p>随着企业数字化转型进入深水区，混合云的业务场景也越来越多，在未来，如何将本地存储与公有云存储打通、企业如何继续使用原来存储方式的同时，还能享受到分布式存储系统所具有的弹性及低成本能力，这将是一个非常值得探索的技术方向。</p>",
    "publish_time": "2022-07-05 09:43:42",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "借助Spring Boot和GraalVM实现原生Java",
    "url": "https://www.infoq.cn/article/VvdlB7CkAyoFvwY6jTSZ",
    "summary": "<p></p><blockquote>本文是“<a href=\"https://www.infoq.com/articles/native-compilations-boosts-java/\">Native Compilations Boosts Java</a>\"”系列文章的一部分。你可以通过<a href=\"https://feed.infoq.com/native-compilations-boosts-java-article-series/\">RSS</a>\"订阅接收新文章更新通知。Java在主导着企业级应用。但是在云中，采用Java的成本要比其竞争者更高。使用GraalVM进行原生编译降低了在云中Java的成本：它所创建的应用启动更快，使用的内存也更少。原生编译为Java用户带来了很多的问题：原生Java会如何改变开发方式？我们在什么情况下该转向原生Java？在什么情况下又该避免转向原生Java？要使用原生Java，我们该采用哪个框架？本系列的文章将回答这些问题。</blockquote><p></p><p></p><h2>Java社区包罗万象</h2><p></p><p>我们知道，Java是一个神奇的生态系统，很难列出哪些东西是最适合我们的。这样做的话，清单似乎是无穷无尽的。但是，要说出它的几个缺点也不是那么困难。正如<a href=\"https://www.infoq.com/articles/native-compilations-boosts-java/\">本系列文章</a>\"所说的，在JRE上运行的应用往往需要10秒钟或更长的时间才能启动，并需要数百或数千兆字节的内存。</p><p></p><p>这样的性能在如今的世界并不处于领先的位置。有些新的领域和机会正在出现：函数即服务产品、容器化与容器编排。它们有一个共同点，即对启动速度和内存占用有很高的要求。</p><p></p><h2>迈向GraalVM！</h2><p></p><p><a href=\"https://www.infoq.com/articles/native-java-graalvm\">GraalVM</a>\"提供了一个前进的方向，但它也有一定的代价。GraalVM是OpenJDK的替代方案，它有一个名为Native Image的工具，支持预先（ahead-of-time，AOT）编译。</p><p></p><p>AOT编译与常规的Java编译有一些差异。正如<a href=\"https://www.infoq.com/articles/native-java-graalvm/\">本系列的第一篇文章</a>\"所概述的那样，Native Image消除了Java中“所有不必要的东西”。那么，Native Image是如何知道Java或Spring Boot中哪些是不必要的呢？</p><p></p><p>Native Image会探查我们的源码，并确定所有可达的代码，也就是通过调用或我们代码的使用所能链接到的代码。其他的所有内容，不管是位于应用的classpath下还是位于JRE中，都会被视为不必要的，它们都会被抛弃掉。</p><p></p><p>当我们做了一些Native Image无法明确知道该怎么处理的事情时，麻烦就来了。毕竟，Java是一个非常动态化的语言。我们有可能会创建这样一个Java应用：在运行时，将一个字符串编译成文件系统中一个合法Java类文件，并将其加载到ClassLoader中，然后使用反射创建它的实例或者为其创建代理。我们还可能会将实例序列化到磁盘上，然后将其加载到另外一个JVM中。在这个过程中，我们可能不需要链接任何比java.lang.Object更具体的类。但是，如果这些类型没有被放到原生可执行堆中，所有的这些方式在原生Java中是无法正常运行的。</p><p></p><p>但是，我们并没有失去任何东西。我们可以在一个配置文件中告诉Native Image要保留哪些类型，这样，在运行时使用反射、代理、classpath资源加载、JNI等特性的时候，它依然可以运行。</p><p></p><p>现在，Java和Spring生态系统非常庞大。所有的东西都要进行配置将会非常痛苦。所以我们有了两种方案：1）教会Spring尽可能避免使用这些机制，或者2）教会Spring尽可能多地提供配置文件，这个配置文件必然要包含Spring框架和Spring Boot，并且要在一定程度上包含Spring Boot支持的第三方集成功能。友情剧透一下，这两种方案我们都需要！</p><p></p><p>要运行样例项目，你需要在自己的机器上安装GraalVM。GraalVM有<a href=\"https://www.graalvm.org/java/quickstart/\">安装指南</a>\"。如果你使用Mac的话，也可以<a href=\"https://sdkman.io/jdks#grl\">使用SDKMAN!来安装GraalVM</a>\"。</p><p></p><h2>Spring Native</h2><p></p><p>Spring团队在2019年启动了Spring Native项目，为Spring Boot生态系统引入了原生可执行程序编译的功能。它已经为多种不同的方式提供了研究场所。但是，Spring Native并没有从根本上改变Framework 5.x或Spring Boot 2.x。而且它也绝不是终点，只是漫长旅程中的第一步：它已经为下一代Spring Framework（6.x）和Spring Boot（3.x）证明了很多概念，这两个版本预计都会在2022年晚些时候发布。这些新一代的项目会进行更多的优化，所以前景看起来是非常光明的！鉴于这些版本尚未发布，我们将会在本文中研究一下Spring Native。</p><p></p><p>Spring Native会对发送给Native Image的源码进行转换。比如，Spring Native会将spring.factories服务加载机制转换为静态类，从而使Spring Native应用知道要使用它们。它会将所有的Java配置类（带有@Configuration注解的类）转换成Spring的函数式配置，从而消除应用及其依赖的反射。</p><p></p><p>Spring Native还会自动分析我们的代码，探测需要GraalVM配置的场景，并以编程的方式提供这些配置。Spring Native为Spring、Spring Boot以及第三方集成提供了线索（hint）类。</p><p></p><h2>第一个Spring Native应用：JPA、Spring MVC和H2</h2><p></p><p>我们开始使用Spring Native的方式与所有其他Spring项目相同：访问<a href=\"https://start.spring.io/\">Spring Initializr</a>\"，点击cmd + B（或Ctrl + B）或者Add Dependencies，并选择Spring Native。</p><p></p><p>Spring Initializr会配置Apache Maven和Gradle构建。随后，只需添加必要的依赖即可。我们先从一些典型的依赖开始。将Artifact名称改为jpa，接下来添加如下依赖：Spring Native、Spring Web、Lombok、H2 Database和Spring Data JPA。请确保选择Java 17，当然你也可以选择Java 11，但这就像你挥舞着一个橡胶做的小鸡满世界乱跑，这看上去非常傻，对吧？点击“Generate”，解压生成的项目并将其导入到你最喜欢的IDE中。</p><p></p><p>这个样例非常简单，将JpaApplication.java类改成如下所示：</p><p><code lang=\"java\">package com.example.jpa;\n\nimport lombok.*;\nimport org.springframework.boot.ApplicationArguments;\nimport org.springframework.boot.ApplicationRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.bind.annotation.*;\nimport javax.persistence.*;\nimport java.util.Collection;\nimport java.util.stream.Stream;\n\n@SpringBootApplication\npublic class JpaApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(JpaApplication.class, args);\n    }\n}\n\n@Component\nrecord Initializr(CustomerRepository repository)\n       implements ApplicationRunner {\n\n   @Override\n   public void run(ApplicationArguments args) throws Exception {\n       Stream.of(\"A\", \"B\", \"C\", \"D\")\n               .map(c -&gt;; new Customer(null, c))\n               .map(this.repository::save)\n               .forEach(System.out::println);\n   }\n}\n\n@RestController\nrecord CustomerRestController(CustomerRepository repository) {\n\n    @GetMapping(\"/customers\")\n    Collection customers() {\n        return this.repository.findAll();\n    }\n}\n\ninterface CustomerRepository extends JpaRepository {\n}\n\n@Entity\n@Getter\n@Setter\n@ToString\n@NoArgsConstructor\n@AllArgsConstructor\n@Table (name = \"customer\")\nclass Customer {\n    @Id\n    @GeneratedValue\n    private Integer id;\n    private String name;\n}\n</code></p><p></p><p>我们也可以将测试以原生可执行文件的形式进行编译和运行。但是需要注意的是，有些内容还不能很好的运行，比如Mockito。我们修改测试类JpaApplicationTests.java，使其如下所示：</p><p><code lang=\"java\">package com.example.jpa;\n\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.util.Assert;\n\n@SpringBootTest\nclass JpaApplicationTests {\n\n    private final CustomerRepository customerRepository;\n\n    @Autowired\n    JpaApplicationTests(CustomerRepository customerRepository) {\n        this.customerRepository = customerRepository;\n    }\n\n    @Test\n    void contextLoads() {\n        var size = this.customerRepository.findAll().size();\n        Assert.isTrue(size &gt; 0, () -&gt; \"there should be more than one result!\");\n    }\n\n}\n</code></p><p></p><p>在本文中，我将会展示macOS下的命令。对于Windows和Linux，请相应的进行调整。</p><p></p><p>我们可以按照常规的方式运行应用和测试，比如在终端中运行mvn spring-boot:run命令。直接运行这些样例其实是个不错的主意，至少可以保证应用能够正常运行。但是，这并不是我们的目的。相反，我们想要将应用及其测试编译成GraalVM原生应用。</p><p></p><p>如果你看过pom.xml文件的话，你就会发现里面有很多额外的配置，它们搭建了GraalVM原生镜像并添加了一个Maven profile（叫做native）以支持构建原生可执行文件。我们可以使用mvn clean package像以往那样编译应用。也可以使用mvn -Pnative clean package对应用进行原生编译。需要记住的是，你需要将GraalVM设置为成自己的JDK。这个过程会持续几分钟，所以现在是来一杯茶、咖啡、水或其他饮品的时间。我就是这么做的，因为我需要它。当我回来的时候，我看到了如下所示的输出：</p><p><code lang=\"java\">...\n13.9s (16.9% of total time) in 71 GCs | Peak RSS: 10.25GB | CPU load: 5.66\n...\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  03:00 min\n[INFO] Finished at: 2022-04-28T17:57:56-07:00\n[INFO] ------------------------------------------------------------------------\n</code></p><p></p><p>我们花费了三分钟的时间来编译原生测试，如果测试成功的话，还会编译原生应用本身。在这个过程中，Native Image使用了高达10.25GB的RAM。为了加快讲解的速度，在后文中我将会跳过编译和运行测试的过程。所以，当我们编译下面的样例时，将会使用如下的命令：</p><p><code lang=\"java\">mvn -Pnative -DskipTests clean package\n</code></p><p></p><p>编译时间因应用的classpath不同而有所差异。根据经验，如果跳过编译测试的话，我的大多数构建将会需要1分钟到90秒的时间。例如，本应用包含了JPA（和Hibernate）、Spring Data、H2数据库、Apache Tomcat和Spring MVC。</p><p></p><p>运行应用：</p><p></p><p><code lang=\"java\">./target/jpa\n</code></p><p></p><p>在我的机器上，将会看到：</p><p></p><p><code lang=\"java\">…Started TraditionalApplication in 0.08 seconds (JVM running for 0.082)\n</code></p><p></p><p>非常不错，80毫秒，也就是千分之八十秒！更棒的，该应用几乎不占用任何内存。我使用如下的脚本来测试应用的<a href=\"https://en.wikipedia.org/wiki/Resident_set_size\">RSS（resident set size）</a>\"。</p><p><code lang=\"java\">#!/usr/bin/env bash  \nPID=$1\nRSS=`ps -o rss ${PID} | tail -n1`\nRSS=`bc &lt;&lt;&lt; \"scale=1; ${RSS}/1024\"`\necho \"RSS memory (PID: ${PID}): ${RSS}M\"\n</code></p><p></p><p>我们需要正在运行的应用的进程ID（PID）。在macOS上，我可以通过运行pgrep jpa来获取它。我所使用的脚本如下所示：</p><p><code lang=\"java\">~/bin/RSS.sh $(pgrep jpa)\nRSS memory (PID: 35634): 96.9M\n</code></p><p></p><p>大约97MB的RAM。这个数值可能会因运行应用的操作系统和架构的不同而有所差异。在Intel上的Linux和M1上的macOS中运行应用时，这个值就是不一样的。与JRE应用相比，这当前是一个明显的改进，但依然并不是最好的。</p><p></p><p>我喜欢反应式编程，而且我认为它更适合我现在的工作负载。我创建了一个类似的反应式应用。它不仅耗费了更少的空间（原因很多，包括Spring Data R2DBC支持Java 17的record语法），应用的编译时间是1:14（差不多快了两分钟），启动时间是0.044秒。它占用的内存少了35%，大约为63.5MB。这个应用每秒还可以处理更多的请求。所以，它的编译和执行速度更快，内存效率更高，启动更快并且能够处理更高的流量。我说的是，在各方面这都是一笔不亏的买卖。</p><p></p><h2>集成应用</h2><p></p><p>Spring不仅仅是HTTP端点，还有很多其他的东西。它包括很多框架，比如Spring Batch、Spring Integration、Spring Security、Spring Cloud以及不断增加的其他框架，它们都提供了对Spring Native的良好支持。</p><p></p><p>我们看一个Spring Integration的应用样例。Spring Integration是一个支持企业级应用集成（enterprise-application integration，EAI）的框架。Gregor Hohpe和Bobby Woolf的开创性著作<a href=\"https://www.enterpriseintegrationpatterns.com/gregor.html\">Enterprise Integration Patterns</a>\"为集成模式提供了通用的术语。Spring Integration提供了实现这些模式的抽象。</p><p></p><p>返回Spring Initializr，将项目命名为integration，并选择Java 17，添加Spring Native、Spring Integration、Spring Web，然后点击Generate。我们需要在pom.xml文件中手动添加一个依赖项：</p><p><code lang=\"java\">\n  org.springframework.integration\n  spring-integration-file\n  ${spring-integration.version}\n\n</code></p><p></p><p>修改IntegrationApplication.java的代码，如下所示：</p><p><code lang=\"java\">package com.example.integration;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.integration.dsl.IntegrationFlow;\nimport org.springframework.integration.dsl.IntegrationFlows;\nimport org.springframework.integration.file.dsl.Files;\nimport org.springframework.integration.file.transformer.FileToStringTransformer;\nimport org.springframework.integration.transformer.GenericTransformer;\n\nimport java.io.File;\n\n@SpringBootApplication\npublic class IntegrationApplication {\n\n    @Bean\n    IntegrationFlow integration(@Value(\"file://${user.home}/Desktop/integration\") File root) {\n        var in = new File(root, \"in\");\n        var out = new File(root, \"out\");\n        var inboundFileAdapter = Files\n                .inboundAdapter(in)\n                .autoCreateDirectory(true)\n                .get();\n        var outboundFileAdapter = Files\n                .outboundAdapter(out)\n                .autoCreateDirectory(true)\n                .get();\n        return IntegrationFlows //\n                .from(inboundFileAdapter, spec -&gt; spec.poller(pm -&gt; pm.fixedRate(1000)))//\n                .transform(new FileToStringTransformer())\n                .transform((GenericTransformer) source -&gt; new StringBuilder(source)\n                        .reverse()\n                        .toString()\n                        .trim())\n                .handle(outboundFileAdapter)\n                .get();\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(IntegrationApplication.class, args);\n    } \n} \n</code></p><p></p><p>这个应用非常简单：它会监控一个目录（$HOME/Desktop/integration/in）中的新文件。一旦发现新文件，它就会创建一个副本，其String内容与源文件恰好相反，并将其写入到$HOME/Desktop/integration/out中。在JRE上，该应用的启动时间为0.429秒。这已经非常不错了，接下来我们看一下将其转换成GraalVM可执行文件会带来什么变化。</p><p><code lang=\"java\">mvn -Pnative -DskipTests clean package\n</code></p><p></p><p>该应用的编译时间为55.643秒。它的启动时间（./target/integration）为0.029秒，占用了35.5MB的RAM。很不错！</p><p></p><p>我们可以看到，没有所谓的典型结果。编译过程的输入对输出有着很大的影响。</p><p></p><h2>将应用带入生产环境</h2><p></p><p>在某个时间点，我们可能希望将应用部署到生产环境中，如今典型的生产环境就是Kubernetes了。Kubernetes以容器的方式运行。<a href=\"https://buildpacks.io/\">Buildpacks项目</a>\"背后的核心概念是集中和重用将应用制品转换成容器的习惯性做法。使用Buildpacks的方式有很多，可以借助pack CLI，也可以在Kubernetes集群中使用<a href=\"https://github.com/pivotal/kpack\">KPack</a>\"，还可以使用Spring Boot的构建插件。我们将使用最后一种方式，因为它仅需要Docker Desktop即可。请<a href=\"https://www.docker.com/products/docker-desktop/\">点击官网</a>\"了解Docker Desktop的更多信息。</p><p><code lang=\"java\">mvn spring-boot:build-image\n</code></p><p></p><p>该命令会在容器内构建原生可执行文件，所以我们会得到一个包含Linux原生二进制文件的Linux容器。随后，我们可以通过docker tag和docker push为其添加标签并推送至所选择的容器registry中。当我在2022年5月撰写这篇文章的时候，在M1架构的Mac上，Docker Buildpacks仍然有点不稳定。但我相信这很快就会得到解决。</p><p></p><h2>为Native Image提供一些线索</h2><p></p><p>在到目前为止所看到的样例中，为了让应用能够以原生可执行文件的形式运行，我们并没有做其他更多的事情。按照上述默认的配置，它自然就可以运行。在大多数情况下，这种易用性就是我们期望的结果。但有时候，我们需要给Native Image提供一些线索，正如我在前面的“迈向GraalVM！”章节所提到的那样。</p><p></p><p>我们看一下另外一个样例。首先，进入Spring Initializr，将项目命名为extensions，选择Java 17并添加Spring Native，然后点击Generate。接下来，我们会手动添加一个在Initialzr上不存在的依赖项：</p><p><code lang=\"java\">\n  org.springframework.boot\n  spring-boot-starter-json\n\n</code></p><p></p><p>我们在这里的目标是看一下当出错的时候，会发生些什么。Spring Native提供了一组线索，允许我们很容易地增强默认的配置。将ExtensionsApplication.java修改为如下所示：</p><p><code lang=\"java\">package com.example.extensions;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.aopalliance.intercept.MethodInterceptor;\nimport org.springframework.aop.framework.ProxyFactoryBean;\n\nimport org.springframework.boot.*;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.core.io.ClassPathResource;\nimport org.springframework.nativex.hint.*;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.*;\n\nimport java.io.InputStreamReader;\nimport java.util.List;\nimport java.util.function.Supplier;\n\n@SpringBootApplication\npublic class ExtensionsApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ExtensionsApplication.class, args);\n    }\n}\n\n@Component\nclass ReflectionRunner implements ApplicationRunner {\n    \n    private final ObjectMapper objectMapper ;\n\n    ReflectionRunner(ObjectMapper objectMapper) {\n        this.objectMapper = objectMapper;\n    }\n\n    record Customer(Integer id, String name) {\n    }\n\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        var json = \"\"\"\n                [\n                 { \"id\" : 2, \"name\": \"Dr. Syer\"} ,\n                 { \"id\" : 1, \"name\": \"Jürgen\"} ,\n                 { \"id\" : 4, \"name\": \"Olga\"} ,\n                 { \"id\" : 3, \"name\": \"Violetta\"}  \n                ]\n                \"\"\";\n        var result = this.objectMapper.readValue(json, new TypeReference&gt;() {\n        });\n        System.out.println(\"there are \" + result.size() + \" customers.\");\n        result.forEach(System.out::println);\n    }\n}\n\n@Component\nclass ResourceRunner implements ApplicationRunner {\n\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        var resource = new ClassPathResource(\"Log4j-charsets.properties\");\n        Assert.isTrue(resource.exists(), () -&gt; \"the file must exist\");\n        try (var in = new InputStreamReader(resource.getInputStream())) {\n            var contents = FileCopyUtils.copyToString(in);\n            System.out.println(contents.substring(0, 100) + System.lineSeparator() + \"...\");\n        }\n    }\n}\n\n@Component\nclass ProxyRunner implements ApplicationRunner {\n\n    private static Animal buildAnimalProxy(Supplier greetings) {\n        var pfb = new ProxyFactoryBean();\n        pfb.addInterface(Animal.class);\n        pfb.addAdvice((MethodInterceptor) invocation -&gt; {\n            if (invocation.getMethod().getName().equals(\"speak\"))\n                System.out.println(greetings.get());\n\n            return null;\n        });\n        return (Animal) pfb.getObject();\n    }\n\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        var cat = buildAnimalProxy(() -&gt; \"meow!\");\n        cat.speak();\n\n        var dog = buildAnimalProxy(() -&gt; \"woof!\");\n        dog.speak();\n    }\n\n    interface Animal {\n        void speak();\n    }\n}\n</code></p><p></p><p>这个样例包含了三个ApplicationRunner实例，Spring应用在启动的时候会运行它们。每个Bean都会做一些让GraalVM Native Image感觉不爽的事情。但是，在JVM上，它们能够很好地运行：mvn spring-boot:run。</p><p></p><p>第一个ApplicationRunner，即ReflectionRunner，会读取JSON数据并使用反射将它的结构映射到一个Java类Customer上。它无法正常运行，因为Native Image将会移除Customer类。使用mvn -Pnative -DskipTests clean package构建应用，并使用./target/extensions运行它。我们将会看到“com.oracle.svm.core.jdk.UnsupportedFeatureError: Proxy class defined by interfaces”这样的错误。</p><p></p><p>我们可以使用@TypeHint注解来修复该问题。添加如下的内容到ExtensionsApplication类上：</p><p><code lang=\"java\">@TypeHint(types =  ReflectionRunner.Customer.class, access = { TypeAccess.DECLARED_CONSTRUCTORS, TypeAccess.DECLARED_METHODS })\n</code></p><p></p><p>在这里，我们声明我们希望对ReflectionRunner.Customer的构造器和方法进行反射访问。对于不同类型的反射，还有其他的TypeAccess值。</p><p></p><p>第二个ApplicationRunner，即ResourceRunner，会从classpath下某个依赖的.jar中加载文件。它也无法正常运行，并且会提示“java.lang.IllegalArgumentException: the file must exist”这样的错误。原因在于该文件位于其他的.jar中，而不是在我们的应用代码中。如果文件位于src/main/resources中的话，加载资源是可以正常运行的。我们可以使用@ResourceHint注解来解决这个问题。将如下的内容添加到ExtensionsApplication类中：</p><p><code lang=\"java\">@ResourceHint(patterns = \"Log4j-charsets.properties\", isBundle = false)\n</code></p><p></p><p>第三个ApplicationRunner，即ProxyRunner，创建了一个JDK代理。代理会创建相关类型的子类或实现类。Spring支持两种类型的代理，即JDK代理和AOT代理。JDK代理仅限于使用Java java.lang.reflect.Proxy的接口。AOT代理则是Spring特有的，并不是JRE的一部分。JDK代理通常是给定具体类的子类，也可能是接口。Native Image需要知道我们的代理要使用哪些接口和具体类。</p><p></p><p>继续将第三个应用编译为原生可执行文件。Native Image将会给出一条友好的错误信息“com.oracle.svm.core.jdk.UnsupportedFeatureError: Proxy class defined by interfaces”，并且会列出所有Spring试图要代理的接口。请注意这些类型：com.example.extensions.ProxyRunner.Animal、org.springframework.aop.SpringProxy、org.springframework.aop.framework.Advised和org.springframework.core.DecoratingProxy。我们将会使用它们为ExtensionsApplication添加如下的线索：</p><p><code lang=\"java\">@JdkProxyHint(types = {\n    com.example.extensions.ProxyRunner.Animal.class,\n    org.springframework.aop.SpringProxy.class,\n    org.springframework.aop.framework.Advised.class,\n    org.springframework.core.DecoratingProxy.class\n})\n</code></p><p></p><p>如果你现在尝试构建（mvn -DskipTests -Pnative clean package）并运行（./target/extensions）样例的话，就不会有任何问题了。</p><p></p><h2>构建期和运行期的Processor</h2><p></p><p>Spring有很多的Processor实现。Spring Native提供了一些新的Processor接口，它们只会在构建期激活。这些Processor会动态地为构建过程提供线索信息。理想情况下，这些Processor的实现会位于一个可重用的库中。访问Spring Initializr，将项目命名为processors，并添加Spring Native。在IDE中打开生成的项目，在pom.xml文件中移除build节点，这样会删除所有的Maven插件配置。接下来，我们需要手动添加一个新的库：</p><p><code lang=\"java\"> \n  org.springframework.experimental\n  spring-aot\n  ${spring-native.version}\n  provided\n\n</code></p><p></p><p>Maven构建会生成一个常规的Java “.jar”制品，我们可以像对待任意Maven “.jar”那样对其进行安装和部署：mvn -DskipTests clean install。</p><p></p><p>这个新的库会引入新的类型，包括：</p><p></p><p>BeanFactoryNativeConfigurationProcessor：它在构建期的行为等同于BeanFactoryPostProcessorBeanNativeConfigurationProcessor：它在构建期的行为等同于BeanPostProcessor</p><p></p><p>我发现自己大多数时候都在和这两个接口打交道。在每个接口中，我们都可以得到一个可供探测的引用以及一个注册表的引用，我们据此能够以编程的方式向注册表中贡献线索内容。如果使用BeanNativeConfigurationProcessor，我们会得到一个bean元数据的实例，它代表了bean factory中的一个bean。如果使用BeanFactoryNativeConfigurationProcessor的话，我们会得到对整个BeanFactory本身的引用。需要注意的是，我们只能使用bean的名称和BeanDefinition实例，无法使用真正的bean。BeanFactory能够知道所有在运行时会存在的对象，但是它此时还没有实例化它们。相反，它的作用是帮助我们理解运行中的应用中bean的样子，比如类、方法等，以便于得到适当的线索信息。</p><p></p><p>我们不能以常规Spring bean的形式来注册这些Processor类型，而是要在spring.factories服务加载器中进行注册。所以，鉴于BeanFactoryNativeConfigurationProcessor的实现名为com.example.nativex.MyBeanFactoryNativeConfigurationProcessor，BeanNativeConfigurationProcessor的实现名为com.example.nativex.MyBeanNativeConfigurationProcessor，spring.factories文件如下所示：</p><p><code lang=\"java\">org.springframework.aot.context.bootstrap.generator.infrastructure.nativex.BeanFactoryNativeConfigurationProcessor=\\\n  com.example.nativex.MyBeanFactoryNativeConfigurationProcessor\norg.springframework.aot.context.bootstrap.generator.infrastructure.nativex.BeanNativeConfigurationProcessor=\\\n  com.example.nativex.MyBeanNativeConfigurationProcessor\n</code></p><p></p><p>借助这些Processor类型，我们可以很容易地在Spring Native应用中消费集成功能或库。我写了一个库（<a href=\"https://search.maven.org/artifact/com.joshlong/hints/0.0.1/jar\">com.joshlong:hints:0.0.1</a>\"），里面包含了各种集成功能（如Kubernetes Java客户端、Fabric8 Kubernetes Java客户端、Spring GraphQL、Liquibase等），这些集成功能不大适合放到官方的Spring Native版本中。目前这就是一个大杂烩，但结果是很酷的：只要把相关的功能添加到classpath中，就像Spring Boot的自动配置一样，我们就会得到一个很棒的结果!</p><p></p><h2>更多信息</h2><p></p><p>我希望你能够从这个关于Spring Native原生可执行文件的简单介绍中有所收获。请继续关注<a href=\"https://spring.io/blog\">Spring博客</a>\"和我的<a href=\"https://twitter.com/starbuxman\">Twitter (@starbuxman)</a>\" ，以获取更多信息。</p><p></p><p>作者简介：</p><p>Josh Long（Twitter为@starbuxman）是第一个Spring开发者倡导者，始于2010年。Josh是一个Java Champion，写了6本图书（包括O'Reilly的“Cloud Native Java: Designing Resilient Systems with Spring Boot, Spring Cloud, and Cloud Foundry”和“Reactive Spring”）和制作了许多畅销的视频培训（包括与Spring Boot联合创始人Phil Webb合作的“Building Microservices with Spring Boot Livelessons”），并且是开源贡献者（Spring Boot、Spring Integration, Spring Cloud、Activiti和Vaadin等）、播客（“A Bootiful Podcast”）和YouTuber。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/native-java-spring-boot/\">Go Native with Spring Boot and GraalVM</a>\"</p>",
    "publish_time": "2022-07-05 09:51:42",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "激动人心！2022开放原子全球开源峰会报名火热开启！",
    "url": "https://www.infoq.cn/article/d04ff8abd72bf21d254dbe2fc",
    "summary": "<p>开源不仅仅是一种技术，更是一种引领发展和变革的理念，连接全球开发者共享知识、共建技术。在全球经济数字化转型的浪潮中，鼓励全球开放、合作、创新的开源软件生态发挥着举足轻重的作用。</p><p></p><p>当前，开源已覆盖软件开发的全领域场景，正在构建新的软件技术创新体系，引领新一代信息技术创新发展，全球 97% 的软件开发者和 99% 的企业使用开源软件，基础软件、工业软件、新兴平台软件大多基于开源，开源软件已经成为软件产业创新源泉和“标准件库”。开源开辟了产业竞争新赛道，基于全球开发者众研众创的开源生态正加速形成。</p><p></p><p>2022 年 7 月 25-27 日，北京亦创国际会展中心，聚焦开源技术与产业生态融合趋势的国际盛会 —— 2022 开放原子全球开源峰会即将盛大开幕，诚邀您报名参与！</p><p></p><p>本次峰会以“软件定义世界，开源共筑未来”为主题，立足中国，面向世界，聚集国内外顶级开源基金会/开源社区负责人、开源意见领袖、开源企业代表、优秀开源企业用户、顶尖开源开发者，为全球开源爱好者们带来一场产业技术盛宴。</p><p><img src=\"https://static001.geekbang.org/infoq/c2/c2d151a384e87f6180b6c0ecf7196edd.jpeg\" /></p><p></p><p>报名通道现已开启，火热报名</p><p><a href=\"https://openatom.cn/summit\">https://openatom.cn/summit</a>\"</p><p>电脑端请访问官网，立即报名</p><p></p><p>峰会议程（拟）</p><p><img src=\"https://static001.geekbang.org/infoq/60/6002e655930e3b96648ac0001c59acff.jpeg\" /></p><p></p><p>峰会简介</p><p>由工业和信息化部、北京市人民政府、国家发展和改革委员会、商务部、国家互联网信息办公室、中国科学技术协会共同主办的 2022 全球数字经济大会将于 7 月底在北京举行。作为六大峰会之一，由开放原子开源基金会和北京市经济和信息化局承办的 2022 开放原子全球开源峰会，将紧扣开源主题，秉持国际视野，突出科技特色，促进业态繁荣，全面助力开源赋能数字经济高质量发展。</p><p></p><p>2022 开放原子全球开源峰会将由一场隆重的开幕式和主论坛，10 余个精彩的开源主题分论坛，持续 2 天的“源博荟”开源展览和 2 场开源之夜互动交流活动组成。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/31/31877370272263be0059cd9a10c7e512.jpeg\" /></p><p></p><p>开放征集：</p><p>诚邀您与我们共同开源共建（议题申报、峰会共建），探索中国开源繁荣生态的未来！</p><p>联系我们</p><p>2022开放原子全球开源峰会组委会</p><p>2022summit@openatom.org</p><p></p>",
    "publish_time": "2022-07-05 11:49:20",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "明势资本徐之浩：资本寒冬才是创业的黄金时代 | TGO 专访",
    "url": "https://www.infoq.cn/article/88BkU5dscTTrJ3ZG5dlV",
    "summary": "<p>嘉宾介绍：徐之浩，明势资本执行董事，TGO 鲲鹏会（北京）学员，所在小组北京 26 组已获得“2022 年度十全十美小组”称号。</p><p></p><p>曾先后供职于 Microsoft、Baidu、Weibo、Amazon Web Services 等公司，担任软件工程师、研发经理、产品经理等职位。自 2017 年底加入投资行业以来，徐之浩一直致力于寻求和帮助科技驱动的软硬件公司发展。</p><p><img src=\"https://static001.geekbang.org/infoq/d8/d8b479a6c49c38b2cc5c198b8671aa25.jpeg\" /></p><p>“2022 年度十全十美小组”北京 26 组莅临 TGO 鲲鹏会总部，徐之浩/右三</p><p></p><p>从技术老兵到风险投资，徐之浩属于半路出家，但这也决定了他是一位有着很强技术、产品专业背景的投资人。</p><p></p><p>现在他是明势资本执行董事，明势是一家从早期便陪伴理想汽车、小牛电动、云鲸机器人、神策数据、酷家乐、PingCAP 等一批科技公司成长的 VC 机构。徐之浩和其它软件组成员在企业服务、云计算与开源软件、全真互联网等领域持续深耕。</p><p></p><p>对于当下的资本寒冬，徐之浩认为，经过寒冬“洗礼”的创业者往往更扎实、更接近商业本质。只有那些坚韧不拔、逆流而上的创业团队，才有可能在今后的创业马拉松长跑中胜出；对于投资机构亦是如此，“潮水退去才知谁在裸泳”。资本寒冬会天然的过滤掉一批“裸泳”的团队，让机构更聚焦于优质项目的筛选；同时，当下更低的估值也有助于今后“潮水涌来”时获取更可观的回报。</p><p></p><p></p><h3>资本寒冬下的创业真相</h3><p></p><p></p><p>如果说创业者都是翻山越岭的行者，那资本寒冬下的创业者则是敢于翻越雪山的勇士。在大环境不利的背景下，创业者依然对自己要做的事情笃定不移，那么很有可能他要做的事情是真的很有价值，甚至可能对行业、对世界产生深远的影响。据徐之浩介绍，从历史统计来看，越是资本寒冬时进行创业，成功的机率越大；越是资本浮躁时创业，成功的百分比反而更低。某种意义上讲，雪山阻吓弱者、筛选强者，是勇士天然的盟友。</p><p></p><p>当然，向雪山进发前，一定要在身体、装备、补给等方面做好更加充足的准备。对于这种依旧笃定的创业者，一定要提前把市场、产品、商业模式、投入节奏等各环节进行更完备的打磨，多和潜在客户聊一聊、和创业前辈聊一聊、和资本圈朋友聊一聊。在充分地打磨之后，就要敢于亮剑、勇于出来创业。徐之浩认为，资本寒冬下，正是创业者勇敢行为能够获得产品和市场成功的好时候。</p><p></p><p>资本回归理性，从客观上提高了创业门槛，让一大波为了创业而创业的搅局者快速离场，为健康的创业环境提供保障。在此背景下，如果创业项目具有足够的价值，在资本市场获得的比较优势反而会更加巨大。对于那些务实的创业者而言，“寒冬”反而是公司化茧成蝶的好机会。</p><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/53/53f35ff5e99314dad53b7346708cdc48.png\" /></p><p>对于已经在创业路上的创始人，徐之浩认为现在反倒应该冷静一些，留意公司现金流，做好资本寒冬还会持续一段时间的准备。在融资上，不要过于纠结估值和条款，并尽量提前为下一轮融资做好更充足的准备。借此时机，创始人也有必要对公司的业务范围、商业模式和团队情况进行一次整体检视，利用危机推进变革，学会在“寒冬”中“强健体魄”。</p><p></p><p>资本寒冬是资本的理性回归，也是检验创业者综合竞争力的试金石。伟大的公司一定会经历过很多经济周期和资本寒冬，只有穿越过周期，还能保持成长的企业，才叫伟大企业。只要没有在困难面前倒下，那么每个困难都将成为成长的台阶。创业如此，投资亦如此。只有在逆境中不断付出，未来才有可能抓住更多更好的机会。</p><p></p><p></p><h3>To B 赛道正迎来长期趋势</h3><p></p><p></p><p>普通的运动爱好者，往往只靠自己；但专业运动员，往往会需要营养师、理疗师和私人医生。企业也是同理，如果只是做 60-70 分的初级产品，往往不需要专业的 To B 服务；但当企业希望在价值链上实现攀升，需要做 80-90 分的高附加值产品时，它就会有大量专业服务的需求。To B 服务相当于企业的外援，帮助其迈向更高端。</p><p></p><p>据徐之浩介绍，过去两百年的商业发展，让欧美企业占据了全球产业链上的高端位置，所以欧美的企业服务市场已然非常发达。当我们看世界上最顶级的企业，如苹果、特斯拉等，都有大量专业服务的需求，甚至会围绕这些企业诞生庞大的产业链条。这些 To B 服务商的存在，使得客户企业能持续提高自身效率、专注核心领域创新。</p><p></p><p>对于中国市场，改革开放后几十年中国企业的发展相对粗放，靠着庞大的市场红利和人口红利就能快速发展，因此对于采用外援的紧迫度往往不高。如今随着种种红利接近吃完、员工成本和获客成本不断上涨，留在低端产业已不再是长久之计，必定有相当数量的企业要往高端探索。再加上社会分工愈发专业化、市场竞争更为激烈，大量企业都会有创新、提效、降本的诉求，使得 To B 企业的红利期真正到来。</p><p></p><p>除了贴近企业场景的 To B SaaS 赛道，徐之浩表示，明势资本也非常坚信中国会诞生一批专注在底层技术领域的世界级公司，包括消耗大量算力并有云化预期的 PaaS 平台、人人都在重复制造的“轮子”、新兴硬件平台拉动的配套 PaaS 软件、满足新兴场景需求的数据处理工具等。</p><p></p><p>比如在数据库领域，中国优秀企业已有能力获得全球最苛刻的头部客户的认可，基础软件出海已成趋势。“不仅仅是数据库领域，中国其他很多基础软件或者工具软件领域，我们相信接下来也会一幕幕上演相似的剧情。”</p><p></p><p></p><h3>找到生死之交的 VC 机构</h3><p></p><p></p><p>创业企业与投资机构永远是一个双向选择的关系，优秀的创业者只有选对合适的投资机构，后续的发展道路才会更加顺畅。而创业者获得的不仅仅是资本，更多的是资源支持和长期陪伴。</p><p></p><p>在徐之浩看来，像资源对接、战略梳理、人才引进、客户介绍等日常的帮助都只是基本功。“投资机构与创业团队是长期的战友关系，而真正的战友情分是生死之交 – 在困境中仍愿意倾力相助。”很多现在大家耳熟能详的明星企业，过去都经历过鲜为人知的至暗时刻，如果不是投资机构与创业团队同心协力，可能企业早就不存在了。</p><p></p><p>据徐之浩介绍，明势资本所投资的企业，也同样出现过类似的情况，他们会一直陪着创始人约见国内外投资机构；机构都不敢下手，就继续去见高净值的个人投资人。整个过程也许会持续几个月，直至最终完成融资。</p><p></p><p>对于核心成员离开的企业，他们会帮助委派同样专业的人员协助创始人打理业务、并积极物色人员，直至新的、合适的候选人入职……“黎明到来前总会经历黑暗，对创业者而言，VC 机构的雪中送炭远比锦上添花更显珍贵。”</p><p></p><p>作为创业投资生态链最重要的一环，VC 机构在整个行业的发展过程中扮演了非常关键的角色，成为很多企业成功道路上的助推器。</p><p></p><p>资本寒冬的背景下，虽然 VC 机构“出手”标准在提高，但像明势这样的机构仍在积极的对潜在标的进行发掘和尽调，积极性丝毫没有减弱。特别是 To B 领域的创业企业，他们成长的周期较长，只要处于正确的发展轨道上，且团队足够坚定，就有机会做大。</p><p></p><p>“回顾历史，很多优秀创业公司都是在此背景下诞生的，我们没有理由不持续投资。”徐之浩表示，创业者也要学着在环境不利的背景下苦练内功、扎实打好技术、服务的基本功，从客户需求出发、回归商业本质，并学会向资本借力，就一定可以让自己稳稳地走下去。</p><p></p><p>凛冬已至，春风不远！</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ea/ea7fb0f57ed91eb9861b5a6fa4260b1c.jpeg\" /></p><p></p><p>Q&amp;A</p><p>Q：在接触企业时，您与财务性投资人相比，在观察视角方面有哪些不一样？</p><p></p><p>A：首先，现在 To B 方向的科技企业创始人，绝大部分具有产品、技术背景。我和明势的其它同事多是产业出身、明势创立者黄明明先生还是科技领域的连续创业者，所以我们对于创始人要做的事情可以更快速的理解，更容易和创始人“聊到点上”，特别是在一些技术属性较强的领域；</p><p></p><p>其次，有些观点认为技术是技术、商业是商业，但我觉得不是这样的。因为很多产品的商业价值，很大程度上就是它的技术特性创造出来的；有时候产品的技术特点，就决定了其适用的商业场景。具有产业背景的投资人，能够更好地去评估企业的商业潜力、甚至帮助企业发掘自身的商业价值；</p><p></p><p>最后，产业背景出身的投资人，也能在投后阶段能更好地帮助到创业公司。因为更懂在做的事情，所以知道什么时候帮忙、该怎么帮忙。能够更深入地和创始人探讨业务，也有更相关的一些产业人脉可以介绍给被投公司。</p><p></p><p>Q：您认为有哪些特质的技术人，可以向投资人转变？</p><p></p><p>A：我相信技术人都很优秀，确实有很多技术背景的人转行投资的，而且还能做得很好。综合来看，有以下两点是比较重要的：</p><p></p><p>第一是敢于冒险和快速学习能力，技术领域工资优渥、机会众多，转行毕竟是从头再来、成败的可能性都有，愿不愿承担潜在的风险和快速学习和迭代是很关键的；第二是好奇心，始终保持好奇心、时刻保持开放的形态，才能够跟上市场的步伐，这对于投资同样重要。</p><p></p><p>Q：明势资本成功投资了一批处在早期阶段的优秀创业企业，请问我们是如何挖掘这些企业的？</p><p></p><p>A：最关键的是明势资本愿意去探索一些市场还没有形成共识的领域，而不是在形成共识后“跟风”。比如，在理想汽车早期时，整个电动车市场都被大量质疑、而理想的增程式方案更是被广泛唱衰；神策数据创业初期，中国企业软件市场尚且一片混沌、而神策对私有化部署的支持更是被戏谑为“开历史倒车”。</p><p></p><p>现在大家看起来很多理所应当的事情，往往在当时都没有形成市场共识、甚至是有很大怀疑的。明势资本希望通过自己的研究，能够更早看清一些行业方向，并在市场未达成共识的时候去下注支持。另外就是要与行业一线的专家成为朋友，了解最一手的行业趋势，而不是仅仅是看滞后的公开研报。包括加入像 TGO 鲲鹏会这样的组织，学员们背景相通、意趣相投，不仅能更好地了解行业信息，也能在讨论中互相促进、碰撞火花。</p><p></p><p></p><h4>关于 TGO 鲲鹏会</h4><p></p><p></p><p>TGO 鲲鹏会是极客邦旗下科技领导者聚集和交流的组织，学员由 CTO、架构师、技术 VP、具有技术背景的 CEO 等组成，目前已经在北京、上海、深圳、广州、杭州、成都、硅谷、南京、台北、厦门、武汉、苏州等 12 个城市定期举办学习活动。</p><p></p><p>TGO 鲲鹏会采用了“学员共建”的组织形式，希望通过“共建、自治”的方式维护各城市的健康发展，为学员提供必要的服务，帮助学员个人更好地学习和成长，助力学员企业之间更好地合作与交流。加入 TGO 鲲鹏会，全方位提升自身价值，成为卓越科技领导者！</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/4c/4c5129d041d7023b2c328ccaa1b96277.png\" /></p><p></p>",
    "publish_time": "2022-07-05 14:02:25",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "BizDevOps：数字化转型浪潮下的技术破局之路",
    "url": "https://www.infoq.cn/article/Ag8boEIavbwBDd67aCLz",
    "summary": "<p>阿里云、南京大学、Thoughtworks、InfoQ产学研界6位领军人物，共同探讨数字化转型浪潮下的技术变局，并寻找破局之道。</p>",
    "publish_time": "2022-07-05 14:58:49",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "华为夏季新品发布会：鸿蒙手机应用全部“上车”",
    "url": "https://www.infoq.cn/article/jV3UbfT6Iyti95koSfBD",
    "summary": "<p>7月4日，华为全场景新品夏季发布会在深圳举行，重磅推出手机新品nova 10、智能穿戴、全屋智能等一系列终端新品。</p><p></p><p>华为终端BG首席运营官何刚透露，截至目前nova系列手机全球用户已突破2亿。同时，他宣布，华为正式推出全新自主影像品牌——XMAGE。</p><p></p><p>华为于2016年开始推出nova系列手机，主打影像能力，定位偏年轻人群体。此次发布的nova10 Pro在前置摄影能力上较为突出，其搭载业界首发的前置6000万全焦段追焦双摄，这也是目前手机前置摄像头中像素最高的配置，并搭载100度超广角，支持4K画质，同时也拥有业界首发的前置QPD全像素精准对焦技术。</p><p></p><p>继与徕卡的合作结束之后，华为推出了自己的移动影像品牌“华为影像XMAGE”。华为方面表示，华为影像的技术创新和拍摄体验创新，将主要围绕光学系统、成像技术、图像处理等领域展开。</p><p></p><p>其中，光学系统以多项核心技术为代表，如多摄像头系统、潜望式长焦、自由曲面镜头等；成像技术是一个光电转换的交汇中心，包含RYYB超感光传感器、全像素八核对焦、10通道多光谱传感器、超光谱影像等。图像处理则是在算法层面的集合，包括了AI摄影、实时HDR融合、XD Fusion Pro计算摄影、XD Optics计算光学等技术。</p><p></p><p>此次发布会还正式推出了华为全屋智能2.0。华为相关负责人介绍道，2.0版本的主要亮点体现在两方面：</p><p></p><p>一是交互革新。在中控屏交互上进行升级，中控屏家族不仅新增桌面中控屏，而且更新了UX界面。用户可以通过子空间选择希望控制的生活空间，通过子场景根据意图触发离家、睡眠、观影等高频场景，子系统控制将同类设备进行归纳收拢。二是空间解锁。推出全新的后装解决方案，可以覆盖后装多户型，新发布的智能主机EZ作为全屋互联中枢，采用有线+无线双网架构，能够实现全屋网络统一管理，不仅免去布线与破墙的烦恼，同时支持一键批量配网和场景导入，最快当天装当天用。</p><p></p><p>事实上，在发布会当天最备受瞩目的还属新车发布——华为与小康股份旗下赛力斯共同打造的AITO品牌的第二款车型问界M7正式亮相。华为常务董事、终端业务CEO、智能汽车解决方案BU首席执行官余承东宣布，AITO首款车型问界M5在上市第87天已累计销量破万，成为成长最快的智能电动汽车品牌之一。</p><p></p><p>余承东强调华为不造车，要帮助车企造好车、卖好车，通过ICT技术的赋能，在“智选”模式下缔造AITO品牌的商业成功。</p><p></p><p>华为与车企之间的合作模式分为三种，一种是作为上游的零部件供应商；一种是HI模式，华为和车企如北汽新能源旗下的极狐一起打造智能座舱、自动驾驶等；华为与小康集团之间的合作属于第三种——智选模式，在此模式下，双方合力打造的新品牌AITO应运而生，华为深度参与产品定义、功能设定、营销服务，而小康集团除了与华为联合进行产品开发，还负责制造和交付。</p><p></p><p>据介绍，新发布的问界M7搭配楼层识别技术、360度全景自动泊车、自定义车位选择、精准车位信息识别以及停车障碍物预警功能。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ec/ec8b27d187ac2ce591c2abb56bfd0c87.jpeg\" /></p><p></p><p>“所有鸿蒙手机应用全部上车，全球仅此一家。”此次M7搭载的HarmonyOS智能座舱也迎来大版本升级，新增的超级桌面功能不仅可让手机应用直达车机，用户还可通过车机大屏来操作手机。在系统运行方面，鸿蒙智能座舱继承了华为终端流畅的特点。问界M7具备多设备互联能力，其中的Petal Maps导航能够在不同设备间无缝流转，一键同步位置信息，完成车机导航。</p><p></p><p>余承东说，AITO汽车拥有强大的生产能力，可实现快速交付，现拥有以工业4.0标准打造的全新凤凰工厂，连同两江智慧工厂，其年产量将达到30万台。</p>",
    "publish_time": "2022-07-05 16:40:17",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]