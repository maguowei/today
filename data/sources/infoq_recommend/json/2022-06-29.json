[
  {
    "title": "C#警告波预示未来将增加新的关键字",
    "url": "https://www.infoq.cn/article/Eo9Qz2YRk7xRAVGJdWh8",
    "summary": "<p>与C# 9和10一样，C# 11也悄悄地增加了一个新的编译器警告。该警告可以防止使用全部小写的类型名称（如类、结构和接口）。</p><p>&nbsp;</p><p>创建这个警告是为了方便微软在未来添加新的关键字。C#的关键只包含小写ASCII字母，因此，加入其他任何字母都可以防止类型名称与未来的关键字发生冲突。</p><p>&nbsp;</p><p><a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/warning-waves#cs8981---the-type-name-only-contains-lower-cased-ascii-characters\">该警告的文档</a>\"并没有详细说明他们正在考虑引入哪些关键字。</p><p></p><h3>背景</h3><p></p><p>C#工具链一直将其信息分为三大类：编译器错误、编译器警告和静态分析警告。错误会妨碍编译器正常工作。当这些错误发生时，基本上是在说，编译器检测到了不容忽视的问题。</p><p>&nbsp;</p><p>另一类是编译器警告。这意味着存在明显的问题，但编译器仍然可以生成一个输出文件。编译器警告默认是启用的，但开发者可以忽略。另外，开发者也可以要求把它们当作错误处理。</p><p>&nbsp;</p><p>最后一类基本上包含“其他一切”。静态分析错误可能只有在特定类型的应用程序甚至是应用程序的特定部分中才算是问题。它们比编译器警告更容易产生误报，也就是不恰当的警告。与其他类型的警告不同，静态分析警告默认是不启用的。在Roslyn编译器推出之前，它们是一个完全独立的工具的一部分。所以，有相当多的开发者从来没有用过它们。</p><p>&nbsp;</p><p>历史上，微软一直不愿意增加新的编译器警告。因为它们是默认启用的，添加新警告被认为是一种破坏性变化。如果添加了新的警告并启用了TreatWarningsAsErrors，那么在C#7中可以编译的代码在C#8中可能会无法编译。</p><p>&nbsp;</p><p>从C# 9开始，微软增加了<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/warning-waves\">C#警告波（Warning Waves）</a>\"的概念。这是些附加的编译器警告，也就是说，不需要额外安装一个工具或包，它们默认是不启用的。要使用它们，则必须将项目文件中的<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/errors-warnings#analysis-level\">AnalysisLevel</a>\"设置为5或者更高。</p><p></p><p>作者简介：</p><p>Jonathan Allen从90年代末开始就为一家健康诊所建设MIS项目，帮他们从Access和Excel升级到企业解决方案。在花了五年时间编写金融业自动交易系统后，他成为各种项目的顾问，包括机器人仓库UI、癌症研究软件的中间层以及一家大型房地产保险公司的大数据需求。在空闲时间，他喜欢研究源于16世纪的武术，并从事相关写作。</p><p>&nbsp;</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2022/06/CSharp-Warning-Wave/\">C# Warning Waves Hint at New Keywords in the Future</a>\"</p>",
    "publish_time": "2022-06-29 08:51:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "谷歌最新Imagen AI在文本至图像生成方面优于DALL-E",
    "url": "https://www.infoq.cn/article/QhKzahCQ9bdTgAUobYUg",
    "summary": "<p>来自<a href=\"https://research.google/teams/brain/\">谷歌大脑团队</a>\"的研究人员发布了<a href=\"https://imagen.research.google/\">Imagen</a>\"，这是一个文本至图像的AI模型，它能够通过给定的文本描述生成该场景下逼真的图像。Imagen在COCO基准上的表现要优于<a href=\"https://openai.com/dall-e-2/\">DALL-E 2</a>\"，并且与很多类似的模型不同，它只对文本数据进行了预训练。</p><p></p><p>发布在arXiv上的论文描述了该<a href=\"https://arxiv.org/abs/2205.11487\">模型和多个实验</a>\"。Imagen使用Transformer语言模型将输入的文本转换成一个嵌入式向量的序列。然后，连续的三个扩散模型（diffusion model）会将这些嵌入式的向量转换成1024x1024像素的图片。作为其成果的一部分，该团队开发了名为<a href=\"https://en.wikipedia.org/wiki/U-Net\">U-Net</a>\"的改进型扩散模型，以及适用于文本至图像模型的新基准套件DrawBench。按照COCO基准，Imagen的zero-shot&nbsp;<a href=\"https://en.wikipedia.org/wiki/Fr%C3%A9chet_inception_distance\">FID</a>\"得到了7.27分，超过了之前表现最好的DALL-E 2模型。研究人员还讨论了其工作潜在的社会影响，指出：</p><p></p><p></p><blockquote>我们开发Imagen的主要目标是推进生成方法（generative method）的研究，使用文本到图像的合成作为一个测试平台。尽管生成方法的终端用户在很大程度上不在这个范围之内，但是我们意识到该研究的潜在下游应用是多种多样的，并且可能会以很复杂的方式影响社会……在未来的工作中，我们将会探索一个负责任的外部化框架，以平衡外部审计的价值和不受限制的开放访问的风险。</blockquote><p></p><p></p><p>近年来，一些研究人员已经在探索训练多模式（multimodal）的AI模型，也就是在不同类型的数据上操作系统，比如文本和图像。在2021年，OpenAI发布了<a href=\"https://openai.com/blog/clip/\">CLIP</a>\"，这是一个深度学习模型，能够将文本和图像映射到相同的嵌入空间中，让用户判断文本描述是否与给定的图像匹配。该模型在很多计算机视觉任务中被证明是有效的，OpenAI还用它创建了<a href=\"https://www.infoq.com/news/2021/02/openai-gpt-image/\">DALL-E</a>\"模型，它能够通过文本描述生成逼真的图像。CLIP以及类似的模型都是在图像-文本组合的数据集上进行训练，这些数据都是从互联网上搜集而来，类似于InfoQ今年早些时候报道的<a href=\"https://www.infoq.com/news/2022/05/laion-5b-image-text-dataset/\">LAION-5B</a>\"数据集。</p><p></p><p>谷歌团队没有使用图像-文本数据集来训练Imagen，而是简单地使用了“现成的”文本编码器<a href=\"https://github.com/google-research/text-to-text-transfer-transformer\">T5</a>\"，将输入文本转换成嵌入式向量。为了将嵌入式向量转换成图像，Imagen使用了一系列的扩散模型。这些用于图像生成的AI模型使用了迭代的去噪过程，将Gaussian噪音转换成数据分布中的样本，在该情况下，也就是图像。去噪的条件是一些输入。在第一个扩散模型中，条件就是输入文本的嵌入式向量，该模型的输出是一个64x64像素的图像。该图像经过两个“超级分辨率”扩散模型的向上采样，将分辨率提升到了1024x1024。对于这些模型，谷歌开发了一个新的深度学习架构，叫做Efficient U-Net，它比以前的U-Net实现 “更简单，收敛更快，内存效率更高”。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/news/2022/06/google-brain-imagen/en/resources/1a-cute-corgi-lives-in-a-house-made-out-of-sushi-1653751745269.jpg\" /></p><p></p><p>“一只可爱的柯基犬住在用寿司做成的房子里”。图片来源：<a href=\"https://imagen.research.google/\">https://imagen.research.google</a>\"</p><p></p><p>除了在COCO校验集上评估Imagen之外，研究人员还开发了一个新的图像生成基准，即DrawBench。该基准由一系列<a href=\"https://docs.google.com/spreadsheets/d/1y7nAbmR4FREi6npB1u-Bo3GFdwdOPYJc617rBOxIRHY/edit#gid=0\">文本提示</a>\"组成，“旨在探测模型的不同语义属性”，包括组成、基数（cardinality）和空间关系。DrawBench使用人类评估员比较了两种不同的模型。首先，每个模型根据提示生成图像。然后，评估人员比较这两个模型的结果，指出哪个模型产生的图像更好。借助DrawBench，谷歌大脑团队将Imagen与DALL-E 2以及其他三个类似的模型进行了评估。团队发现，与其他模型相比，评委们“非常”喜欢Imagen生成的图像。</p><p></p><p>在Twitter上，谷歌的产品经理Sharon Zhou<a href=\"https://twitter.com/realSharonZhou/status/1528973014985224192\">讨论了这项成果</a>\"，她指出：</p><p></p><p></p><blockquote>一如既往，[结论]是我们需要不断扩大[大型语言模型]的规模</blockquote><p></p><p></p><p>在另一个主题推文中，谷歌大脑团队的负责人Douglas Eck发布了<a href=\"https://twitter.com/douglas_eck/status/1530259615878881282\">一系列由Imagen生成的图像</a>\"，这些图像都来自于同一个提示信息的不同变化形式，Eck通过添加词语来调整图像的风格、亮度和其他方面。在<a href=\"https://imagen.research.google/\">Imagen项目的网站</a>\"上还可以找到其他几个由Imagen所生成图像的样例。</p><p></p><p>作者简介：</p><p>Anthony是Genesys的开发总监，他从事与客户体验相关的多个AI和ML项目。他在设计和构建可扩展软件方面有着超过20年的经验。Anthony拥有电子工程博士学位，专业是智能机器人软件，曾在人与人工智能交互和SaaS业务优化的预测分析领域研究过各种问题。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2022/06/google-brain-imagen/\">Google's New Imagen AI Outperforms DALL-E on Text-to-Image Generation Benchmarks</a>\"</p>",
    "publish_time": "2022-06-29 09:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "字节跳动开源 Go HTTP 框架 Hertz 设计实践",
    "url": "https://www.infoq.cn/article/l1KUimTRzb8wZ0ffNNoG",
    "summary": "<p></p><h2>前言</h2><p></p><p></p><p><a href=\"https://github.com/cloudwego/hertz\">Hertz </a>\"是字节跳动服务框架团队研发的超大规模的企业级微服务 HTTP 框架，具有高易用性、易扩展、低时延等特点。在经过了字节跳动内部一年多的使用和迭代，如今已在 CloudWeGo 正式开源。</p><p></p><p>目前，Hertz 已经成为了字节跳动内部最大的 HTTP 框架，线上接入的服务数量超过 1 万，峰值 QPS 超过 4 千万。除了各个业务线的同学使用外，也服务于内部很多基础组件，如：函数计算平台 FaaS、压测平台、各类网关、Service Mesh 控制面等，均收到不错的使用反馈。</p><p></p><p>在如此大规模的场景下，Hertz 拥有极强的稳定性和性能，在内部实践中某些典型服务，如框架占比较高的服务、网关等服务，迁移 Hertz 后相比 Gin 框架，资源使用显著减少，CPU 使用率随流量大小降低 30%-60%，时延也有明显降低。</p><p></p><p>Hertz 坚持内外维护一套代码，为开源使用提供了强有力的保障。通过开源， Hertz 也将丰富云原生的 Golang 中间件体系，完善 CloudWeGo 生态矩阵，为更多开发者和企业搭建云原生化的大规模分布式系统，提供一种现代的、资源高效的的技术方案。</p><p></p><p>本文将重点关注 Hertz 的架构设计与功能特性。</p><p></p><h2>项目缘起</h2><p></p><p></p><p>最初，字节跳动内部的 HTTP 框架是对 Gin 框架的封装，具备不错的易用性、生态完善等优点。随着内部业务的不断发展，高性能、多场景的需求日渐强烈。而 Gin 是对 Golang 原生 net/http 进行的二次开发，在按需扩展和性能优化上受到很大局限。</p><p></p><p>因此，为了满足业务需求，更好的服务各大业务线，2020 年初，字节跳动服务框架团队经过内部使用场景和外部主流开源 HTTP 框架 Fasthttp、Gin、Echo 的调研后，开始基于自研网络库 Netpoll 开发内部框架 Hertz，让 Hertz 在面对企业级需求时，有更好的性能及稳定性表现，也能够满足业务发展和应对不断演进的技术需求。</p><p></p><h2>架构设计</h2><p></p><p></p><p>Hertz 设计之初调研了大量业界优秀的 HTTP 框架，同时参考了近年来内部实践中积累的经验。</p><p></p><p>为了保证框架整体上满足：1. 极致性能优化的可能性；2. 面对未来不可控需求的扩展能力， Hertz 采用了 4 层分层设计，保证各个层级功能内聚，同时通过层级之间的接口达到灵活扩展的目标。整体架构图如图 1 所示。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/f9/b8/f912528fe72fb25a1493040ce1fa07b8.jpg\" /></p><p></p><p>Hertz 从上到下分为：应用层、路由层、协议层和传输层，每一层各司其职，同时公共能力被统一抽象到公共层（common），做到跨层级复用。另外，同主库一同发布的还有作为子模块的 Hz 脚手架，它能够协助使用者快速搭建出项目核心骨架以及提供实用的构建工具链。</p><p></p><h4>应用层</h4><p></p><p></p><p>应用层是和用户直接交互的一层，提供丰富易用的 API，主要包括 Server、Client 和一些其他通用抽象。Server 提供了注册 HandlerFunc、Binding、Rendering 等能力；Client 提供了调用下游和服务发现等能力；以及抽象一个 HTTP 请求所必须涉及到的请求（Request）、响应（Response）、上下文（RequestContext）、中间件（Middleware）等等。Hertz 的 Server 和 Client 都能够提供中间件这样的扩展能力。</p><p></p><p>应用层中一个非常重要的抽象就是对 Server HandlerFunc 的抽象。</p><p></p><p>早期，Hertz 路由的处理函数 （HandlerFunc）中并没有接收标准的 context.Context，我们在大量的实践过程中发现，业务方通常需要一个标准的上下文在 RPC Client 或者日志、Tracing 等组件间传递，但由于请求上下文（RequestContext）生命周期局限于一次 HTTP 请求之内，而以上提到的场景往往存在异步的传递和处理，导致如果直接传递请求上下文，会导致出现一些数据不一致的问题。</p><p></p><p>为此我们做了诸多尝试，但是因为核心原因在于请求上下文（RequestContext）的生命周期无法优雅的按需延长，最终在各种设计权衡下，我们在路由的处理函数签名中增加一个标准的上下文入参，通过分离出生命周期长短各异的两个上下文的方式，从根本上解决各种因为上下文生命周期不一致导致的异常问题，即：</p><p></p><p><code lang=\"python\">type HandlerFunc func(c context.Context, ctx *app.RequestContext)</code></p><p></p><h4>路由层</h4><p></p><p></p><p>路由层负责根据 URI 匹配对应的处理函数。</p><p></p><p>起初，Hertz 的路由基于 httprouter 开发，但随着使用的用户越来越多，httprouter 渐渐不能够满足需求，主要体现在 httprouter 不能够同时注册静态路由和参数路由，即 /a/b，/:c/d 这两个路由不能够同时注册；甚至有一些更特殊的需求，如/a/b、/:c/b ，当匹配 /a/b 路由时，两个路由都能够匹配上。</p><p></p><p>Hertz 为满足这些需求重新构造了路由树，用户在注册路由时拥有很高的自由度：支持静态路由、参数路由的注册；支持按优先级匹配，如上述例子会优先匹配静态路由 /a/b ；支持路由回溯，如注册 /a/b、/:c/d，当匹配 /a/d 时仍然能够匹配上；支持尾斜线重定向，如注册 /a/b，当匹配 /a/b/ 时能够重定向到 /a/b 上。Hertz 提供了丰富的路由能力来满足用户的需求，更多的功能可以参考 Hertz 配置文档。</p><p></p><h4>协议层</h4><p></p><p></p><p>协议层负责不同协议的实现和扩展。</p><p></p><p>Hertz 支持协议的扩展，用户只需要实现下面的接口便可以按照自己的需求在引擎（Engine） 上扩展协议，同时也支持通过 ALPN 协议协商的方式注册。Hertz 首批只开源了 HTTP1 实现，未来会陆续开源 HTTP2、QUIC 等实现。协议层扩展提供的灵活性甚至可以超越 HTTP 协议的范畴，用户完全可以按需注册任意符合自身需求的协议层实现，并且加入到 Hertz 的引擎中来，同时，也能够无缝享受到传输层带来的极致性能。</p><p></p><p><code lang=\"python\">type ServerFactory interface {\n   New(core Core) (server protocol.Server, err error)\n}\n\ntype Server interface {\n   Serve(c context.Context, conn network.Conn) error\n}</code></p><p></p><h4>传输层</h4><p></p><p></p><p>传输层负责底层的网络库的抽象和实现。</p><p></p><p>Hertz 支持底层网络库的扩展。Hertz 原生完美适配 Netpoll，在时延方面有很多深度的优化，非常适合时延敏感的业务接入。Netpoll 对 TLS 能力的支持有待完善，而 TLS 能力又是 HTTP 框架必备能力，为此 Hertz 底层同时支持基于 Golang 标准网络库的实现适配，支持网络库的一键切换，用户可根据自己的需求选择合适的网络库进行替换。如果用户有更加高效的网络库或其他网络库需求，也完全可以根据需求自行扩展。</p><p></p><h4>Hz 脚手架</h4><p></p><p></p><p>与 Hertz 一并开源的还有一个易用的命令行工具 Hz，用户只需提供一个 IDL，根据定义好的接口信息，Hz 便可以一键生成项目脚手架，让 Hertz 达到开箱即用的状态；Hz 也支持基于 IDL 的更新能力，能够基于 IDL 变动智能地更新项目代码。目前 Hz 支持了 Thrift 和 Protobuf 两种 IDL 定义。命令行工具内置丰富的选项，可以根据自己的需求使用。同时它底层依赖 Protobuf 官方的编译器和自研的 Thriftgo 的编译器，两者都支持自定义的生成代码插件。如果默认模板不能够满足需求，完全能够按需定义。</p><p></p><p>未来，我们将继续迭代 Hz，持续集成各种常用的中间件，提供更高层面的模块化构建能力。给 Hertz 的用户提供按需调整的能力，通过灵活的自定义配置打造一套满足自身开发需求的脚手架。</p><p></p><h4>Common 组件</h4><p></p><p></p><p>Common 组件主要存放一些公共的能力，比如错误处理、单元测试能力、可观测性相关能力（Log、Trace、Metrics 等）。对于服务可观测性的能力，Hertz 提供了默认的实现，用户可以按需装配；如果用户有特殊的需求，也可以通过 Hertz 提供的接口注入。比如对于 Trace 能力，Hertz 提供了默认的实现，也提供了将 Hertz 和 Kitex 串起来的 Example。如果想注入自己的实现，也可以实现下面的接口：</p><p></p><p><code lang=\"python\">// Tracer is executed at the start and finish of an HTTP.\ntype Tracer interface {\n        Start(ctx context.Context, c *app.RequestContext) context.Context\n        Finish(ctx context.Context, c *app.RequestContext)\n}</code></p><p></p><h2>功能特性</h2><p></p><p></p><h4>中间件</h4><p></p><p></p><p>Hertz 除了提供 Server 的中间件能力，还提供了 Client 中间件能力。用户可以使用中间件能力将通用逻辑（如：日志记录、性能统计、异常处理、鉴权逻辑等等）和业务逻辑区分开，让用户更加专注于业务代码。Server 和 Client 中间件使用方式相同，使用 Use 方法注册中间件，中间件执行顺序和注册顺序相同，同时支持预处理和后处理逻辑。</p><p></p><p>Server 和 Client 的中间件实现方式并不相同。对于 Server 来说，我们希望减少栈的深度，同时也希望中间件能够默认的执行下一个，用户需要手动终止中间件的执行。因此，我们将 Server 的中间件分成了两种类型，即不在同一个函数调用栈（该中间件调用完后返回，由上一个中间件调用下一个中间件，如图 2 中 B 和 C）和在同一个函数调用栈的中间件（该中间件调用完后由该中间件继续调用下一个中间件，如图 2 中 C 和 Business Handler）。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/ec/58/ecf3ed884dc640ef02436263614ecc58.jpg\" /></p><p></p><p>其核心是需要一个地方存下当前的调用位置 index，并始终保持其递增。恰好 RequestContext 就是一个存储 index 合适的位置。但是对于 Client，由于没有合适的地方存储 index，我们只能退而求其次，抛弃 index 的实现，将所有的中间件构造在同一调用链上，需要用户手动调用下一个中间件。</p><p></p><h4>流式处理</h4><p></p><p></p><p>Hertz 提供 Server 和 Client 的流式处理能力。HTTP 的文件场景是十分常见的场景，除了 Server 侧的上传场景之外，Client 的下载场景也十分常见。为此，Hertz 支持了 Server 和 Client 的流式处理。</p><p></p><p>在内部网关场景中，从 Gin 迁移到 Hertz 后，cpu 使用量随流量大小不同可节省 30%-60% 不等，服务压力越大，收益越大。Hertz 开启流式功能的方式也很容易，只需要在 Server 上或 Client 上添加一个配置即可，可参考 CloudWeGo 官网 Hertz 文档的流式处理部分。</p><p></p><p>由于 Netpoll 采用 LT 的触发模式，由网络库主动将将数据从 TCP 缓冲区读到用户态，并存储到 buffer 中，否则 epoll 事件会持续触发。因此 Server 在超大请求的场景下，由于 Netpoll 持续将数据读到用户态内存中，可能会有 OOM 的风险。HTTP 文件上传场景就是一个典型的场景，但 HTTP 上传服务又是很常见的场景，因此我们支持标准网络库 go net，并针对 Hertz 做了特殊优化，暴露出 Read() 接口，防止 OOM 发生。</p><p></p><p>对于 Client，情况并不相同。流式场景下会将连接封装成 Reader 暴露给用户，而 Client 有连接池管理，那这样连接就多了一种状态，何时关连接，何时复用连接成了一个问题。由于框架侧并不知道该连接何时会用完，框架侧复用该连接不现实，会导致串包问题。由于 GC 会关闭连接，因此我们起初设想流式场景下的连接交由用户后，由 GC 负责关闭，这样也不会导致资源泄漏。但是在测试后发现，由于 GC 存在一定时间间隔，另外 TCP 中主动关闭连接的一方需要等待 2RTT，在高并发场景下会导致 fd 被打满的情况。最终我们提供了复用连接的接口，对于性能有场要求用户，在使用完连接后可以将连接重新放入连接池中复用。</p><p></p><h2>性能表现</h2><p></p><p></p><p>Hertz 使用字节跳动自研高性能网络库 Netpoll，在提高网络库效率方面有诸多实践，参考已发布文章字节跳动在 Go 网络库上的实践。除此之外，Netpoll 还针对 HTTP 场景进行优化，通过减少拷贝和系统调用次数提高吞吐以及降低时延。为了衡量 Hertz 性能指标，我们选取了社区中有代表性的框架 Gin（net/http）和 Fasthttp 作为对比，如图 3 所示。可以看到，Hertz 的极限吞吐、TP99 等指标均处于业界领先水平。未来，Hertz 还将继续和 Netpoll 深度配合，探索 HTTP 框架性能的极限。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/d3/9b/d3cf4da30e004376cbaeb919a792249b.jpg\" /></p><p></p><h2>一个 Demo</h2><p></p><p></p><p>下面简单演示一下 Hertz 是如何开发一个服务的。</p><p></p><p>1.首先，定义 IDL，这里使用 Thrift 作为 IDL 的定义（也支持使用 Protobuf 定义的 IDL），编写一个名为 Demo 的 service。这个服务有一个 API: Hello，它的请求参数是一个 query，响应是一个包含一个 RespBody 字段的 Json。</p><p></p><p><code lang=\"python\">// idl/hello.thrift\nnamespace go hello.example\n\nstruct HelloReq {\n    1: string Name (api.query=\"name\");\n}\n\nstruct HelloResp {\n    1: string RespBody;\n}\n\nservice HelloService {\n    HelloResp Hello(1: HelloReq request) (api.get=\"/hello\");\n}</code></p><p></p><p>2.接下来我们使用 hz 生成代码，并整理和拉取依赖</p><p></p><p><code lang=\"python\">$ hz new -idl idl/hello.thrift -mod Demo\n$ go mod tidy &amp;&amp; go mod verify</code></p><p></p><p>3.填充业务逻辑，比如我们返回 hello， ${Name}，那我们在biz/handler/example/hello_service.go 中添加以下代码即可</p><p></p><p><code lang=\"python\">// Hello .\n// @router /hello [GET]\nfunc Hello(ctx context.Context, c *app.RequestContext) {\n    var err error\n    var req example.HelloReq\n    err = c.BindAndValidate(&amp;req)\n    if err != nil {\n        c.String(400, err.Error())\n        return\n    }\n\n    resp := new(example.HelloResp)\n    resp.RespBody = \"hello, \" + req.Name\n    c.JSON(200, resp)\n}</code></p><p></p><p>4.编译并运行项目</p><p></p><p><code lang=\"python\">$ go build\n$ ./Demo</code></p><p></p><p>到现在一个简单的 Hertz 项目已经生成，下面我们来测试一下：</p><p></p><p><code lang=\"python\">$ curl http://localhost:8888/hello\\?name\\=Xiaoming\n// 如果看到以下返回说明服务已经正常启动起来啦\n$ {\"RespBody\":\"hello, Xiaoming\"}</code></p><p></p><p>（以上 demo 可以在 hertz-examples 中查看） 之后就可以愉快的构建自己的项目了。</p><p></p><h2>后记</h2><p></p><p></p><p>希望以上的分享能够让大家对 Hertz 有一个整体上的认识。同时，我们也在不断地迭代 Hertz、完善 CloudWeGo 整体生态。欢迎各位感兴趣的同学们加入我们，共同建设 CloudWeGo。</p><p></p><p>参考资料：</p><p>Hertz: https://github.com/cloudwego/hertz</p><p>Hertz Doc: https://www.cloudwego.io/zh/docs/hertz/</p><p>字节跳动在 Go 网络库上的实践: https://www.cloudwego.io/zh/blog/2021/10/09/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%9C%A8-go-%E7%BD%91%E7%BB%9C%E5%BA%93%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/</p>",
    "publish_time": "2022-06-29 10:02:41",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "出海之路百花齐放，行业新兵 F5 如何立足？",
    "url": "https://www.infoq.cn/article/TZfEsAPfdRcJHz8wLOVv",
    "summary": "<p>采访嘉宾：杜士峰、王志博</p><p>编辑：辛晓亮</p><p>&nbsp;</p><p>海外各行业对中国出口的需求变得越来越旺盛，出海之路百花齐放，但在陌生的环境下，如何正视、应对出海挑战，如何针对海外业务调整企业的技术架构，保证海内外客户一致的体验，都是大众所担心的问题。</p><p>&nbsp;</p><p>基于这些背景，InfoQ最近采访了F5负责出海解决方案的两位负责人，以下是部分采访速记，供大家参考。</p><p>&nbsp;</p><p>InfoQ：我个人理解当前国内企业出海需要具备以下几个条件，比如开源、上云、合规等，在您看来是什么样的情况呢，这中间又有哪些挑战？</p><p>&nbsp;</p><p>杜士峰：我加入 F5 之前在云公司工作，在这方面还是深有感触，关于你提到的这些确实都是中国的企业出海的时候需要特别关注的几个重要条件。</p><p>&nbsp;</p><p>首先我们现在可以看到，企业对于云原生架构（也可以说是你提到的开源）越来越热衷。现代应用的架构里仅确保企业更快地把应用推向市场，同时进行高频率的做迭代。但是现代应用 API 的调度、安全给企业的开发和运维也带来了新的挑战。过去传统应用使用前端+后端服务器的模式，现在多数应用之间都是通过大量 API 进行交互，那么 API 的暴露也会给管理和安全带来不小的挑战。</p><p>&nbsp;</p><p>第二点，上云这部分也是没有太多争议的。云技术帮助出海的企业在时间、成本、技术、管理上都得到很大的效率提升。以 F5 为例，F5 与全球包括 AWS、Azure、GCP 还有国内阿里云、腾讯云等云厂商都有比较紧密的合作。比较大的企业客户会同时使用多个公有云，那么多个云之间的连接、网络交付、运维安全策略的统一管理就是一个痛点。</p><p>&nbsp;</p><p>最后一点也是比较复杂的，就是法律法规和合规。遵守法律法规是出海企业在全球化过程中需要高度重视的。每个国家和地区在数据和业务上的法律法规要求都不尽相同。除了遵守法规之外，很重要的一点是数据的合规，数据是否按照 GDPR 进行本地环境的存储，是否对数据按安全级别进行分类，在数据账户的保护和数据泄漏相关的措施等等都是出海企业需要重点考虑的问题。</p><p>&nbsp;</p><p>法律的合规与监管是非常复杂的，以 F5 为例，主要的解决方案是两种：一是确保业务和流程合规，对当地的法律法规进行充分的解读，比如说金融行业的规范、医疗行业的规范、数据或等级保护的规范等等。第二就是在技术上要提供防护与反欺诈的方案，这些可以帮助企业提升防止数据泄露、账户欺诈业务损失等方面的能力。</p><p>&nbsp;</p><p>InfoQ：随着越来越多企业选择出海，公司的基础架构势必要针对新的业务进行升级，这中间会遇到哪些挑战，我们又该如何解决这些问题？</p><p>&nbsp;</p><p>杜士峰：关于你提到的这些问题我做过一些总结，在 IT 和业务层面，主要的挑战和关注点包括以下几个方面。第一是多云环境下统一的安全服务策略。第二是多云和边缘情况下的应用安全与应用交付。第三则是保证高可靠性的同时提供高性价比的服务，比如你是否有足够的全球化的网络支撑，是否有足够的弹性资源，是否有足够的基础设施确保你的高性价比。第四是传统应用和现代应用的问题，我们目前讨论比较多的是现代应用，同时现在仍有非常多的应用是基于传统的架构设计的，那么既要满足现代应用的交付和安全的管理，又要满足传统应用，对企业来说也是一个挑战。最后，怎么让出海应用在应用管理上更一体化、智能化也非常重要。</p><p>&nbsp;</p><p>王志博：关于解决方案，我可以做一些补充，从方案来讲 F5 一直在丰富全球的骨干网络，每周迭代适应来自不同应用的挑战，重点解决延时问题。同时跟海外比较多的公有云，Google、Azure 之间都有直连专线，整体延迟少于 10 毫秒。另外 F5 过去深耕于 WAF 、WAAP 领域，安全能力也比较强。此外，ISO9001、ISO27001 等标准认证包括 GDPR ，PCI DSS都是需要企业重点关注的。</p><p>&nbsp;</p><p>InfoQ：分布式云从 2019 年被提出来，连续两年被 Gartner 定义为云计算的重点发展方向，关于这方面您怎么看？</p><p>&nbsp;</p><p>杜士峰：我简单从趋势方面阐述一下。首先第一，毫无疑问 F5 一定会坚定的向成为 SaaS 公司的方向去发展，我们把 SaaS 作为 F5 在今后几大发展方向之一，其中一个是感知可控的应用；第二个是应用安全；第三，F5要成为一家 SaaS 公司。因为客户对上云的采纳率越来越高，同时对 SaaS 化的业务需求也越来越多。</p><p>&nbsp;</p><p>在分布式云服务平台的基础之上，我们提供客户的开发、提供客户的管理和运维，增强基于现代应用和传统应用的安全能力，再增强全球交付到边缘的网络，让 F5 能够在上面变成一个综合的服务平台，既迎合了技术的趋势，也满足客户在云的架构下，在业务到边缘的场景下对基础的应用交付，还有网络安全统一策略的能力和要求。所以整个分布式平台会是 F5 非常坚定追随的一个方向。</p><p>&nbsp;</p><p>InfoQ：是什么契机让 F5 瞄准出海市场？相比亚马逊与阿里云等云厂商，F5 的产品有哪些差异化的体现？</p><p>&nbsp;</p><p>杜士峰：首先 F5 在出海领域还是个新兵，过去 F5 的很多业务，大部分都在比较标准的行业里，比如金融、运营商、医疗、制造、汽车等等。为什么要做跨境出海的市场？因为我们看到宏观趋势上，最近十多年以来中国经济的发展、中国企业全球化的进程都在加快。我们很明显的感受到从云的角度，从技术前沿的角度看中国的出海企业从早期输出原材料、输出制造型的企业为主，到现在以品牌为核心的消费电子行业，和游戏、电商、音视频、社交娱乐、金融科技等不同的领域。可以说中国的出海企业在过去十多年的发展里面，到现在已经呈现出百花齐放的格局。</p><p>&nbsp;</p><p>同时，许多不同的企业，包括 TikTok、SHEIN、安克创新，甚至像小米、传音这些不同领域的企业逐渐成为全球领域的佼佼者。F5 在出海市场也是经过比较慎重的思考，过去，在数据中心领域或者传统应用领域，F5 毫无疑问一直是应用交付的领先厂商。最近几年 F5 的转型在加速，通过并购反欺诈领域的 Shape，边缘计算的 Volterra，和基于现代应用的 NGINX，丰富了 F5 从数据中心到云端、现代应用到边缘场景下的能力。让我们可以更好地把原来的应用交付和安全延伸到现在的客户，满足企业对 SaaS 化的需求。</p><p>&nbsp;</p><p>第二个问题，与亚马逊和阿里云等云厂商服务上的差异化。从我的角度来看，我提供一个不同层面的比较。事实上我们和亚马逊云科技和阿里云等厂商有非常好的互补关系。举例子云厂商好比是一个高速公路，客户每一个应用就像一辆汽车，可能有跑车、轿车，也有货车。汽车在高速公路上跑依然需要加油站维修、补给、餐饮的服务等等。F5 就好比高速公路的加油站，帮助客户在高速公路跑得更快的同时，跑得更稳健、更安全。</p><p>&nbsp;</p><p>InfoQ：刚才您说 F5 在出海方面还是个新兵，那么 F5 目前的定位主要在哪些方面，未来会有什么改变，是否可以分享一下建议给其他出海企业做参考？</p><p>&nbsp;</p><p>杜士峰：我简单分享一下 F5 视角的建议，希望可以给其他出海企业带来参考，F5 最重要的一点是重视来自于客户的需求、来自于客户的痛点，从满足客户、帮助客户解决他们在出海过程中所面临的挑战出发。</p><p>&nbsp;</p><p>首先 F5 在过去的 20 多年里面，我们具备在商用级别、企业级别的应用交付和应用安全。而随着客户新的需求变化，比如应用越来越现代化，比如以云原生的线路做开发，涉及到大量的开发的平台、开发的应用交付，包括运维，还有 API 的管理、API的调度，还有很重要的，涉及到当我们到边缘的时候，应用是不是能快速的到达边缘。再加上客户对合规和监管的要求越来越高，技术上既需要你提供服务的平台来满足 GDPR，满足 PCI，满足 ISO 这样的全球标准化的规范。同时对客户来讲，他们会受到大量的来自于恶意的流量攻击，为了确保合乎的体验，为了自己的运营效率比较要加强安全的能力。</p><p>&nbsp;</p><p>那么结合客户出海的这些问题，F5 或者说所有提供出海服务的企业要能够帮助客户在现代应用里，无论是应用交付还是应用安全上提供更优的解决方案。</p><p>&nbsp;</p><p>第二，企业客户需要将传统的应用向云上做迁移，基于云端做现代应用的开发。这可能会同时用到多个云的服务。如何确保客户在多云环境下，无论是本地的私有云还是多个公有云，甚至到边缘，他的应用交付、应用安全，统一的安全策略、统一的运维策略都能够更加简化。</p><p>&nbsp;</p><p>第三，企业基于现代化设计的应用，需要借助全球化的网络更灵活的、更开放的实现全球化的部署和管理，需要借助全球化既有的资源，让他的应用快速的本地服务策略，这些也是 F5 需要聚焦的重心。</p><p>&nbsp;</p><p>总结来说，F5 会聚焦三个领域。一是在现代应用，二是多云管理，三是应用交付网络。同时补充在应用安全，包括Bot反欺诈，WAF、API 的管理以及DDoS 上的防护能力。</p><p>&nbsp;</p><p>云已经铺好了高速公路，我们要做的就是给在云上在跑的应用带来更稳健、更安全的用户体验。</p><p>&nbsp;</p><p>采访嘉宾：</p><p>&nbsp;</p><p>杜士峰 F5中国区云与合作伙伴业务总经理</p><p>&nbsp;</p><p>王志博 F5中国区方案顾问</p>",
    "publish_time": "2022-06-29 14:51:01",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "2022 OpenCloudOS 社区开放日",
    "url": "https://www.infoq.cn/article/51Q5Z2RyvE6EygB4Fhik",
    "summary": "<p>“2022 OpenCloudOS 社区开放日” 作为社区成立后的首个活动，聚焦连接各行各业及操作系统上下游合作伙伴，活动期间不仅有重磅嘉宾亮相，还将全面而系统地介绍 OpenCloudOS 社区的定位、特色、初心、愿景和最新成果，并发布 OpenCloudOS 的新版本，同时特设圆桌讨论环节，邀请十余位嘉宾强强对话，共探国产操作系统领域新机会。</p>\n<p><img alt=\"\" src=\"https://static001.infoq.cn/resource/image/12/1d/124c89a0441d70dbe6dc0c6ac141471d.jpg\" /></p>",
    "publish_time": "2022-06-29 15:04:09",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Databricks 宣布将 Delta Lake 云数据平台完全开源",
    "url": "https://www.infoq.cn/article/8qjSlRVAx7k7K4apNisy",
    "summary": "<p>本周二，数据湖提供商 Databricks 表示正在开源所有 Delta Lake API，作为Delta Lake 2.0 版本发布计划的一部分。另外该公司还宣布将 Delta Lake 的所有增强功能贡献给 Linux 基金会。</p><p>&nbsp;</p><p>“从一开始，Databricks 就一直致力于开放标准和开源社区。”Databricks 的联合创始人兼首席执行官 Ali Ghodsi 说，“开放数据湖库正迅速成为企业处理数据的标准。Delta Lake、MLflow 和 Spark 都是这一数据架构的核心，我们很自豪能够在加速企业创新和采用方面尽自己的一份力量。”&nbsp;</p><p>&nbsp;</p><p>2019年6月，Databricks <a href=\"https://databricks.com/blog/2019/04/24/open-sourcing-delta-lake.html\">曾宣布</a>\"Delta Lake的开源，但显然不是全部开源。Cloudera、Microsoft、SAP、Snowflake等 Databricks 竞争对手通过质疑 Delta Lake 到底是开源还是专有软件的方式，夺走了一部分的潜在客户。分析师认为，通过完全开源，Databricks 正在消除客户的这种担忧和竞争性批评。</p><p>&nbsp;</p><p>随着数据湖市场上的商业开源项目越来越多，Databricks 可能会发现自己面临新的竞争，包括为超大型分析表提供高性能查询的 Apache Iceberg。这个领域的许多其他参与者都专注于 Apache Iceberg 作为 Delta Lake 表的替代品。</p><p>&nbsp;</p><p>一些其他企业也都开始推出 Apache Iceberg 商业化产品。随着这些产品的推出，数据湖市场开始分裂，技术人员有着多种选择，Delta Lake 面临着来自其他开源 Lakehouse 格式的压力。在竞争压力下，Databricks 表示 Delta Lake 2.0 将于今年晚些时候全面推出，预计将为数据分析提供更快的查询性能。</p><p>&nbsp;</p><p>查看更多：<a href=\"https://www.infoworld.com/article/3665117/databricks-open-sources-its-delta-lake-data-lake.amp.html\">https://www.infoworld.com/article/3665117/databricks-open-sources-its-delta-lake-data-lake.amp.html</a>\"</p>",
    "publish_time": "2022-06-29 16:22:46",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "如果你是一名程序员，其实是在拯救世界",
    "url": "https://www.infoq.cn/article/o4QLfRXTS7XC2HpJPLA0",
    "summary": "<p>程序员不是普通的人，每当他们坐下来写代码时，其实都是在从事着对人类文明的持续发展非常关键的工作。由于程序员的存在，人们的生活各个方面都发生了根本的改变，并且对美好的未来充满了憧憬。</p><p>&nbsp;</p><p></p><h2>技术</h2><p></p><p>&nbsp;</p><p>所有的道路、车辆、工厂和电力线路，包括整个世界的供应链，其实都是靠软件来支撑的。如果程序员一夜之间消失了，那我们就全得吃石头了。</p><p>&nbsp;</p><p>当然，你需要非程序员来做手工工作，但是如果我们拥有了机器人，这种工作就会停止。到那时，全世界的工人都会抛弃他们锈迹斑斑的工具，与我们一同进行智力活动，比如聆听 Bach（译注：西方古典音乐之父）的音乐。</p><p>&nbsp;</p><p></p><h2>生物学</h2><p></p><p>&nbsp;</p><p>普通人有着混乱的思维和本能，而程序员的思维却是井然有序的，如同编写好的代码。</p><p>&nbsp;</p><p>这是因为只有他们才能了解我们的代码，我们只不过是用我们的身体硬件来运行而已。</p><p>&nbsp;</p><p>有了这些知识，程序员就能控制自己的内分泌系统，所有的情感都会立刻被抑制，或者转变成行动或行为，以支撑他们的抽象工作。</p><p>&nbsp;</p><p>这在非程序员看来是非常遗憾的。但是，抽象给了一个丰富的内心世界，其乐趣远远大于现实世界。当你能想到一个 for-loop 的时候，那为什么还要闻到玫瑰呢？</p><p>&nbsp;</p><p></p><h2>政治学</h2><p></p><p>&nbsp;</p><p>在这个地球上，我们大多数时候都是动物，于是我们创造了语言，然后就是编程语言。最终，我们开始驯服人性这头野兽。</p><p>&nbsp;</p><p>有了这些代码，我们就能对任何情况进行建模，这样就能搞明白为什么会发生战争和饥荒，还有怎么防止这些事情发生。</p><p>&nbsp;</p><p>程序员的确会为未来着想。有一种普遍的错误观念，就是程序员们成天呆在计算机旁。但是，这仅仅是事实的一部分；他们还通宵在计算机上工作。</p><p>&nbsp;</p><p></p><h2>哲学</h2><p></p><p>&nbsp;</p><p>Ludwig Wittgenstein（译注：分析哲学创始人之一，语言哲学的奠基人）有句名言：“我的语言的极限就是我的世界的极限”，这对程序员来说尤其正确。</p><p>&nbsp;</p><p>当你可以用几行 JavaScript 创造任何你想要的现实时，那么你为何要生活在一个混乱的，不可预测的世界里呢？</p><p>&nbsp;</p><p>只有程序员才能实现像 Dalí 和 Joyce 那样的人所开创的理想：现实的崩溃，以及一个有序、完美的元宇宙的诞生。</p><p>&nbsp;</p><p>事实上，很多程序员都觉得只有自己才是真正活着的人，而我们这些人只不过是<a href=\"https://en.wikipedia.org/wiki/Philosophical_zombie\">哲学僵尸</a>\"，不知道发生了什么，只会走走过场，并没有把自己的潜能完全激发出来，Kant（译注：德国哲学家）就曾处理这个问题。</p><p>&nbsp;</p><p></p><h2>艺术</h2><p></p><p>&nbsp;</p><p>说到 Dalí（译注：西班牙画家），世界上所有的艺术家都只是还没有写过任何代码的程序员。</p><p>&nbsp;</p><p>人工智能的艺术工具，如 <a href=\"https://openai.com/dall-e-2/#demos\">DALL·E</a>\"，不久将会让剩余的艺术家们明白，除了编程之外，没有必要将自己的创造力浪费在其他方面上。</p><p>&nbsp;</p><p></p><h2>宗教</h2><p></p><p>&nbsp;</p><p>每一个重要的宗教都是由出生在计算机时代之前的程序员发起的。</p><p>&nbsp;</p><p>原因很简单：只有程序员可以穿透物质的幻觉，看见这个世界的真正面目：信息。作为证据，现实的像素就是<a href=\"https://en.wikipedia.org/wiki/Planck_units#Planck_length\">普朗克长度</a>\"，以及在<a href=\"https://www.quantamagazine.org/how-space-and-time-could-be-a-quantum-error-correcting-code-20190103/\">时间和空间中嵌入的量子计算机的代码</a>\"。</p><p>&nbsp;</p><p>大多数现代程序员是不可知的，因为他们知道，到那时，或许借助人工智能，他们将会编写一个 <a href=\"https://en.wikipedia.org/wiki/Prolog\">Prolog</a>\" 程序，向外输出有关神的存在的<a href=\"https://en.wikipedia.org/wiki/G%C3%B6del%27s_ontological_proof\">哥德尔本体论证明</a>\"，或者是 NULL。</p><p>&nbsp;</p><p></p><h2>编程</h2><p></p><p>&nbsp;</p><p>当然，还有编程本身。</p><p>&nbsp;</p><p>你把一条鱼送给一个人，他就会把这条鱼吃掉，而他也会死去。如果你教会一个人去垂钓，他学会怎么编程，就可以打造一个钓鱼机器人，从而可以活下去。</p><p>&nbsp;</p><p>不只是钓鱼，凡是能实现自动化的东西，最终都会实现。不久之后，人类就再也没有别的事情可做了，而这将使最终取代我们的人工智能霸主脸上露出笑容。</p><p>&nbsp;</p><p>所以，当你下次看到程序员时，一定要为他们的坚持不懈的工作表示感谢。我们对他们的感激之情无以复加。</p><p>&nbsp;</p><p>作者介绍：</p><p>&nbsp;</p><p>Sebastian Carlos，程序员，博主。</p><p>&nbsp;</p><p>原文链接：</p><p>&nbsp;</p><p>https://sebastiancarlos.medium.com/you-are-not-just-a-programmer-you-are-literally-saving-the-world-d2cff66c8c2d</p>",
    "publish_time": "2022-06-29 18:58:06",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "十年编程经历杂谈",
    "url": "https://www.infoq.cn/article/mBooHWbbweY5bKUlkZkO",
    "summary": "<p>本文最初发布于 Thorsten Ball 的个人博客，经原作者授权由 InfoQ 中文站翻译并分享。</p><p></p><p>截至2022年4月，我的职业程序员生涯已达10周年。</p><p></p><p>我接触编程的时间比这更早，只是那时没有赚工资。在十几岁时，我创建过网站和IRC机器人，并编写了简短的Python脚本。然后我停下来，弹了几年吉他。在我二十多岁的时候，在相当巧合的情况下，我再次发现了自己是多么喜欢编程。当时，我按照要求创建了另一个网站，并发现，在我离开的这段时间里，Web发生了很大的变化（现在是HTML5的了）。</p><p></p><p>于是我就想弄清楚，与继续在大学学习哲学相比，编程是否是更好的职业选择。<a href=\"https://coding-robin.de/\">Robin</a>\"为我回答了这个问题，他慷慨地给我提供了一个带薪实习的机会。</p><p></p><p>现在已经过去10年了，说实话，不管是对于我作为程序员的成长过程，还是对于我的职业生涯，这都不是一个重要的标志。但意识到已经过去10年了，我认为有必要停下来思考一下。</p><p></p><p>以下是我回顾过去10年时想到的一些散乱无序的想法。我学到的东西，我没有学到的东西，我改变了看法的东西，以及我从来没有想过我会相信现在却信了的东西。</p><p></p><p>在很大程度上，它们源于我参与软件开发的环境：作为Robin的实习生，作为<a href=\"https://de.wikipedia.org/wiki/Flinc\">德国一家小型创业公司</a>\"的软件开发人员，作为<a href=\"https://ioki.com/\">德国一家大型公司内部的创业公司</a>\"的高级软件开发人员，以及现在作为一家<a href=\"https://about.sourcegraph.com/\">完全远程、异步的美国创业公司</a>\"的资深工程师。接下来这句话就当作免责声明吧，我敢打赌，如果我是在游戏工作室、硬件公司和大型科技公司工作，这篇文章的内容会很不一样。</p><p></p><h2>大无畏精神的价值被低估了</h2><p></p><p></p><p>我作为学习榜样的大多数程序员都有一个很少被提及的特质：大无畏精神。</p><p></p><p>他们会毫无畏惧地钻入一个未知的代码库。他们会毫无畏惧地打开他们怀疑存在不正常依赖关系的代码。他们会在不知道如何完成的情况下开始工作。</p><p></p><p>看到别人无所畏惧非常令人鼓舞，但自己变得无所畏惧是我发现的最好的学习加速器之一。</p><p></p><h2>你无法预测未来；试一下可能给自己惹来麻烦</h2><p></p><p></p><p>我们都知道，未来不可预测。但我花了很多年才真正在编程时考虑这一点。</p><p></p><p>在我职业生涯的前三分之一，我会想：我们会需要这个的，所以让我们现在就构建它。在第二个三分之一，我会想：我们可能需要这个，所以让我们做好准备。现在，我会想：我们不知道我们是否会需要这个，这是一种可能性。当然，看起来我们可能需要，没错。但事情一直在变化，所以让我们构建现在已知需要的东西。</p><p></p><h2>编写的代码要易于测试</h2><p></p><p></p><p>编写代码时要秉持这样一个理念：我写代码不只是为了让计算机执行，我写代码也是为了让它易于阅读和理解，或易于删除，或易于修改，或易于审查。</p><p></p><h2>除了给客户带来价值外，没有什么是真正重要的</h2><p></p><p></p><p>类型安全、测试覆盖率100%、在代码中流畅表达业务逻辑的能力、完美的开发工具、不浪费资源的高效系统、在工作中使用最好的编程语言、优雅的API设计、快速反馈回路、编写良好的代码——这些都不是目标。</p><p></p><p>目标应该是：为你的客户提供价值，通过交付软件来解决他们的问题，不断重复这个过程。前面那些事可以帮助你做到这一点——更快、更便宜、更有效、更安全、更快乐——但它们不是目标。目标是为你的客户提供价值。</p><p></p><p>陷阱：编写软件往往比交付软件更容易。但是，交付才是最重要的。</p><p></p><h2>完美是不可能的</h2><p></p><p></p><p>我或许曾经认为那是可能的，但现在我确定那不可能。一切都是权衡的结果。</p><p></p><p>你永远无法在你关心的每个方面都达到100%。有些东西必须要让步。当你认为自己做到了完美，你很快就会意识到自己忘记了一些东西。</p><p></p><p>我的审美观也发生了变化。我现在不再寻求完美之美，而是认为尽管有缺陷但仍能成功的程序就是美。看看那个小程序吧，尽管里面有17个TODO，但它还是维系了互联网的发展。</p><p></p><h2>如果你不能把它与业务联系起来，那就无所谓了</h2><p></p><p></p><p>你可以重构一个代码库，对其进行大幅清理，使每个人都更容易理解，也让代码库更容易扩展，但如果该代码库在四个月后因为该项目对业务没有帮助而被删除，那么所有这些就都不重要了。</p><p></p><p>你可以花几周时间为你写的所有代码添加跟踪和可观察性，但你会意识到，没有人会去看，因为这些代码每天都会运行三次，而且从未引起任何问题。</p><p></p><p>你可以调整和优化代码，使其高效运行，以至于公司可以将运行代码所需的机器数量减半，尽管所节省的成本与你在优化时得到的工资相比显得微不足道。</p><p></p><p>你可以把时间花在绝妙的技术工作上，但那仍然是时间的浪费。</p><p></p><h2>弄清楚规则试图防止什么，然后考虑该规则的可选性</h2><p></p><p></p><p>如果你在5年前问我TDD、清洁代码、软件工匠精神和其他学派是否是教条主义，我会说：“不！你看不出来吗？干净、良好的代码很重要！”</p><p></p><p>现在，回过头来看，当我思考“一个方法不应该超过5行”这样的规则是否有用的时候，我摇了摇头。</p><p></p><p>这不是关于规则的问题！而是这些规则所要防止的问题。如果你没有规则试图防止的问题，或者你可以用另一种方式来防止它，那么你就不需要这个规则。</p><p></p><h2>编写测试让你可以相信系统能正常工作</h2><p></p><p></p><p>不要太在意一个测试是集成测试还是端到端测试，是单元测试还是功能测试。不要和别人争论是否应该测试私有方法。不要再为是否应该在测试中访问数据库费神。</p><p></p><p>相反，编写能让你知道系统是否能正常工作的测试。理想情况下，只需3次点击，并且在1秒钟内就可以完成。</p><p></p><p>关于这一点，我花了很长时间，做了很多无用的讨论，并以诸多代码缺陷为代价才学到。</p><p></p><h2>最佳实践通常是基于这样的假设：你知道代码应该做什么</h2><p></p><p></p><p>如果你确切地知道要构建什么，那么最佳实践和模式可以给你带来帮助，为你提供如何进行构建的建议。</p><p></p><p>但是，如果你还不知道这个程序应该做什么，或者它在四周后会是什么样子，那么有些最佳实践会使事情变得更加困难。</p><p></p><p>有些实践在重写时使用非常合适，但在探索时使用却非常糟糕。</p><p></p><h2>使用别人的代码并不像我想象的那么好</h2><p></p><p></p><p>我的职业生涯是从编写Ruby和JavaScript代码开始的，因为有包管理器可以使用，所以我总是会问，“难道没有一个包能做这个吗？”。</p><p></p><p>常识告诉我们：如果可以，尽量使用库，而不是自己编写。尽可能地重用代码。不要重新发明轮子。不要复制和粘贴。这是我多年来的信念。</p><p></p><p>但这也有弊端。有时候，自己写一个函数可能比添加一个依赖更好。</p><p></p><p>依赖是有成本的。你必须保持它们最新。它们会增加编译或加载时间。它们会在堆栈跟踪信息中添加奇怪的东西。而且，很多时候，它们所做的比你需要的多得多，这意味着你付出的比得到的多得多。</p><p></p><p>当你把别人的代码粘在一起的时候，有一个非常现实的危险，那就是胶水代码的复杂度会不断累积。但这是你最不希望复杂性存在的地方。它会隐藏复杂性。你所要做的是尽可能地让复杂性显露出来，并想办法消除。</p><p></p><p>有时候，自己写比用别人的代码更好。</p><p></p><h2>有些公司做到了，有些公司没做到，但没有谁是完美的</h2><p></p><p></p><p>为软件公司开发软件和为迫不得已雇用软件开发人员的公司开发软件之间有很大的区别。在一个领导层了解软件及其生产方式的公司工作是一件很快乐的事。</p><p></p><p>话虽如此，我不认为有哪家公司能解决所有问题。每家公司都有某种程度的发挥空间。</p><p></p><h2>在反馈回路上投入绝对不会白费功夫</h2><p></p><p></p><p>我从来没有后悔改进反馈回路。更快的测试，更好的测试输出，更快的部署，把一个手动的反馈回路变成一个可以一键反馈信号的东西。</p><p></p><p>不过要注意：一旦你看到软件开发可以具有真正快速、高效的反馈回路，你就会永远渴望它。</p><p></p><h2>总是在一天结束的时候留点未完成的事</h2><p></p><p></p><p>一个失败的测试，一个编译错误，一个未写完的语句，以其中某一项结束你的一天，第二天早上你就可以坐下来继续你的工作，完全跳过了“嗯，我今天应该做什么……”。</p><p></p><p>没有什么比一个需要通过的测试失败了更能让我快速开始。</p><p></p><h2>完美主义是个陷阱</h2><p></p><p></p><p>完美主义基于谎言。你永远无法做到完美。总会有一些东西差强人意。接受不完美的存在，交付并继续构建。</p><p></p><p>以80%为目标，将其他20%视为可选项。给自己留下可以自由呼吸的空间。你最终可能达到99%，谁知道呢？</p><p></p><h2>工欲善其事必先利其器</h2><p></p><p></p><p>我把大量的精力投入到了工具上：Vim、git、shells、Unix环境、测试框架。我真的很享受在Vim配置中度过一个周日的早晨。</p><p></p><p>但也有可能做得过头，陷入配置阶段无法自拔，做着无休止的修补工作。你必须先使用工具，然后才能知道如何配置和使用最好。</p><p></p><h2>招聘很难</h2><p></p><p></p><p>我现在已经做过数百次面试，我获得的最重要的见解是，招聘真的非常非常难。面试评价受很多随机因素影响，让人在“强烈同意”和“强烈反对”之间摇摆不定。</p><p></p><p>我常常希望有一种方法可以发现人们是否有“搞定”基因。</p><p></p><h2>开发人员最重要的特质：因为必须要完成，所以撸起袖子就干</h2><p></p><p></p><p>所有我喜欢的人都有一个共同点：他们做工作任劳任怨。他们知道有些任务并不好玩，也不刺激，更不有趣。但因为必须有人去做，所以他们就做。</p><p></p><h2>在一段比较长的时间内与其他人一起在同一个代码库上工作</h2><p></p><p></p><p>与一群人在同一个代码库中工作多年，没有什么能比这个更能帮助我提升软件工程方面的水平了。</p><p></p><p>你会看到决策是如何进行的。</p><p></p><p>你会看到最终哪些事情是重要的，哪些不重要。</p><p></p><p>当你的同事在你写完代码3年后试图修改它时，你会看到你代码真正的可扩展性。</p><p></p><p>你会看到你的预测——我们现在有2个，但我肯定将来会有5个——是否会变成现实，并在做其他预测时考虑这个结果。</p><p></p><p>会有些代码让你后悔，也会有其他一些代码让你感到高兴。反思这两者的区别，你就可以学习提升。</p><p></p><p>你会看到工具出故障，只是因为某个地方的某个东西发生了变化，虽然与你无关，但你仍然要修复。</p><p></p><p>对于软件的某些部分，你会说“我三年来从未考虑过这个问题”，并把它们视为珍宝。</p><p></p><p>你会看到代码库中有哪些部分新同事很难理解，哪些部分他们马上就会有收获。</p><p></p><p>你会看到你编写的代码在4年后是什么样子。</p><p></p><h2>了解全栈</h2><p></p><p></p><p>对我来说，很少有什么事情能像听到“你并不一定需要知道它是如何工作的 ”这句话那样让我备受激励。</p><p></p><p>当然，我可能不需要，但如果我没有设法理解GC的工作原理，或Unix的工作原理，或多线程的工作原理，或数据库如何存储数据，或解释器和编译器如何工作，我就无法做到今天这个程度。</p><p></p><p>这对我的工作也有好处。我可以做出更好的技术决策，因为我能够更准确地权衡取舍，知道底层发生了什么。</p><p></p><h2>打字可能成为瓶颈</h2><p></p><p></p><p>我<a href=\"https://thorstenball.com/blog/2020/09/01/typing-can-be-the-bottleneck\">之前说过</a>\"。不要让打字成为瓶颈。</p><p></p><h2>代码审查并非密不透风</h2><p></p><p></p><p>在很长一段时间里，如果我在代码审查时漏掉了Bug，我就会认为这是我的错。我漏掉了！我怎么会漏掉呢？如此明显的Bug！</p><p></p><p>后来我发现，不仅仅是我：其他人在代码审查也会漏掉Bug。事实上，他们已经接受了这种情况，并且毫无顾忌地说，代码审查并非无懈可击。我松了一口气。</p><p></p><p>这改变了我对代码审查的看法：它是一种不完美的东西，需要与其他方式相结合来验证代码。</p><p></p><h2>并非每次代码审查都是值得的</h2><p></p><p></p><p>并非每条代码都需要进行彻底地审查。有时候，如果风险可接受，那么快速扔下一句 “LGTM!”就可以了。这可以释放同事的潜能，保持势头，潜移默化地建立信任。</p><p></p><h2>消极滋生消极</h2><p></p><p></p><p>如果你屈服于消极，那么你就会越来越消极。你得到的总是比你想要的多得多。</p><p></p><p>它是病毒式的。它始于讽刺，然后变成愤世嫉俗，最终演变为“一切都很糟糕”。不久之后，无论做什么事情都要问“为什么要这么做？”久而久之，人们会对你隐瞒兴奋、喜悦和想法。</p><p></p><p>做一个消极的人太容易了。我认为，在某种程度上，指着什么说它的坏处，然后耸耸肩说，我早就料到这不是什么好事（每件事都是坏事，对吗？）这很容易做到，也很容易被误认为是一种能够发现缺陷和最坏情况的工程思维（其实不是这样的）。</p><p></p><p>困难的是看到事物的本来面目，看到它们的美好之处。对别人的想法给予鼓励，即使它们几乎没有什么可谈的东西。创造和培育快乐。这很有挑战性。</p><p></p><p>所以，最终在某个时候，我决定克服消极，并试图做有挑战的事情。到目前为止，这对我很有帮助。</p><p></p><h2>你无法什么都做百分之百</h2><p></p><p></p><p>我不可能一直把所有事情都做得同样好。我不能一边写书，一边在事业上取得进展，一边做一个伟大的父亲，一边在健身房里创造记录，还一边读着两本书。这种状态维持不了一两个星期。这是不可持续的。</p><p></p><p>现在，我会在重要的事情之间做好切换：当我想在一件特定的事情上取得进展时，我就会在一段时间内专注于这件事情，并接受其他事情必须进入保持模式。</p><p></p><h2>代码是有重量的</h2><p></p><p></p><p>代码是有重量的。你不需要的每一行代码都是压舱物，它会增加代码库的重量，这会让你更难掌控和改变方向。你需要的代码越少越好。</p><p></p><p>代码必须易于阅读，必须经过测试，必须保持兼容，必须保持安全，必须可以工作。即使它现在没有做任何有用的工作，有它在身边也无妨，不是吗？不是的。务必删除它并继续前进。如果有必要，从版本控制中恢复即可。</p><p></p><p>对测试来说也是如此，我要是早知道就好了。</p><p></p><h2>编程是我生活的一部分</h2><p></p><p></p><p>自从开始做实习生以来，我在工作之外花了相当多的时间在编程上：阅读技术书籍，写书，做业余项目，写博客文章，做讲座，去参加会议，学习新语言和工具。</p><p></p><p>有一些公司并不关心你的大学学位，只要你能证明你真的很擅长编程，这是我多年来的动力。</p><p></p><p>我喜欢在工作之外花时间进行编程，但不是所有时间。有些感觉像是工作。有些技术书籍读起来很耗费精力。但就是有些事情在做的时候感觉不是很好。</p><p></p><p>如果我只在白天的工作中编程和学习编程知识，那么我的职业生涯将完全不同。</p><p></p><h2>计算机速度很快</h2><p></p><p></p><p>构建Web应用程序使我认为100毫秒很快，50毫秒是真的快。编写编译器让我知道，对于现代计算机来说，1毫秒就是永恒。</p><p></p><h2>我还是那么喜欢编程</h2><p></p><p></p><p>我写的一些内容可能会被说成是我多年来变得愤世嫉俗。我的意思是“什么都不重要，完美不可能实现”吗？</p><p></p><p>不，恰恰相反。我有在意的事情，而且非常在意，只是在意的事情比之前少了，但我还是那么喜欢编程。</p><p></p><p>欢迎在Twitter上关注我（<a href=\"https://twitter.com/thorstenball\">@thorstenball</a>\"），或者给我发邮件（<a href=\"mailto:me@thorstenball.com\">me@thorstenball.com</a>\"），或者在<a href=\"https://interpreterbook.com/\">interpreterbook.com</a>\"和<a href=\"https://compilerbook.com/\">compilerbook.com</a>\"网站上阅读我写的书。</p><p></p><p>查看英文原文：<a href=\"https://thorstenball.com/blog/2022/05/17/professional-programming-the-first-10-years\">Professional Programming: The First 10 Years</a>\"</p>",
    "publish_time": "2022-06-29 19:12:43",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]