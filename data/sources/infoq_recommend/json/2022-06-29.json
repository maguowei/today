[
  {
    "title": "C#警告波预示未来将增加新的关键字",
    "url": "https://www.infoq.cn/article/Eo9Qz2YRk7xRAVGJdWh8",
    "summary": "<p>与C# 9和10一样，C# 11也悄悄地增加了一个新的编译器警告。该警告可以防止使用全部小写的类型名称（如类、结构和接口）。</p><p>&nbsp;</p><p>创建这个警告是为了方便微软在未来添加新的关键字。C#的关键只包含小写ASCII字母，因此，加入其他任何字母都可以防止类型名称与未来的关键字发生冲突。</p><p>&nbsp;</p><p><a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/warning-waves#cs8981---the-type-name-only-contains-lower-cased-ascii-characters\">该警告的文档</a>\"并没有详细说明他们正在考虑引入哪些关键字。</p><p></p><h3>背景</h3><p></p><p>C#工具链一直将其信息分为三大类：编译器错误、编译器警告和静态分析警告。错误会妨碍编译器正常工作。当这些错误发生时，基本上是在说，编译器检测到了不容忽视的问题。</p><p>&nbsp;</p><p>另一类是编译器警告。这意味着存在明显的问题，但编译器仍然可以生成一个输出文件。编译器警告默认是启用的，但开发者可以忽略。另外，开发者也可以要求把它们当作错误处理。</p><p>&nbsp;</p><p>最后一类基本上包含“其他一切”。静态分析错误可能只有在特定类型的应用程序甚至是应用程序的特定部分中才算是问题。它们比编译器警告更容易产生误报，也就是不恰当的警告。与其他类型的警告不同，静态分析警告默认是不启用的。在Roslyn编译器推出之前，它们是一个完全独立的工具的一部分。所以，有相当多的开发者从来没有用过它们。</p><p>&nbsp;</p><p>历史上，微软一直不愿意增加新的编译器警告。因为它们是默认启用的，添加新警告被认为是一种破坏性变化。如果添加了新的警告并启用了TreatWarningsAsErrors，那么在C#7中可以编译的代码在C#8中可能会无法编译。</p><p>&nbsp;</p><p>从C# 9开始，微软增加了<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/warning-waves\">C#警告波（Warning Waves）</a>\"的概念。这是些附加的编译器警告，也就是说，不需要额外安装一个工具或包，它们默认是不启用的。要使用它们，则必须将项目文件中的<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/errors-warnings#analysis-level\">AnalysisLevel</a>\"设置为5或者更高。</p><p></p><p>作者简介：</p><p>Jonathan Allen从90年代末开始就为一家健康诊所建设MIS项目，帮他们从Access和Excel升级到企业解决方案。在花了五年时间编写金融业自动交易系统后，他成为各种项目的顾问，包括机器人仓库UI、癌症研究软件的中间层以及一家大型房地产保险公司的大数据需求。在空闲时间，他喜欢研究源于16世纪的武术，并从事相关写作。</p><p>&nbsp;</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2022/06/CSharp-Warning-Wave/\">C# Warning Waves Hint at New Keywords in the Future</a>\"</p>",
    "publish_time": "2022-06-29 08:51:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "谷歌最新Imagen AI在文本至图像生成方面优于DALL-E",
    "url": "https://www.infoq.cn/article/QhKzahCQ9bdTgAUobYUg",
    "summary": "<p>来自<a href=\"https://research.google/teams/brain/\">谷歌大脑团队</a>\"的研究人员发布了<a href=\"https://imagen.research.google/\">Imagen</a>\"，这是一个文本至图像的AI模型，它能够通过给定的文本描述生成该场景下逼真的图像。Imagen在COCO基准上的表现要优于<a href=\"https://openai.com/dall-e-2/\">DALL-E 2</a>\"，并且与很多类似的模型不同，它只对文本数据进行了预训练。</p><p></p><p>发布在arXiv上的论文描述了该<a href=\"https://arxiv.org/abs/2205.11487\">模型和多个实验</a>\"。Imagen使用Transformer语言模型将输入的文本转换成一个嵌入式向量的序列。然后，连续的三个扩散模型（diffusion model）会将这些嵌入式的向量转换成1024x1024像素的图片。作为其成果的一部分，该团队开发了名为<a href=\"https://en.wikipedia.org/wiki/U-Net\">U-Net</a>\"的改进型扩散模型，以及适用于文本至图像模型的新基准套件DrawBench。按照COCO基准，Imagen的zero-shot&nbsp;<a href=\"https://en.wikipedia.org/wiki/Fr%C3%A9chet_inception_distance\">FID</a>\"得到了7.27分，超过了之前表现最好的DALL-E 2模型。研究人员还讨论了其工作潜在的社会影响，指出：</p><p></p><p></p><blockquote>我们开发Imagen的主要目标是推进生成方法（generative method）的研究，使用文本到图像的合成作为一个测试平台。尽管生成方法的终端用户在很大程度上不在这个范围之内，但是我们意识到该研究的潜在下游应用是多种多样的，并且可能会以很复杂的方式影响社会……在未来的工作中，我们将会探索一个负责任的外部化框架，以平衡外部审计的价值和不受限制的开放访问的风险。</blockquote><p></p><p></p><p>近年来，一些研究人员已经在探索训练多模式（multimodal）的AI模型，也就是在不同类型的数据上操作系统，比如文本和图像。在2021年，OpenAI发布了<a href=\"https://openai.com/blog/clip/\">CLIP</a>\"，这是一个深度学习模型，能够将文本和图像映射到相同的嵌入空间中，让用户判断文本描述是否与给定的图像匹配。该模型在很多计算机视觉任务中被证明是有效的，OpenAI还用它创建了<a href=\"https://www.infoq.com/news/2021/02/openai-gpt-image/\">DALL-E</a>\"模型，它能够通过文本描述生成逼真的图像。CLIP以及类似的模型都是在图像-文本组合的数据集上进行训练，这些数据都是从互联网上搜集而来，类似于InfoQ今年早些时候报道的<a href=\"https://www.infoq.com/news/2022/05/laion-5b-image-text-dataset/\">LAION-5B</a>\"数据集。</p><p></p><p>谷歌团队没有使用图像-文本数据集来训练Imagen，而是简单地使用了“现成的”文本编码器<a href=\"https://github.com/google-research/text-to-text-transfer-transformer\">T5</a>\"，将输入文本转换成嵌入式向量。为了将嵌入式向量转换成图像，Imagen使用了一系列的扩散模型。这些用于图像生成的AI模型使用了迭代的去噪过程，将Gaussian噪音转换成数据分布中的样本，在该情况下，也就是图像。去噪的条件是一些输入。在第一个扩散模型中，条件就是输入文本的嵌入式向量，该模型的输出是一个64x64像素的图像。该图像经过两个“超级分辨率”扩散模型的向上采样，将分辨率提升到了1024x1024。对于这些模型，谷歌开发了一个新的深度学习架构，叫做Efficient U-Net，它比以前的U-Net实现 “更简单，收敛更快，内存效率更高”。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/news/2022/06/google-brain-imagen/en/resources/1a-cute-corgi-lives-in-a-house-made-out-of-sushi-1653751745269.jpg\" /></p><p></p><p>“一只可爱的柯基犬住在用寿司做成的房子里”。图片来源：<a href=\"https://imagen.research.google/\">https://imagen.research.google</a>\"</p><p></p><p>除了在COCO校验集上评估Imagen之外，研究人员还开发了一个新的图像生成基准，即DrawBench。该基准由一系列<a href=\"https://docs.google.com/spreadsheets/d/1y7nAbmR4FREi6npB1u-Bo3GFdwdOPYJc617rBOxIRHY/edit#gid=0\">文本提示</a>\"组成，“旨在探测模型的不同语义属性”，包括组成、基数（cardinality）和空间关系。DrawBench使用人类评估员比较了两种不同的模型。首先，每个模型根据提示生成图像。然后，评估人员比较这两个模型的结果，指出哪个模型产生的图像更好。借助DrawBench，谷歌大脑团队将Imagen与DALL-E 2以及其他三个类似的模型进行了评估。团队发现，与其他模型相比，评委们“非常”喜欢Imagen生成的图像。</p><p></p><p>在Twitter上，谷歌的产品经理Sharon Zhou<a href=\"https://twitter.com/realSharonZhou/status/1528973014985224192\">讨论了这项成果</a>\"，她指出：</p><p></p><p></p><blockquote>一如既往，[结论]是我们需要不断扩大[大型语言模型]的规模</blockquote><p></p><p></p><p>在另一个主题推文中，谷歌大脑团队的负责人Douglas Eck发布了<a href=\"https://twitter.com/douglas_eck/status/1530259615878881282\">一系列由Imagen生成的图像</a>\"，这些图像都来自于同一个提示信息的不同变化形式，Eck通过添加词语来调整图像的风格、亮度和其他方面。在<a href=\"https://imagen.research.google/\">Imagen项目的网站</a>\"上还可以找到其他几个由Imagen所生成图像的样例。</p><p></p><p>作者简介：</p><p>Anthony是Genesys的开发总监，他从事与客户体验相关的多个AI和ML项目。他在设计和构建可扩展软件方面有着超过20年的经验。Anthony拥有电子工程博士学位，专业是智能机器人软件，曾在人与人工智能交互和SaaS业务优化的预测分析领域研究过各种问题。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2022/06/google-brain-imagen/\">Google's New Imagen AI Outperforms DALL-E on Text-to-Image Generation Benchmarks</a>\"</p>",
    "publish_time": "2022-06-29 09:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "字节跳动开源 Go HTTP 框架 Hertz 设计实践",
    "url": "https://www.infoq.cn/article/l1KUimTRzb8wZ0ffNNoG",
    "summary": "<p></p><h2>前言</h2><p></p><p></p><p><a href=\"https://github.com/cloudwego/hertz\">Hertz </a>\"是字节跳动服务框架团队研发的超大规模的企业级微服务 HTTP 框架，具有高易用性、易扩展、低时延等特点。在经过了字节跳动内部一年多的使用和迭代，如今已在 CloudWeGo 正式开源。</p><p></p><p>目前，Hertz 已经成为了字节跳动内部最大的 HTTP 框架，线上接入的服务数量超过 1 万，峰值 QPS 超过 4 千万。除了各个业务线的同学使用外，也服务于内部很多基础组件，如：函数计算平台 FaaS、压测平台、各类网关、Service Mesh 控制面等，均收到不错的使用反馈。</p><p></p><p>在如此大规模的场景下，Hertz 拥有极强的稳定性和性能，在内部实践中某些典型服务，如框架占比较高的服务、网关等服务，迁移 Hertz 后相比 Gin 框架，资源使用显著减少，CPU 使用率随流量大小降低 30%-60%，时延也有明显降低。</p><p></p><p>Hertz 坚持内外维护一套代码，为开源使用提供了强有力的保障。通过开源， Hertz 也将丰富云原生的 Golang 中间件体系，完善 CloudWeGo 生态矩阵，为更多开发者和企业搭建云原生化的大规模分布式系统，提供一种现代的、资源高效的的技术方案。</p><p></p><p>本文将重点关注 Hertz 的架构设计与功能特性。</p><p></p><h2>项目缘起</h2><p></p><p></p><p>最初，字节跳动内部的 HTTP 框架是对 Gin 框架的封装，具备不错的易用性、生态完善等优点。随着内部业务的不断发展，高性能、多场景的需求日渐强烈。而 Gin 是对 Golang 原生 net/http 进行的二次开发，在按需扩展和性能优化上受到很大局限。</p><p></p><p>因此，为了满足业务需求，更好的服务各大业务线，2020 年初，字节跳动服务框架团队经过内部使用场景和外部主流开源 HTTP 框架 Fasthttp、Gin、Echo 的调研后，开始基于自研网络库 Netpoll 开发内部框架 Hertz，让 Hertz 在面对企业级需求时，有更好的性能及稳定性表现，也能够满足业务发展和应对不断演进的技术需求。</p><p></p><h2>架构设计</h2><p></p><p></p><p>Hertz 设计之初调研了大量业界优秀的 HTTP 框架，同时参考了近年来内部实践中积累的经验。</p><p></p><p>为了保证框架整体上满足：1. 极致性能优化的可能性；2. 面对未来不可控需求的扩展能力， Hertz 采用了 4 层分层设计，保证各个层级功能内聚，同时通过层级之间的接口达到灵活扩展的目标。整体架构图如图 1 所示。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/f9/b8/f912528fe72fb25a1493040ce1fa07b8.jpg\" /></p><p></p><p>Hertz 从上到下分为：应用层、路由层、协议层和传输层，每一层各司其职，同时公共能力被统一抽象到公共层（common），做到跨层级复用。另外，同主库一同发布的还有作为子模块的 Hz 脚手架，它能够协助使用者快速搭建出项目核心骨架以及提供实用的构建工具链。</p><p></p><h4>应用层</h4><p></p><p></p><p>应用层是和用户直接交互的一层，提供丰富易用的 API，主要包括 Server、Client 和一些其他通用抽象。Server 提供了注册 HandlerFunc、Binding、Rendering 等能力；Client 提供了调用下游和服务发现等能力；以及抽象一个 HTTP 请求所必须涉及到的请求（Request）、响应（Response）、上下文（RequestContext）、中间件（Middleware）等等。Hertz 的 Server 和 Client 都能够提供中间件这样的扩展能力。</p><p></p><p>应用层中一个非常重要的抽象就是对 Server HandlerFunc 的抽象。</p><p></p><p>早期，Hertz 路由的处理函数 （HandlerFunc）中并没有接收标准的 context.Context，我们在大量的实践过程中发现，业务方通常需要一个标准的上下文在 RPC Client 或者日志、Tracing 等组件间传递，但由于请求上下文（RequestContext）生命周期局限于一次 HTTP 请求之内，而以上提到的场景往往存在异步的传递和处理，导致如果直接传递请求上下文，会导致出现一些数据不一致的问题。</p><p></p><p>为此我们做了诸多尝试，但是因为核心原因在于请求上下文（RequestContext）的生命周期无法优雅的按需延长，最终在各种设计权衡下，我们在路由的处理函数签名中增加一个标准的上下文入参，通过分离出生命周期长短各异的两个上下文的方式，从根本上解决各种因为上下文生命周期不一致导致的异常问题，即：</p><p></p><p><code lang=\"python\">type HandlerFunc func(c context.Context, ctx *app.RequestContext)</code></p><p></p><h4>路由层</h4><p></p><p></p><p>路由层负责根据 URI 匹配对应的处理函数。</p><p></p><p>起初，Hertz 的路由基于 httprouter 开发，但随着使用的用户越来越多，httprouter 渐渐不能够满足需求，主要体现在 httprouter 不能够同时注册静态路由和参数路由，即 /a/b，/:c/d 这两个路由不能够同时注册；甚至有一些更特殊的需求，如/a/b、/:c/b ，当匹配 /a/b 路由时，两个路由都能够匹配上。</p><p></p><p>Hertz 为满足这些需求重新构造了路由树，用户在注册路由时拥有很高的自由度：支持静态路由、参数路由的注册；支持按优先级匹配，如上述例子会优先匹配静态路由 /a/b ；支持路由回溯，如注册 /a/b、/:c/d，当匹配 /a/d 时仍然能够匹配上；支持尾斜线重定向，如注册 /a/b，当匹配 /a/b/ 时能够重定向到 /a/b 上。Hertz 提供了丰富的路由能力来满足用户的需求，更多的功能可以参考 Hertz 配置文档。</p><p></p><h4>协议层</h4><p></p><p></p><p>协议层负责不同协议的实现和扩展。</p><p></p><p>Hertz 支持协议的扩展，用户只需要实现下面的接口便可以按照自己的需求在引擎（Engine） 上扩展协议，同时也支持通过 ALPN 协议协商的方式注册。Hertz 首批只开源了 HTTP1 实现，未来会陆续开源 HTTP2、QUIC 等实现。协议层扩展提供的灵活性甚至可以超越 HTTP 协议的范畴，用户完全可以按需注册任意符合自身需求的协议层实现，并且加入到 Hertz 的引擎中来，同时，也能够无缝享受到传输层带来的极致性能。</p><p></p><p><code lang=\"python\">type ServerFactory interface {\n   New(core Core) (server protocol.Server, err error)\n}\n\ntype Server interface {\n   Serve(c context.Context, conn network.Conn) error\n}</code></p><p></p><h4>传输层</h4><p></p><p></p><p>传输层负责底层的网络库的抽象和实现。</p><p></p><p>Hertz 支持底层网络库的扩展。Hertz 原生完美适配 Netpoll，在时延方面有很多深度的优化，非常适合时延敏感的业务接入。Netpoll 对 TLS 能力的支持有待完善，而 TLS 能力又是 HTTP 框架必备能力，为此 Hertz 底层同时支持基于 Golang 标准网络库的实现适配，支持网络库的一键切换，用户可根据自己的需求选择合适的网络库进行替换。如果用户有更加高效的网络库或其他网络库需求，也完全可以根据需求自行扩展。</p><p></p><h4>Hz 脚手架</h4><p></p><p></p><p>与 Hertz 一并开源的还有一个易用的命令行工具 Hz，用户只需提供一个 IDL，根据定义好的接口信息，Hz 便可以一键生成项目脚手架，让 Hertz 达到开箱即用的状态；Hz 也支持基于 IDL 的更新能力，能够基于 IDL 变动智能地更新项目代码。目前 Hz 支持了 Thrift 和 Protobuf 两种 IDL 定义。命令行工具内置丰富的选项，可以根据自己的需求使用。同时它底层依赖 Protobuf 官方的编译器和自研的 Thriftgo 的编译器，两者都支持自定义的生成代码插件。如果默认模板不能够满足需求，完全能够按需定义。</p><p></p><p>未来，我们将继续迭代 Hz，持续集成各种常用的中间件，提供更高层面的模块化构建能力。给 Hertz 的用户提供按需调整的能力，通过灵活的自定义配置打造一套满足自身开发需求的脚手架。</p><p></p><h4>Common 组件</h4><p></p><p></p><p>Common 组件主要存放一些公共的能力，比如错误处理、单元测试能力、可观测性相关能力（Log、Trace、Metrics 等）。对于服务可观测性的能力，Hertz 提供了默认的实现，用户可以按需装配；如果用户有特殊的需求，也可以通过 Hertz 提供的接口注入。比如对于 Trace 能力，Hertz 提供了默认的实现，也提供了将 Hertz 和 Kitex 串起来的 Example。如果想注入自己的实现，也可以实现下面的接口：</p><p></p><p><code lang=\"python\">// Tracer is executed at the start and finish of an HTTP.\ntype Tracer interface {\n        Start(ctx context.Context, c *app.RequestContext) context.Context\n        Finish(ctx context.Context, c *app.RequestContext)\n}</code></p><p></p><h2>功能特性</h2><p></p><p></p><h4>中间件</h4><p></p><p></p><p>Hertz 除了提供 Server 的中间件能力，还提供了 Client 中间件能力。用户可以使用中间件能力将通用逻辑（如：日志记录、性能统计、异常处理、鉴权逻辑等等）和业务逻辑区分开，让用户更加专注于业务代码。Server 和 Client 中间件使用方式相同，使用 Use 方法注册中间件，中间件执行顺序和注册顺序相同，同时支持预处理和后处理逻辑。</p><p></p><p>Server 和 Client 的中间件实现方式并不相同。对于 Server 来说，我们希望减少栈的深度，同时也希望中间件能够默认的执行下一个，用户需要手动终止中间件的执行。因此，我们将 Server 的中间件分成了两种类型，即不在同一个函数调用栈（该中间件调用完后返回，由上一个中间件调用下一个中间件，如图 2 中 B 和 C）和在同一个函数调用栈的中间件（该中间件调用完后由该中间件继续调用下一个中间件，如图 2 中 C 和 Business Handler）。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/ec/58/ecf3ed884dc640ef02436263614ecc58.jpg\" /></p><p></p><p>其核心是需要一个地方存下当前的调用位置 index，并始终保持其递增。恰好 RequestContext 就是一个存储 index 合适的位置。但是对于 Client，由于没有合适的地方存储 index，我们只能退而求其次，抛弃 index 的实现，将所有的中间件构造在同一调用链上，需要用户手动调用下一个中间件。</p><p></p><h4>流式处理</h4><p></p><p></p><p>Hertz 提供 Server 和 Client 的流式处理能力。HTTP 的文件场景是十分常见的场景，除了 Server 侧的上传场景之外，Client 的下载场景也十分常见。为此，Hertz 支持了 Server 和 Client 的流式处理。</p><p></p><p>在内部网关场景中，从 Gin 迁移到 Hertz 后，cpu 使用量随流量大小不同可节省 30%-60% 不等，服务压力越大，收益越大。Hertz 开启流式功能的方式也很容易，只需要在 Server 上或 Client 上添加一个配置即可，可参考 CloudWeGo 官网 Hertz 文档的流式处理部分。</p><p></p><p>由于 Netpoll 采用 LT 的触发模式，由网络库主动将将数据从 TCP 缓冲区读到用户态，并存储到 buffer 中，否则 epoll 事件会持续触发。因此 Server 在超大请求的场景下，由于 Netpoll 持续将数据读到用户态内存中，可能会有 OOM 的风险。HTTP 文件上传场景就是一个典型的场景，但 HTTP 上传服务又是很常见的场景，因此我们支持标准网络库 go net，并针对 Hertz 做了特殊优化，暴露出 Read() 接口，防止 OOM 发生。</p><p></p><p>对于 Client，情况并不相同。流式场景下会将连接封装成 Reader 暴露给用户，而 Client 有连接池管理，那这样连接就多了一种状态，何时关连接，何时复用连接成了一个问题。由于框架侧并不知道该连接何时会用完，框架侧复用该连接不现实，会导致串包问题。由于 GC 会关闭连接，因此我们起初设想流式场景下的连接交由用户后，由 GC 负责关闭，这样也不会导致资源泄漏。但是在测试后发现，由于 GC 存在一定时间间隔，另外 TCP 中主动关闭连接的一方需要等待 2RTT，在高并发场景下会导致 fd 被打满的情况。最终我们提供了复用连接的接口，对于性能有场要求用户，在使用完连接后可以将连接重新放入连接池中复用。</p><p></p><h2>性能表现</h2><p></p><p></p><p>Hertz 使用字节跳动自研高性能网络库 Netpoll，在提高网络库效率方面有诸多实践，参考已发布文章字节跳动在 Go 网络库上的实践。除此之外，Netpoll 还针对 HTTP 场景进行优化，通过减少拷贝和系统调用次数提高吞吐以及降低时延。为了衡量 Hertz 性能指标，我们选取了社区中有代表性的框架 Gin（net/http）和 Fasthttp 作为对比，如图 3 所示。可以看到，Hertz 的极限吞吐、TP99 等指标均处于业界领先水平。未来，Hertz 还将继续和 Netpoll 深度配合，探索 HTTP 框架性能的极限。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/d3/9b/d3cf4da30e004376cbaeb919a792249b.jpg\" /></p><p></p><h2>一个 Demo</h2><p></p><p></p><p>下面简单演示一下 Hertz 是如何开发一个服务的。</p><p></p><p>1.首先，定义 IDL，这里使用 Thrift 作为 IDL 的定义（也支持使用 Protobuf 定义的 IDL），编写一个名为 Demo 的 service。这个服务有一个 API: Hello，它的请求参数是一个 query，响应是一个包含一个 RespBody 字段的 Json。</p><p></p><p><code lang=\"python\">// idl/hello.thrift\nnamespace go hello.example\n\nstruct HelloReq {\n    1: string Name (api.query=\"name\");\n}\n\nstruct HelloResp {\n    1: string RespBody;\n}\n\nservice HelloService {\n    HelloResp Hello(1: HelloReq request) (api.get=\"/hello\");\n}</code></p><p></p><p>2.接下来我们使用 hz 生成代码，并整理和拉取依赖</p><p></p><p><code lang=\"python\">$ hz new -idl idl/hello.thrift -mod Demo\n$ go mod tidy &amp;&amp; go mod verify</code></p><p></p><p>3.填充业务逻辑，比如我们返回 hello， ${Name}，那我们在biz/handler/example/hello_service.go 中添加以下代码即可</p><p></p><p><code lang=\"python\">// Hello .\n// @router /hello [GET]\nfunc Hello(ctx context.Context, c *app.RequestContext) {\n    var err error\n    var req example.HelloReq\n    err = c.BindAndValidate(&amp;req)\n    if err != nil {\n        c.String(400, err.Error())\n        return\n    }\n\n    resp := new(example.HelloResp)\n    resp.RespBody = \"hello, \" + req.Name\n    c.JSON(200, resp)\n}</code></p><p></p><p>4.编译并运行项目</p><p></p><p><code lang=\"python\">$ go build\n$ ./Demo</code></p><p></p><p>到现在一个简单的 Hertz 项目已经生成，下面我们来测试一下：</p><p></p><p><code lang=\"python\">$ curl http://localhost:8888/hello\\?name\\=Xiaoming\n// 如果看到以下返回说明服务已经正常启动起来啦\n$ {\"RespBody\":\"hello, Xiaoming\"}</code></p><p></p><p>（以上 demo 可以在 hertz-examples 中查看） 之后就可以愉快的构建自己的项目了。</p><p></p><h2>后记</h2><p></p><p></p><p>希望以上的分享能够让大家对 Hertz 有一个整体上的认识。同时，我们也在不断地迭代 Hertz、完善 CloudWeGo 整体生态。欢迎各位感兴趣的同学们加入我们，共同建设 CloudWeGo。</p><p></p><p>参考资料：</p><p>Hertz: https://github.com/cloudwego/hertz</p><p>Hertz Doc: https://www.cloudwego.io/zh/docs/hertz/</p><p>字节跳动在 Go 网络库上的实践: https://www.cloudwego.io/zh/blog/2021/10/09/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%9C%A8-go-%E7%BD%91%E7%BB%9C%E5%BA%93%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/</p>",
    "publish_time": "2022-06-29 10:02:41",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]