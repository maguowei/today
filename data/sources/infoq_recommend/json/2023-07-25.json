[
  {
    "title": "PHP 8：类型系统改进",
    "url": "https://www.infoq.cn/article/syFMveVDuy7UdOUCG7Cl",
    "summary": "<p></p><blockquote>本文属于专题文章<a href=\"https://www.infoq.cn/theme/php8-article-series\">《深入浅出 PHP 8》</a>\"。根据<a href=\"https://w3techs.com/technologies/details/pl-php\">w3tech</a>\"的数据，PHP 仍然是 Web 上使用最广泛的脚本语言之一，77.3%的网站使用 PHP 进行服务器端编程。PHP 8 带来了许多新特性和其他改进，我们将在本系列文章中进行探讨。PHP 8.0 添加了对多个函数和方法相关特性的支持，其中一些是对现有特性的改进，而另一些则是全新的特性。PHP 8.1 中增强的可调用语法可用于通过可调用对象创建匿名函数。命名函数参数可以与位置参数一起使用，另外还有一个好处，即命名参数没有顺序，可以通过它们的名称来传达含义。纤程（Fiber）是可中断的函数，增加了对多任务的支持。</blockquote><p></p><p></p><p>在本文中，我们将讨论PHP 8、8.1和8.2对PHP类型系统的扩展，其中包括联合类型、交集类型和mixed 类型，以及返回类型static 和never 。</p><p></p><p>此外，PHP 8还支持独立类型true、null和false。</p><p></p><h2>一些定义</h2><p></p><p></p><p>在PHP中，类型声明与类属性、函数参数和函数返回类型一起使用。我们经常使用各种定义从类型系统方面描述一种语言：强/弱，动态/静态。</p><p></p><p>PHP是一种动态类型语言。所谓动态类型是指类型检查是在运行时进行的，与之相对的是在静态编译时进行类型检查。PHP默认是弱类型的，这意味着它在运行时支持的隐式类型转换规则比较少。不过，在PHP中可以启用强类型。</p><p></p><p>PHP会在不同的上下文中使用类型：</p><p></p><p>独立类型：可以在类型声明中使用的类型，如int、string、array；字面量类型：除了值的类型之外，还对值本身进行检查的类型。PHP支持两种字面量类型：true和false；单元类型：保存单个值的类型，如null。除了简单类型之外，PHP 8还引入了复合类型，如联合类型和交集类型。联合类型是多个简单类型的并集。其值只需匹配联合类型中的一种类型。联合类型可用于指定类属性、函数形参的类型或函数返回类型。新增类型mixed 是联合类型的一种特殊类型。</p><p></p><p>PHP 8.1还增加了交集类型，用于说明那种是多个类类型的交集的类类型。它还增加了两个新的返回类型。如果函数无返回值，则使用返回类型never 。例如，当函数抛出异常或调用exit()时，可能出现这种情况。返回类型static意味着返回值必须是调用该方法的类的实例。</p><p></p><h2>联合类型</h2><p></p><p></p><p>如果你熟悉文氏图，那么你可能还记得集合的并集和交集。为了支持简单类型的并集，PHP 8引入了联合类型。用于声明联合类型的语法如下：</p><p></p><p><code lang=\"php\">Type1|Type2|....|TypeN\n</code></p><p></p><p>我们首先看个例子。在下面的脚本中，$var1属于联合类型int|string|array 。它被初始化为一个整数值，然后它被设置为联合类型声明中包含的其他类型的值。</p><p></p><p><code lang=\"php\"><!--?php\n\nclass A{\n\n  public int|string|array $var1=1;\n \n}\n\n$a= new A();\necho $a--->var1;\n$a-&gt;var1=\"hello\";\necho $a-&gt;var1;\n$a-&gt;var1=array(\n    \"1\" =&gt; \"a\",\n    \"2\" =&gt; \"b\",\n);\nvar_dump($a-&gt;var1);\n</code></p><p></p><p>上述脚本输出如下：</p><p></p><p><code lang=\"plain\">1\nhello\narray(2) { [1]=&gt; string(1) \"a\" [2]=&gt; string(1) \"b\" }\n</code></p><p></p><p>由于PHP是弱类型语言，如果将$var1的值设置为float值1.0，就会执行隐式转换。下面的脚本将输出1。</p><p></p><p><code lang=\"php\"><!--?php\n\n//declare(strict_types = 1);\nclass A{\n\npublic int|string|array $var1=1;\n \n}\n\n$a= new A();\n \n$a--->var1=1.0;\necho $a-&gt;var1;\n</code></p><p></p><p>然而，如果在声明时启用了强类型declare(strict_types = 1) ，那么就不能将$var1 设置为1.0 ，否则会报下面这个错：</p><p></p><p><code lang=\"plain\">Uncaught TypeError:无法将浮点数赋给array|string|int类型的属性A::$var1\n</code></p><p></p><p>有时候，在弱类型的情况下，可以将值转换为密切相关的类型，但这种转换并非总能执行。例如，我们不能像下面的脚本那样，给联合类型（int|array ）的变量赋字符串值：</p><p></p><p><code lang=\"php\"><!--?php\n\nclass A{\n\npublic int|array $var1=2;\n \n}\n\n$a= new A();\n \n$a--->var1=\"hello\";\necho $a-&gt;var1;\n</code></p><p></p><p>上述脚本会报如下错误：</p><p></p><p><code lang=\"plain\">Uncaught TypeError: 无法将字符串赋给array|int类型的属性A::$var1\n</code></p><p></p><p>我们看一个稍微复杂一点的例子。下面的脚本在类属性声明、函数参数和函数返回类型中使用了联合类型。</p><p></p><p><code lang=\"php\"><!--?php\n\nclass A{\n\npublic string|int|bool $var1=true;\n\nfunction fn1(string|int|array $a, object|string $b): \n\nstring|bool|int {\n    return $a;\n}\n\n}\n$a=new A();\necho $a--->var1;\necho $a-&gt;fn1(\"hello\",\"php\"); \n</code></p><p></p><p>输出如下：</p><p></p><p><code lang=\"plain\">1\nhello\n</code></p><p></p><h3>联合类型中的null</h3><p></p><p></p><p>联合类型可以为空，在这种情况下，null是联合类型声明中的类型之一。在下面的脚本中，类属性、函数参数和函数返回类型都声明为可空的联合类型。</p><p></p><p><code lang=\"php\"><!--?php\n\nclass A{\n\npublic string|null $var1=null;\n\nfunction fn1(string|int|null $a=null, object|false|null $b=null): \n\nstring|bool|null {\n    return null;\n}\n\n}\n$a=new A();\necho $a--->var1;\necho $a-&gt;fn1(); \n</code></p><p></p><h3>联合类型中的false</h3><p></p><p></p><p>伪类型false可用于联合类型。在下面的示例中，false类型用于类属性声明、函数参数和函数返回类型，它们全都声明为联合类型。</p><p></p><p><code lang=\"php\"><!--?php\n\nclass A{\n\npublic string|int|false $var1=1;\n\nfunction fn1(string|int|false $a, false|string $b): \n\nstring|false|int {\n    return $a;\n}\n\n}\n$a=new A();\necho $a--->var1;\necho $a-&gt;fn1(\"hello\",false);\n</code></p><p></p><p>输出如下：</p><p></p><p><code lang=\"plain\">1\nhello\n</code></p><p></p><p>如果在联合类型中使用了bool，则不能再使用false，那会被认为是重复声明。考虑下面的脚本，其中一个函数在声明参数时使用了包含false和bool的联合类型。</p><p></p><p><code lang=\"php\"><!--?php\nfunction fn1(string $a, bool|string|false  $b): object {\n    return $b;\n} \n</code--></code></p><p></p><p><code lang=\"php\">执行上述脚本会显示如下错误信息：</code></p><p></p><p><code lang=\"php\"><code lang=\"plain\">重复类型false是多余的\n</code></code></p><p></p><h3><code lang=\"php\">联合类型中的class类型</code></h3><p></p><p></p><p><code lang=\"php\">Class类型可以用于联合类型。如下所示，在联合类型中使用class类型A：</code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A{}\n \nfunction fn1(string|int|A $a, array|A $b): A|string  {\n    return $a;\n}\n$a=new A();\nvar_dump(fn1($a,$a));\n</code--></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">object(A)#1 (0) { }\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">但是，如果联合类型中使用了object 类型，就不能再使用class类型了。下面的脚本在联合类型中同时使用了class类型和object 。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A{}\n \nfunction fn1(object|A $a,  A $b): A   {\n    return $a;\n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">执行上述脚本会显示如下错误信息：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">类型A|object中同时包含object和class类型，这是多余的\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">如果联合类型中使用了iterable，则不能再使用array和Traversable。下面的脚本在联合类型中同时使用了array 和iterable：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nfunction fn1(object $a, iterable|array $b):  iterable {\n     \n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">执行上述脚本会显示如下错误信息：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">类型iterable|array中同时包含iterable和array类型，这是多余的\n</code></code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">联合类型与类继承</code></code></code></h3><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">如果一个类继承了另一个类，那么联合类型可以单独声明两个类，或者只声明超类。例如，在下面的脚本中，类C继承了类B，类B又继承了类A。然后，在声明联合类型的函数参数时把类A、B和C都包含了进去。</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A  {\nfunction fn1(){\n  return \"Class A object\";\n}\n}\n\nclass B extends A {\nfunction fn1(){\n  return \"Class B object\";\n}\n}\n\nclass C extends B {\nfunction fn1(){\n  return \"Class C object\";\n  }\n}\n\n$c = new C();\n \n\nfunction fn1(A|B|C $a, A|B|C $b): string {\n     \n    return $a--->fn1();\n}\n\necho fn1($c,$c);\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">Class C object\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">或者，在声明fn1 的参数时可以只使用A 类型，输出不变：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">  function fn1(A $a, A $b): string {\n     \n    return $a-&gt;fn1();\n}\n</code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\">联合类型中的void</code></code></h3><p></p><p></p><p><code lang=\"php\"><code lang=\"php\">不能在联合类型的返回类型中使用void 。执行如下脚本：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nfunction fn1(int|string $a, int|string $b): void|string {\n     \n    return $a;\n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">将显示如下错误信息：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">Void只能作为独立类型使用\n</code></code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">联合类型的隐式类型转换</code></code></code></h3><p></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">前面我们提到过，如果不启用强类型，那么当一个值与联合类型中的任何类型都无法匹配时，它将转换为与之密切相关的类型。但是，哪些是密切相关的类型呢？隐式转换会按以下优先顺序进行：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">整型浮点型字符串型布尔型例如，在下面的脚本中，字符串值\"1\"将被转换成一个浮点数：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\n \nclass A{\n\npublic  float|bool  $var1=true;\n \n}\n\n$a= new A();\n \n$a--->var1=\"1\";\nvar_dump($a-&gt;var1);\n?&gt;\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">float(1)\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">但是，如果联合类型中包含int，则输出为int(1)。在下面的脚本中，联合类型（int|float）变量被赋值为字符串\"1.0\"。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A{\n\npublic  int|float    $var1=1;\n \n}\n\n$a= new A();\n \n$a--->var1=\"1.0\";\nvar_dump($a-&gt;var1);\n?&gt;\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">float(1)\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">在下面的脚本中，字符串值\"true\"会被解释成string 值，因为联合类型中包含string 。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A{\n\npublic  float|bool|string   $var1=1;\n \n}\n\n$a= new A();\n \n$a--->var1=\"true\";\nvar_dump($a-&gt;var1);\n?&gt;\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">string(4) \"true\"\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">但是，在下面的脚本中，字符串值\"true\"会被转换成bool 值，因为联合类型中不包含string 。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A{\n\npublic  float|bool    $var1=1;\n \n}\n\n$a= new A();\n \n$a--->var1=\"true\";\nvar_dump($a-&gt;var1);\n?&gt;\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">bool(true)\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">下面这个例子的输出难以预测。这个脚本将一个字符串值赋给联合类型为int|bool|float的变量。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A{\n\npublic  int|bool|float    $var1=1;\n \n}\n\n$a= new A();\n \n$a--->var1=\"hello\";\nvar_dump($a-&gt;var1);\n?&gt;\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">bool(true)\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">string被转换为bool值，因为它无法转换为int或float。</code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\">新增的mixed类型</code></code></h2><p></p><p></p><p><code lang=\"php\"><code lang=\"php\">PHP 8引入了一个名为mixed的新类型，它相当于联合类型object |resource|array|string|int|float|bool|null。例如，在下面的脚本中，mixed被用作类属性类型、函数参数类型和函数返回类型。启用强类型是为了证明mixed不受强类型所影响。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\ndeclare(strict_types = 1);\n\nclass A{\n\npublic  mixed    $var1=1;\n \nfunction fn1(mixed $a):mixed{ return $a;}\n}\n\n$a= new A();\n  \nvar_dump($a--->fn1(true));\nvar_dump($a-&gt;var1);\n$a-&gt;var1=\"hello\";\nvar_dump($a-&gt;var1);\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">显然，mixed非常灵活，可以输出不同类型：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">bool(true) \nint(1) \nstring(5) \"hello\"\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">在联合类型中将其他标量类型与混合类型一起使用是多余的，因为mixed类型是所有其他标量类型的联合类型。请看下面的脚本，在一个联合类型中同时使用int和mixed类型。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><!--?php\n \nclass A{\n\nfunction fn1(int|mixed $a):mixed{ return $a;}\n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">执行脚本会显示如下错误信息：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">类型mixed只能作为独立类型使用\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">类似地，mixed 也不能和任何类类型一起使用。下面的脚本会显示同样的错误信息：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n \nclass A{}\nclass B{\n\nfunction fn1(A|mixed $a):mixed{ return $a;}\n}\n</code--></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">子类的方法可以缩小返回类型mixed。例如，子类中的函数fn1将返回类型mixed缩小为array。</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \nclass A{\npublic function fn1(mixed $a):mixed{ return $a;}\n}\nclass B extends A{\n\npublic function fn1(mixed $a):array{ return $a;\n\n}\n</code--></code></code></code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">新增的独立类型null、false和true</code></code></code></code></h2><p></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">在PHP 8.2之前，null类型是PHP的单元类型，即保存单个值的类型。类似地，false类型是bool类型的字面量类型。不过，null和false类型只能在联合类型中使用，而不能作为独立类型使用。要证明这一点，可在PHP 8.1及更早的版本中运行如下脚本：</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A{\n\npublic  null $var1=null;\n\n}\n$a=new A();\necho $a--->var1;\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">在PHP 8.1中，该脚本会输出以下错误信息：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">Null不能作为独立类型使用\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">类似地，为了证明在PHP 8.1或更早的版本中，false类型不能作为独立类型使用，可运行以下脚本：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A{\n\npublic false $var1=false;\n\n}\n</code--></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">在PHP 8.1中，该脚本会生成如下错误信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">False不能作为独立类型使用\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">PHP 8.2支持将null和false作为独立类型来使用。下面的脚本使用null作为方法参数类型和方法返回类型。</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><!--?php\n\nclass NullExample {\n  public null $nil = null;\n \n  public function fn1(null $v): null { return null;  }\n}\n</code--></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">null不能使用?null 显式标记为可空。要证明这一点，可运行以下脚本：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n \nclass NullExample {\n    public null $nil = null;\n \n    public function fn1(?null $v): null { return null;  }\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">该脚本会生成以下错误信息：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">null不能标记为可空\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">以下脚本将false 作为独立类型来使用：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \nclass FalseExample {\n    public false $false = false;\n \n    public function fn1(false $f): false { return false;}\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">null 和false 可以用于联合类型，如下所示：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \nclass NullUnionExample {\n    public null $nil = null;\n \n    public function fn1(null $v): null|false { return null;  }\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">此外，PHP 8.2还新增了一个类型true，它可以用作独立类型使用。下面的脚本使用true作为类属性类型、方法参数类型和方法返回类型。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><!--?php\n\nclass TrueExample {\n    public true $true = true;\n \n    public function f1(true $v): true { return true;}\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">true 类型不能和false一起用于联合类型，如下所示：</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n \nclass TrueExample {\n \n    public function f1(true $v): true|false { return true;}\n}\n</code--></code></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">该脚本会生成以下错误信息：</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">类型同时包含true和false，应该用bool来替代它们\n</code></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">类似地，true 也不能和bool 一起用于联合类型，如下所示：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">class TrueExample {\n        public function f1(true $v): true|bool { return true;}\n}\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">该脚本会生成以下错误信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">重复类型true是多余的\n</code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">交集类型</code></code></code></code></h2><p></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">PHP 8.1将交集类型作为复合类型引入。交集类型可以与类和接口类型一起使用。交集类型用于表示多个类和接口类型的类型，而不是单个类或接口类型的类型。交集类型的语法如下：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">Type1&amp;Type2...TypeN\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">何时使用交集类型，何时使用联合类型？如果一个类型表示多个类型中的一个，则使用联合类型。如果一个类型要同时表示多个类型，则使用交集类型。下面这个例子很好地说明了这种差异。A、B和C是3个相互之间没有关系的类。如果一个类型要表示这些类型中的任何一个，则要使用联合类型，如下所示：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A\n{\n  function fn1(){\n    return \"Class A object\";\n  }\n}\n\nclass B  \n{\n  function fn1(){\n    return \"Class B object\";\n  }\n}\n\nclass C  \n{\n  function fn1(){\n    return \"Class C object\";\n  }\n}\n\n$c = new C();\n \n\nfunction fn1(A|B|C $a, A|B|C $b): string {\n     \n    return $a--->fn1();\n}\n\necho fn1($c,$c); \n?&gt;\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">输出如下：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">Class C object\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">这里如果使用交集类型，就会产生错误。修改这个函数，使用交集类型：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">function fn1(A&amp;B&amp;C $a, A&amp;B&amp;C $b): string {\n     \n    return $a-&gt;fn1();\n}\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">执行上述脚本会产生以下错误信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">Uncaught TypeError: fn1(): 参数 #1 ($a)的类型必须是A&amp;B&amp;C，但提供了C\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">如果C 继承了B ，B 继承了A ，就可以使用交集类型了，如下所示：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A\n{\n  function fn1(){\n  return \"Class A object\";\n}\n}\n\nclass B  extends A\n{\n  function fn1(){\n  return \"Class B object\";\n}\n}\n\nclass C  extends B\n{\n  function fn1(){\n  return \"Class C object\";\n  }\n}\n\n$c = new C();\n \n\nfunction fn1(A&B&C $a, A&B&C $b): string {\n     \n    return $a--->fn1();\n}\n\necho fn1($c,$c); \n?&gt;\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">输出如下：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">Class C object\n</code></code></code></code></code></p><p></p><h3><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">标量类型与交集类型</code></code></code></code></h3><p></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">交集类型只能与类和接口类型一起使用，但不能与标量类型一起使用。为了证明这一点，修改前述脚本中的fn1函数，如下所示：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">function fn1(A&amp;B&amp;C&amp;string $a, A&amp;B&amp;C $b): string {\n     \n}\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">执行上述脚本会产生以下错误信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">string类型不能作为交集类型的一部分\n</code></code></code></code></code></p><p></p><h3><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">交集类型与联合类型</code></code></code></code></h3><p></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">交集类型不能与联合类型组合使用。具体来说，在同一类型声明中，交集类型表示法不能与联合类型表示法组合使用。为了证明这一点，修改fn1函数如下：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">function fn1(A&amp;B|C $a, A&amp;B|C $b): string {\n    \n}\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">上述脚本会导致如下解析错误信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">Parse error: 语法错误，需要变量，但意外遇到符号“|”\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">在同一个函数声明中，交集类型可以与联合类型一起使用，如下所示：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">function fn1(A&amp;B&amp;C $a, A|B|C $b): string {\n       \n}\n</code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">返回类型static与never</code></code></code></code></h2><p></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">PHP 8.0引入了一个新的返回类型static ，PHP 8.1引入了一个新的返回类型 never。</code></code></code></code></p><p></p><h3><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">返回类型static</code></code></code></code></h3><p></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">如果返回类型指定为static ，则返回值的类型必须是定义方法的类的类型。例如，类A中定义的fn1方法返回类型为static，因此，该方法必须返回类型为A的值，即声明该函数的类。</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A \n{\n    public int $var1=1;\n    public function fn1(): static\n    {    \n      return new A();\n    }\n}\n\n \n$a=new A();\necho $a--->fn1()-&gt;var1;\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">输出如下：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">1\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">返回类型声明为static 的函数必须属于某个类。为了证明这一点，声明一个返回类型为static 的全局函数：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\n  function fn1(): static\n    {    \n       \n    }\n</code--></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">上述脚本会导致如下错误：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">当没有处于活动状态的类作用域时，不能使用“static”\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">返回的类对象必须是外围类。下面的脚本会生成一个错误，因为返回值是类类型B，而返回类型static 要求返回类型为类型A。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\n \nclass B{}\nclass A \n{\n    public int $var1=1;\n    public function fn1(): static\n    {    \n      return new B();\n    }\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">上述脚本会产生以下错误：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">Uncaught TypeError: A::fn1(): 返回类型必须为类型A，但返回了B \n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">如果类B 继承了类A ，那么上述脚本就不会有什么问题，将输出1 。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">class B extends A{}\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">返回类型static 可用于联合类型。如果在联合类型中使用static ，则返回值不一定是类类型。例如，以下脚本在联合类型中使用了static：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A \n{\n    public int $var1=1;\n    public function fn1(): static|int\n    {    \n      return 1;\n    }\n}\n\n \n$a=new A(); \necho $a--->fn1();\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"> 1\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">类型static 不能用于交集类型。为了证明这一点，请看下面的脚本：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass B extends A{}\nclass A \n{\n    public function fn1(): static&B\n    {    \n      return new B();\n    }\n}\n</code--></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">该脚本会导致以下错误：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">类型static不能作为交集类型的一部分\n</code></code></code></code></code></code></p><p></p><h3><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">返回类型never</code></code></code></code></code></h3><p></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">如果返回类型为never，则函数必须不返回值，或者根本不返回，即函数不终止。返回类型never 是其他所有返回类型的子类型。也就是说，在继承一个类时，never 可以在重写方法中替换任何其他返回类型。返回never 的函数必须执行以下操作之一：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">抛出一个异常调用 exit()启动一个无限循环如果返回never 的函数永远不会被调用，那么这个函数可以为空，如下所示：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A\n{\nfunction fn1(): never {\n     \n} \n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">类A中的函数fn1()不能被调用，因为该函数隐式返回NULL 。为了证明这一点，我们将上述脚本修改为：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A {\nfunction fn1(): never {\n   } \n}\n\n$a=new A();\n$a--->fn1();\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">执行该脚本将生成以下错误信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">Uncaught TypeError: A::fn1(): 返回never的函数不能隐式返回\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">下面的脚本将生成同样的错误消息，因为if条件永远无法满足，而函数隐式返回NULL：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nfunction fn1(): never\n{\n    if (false) {\n        exit();\n    }\n}\nfn1();\n</code--></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">与static 返回类型不同，never可以用作不属于类作用域的函数的返回类型，例如：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A\n{\n  \n}\n \nfunction fn1(): never {\n     \n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">返回类型为never的函数一定不能返回值。为了证明这一点，下面的脚本声明了一个函数，该函数试图返回值，尽管它的返回类型为never。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\n  function fn1(): never\n    {    \n     return 1;\n    }\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">执行上述脚本会生成以下错误信息：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">返回never的函数必须没有返回值\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">如果返回类型为never，则函数即使是隐式返回也不行。例如，下述脚本中的fn1函数不返回值，而是在其作用域结束时隐式返回。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><!--?php\n\n  function fn1(): never\n    {    \n    }\n\nfn1();\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">上述脚本会导致以下错误：</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">Uncaught TypeError: fn1(): 返回never的函数不能隐式返回\n</code></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">声明返回类型为never且不会终止的函数有什么用？返回类型never 可以在开发、测试和调试期间使用。返回never类型的函数可以通过调用exit()退出。这样的函数甚至可以被调用，如下面的脚本所示：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n\n  function fn1(): never\n    {    \n      exit(); \n    }\n\nfn1();\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">返回never类型的函数可以抛出异常，如下所示：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\n  function fn1(): never {\n      \n    throw new Exception('Exception thrown');\n     \n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">包含无限循环的函数可以将返回类型声明为never ，如下所示：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\n  function fn1(): never {\n     while (1){}\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">返回类型never 可以覆盖派生类中的任何类型，如下所示：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\nclass A\n{\n   \n  function fn1(): int {\n      \n  }\n}\nclass B extends A{\nfunction fn1(): never {\n      \n}\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">返回类型never 不能用于联合类型。为了证明这一点，下面的脚本在联合类型中使用了never ：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \nclass A{  \nfunction fn1(): never|int {\n      \n}\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">该脚本将导致以下错误：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">never只能作为独立类型使用\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">never 类型不能用于交集类型。为了证明这一点，请运行以下将never和类类型B 一起使用的脚本。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \nclass B{}\nclass A{  \nfunction fn1(): never&B {\n      \n}\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">该脚本将导致以下错误：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">类型never不能作为交集类型的一部分\n</code></code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">标量类型不支持别名</code></code></code></code></code></h2><p></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">从PHP 8开始，如果使用标量类型别名，就会生成警告信息。例如，如果使用boolean代替bool，则生成一条消息，说明boolean 将被解释成类名。为了证明这一点，考虑下面的脚本，函数声明将integer作为参数类型。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n    function fn1(integer $param) {}\n    fn1(1);\n?-->\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">如下所示，该脚本的输出中将包含一条警告信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">警告：“integer”将被解释为类名。你是指“int”吗？输入“\\integer”来消除该警告\n\nFatal error: Uncaught TypeError: fn1():参数#1 ($param)必须是integer类型，但提供的是int\n</code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">不再支持从void函数通过引用返回</code></code></code></code></h2><p></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">从PHP 8.1开始，不再支持从void函数通过引用返回，因为只有变量引用可以通过引用返回，而void返回类型不返回值。为了证明这一点，可运行下面的脚本：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><!--?php\nfunction &fn1(): void {}\n?-->\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">该脚本将输出一条弃用提示信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">弃用：不再支持从void函数通过引用返回\n</code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">小结</code></code></code></code></h2><p></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">在本文中，我们讨论了PHP 8中引入的与类型相关的新特性，包括联合类型、交集类型和mixed 类型，以及返回类型static 和never 。在下一篇文章中，我们将介绍与PHP数组、变量、运算符和异常处理相关的新特性。</code></code></code></code></p><p></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">原文链接：</code></code></code></code></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.com/articles/php-8-type-system-improvements/\">https://www.infoq.com/articles/php-8-type-system-improvements/</a>\"</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">相关阅读：</code></code></code></code></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.cn/article/XkzLrAYhV1CWPDzu72N2\">PHP 8：注解、match 表达式及其他改进</a>\"</code></code></code></code></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.cn/article/XkIrT3XLmZFW9XdoJS1F\">PHP 8：类和枚举</a>\"</code></code></code></code></p>",
    "publish_time": "2023-07-25 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "多点开花，大模型在企业中的提效实践 ｜ArchSummit 闭门会",
    "url": "https://www.infoq.cn/article/kWKCoO36iYG4RmoGyatN",
    "summary": "<p>在当今数字时代，大模型技术无疑成为了科技界的一颗璀璨明星。随着人工智能的不断发展，大模型在各个领域展现出了强大的应用潜力，引发了无尽的探讨和期待。在<a href=\"https://archsummit.infoq.cn/202307/shenzhen/\"> ArchSummit全球架构师峰会（深圳站）</a>\"，InfoQ策划了《大模型在提效与驱动业务变革中的作用》闭门会，在这里探讨了很多大模型的实践应用，本文为部分精彩分享摘要～</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/26/263f83287a9031d2f4477f658b2fb08d.jpeg\" /></p><p></p><p></p><h3>参会嘉宾（排名不分先后）</h3><p></p><p>主持人：杨攀，极客邦科技副总裁&nbsp;&amp;&nbsp;TGO&nbsp;鲲鹏会总经理</p><p>李孟桃，字节跳动&nbsp;云业务架构师冼牛，即构科技&nbsp;技术&nbsp;VP王海华，货拉拉&nbsp;基础架构负责人贺昕玥，东亚银行&nbsp;AI&nbsp;数字化专家汪洋，东亚银行&nbsp;AI&nbsp;场景专家</p><p></p><h4>精彩分享1：</h4><p></p><p>首先各大公司都意识到需要拥有自己的私有大模型；其次，由于大模型本身存在不确定性，它在需要确定结果的领域的应用是困难的。因此，大模型更多的是作为辅助工具，帮助提高效率，而不是作为完成整个任务的主力。最后，分享一个关于游戏公司美术团队的例子，这个团队开始时引入了新的技术工具，但最终发现，真正能够将这些工具用得恰到好处的还是具有高级审美水平的设计师。这表明，人本身的能力，比如艺术审美，决定了新工具能够帮你提升多少效率，这并不意味着你的个人能力不足，使用新工具就能做得更好。</p><p></p><h4>精彩分享2：</h4><p></p><p>我一直在关注和开发智能客服解决方案。尽管大模型的出现为我们提供了新的可能，但在构建知识库和训练模型方面，仍需要大量的人力投入。在实际应用中，我们面临的主要挑战是如何确保模型的输出准确无误，以避免客户投诉和合规风险。即便有了像讯飞风星火这样的大模型，我们仍需要人力去维护和质检输出结果。因此，目前看来，大模型可能更适合作为“Copilot”的角色，而真正需要承担责任的岗位仍需要人力来负责。</p><p></p><h4>精彩分享3：</h4><p></p><p>我们是一家主导TOB行业的公司，技术支持压力巨大，团队有十几二十人，大部分时间都在处理重复的客户问题。客户对技术支持费用持保留态度。尽管客户问题常常重复且答案都在文档中，但他们仍希望我们及时有效地回答，给团队带来巨大压力。因此，我们考虑使用大模型来解决这些常见问题，但同时也面临成本高和言论风险的挑战。</p><p></p><h4>精彩分享4:</h4><p></p><p>首先，我们企业内部允许使用ChatGPT，对个人起效很大。其次，我们在内部使用了GPT3.5来理解大模型领域的新概念，感觉比Google更好，能快速接受新概念。第三，内部大模型开发在代码层面使用了ChatGPT输出，通过double&nbsp;check后应用于测试或生产环境，有效提升了效率。第四，他们自己也在进行内部大模型开发，预计能进一步提高效率。最后，他分享了一个外部提效的例子，通过使用AIGC在第一轮生成美工的初稿，缩短了生产链条，提高了效率。</p><p></p><h4>精彩分享5：</h4><p></p><p>起初大模型爆发，大家都很激动，老板也期望高效率降本。但实际落地后，发现效果并不理想，几个场景的代码提交效果较差。我们尝试与云厂商合作，但在一些场景下效果依然不佳，比如代码传播法务问题。总体而言，大模型提效只能占工作30%，且不能完全替代人工部分。现在，我们正努力降低老板的预期，当然也在等待大模型进一步成熟。</p><p></p><h4>精彩分享6：</h4><p></p><p>我看到我们的公司在许多方面都取得了显著的效率提升。首先，比如在为客户编写示例代码方面，现在我们可以快速地完成这个任务，而不再需要花费时间查询文档或者让客户自己去阅读文档。另一个提效的地方是收集客户信息，这对于我们服务B端客户至关重要。现在，我们可以通过收集信息，将客户分成a类、b类、c类，甚至详细到是否上市。这不仅提升了我们的效率，也使我们能更精准地为客户制定解决方案。</p><p></p><p>我想延伸一下，我们从筛选客户画像，到制作有针对性的PPT，再到定位客户的痛点，无论是针对金融行业，还是针对RTC行业，都能为我们提供很大的帮助。再者，我们的支持团队常常需要在半夜处理网络问题，而这种情况对客户影响巨大。有时，问题可能出在我们和腾讯或者Oracle的连接上，而不是他们两家的问题。我相信，如果有机器人帮忙，我们的同事就不必在凌晨两三点钟醒来处理问题了。机器人完全可以替我们做这个工作，这将极大地提高我们的效率。</p><p></p><h4>精彩分享7:</h4><p></p><p>作为金融行业的一份子，我们一直在探索和投资人工智能的可能性，以增强我们的业务能力和效率。客户服务、信用审核和运营是我们主要的投资领域。其中，我们已经发现了AI在风险控制、操作流程优化，甚至催收和营销等方面的巨大潜力。实际上，AI&nbsp;的加入已经改变了工作模式，让我们每个员工都可以专注于自己的角色，并利用自己的经验和技能做出最佳决策。</p><p></p><p>然而，大模型的应用带来了一些新的挑战。首先，它可能会导致结构调整，因为有了AI的帮助，我们的设计师和运营专家可以提高工作效率，而不再需要一些底层的工作。其次，我们预见到强者越强的情况会变得更加明显。具备足够规模和资本的公司将能更好地利用大模型，降低人工成本，从而在市场中脱颖而出。然而，中小型银行可能会面临更大的挑战。尽管目前大模型还无法解决所有问题，如精确度和安全性等，但我们仍然愿意投资并寻求更好的解决方案。这是一个重要的转折点，我们期待能够在这个过程中找到新的机遇和发展路径。</p><p></p><h4>精彩分享8:</h4><p></p><p>作为PaaS企业，技术支持是刚需，工程师需要长时间的训练才能成为专家。因为他们不仅需要解答通用问题，还需要根据客户的具体需求，和研发以及产品团队合作找到解决方案。考虑到人力成本，我们正在探索如何利用大语言模型来提升效率。我们可以构建一个可以回答大约&nbsp;60%&nbsp;重复性问题的&nbsp;ChatBOT，我们可以将一些问题转化为Web，建立Web库，先在库里查找问题，然后合并，然后询问GPT，生成问题，然后回答客户。</p><p></p><p>这里的难题是如何将这种能力是否将其公开发布在官网上，还是放在客户群里。法律风险和成本都是我们需要考虑的因素。此外，还存在一个问题，微信是否有开放接口允许我们放入一个机器人进行聊天。</p><p></p><p>另一个方向是将其变为技术支持的Copilot。对于某些问题不熟悉的技术支持人员，他们可以在内部先提问，然后根据得到的答案去回答客户。这就像一个文档查询助手，能够帮助他们提高效率。</p><p></p><p>对于我们来说，还有一个方向是在代码方面。目前我们只能生成小段代码，而不能大规模地输出代码。这是因为我们需要保证代码的质量，而且我们的公司风格不允许我们随便输出代码。我们只能说，基于个人为了提高效率，每个工程师都可以生成一些标准的代码段，然后修改和使用。我们暂时还不能将核心代码交出去让别人修改Bug。</p><p></p><h4>精彩分享9</h4><p></p><p>我们比较关注流量入口变化，可能未来流量的入口会集中在某些特定的平台或应用，比如阿里、苹果的Siri或者某些自然语言交互的入口。对此，我们已经开始与OpenAI等机构对话，并希望有很多的收获。</p><p></p><p>另一部分我门也关注自然语言问题的回答，即针对特定问题提供精准的回答。经过两个月的努力，我们的团队已经将准确率提高到40%以上。尽管这个数字可能并不令人满意，但在我们的业务中，这个准确率是可接受的。</p><p></p><p>我们还在努力解决自然语言模型的落地问题，这个过程的挑战性非常大，而且成本也很高。同时，我们也正在尝试使用智能体来做业务的归因分析。这是一个复杂的过程，需要考虑许多因素，比如天气、公众舆论、政府活动和内部调整等。在我们对智能体的分析中，我们发现真正的AutoGPT具有很强的自主性，难以完全控制，但是受控的智能体仍然是一种不错的选择。我们采用类似于langchain的方法，结合自己的编排，还加入了一些大模型的反思和纠错能力。通过这种方式，我们成功实现了一个业务比较复杂的归因案例，智能体能够回答出相关问题。</p><p></p><h4>精彩分享10</h4><p></p><p>我讲讲Oracle在做的的事情，Oracle本身它也是一个大玩家。首先，它在医疗领域有所发展，收购了一家公司，该公司拥有所有美国人的电子病历，包括病人在医院的所有医疗数据。对于任何公司来说，数据都非常重要。Oracle&nbsp;花费280亿购买这样的公司，这表明公司的领导层有先见之明。</p><p></p><p>此外，Oracle还投资了AI公司，所以它拥有着大量的数据和模型，再者，Oracl也页与英伟达有战略合作关系，以满足他们的算力需求。</p><p></p><p>Oracle也提供像SaaS和ERP等产品，ERP常常被用于Planning。例如在工厂中，当工厂接收到大量订单时，必须决定在哪个工厂生产。然后，它们需要找到供应商来采购原材料，这些原材料的质量可能会有所不同，价格也可能会有所不同。这就需要对库存进行协调，确定哪些原材料可用，哪些原材料不可用，然后决定在哪里生产。Oracle曾经有一个相对封闭的Planning模型，但实际效果并不高。因此，产品部门现在正在考虑引入新的模型，以改进我们所谓的传统制造业。例如，他们想要使用大型模型来提高效率，并把这些新技术引入我们的产品中，提供下一代的AI辅助Planning</p><p></p><p>在国内，我们看到的大多是互联网公司，但针对传统制造业的软件企业其实相对较弱。我认为在改造传统制造业的生产流程方面，仍然有巨大的潜力和机会。无论是工业互联网，还是传统ERP的改造，都有很大的市场。</p><p></p><h4>精彩分享11</h4><p></p><p>在我看来，目前AI算力的底层，即显卡的需求供不应求，从CPU过渡到GPU，供应短缺并持续排队。特别是英伟达的新一代显卡H800引发了从今年下半年到明年的大规模需求。无论是迭代快速的模型还是计划中的大模型，现在都处在烧钱烧卡的阶段。对于显卡的国产化替代，虽然面临生态和技术支持问题，我们也必须去考虑，因为政策在不断变化。而在供应显卡给客户之后，我们面临的最大挑战是这项技术相当新，且很难高效利用。</p><p></p><p>如果发生故障，可能导致整个模型停止，造成巨大的成本损失。所以现在很多公司都在寻找专业人才来做优化。至于模型训练的进展，实话说，我们有些悲观。模型训练的效果如同做菜一样，取决于配方和烹饪顺序。每次启动大规模的训练都像是一次登月，无法预知结果。如果模型失败，可能几个月甚至几百万的资金就此损失。所以，我们需要深思如何持续发展这个行业。</p><p></p><h4>精彩观点12</h4><p></p><p>在我看来，我们之前用A100卡做过很多仿真工作，比如汽车碰撞实验和数字孪生，甚至还有马桶的流体力学模拟。早期的模型可能并不是使用A100，而是使用早一些的卡，包括多节点之间的互联以及同一台机器上多卡之间的互联。我们提供的RGB网络可以支持多节点之间的互联，比如两个节点之间的连接速度可以达到两秒的最大量。但是，当真正开始运行模型后，我们发现，增加节点并不能直接提高效率，反而会有衰减现象，尤其是在增加到三四台之后，衰减会更严重。目前来看，英伟达的卡因为比较成熟，所以效果会比较好，国产的卡可能还需要一段时间才能赶上。相比于现在的大模型，我们早期的汽车碰撞实验等仿真工作其实用的资源相对较少。</p><p></p><h4>精彩观点13</h4><p></p><p>我们这边主要从图形跟语音方面入手，之前我们使用小模型进行背景构图、图形增强以及数字处理等工作。但大模型的出现引发了我们的思考：在某个时间点上，大模型的通用能力是否会超过我们这种小模型精挑细走出来的能力？我们进行了测评，将通用模型与我们自己内部的精挑细琢的模型进行比较，发现在性能、CPU资源利用、完成时间以及最终效果方面，我们的小模型仍然要强于大模型。</p><p>尽管我们目前的实验结果还显示大模型在细分领域的专业上并未超过我们的小模型，我们仍然担心大模型的快速发展。我们不能排除在未来的某个时间点，它的通用能力会超过我们的小模型，就像GPT这样的大模型已经在某些领域的专业能力上超越了，比如客服的能力。因此，我们对图形和视频方面的发展保持警惕。</p><p></p><h4>活动推荐：</h4><p></p><p></p><p><a href=\"https://fcon.infoq.cn/2023/shanghai?utm_source=infoq&amp;utm_medium=conference\">FCon全球金融科技大会（2023·上海站）</a>\"是极客邦科技旗下InfoQ中国团队推出的面向金融行业高端技术管理者、技术专家的会议，50%参会者拥有8年及以上工作经验。</p><p></p><p>FCon聚焦当前金融行业遇到的问题，围绕金融企业在数字化转型过程中的痛点，例如数据治理，智能化、数字化风控，数字化投研，数字化营销，IT技术能力等方向，邀请国内外金融企业，来分享人工智能、区块链、大模型、大数据、数字货币等新一代信息技术实践话题，帮助听众解决技术和业务上的问题，提升技术能力。欢迎大家报名参会，<a href=\"https://fcon.infoq.cn/2023/shanghai?utm_source=infoq&amp;utm_medium=conference\">详细信息可点击这里查看</a>\"</p><p></p>",
    "publish_time": "2023-07-25 11:44:51",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "晟云磐盾郝峻晟：技术人如何走上创业之路，实现人生价值",
    "url": "https://www.infoq.cn/article/x5pfVaM4F0ghRfKr8ZQB",
    "summary": "<p></p><blockquote>在<a href=\"https://archsummit.infoq.cn/202304/shanghai/schedule\">ArchSummit上海站</a>\"的【架构师成长】专题论坛，InfoQ邀请了晟云磐盾总裁郝峻晟做了一场《技术人如何走上创业之路，实现人生价值》为题的分享，他从优秀的架构师与创业者对比入手，详细阐述了如何用云原生的架构思路，来设计敏捷的创业组织。本文为嘉宾演讲整理～</blockquote><p></p><p>&nbsp;</p><p>有人向我提问，为什么选择创业的道路？</p><p>&nbsp;</p><p>作为一名技术人员，我曾在微软初试职场，对编程有着浓厚的兴趣，并投入时间研发创新项目，我甚至为了追踪股市，编写了一个小型爬虫，自动获取新浪炒股数据，而无需亲自盯着屏幕。当时我尝试构建一个系统，当股票波动到一定幅度时，它能自动发出警报，甚至完成自动交易。但遗憾的是，这个想法并未实现，原因在于当时国内的证券市场APP不支持这样的操作。</p><p>&nbsp;</p><p>事实上，我把自己的许多工作通过程序自动化，这也导致我当时在微软的工作变得有些无聊，因为我大部分的任务都已自动化。今天，我们看到许多如低代码开发平台，其本质都在于解决这个问题，即通过技术来减少重复的人工操作。这段经历让我意识到，在大公司里单纯做一名程序员对我而言可能会有些无聊，所以我选择了创业这条艰辛的道路。创业过程中的困难和挑战，我会在接下来的分享中一一揭示。</p><p>&nbsp;</p><p></p><h4>优秀的架构师 VS 优秀的创业者</h4><p></p><p>&nbsp;</p><p>在昨天上午的主题论坛上，一位外国教授做了一场关于云原生架构的精彩讲座。他提到，在我们开发传统的单体应用程序时，我们使用的是瀑布模型，而当我们使用基于服务的软件架构，如BS、CS架构时，我们转向了敏捷开发流程的模型。如今，当我们以云原生或无服务器方式进行开发，我们更多地依赖于Devops。</p><p>&nbsp;</p><p>如何以敏捷方式快速迭代团队，对于加入一家公司、创业或组建一个团队来说，都至关重要。你们可能听说过OpenAI这家公司，他们开发了ChatGPT。这家公司最近非常火爆，你们知道他们刚开始时有多少员工吗？只有十几个人。还有Instagram，被Facebook收购之前也只有十几个人的团队。他们能够以数十人的团队规模，卖出一亿甚至两亿美元。这就是创业公司需要研究和深思的问题。</p><p>&nbsp;</p><p>我曾和多个基金投资人合作，与许多传统投资者讨论过企业规模的问题，他们往往觉得人数较少是一种困扰，但我认为这种看法是错误的。企业应该以敏捷的方式运营，依赖于技术和流程，而不是人力。随着ChatGPT和大模型的出现，这种趋势越来越明显。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/d5/d5ad9c4881f6877a701a6d08f92c9881.png\" /></p><p></p><p>&nbsp;</p><p>你可能经常对项目经理感到不满，觉得他们无法明确地表达需求。我想说的是，项目经理其实已经足够ok了。当你尝试与客户或销售人员讨论技术设计时，你会发现沟通非常困难。</p><p>&nbsp;</p><p>作为架构师，我们需要从服务对象的角度出发，要满足甲方的需求，他们希望成本低且能够使用现有的模块。在资源紧张的情况下，我们需要提供有效的解决方案，无论是对市场总监，还是对最终用户，我们都需要满足他们的需求。同时，我们还需要考虑运维人员，保证他们能够在短时间内掌握新的系统。最后，销售人员希望产品价格适中并且能够快速交付。所有这些考虑因素都对架构师提出了高要求，我们需要在压力下设计出支持高并发、高可用的系统，同时还需要满足客户的个性化需求。在大多数公司中，这是一项极具挑战的任务。</p><p>&nbsp;</p><p>另外，作为架构师，我们往往需要与开发总监紧密合作，不同的公司中，架构师与开发总监的关系可能会有所不同。在一些公司中，开发总监可能是架构师的直接上级，而在其他公司中，他们可能是同一级别的职位。无论哪种情况，都存在各种挑战。</p><p>&nbsp;</p><p>如果我们需要将传统的BS或CS架构容器化，你可能会预计需要花费三到六个月的时间将系统设计为容器模式，并通过Docker或Kubernetes等工具进行部署。然而，在这个过程中，你可能会遇到的一个挑战是，虽然你已经花费了半年的时间去做这项工作，但这并没有为客户或销售提供新的价值。他们看到的可能仅仅是一个在功能上并无任何变化的系统。对于架构师来说，这是一种压力，你会觉得自己的工作已经非常优秀，但对于其他人来说，他们无法看到这项工作的价值。</p><p>&nbsp;</p><p>我想要分享的第二个观点是，所有公司都存在一种所谓的“技术债务”。技术债务是指诸如缺乏文档的旧代码，开发过程中出现的各种问题，或者重复功能模块等一系列问题。当我们试图在开发团队中实行Devops流程时，可能会发现许多开发人员不熟悉这个流程。他们需要签入代码checkin，遵循各种流程和检查，以确保代码的质量达标。但是，有时业务需求极高，比如在明天就上线，这就使得整个CI/CD的流程变得压力重重。如果在这种情况下系统无法上线，责任往往会落到开发团队头上。但是如果说大家觉得这个架构师的人生已经非常痛苦了的话，其实不是这样的。</p><p>&nbsp;</p><p>作为架构师，如果你想走出技术领域，向创业迈进，我想分享的是，架构师的工作实际上只是整个过程的一部分。昨天我在讲解GPT的时候，提到在制定企业战略时，有一个重要的建模模型，即PEST模型。PEST代表政策（Policy）、经济（Economy）、社会（Social）和技术（Technology）。在这里，架构只是技术部分的一小部分。因此，如果你想建立一家公司，你可能需要再往前走一步，从公司的角度来考虑架构，思考公司应该如何运作，这将是我接下来要分享的内容。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/39/39d574bc75687b2ccf0293a76e9bb51f.png\" /></p><p></p><p></p><p>首先，作为架构师，我们需要具备软件工程师的核心能力，包括系统设计、系统分析、系统建模、评估、沟通以及领导力。作为架构师，我们的工作领域广泛，包括向客户提供新功能，以及优化系统架构。然而，这些工作中有些可能非常繁琐和复杂。例如，向客户提供新功能，这些功能需要能够满足客户的需求，同时为他们创造实际价值。我们还需要处理一些可见和不可见的价值，例如修复bug和优化架构。</p><p>&nbsp;</p><p>对于这些工作，我们需要有正确的商业认识。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d7/d7278d0eb0363ec04e714a34a6a82d66.png\" /></p><p></p><p>对于创业者来说，需要考虑的问题主要包括客户和股东（包括投资人）。为什么我现在投资各种基金呢？其实是希望通过这种方式了解更多的创业公司，了解他们在市场上的动态，同时帮助创业者更好地理解商业模式，让公司能够首先存活下来。</p><p>&nbsp;</p><p>创业其实是一件非常困难的事情，创业公司能够存活的比例非常低。我是在2012年创立的公司，如果今天再去回顾那个时候我知道的创业公司，我发现大约只有1/3的公司还存在，没有太大发展，不过仍在经营。还有许多企业已经注销或者不再经营了。如果我们去企查查上查询一些创业公司，会发现好多公司全是诉讼，创始人成了失信人欠了一堆钱。创业是个有趣的过程，因为一旦你开始，就没有回头路，你无法预知明天会发生什么。</p><p>&nbsp;</p><p>我曾在一些大学讲授创业课程，一个学生问我遇到的最大困难是什么？我的回答是：下一个困难。因为当你克服了一个困难，它就不再是困难，总是下一个困难，而且每次的困难都比上次难。所以，作为创业者，你需要在服务众多的客户和甲方时，找到更高的维度，更有趣的方法来解决我们的企业架构的创业问题。</p><p>&nbsp;</p><p>原来作为架构师的分析系统的能力是可以继续使用的，包括沟通力和领导力，对系统的评估、分析、建模，以及在公司内部的沟通能力和领导力，都是非常有用的。而且如果你能加强这些能力，会帮助我们架构师，在管理公司时变得更加理性和有逻辑，提高效率。但其实还有更多的能力要学习，如对市场的分析和建模。与我们进行软件系统建模的最大区别是，软件系统建模的对象是不变的，而市场分析和建模则面临的是一直在变化的市场环境。</p><p>&nbsp;</p><p>不论你是使用Docker，还是kubernetes，设计模式完成后，它们是不会变化的。然而，在市场或创业的环境中，你会发现最大的挑战是一切都在变，市场上的人，你的竞争对手，你的员工，甚至整个的商业逻辑都在不断变化。</p><p>&nbsp;</p><p>举例来说，如果你想做关于大型模型如ChatGPT的演讲，你可能会发现在你准备PPT两周后，内容就已经过期了。为什么呢？因为每天都有新的科技产品和创新出现，很多都是基于人工智能实现的。这时候，你就需要更深层次地考虑问题，而不是简单地用你原来的架构方式来处理。</p><p>&nbsp;</p><p>第二个需要提升的是沟通能力，这不仅包括内部沟通，如对老板、同事或下属，也包括对外的客户沟通。有些客户可能并不理性，他们更看重情感交流，你可能需要和他们共进晚餐或一起喝酒来建立良好的关系。</p><p>&nbsp;</p><p>此外，还包括诸如企业领导力、管理治理模式，以及市场、销售、财务、人事等各方面的管理知识。还有更为重要的企业架构设计，如如何分配股份a如何激励同事等。这些都是创业者需要学习和掌握的知识。每个领域的知识可能都需要在商学院中学习一学期才能掌握，而且还需要实际运用才能记住。</p><p>&nbsp;</p><p></p><h4>用云原生的架构来设计敏捷创业组织</h4><p></p><p>&nbsp;</p><p>但今天我想强调的不是这些创业应该怎么做，而是希望从架构师的角度来看，如何帮助架构师设计一个与云原生相关的企业。这是架构师的优势所在。为什么是优势呢？</p><p>&nbsp;</p><p>如果一个销售人员要创办公司，他会选择租用大展厅，政府领导参观时会感到开心，或者购买豪车来接送客户，这些都是传统的商业模式。然而这种模式，从我的角度来看，更多是基于人性和传统的关系型的商业模式。</p><p>&nbsp;</p><p>现如今，许多生意，或者说我们架构师能做的生意，其大部分实际上并不来自于人与人之间的关系型生意，而是来源于技术和创新。当然，人际关系也是必需的，我们不能完全忽视它。但是，如果还是坚持做这种关系型的生意，那么对于架构师来说，竞争优势可能并不明显。</p><p>&nbsp;</p><p>另外，插一句，如果你在做公司的战略分析，商学院一定会教你一个模型，叫做波特五力模型。波特五力模型就是用来分析你在市场上具有什么样的竞争优势？你的优势对他人有何影响？反之，他人的优势对你有何影响？这个过程就是所谓的竞争战略分析。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/f3/f3ba4d39a399722bf653961ba4d94f86.png\" /></p><p></p><p>云原生是一种建构关键业务系统的理念，它包括容器（Container）、自动化（Automation）、微服务（Microservices），以及现代化应用（Modern Applications）。这种理念强调的是业务需求的重要性，因此在创业或设计架构时，我们需要首先考虑业务需求。</p><p>&nbsp;</p><p>想象一下，仅有11个人的团队卖出了价值1亿美元的产品，这听起来十分令人向往。实际上，如果我们5人的团队，能够卖出价值5000万人民币的产品，那每人分到的就有1000万，这在上海也可以买下一套房产。关键在于我们如何用敏捷的方式来帮助企业快速成长，并最大化其价值。</p><p>&nbsp;</p><p>那么，如何提升一家创业公司的效率，或者让其价值最大化呢？首要的是要降低成本，同时赚取最多的收入。这就需要我们在市场上具有竞争优势。比如，你可以拥有比别人更多的客户，或者你的成本比别人低。但实际上，在如今变化如此之快的世界，我们常常需要应对各种不确定性，因此并非只有拥有更多客户或低成本就一定能成功。实际上，成功更可能来自于我们能否让公司以更快的速度获得收益，这就是所谓的“高频”。</p><p>&nbsp;</p><p>比如，你可能听说过996工作制。如果我每天工作12个小时，而你只工作6个小时，那么我就能比你更快地完成工作。有人知道亚马逊的设计框架是如何工作的吗？亚马逊官方网站上详细描述了如何构建一家高频企业。在这里，他们提到了工作分解，以及小团队的重要性。亚马逊有一种称为\"two pizza team\"的管理理念，也就是说每个小团队的人数应该控制在两个披萨就能吃饱的程度，也就是大约20人左右。这样可以避免团队过大导致会议过长，工作效率低下。</p><p>&nbsp;</p><p>同时，亚马逊也强调自动化的重要性。当我在微软工作时，大部分的工作都是通过自动化完成的。自动化不仅可以提高工作效率，也可以降低成本。最后，我们也需要接受失败的可能性。比如SpaceX在早期的测试中，火箭反复失败，但是他们并没有因此放弃，反而从中吸取教训，不断改进，最终成功。在中国，如果一个系统设计或程序发布后出现了问题，那么开发者是否还有机会修正他们的错误呢？在很多公司中，他们无法接受失败，这可能会阻碍创新和进步。因此，我们需要改变这种文化，接受并从失败中学习和进步。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/0d/0da479337095ed0a2c29e8a248d5ae8f.png\" /></p><p></p><p>&nbsp;在云原生的架构中，有几个重要的概念，如不可变的技术设施和业务平台。他们在云原生中是Docker和Kubernetes（K8S），他们提供了各种维护和运营功能。</p><p>&nbsp;</p><p>对于创业公司，一个有效的策略是构建一个薄平台，它能支持小团队快速迭代和交付产品或服务。这种平台能帮助公司提取出共性部分，从而实现快速发展。第二个关键要点是微服务，推崇所有应用程序应通过API进行通信。这种强调API而非人际信息传递的方式有助于提高沟通效率，并避免在信息传递过程中产生信息变形。</p><p>&nbsp;</p><p>第三个关键要点是容器编排和团队管理，提倡团队按照纵向（如前端、中台、后端）而非横向来进行组织和发展。这种组织方式对于创业公司和大型企业都适用，因为它鼓励纵向的开发流程。最后，DevOps和企业数字文化被认为是架构师向创业者转变的关键因素。它强调的是持续更新、持续发布和持续学习。</p><p></p><h4>从架构师走向创业者</h4><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/62/62234f13d2a8e6a34cb7d1eb613f8513.png\" /></p><p></p><p>如何从架构师转变为创业者？这是我从微软的网站上找到的关于云计算设计模式的介绍。我之前从事云计算的工作时，我对这些内容进行了深入的研究，其中也包括了分布式系统。云计算主要涉及负载均衡、故障转移等方面，例如在某些地方出现故障时，你可以切换到另一个服务实例。还有金丝雀部署和蓝绿部署等测试策略，以实现系统的持续可用性。虽然云计算设计模式有很多种，但由于它们相对稳定，所以实际上并不复杂。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/6a/6a951b995ee7698951875bce24e64cfc.png\" /></p><p></p><p>如果你有创业的打算，我强烈建议你详细了解商业模式画布。商业模式画布包括几个关键要素，你需要考虑的是：首先是关键合作伙伴，你要和谁合作？谁是你的合作伙伴？其次是关键活动，也就是你要做什么？你的系统要实现什么功能？第三个要素是关键资源，你了解哪些客户？你拥有哪些技术和能力，可以为客户提供什么价值？你与客户之间有何种关系？还有销售渠道，你的产品或服务将卖给谁？成本结构是什么样的？收入来源又是什么？如果仅仅考虑架构方面的问题，相比刚才所介绍的内容，这些要素会简单得多。然而，我的观点是你需要对商业模式画布有一个清晰的认识。</p><p>&nbsp;</p><p>当我们了解了架构的基础知识后，我强烈建议在从架构师转变为创业者或企业家的过程中，我们要意识到这些要素都是不断变化的，这是非常关键的。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/0f/0fa74598b255f11d72c30ee3a130aba1.png\" /></p><p></p><p>我给大家展示的是一个云计算设计模式的图表，其中模式非常多，而商业模式的要素相对较少。云计算和软件架构相对稳定和简单，而商业环境则非常复杂且经常变化。作为架构师，你可能经常感觉自己像是项目经理，今天有人告诉你要做A功能，明天又改成其他功能，这不是你的决定，而是客户的决定。然而，当你创办自己的公司时，你必须以客户为中心，满足客户的需求。客户今天可能满意某个功能，明天却改变主意，要求进行修改。这时候你需要思考如何持续满足客户需求，包括在部署后无法更改的情况下。同时，利益相关方的需求也在持续变化。</p><p>&nbsp;</p><p>人的行为模式是无法预测的，而系统的行为模式是可以预测的，包括应对逻辑和目标等方面。在商业环境中，我们会看到不同的人之间相互冲突。因此，我们建议在团队中实现各取所需的理念，让每个人都发挥自己的优势，这样才能使公司良好运转。然而，现实情况并非如此，尤其是从事技术工作的人常常认为自己是最厉害的。我曾经也这样认为，认为自己可以学会一切，但事实并非如此，你不可能掌握所有的知识和技能，因此你必须寻找合作伙伴，他可能是一个销售人员，你们之间的合作关系可能会非常好。</p><p>&nbsp;</p><p>但你需要花费很多时间来建立信任，由于你们两个人的角色互补，你们的个性和逻辑思维方式肯定也不一样，因此一开始可能会有些摩擦。无论是在公司内部还是创业公司中的各种团队，只要涉及到不同的人，就一定会有矛盾。你需要建立机制来解决信任和矛盾问题。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/e9/e9bd81063a941d3771d2ca30ff26ac0d.png\" /></p><p></p><p>在创业过程中，我们需要注意几个重要阶段。首先是建立自己的想法阶段。然后是概念化阶段，这两个阶段并不算是创业。真正的创业是当你辞职、建立公司并开始支付员工工资的那一刻。</p><p>&nbsp;</p><p>第三阶段是承诺阶段，表明你对创业有责任心，全身心投入其中。接下来是第一轮、第二轮和第三轮的阶段，包括验证创业概念的可行性。然后是扩张阶段，不断扩大业务规模并寻求资金支持。最后是建立商业环境，持续经营。</p><p>&nbsp;</p><p>因此，从创业的角度来看，你会发现这与架构师的系统思维有很多相似之处，特别是持续集成与持续交付（CI/CD）的系统。当你进行代码提交时，前面的步骤是在本地编写代码，然后是将其部署到生产环境，可能还有一个测试环境。然后是扩展阶段，对系统进行扩展并进行一些工作，最后将其部署到生产环境。</p><p>&nbsp;</p><p>因此，伟大的企业都是从基础需求开始，逐步满足个人和企业的需求。在每个阶段中，你会注意到企业不断向前推进。大家知道中国企业的平均寿命吗？企业的寿命通常会比人的寿命短，大约两年左右。在这个过程中，只有极其少数的企业能够成为伟大的企业。</p><p>&nbsp;</p><p>创业的第一步是对自己负责，对自己的认知能力负责，无论是作为架构师还是团队成员；第二步是对他人负责，作为架构师，通过你的工作来解决他人的需求。创业是解决相关问题的过程，创业首先是为了实现创意，关注小团队，解决小问题。</p><p>&nbsp;</p><p>但如果你想打造一家伟大的企业，你就要进入第三步。在这个阶段，你需要对股东负责，了解市场的变化，并能够承担起企业和社会的责任。在这个过程中，你要努力帮助企业和我们的环境、社区不断成长。如果你有这样的想法或梦想，希望改变世界，我强烈建议你跳入市场，为了共同的利益，实现自己的价值，也帮助他人实现他们的价值。</p><p></p><h4>活动推荐：</h4><p></p><p></p><p><a href=\"https://fcon.infoq.cn/2023/shanghai?utm_source=infoq&amp;utm_medium=conference\">FCon全球金融科技大会（2023·上海站）</a>\"是极客邦科技旗下 InfoQ 中国团队推出的面向金融行业高端技术管理者、技术专家的会议，50%参会者拥有 8 年及以上工作经验。</p><p></p><p>FCon 聚焦当前金融行业遇到的问题，围绕金融企业在数字化转型过程中的痛点，例如数据治理，智能化、数字化风控，数字化投研，数字化营销，IT 技术能力等方向，邀请国内外金融企业，来分享人工智能、区块链、大模型、大数据、数字货币等新一代信息技术实践话题，帮助听众解决技术和业务上的问题，提升技术能力。欢迎大家报名参会，<a href=\"https://fcon.infoq.cn/2023/shanghai?utm_source=infoq&amp;utm_medium=conference\">详细信息可点击这里查看</a>\"</p>",
    "publish_time": "2023-07-25 12:07:04",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "第一批因AIGC裁掉自家员工的老板该后悔了？",
    "url": "https://www.infoq.cn/article/Z5BTVI75AVhwMvT5t1TM",
    "summary": "<p></p><blockquote>拥抱生成式AI并不断裁员，这家电商企业付出了惨重代价。</blockquote><p></p><p>&nbsp;</p><p>自 2022 年 11 月 30 日推出后，ChatGPT 受欢迎程度迅速飙升。2023 年 3 月，Shopify成为首批采用 ChatGPT生成移动产品推荐的企业之一，比一些大公司和 CRM公司如Salesforce 更为激进。</p><p>&nbsp;</p><p>Shopify成立于2004年，是全球头部电商SaaS服务平台，为电商卖家提供搭建网店的技术和模版，管理全渠道的营销、售卖、支付、物流等服务。2015 年Shopify 正式上市。2021年该公司在北美电商的市场份额约为10%，仅次于亚马逊。</p><p>&nbsp;</p><p></p><h2>拥抱AI并不断裁员，Shopify的赌徒心态</h2><p></p><p>&nbsp;</p><p>今年3月，Shopify 将 <a href=\"https://www.infoq.cn/article/oo9HpcE5G7Sf5AJHxamr\">ChatGPT 助手</a>\"添加到商店应用程序和网站中。Shopify认为与ChatGPT结合的智能客服，可以超越上一代个性化问答，解决传统客服响应速率慢、人工成本高的痛点，降低运营成本。</p><p>&nbsp;</p><p>随后到了5月份的时候，Shopify首席执行官Tobias Lütke宣布公司整体裁员20%。市场普遍认为<a href=\"https://www.infoq.cn/article/13JGqTrdEdghk8mEwyRP\">AIGC的提效赋能</a>\"是裁员的重要原因之一。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/35/350c4ce363073784e60f6b0fca1d2d34.jpeg\" /></p><p></p><p>&nbsp;</p><p>&nbsp;</p><p>从这些举措来看，Shopify今年已经将业务重点放在了电商软件与AIGC的结合上，率先投身于这场轰轰烈烈的科技界转型大潮。一些证券投资公司因此认为，电商已经是ChatGPT核心应用场景之一，且有望在较快时间内落地，产生行业变革效应。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/42/4249e5fc8d6579c081c43b6619cc9361.png\" /></p><p></p><p>&nbsp;</p><p>&nbsp;</p><p>7月份，Shopify 再次推出一款名为 Sidekick 的助手，其创始人兼首席执行官 Tobi Lütke&nbsp;将其描述为一个非常有能力并可随时提供帮助的强大助手。凭借对系统和可用数据的深入了解，这个助手能够根据每个商店的具体背景并给予销售策略建议。在Twitter上分享的一段视频中，Tobi演示了如何通过Shopify上的功能按钮访问“Sidekick”助手，响应商家咨询、提供销售相关趋势信息等。</p><p>&nbsp;</p><p>这次演示效果非常炫酷，比如 Lütke 在视频中询问助手“为什么滑雪板销量下降”，Sidekick 回答说这可能是因为降雪量一直在下降，并展示了一张图表来支持这一观点。然后，他要求打折出售所有滑雪板，Sidekick 自动更改主页上所有相关内容，并在几秒钟内添加红色折扣标签。Lütke 随后还演示了如何使用 Sidekick 更改整个店铺的设计，给顾客推荐夏天的冲浪板，瞬间，店铺主视觉从冬天变成夏天的图像。</p><p>&nbsp;</p><p>拥抱AI技术的同时，Tobi Lütke在Twitter上曾公开表达了其基本思路：公司可以用更少的员工创造更高的收入，希望借此削减成本来取悦各位股东。</p><p>&nbsp;</p><p>紧跟着到了7月26日，Tobi Lütke向全体员工发出一封电子邮件，告诉他们部分雇员会在几分钟后收到裁撤通知。这次裁员涉及到了大约1000名员工，占其全球员工总数的10%。Tobi Lütke表示“裁员是必要的”，并将其原因归于消费者恢复了以往的购物习惯，加之推动公司近期增长的网上订单量也在不断减少。</p><p>&nbsp;</p><p>但Shopify的员工并不认可这个裁员理由，一名愤怒的网名为“Joe Momma”的员工不顾保密协议（NDA）毅然披露该公司颇有争议的行为和战略方向。</p><p>&nbsp;</p><p>这名员工表示，此番裁员是出于公司CEO&nbsp;Tobi Lutke疯狂的赌徒心态，想尝试用更便宜的合同工跟人工智能（AI）支持取代全职员工。</p><p>&nbsp;</p><p>并且目前这些举措已经引发了非常严重的问题：由于客户支持团队已大部分被淘汰，Shopify 的等待时间即将飙升。Shopify 客户虽然可以与机器人对话，但如果想要升级为人工服务，需要等待数小时。Tobi Lutke也掏空了其他团队，比如信任和安全，其结果是每 5 家商店就有 1 家存在欺诈或诈骗行为。这严重影响了消费者的安全，但也表明 Shopify 洗钱的时机已经成熟。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/f2/f2dc82df2c0c46d1c4b4293249e18bb2.png\" /></p><p></p><p>&nbsp;</p><p></p><blockquote>大新闻：某@shopify员工违反保密协议，向我们透露称@tobi：-已经在悄悄解雇位于美国、加拿大和爱尔兰的全球客户服务团队；-即将用AI聊天机器人将其替代。祝各位Shopify店主好运——暗无天日的时期要来了。</blockquote><p></p><p>&nbsp;</p><p></p><h2>用AI取代自家员工的代价</h2><p></p><p>&nbsp;</p><p>在帖子中，该员工介绍了Shopify在这一年中，试图将AI应用到多个地方，期望能降低成本，包括生产产品描述、创建虚拟助手、开发仍处于Beta测试阶段的新客服中心AI代理等。然而，这种成本削减策略已经对客户满意度产生了负面影响。</p><p>&nbsp;</p><p>员工数量的减少加上把大量业务转给外包和廉价的合同工，客服支持体验开始严重滞后。很多沮丧的商家等待几个小时，仍很难获得明确的答复。</p><p>&nbsp;</p><p>此外，负责监控欺诈商店的团队已经不堪重负，可能导致平台上欺诈业务的数量有所增加。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/63/63a9c1c70d67106e2639985e084d0e9f.jpeg\" /></p><p></p><p>&nbsp;</p><p></p><blockquote>Shopify中的一切都在转向AI，从产品描述到虚拟助手，再到新客服中心的AI代理（目前仍处于beta测试阶段、未正式发布）。Toby对自己的计划毫不避讳，还在Twitter上分享一张图表，展示多年来Shopify公司如何用更少的人手赚取百万美元收入。</blockquote><p></p><p>&nbsp;</p><p>该员工发布的推文也引发了人们对于其余Shopify员工命运的担忧。</p><p>&nbsp;</p><p>据报道，自裁员以来，余下员工面临着工作量增加，但却没有相应补偿或福利的困境。不少人陷入严重的倦怠、焦虑和压力过大而被迫休假的状态。</p><p>&nbsp;</p><p>尽管这些问题已经引起公司领导层的注意，但却被视为“系统性”问题而遭到忽视。另外，该公司似乎打算用基于AI的解决方案，全面取代之前依靠人工运转的客户服务体系。</p><p>&nbsp;</p><p>此外，帖子还强调了Shopify在目标市场方面出现的显著重心转变。Shopify向来以支持小企业和创业者而闻名，但随着收入模式严重依赖支付交易而非订阅软件，现在其似乎正更多优先关注大公司。</p><p>&nbsp;</p><p>Shopify在运营战略方面的巨大转变，导致员工和客户开始质疑该公司的诚信度，以及为小企业赋能的使命与承诺。不少人认为该公司已经偏离了其根本，变得越来越类似于其曾经反对的那些行业巨头。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/4b/4bd862adec0a77255beef2d3523db869.png\" /></p><p></p><p></p><blockquote>相反，公司CRO Bobby Morrison将这一切照片于“系统性”问题，并表示Shopify将增加AI技术的应用，借此“快速为我们的顾问和商家提供辅助。”“在找到修复系统性问题的方法后，我们将大力投资于工具开发，包括帮助客服人员更好完成工作的工具，以及帮助商家更快获取问题答案、且无需与真人交流的工具。”</blockquote><p></p><p>&nbsp;</p><p>Shopify公司的领导层，包括总裁Harley Finkelstein，已经向员工们保证不会进一步裁员。但该公司的一系列做法、特别是在保密协议的约束下秘密精简人手的行径，已经令员工们对承诺产生了怀疑。</p><p>&nbsp;</p><p>尽管去年曾进行多轮裁员，但Shopify公司管理层的薪酬似乎基本未受影响。在今年5月提交的监管文件中，Shopify公司透露Lutke在2022年拿到的总薪酬略高于2000万美元，与2021年的2000万美元基本持平，且高于2020年的1510万美元。</p><p>&nbsp;</p><p>随着公众监督的不断加强，以及对其企业价值主张和商业模式的愈发担忧，Shopify在重建信任和解决自身决策对员工/客户的影响方面正面临重大挑战。</p><p>&nbsp;</p><p>不少Twitter网友对此爆料给予了点评：用AI削减成本是资本家才喜欢讲的故事；Shopify 客户服务已经很糟糕了，情况会变得更糟；“人工智能聊天机器人无法提供客户服务支持，我保证 Shopify 很快就会发现这一点”；这将是一场彻底的灾难。</p><p>&nbsp;</p><p>参考链接：</p><p><a href=\"https://thedeepdive.ca/shopify-employee-breaks-nda-to-reveal-firm-quietly-replacing-laid-off-workers-with-ai/\">https://thedeepdive.ca/shopify-employee-breaks-nda-to-reveal-firm-quietly-replacing-laid-off-workers-with-ai/</a>\"</p><p><a href=\"https://twitter.com/sh0p1fyj03/status/1681673980682305541\">https://twitter.com/sh0p1fyj03/status/1681673980682305541</a>\"</p><p><a href=\"https://twitter.com/nandoodles/status/1681694042256449536\">https://twitter.com/nandoodles/status/1681694042256449536</a>\"</p><p><a href=\"https://finance.sina.com.cn/stock/hkstock/ggscyd/2023-05-05/doc-imyssmrc3081076.shtml\">https://finance.sina.com.cn/stock/hkstock/ggscyd/2023-05-05/doc-imyssmrc3081076.shtml</a>\"</p><p><a href=\"https://finance.sina.com.cn/tech/internet/2022-07-26/doc-imizirav5526612.shtml\">https://finance.sina.com.cn/tech/internet/2022-07-26/doc-imizirav5526612.shtml</a>\"</p><p>&nbsp;</p>",
    "publish_time": "2023-07-25 14:53:59",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Dell EMC 敏捷与精益创业咨询师袁店明，确认担任 QCon 北京重塑高效组织架构专题出品人",
    "url": "https://www.infoq.cn/article/t5yhOyIo4q6LthWX20LK",
    "summary": "<p>9 月 3 日 - 5 日，在<a href=\"https://qcon.infoq.cn/202309/beijing/?utm_source=infoqweb&amp;utm_medium=teacherart&amp;utm_campaign=9&amp;utm_term=0725\"> QCon 全球软件开发大会（北京站）</a>\"，Dell EMC 敏捷与精益创业咨询师袁店明将担任「重塑高效组织架构」的专题出品人。在此次专题中，你将了解到面对市场的变化，大型组织和企业调整自己的组织架构来应对外界的各种变化的真实故事，以及组织架构变更后，企业应该经受住的一些拷问。</p><p></p><p>袁店明是 Dell EMC 资深敏捷咨询师 / 培训师，精益创业导师。曾任职于百度，辅导多个产品线转型，包括商业产品、无线变现、以及多个移动互联网产品的团队转型以及组织转型。在阿尔卡特朗讯就职期间，负责上海贝尔多个产品线的敏捷教练和敏捷培训师工作，逐步培养内部敏捷教练师以加速企业敏捷转型。目前着重于团队转型、组织转型、持续集成、欣赏式探询、以及专业引导（Facilitation）的实践和应用，同时积极参与社区活动和组织。</p><p></p><p>相信袁店明的到来，可以帮助提升此专题的质量，让你通过组织架构变更的成功或不那么成功的真实案例，更好地去思考和学习到故事背后的价值和经验，为后续组织架构变更实践提供更广阔的思路。</p><p></p><p>除上述专题外，QCon 北京还将围绕<a href=\"https://qcon.infoq.cn/202309/beijing/track/1553?utm_source=infoqweb&amp;utm_medium=teacherart&amp;utm_campaign=9\">异构计算</a>\"、<a href=\"https://qcon.infoq.cn/202309/beijing/track/1554?utm_source=infoqweb&amp;utm_medium=teacherart&amp;utm_campaign=9\">向量数据库</a>\"、<a href=\"https://qcon.infoq.cn/202309/beijing/track/1556?utm_source=infoqweb&amp;utm_medium=teacherart&amp;utm_campaign=9\">FinOps 落地</a>\"、<a href=\"https://qcon.infoq.cn/202309/beijing/track/1558?utm_source=infoqweb&amp;utm_medium=teacherart&amp;utm_campaign=9\">业务安全技术</a>\"、<a href=\"https://qcon.infoq.cn/202309/beijing/track/1557?utm_source=infoqweb&amp;utm_medium=teacherart&amp;utm_campaign=9\">从 BI 到 BI+AI，新计算范式下的大数据平台</a>\"、<a href=\"https://qcon.infoq.cn/202309/beijing/track/1559?utm_source=infoqweb&amp;utm_medium=teacherart&amp;utm_campaign=9\">从 MLOps 到 LLMOps </a>\"等进行分享。</p><p></p><p>近 100 名讲师、近 30 个精彩专题、8 种交流活动，QCon 北京 2023，相约 9 月！ 现在购票，享 9 折特惠，立省 ¥880！咨询购票请联系 18514549229（微信同手机号）。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/33/aa/33cbbbf20baa8b2a18db4f0681f159aa.jpg\" /></p><p></p>",
    "publish_time": "2023-07-25 15:05:13",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "实战：超低延时直播技术的落地实践",
    "url": "https://www.infoq.cn/article/r3J9F7CtFJyljwQWwl79",
    "summary": "<p></p><blockquote>据中国互联网络信息中心发布的《中国互联网络发展状况统计报告》显示，截止到 2022 年 6 月我国网络直播用户规模达到了 7.16 亿，占网民整体的 68.1%。最主要原因是 2020 年度疫情期间导致居家办公和休闲娱乐的人数呈现激增，新媒体互动直播成为了广大网民最重要的休闲娱乐方式之一。随着直播产业链的不断扩展完备升级，相关产业链各个环节分工逐渐明确且各环节参与人数逐步增多；为了满足不同的就业需求，引发相关就业人数提升，通过直播形式赋能传统产业升级转型，并与高新技术融合创新，优化传统行业商业模式，如直播带货、新媒体广告传媒转型等。丰富的传统文化、新闻、竞技体育、法律、知识共享等内容，通过移动端互动直播的形式得以更加高效的展现传播，既让优质的直播内容可以实现爆发式传播扩散，又可以让用户有更多的机会感受，学习甚至主动参与直播互动，实现内容供给侧和需求传播的多方共赢。可以说，<a href=\"https://www.volcengine.com/product/live\">超低延时直播技术</a>\"正在走上一条全新的发展之路。InfoQ 将联合火山引擎视频直播团队推出《超低延时直播技术演进之路》系列，带您探索超低延时直播<a href=\"https://xie.infoq.cn/article/feb3808b91b888f3cbbe9f589\">技术</a>\"的演进历程，揭示背后的挑战和突破，以及对未来直播行业的影响。</blockquote><p></p><p></p><p></p><h2>第二篇 实战篇-超低延时直播技术的落地实践</h2><p></p><p></p><p>随着互联网技术以及网络基建的快速发展和普及，视频直播已经成为了一种越来越普遍的娱乐和社交方式。无论是个人还是企业，都可以通过视频直播平台进行直播活动，向观众展示自己的生活、工作或者产品。同时，视频直播也成为了一种新型的社交媒体，让人们可以在虚拟空间中进行互动交流。</p><p></p><p><a href=\"https://www.volcengine.com/product/live\">超低延时直播技术</a>\"（英文简称：RTM）是近期逐步兴起的一种以提升客户交互体验为目标的直播解决方案，它的特点是较传统的直播解决方案，端到端延时更小达到 1 秒级别，卡顿无明显负向，RTM的网络传输层是基于 WebRTC 技术的（RTP/RTCP 协议）。</p><p></p><p>RTM 推流相比于传统的 RTMP 推流，在网络变化响应灵敏度、弱网对抗、带宽利用率等方面都有明显优势。在抖音的 AB 实验中主播人均被看播时长/被关注/被评论显著正向，拉流音频/视频卡顿 -22.2%/-7.8%，端到端延迟 -1.6%。目前 RTM 推流在抖音秀场完成了 10% 左右的常规放量。</p><p></p><p></p><h2>技术架构</h2><p></p><p></p><h4>CDN 技术架构</h4><p></p><p></p><p>目前 CDN 厂商对<a href=\"https://www.volcengine.com/product/live\">RTM</a>\"的支持主要有两种技术架构，一种是基于传统的 RTMP/FLV 架构，在推拉流边缘节点增加 RTM 接入协议的支持，CDN 集群内部复用传统架构，另一种是 CDN 内部集群也采用 RTP/RTCP 协议和架构。CDN 的技术架构如下图所示：</p><p></p><h4>客户端技术架构</h4><p></p><p></p><p>在推流客户端，<a href=\"https://www.volcengine.com/product/live\">RTM</a>\"推流网络传输层使用了火山引擎自研 RTC SDK（VolcEngineRTC），在设计之初，为了支持业务无缝接入，以及最大化复用已有能力、避免重复造轮子，RTM 推流在客户端采用了 LiveCore（火山引擎自研直播推流 SDK）编码音视频 + VolcEngineRTC 传输的技术架构，如下图所示：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/64/6427b21b98aa74c5984c2a43b2ecff7d.png\" /></p><p>主要包括三部分：</p><p>推流建立连接时，LiveCore 调用 RTM 推流引擎的接口，RTM SDK 内部的 RTC 标准 SDP 信令管理模块，通过 VolcEngineRTC 的 W3C 标准 WebRTC 接口，和 CDN 服务端完成信令协商，信令交换使用的是 HTTP/HTTPS 协议（图中的红色箭头）；推流过程中，LiveCore 完成音视频采集、编码，把编码后的 AAC 和 H.264/H.265 码流，送入 RTM 推流引擎，RTM 推流引擎再通过 VolcEngineRTC 的外部音视频源私有接口，把音视频码流送入 VolcEngineRTC，进而封装为 RTP/SRTP 包，发送到 CDN 服务端（图中的蓝色箭头）；推流过程中，VolcEngineRTC 内部的网络传输引擎，对网络状态进行追踪，预估出网络可用带宽，并进行编码器带宽分配，再通过 VolcEngineRTC 私有接口回调到 RTM 推流引擎，最后再反馈到 LiveCore 的视频编码模块，进行视频编码码率调节（图中的黄色箭头）；</p><p></p><p></p><h2>技术优化</h2><p></p><p></p><h4>功能补齐和稳定性打磨</h4><p></p><p></p><p>因为 <a href=\"https://www.volcengine.com/product/live\">RTM</a>\"是近期逐步兴起的直播解决方案，无论是在 CDN 服务端，还是客户端 SDK，都处于发展早期，功能仍有诸多欠缺，比如最初只有两家 CDN 支持 RTM 推流，音视频编码格式的兼容性也有欠缺，HE AAC、H.265 和视频 B 帧在前期联调阶段都是不支持的，而且稳定性也有待打磨，在联调和灰度放量过程中，多次遇到过花屏问题。</p><p></p><p>关于功能和稳定性，这里我们分享两个案例：支持视频 B 帧，解决花屏问题。</p><p></p><h4>支持视频 B 帧</h4><p></p><p></p><p>WebRTC 标准本身是不支持视频 B 帧的，因为 WebRTC 的设计初衷就是实时通话（RTC）场景，而视频编码开启 B 帧会引入额外的延迟，影响通话体验。但在直播场景，对延迟的要求比 RTC 要宽松很多，而开启 B 帧能提高视频压缩效率，可以提升画质或者节省带宽成本，所以在直播场景开启 B 帧是很普遍的做法。</p><p></p><p>下面是抖音互娱-评测实验室针对开 B 帧进行的画质测评结论：</p><p></p><blockquote>【互娱-评测实验室】抖音直播 Android 软编开 B 帧降码率画质评测报告结合主客观表现，Android 设置软编 + B 帧后，静态清晰度与硬编无明显差异，但马赛克明显增多，劣化幅度较大， 软编各个降码率点之间马赛克差距不大（*0.9、*0.88、*0.85、*0.82）主观画质：马赛克表现：秀场场景，相较于硬编软编动态场景下均存在明显马赛克；PK 场景：软编动态场景存在轻微马赛克，稍差于硬编清晰度表现：软编面部纹理细节表现略优于硬编，各个降码率档位清晰度与不降码率差异主观感知不明显客观画质：VMAF：硬编切软编后，指标下降较明显，软编各个降码率点之间指标下降不明显Acutance（图卡清晰度指标）：硬编切软编后，指标下降较明显，软编各个降码率点之间指标下降不明显</blockquote><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/2a/2a5e7670b9d8edf2ee0cb05cf4dd2ad8.png\" /></p><p></p><p>测评发现虽然软编和硬编的主客观清晰度有比较明显的差异，但是在软编的情况下（都开了 B 帧），降低编码码率主客观清晰度都没有明显的差异。</p><p></p><p>为了支持 B 帧，我们需要对 WebRTC 进行媒体能力协商的 SDP 标准进行扩展，下面是<a href=\"https://www.volcengine.com/docs/6469/103017#%E8%A7%86%E9%A2%91-b-%E5%B8%A7%E6%94%AF%E6%8C%81\">《超低延时直播技术白皮书》</a>\"中关于视频 B 帧支持的相关扩展定义：</p><p></p><h5>SDP 视频 B 帧协商</h5><p></p><p></p><p>客户端需要在 Offer SDP 中添加 B 帧相关信息，实现 B 帧 timestamp 非单调递增的处理逻辑，后台则需要实现相应 B 帧 timestamp 封装逻辑。SDP B 帧协商示例如下所示。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/68/687e1a6d6da7d2448df1725ca6b84b1a.png\" /></p><p></p><p>SDP 中的 BFrame-enabled 代表客户端是否支持解码 B 帧。不代表服务端是否支持发送 B 帧。</p><p></p><p>OfferSDP中BFrame-enabled=0，源流带 B 帧，则服务器把源流B帧去除后再转发客户端。OfferSDP中BFrame-enabled=0，源流不带 B 帧，则服务器把源流直接转发客户端。OfferSDP中BFrame-enabled=1，源流带 B 帧，则服务器把源流直接转发客户端。OfferSDP中BFrame-enabled=1，源流不带 B 帧，则服务器把源流直接转发客户端。</p><p></p><h5>视频 B 帧时间戳计算</h5><p></p><p></p><p>视频 B 帧时间戳计算方式有 2 种。</p><p></p><p>建议规范 1： 每个 RTP 包的 rtp timestamp 携带当前帧数据的采样时间即 PTS，解码顺序附着于 SequenceNumber 顺序, 客户端不能直接计算出 DTS 的值，此种规范下在有 B 帧的时候不便于快速解码和出帧。</p><p></p><p>建议规范 2：使用 RTP 私有扩展头携带 CTS 值，每个 RTP 包的 RTP timestamp 携带当前帧数据的采样时间即 PTS, 每一帧首个 RTP 包和 VPS/SPS/PPS 包通过 RFC5285-Header-Extension 扩展头携带该帧的 CTS 值，通过 DTS = PTS - CTS * 90 公式计算出当前帧的解码时间戳。SDP extmap 示例如下所示。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/16/16deb95d26d73a843b0134f4cb70b23c.png\" /></p><p></p><p>以上两种方式可以兼容，当 offer sdp 有相应 extmap rtp-hrdext 字段时采用规范 2，否则采用规范 1。</p><p></p><p>在 RTM 推流立项之初，VolcEngineRTC 对推流视频 B 帧的支持也是欠缺的，我们也对 VolcEngineRTC 的代码仓库提交了相关修改的 MR，并推动 CDN 服务端进行开发、联调，最终通过灰度放量，验证了功能和稳定性问题，完成了对视频 B 帧的支持。</p><p></p><h4>解决花屏问题</h4><p></p><p></p><p>花屏的可能原因很多，从主播端到观众端的整个链路中，任何一个环节都可能出错导致花屏，下面是典型的视频全链路涉及到的环节：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/4e/4e431eeb3a624b4195eaa0ba4b842070.png\" /></p><p></p><p>用户有两个环节会观察到花屏现象：主播的预览和观众的渲染。但问题不一定出在这两个环节，尤其是观众看到花屏时，就可能是编码器有 bug，推流传输过程丢失了视频参考帧，CDN 下发给观众端的数据出现了错误，解码器有 bug，或者渲染模块有 bug。</p><p></p><p>排查花屏问题最常用、也是最有效的手段，就是在一些关键环节的位置，保存视频码流数据，用可信的程序（比如 ffmpeg）验证到这个环节的数据是否正常，比如在推流端把编码器输出的数据写入到本地，抓取发送的数据包，或者在服务端抓包。</p><p></p><p>除了直接用 ffplay 播放观察是否花屏（或者 ffplay 控制台是否打印了错误日志），我们还可以用下面的 ffmpeg 命令，把视频的每一帧都导出为图片：</p><p></p><p><code lang=\"null\">ffmpeg -i test.flv frames/$filename%03d.bmp</code></p><p></p><p>比如我们某次排查花屏问题时，就发现是从第 30 帧开始出现花屏：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/1a/1a2f407452af5632cc13f0c3fd0ef828.png\" /></p><p></p><p>而这个 flv 文件是 QA 同学在测试过程中使用 wget 命令保存的拉流 url 的数据，并且推流端的抓包码流播放并不会花屏，所以就实锤是 CDN 的问题了。</p><p></p><p>在 RTM 推流的联调和灰度放量过程中，多次遇到过花屏问题，每次出问题的环节都不一样，可以说基本上把坑都趟了个遍，这里就不一一展开介绍了，感兴趣的同学欢迎线下交流。</p><p></p><p></p><h4>卡顿优化</h4><p></p><p></p><p>功能和稳定性问题解决之后，我们在线下使用公司内部的 ByNet 弱网模拟工具测试发现，RTM 推流在弱网下的表现很差（测试基于 iOS 系统，视频编码格式为 H.265，分辨率 720p，码率自适应范围为 440kbps~1833kbps）：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/c2/c2fc7cdc4417423139d383d97f7a33ca.png\" /></p><p></p><p>5% 丢包 150ms rtt 的情况，RTM 推流就已经卡得无法播放了（表格中的 -- 表示基本无法播放，数据无法统计）。</p><p></p><p>经过和各家 CDN 服务端的联合分析，我们发现了几个问题：</p><p></p><p>某云 CDN 发送的音频 NACK 包没有携带正确的 sender ssrc，导致丢失的音频包没有重传；VolcEngineRTC 发送 RTCP XR 报文时 DLRR block 有问题，导致 CDN 无法正常估算网络 rtt，视频重传次数很快用完，进而导致视频重传也基本无效；CDN 推流边缘节点视频组帧之前的 buffer 过小，导致客户端重传的视频包也基本没有生效；CDN 没有启用 TCC 算法（之前用的 REMB 算法），推流端对网络状态的适应能力差；</p><p></p><p>在技术架构上，火山引擎直播 CDN 采用的是上文介绍的第一种技术架构，即边缘的收流节点会把 RTP 组帧，转换成 RTMP/FLV 流推到源站，这里我们展开介绍火山引擎直播 CDN 在组帧环节做的两个优化。</p><p></p><p>组帧 jitter buffer：针对抖动、乱序、丢包重传场景，如果 CDN 接收组帧 buffer 设置得太小，就会导致帧丢失和 GOP 丢失，从而影响用户观看直播的流畅度并引起卡顿感；如果 CDN 接收组帧 buffer 设置太大，则由于组帧引入的延迟就很大，降低直播的交互性。为了解决这个问题，我们参考 WebRTC 的 NetEQ，引入了网络自适应的 buffer，即通过估算推流侧的网络抖动设置接收组帧 buffer 大小。对于大部分网络较好的推流，组帧 buffer 引入的延时极小；对于抖动、乱序、丢包重传的推流，又可以保障流畅性同时尽可能少引入延时。</p><p></p><p>组帧交织：UDP 数据包不保证到达顺序、视频组帧抖动等因素，会引起转换出RTMP/FLV 流中的音视频不严格交织，有的视频连续 3~4s 都没有音频（或反过来）。在拉流端到端延时低至 2~3s 的背景下，播放端会因为音画同步机制引入卡顿，影响用户看播体验。对于这个问题，我们在 CDN 接收组帧的 jitter buffer 出帧时，结合音视频 jitter buffer 的长度，做了音视频交织，确保音视频帧尽量均匀，dts 差距不能过大。经过线上验证，不交织引起的播放卡顿显著下降。</p><p></p><p>上述问题都解决之后，再次进行模拟弱网测试，结果有了很大的改善：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/5c/5c0aa17968106267b2bf9bdde4beb177.jpeg\" /></p><p></p><p></p><p>可以看到在 10% 丢包 150ms rtt 时，推流仍保持在自适应的最高码率进行推流，并且拉流也没有任何卡顿。不过在丢包率增加到 15% 甚至 20% 时，RTM 推流的效果也基本就不行了，但我们分析线上数据发现，丢包率超过 10% 的情况占比很少，所以就没有继续优化了。</p><p>最后我们请视频云团队的音视频实验室对 RTM 推流和 RTMP 推流在抖音上进行了权威的测评，测评结果为：</p><p></p><blockquote>「抖音推流」RTM vs RTMP 评测报告弱网下：各指标均优于 RTMP正常网络下：视频首帧、视频延时、音频延时优于 RTMP，视频卡顿、音频卡顿、音画同步和画质基本持平 RTMP</blockquote><p></p><p><img src=\"https://static001.geekbang.org/infoq/73/73e7f849857650f41cf31803ed4ee261.png\" /></p><p></p><h4>算法优化</h4><p></p><p></p><p>经过上述一系列工程优化，最后开启线上 AB 实验，相比基线算法 RTMP，结果却不如预期：QoE 开播场次无明显趋势，开播时长稳定偏负，被看播指标无明显趋势，QoS 音频渲染百秒卡顿时长/次数 -3.641%/-4.649%，视频渲染百秒卡顿时长/次数 -2.926%/-8.044%。</p><p></p><p>直观的疑问是：为什么 QoS 卡顿有收益了却没有 QoE 收益，甚至 QoE 还是负向？</p><p></p><p>为了探寻原因和更好的进行下一步迭代优化，我们开始深入到 RTM 算法部分进行研究。</p><p></p><h2>问题分析</h2><p></p><p></p><h4>黑盒测评分析</h4><p></p><p></p><p></p><blockquote>基于抖音 app 测试推流，拉流影响则使用了拉流 demo</blockquote><p></p><p></p><p>无网损场景、相同直播推流内容下，测试发现，RTM 比 RTMP 目标码率更加保守。e.g.</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/5f/5f11ae93553d2857c13fdc566fe4336c.png\" /></p><p></p><p>2Mbps 网损下，RTM 带宽利用率仅 50%，对于拉流侧的影响则是画质损伤严重，e.g.</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/bd/bd5d518900a3a7b89abb49ba6f3e4b45.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/01/0152d2dd23f4d754edcb9fdbd3b0df81.png\" /></p><p>图：（左）RTM（TCC 开启）的 2Mbps 网损下画面质量；（右）无网损画面质量</p><p></p><p>这意味着 RTM 在部分场景下通过牺牲画质体验置换来了卡顿收益。</p><p></p><h4>基于线上大规模数据分析</h4><p></p><p></p><p>我们基于抖音的数据集，分析出了以下 3 类关键问题：</p><p></p><p>1、bwe 周期性震荡问题</p><p></p><p>红色线 bwe 震荡波动，大概率会导致黄色线目标码率震荡波动；bwe 的波动不是因为高丢包率，rtt 也是在绝对值较小（100ms 以内）范围内波动。</p><p><img src=\"https://static001.geekbang.org/infoq/21/2129d81be4235a15cf9ace4303ac5559.png\" /></p><p></p><p>2、目标码率周期性震荡问题</p><p></p><p>目标码率自身震荡波动，不是受 bwe 影响的（bwe 是稳态的）</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ad/ad2cb0ee2e19018d583a2b41ea3a294b.png\" /></p><p></p><p>3、传输能力足够，固定式码表限制了画质提升</p><p></p><p>bwe 高达 8Mbps 以上，而 max bitrate 才3Mbps 左右</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/94/94a480ad20a233017505a3309d55b7b1.png\" /></p><p></p><p>我们还量化识别了问题类型在全部数据集中的重要程度情况：</p><p></p><p>bwe 波动较普遍（19.7%），且 bwe 波动几乎都会引起目标码率波动目标码率波动更普遍（28.3%），但不一定是由 bwe 波动引起的在低带宽场景下更容易产生 bwe 波动</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d7/d77f9d9e6be543bb565d46ab637d5f53.png\" /></p><p></p><p></p><h4>白盒测试复现问题及根因分析</h4><p></p><p></p><p>我们选取了 典型的非稳态网络场景进行上述问题复现实验，并对算法内部原理进行分析，发现：</p><p>在非弱网比如只是 rtt 较小范围（150 以内）抖动的网络场景下，VolcEngineRTC TCC 带宽估计算法中，delay_based_bwe 部分，trendline estimator 对时延信号太过敏感，经常误判弱网，导致周期性下调估计的带宽值，从而降低了带宽利用率。</p><p></p><p>具体分析过程如下：</p><p></p><p>首先是复现问题场景，这里举例2个场景来说明。4Mbps 带宽+时延波动场景（左图）的实验表现和前面线上埋点（5 秒级别）的波动现象吻合，当bwe波动在码表范围内，该测试场景复现了线上 bwe 波动的问题场景；带宽泊松波动场景（右图）周期性波动问题复现更加明显。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/71/71a83d63c98ddea12fbfcb6ade6ade70.png\" /></p><p></p><p>2张图合二为一：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/2f/2f667b0c9b62135536fe8f39d8cae558.png\" /></p><p></p><p>其次，进行问题根因定位。bwe 波动的根因在于算法频繁置位 overuse （左图）来降低所估计的带宽，而 overuse 的判别逻辑在 delay_based_bwe 部分，trendline estimator（基于趋势线的时延估计器）这里把时延抖动误判成了弱网（注：误判是指实际的rtt和丢包情况均不表现为弱网特征，如右图的子图4和子5）。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/43/43f19d6c77ffb68d68b29ff32404723f.png\" /></p><p></p><p>2张图合二为一：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/64/64c127fa620b96a4d01a1e764ad1a7e2.png\" /></p><p></p><p></p><h2>解决方案</h2><p></p><p></p><h4>带宽估计算法</h4><p></p><p></p><p>1、调优已有 VolcEngineRTC bwe 算法模型参数</p><p></p><p></p><blockquote>无须写代码、等待发版周期，以最快速度缓解问题</blockquote><p></p><p></p><p>我们梳理了 VolcEngineRTC 代码逻辑以及 bwe 算法参数。好处是可以很方便的通过线上配置直接修改做实验，但是缺点是参数太多、调参太耗费精力且很大可能是收益非常有限（理论上参数的默认值应该就是一个推荐的最优值了），最终我们决定先凭借经验挑选了几个关键参数作为一期方案优化，离线验证调参的收益后就开展一期方案线上 AB 实验，期间也为我们留下了相对充足的时间去做后期优化。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/44/4400d275c4347566a94c04e719e3df4d.png\" /></p><p></p><p>2、Beyond VolcEngineRTC bwe 算法，进行线上问题模式检测与 bwe 模型纠正</p><p></p><p></p><blockquote>最小化对 VolcEngineRTC 代码/bwe 算法模型的入侵修改，同时达到解决问题的目的</blockquote><p></p><p></p><p>我们在 bwe 算法之上，引入周期性震荡场景识别及平滑策略，以改善带宽估计的准确性、提升带宽利用率，进而提升视频画质。</p><p></p><h4>码控算法</h4><p></p><p></p><p>1、解耦码控算法与带宽估计算法</p><p></p><p>在原来 RTM 推流的架构下，没有单独的码率控制算法，码控的上下界由 LiveCore 的码表决定，在上下界之间如何变化则完全是由 VolcEngineRTC bwe 算法决定。</p><p></p><p>上述架构存在以下 2 个问题：</p><p></p><p>A. bwe 算法的问题会直接体现在码控层面，e.g. 前面的问题类型（bwe 震荡波动几乎一定会引起码率震荡波动，进而导致画质问题，e.g. 业务方反馈的推流码率突降导致画面模糊的问题）</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/8f/8fb2a616f4ea32f38bceee85be660fdc.png\" /></p><p></p><p>B. 码控算法很好地利用了 VolcEngineRTC 弱网感知优势，却忘记了利用 VolcEngineRTC 的强网感知优势，e.g. 当带宽估计值超过码表码率上界时，还可以超越码表上界再进一步提升码率（非中国区码表上界比中国区低很多），从而提升画质。</p><p></p><p>因此，我们将传输层的 bwe 算法和应用层的码控算法进行了解耦。在 RTM SDK 层面设计实现单独的码控算法，可以更加灵活的根据业务场景/需求设计码控策略。</p><p></p><p>2、目标码率波动在线识别和平滑策略</p><p></p><p>与 bwe 算法的震荡波动识别和平滑思路类似，设计在线检测算法识别码率周期性波动并进行码率平滑。码控算法不一定要听从 bwe 算法，因为 bwe 算法也可能误判，此外，非实时通讯的直播场景下，秒级的端到端延时、推流拉流均有buffer情况下，不一定要立即响应带宽的波动，码控算法可以选择性的在清晰度和流畅度（卡顿）之间平衡，根据线上实验用户体验偏好进行迭代。</p><p><img src=\"https://static001.geekbang.org/infoq/11/1196151352f12fd804cc95695a68fe30.jpeg\" /></p><p></p><p></p><h4>算法优化离线效果评估</h4><p></p><p></p><p>在有限的测试场景下：</p><p></p><p>弱网场景</p><p></p><p>bwe 波动识别与平滑方案开启 vs 该方案关闭</p><p></p><p>bwe 波动识别与平滑方案对 bw、rtt 抖动场景的 bwe 进行了有效的平滑，特别是 rtt jitter 场景下有效去除了部分不必要的码率下调，有约 10% 的码率收益；</p><p></p><p>码控码率波动识别与平滑开启 vs 该方案关闭</p><p></p><p>码控优化点 2 即使在 bwe 波动识别与平滑方案关闭的情况下也可平滑一定的网络震荡（特别是 bwe 波动场景下）；码控优化方案整体在强网下 PSNR 有约 6% 的收益（720p）；</p><p></p><p>bwe 波动识别与平滑方案叠加码率波动识别与平滑效果</p><p></p><p>两者无冲突，在带宽剧烈波动场景下叠加生效有带宽利用收益；</p><p></p><p>强网场景</p><p></p><p>相比对照组无负向效果，以上实验中拉流侧均未出现卡顿。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/3d/3d76ca819e4714bffe59f7e248ea1718.jpeg\" /></p><p></p><p>综上，在有限测试场景下，bwe 波动识别与平滑方案在 rtt jitter 场景有更明显的码率收益，而码率波动识别与平滑方案在 bwe jitter 场景有明显的画质收益，两者叠加在两种场景下均有较好的码率收益。</p><p></p><h4>优化结果</h4><p></p><p></p><p>目前为止，我们的 RTM 方案在抖音已经落地以及完成放量，在抖音的指标收益主要在主播人均被看播时长/被关注/被评论显著正向，拉流音频/视频卡顿 -22.2%/-7.8%，端到端延迟 -1.6%。</p><p></p><p></p>",
    "publish_time": "2023-07-25 15:09:40",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]