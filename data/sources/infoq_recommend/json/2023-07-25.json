[
  {
    "title": "PHP 8：类型系统改进",
    "url": "https://www.infoq.cn/article/syFMveVDuy7UdOUCG7Cl",
    "summary": "<p></p><blockquote>本文属于专题文章<a href=\"https://www.infoq.cn/theme/php8-article-series\">《深入浅出 PHP 8》</a>\"。根据<a href=\"https://w3techs.com/technologies/details/pl-php\">w3tech</a>\"的数据，PHP 仍然是 Web 上使用最广泛的脚本语言之一，77.3%的网站使用 PHP 进行服务器端编程。PHP 8 带来了许多新特性和其他改进，我们将在本系列文章中进行探讨。PHP 8.0 添加了对多个函数和方法相关特性的支持，其中一些是对现有特性的改进，而另一些则是全新的特性。PHP 8.1 中增强的可调用语法可用于通过可调用对象创建匿名函数。命名函数参数可以与位置参数一起使用，另外还有一个好处，即命名参数没有顺序，可以通过它们的名称来传达含义。纤程（Fiber）是可中断的函数，增加了对多任务的支持。</blockquote><p></p><p></p><p>在本文中，我们将讨论PHP 8、8.1和8.2对PHP类型系统的扩展，其中包括联合类型、交集类型和mixed 类型，以及返回类型static 和never 。</p><p></p><p>此外，PHP 8还支持独立类型true、null和false。</p><p></p><h2>一些定义</h2><p></p><p></p><p>在PHP中，类型声明与类属性、函数参数和函数返回类型一起使用。我们经常使用各种定义从类型系统方面描述一种语言：强/弱，动态/静态。</p><p></p><p>PHP是一种动态类型语言。所谓动态类型是指类型检查是在运行时进行的，与之相对的是在静态编译时进行类型检查。PHP默认是弱类型的，这意味着它在运行时支持的隐式类型转换规则比较少。不过，在PHP中可以启用强类型。</p><p></p><p>PHP会在不同的上下文中使用类型：</p><p></p><p>独立类型：可以在类型声明中使用的类型，如int、string、array；字面量类型：除了值的类型之外，还对值本身进行检查的类型。PHP支持两种字面量类型：true和false；单元类型：保存单个值的类型，如null。除了简单类型之外，PHP 8还引入了复合类型，如联合类型和交集类型。联合类型是多个简单类型的并集。其值只需匹配联合类型中的一种类型。联合类型可用于指定类属性、函数形参的类型或函数返回类型。新增类型mixed 是联合类型的一种特殊类型。</p><p></p><p>PHP 8.1还增加了交集类型，用于说明那种是多个类类型的交集的类类型。它还增加了两个新的返回类型。如果函数无返回值，则使用返回类型never 。例如，当函数抛出异常或调用exit()时，可能出现这种情况。返回类型static意味着返回值必须是调用该方法的类的实例。</p><p></p><h2>联合类型</h2><p></p><p></p><p>如果你熟悉文氏图，那么你可能还记得集合的并集和交集。为了支持简单类型的并集，PHP 8引入了联合类型。用于声明联合类型的语法如下：</p><p></p><p><code lang=\"php\">Type1|Type2|....|TypeN\n</code></p><p></p><p>我们首先看个例子。在下面的脚本中，$var1属于联合类型int|string|array 。它被初始化为一个整数值，然后它被设置为联合类型声明中包含的其他类型的值。</p><p></p><p><code lang=\"php\"><!--?php\n\nclass A{\n\n  public int|string|array $var1=1;\n \n}\n\n$a= new A();\necho $a--->var1;\n$a-&gt;var1=\"hello\";\necho $a-&gt;var1;\n$a-&gt;var1=array(\n    \"1\" =&gt; \"a\",\n    \"2\" =&gt; \"b\",\n);\nvar_dump($a-&gt;var1);\n</code></p><p></p><p>上述脚本输出如下：</p><p></p><p><code lang=\"plain\">1\nhello\narray(2) { [1]=&gt; string(1) \"a\" [2]=&gt; string(1) \"b\" }\n</code></p><p></p><p>由于PHP是弱类型语言，如果将$var1的值设置为float值1.0，就会执行隐式转换。下面的脚本将输出1。</p><p></p><p><code lang=\"php\"><!--?php\n\n//declare(strict_types = 1);\nclass A{\n\npublic int|string|array $var1=1;\n \n}\n\n$a= new A();\n \n$a--->var1=1.0;\necho $a-&gt;var1;\n</code></p><p></p><p>然而，如果在声明时启用了强类型declare(strict_types = 1) ，那么就不能将$var1 设置为1.0 ，否则会报下面这个错：</p><p></p><p><code lang=\"plain\">Uncaught TypeError:无法将浮点数赋给array|string|int类型的属性A::$var1\n</code></p><p></p><p>有时候，在弱类型的情况下，可以将值转换为密切相关的类型，但这种转换并非总能执行。例如，我们不能像下面的脚本那样，给联合类型（int|array ）的变量赋字符串值：</p><p></p><p><code lang=\"php\"><!--?php\n\nclass A{\n\npublic int|array $var1=2;\n \n}\n\n$a= new A();\n \n$a--->var1=\"hello\";\necho $a-&gt;var1;\n</code></p><p></p><p>上述脚本会报如下错误：</p><p></p><p><code lang=\"plain\">Uncaught TypeError: 无法将字符串赋给array|int类型的属性A::$var1\n</code></p><p></p><p>我们看一个稍微复杂一点的例子。下面的脚本在类属性声明、函数参数和函数返回类型中使用了联合类型。</p><p></p><p><code lang=\"php\"><!--?php\n\nclass A{\n\npublic string|int|bool $var1=true;\n\nfunction fn1(string|int|array $a, object|string $b): \n\nstring|bool|int {\n    return $a;\n}\n\n}\n$a=new A();\necho $a--->var1;\necho $a-&gt;fn1(\"hello\",\"php\"); \n</code></p><p></p><p>输出如下：</p><p></p><p><code lang=\"plain\">1\nhello\n</code></p><p></p><h3>联合类型中的null</h3><p></p><p></p><p>联合类型可以为空，在这种情况下，null是联合类型声明中的类型之一。在下面的脚本中，类属性、函数参数和函数返回类型都声明为可空的联合类型。</p><p></p><p><code lang=\"php\"><!--?php\n\nclass A{\n\npublic string|null $var1=null;\n\nfunction fn1(string|int|null $a=null, object|false|null $b=null): \n\nstring|bool|null {\n    return null;\n}\n\n}\n$a=new A();\necho $a--->var1;\necho $a-&gt;fn1(); \n</code></p><p></p><h3>联合类型中的false</h3><p></p><p></p><p>伪类型false可用于联合类型。在下面的示例中，false类型用于类属性声明、函数参数和函数返回类型，它们全都声明为联合类型。</p><p></p><p><code lang=\"php\"><!--?php\n\nclass A{\n\npublic string|int|false $var1=1;\n\nfunction fn1(string|int|false $a, false|string $b): \n\nstring|false|int {\n    return $a;\n}\n\n}\n$a=new A();\necho $a--->var1;\necho $a-&gt;fn1(\"hello\",false);\n</code></p><p></p><p>输出如下：</p><p></p><p><code lang=\"plain\">1\nhello\n</code></p><p></p><p>如果在联合类型中使用了bool，则不能再使用false，那会被认为是重复声明。考虑下面的脚本，其中一个函数在声明参数时使用了包含false和bool的联合类型。</p><p></p><p><code lang=\"php\"><!--?php\nfunction fn1(string $a, bool|string|false  $b): object {\n    return $b;\n} \n</code--></code></p><p></p><p><code lang=\"php\">执行上述脚本会显示如下错误信息：</code></p><p></p><p><code lang=\"php\"><code lang=\"plain\">重复类型false是多余的\n</code></code></p><p></p><h3><code lang=\"php\">联合类型中的class类型</code></h3><p></p><p></p><p><code lang=\"php\">Class类型可以用于联合类型。如下所示，在联合类型中使用class类型A：</code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A{}\n \nfunction fn1(string|int|A $a, array|A $b): A|string  {\n    return $a;\n}\n$a=new A();\nvar_dump(fn1($a,$a));\n</code--></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">object(A)#1 (0) { }\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">但是，如果联合类型中使用了object 类型，就不能再使用class类型了。下面的脚本在联合类型中同时使用了class类型和object 。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A{}\n \nfunction fn1(object|A $a,  A $b): A   {\n    return $a;\n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">执行上述脚本会显示如下错误信息：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">类型A|object中同时包含object和class类型，这是多余的\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">如果联合类型中使用了iterable，则不能再使用array和Traversable。下面的脚本在联合类型中同时使用了array 和iterable：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nfunction fn1(object $a, iterable|array $b):  iterable {\n     \n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">执行上述脚本会显示如下错误信息：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">类型iterable|array中同时包含iterable和array类型，这是多余的\n</code></code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">联合类型与类继承</code></code></code></h3><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">如果一个类继承了另一个类，那么联合类型可以单独声明两个类，或者只声明超类。例如，在下面的脚本中，类C继承了类B，类B又继承了类A。然后，在声明联合类型的函数参数时把类A、B和C都包含了进去。</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A  {\nfunction fn1(){\n  return \"Class A object\";\n}\n}\n\nclass B extends A {\nfunction fn1(){\n  return \"Class B object\";\n}\n}\n\nclass C extends B {\nfunction fn1(){\n  return \"Class C object\";\n  }\n}\n\n$c = new C();\n \n\nfunction fn1(A|B|C $a, A|B|C $b): string {\n     \n    return $a--->fn1();\n}\n\necho fn1($c,$c);\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">Class C object\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">或者，在声明fn1 的参数时可以只使用A 类型，输出不变：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">  function fn1(A $a, A $b): string {\n     \n    return $a-&gt;fn1();\n}\n</code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\">联合类型中的void</code></code></h3><p></p><p></p><p><code lang=\"php\"><code lang=\"php\">不能在联合类型的返回类型中使用void 。执行如下脚本：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nfunction fn1(int|string $a, int|string $b): void|string {\n     \n    return $a;\n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">将显示如下错误信息：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">Void只能作为独立类型使用\n</code></code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">联合类型的隐式类型转换</code></code></code></h3><p></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">前面我们提到过，如果不启用强类型，那么当一个值与联合类型中的任何类型都无法匹配时，它将转换为与之密切相关的类型。但是，哪些是密切相关的类型呢？隐式转换会按以下优先顺序进行：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">整型浮点型字符串型布尔型例如，在下面的脚本中，字符串值\"1\"将被转换成一个浮点数：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\n \nclass A{\n\npublic  float|bool  $var1=true;\n \n}\n\n$a= new A();\n \n$a--->var1=\"1\";\nvar_dump($a-&gt;var1);\n?&gt;\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">float(1)\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">但是，如果联合类型中包含int，则输出为int(1)。在下面的脚本中，联合类型（int|float）变量被赋值为字符串\"1.0\"。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A{\n\npublic  int|float    $var1=1;\n \n}\n\n$a= new A();\n \n$a--->var1=\"1.0\";\nvar_dump($a-&gt;var1);\n?&gt;\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">float(1)\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">在下面的脚本中，字符串值\"true\"会被解释成string 值，因为联合类型中包含string 。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A{\n\npublic  float|bool|string   $var1=1;\n \n}\n\n$a= new A();\n \n$a--->var1=\"true\";\nvar_dump($a-&gt;var1);\n?&gt;\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">string(4) \"true\"\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">但是，在下面的脚本中，字符串值\"true\"会被转换成bool 值，因为联合类型中不包含string 。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A{\n\npublic  float|bool    $var1=1;\n \n}\n\n$a= new A();\n \n$a--->var1=\"true\";\nvar_dump($a-&gt;var1);\n?&gt;\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">bool(true)\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">下面这个例子的输出难以预测。这个脚本将一个字符串值赋给联合类型为int|bool|float的变量。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A{\n\npublic  int|bool|float    $var1=1;\n \n}\n\n$a= new A();\n \n$a--->var1=\"hello\";\nvar_dump($a-&gt;var1);\n?&gt;\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">bool(true)\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">string被转换为bool值，因为它无法转换为int或float。</code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\">新增的mixed类型</code></code></h2><p></p><p></p><p><code lang=\"php\"><code lang=\"php\">PHP 8引入了一个名为mixed的新类型，它相当于联合类型object |resource|array|string|int|float|bool|null。例如，在下面的脚本中，mixed被用作类属性类型、函数参数类型和函数返回类型。启用强类型是为了证明mixed不受强类型所影响。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\ndeclare(strict_types = 1);\n\nclass A{\n\npublic  mixed    $var1=1;\n \nfunction fn1(mixed $a):mixed{ return $a;}\n}\n\n$a= new A();\n  \nvar_dump($a--->fn1(true));\nvar_dump($a-&gt;var1);\n$a-&gt;var1=\"hello\";\nvar_dump($a-&gt;var1);\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">显然，mixed非常灵活，可以输出不同类型：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">bool(true) \nint(1) \nstring(5) \"hello\"\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">在联合类型中将其他标量类型与混合类型一起使用是多余的，因为mixed类型是所有其他标量类型的联合类型。请看下面的脚本，在一个联合类型中同时使用int和mixed类型。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><!--?php\n \nclass A{\n\nfunction fn1(int|mixed $a):mixed{ return $a;}\n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">执行脚本会显示如下错误信息：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">类型mixed只能作为独立类型使用\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">类似地，mixed 也不能和任何类类型一起使用。下面的脚本会显示同样的错误信息：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n \nclass A{}\nclass B{\n\nfunction fn1(A|mixed $a):mixed{ return $a;}\n}\n</code--></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">子类的方法可以缩小返回类型mixed。例如，子类中的函数fn1将返回类型mixed缩小为array。</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \nclass A{\npublic function fn1(mixed $a):mixed{ return $a;}\n}\nclass B extends A{\n\npublic function fn1(mixed $a):array{ return $a;\n\n}\n</code--></code></code></code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">新增的独立类型null、false和true</code></code></code></code></h2><p></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">在PHP 8.2之前，null类型是PHP的单元类型，即保存单个值的类型。类似地，false类型是bool类型的字面量类型。不过，null和false类型只能在联合类型中使用，而不能作为独立类型使用。要证明这一点，可在PHP 8.1及更早的版本中运行如下脚本：</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A{\n\npublic  null $var1=null;\n\n}\n$a=new A();\necho $a--->var1;\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">在PHP 8.1中，该脚本会输出以下错误信息：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">Null不能作为独立类型使用\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">类似地，为了证明在PHP 8.1或更早的版本中，false类型不能作为独立类型使用，可运行以下脚本：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A{\n\npublic false $var1=false;\n\n}\n</code--></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">在PHP 8.1中，该脚本会生成如下错误信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">False不能作为独立类型使用\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">PHP 8.2支持将null和false作为独立类型来使用。下面的脚本使用null作为方法参数类型和方法返回类型。</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><!--?php\n\nclass NullExample {\n  public null $nil = null;\n \n  public function fn1(null $v): null { return null;  }\n}\n</code--></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">null不能使用?null 显式标记为可空。要证明这一点，可运行以下脚本：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n \nclass NullExample {\n    public null $nil = null;\n \n    public function fn1(?null $v): null { return null;  }\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">该脚本会生成以下错误信息：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">null不能标记为可空\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">以下脚本将false 作为独立类型来使用：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \nclass FalseExample {\n    public false $false = false;\n \n    public function fn1(false $f): false { return false;}\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">null 和false 可以用于联合类型，如下所示：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \nclass NullUnionExample {\n    public null $nil = null;\n \n    public function fn1(null $v): null|false { return null;  }\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">此外，PHP 8.2还新增了一个类型true，它可以用作独立类型使用。下面的脚本使用true作为类属性类型、方法参数类型和方法返回类型。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><!--?php\n\nclass TrueExample {\n    public true $true = true;\n \n    public function f1(true $v): true { return true;}\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">true 类型不能和false一起用于联合类型，如下所示：</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n \nclass TrueExample {\n \n    public function f1(true $v): true|false { return true;}\n}\n</code--></code></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">该脚本会生成以下错误信息：</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">类型同时包含true和false，应该用bool来替代它们\n</code></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">类似地，true 也不能和bool 一起用于联合类型，如下所示：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">class TrueExample {\n        public function f1(true $v): true|bool { return true;}\n}\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">该脚本会生成以下错误信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">重复类型true是多余的\n</code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">交集类型</code></code></code></code></h2><p></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">PHP 8.1将交集类型作为复合类型引入。交集类型可以与类和接口类型一起使用。交集类型用于表示多个类和接口类型的类型，而不是单个类或接口类型的类型。交集类型的语法如下：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">Type1&amp;Type2...TypeN\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">何时使用交集类型，何时使用联合类型？如果一个类型表示多个类型中的一个，则使用联合类型。如果一个类型要同时表示多个类型，则使用交集类型。下面这个例子很好地说明了这种差异。A、B和C是3个相互之间没有关系的类。如果一个类型要表示这些类型中的任何一个，则要使用联合类型，如下所示：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A\n{\n  function fn1(){\n    return \"Class A object\";\n  }\n}\n\nclass B  \n{\n  function fn1(){\n    return \"Class B object\";\n  }\n}\n\nclass C  \n{\n  function fn1(){\n    return \"Class C object\";\n  }\n}\n\n$c = new C();\n \n\nfunction fn1(A|B|C $a, A|B|C $b): string {\n     \n    return $a--->fn1();\n}\n\necho fn1($c,$c); \n?&gt;\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">输出如下：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">Class C object\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">这里如果使用交集类型，就会产生错误。修改这个函数，使用交集类型：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">function fn1(A&amp;B&amp;C $a, A&amp;B&amp;C $b): string {\n     \n    return $a-&gt;fn1();\n}\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">执行上述脚本会产生以下错误信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">Uncaught TypeError: fn1(): 参数 #1 ($a)的类型必须是A&amp;B&amp;C，但提供了C\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">如果C 继承了B ，B 继承了A ，就可以使用交集类型了，如下所示：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A\n{\n  function fn1(){\n  return \"Class A object\";\n}\n}\n\nclass B  extends A\n{\n  function fn1(){\n  return \"Class B object\";\n}\n}\n\nclass C  extends B\n{\n  function fn1(){\n  return \"Class C object\";\n  }\n}\n\n$c = new C();\n \n\nfunction fn1(A&B&C $a, A&B&C $b): string {\n     \n    return $a--->fn1();\n}\n\necho fn1($c,$c); \n?&gt;\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">输出如下：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">Class C object\n</code></code></code></code></code></p><p></p><h3><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">标量类型与交集类型</code></code></code></code></h3><p></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">交集类型只能与类和接口类型一起使用，但不能与标量类型一起使用。为了证明这一点，修改前述脚本中的fn1函数，如下所示：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">function fn1(A&amp;B&amp;C&amp;string $a, A&amp;B&amp;C $b): string {\n     \n}\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">执行上述脚本会产生以下错误信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">string类型不能作为交集类型的一部分\n</code></code></code></code></code></p><p></p><h3><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">交集类型与联合类型</code></code></code></code></h3><p></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">交集类型不能与联合类型组合使用。具体来说，在同一类型声明中，交集类型表示法不能与联合类型表示法组合使用。为了证明这一点，修改fn1函数如下：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">function fn1(A&amp;B|C $a, A&amp;B|C $b): string {\n    \n}\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">上述脚本会导致如下解析错误信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">Parse error: 语法错误，需要变量，但意外遇到符号“|”\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">在同一个函数声明中，交集类型可以与联合类型一起使用，如下所示：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">function fn1(A&amp;B&amp;C $a, A|B|C $b): string {\n       \n}\n</code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">返回类型static与never</code></code></code></code></h2><p></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">PHP 8.0引入了一个新的返回类型static ，PHP 8.1引入了一个新的返回类型 never。</code></code></code></code></p><p></p><h3><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">返回类型static</code></code></code></code></h3><p></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">如果返回类型指定为static ，则返回值的类型必须是定义方法的类的类型。例如，类A中定义的fn1方法返回类型为static，因此，该方法必须返回类型为A的值，即声明该函数的类。</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A \n{\n    public int $var1=1;\n    public function fn1(): static\n    {    \n      return new A();\n    }\n}\n\n \n$a=new A();\necho $a--->fn1()-&gt;var1;\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">输出如下：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">1\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">返回类型声明为static 的函数必须属于某个类。为了证明这一点，声明一个返回类型为static 的全局函数：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\n  function fn1(): static\n    {    \n       \n    }\n</code--></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">上述脚本会导致如下错误：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">当没有处于活动状态的类作用域时，不能使用“static”\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">返回的类对象必须是外围类。下面的脚本会生成一个错误，因为返回值是类类型B，而返回类型static 要求返回类型为类型A。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\n \nclass B{}\nclass A \n{\n    public int $var1=1;\n    public function fn1(): static\n    {    \n      return new B();\n    }\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">上述脚本会产生以下错误：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">Uncaught TypeError: A::fn1(): 返回类型必须为类型A，但返回了B \n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">如果类B 继承了类A ，那么上述脚本就不会有什么问题，将输出1 。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">class B extends A{}\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">返回类型static 可用于联合类型。如果在联合类型中使用static ，则返回值不一定是类类型。例如，以下脚本在联合类型中使用了static：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A \n{\n    public int $var1=1;\n    public function fn1(): static|int\n    {    \n      return 1;\n    }\n}\n\n \n$a=new A(); \necho $a--->fn1();\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"> 1\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">类型static 不能用于交集类型。为了证明这一点，请看下面的脚本：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass B extends A{}\nclass A \n{\n    public function fn1(): static&B\n    {    \n      return new B();\n    }\n}\n</code--></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">该脚本会导致以下错误：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">类型static不能作为交集类型的一部分\n</code></code></code></code></code></code></p><p></p><h3><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">返回类型never</code></code></code></code></code></h3><p></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">如果返回类型为never，则函数必须不返回值，或者根本不返回，即函数不终止。返回类型never 是其他所有返回类型的子类型。也就是说，在继承一个类时，never 可以在重写方法中替换任何其他返回类型。返回never 的函数必须执行以下操作之一：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">抛出一个异常调用 exit()启动一个无限循环如果返回never 的函数永远不会被调用，那么这个函数可以为空，如下所示：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A\n{\nfunction fn1(): never {\n     \n} \n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">类A中的函数fn1()不能被调用，因为该函数隐式返回NULL 。为了证明这一点，我们将上述脚本修改为：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A {\nfunction fn1(): never {\n   } \n}\n\n$a=new A();\n$a--->fn1();\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">执行该脚本将生成以下错误信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">Uncaught TypeError: A::fn1(): 返回never的函数不能隐式返回\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">下面的脚本将生成同样的错误消息，因为if条件永远无法满足，而函数隐式返回NULL：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nfunction fn1(): never\n{\n    if (false) {\n        exit();\n    }\n}\nfn1();\n</code--></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">与static 返回类型不同，never可以用作不属于类作用域的函数的返回类型，例如：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A\n{\n  \n}\n \nfunction fn1(): never {\n     \n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">返回类型为never的函数一定不能返回值。为了证明这一点，下面的脚本声明了一个函数，该函数试图返回值，尽管它的返回类型为never。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\n  function fn1(): never\n    {    \n     return 1;\n    }\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">执行上述脚本会生成以下错误信息：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">返回never的函数必须没有返回值\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">如果返回类型为never，则函数即使是隐式返回也不行。例如，下述脚本中的fn1函数不返回值，而是在其作用域结束时隐式返回。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><!--?php\n\n  function fn1(): never\n    {    \n    }\n\nfn1();\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">上述脚本会导致以下错误：</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">Uncaught TypeError: fn1(): 返回never的函数不能隐式返回\n</code></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">声明返回类型为never且不会终止的函数有什么用？返回类型never 可以在开发、测试和调试期间使用。返回never类型的函数可以通过调用exit()退出。这样的函数甚至可以被调用，如下面的脚本所示：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n\n  function fn1(): never\n    {    \n      exit(); \n    }\n\nfn1();\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">返回never类型的函数可以抛出异常，如下所示：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\n  function fn1(): never {\n      \n    throw new Exception('Exception thrown');\n     \n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">包含无限循环的函数可以将返回类型声明为never ，如下所示：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\n  function fn1(): never {\n     while (1){}\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">返回类型never 可以覆盖派生类中的任何类型，如下所示：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\nclass A\n{\n   \n  function fn1(): int {\n      \n  }\n}\nclass B extends A{\nfunction fn1(): never {\n      \n}\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">返回类型never 不能用于联合类型。为了证明这一点，下面的脚本在联合类型中使用了never ：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \nclass A{  \nfunction fn1(): never|int {\n      \n}\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">该脚本将导致以下错误：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">never只能作为独立类型使用\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">never 类型不能用于交集类型。为了证明这一点，请运行以下将never和类类型B 一起使用的脚本。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \nclass B{}\nclass A{  \nfunction fn1(): never&B {\n      \n}\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">该脚本将导致以下错误：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">类型never不能作为交集类型的一部分\n</code></code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">标量类型不支持别名</code></code></code></code></code></h2><p></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">从PHP 8开始，如果使用标量类型别名，就会生成警告信息。例如，如果使用boolean代替bool，则生成一条消息，说明boolean 将被解释成类名。为了证明这一点，考虑下面的脚本，函数声明将integer作为参数类型。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n    function fn1(integer $param) {}\n    fn1(1);\n?-->\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">如下所示，该脚本的输出中将包含一条警告信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">警告：“integer”将被解释为类名。你是指“int”吗？输入“\\integer”来消除该警告\n\nFatal error: Uncaught TypeError: fn1():参数#1 ($param)必须是integer类型，但提供的是int\n</code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">不再支持从void函数通过引用返回</code></code></code></code></h2><p></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">从PHP 8.1开始，不再支持从void函数通过引用返回，因为只有变量引用可以通过引用返回，而void返回类型不返回值。为了证明这一点，可运行下面的脚本：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><!--?php\nfunction &fn1(): void {}\n?-->\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">该脚本将输出一条弃用提示信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">弃用：不再支持从void函数通过引用返回\n</code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">小结</code></code></code></code></h2><p></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">在本文中，我们讨论了PHP 8中引入的与类型相关的新特性，包括联合类型、交集类型和mixed 类型，以及返回类型static 和never 。在下一篇文章中，我们将介绍与PHP数组、变量、运算符和异常处理相关的新特性。</code></code></code></code></p><p></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">原文链接：</code></code></code></code></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.com/articles/php-8-type-system-improvements/\">https://www.infoq.com/articles/php-8-type-system-improvements/</a>\"</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">相关阅读：</code></code></code></code></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.cn/article/XkzLrAYhV1CWPDzu72N2\">PHP 8：注解、match 表达式及其他改进</a>\"</code></code></code></code></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.cn/article/XkIrT3XLmZFW9XdoJS1F\">PHP 8：类和枚举</a>\"</code></code></code></code></p>",
    "publish_time": "2023-07-25 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "多点开花，大模型在企业中的提效实践 ｜ArchSummit 闭门会",
    "url": "https://www.infoq.cn/article/kWKCoO36iYG4RmoGyatN",
    "summary": "<p>在当今数字时代，大模型技术无疑成为了科技界的一颗璀璨明星。随着人工智能的不断发展，大模型在各个领域展现出了强大的应用潜力，引发了无尽的探讨和期待。在<a href=\"https://archsummit.infoq.cn/202307/shenzhen/\"> ArchSummit全球架构师峰会（深圳站）</a>\"，InfoQ策划了《大模型在提效与驱动业务变革中的作用》闭门会，在这里探讨了很多大模型的实践应用，本文为部分精彩分享摘要～</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/26/263f83287a9031d2f4477f658b2fb08d.jpeg\" /></p><p></p><p></p><h3>参会嘉宾（排名不分先后）</h3><p></p><p>主持人：杨攀，极客邦科技副总裁&nbsp;&amp;&nbsp;TGO&nbsp;鲲鹏会总经理</p><p>李孟桃，字节跳动&nbsp;云业务架构师冼牛，即构科技&nbsp;技术&nbsp;VP王海华，货拉拉&nbsp;基础架构负责人贺昕玥，东亚银行&nbsp;AI&nbsp;数字化专家汪洋，东亚银行&nbsp;AI&nbsp;场景专家</p><p></p><h4>精彩分享1：</h4><p></p><p>首先各大公司都意识到需要拥有自己的私有大模型；其次，由于大模型本身存在不确定性，它在需要确定结果的领域的应用是困难的。因此，大模型更多的是作为辅助工具，帮助提高效率，而不是作为完成整个任务的主力。最后，分享一个关于游戏公司美术团队的例子，这个团队开始时引入了新的技术工具，但最终发现，真正能够将这些工具用得恰到好处的还是具有高级审美水平的设计师。这表明，人本身的能力，比如艺术审美，决定了新工具能够帮你提升多少效率，这并不意味着你的个人能力不足，使用新工具就能做得更好。</p><p></p><h4>精彩分享2：</h4><p></p><p>我一直在关注和开发智能客服解决方案。尽管大模型的出现为我们提供了新的可能，但在构建知识库和训练模型方面，仍需要大量的人力投入。在实际应用中，我们面临的主要挑战是如何确保模型的输出准确无误，以避免客户投诉和合规风险。即便有了像讯飞风星火这样的大模型，我们仍需要人力去维护和质检输出结果。因此，目前看来，大模型可能更适合作为“Copilot”的角色，而真正需要承担责任的岗位仍需要人力来负责。</p><p></p><h4>精彩分享3：</h4><p></p><p>我们是一家主导TOB行业的公司，技术支持压力巨大，团队有十几二十人，大部分时间都在处理重复的客户问题。客户对技术支持费用持保留态度。尽管客户问题常常重复且答案都在文档中，但他们仍希望我们及时有效地回答，给团队带来巨大压力。因此，我们考虑使用大模型来解决这些常见问题，但同时也面临成本高和言论风险的挑战。</p><p></p><h4>精彩分享4:</h4><p></p><p>首先，我们企业内部允许使用ChatGPT，对个人起效很大。其次，我们在内部使用了GPT3.5来理解大模型领域的新概念，感觉比Google更好，能快速接受新概念。第三，内部大模型开发在代码层面使用了ChatGPT输出，通过double&nbsp;check后应用于测试或生产环境，有效提升了效率。第四，他们自己也在进行内部大模型开发，预计能进一步提高效率。最后，他分享了一个外部提效的例子，通过使用AIGC在第一轮生成美工的初稿，缩短了生产链条，提高了效率。</p><p></p><h4>精彩分享5：</h4><p></p><p>起初大模型爆发，大家都很激动，老板也期望高效率降本。但实际落地后，发现效果并不理想，几个场景的代码提交效果较差。我们尝试与云厂商合作，但在一些场景下效果依然不佳，比如代码传播法务问题。总体而言，大模型提效只能占工作30%，且不能完全替代人工部分。现在，我们正努力降低老板的预期，当然也在等待大模型进一步成熟。</p><p></p><h4>精彩分享6：</h4><p></p><p>我看到我们的公司在许多方面都取得了显著的效率提升。首先，比如在为客户编写示例代码方面，现在我们可以快速地完成这个任务，而不再需要花费时间查询文档或者让客户自己去阅读文档。另一个提效的地方是收集客户信息，这对于我们服务B端客户至关重要。现在，我们可以通过收集信息，将客户分成a类、b类、c类，甚至详细到是否上市。这不仅提升了我们的效率，也使我们能更精准地为客户制定解决方案。</p><p></p><p>我想延伸一下，我们从筛选客户画像，到制作有针对性的PPT，再到定位客户的痛点，无论是针对金融行业，还是针对RTC行业，都能为我们提供很大的帮助。再者，我们的支持团队常常需要在半夜处理网络问题，而这种情况对客户影响巨大。有时，问题可能出在我们和腾讯或者Oracle的连接上，而不是他们两家的问题。我相信，如果有机器人帮忙，我们的同事就不必在凌晨两三点钟醒来处理问题了。机器人完全可以替我们做这个工作，这将极大地提高我们的效率。</p><p></p><h4>精彩分享7:</h4><p></p><p>作为金融行业的一份子，我们一直在探索和投资人工智能的可能性，以增强我们的业务能力和效率。客户服务、信用审核和运营是我们主要的投资领域。其中，我们已经发现了AI在风险控制、操作流程优化，甚至催收和营销等方面的巨大潜力。实际上，AI&nbsp;的加入已经改变了工作模式，让我们每个员工都可以专注于自己的角色，并利用自己的经验和技能做出最佳决策。</p><p></p><p>然而，大模型的应用带来了一些新的挑战。首先，它可能会导致结构调整，因为有了AI的帮助，我们的设计师和运营专家可以提高工作效率，而不再需要一些底层的工作。其次，我们预见到强者越强的情况会变得更加明显。具备足够规模和资本的公司将能更好地利用大模型，降低人工成本，从而在市场中脱颖而出。然而，中小型银行可能会面临更大的挑战。尽管目前大模型还无法解决所有问题，如精确度和安全性等，但我们仍然愿意投资并寻求更好的解决方案。这是一个重要的转折点，我们期待能够在这个过程中找到新的机遇和发展路径。</p><p></p><h4>精彩分享8:</h4><p></p><p>作为PaaS企业，技术支持是刚需，工程师需要长时间的训练才能成为专家。因为他们不仅需要解答通用问题，还需要根据客户的具体需求，和研发以及产品团队合作找到解决方案。考虑到人力成本，我们正在探索如何利用大语言模型来提升效率。我们可以构建一个可以回答大约&nbsp;60%&nbsp;重复性问题的&nbsp;ChatBOT，我们可以将一些问题转化为Web，建立Web库，先在库里查找问题，然后合并，然后询问GPT，生成问题，然后回答客户。</p><p></p><p>这里的难题是如何将这种能力是否将其公开发布在官网上，还是放在客户群里。法律风险和成本都是我们需要考虑的因素。此外，还存在一个问题，微信是否有开放接口允许我们放入一个机器人进行聊天。</p><p></p><p>另一个方向是将其变为技术支持的Copilot。对于某些问题不熟悉的技术支持人员，他们可以在内部先提问，然后根据得到的答案去回答客户。这就像一个文档查询助手，能够帮助他们提高效率。</p><p></p><p>对于我们来说，还有一个方向是在代码方面。目前我们只能生成小段代码，而不能大规模地输出代码。这是因为我们需要保证代码的质量，而且我们的公司风格不允许我们随便输出代码。我们只能说，基于个人为了提高效率，每个工程师都可以生成一些标准的代码段，然后修改和使用。我们暂时还不能将核心代码交出去让别人修改Bug。</p><p></p><h4>精彩分享9</h4><p></p><p>我们比较关注流量入口变化，可能未来流量的入口会集中在某些特定的平台或应用，比如阿里、苹果的Siri或者某些自然语言交互的入口。对此，我们已经开始与OpenAI等机构对话，并希望有很多的收获。</p><p></p><p>另一部分我门也关注自然语言问题的回答，即针对特定问题提供精准的回答。经过两个月的努力，我们的团队已经将准确率提高到40%以上。尽管这个数字可能并不令人满意，但在我们的业务中，这个准确率是可接受的。</p><p></p><p>我们还在努力解决自然语言模型的落地问题，这个过程的挑战性非常大，而且成本也很高。同时，我们也正在尝试使用智能体来做业务的归因分析。这是一个复杂的过程，需要考虑许多因素，比如天气、公众舆论、政府活动和内部调整等。在我们对智能体的分析中，我们发现真正的AutoGPT具有很强的自主性，难以完全控制，但是受控的智能体仍然是一种不错的选择。我们采用类似于langchain的方法，结合自己的编排，还加入了一些大模型的反思和纠错能力。通过这种方式，我们成功实现了一个业务比较复杂的归因案例，智能体能够回答出相关问题。</p><p></p><h4>精彩分享10</h4><p></p><p>我讲讲Oracle在做的的事情，Oracle本身它也是一个大玩家。首先，它在医疗领域有所发展，收购了一家公司，该公司拥有所有美国人的电子病历，包括病人在医院的所有医疗数据。对于任何公司来说，数据都非常重要。Oracle&nbsp;花费280亿购买这样的公司，这表明公司的领导层有先见之明。</p><p></p><p>此外，Oracle还投资了AI公司，所以它拥有着大量的数据和模型，再者，Oracl也页与英伟达有战略合作关系，以满足他们的算力需求。</p><p></p><p>Oracle也提供像SaaS和ERP等产品，ERP常常被用于Planning。例如在工厂中，当工厂接收到大量订单时，必须决定在哪个工厂生产。然后，它们需要找到供应商来采购原材料，这些原材料的质量可能会有所不同，价格也可能会有所不同。这就需要对库存进行协调，确定哪些原材料可用，哪些原材料不可用，然后决定在哪里生产。Oracle曾经有一个相对封闭的Planning模型，但实际效果并不高。因此，产品部门现在正在考虑引入新的模型，以改进我们所谓的传统制造业。例如，他们想要使用大型模型来提高效率，并把这些新技术引入我们的产品中，提供下一代的AI辅助Planning</p><p></p><p>在国内，我们看到的大多是互联网公司，但针对传统制造业的软件企业其实相对较弱。我认为在改造传统制造业的生产流程方面，仍然有巨大的潜力和机会。无论是工业互联网，还是传统ERP的改造，都有很大的市场。</p><p></p><h4>精彩分享11</h4><p></p><p>在我看来，目前AI算力的底层，即显卡的需求供不应求，从CPU过渡到GPU，供应短缺并持续排队。特别是英伟达的新一代显卡H800引发了从今年下半年到明年的大规模需求。无论是迭代快速的模型还是计划中的大模型，现在都处在烧钱烧卡的阶段。对于显卡的国产化替代，虽然面临生态和技术支持问题，我们也必须去考虑，因为政策在不断变化。而在供应显卡给客户之后，我们面临的最大挑战是这项技术相当新，且很难高效利用。</p><p></p><p>如果发生故障，可能导致整个模型停止，造成巨大的成本损失。所以现在很多公司都在寻找专业人才来做优化。至于模型训练的进展，实话说，我们有些悲观。模型训练的效果如同做菜一样，取决于配方和烹饪顺序。每次启动大规模的训练都像是一次登月，无法预知结果。如果模型失败，可能几个月甚至几百万的资金就此损失。所以，我们需要深思如何持续发展这个行业。</p><p></p><h4>精彩观点12</h4><p></p><p>在我看来，我们之前用A100卡做过很多仿真工作，比如汽车碰撞实验和数字孪生，甚至还有马桶的流体力学模拟。早期的模型可能并不是使用A100，而是使用早一些的卡，包括多节点之间的互联以及同一台机器上多卡之间的互联。我们提供的RGB网络可以支持多节点之间的互联，比如两个节点之间的连接速度可以达到两秒的最大量。但是，当真正开始运行模型后，我们发现，增加节点并不能直接提高效率，反而会有衰减现象，尤其是在增加到三四台之后，衰减会更严重。目前来看，英伟达的卡因为比较成熟，所以效果会比较好，国产的卡可能还需要一段时间才能赶上。相比于现在的大模型，我们早期的汽车碰撞实验等仿真工作其实用的资源相对较少。</p><p></p><h4>精彩观点13</h4><p></p><p>我们这边主要从图形跟语音方面入手，之前我们使用小模型进行背景构图、图形增强以及数字处理等工作。但大模型的出现引发了我们的思考：在某个时间点上，大模型的通用能力是否会超过我们这种小模型精挑细走出来的能力？我们进行了测评，将通用模型与我们自己内部的精挑细琢的模型进行比较，发现在性能、CPU资源利用、完成时间以及最终效果方面，我们的小模型仍然要强于大模型。</p><p>尽管我们目前的实验结果还显示大模型在细分领域的专业上并未超过我们的小模型，我们仍然担心大模型的快速发展。我们不能排除在未来的某个时间点，它的通用能力会超过我们的小模型，就像GPT这样的大模型已经在某些领域的专业能力上超越了，比如客服的能力。因此，我们对图形和视频方面的发展保持警惕。</p><p></p><h4>活动推荐：</h4><p></p><p></p><p><a href=\"https://fcon.infoq.cn/2023/shanghai?utm_source=infoq&amp;utm_medium=conference\">FCon全球金融科技大会（2023·上海站）</a>\"是极客邦科技旗下InfoQ中国团队推出的面向金融行业高端技术管理者、技术专家的会议，50%参会者拥有8年及以上工作经验。</p><p></p><p>FCon聚焦当前金融行业遇到的问题，围绕金融企业在数字化转型过程中的痛点，例如数据治理，智能化、数字化风控，数字化投研，数字化营销，IT技术能力等方向，邀请国内外金融企业，来分享人工智能、区块链、大模型、大数据、数字货币等新一代信息技术实践话题，帮助听众解决技术和业务上的问题，提升技术能力。欢迎大家报名参会，<a href=\"https://fcon.infoq.cn/2023/shanghai?utm_source=infoq&amp;utm_medium=conference\">详细信息可点击这里查看</a>\"</p><p></p>",
    "publish_time": "2023-07-25 11:44:51",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "晟云磐盾郝峻晟：技术人如何走上创业之路，实现人生价值",
    "url": "https://www.infoq.cn/article/x5pfVaM4F0ghRfKr8ZQB",
    "summary": "<p></p><blockquote>在<a href=\"https://archsummit.infoq.cn/202304/shanghai/schedule\">ArchSummit上海站</a>\"的【架构师成长】专题论坛，InfoQ邀请了晟云磐盾总裁郝峻晟做了一场《技术人如何走上创业之路，实现人生价值》为题的分享，他从优秀的架构师与创业者对比入手，详细阐述了如何用云原生的架构思路，来设计敏捷的创业组织。本文为嘉宾演讲整理～</blockquote><p></p><p>&nbsp;</p><p>有人向我提问，为什么选择创业的道路？</p><p>&nbsp;</p><p>作为一名技术人员，我曾在微软初试职场，对编程有着浓厚的兴趣，并投入时间研发创新项目，我甚至为了追踪股市，编写了一个小型爬虫，自动获取新浪炒股数据，而无需亲自盯着屏幕。当时我尝试构建一个系统，当股票波动到一定幅度时，它能自动发出警报，甚至完成自动交易。但遗憾的是，这个想法并未实现，原因在于当时国内的证券市场APP不支持这样的操作。</p><p>&nbsp;</p><p>事实上，我把自己的许多工作通过程序自动化，这也导致我当时在微软的工作变得有些无聊，因为我大部分的任务都已自动化。今天，我们看到许多如低代码开发平台，其本质都在于解决这个问题，即通过技术来减少重复的人工操作。这段经历让我意识到，在大公司里单纯做一名程序员对我而言可能会有些无聊，所以我选择了创业这条艰辛的道路。创业过程中的困难和挑战，我会在接下来的分享中一一揭示。</p><p>&nbsp;</p><p></p><h4>优秀的架构师 VS 优秀的创业者</h4><p></p><p>&nbsp;</p><p>在昨天上午的主题论坛上，一位外国教授做了一场关于云原生架构的精彩讲座。他提到，在我们开发传统的单体应用程序时，我们使用的是瀑布模型，而当我们使用基于服务的软件架构，如BS、CS架构时，我们转向了敏捷开发流程的模型。如今，当我们以云原生或无服务器方式进行开发，我们更多地依赖于Devops。</p><p>&nbsp;</p><p>如何以敏捷方式快速迭代团队，对于加入一家公司、创业或组建一个团队来说，都至关重要。你们可能听说过OpenAI这家公司，他们开发了ChatGPT。这家公司最近非常火爆，你们知道他们刚开始时有多少员工吗？只有十几个人。还有Instagram，被Facebook收购之前也只有十几个人的团队。他们能够以数十人的团队规模，卖出一亿甚至两亿美元。这就是创业公司需要研究和深思的问题。</p><p>&nbsp;</p><p>我曾和多个基金投资人合作，与许多传统投资者讨论过企业规模的问题，他们往往觉得人数较少是一种困扰，但我认为这种看法是错误的。企业应该以敏捷的方式运营，依赖于技术和流程，而不是人力。随着ChatGPT和大模型的出现，这种趋势越来越明显。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/d5/d5ad9c4881f6877a701a6d08f92c9881.png\" /></p><p></p><p>&nbsp;</p><p>你可能经常对项目经理感到不满，觉得他们无法明确地表达需求。我想说的是，项目经理其实已经足够ok了。当你尝试与客户或销售人员讨论技术设计时，你会发现沟通非常困难。</p><p>&nbsp;</p><p>作为架构师，我们需要从服务对象的角度出发，要满足甲方的需求，他们希望成本低且能够使用现有的模块。在资源紧张的情况下，我们需要提供有效的解决方案，无论是对市场总监，还是对最终用户，我们都需要满足他们的需求。同时，我们还需要考虑运维人员，保证他们能够在短时间内掌握新的系统。最后，销售人员希望产品价格适中并且能够快速交付。所有这些考虑因素都对架构师提出了高要求，我们需要在压力下设计出支持高并发、高可用的系统，同时还需要满足客户的个性化需求。在大多数公司中，这是一项极具挑战的任务。</p><p>&nbsp;</p><p>另外，作为架构师，我们往往需要与开发总监紧密合作，不同的公司中，架构师与开发总监的关系可能会有所不同。在一些公司中，开发总监可能是架构师的直接上级，而在其他公司中，他们可能是同一级别的职位。无论哪种情况，都存在各种挑战。</p><p>&nbsp;</p><p>如果我们需要将传统的BS或CS架构容器化，你可能会预计需要花费三到六个月的时间将系统设计为容器模式，并通过Docker或Kubernetes等工具进行部署。然而，在这个过程中，你可能会遇到的一个挑战是，虽然你已经花费了半年的时间去做这项工作，但这并没有为客户或销售提供新的价值。他们看到的可能仅仅是一个在功能上并无任何变化的系统。对于架构师来说，这是一种压力，你会觉得自己的工作已经非常优秀，但对于其他人来说，他们无法看到这项工作的价值。</p><p>&nbsp;</p><p>我想要分享的第二个观点是，所有公司都存在一种所谓的“技术债务”。技术债务是指诸如缺乏文档的旧代码，开发过程中出现的各种问题，或者重复功能模块等一系列问题。当我们试图在开发团队中实行Devops流程时，可能会发现许多开发人员不熟悉这个流程。他们需要签入代码checkin，遵循各种流程和检查，以确保代码的质量达标。但是，有时业务需求极高，比如在明天就上线，这就使得整个CI/CD的流程变得压力重重。如果在这种情况下系统无法上线，责任往往会落到开发团队头上。但是如果说大家觉得这个架构师的人生已经非常痛苦了的话，其实不是这样的。</p><p>&nbsp;</p><p>作为架构师，如果你想走出技术领域，向创业迈进，我想分享的是，架构师的工作实际上只是整个过程的一部分。昨天我在讲解GPT的时候，提到在制定企业战略时，有一个重要的建模模型，即PEST模型。PEST代表政策（Policy）、经济（Economy）、社会（Social）和技术（Technology）。在这里，架构只是技术部分的一小部分。因此，如果你想建立一家公司，你可能需要再往前走一步，从公司的角度来考虑架构，思考公司应该如何运作，这将是我接下来要分享的内容。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/39/39d574bc75687b2ccf0293a76e9bb51f.png\" /></p><p></p><p></p><p>首先，作为架构师，我们需要具备软件工程师的核心能力，包括系统设计、系统分析、系统建模、评估、沟通以及领导力。作为架构师，我们的工作领域广泛，包括向客户提供新功能，以及优化系统架构。然而，这些工作中有些可能非常繁琐和复杂。例如，向客户提供新功能，这些功能需要能够满足客户的需求，同时为他们创造实际价值。我们还需要处理一些可见和不可见的价值，例如修复bug和优化架构。</p><p>&nbsp;</p><p>对于这些工作，我们需要有正确的商业认识。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d7/d7278d0eb0363ec04e714a34a6a82d66.png\" /></p><p></p><p>对于创业者来说，需要考虑的问题主要包括客户和股东（包括投资人）。为什么我现在投资各种基金呢？其实是希望通过这种方式了解更多的创业公司，了解他们在市场上的动态，同时帮助创业者更好地理解商业模式，让公司能够首先存活下来。</p><p>&nbsp;</p><p>创业其实是一件非常困难的事情，创业公司能够存活的比例非常低。我是在2012年创立的公司，如果今天再去回顾那个时候我知道的创业公司，我发现大约只有1/3的公司还存在，没有太大发展，不过仍在经营。还有许多企业已经注销或者不再经营了。如果我们去企查查上查询一些创业公司，会发现好多公司全是诉讼，创始人成了失信人欠了一堆钱。创业是个有趣的过程，因为一旦你开始，就没有回头路，你无法预知明天会发生什么。</p><p>&nbsp;</p><p>我曾在一些大学讲授创业课程，一个学生问我遇到的最大困难是什么？我的回答是：下一个困难。因为当你克服了一个困难，它就不再是困难，总是下一个困难，而且每次的困难都比上次难。所以，作为创业者，你需要在服务众多的客户和甲方时，找到更高的维度，更有趣的方法来解决我们的企业架构的创业问题。</p><p>&nbsp;</p><p>原来作为架构师的分析系统的能力是可以继续使用的，包括沟通力和领导力，对系统的评估、分析、建模，以及在公司内部的沟通能力和领导力，都是非常有用的。而且如果你能加强这些能力，会帮助我们架构师，在管理公司时变得更加理性和有逻辑，提高效率。但其实还有更多的能力要学习，如对市场的分析和建模。与我们进行软件系统建模的最大区别是，软件系统建模的对象是不变的，而市场分析和建模则面临的是一直在变化的市场环境。</p><p>&nbsp;</p><p>不论你是使用Docker，还是kubernetes，设计模式完成后，它们是不会变化的。然而，在市场或创业的环境中，你会发现最大的挑战是一切都在变，市场上的人，你的竞争对手，你的员工，甚至整个的商业逻辑都在不断变化。</p><p>&nbsp;</p><p>举例来说，如果你想做关于大型模型如ChatGPT的演讲，你可能会发现在你准备PPT两周后，内容就已经过期了。为什么呢？因为每天都有新的科技产品和创新出现，很多都是基于人工智能实现的。这时候，你就需要更深层次地考虑问题，而不是简单地用你原来的架构方式来处理。</p><p>&nbsp;</p><p>第二个需要提升的是沟通能力，这不仅包括内部沟通，如对老板、同事或下属，也包括对外的客户沟通。有些客户可能并不理性，他们更看重情感交流，你可能需要和他们共进晚餐或一起喝酒来建立良好的关系。</p><p>&nbsp;</p><p>此外，还包括诸如企业领导力、管理治理模式，以及市场、销售、财务、人事等各方面的管理知识。还有更为重要的企业架构设计，如如何分配股份a如何激励同事等。这些都是创业者需要学习和掌握的知识。每个领域的知识可能都需要在商学院中学习一学期才能掌握，而且还需要实际运用才能记住。</p><p>&nbsp;</p><p></p><h4>用云原生的架构来设计敏捷创业组织</h4><p></p><p>&nbsp;</p><p>但今天我想强调的不是这些创业应该怎么做，而是希望从架构师的角度来看，如何帮助架构师设计一个与云原生相关的企业。这是架构师的优势所在。为什么是优势呢？</p><p>&nbsp;</p><p>如果一个销售人员要创办公司，他会选择租用大展厅，政府领导参观时会感到开心，或者购买豪车来接送客户，这些都是传统的商业模式。然而这种模式，从我的角度来看，更多是基于人性和传统的关系型的商业模式。</p><p>&nbsp;</p><p>现如今，许多生意，或者说我们架构师能做的生意，其大部分实际上并不来自于人与人之间的关系型生意，而是来源于技术和创新。当然，人际关系也是必需的，我们不能完全忽视它。但是，如果还是坚持做这种关系型的生意，那么对于架构师来说，竞争优势可能并不明显。</p><p>&nbsp;</p><p>另外，插一句，如果你在做公司的战略分析，商学院一定会教你一个模型，叫做波特五力模型。波特五力模型就是用来分析你在市场上具有什么样的竞争优势？你的优势对他人有何影响？反之，他人的优势对你有何影响？这个过程就是所谓的竞争战略分析。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/f3/f3ba4d39a399722bf653961ba4d94f86.png\" /></p><p></p><p>云原生是一种建构关键业务系统的理念，它包括容器（Container）、自动化（Automation）、微服务（Microservices），以及现代化应用（Modern Applications）。这种理念强调的是业务需求的重要性，因此在创业或设计架构时，我们需要首先考虑业务需求。</p><p>&nbsp;</p><p>想象一下，仅有11个人的团队卖出了价值1亿美元的产品，这听起来十分令人向往。实际上，如果我们5人的团队，能够卖出价值5000万人民币的产品，那每人分到的就有1000万，这在上海也可以买下一套房产。关键在于我们如何用敏捷的方式来帮助企业快速成长，并最大化其价值。</p><p>&nbsp;</p><p>那么，如何提升一家创业公司的效率，或者让其价值最大化呢？首要的是要降低成本，同时赚取最多的收入。这就需要我们在市场上具有竞争优势。比如，你可以拥有比别人更多的客户，或者你的成本比别人低。但实际上，在如今变化如此之快的世界，我们常常需要应对各种不确定性，因此并非只有拥有更多客户或低成本就一定能成功。实际上，成功更可能来自于我们能否让公司以更快的速度获得收益，这就是所谓的“高频”。</p><p>&nbsp;</p><p>比如，你可能听说过996工作制。如果我每天工作12个小时，而你只工作6个小时，那么我就能比你更快地完成工作。有人知道亚马逊的设计框架是如何工作的吗？亚马逊官方网站上详细描述了如何构建一家高频企业。在这里，他们提到了工作分解，以及小团队的重要性。亚马逊有一种称为\"two pizza team\"的管理理念，也就是说每个小团队的人数应该控制在两个披萨就能吃饱的程度，也就是大约20人左右。这样可以避免团队过大导致会议过长，工作效率低下。</p><p>&nbsp;</p><p>同时，亚马逊也强调自动化的重要性。当我在微软工作时，大部分的工作都是通过自动化完成的。自动化不仅可以提高工作效率，也可以降低成本。最后，我们也需要接受失败的可能性。比如SpaceX在早期的测试中，火箭反复失败，但是他们并没有因此放弃，反而从中吸取教训，不断改进，最终成功。在中国，如果一个系统设计或程序发布后出现了问题，那么开发者是否还有机会修正他们的错误呢？在很多公司中，他们无法接受失败，这可能会阻碍创新和进步。因此，我们需要改变这种文化，接受并从失败中学习和进步。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/0d/0da479337095ed0a2c29e8a248d5ae8f.png\" /></p><p></p><p>&nbsp;在云原生的架构中，有几个重要的概念，如不可变的技术设施和业务平台。他们在云原生中是Docker和Kubernetes（K8S），他们提供了各种维护和运营功能。</p><p>&nbsp;</p><p>对于创业公司，一个有效的策略是构建一个薄平台，它能支持小团队快速迭代和交付产品或服务。这种平台能帮助公司提取出共性部分，从而实现快速发展。第二个关键要点是微服务，推崇所有应用程序应通过API进行通信。这种强调API而非人际信息传递的方式有助于提高沟通效率，并避免在信息传递过程中产生信息变形。</p><p>&nbsp;</p><p>第三个关键要点是容器编排和团队管理，提倡团队按照纵向（如前端、中台、后端）而非横向来进行组织和发展。这种组织方式对于创业公司和大型企业都适用，因为它鼓励纵向的开发流程。最后，DevOps和企业数字文化被认为是架构师向创业者转变的关键因素。它强调的是持续更新、持续发布和持续学习。</p><p></p><h4>从架构师走向创业者</h4><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/62/62234f13d2a8e6a34cb7d1eb613f8513.png\" /></p><p></p><p>如何从架构师转变为创业者？这是我从微软的网站上找到的关于云计算设计模式的介绍。我之前从事云计算的工作时，我对这些内容进行了深入的研究，其中也包括了分布式系统。云计算主要涉及负载均衡、故障转移等方面，例如在某些地方出现故障时，你可以切换到另一个服务实例。还有金丝雀部署和蓝绿部署等测试策略，以实现系统的持续可用性。虽然云计算设计模式有很多种，但由于它们相对稳定，所以实际上并不复杂。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/6a/6a951b995ee7698951875bce24e64cfc.png\" /></p><p></p><p>如果你有创业的打算，我强烈建议你详细了解商业模式画布。商业模式画布包括几个关键要素，你需要考虑的是：首先是关键合作伙伴，你要和谁合作？谁是你的合作伙伴？其次是关键活动，也就是你要做什么？你的系统要实现什么功能？第三个要素是关键资源，你了解哪些客户？你拥有哪些技术和能力，可以为客户提供什么价值？你与客户之间有何种关系？还有销售渠道，你的产品或服务将卖给谁？成本结构是什么样的？收入来源又是什么？如果仅仅考虑架构方面的问题，相比刚才所介绍的内容，这些要素会简单得多。然而，我的观点是你需要对商业模式画布有一个清晰的认识。</p><p>&nbsp;</p><p>当我们了解了架构的基础知识后，我强烈建议在从架构师转变为创业者或企业家的过程中，我们要意识到这些要素都是不断变化的，这是非常关键的。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/0f/0fa74598b255f11d72c30ee3a130aba1.png\" /></p><p></p><p>我给大家展示的是一个云计算设计模式的图表，其中模式非常多，而商业模式的要素相对较少。云计算和软件架构相对稳定和简单，而商业环境则非常复杂且经常变化。作为架构师，你可能经常感觉自己像是项目经理，今天有人告诉你要做A功能，明天又改成其他功能，这不是你的决定，而是客户的决定。然而，当你创办自己的公司时，你必须以客户为中心，满足客户的需求。客户今天可能满意某个功能，明天却改变主意，要求进行修改。这时候你需要思考如何持续满足客户需求，包括在部署后无法更改的情况下。同时，利益相关方的需求也在持续变化。</p><p>&nbsp;</p><p>人的行为模式是无法预测的，而系统的行为模式是可以预测的，包括应对逻辑和目标等方面。在商业环境中，我们会看到不同的人之间相互冲突。因此，我们建议在团队中实现各取所需的理念，让每个人都发挥自己的优势，这样才能使公司良好运转。然而，现实情况并非如此，尤其是从事技术工作的人常常认为自己是最厉害的。我曾经也这样认为，认为自己可以学会一切，但事实并非如此，你不可能掌握所有的知识和技能，因此你必须寻找合作伙伴，他可能是一个销售人员，你们之间的合作关系可能会非常好。</p><p>&nbsp;</p><p>但你需要花费很多时间来建立信任，由于你们两个人的角色互补，你们的个性和逻辑思维方式肯定也不一样，因此一开始可能会有些摩擦。无论是在公司内部还是创业公司中的各种团队，只要涉及到不同的人，就一定会有矛盾。你需要建立机制来解决信任和矛盾问题。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/e9/e9bd81063a941d3771d2ca30ff26ac0d.png\" /></p><p></p><p>在创业过程中，我们需要注意几个重要阶段。首先是建立自己的想法阶段。然后是概念化阶段，这两个阶段并不算是创业。真正的创业是当你辞职、建立公司并开始支付员工工资的那一刻。</p><p>&nbsp;</p><p>第三阶段是承诺阶段，表明你对创业有责任心，全身心投入其中。接下来是第一轮、第二轮和第三轮的阶段，包括验证创业概念的可行性。然后是扩张阶段，不断扩大业务规模并寻求资金支持。最后是建立商业环境，持续经营。</p><p>&nbsp;</p><p>因此，从创业的角度来看，你会发现这与架构师的系统思维有很多相似之处，特别是持续集成与持续交付（CI/CD）的系统。当你进行代码提交时，前面的步骤是在本地编写代码，然后是将其部署到生产环境，可能还有一个测试环境。然后是扩展阶段，对系统进行扩展并进行一些工作，最后将其部署到生产环境。</p><p>&nbsp;</p><p>因此，伟大的企业都是从基础需求开始，逐步满足个人和企业的需求。在每个阶段中，你会注意到企业不断向前推进。大家知道中国企业的平均寿命吗？企业的寿命通常会比人的寿命短，大约两年左右。在这个过程中，只有极其少数的企业能够成为伟大的企业。</p><p>&nbsp;</p><p>创业的第一步是对自己负责，对自己的认知能力负责，无论是作为架构师还是团队成员；第二步是对他人负责，作为架构师，通过你的工作来解决他人的需求。创业是解决相关问题的过程，创业首先是为了实现创意，关注小团队，解决小问题。</p><p>&nbsp;</p><p>但如果你想打造一家伟大的企业，你就要进入第三步。在这个阶段，你需要对股东负责，了解市场的变化，并能够承担起企业和社会的责任。在这个过程中，你要努力帮助企业和我们的环境、社区不断成长。如果你有这样的想法或梦想，希望改变世界，我强烈建议你跳入市场，为了共同的利益，实现自己的价值，也帮助他人实现他们的价值。</p><p></p><h4>活动推荐：</h4><p></p><p></p><p><a href=\"https://fcon.infoq.cn/2023/shanghai?utm_source=infoq&amp;utm_medium=conference\">FCon全球金融科技大会（2023·上海站）</a>\"是极客邦科技旗下 InfoQ 中国团队推出的面向金融行业高端技术管理者、技术专家的会议，50%参会者拥有 8 年及以上工作经验。</p><p></p><p>FCon 聚焦当前金融行业遇到的问题，围绕金融企业在数字化转型过程中的痛点，例如数据治理，智能化、数字化风控，数字化投研，数字化营销，IT 技术能力等方向，邀请国内外金融企业，来分享人工智能、区块链、大模型、大数据、数字货币等新一代信息技术实践话题，帮助听众解决技术和业务上的问题，提升技术能力。欢迎大家报名参会，<a href=\"https://fcon.infoq.cn/2023/shanghai?utm_source=infoq&amp;utm_medium=conference\">详细信息可点击这里查看</a>\"</p>",
    "publish_time": "2023-07-25 12:07:04",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]