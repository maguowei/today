[
  {
    "title": "PHP 8：类型系统改进",
    "url": "https://www.infoq.cn/article/syFMveVDuy7UdOUCG7Cl",
    "summary": "<p></p><blockquote>本文属于专题文章<a href=\"https://www.infoq.cn/theme/php8-article-series\">《深入浅出 PHP 8》</a>\"。根据<a href=\"https://w3techs.com/technologies/details/pl-php\">w3tech</a>\"的数据，PHP 仍然是 Web 上使用最广泛的脚本语言之一，77.3%的网站使用 PHP 进行服务器端编程。PHP 8 带来了许多新特性和其他改进，我们将在本系列文章中进行探讨。PHP 8.0 添加了对多个函数和方法相关特性的支持，其中一些是对现有特性的改进，而另一些则是全新的特性。PHP 8.1 中增强的可调用语法可用于通过可调用对象创建匿名函数。命名函数参数可以与位置参数一起使用，另外还有一个好处，即命名参数没有顺序，可以通过它们的名称来传达含义。纤程（Fiber）是可中断的函数，增加了对多任务的支持。</blockquote><p></p><p></p><p>在本文中，我们将讨论PHP 8、8.1和8.2对PHP类型系统的扩展，其中包括联合类型、交集类型和mixed 类型，以及返回类型static 和never 。</p><p></p><p>此外，PHP 8还支持独立类型true、null和false。</p><p></p><h2>一些定义</h2><p></p><p></p><p>在PHP中，类型声明与类属性、函数参数和函数返回类型一起使用。我们经常使用各种定义从类型系统方面描述一种语言：强/弱，动态/静态。</p><p></p><p>PHP是一种动态类型语言。所谓动态类型是指类型检查是在运行时进行的，与之相对的是在静态编译时进行类型检查。PHP默认是弱类型的，这意味着它在运行时支持的隐式类型转换规则比较少。不过，在PHP中可以启用强类型。</p><p></p><p>PHP会在不同的上下文中使用类型：</p><p></p><p>独立类型：可以在类型声明中使用的类型，如int、string、array；字面量类型：除了值的类型之外，还对值本身进行检查的类型。PHP支持两种字面量类型：true和false；单元类型：保存单个值的类型，如null。除了简单类型之外，PHP 8还引入了复合类型，如联合类型和交集类型。联合类型是多个简单类型的并集。其值只需匹配联合类型中的一种类型。联合类型可用于指定类属性、函数形参的类型或函数返回类型。新增类型mixed 是联合类型的一种特殊类型。</p><p></p><p>PHP 8.1还增加了交集类型，用于说明那种是多个类类型的交集的类类型。它还增加了两个新的返回类型。如果函数无返回值，则使用返回类型never 。例如，当函数抛出异常或调用exit()时，可能出现这种情况。返回类型static意味着返回值必须是调用该方法的类的实例。</p><p></p><h2>联合类型</h2><p></p><p></p><p>如果你熟悉文氏图，那么你可能还记得集合的并集和交集。为了支持简单类型的并集，PHP 8引入了联合类型。用于声明联合类型的语法如下：</p><p></p><p><code lang=\"php\">Type1|Type2|....|TypeN\n</code></p><p></p><p>我们首先看个例子。在下面的脚本中，$var1属于联合类型int|string|array 。它被初始化为一个整数值，然后它被设置为联合类型声明中包含的其他类型的值。</p><p></p><p><code lang=\"php\"><!--?php\n\nclass A{\n\n  public int|string|array $var1=1;\n \n}\n\n$a= new A();\necho $a--->var1;\n$a-&gt;var1=\"hello\";\necho $a-&gt;var1;\n$a-&gt;var1=array(\n    \"1\" =&gt; \"a\",\n    \"2\" =&gt; \"b\",\n);\nvar_dump($a-&gt;var1);\n</code></p><p></p><p>上述脚本输出如下：</p><p></p><p><code lang=\"plain\">1\nhello\narray(2) { [1]=&gt; string(1) \"a\" [2]=&gt; string(1) \"b\" }\n</code></p><p></p><p>由于PHP是弱类型语言，如果将$var1的值设置为float值1.0，就会执行隐式转换。下面的脚本将输出1。</p><p></p><p><code lang=\"php\"><!--?php\n\n//declare(strict_types = 1);\nclass A{\n\npublic int|string|array $var1=1;\n \n}\n\n$a= new A();\n \n$a--->var1=1.0;\necho $a-&gt;var1;\n</code></p><p></p><p>然而，如果在声明时启用了强类型declare(strict_types = 1) ，那么就不能将$var1 设置为1.0 ，否则会报下面这个错：</p><p></p><p><code lang=\"plain\">Uncaught TypeError:无法将浮点数赋给array|string|int类型的属性A::$var1\n</code></p><p></p><p>有时候，在弱类型的情况下，可以将值转换为密切相关的类型，但这种转换并非总能执行。例如，我们不能像下面的脚本那样，给联合类型（int|array ）的变量赋字符串值：</p><p></p><p><code lang=\"php\"><!--?php\n\nclass A{\n\npublic int|array $var1=2;\n \n}\n\n$a= new A();\n \n$a--->var1=\"hello\";\necho $a-&gt;var1;\n</code></p><p></p><p>上述脚本会报如下错误：</p><p></p><p><code lang=\"plain\">Uncaught TypeError: 无法将字符串赋给array|int类型的属性A::$var1\n</code></p><p></p><p>我们看一个稍微复杂一点的例子。下面的脚本在类属性声明、函数参数和函数返回类型中使用了联合类型。</p><p></p><p><code lang=\"php\"><!--?php\n\nclass A{\n\npublic string|int|bool $var1=true;\n\nfunction fn1(string|int|array $a, object|string $b): \n\nstring|bool|int {\n    return $a;\n}\n\n}\n$a=new A();\necho $a--->var1;\necho $a-&gt;fn1(\"hello\",\"php\"); \n</code></p><p></p><p>输出如下：</p><p></p><p><code lang=\"plain\">1\nhello\n</code></p><p></p><h3>联合类型中的null</h3><p></p><p></p><p>联合类型可以为空，在这种情况下，null是联合类型声明中的类型之一。在下面的脚本中，类属性、函数参数和函数返回类型都声明为可空的联合类型。</p><p></p><p><code lang=\"php\"><!--?php\n\nclass A{\n\npublic string|null $var1=null;\n\nfunction fn1(string|int|null $a=null, object|false|null $b=null): \n\nstring|bool|null {\n    return null;\n}\n\n}\n$a=new A();\necho $a--->var1;\necho $a-&gt;fn1(); \n</code></p><p></p><h3>联合类型中的false</h3><p></p><p></p><p>伪类型false可用于联合类型。在下面的示例中，false类型用于类属性声明、函数参数和函数返回类型，它们全都声明为联合类型。</p><p></p><p><code lang=\"php\"><!--?php\n\nclass A{\n\npublic string|int|false $var1=1;\n\nfunction fn1(string|int|false $a, false|string $b): \n\nstring|false|int {\n    return $a;\n}\n\n}\n$a=new A();\necho $a--->var1;\necho $a-&gt;fn1(\"hello\",false);\n</code></p><p></p><p>输出如下：</p><p></p><p><code lang=\"plain\">1\nhello\n</code></p><p></p><p>如果在联合类型中使用了bool，则不能再使用false，那会被认为是重复声明。考虑下面的脚本，其中一个函数在声明参数时使用了包含false和bool的联合类型。</p><p></p><p><code lang=\"php\"><!--?php\nfunction fn1(string $a, bool|string|false  $b): object {\n    return $b;\n} \n</code--></code></p><p></p><p><code lang=\"php\">执行上述脚本会显示如下错误信息：</code></p><p></p><p><code lang=\"php\"><code lang=\"plain\">重复类型false是多余的\n</code></code></p><p></p><h3><code lang=\"php\">联合类型中的class类型</code></h3><p></p><p></p><p><code lang=\"php\">Class类型可以用于联合类型。如下所示，在联合类型中使用class类型A：</code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A{}\n \nfunction fn1(string|int|A $a, array|A $b): A|string  {\n    return $a;\n}\n$a=new A();\nvar_dump(fn1($a,$a));\n</code--></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">object(A)#1 (0) { }\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">但是，如果联合类型中使用了object 类型，就不能再使用class类型了。下面的脚本在联合类型中同时使用了class类型和object 。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A{}\n \nfunction fn1(object|A $a,  A $b): A   {\n    return $a;\n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">执行上述脚本会显示如下错误信息：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">类型A|object中同时包含object和class类型，这是多余的\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">如果联合类型中使用了iterable，则不能再使用array和Traversable。下面的脚本在联合类型中同时使用了array 和iterable：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nfunction fn1(object $a, iterable|array $b):  iterable {\n     \n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">执行上述脚本会显示如下错误信息：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">类型iterable|array中同时包含iterable和array类型，这是多余的\n</code></code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">联合类型与类继承</code></code></code></h3><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">如果一个类继承了另一个类，那么联合类型可以单独声明两个类，或者只声明超类。例如，在下面的脚本中，类C继承了类B，类B又继承了类A。然后，在声明联合类型的函数参数时把类A、B和C都包含了进去。</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A  {\nfunction fn1(){\n  return \"Class A object\";\n}\n}\n\nclass B extends A {\nfunction fn1(){\n  return \"Class B object\";\n}\n}\n\nclass C extends B {\nfunction fn1(){\n  return \"Class C object\";\n  }\n}\n\n$c = new C();\n \n\nfunction fn1(A|B|C $a, A|B|C $b): string {\n     \n    return $a--->fn1();\n}\n\necho fn1($c,$c);\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">Class C object\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">或者，在声明fn1 的参数时可以只使用A 类型，输出不变：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">  function fn1(A $a, A $b): string {\n     \n    return $a-&gt;fn1();\n}\n</code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\">联合类型中的void</code></code></h3><p></p><p></p><p><code lang=\"php\"><code lang=\"php\">不能在联合类型的返回类型中使用void 。执行如下脚本：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nfunction fn1(int|string $a, int|string $b): void|string {\n     \n    return $a;\n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">将显示如下错误信息：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">Void只能作为独立类型使用\n</code></code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">联合类型的隐式类型转换</code></code></code></h3><p></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">前面我们提到过，如果不启用强类型，那么当一个值与联合类型中的任何类型都无法匹配时，它将转换为与之密切相关的类型。但是，哪些是密切相关的类型呢？隐式转换会按以下优先顺序进行：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">整型浮点型字符串型布尔型例如，在下面的脚本中，字符串值\"1\"将被转换成一个浮点数：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\n \nclass A{\n\npublic  float|bool  $var1=true;\n \n}\n\n$a= new A();\n \n$a--->var1=\"1\";\nvar_dump($a-&gt;var1);\n?&gt;\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">float(1)\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">但是，如果联合类型中包含int，则输出为int(1)。在下面的脚本中，联合类型（int|float）变量被赋值为字符串\"1.0\"。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A{\n\npublic  int|float    $var1=1;\n \n}\n\n$a= new A();\n \n$a--->var1=\"1.0\";\nvar_dump($a-&gt;var1);\n?&gt;\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">float(1)\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">在下面的脚本中，字符串值\"true\"会被解释成string 值，因为联合类型中包含string 。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A{\n\npublic  float|bool|string   $var1=1;\n \n}\n\n$a= new A();\n \n$a--->var1=\"true\";\nvar_dump($a-&gt;var1);\n?&gt;\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">string(4) \"true\"\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">但是，在下面的脚本中，字符串值\"true\"会被转换成bool 值，因为联合类型中不包含string 。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A{\n\npublic  float|bool    $var1=1;\n \n}\n\n$a= new A();\n \n$a--->var1=\"true\";\nvar_dump($a-&gt;var1);\n?&gt;\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">bool(true)\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">下面这个例子的输出难以预测。这个脚本将一个字符串值赋给联合类型为int|bool|float的变量。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A{\n\npublic  int|bool|float    $var1=1;\n \n}\n\n$a= new A();\n \n$a--->var1=\"hello\";\nvar_dump($a-&gt;var1);\n?&gt;\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">bool(true)\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">string被转换为bool值，因为它无法转换为int或float。</code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\">新增的mixed类型</code></code></h2><p></p><p></p><p><code lang=\"php\"><code lang=\"php\">PHP 8引入了一个名为mixed的新类型，它相当于联合类型object |resource|array|string|int|float|bool|null。例如，在下面的脚本中，mixed被用作类属性类型、函数参数类型和函数返回类型。启用强类型是为了证明mixed不受强类型所影响。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\ndeclare(strict_types = 1);\n\nclass A{\n\npublic  mixed    $var1=1;\n \nfunction fn1(mixed $a):mixed{ return $a;}\n}\n\n$a= new A();\n  \nvar_dump($a--->fn1(true));\nvar_dump($a-&gt;var1);\n$a-&gt;var1=\"hello\";\nvar_dump($a-&gt;var1);\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">显然，mixed非常灵活，可以输出不同类型：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">bool(true) \nint(1) \nstring(5) \"hello\"\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">在联合类型中将其他标量类型与混合类型一起使用是多余的，因为mixed类型是所有其他标量类型的联合类型。请看下面的脚本，在一个联合类型中同时使用int和mixed类型。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><!--?php\n \nclass A{\n\nfunction fn1(int|mixed $a):mixed{ return $a;}\n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">执行脚本会显示如下错误信息：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">类型mixed只能作为独立类型使用\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">类似地，mixed 也不能和任何类类型一起使用。下面的脚本会显示同样的错误信息：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n \nclass A{}\nclass B{\n\nfunction fn1(A|mixed $a):mixed{ return $a;}\n}\n</code--></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">子类的方法可以缩小返回类型mixed。例如，子类中的函数fn1将返回类型mixed缩小为array。</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \nclass A{\npublic function fn1(mixed $a):mixed{ return $a;}\n}\nclass B extends A{\n\npublic function fn1(mixed $a):array{ return $a;\n\n}\n</code--></code></code></code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">新增的独立类型null、false和true</code></code></code></code></h2><p></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">在PHP 8.2之前，null类型是PHP的单元类型，即保存单个值的类型。类似地，false类型是bool类型的字面量类型。不过，null和false类型只能在联合类型中使用，而不能作为独立类型使用。要证明这一点，可在PHP 8.1及更早的版本中运行如下脚本：</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A{\n\npublic  null $var1=null;\n\n}\n$a=new A();\necho $a--->var1;\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">在PHP 8.1中，该脚本会输出以下错误信息：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">Null不能作为独立类型使用\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">类似地，为了证明在PHP 8.1或更早的版本中，false类型不能作为独立类型使用，可运行以下脚本：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A{\n\npublic false $var1=false;\n\n}\n</code--></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">在PHP 8.1中，该脚本会生成如下错误信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">False不能作为独立类型使用\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">PHP 8.2支持将null和false作为独立类型来使用。下面的脚本使用null作为方法参数类型和方法返回类型。</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><!--?php\n\nclass NullExample {\n  public null $nil = null;\n \n  public function fn1(null $v): null { return null;  }\n}\n</code--></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">null不能使用?null 显式标记为可空。要证明这一点，可运行以下脚本：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n \nclass NullExample {\n    public null $nil = null;\n \n    public function fn1(?null $v): null { return null;  }\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">该脚本会生成以下错误信息：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">null不能标记为可空\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">以下脚本将false 作为独立类型来使用：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \nclass FalseExample {\n    public false $false = false;\n \n    public function fn1(false $f): false { return false;}\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">null 和false 可以用于联合类型，如下所示：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \nclass NullUnionExample {\n    public null $nil = null;\n \n    public function fn1(null $v): null|false { return null;  }\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">此外，PHP 8.2还新增了一个类型true，它可以用作独立类型使用。下面的脚本使用true作为类属性类型、方法参数类型和方法返回类型。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><!--?php\n\nclass TrueExample {\n    public true $true = true;\n \n    public function f1(true $v): true { return true;}\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">true 类型不能和false一起用于联合类型，如下所示：</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n \nclass TrueExample {\n \n    public function f1(true $v): true|false { return true;}\n}\n</code--></code></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">该脚本会生成以下错误信息：</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">类型同时包含true和false，应该用bool来替代它们\n</code></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">类似地，true 也不能和bool 一起用于联合类型，如下所示：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">class TrueExample {\n        public function f1(true $v): true|bool { return true;}\n}\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">该脚本会生成以下错误信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">重复类型true是多余的\n</code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">交集类型</code></code></code></code></h2><p></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">PHP 8.1将交集类型作为复合类型引入。交集类型可以与类和接口类型一起使用。交集类型用于表示多个类和接口类型的类型，而不是单个类或接口类型的类型。交集类型的语法如下：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">Type1&amp;Type2...TypeN\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">何时使用交集类型，何时使用联合类型？如果一个类型表示多个类型中的一个，则使用联合类型。如果一个类型要同时表示多个类型，则使用交集类型。下面这个例子很好地说明了这种差异。A、B和C是3个相互之间没有关系的类。如果一个类型要表示这些类型中的任何一个，则要使用联合类型，如下所示：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A\n{\n  function fn1(){\n    return \"Class A object\";\n  }\n}\n\nclass B  \n{\n  function fn1(){\n    return \"Class B object\";\n  }\n}\n\nclass C  \n{\n  function fn1(){\n    return \"Class C object\";\n  }\n}\n\n$c = new C();\n \n\nfunction fn1(A|B|C $a, A|B|C $b): string {\n     \n    return $a--->fn1();\n}\n\necho fn1($c,$c); \n?&gt;\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">输出如下：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">Class C object\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">这里如果使用交集类型，就会产生错误。修改这个函数，使用交集类型：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">function fn1(A&amp;B&amp;C $a, A&amp;B&amp;C $b): string {\n     \n    return $a-&gt;fn1();\n}\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">执行上述脚本会产生以下错误信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">Uncaught TypeError: fn1(): 参数 #1 ($a)的类型必须是A&amp;B&amp;C，但提供了C\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">如果C 继承了B ，B 继承了A ，就可以使用交集类型了，如下所示：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A\n{\n  function fn1(){\n  return \"Class A object\";\n}\n}\n\nclass B  extends A\n{\n  function fn1(){\n  return \"Class B object\";\n}\n}\n\nclass C  extends B\n{\n  function fn1(){\n  return \"Class C object\";\n  }\n}\n\n$c = new C();\n \n\nfunction fn1(A&B&C $a, A&B&C $b): string {\n     \n    return $a--->fn1();\n}\n\necho fn1($c,$c); \n?&gt;\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">输出如下：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">Class C object\n</code></code></code></code></code></p><p></p><h3><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">标量类型与交集类型</code></code></code></code></h3><p></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">交集类型只能与类和接口类型一起使用，但不能与标量类型一起使用。为了证明这一点，修改前述脚本中的fn1函数，如下所示：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">function fn1(A&amp;B&amp;C&amp;string $a, A&amp;B&amp;C $b): string {\n     \n}\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">执行上述脚本会产生以下错误信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">string类型不能作为交集类型的一部分\n</code></code></code></code></code></p><p></p><h3><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">交集类型与联合类型</code></code></code></code></h3><p></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">交集类型不能与联合类型组合使用。具体来说，在同一类型声明中，交集类型表示法不能与联合类型表示法组合使用。为了证明这一点，修改fn1函数如下：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">function fn1(A&amp;B|C $a, A&amp;B|C $b): string {\n    \n}\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">上述脚本会导致如下解析错误信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">Parse error: 语法错误，需要变量，但意外遇到符号“|”\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">在同一个函数声明中，交集类型可以与联合类型一起使用，如下所示：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">function fn1(A&amp;B&amp;C $a, A|B|C $b): string {\n       \n}\n</code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">返回类型static与never</code></code></code></code></h2><p></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">PHP 8.0引入了一个新的返回类型static ，PHP 8.1引入了一个新的返回类型 never。</code></code></code></code></p><p></p><h3><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">返回类型static</code></code></code></code></h3><p></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">如果返回类型指定为static ，则返回值的类型必须是定义方法的类的类型。例如，类A中定义的fn1方法返回类型为static，因此，该方法必须返回类型为A的值，即声明该函数的类。</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A \n{\n    public int $var1=1;\n    public function fn1(): static\n    {    \n      return new A();\n    }\n}\n\n \n$a=new A();\necho $a--->fn1()-&gt;var1;\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">输出如下：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">1\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">返回类型声明为static 的函数必须属于某个类。为了证明这一点，声明一个返回类型为static 的全局函数：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\n  function fn1(): static\n    {    \n       \n    }\n</code--></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">上述脚本会导致如下错误：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">当没有处于活动状态的类作用域时，不能使用“static”\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">返回的类对象必须是外围类。下面的脚本会生成一个错误，因为返回值是类类型B，而返回类型static 要求返回类型为类型A。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\n \nclass B{}\nclass A \n{\n    public int $var1=1;\n    public function fn1(): static\n    {    \n      return new B();\n    }\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">上述脚本会产生以下错误：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">Uncaught TypeError: A::fn1(): 返回类型必须为类型A，但返回了B \n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">如果类B 继承了类A ，那么上述脚本就不会有什么问题，将输出1 。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">class B extends A{}\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">返回类型static 可用于联合类型。如果在联合类型中使用static ，则返回值不一定是类类型。例如，以下脚本在联合类型中使用了static：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A \n{\n    public int $var1=1;\n    public function fn1(): static|int\n    {    \n      return 1;\n    }\n}\n\n \n$a=new A(); \necho $a--->fn1();\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"> 1\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">类型static 不能用于交集类型。为了证明这一点，请看下面的脚本：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass B extends A{}\nclass A \n{\n    public function fn1(): static&B\n    {    \n      return new B();\n    }\n}\n</code--></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">该脚本会导致以下错误：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">类型static不能作为交集类型的一部分\n</code></code></code></code></code></code></p><p></p><h3><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">返回类型never</code></code></code></code></code></h3><p></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">如果返回类型为never，则函数必须不返回值，或者根本不返回，即函数不终止。返回类型never 是其他所有返回类型的子类型。也就是说，在继承一个类时，never 可以在重写方法中替换任何其他返回类型。返回never 的函数必须执行以下操作之一：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">抛出一个异常调用 exit()启动一个无限循环如果返回never 的函数永远不会被调用，那么这个函数可以为空，如下所示：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A\n{\nfunction fn1(): never {\n     \n} \n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">类A中的函数fn1()不能被调用，因为该函数隐式返回NULL 。为了证明这一点，我们将上述脚本修改为：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A {\nfunction fn1(): never {\n   } \n}\n\n$a=new A();\n$a--->fn1();\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">执行该脚本将生成以下错误信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">Uncaught TypeError: A::fn1(): 返回never的函数不能隐式返回\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">下面的脚本将生成同样的错误消息，因为if条件永远无法满足，而函数隐式返回NULL：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nfunction fn1(): never\n{\n    if (false) {\n        exit();\n    }\n}\nfn1();\n</code--></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">与static 返回类型不同，never可以用作不属于类作用域的函数的返回类型，例如：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A\n{\n  \n}\n \nfunction fn1(): never {\n     \n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">返回类型为never的函数一定不能返回值。为了证明这一点，下面的脚本声明了一个函数，该函数试图返回值，尽管它的返回类型为never。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\n  function fn1(): never\n    {    \n     return 1;\n    }\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">执行上述脚本会生成以下错误信息：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">返回never的函数必须没有返回值\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">如果返回类型为never，则函数即使是隐式返回也不行。例如，下述脚本中的fn1函数不返回值，而是在其作用域结束时隐式返回。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><!--?php\n\n  function fn1(): never\n    {    \n    }\n\nfn1();\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">上述脚本会导致以下错误：</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">Uncaught TypeError: fn1(): 返回never的函数不能隐式返回\n</code></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">声明返回类型为never且不会终止的函数有什么用？返回类型never 可以在开发、测试和调试期间使用。返回never类型的函数可以通过调用exit()退出。这样的函数甚至可以被调用，如下面的脚本所示：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n\n  function fn1(): never\n    {    \n      exit(); \n    }\n\nfn1();\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">返回never类型的函数可以抛出异常，如下所示：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\n  function fn1(): never {\n      \n    throw new Exception('Exception thrown');\n     \n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">包含无限循环的函数可以将返回类型声明为never ，如下所示：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\n  function fn1(): never {\n     while (1){}\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">返回类型never 可以覆盖派生类中的任何类型，如下所示：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\nclass A\n{\n   \n  function fn1(): int {\n      \n  }\n}\nclass B extends A{\nfunction fn1(): never {\n      \n}\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">返回类型never 不能用于联合类型。为了证明这一点，下面的脚本在联合类型中使用了never ：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \nclass A{  \nfunction fn1(): never|int {\n      \n}\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">该脚本将导致以下错误：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">never只能作为独立类型使用\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">never 类型不能用于交集类型。为了证明这一点，请运行以下将never和类类型B 一起使用的脚本。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \nclass B{}\nclass A{  \nfunction fn1(): never&B {\n      \n}\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">该脚本将导致以下错误：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">类型never不能作为交集类型的一部分\n</code></code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">标量类型不支持别名</code></code></code></code></code></h2><p></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">从PHP 8开始，如果使用标量类型别名，就会生成警告信息。例如，如果使用boolean代替bool，则生成一条消息，说明boolean 将被解释成类名。为了证明这一点，考虑下面的脚本，函数声明将integer作为参数类型。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n    function fn1(integer $param) {}\n    fn1(1);\n?-->\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">如下所示，该脚本的输出中将包含一条警告信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">警告：“integer”将被解释为类名。你是指“int”吗？输入“\\integer”来消除该警告\n\nFatal error: Uncaught TypeError: fn1():参数#1 ($param)必须是integer类型，但提供的是int\n</code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">不再支持从void函数通过引用返回</code></code></code></code></h2><p></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">从PHP 8.1开始，不再支持从void函数通过引用返回，因为只有变量引用可以通过引用返回，而void返回类型不返回值。为了证明这一点，可运行下面的脚本：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><!--?php\nfunction &fn1(): void {}\n?-->\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">该脚本将输出一条弃用提示信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">弃用：不再支持从void函数通过引用返回\n</code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">小结</code></code></code></code></h2><p></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">在本文中，我们讨论了PHP 8中引入的与类型相关的新特性，包括联合类型、交集类型和mixed 类型，以及返回类型static 和never 。在下一篇文章中，我们将介绍与PHP数组、变量、运算符和异常处理相关的新特性。</code></code></code></code></p><p></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">原文链接：</code></code></code></code></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.com/articles/php-8-type-system-improvements/\">https://www.infoq.com/articles/php-8-type-system-improvements/</a>\"</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">相关阅读：</code></code></code></code></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.cn/article/XkzLrAYhV1CWPDzu72N2\">PHP 8：注解、match 表达式及其他改进</a>\"</code></code></code></code></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.cn/article/XkIrT3XLmZFW9XdoJS1F\">PHP 8：类和枚举</a>\"</code></code></code></code></p>",
    "publish_time": "2023-07-25 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]