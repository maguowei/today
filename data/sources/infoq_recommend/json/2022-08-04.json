[
  {
    "title": "全面拆解实时分析数据存储系统Druid",
    "url": "https://www.infoq.cn/article/rZVXjXqlGNEdDwZdpJ5c",
    "summary": "<p>&nbsp;</p><p></p><blockquote>本文对论文“<a href=\"https://www.micahlerner.com/assets/papers/druid.pdf\">Druid：一个实时分析数据存储系统</a>\"”进行了概括总结，对Druid的架构、存储格式、查询API等进行了简要介绍。如需深入了解更多的细节，请查看论文原文。</blockquote><p></p><p></p><h2>这篇论文研究的是什么</h2><p></p><p>&nbsp;</p><p>Druid是一个开源数据库，可以实现低延迟的近实时和历史数据分析。Druid最初是由广告技术公司MetaMarkets开发的，后来被Snap收购，现在已被Netflix、Confluent和Lyft等公司应用于各种不同的场景中。</p><p>&nbsp;</p><p>Druid的目标是支持近实时的和历史数据访问模式，这让它变得非常独特，并被应用在非常广泛的场景中——例如，近实时的数据摄取可以让应用程序（如生产警报）基于日志快速发现问题（类似于Netflix的应用场景），同时也可以基于大量历史数据执行警报逻辑。相比之下，许多数据仓库产品都是以“批处理”为基础，这导致记录指标时的时间与进行分析时的时间之间出现延迟。</p><p>&nbsp;</p><p>除了介绍系统的设计和实现外，这篇论文还讨论了系统组件可用性的降低是如何影响用户的。很少有论文会用这种方式来组织有关生产系统的论文，而且这种方式令人耳目一新。</p><p>&nbsp;</p><p></p><h2>这篇论文的贡献</h2><p></p><p>&nbsp;</p><p>这篇论文有以下几个贡献。</p><p>&nbsp;</p><p>对系统架构进行了描述；探索设计决策和实现；对系统查询API和性能结果进行了评估。</p><p>&nbsp;</p><p></p><h2>系统的工作原理</h2><p></p><p>&nbsp;</p><p></p><h3>分片和数据源</h3><p></p><p>&nbsp;</p><p>片段是Druid的一个关键抽象。它们是一种不可变（但有版本控制）的数据结构，其中保存了一系列记录。片段的集合组合成数据源，也就是Druid的数据库表。每个片段中保存了某个数据源在一个时间段内写入的记录。</p><p>&nbsp;</p><p><img src=\"https://static001.infoq.cn/resource/image/4b/22/4b74a219d0d4abdafb33a8390f998122.png\" /></p><p></p><p></p><h3>系统架构</h3><p></p><p>&nbsp;</p><p>Druid通过摄取数据来构建片段，然后在对查询做出响应时访问这些片段。</p><p>&nbsp;</p><p>Druid通过四种类型的节点来实现数据的摄入和查询：实时节点、历史节点、Broker节点和协调器节点。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/34/341fdbe657a5d0e3b7c03b4412e0e6d7.png\" /></p><p></p><p>与单个无状态节点不同，Druid将状态存储在两个数据源中。</p><p>&nbsp;</p><p>MySQL，其中包含了配置信息和元数据，比如片段的索引。Zookeeper，存储系统的当前状态（包括片段的副本保存在系统中的哪些分布式节点上）。</p><p></p><h4>实时节点</h4><p></p><p>&nbsp;</p><p>实时节点有两个职责：从生产者那里获取数据和响应用户对最新数据的请求。</p><p>&nbsp;</p><p>生产者将原始数据（比如数据库中的记录行）或转换后的数据（比如流式处理管道的输出）发送给实时节点——常见的生产者模式依赖了Kafka主题。Kafka（或其他消息总线）为数据提供了更好的可用性和可伸缩性——实时节点可以保存它们已经消费的偏移量，在发生崩溃或重启时可以重置到这个偏移量。为了提高伸缩性，可以用多个实时节点分别读取相同消息总线的不同子集。</p><p>&nbsp;</p><p>当实时节点在消费来自生产者的记录时，它会检查与记录关联的时间段和数据源，然后将记录路由到具有相同（时间段、数据源）键的内存缓冲区中。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e1/e1e8da3d435ac63c6b93b957460ce649.png\" /></p><p></p><p>每个（时间段、数据源）缓冲区在被清除之前会暂时保留在节点上——由于资源有限，节点需要定期从内存中清除记录缓冲区。在回收时，内存缓冲区中的数据将被写入“深度”存储系统（如S3或谷歌云存储）。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/13/13c67e4e019eb808efb19f1c2e9928f1.png\" /></p><p></p><p>&nbsp;</p><p>除了数据摄取之外，实时节点还对数据查询请求做出响应。为了响应这些请求，实时节点会使用内存中的临时索引进行扫描。</p><p></p><h4>历史节点</h4><p></p><p>&nbsp;</p><p>历史节点从存储中读取不可变的数据片段，并对查询做出响应——协调节点（将在下一小节介绍）控制一个历史节点可以获取哪些片段。当一个历史节点成功下载了一个片段，它会告诉系统的服务发现组件（Zookeeper），然后用户查询就可以访问这个片段。不幸的是，如果Zookeeper离线，系统将无法提供新的片段——历史节点将无法告知已成功获取片段，所以Druid负责查询数据的组件将无法转发查询。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b9/b99243595896083ced0abfaf19ccdb4a.png\" /></p><p></p><p>使用不可变片段简化了历史节点的实现。首先，它简化了系统的伸缩——如果有多个请求涉及同一个片段，就会有更多的历史节点存储片段的副本，导致查询在集群中扩散。其次，操作数据片段而不是较低层次的抽象意味着历史节点可以简单地等待被告知有一个新版本的数据需要获取，而不需要监听片段是否发生了变化。</p><p></p><h4>协调器节点</h4><p></p><p>&nbsp;</p><p>协调器节点决定哪些片段存储在历史节点上，以及存储多长时间。</p><p>&nbsp;</p><p>为了做出决定，协调器节点从两个位置读取数据：MySQL和Zookeeper。MySQL保存了片段的信息，以及与每个段类型相关的元数据。Zookeeper保存了系统服务的所有片段的当前状态——实时节点和历史节点用它来宣布哪些片段是可用的。协调器节点还可以在整个系统中对片段进行负载均衡，以免对同一节点进行多次读取时出现“热点”数据。</p><p>&nbsp;</p><p>论文指出，一个集群中有多个正在运行的协调器节点，但同时只有一个“首领”——其他节点用于故障转移。如果协调器节点不可用（可能因为MySQL或Zookeeper出了问题），那么历史节点和实时节点将继续运行，但可能会出现超载（由于没有了负载均衡）。此外，论文还指出，这种情况会导致新数据不可用。</p><p></p><h4>Broker节点</h4><p></p><p>&nbsp;</p><p>最后，Broker节点接收来自外部客户端的请求，从Zookeeper读取状态，并根据需要将请求转发给历史节点和实时节点。Broker节点还可以在本地缓存数据片段，以应对未来可能出现的对相同数据的访问。</p><p>&nbsp;</p><p>如果Zookeeper不可用，那么Broker将使用“最后已知的状态”来转发查询。</p><p></p><h3>存储格式</h3><p></p><p>&nbsp;</p><p>如前所述，数据片段是Druid的一个关键抽象，一种用于存储数据的不可变数据结构。每一个片段都与一个数据源（Druid中的表）相关联，并包含特定时间段的数据。</p><p>&nbsp;</p><p>片段由两种类型的数据组成：维度和指标。维度是行聚合或过滤的值，而指标对应于数值数据（如计数）。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/4b/4b74a219d0d4abdafb33a8390f998122.png\" /></p><p></p><p>片段中还包含了版本号。如果一个片段发生变化，版本号会增加，并发布一个新的片段版本——如果已经确定的片段加入了延迟事件，就会发生这种情况。协调器节点会告诉历史节点获取新版本并删除旧版本，从而实现向新版本段的迁移。因为采用了这种方式，Druid被认为实现了多版本并发控制（MVCC）。</p><p>&nbsp;</p><p>重要的是，片段是按照列（而不是行）来存储数据的——这种方法被称为“列式存储”。这种设计被用于其他几种数据库（如Redshift和Cassandra）和文件格式（如Parquet）中，因为它提供了性能优势。</p><p>&nbsp;</p><p>例如，如果一个查询选择了列的子集，那么数据库只需要查询这些列的数据子集。基于行的解决方案需要扫描每一行，并选择相关的列。虽然这两种扫描都会产生相同的结果，但基于行的扫描（几乎）肯定会访问不必要的列，而这些列不是查询所需要的，也不会出现在查询结果中。</p><p></p><h3>查询API</h3><p></p><p>&nbsp;</p><p>论文中对HTTP查询API进行了描述，用户可以指定数据源、时间范围、过滤和聚合。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/08/081d2d7efab2bb7d1194bee95f85fc79.png\" /></p><p></p><p>&nbsp;</p><p>近期版本的查询API与论文中描述的有所不同。当前版本的Druid提供了一个<a href=\"https://druid.apache.org/docs/latest/querying/sql.html\">SQL风格的API</a>\"来编写和提交查询。论文还说明了为什么Druid还不支持连接查询，尽管近期的工作已经实现了这个想法。</p><p></p><h2>如何评估这项研究</h2><p></p><p>&nbsp;</p><p>为了评估这个系统，论文对部署在MetaMarkets的Druid的性能和规模进行了评测。</p><p>&nbsp;</p><p>因为Druid最初是为低延迟查询而设计的，所以使用生产流量跟踪来评估延迟性能。</p><p>&nbsp;</p><p></p><blockquote>对于所有不同的数据源，平均查询延迟大约为550毫秒，90%的查询在1秒内返回，95%在2秒内返回，99%在10秒内返回。</blockquote><p></p><p>&nbsp;</p><p>数据摄入延迟是Druid设计的另一个重点。MetaMarkets的生产系统能够以最小的延迟和显著的吞吐量摄取不同形式和大小的数据集。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/de/de6678d34ba33c837a8b5f7efd38d340.png\" /></p><p></p><p>&nbsp;</p><p>论文还指出，虽然摄入延迟存在差异，但可以通过为相关组件添加更多的资源来解决这个问题（如果特别关注这个属性，实现者可能会做出这样的决定）。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/94/940bd064d7d2e7fc7d784b34fd009c19.png\" /></p><p></p><p></p><h2>结论</h2><p></p><p>&nbsp;</p><p>我发现Druid论文很有趣，因为它的设计目标是同时处理实时和历史数据分析。</p><p>&nbsp;</p><p>这个系统代表了实现上述设计目标的一个步骤——Druid是“<a href=\"https://en.wikipedia.org/wiki/Lambda_architecture\">Lambda架构</a>\"”的第一个实现。最近的<a href=\"https://www.oreilly.com/radar/questioning-the-lambda-architecture/\">Kappa</a>\"和Delta架构似乎是对Druid最初建议的架构的改进。</p><p>&nbsp;</p><p>我很喜欢这篇论文，因为它讨论了系统在退化状态下的行为。随着Druid后续的演进，论文的一些细节可能会过时，但它的一些系统设计想法仍然是很独特的。</p><p>&nbsp;</p><p>原文链接：<a href=\"https://www.micahlerner.com/2022/05/15/druid-a-real-time-analytical-data-store.html\">https://www.micahlerner.com/2022/05/15/druid-a-real-time-analytical-data-store.html</a>\"</p><p>&nbsp;</p>",
    "publish_time": "2022-08-04 10:42:15",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "明略科技CTO郝杰：会话式AI应该是“静悄悄”的辅助智能",
    "url": "https://www.infoq.cn/article/hq44bi4BhmUv9TuSc5ma",
    "summary": "<p></p><p></p><blockquote>AI&nbsp;一定要落在实处，一定要追求它能落地成功。不要做飘在天上的“阳春白雪”。</blockquote><p></p><p></p><p></p><h3>明略科技新任CTO：一位平衡型的技术管理者</h3><p></p><p></p><p>今年4月27日，明略科技官宣了一则任命消息，宣布任命郝杰为首席技术官（CTO），全面主持研发部门的管理工作，负责制定技术方向与路线，搭建研发体系与流程，输出高质量的产品研发能力，保持技术领先性，构建技术壁垒。</p><p></p><p>明略科技创始人、CEO吴明辉表示，郝杰加入后，将进一步强化明略科技在人工智能技术领域的产研能力及技术布局。</p><p></p><p>郝杰是语音语义领域的技术大牛。</p><p></p><p>资料显示，郝杰是清华大学信号与信息处理专业博士，IEEE Senior Member，是国际顶级 AI 学术大赛 20 个细分赛道第一名获得者。加入明略科技前，郝杰是OPPO语音语义首席科学家，更早之前，他曾担任东芝（中国）首席科学家、五八集团技术专家，率先在工业界实现了语音和语义技术的产品化落地，主导研发成功了中国最早量产的汽车前装语音导航，世界上最早量产的电视机语音唤醒、离线口语翻译手机软件等。</p><p></p><p>郝杰在接受InfoQ采访时表示，在 To C 的软硬一体化的人工智能领域做了3年后，他非常看好To B 企业智能服务赛道的崛起，这促使他加入了明略科技。</p><p></p><p>郝杰形容自己是一位平衡型的技术管理者。</p><p></p><p>这种“平衡”一方面体现在他的履历上。在此前20多年的职业生涯中，郝杰既在跨国公司工作过，也在本土企业工作过；在传统制造业工作过，也在互联网公司工作过；曾在软硬一体化和偏偏硬件的公司工作过，也在纯粹的软件公司工作过。在产研追求上，郝杰既讲求务实地落地，也追求行走在学术前沿。在技术管理方面，郝杰也有着平衡型的人才观，他崇尚纺锤形的人才梯队的合理性，讲究头部人才、肩部人才均衡搭配。</p><p></p><h3>下一阶段研发重点：明智中台</h3><p></p><p></p><p>郝杰告诉InfoQ，他是以创业的心态加入明略科技的。</p><p></p><p>在他看来，明略科技正处在第三次“创业”的阶段。第一次“创业”是在2006年，吴明辉创办了广告舆情监测系统 — 秒针系统；第二次“创业”是2014年，明略数据成立，通过数据提供支持分析决策的行业人工智能解决方案；第三次“创业”从2019年开始做会话智能平台 — 明智工作。</p><p></p><p>“这个过程中，不仅伴随着产品线的扩展，明略自身的组织也发生了多次变化和调整，故我将其看作是三次创业”。</p><p></p><p>目前在应用层，明略科技聚焦两大产品线 — 秒针产品线和明智产品线。秒针产品线，专注媒体投放、效能改善，针对舆情分析，挖掘营销效能、新产品研发方向等场景。明智产品线包括SCRM营销服一体化、智能助理、OA增强、销售增强、会话智能等场景。</p><p></p><p>这两大产品线都建立在一个产研底座 —— 明智中台上。</p><p></p><p>明智中台既是一个数据中台，也是一个AI能力中台。它不仅仅是一个技术平台，明略科技还往这个底座上扩充了一些新的概念、能力和功能，明智中台上有可以独立售卖的产品单元，如客户数据中台和营销自动化（CDP+MA）等产品模块。</p><p></p><p>郝杰表示，明智中台将是今年研发部门的发力重点，会在这个底座上方做一些偏前端的应用，可以使其灵活地、积木式地组装明智中台上的能力，低成本地快速包装成一些面向客户的创新产品。</p><p></p><p>“如果没有明智中台，我们的产品矩阵就变成了一大片独立的产品了，彼此之间关系不大，各自为战，这样产研效率比较低”，郝杰说道。</p><p></p><p>有了明智中台，就可以把众多的前端产品或应用产品中的众多模块间的相同点做抽象，把共通的部分沉淀在明智中台里。例如，很多应用产品模块中都具备搜索、推荐、问答、数据分析等功能，专门的团队将这些功能下沉到明智中台，一次性封装好，就像积木一样，做成一个个公共组件（Common&nbsp;Building&nbsp;Blocks，CBB）。</p><p></p><p>明智中台，就成了公共组件的集合体，应用产品经理可以根据用户需求，选择明智中台中的若干个CBB，进行简单的、轻量级的封装，来实现产品功能。这样，产研效率就大幅提升，而且降低成本，提升了标准化产品的毛利率。</p><p></p><p>郝杰表示，他加入明略后，带领研发团队的一个重要的工作目标是打造标准化的产品。“只有标准化程度高了，复用率才高，才能从一个场景迁移到另一个场景，从一个行业迁移到另一个行业，且在迁移的过程中，降低定制开发或二次开发成本，提高毛利率”。</p><p></p><p>在TO B行业，打造标准化的流程尤其重要。因为TO B行业的客户经常有五花八门的需求，但如果企业一直难以拒绝一些定制化的开发需求，久而久之，To B软件开发公司就沦为客户的外包公司，自身收入的毛利率也会因此降低。明略科技正在打造一套IPD集成产品开发流程，聚焦标准化产品打造，这套流程能够将标品的需求和定制开发的需求区分开来。</p><p></p><h3>明智工作：提供会话智能的AI能力</h3><p></p><p></p><p>接下来，郝杰及其团队在应用产品上的重点将主要放在明智工作上。</p><p></p><p>在秒针和明略数据时期，在过去十几年服务各行业客户的过程中，明略科技发现，各行业的企业对营销服务流程透明化的需求增加。企业希望员工的销售过程可以量化测量，“可见可测”能够驱动提升成单率和客户的满意度，这正是明略工作这款产品诞生的背景。</p><p></p><p>明智工作的核心是会话智能的AI能力。明智工作基于腾讯企业微信，帮助各行各业的销售解答用户的问题。利用数据和会话分析，帮助销售做销售管理、商机转化、销售卡点、销售旅程等。通过会话智能的B2B产品，可以帮助销售快速、低成本地获取营销过程中的素材、话术等以获取知识，捕捉最佳销售话术、销售实践等，加以推广，提升整体销售效率。</p><p></p><p>明略科技推出的软硬一体化的会话智能产品“灵听”，可以针对线下门店做语音收集、识别、转写、分析，销售最佳话术的赋能培训等。例如在线下的连锁药店或商场中的化妆品柜台店员，有一部分佩戴着明略科技的智能语音工牌。这些店员的销售过程会被录制下来，上传到服务器，进行数据的收集、整理和分析，帮助销售解答顾客的问题。</p><p></p><p>上述应用场景背后采用了声学、语音识别、语义理解、意图识别、话术理解、质检等AI技术。其中，声学和语音识别技术是明略科技的特色技术，在处理智能语音工牌数据的服务器上，运行的都是明略自己的声学和语音识别算法，针对线下门店的声学环境，就录音环境、混响音响等声学条件做了专门的定制优化，也针对线下门店所需要的销售赋能、销售增强的一系列流程SOP做了专门的调优。“这样达成的语音识别就不是通用的语音识别了，而是线下会话智能专用的语音识别，识别率明显高于供应链上的第三方”，郝杰说道。</p><p></p><p>郝杰表示，与服务于To C赛道的手机语音助手、智能音箱等需要唤醒的被动机器人不同，明略在TO B赛道上强调的是主动机器人。</p><p></p><p>在企微侧边栏，明智工作可以预制主动机器人, 相当于人类的助理。侧边栏的主动机器人会“跳”出来帮用户解答问题,它能实时监听对话，并从中挖掘关键词，这些关键词会作为搜索查询词，搜索后台的文档库、话术库、素材库、产品库、聊天问答的剧本库等，搜索到一些相关的能够“命中”问题的文档，构建出搜索页面里一个短的列表，在侧边栏上，用户只要一点鼠标，就立刻发给对话者。</p><p></p><h3>落地之道：“贪食蛇”策略</h3><p></p><p>会话智能产品如何实现应用落地？</p><p></p><p>如果用一个坐标轴来表示，横轴的长度代表垂直行业的个数，纵轴的长度代表场景的个数，那么，垂直行业乘以水平的场景构成的二维平面上会被划分成N个格子，一个格子代表一个细分行业、细分场景。</p><p></p><p>这就是明略科技的会话智能产品的应用蓝图，明略希望，未来能够覆盖到整个二维平面80%以上。</p><p></p><p>郝杰详细介绍了这个应用蓝图的实现路径。</p><p></p><p>“我们采取‘贪食蛇’的策略，围绕着头部行业、重点场景，逐步提升扩展覆盖率”，选择三到五个头部（重点）行业、三到五个重点场景，在二维平面上，就选择了一个相对聚焦的由十几个方格构成的局部（蓝图）。就像玩‘贪吃蛇’游戏，就近吞并。这与人工智能的贪心算法类似，先‘吃’下来一个行业头部的几个重点场景，把几个大客户拿下来。之后，行业中的中长尾的客户也就能拿下来了，采取头部带动中长尾这样的扩张策略，实现对场景逐步覆盖”。</p><p></p><p>在多行业、多场景、大范围的应用会话智能过程中，常常遇到一些挑战，例如，如果技术识别率或准确率上不去怎么办？很多To C、To B的公司做智能类的应用常常会遇到的一个技术瓶颈是，准确率做到百分之八十就上不去了，这样的准确率，用户并不会买单。</p><p></p><p>在这种情况下，要提升识别率，就需要挖掘特定场景下的行业知识、先验知识。通常，要先进行标签化，因为人类的认知就是从简单的分类给事物打标签做起的。因此，在先验知识或行业知识中，最重要的就是分类标签。在明智中台里，有各种各样的标签，如客户中台里的客户标签，业务中台里面，与业务流程相关的标签等。目前明略已积累了各行各业各种场景下数量庞大的标签。</p><p></p><p>此外，还需要在算法和标签库的先验知识的基础上做改造。比如，语音识别算法，在没有线下门店相关行业和场景的标签库前提下就是一个通用的语音识别标签库。把标签库里的这些词汇预先编入到通用的语音识别词典中去，就构建出一个包含了新词、热词的更大的搜索网络。</p><p></p><p>“在此基础上，针对专门性的场景，通用的语音识别率、准确率可能在60%-75%之间。而依靠对场景的理解和建模，依靠这些先验知识，能将识别率拔升到75%-90%之间”，郝杰表示，这是明略科技在To B赛道上的生存之道。</p><p></p><h3>会话式AI的发展现状和趋势</h3><p></p><p></p><p>现阶段，不止明略，会话智能是很多企业尤其是大厂竞相布局的赛道。</p><p></p><p>不过，现在关于会话智能，还没有一个相对成熟的定义。郝杰认为，会话智能就是在工作会话流中，在人与人交流过程中，能适时出现的一些辅助智能。</p><p></p><p>值得注意的是，在业内，一种说法是对话式AI，明略将其翻译成会话式AI。会话和对话有什么区别？字面意思上看，对话对应的英文单词是“dialog”，会话对应的是“conversation”。</p><p></p><p>另一方面，“会话”和To C领域的“对话”不同。To C赛道更多的是人机之间的沟通，AI就是一个语音助手。而To B赛道中的会话智能本质上是人与人之间的会话，如单聊、群聊等，它不应该受到太多的机器打扰。“如果机器能够提供一定的智能，这种智能最好是在需要的时机悄悄出现，然后悄悄退下去，因为它只是一种辅助性的智能”。郝杰表示。</p><p></p><p>它辅助的仍然是人和人之间的沟通。它以人类助理的形式出现。人类助理能做到的事，尽可能的让机器助理做到。与等人呼唤才出来的助理（被动机器人）不同，明略的主动机器人“蹲守”在所有的会话聊天过程中。在人人沟通的过程中，如果能在侧边栏或者某一个角落预置一些主动性的机器人，实时推荐一些与业务流程密切相关的知识和信息，对提升交流的效率很有帮助。</p><p></p><h3>写在最后：AI落地一定要落在实处</h3><p></p><p></p><p>“像我这种一辈子搞AI、搞算法的人，我们比较相信算法和知识的结合。如果光搞算法，抛开场景，抛开行业认知，就搞不好AI”。采访最后，郝杰谈到了包括会话智能在内的AI技术的未来。</p><p></p><p>郝杰认为，“AI&nbsp;一定要落在实处，做AI一定要追求它能落地成功。不要做飘在天上的‘阳春白雪’。这要求我们一方面吃透算法，一方面要融会贯通知识，通过深耕行业实现融会贯通”。</p>",
    "publish_time": "2022-08-04 10:50:33",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Jetpack Compose终于能稳定支持Wear OS，并带来了适用于手机和平板的1.2版本更新",
    "url": "https://www.infoq.cn/article/Qp9CeVh5UAJpLXgGrEHy",
    "summary": "<p>近日，谷歌安卓团队<a href=\"https://android-developers.googleblog.com/2022/07/jetpack-compose-1-2-is-now-stable.html\">发布</a>\"Jetpack Compose 1.2版本，该版本提供了开发者所需要的更多 API，以支持更高级的用例。例如可下载字体、Lazy grids、窗口插图、嵌套滚动互操作以及更多工具支持，还有针对平板电脑和 Chrome 操作系统的改进。</p><p></p><p>在发布 Jetpack Compose 1.2版本的同时，官方还发布了Compose for Wear OS 1.0 ——使得 Compose 也支持 Wear OS 应用开发。这是Compose智能手表平台UI工具包的第一个稳定版本，在这之前，智能手表应用开发者一直被“落下”。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/8c/8c4b0457c2d05d092252a4743fe011d6.png\" /></p><p></p><p>Jetpack Compose是官方推荐的为手机、平板和可折叠设备开发新安卓应用的框架。1.0 版本在去年7月份发布，结合Kotlin的语言生态，设计了新的声明式 UI 开发范式，旨在与谷歌的 Material Design 系统配合使用。</p><p></p><p>谷歌的安卓开发者关系工程师 Kseniia Shumelchyk 说：“在大多数情况下，基于 Compose 的 UI 可以减少代码量并加快开发过程。”</p><p></p><p>智能手机应用程序开发人员在 Compose 1.2 中获得了一些重要更新。Lazy grids，通过只对网格的可见部分进行合成来提高性能，已经从实验阶段转为稳定阶段。WindowInsets类，用于处理屏幕上不可用的区域及其与应用程序窗口的交互，是一个基于Accompanist库中先前工作的新类，谷歌用它来试验Compose的新功能并填补API的空白。此外，动画支持中添加了缓动曲线，用于实现快速加速和逐渐减速等效果。还有嵌套滚动支持和新的鼠标事件，以及各种错误修复。</p><p></p><p>安卓开发有很多方式，包括使用 Dart 语言的跨平台框架 Flutter，或其他方法，如 React Native。不过，Jetpack Compose 是最接近原生解决方案的那个，它为安卓功能提供了很好的支持，而无需尝试跨平台（尽管用 Kotlin 编写的非可视代码也可以在其他地方使用）。</p><p></p><p>“你应该押注Jetpack......Flutter对简单的应用来说是很好的选择，但却不适合复杂的场景，”Hacker News的一位开发者声称。另外也有人表示，学习Compose框架需要付出“很大的前期成本”，但尽管如此，它是“安卓前端开发体验的未来”。</p><p></p><p>参考链接：</p><p></p><p><a href=\"https://android-developers.googleblog.com/2022/07/jetpack-compose-1-2-is-now-stable.html\">https://android-developers.googleblog.com/2022/07/jetpack-compose-1-2-is-now-stable.html</a>\"</p><p></p><p><a href=\"https://devclass.com/2022/07/28/jetpack-compose-comes-to-android-wear-os-plus-1-2-update-for-smartphones-and-tablets/\">https://devclass.com/2022/07/28/jetpack-compose-comes-to-android-wear-os-plus-1-2-update-for-smartphones-and-tablets/</a>\"</p><p></p><p>延展阅读：<a href=\"https://www.infoq.cn/article/qmeK2NDH8ZP2sbBGwFoE\">《为什么除了 Flutter 之外，我们还需要另一个跨平台开发框架？》</a>\"</p>",
    "publish_time": "2022-08-04 12:23:47",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]