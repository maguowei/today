[
  {
    "title": "Flutter 3.3发布，带来新的预览版渲染引擎",
    "url": "https://www.infoq.cn/article/Y0P6hUq6EJC30ThW6USD",
    "summary": "<p>用户可以用谷歌UI框架Flutter基于一个代码库构建出原生编译的移动、Web和桌面应用程序。谷歌刚刚发布了Flutter的2022年第3个版本，即<a href=\"https://medium.com/flutter/whats-new-in-flutter-3-3-893c7b9af1ff?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjI4NzQ5MTksImZpbGVHVUlEIjoiYVd0TjgxWmxuZThSUEp3VSIsImlhdCI6MTY2Mjg3NDYxOSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.ox2CgUlMGozaizAF2zGY1K0ierBJ2S4ANOCc4sVM83o\">版本3.3</a>\"。随之一起发布的还有<a href=\"https://medium.com/dartlang/dart-2-18-f4b3101f146c?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjI4NzQ5MTksImZpbGVHVUlEIjoiYVd0TjgxWmxuZThSUEp3VSIsImlhdCI6MTY2Mjg3NDYxOSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.ox2CgUlMGozaizAF2zGY1K0ierBJ2S4ANOCc4sVM83o\">Dart 2.18</a>\"。这两个版本都是改进版，没有添加重大的新特性。新添加的渲染引擎Impeller只限于预览并且只适用于iOS。谷歌还推出了一个新的展示应用Wonderous，它用Flutter 3.3开发，并使用了新渲染引擎Impeller。</p><p></p><h2>Flutter 3.3的新特性</h2><p></p><p>Flutter应用程序不使用底层平台的UI元素，而是模拟它们。Flutter自带的Material UI适用于所有平台，还提供了一个iOS UI元素集。其他开源库则提供了Windows、macOS和Linux的UI元素集。</p><p></p><p>Flutter网页应用程序中的文本选择现在可以像预期的那样——用户可以一次选择多行文本。触控手势在桌面应用程序中的效果变得更好。Windows应用程序现在可以从pubspec.yaml构建文件中获取版本号。iPad应用程序可以使用苹果手写笔进行手写输入。</p><p></p><p>在这个版本中，一些Material 3组件得到了改进——IconButton, Chips和AppBar。使用新的ui.ImmutableBuffer.fromAsset()方法加载包含在应用程序中的图像速度更快，使用的内存更少。现在在iOS上禁用了指针压缩，将更多的内存用于Flutter应用程序的非Dart部分。</p><p></p><p>Flutter团队提供的go_router包通过基于URL的声明简化了应用程序中的路由，4.3版本支持异步代码。Flutter Visual Studio Code扩展和Flutter DevTools也得到了改进。</p><p></p><p>Flutter 3.3不再运行在32位的iOS设备上，包括iPhone 5C（2014年推出）和更早的机型，以及第二代至第四代iPad（2012年推出）。即将到来的2022年第四季度发布的Flutter也不支持macOS 10.11（2015年推出）和10.12（2016年推出）。</p><p></p><p>苹果在即将发布的秋季iOS和iPadOS版本中取消了Bitcode，这也是为什么Flutter也会在未来的版本中移除对比Bitcode的支持。</p><p></p><p>Flutter从一开始就使用Skia作为它的图形引擎。Skia支持Chrome、Firefox、Android、ChromeOS等。相比之下，Impeller是为Flutter定制的，“充分利用了现代硬件加速图形API，如iOS上的Metal和Android上的Vulkan。”这样就可以实现更好的动画效果，并消除了一个常见的问题——动画和转场不连贯。</p><p></p><p>在发布之前的版本时，Flutter团队将50万款现有的Flutter应用程序作为取得成功的指标。这一次，Flutter团队表示，“每天都有超过1000款使用Flutter开发的新的移动应用发布到苹果和谷歌应用商店”。但这两个数字都缺乏背景支持，比如竞争平台之间的表现如何。</p><p></p><h2>Dart 2.18的新特性</h2><p></p><p>Dart是强类型的编程语言，并针对UI开发进行了优化。一开始它是“JavaScript和Java的混合体”，现在它拥有这两种语言都没有的特性（比如全面空安全）。</p><p></p><p>Dart于2021年3月推出了全面空安全性（Sound Null Safety），涵盖了应用程序和库。这一特性与Swift相同，但与Kotlin不同，Kotlin不能保证库的空安全。排名前250的Flutter和Dart库都迁移到了空安全，而排名前1000的库只有2%没有迁移。在2022年7月运行的所有Flutter应用程序中，超过80%都使用了全面空安全。所以Dart计划在2023年中停止支持没有空安全的Dart版本。</p><p></p><p>Dart包含了一个多平台HTTP库，它为两个特定于平台的库提供了实验性支持。一个是针对iOS和macOS的cupertino_http，它使用苹果的NSURLSession来实现WiFi专属网络或VPN接入等功能。第二个是用于Android的cronet_http，它建立在流行的Cronet库之上。</p><p></p><p>用于调用本地C API的Dart外部函数接口（FFI）现在可以在iOS和macOS上与Objective-C和Swift代码交互。改进的类型推断可以更好地检测一些非空参数的情况。异步代码的体积更小，运行得更快。</p><p></p><p>原文链接：</p><p></p><p><a href=\"https://www.infoq.com/news/2022/09/google-flutter-3-3/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjI4NzQ5MTksImZpbGVHVUlEIjoiYVd0TjgxWmxuZThSUEp3VSIsImlhdCI6MTY2Mjg3NDYxOSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.ox2CgUlMGozaizAF2zGY1K0ierBJ2S4ANOCc4sVM83o\">Flutter 3.3 Previews New Rendering Engine</a>\"</p>",
    "publish_time": "2022-09-12 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Java默认可变性：“万亿美元级别的错误” | InfoQ访谈",
    "url": "https://www.infoq.cn/article/q1YBR2HgoIBCqGUxlPOy",
    "summary": "<p><a href=\"https://www.linkedin.com/in/jamesward/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjI4NzY1NzcsImZpbGVHVUlEIjoiaTlsZlBwS25KU1U2MzFPYSIsImlhdCI6MTY2Mjg3NjI3NywiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.SPb60GdJFzYFQxcEz-yumdrCbV28WkURP8DEGQEuPRw\">James Ward</a>\"是谷歌的Kotlin产品经理，同时也是Java Champion。他和Bruce Eckel（《Java编程思想》作者）一起主持“快乐之路编程”播客。在其中一集播客中，Eckel谈到了“仍被困在Java世界中的人们”。Ward对此表示同意，并将Java的默认可变性称为“万亿美元级别的错误”（参考了NullPointerException是“十亿美元级别的错误”的说法）。Ward对Java的看法引起了InfoQ的好奇。InfoQ采访了他，以下是采访内容。</p><p></p><p>InfoQ：Kotlin产品经理在谷歌是一个怎样的角色？你的日常职责是什么？</p><p></p><p></p><blockquote>Ward：Kotlin产品经理的工作有个方面。我与我们的Android团队和JetBrains一起致力于Kotlin语言的改进和发展。我还与谷歌的许多工程团队合作，帮助他们成功地将服务器端和Android从Java迁移到Kotlin。</blockquote><p></p><p></p><p>InfoQ：2022年JVM编程语言处在一个怎样的状态？</p><p></p><p></p><blockquote>Ward：我在25年前开始使用Java，并且认为它仍然是一种很棒的语言。但在过去的十年中，我也使用了更现代的JVM语言，包括Scala和Kotlin。对于那些想要将函数式编程发挥到极致的开发人员来说，Scala非常棒。对于现有的Java开发人员来说，Kotlin更像是一个循序渐进的步骤，它可以很好地支持一些函数式编程范式，比如不可变性，但缺乏Scala的“Monadic”特性。Kotlin和Scala都与Java有很好的互操作性，支持生态系统共享。JVM开发人员对于优秀的编程语言有很多选择，工具也有很多重叠的地方（构建工具、IDE、生产/内省工具等）。在JVM这个大生态系统中有这么多语言选项是非常棒的。</blockquote><p></p><p></p><p>InfoQ：现在有多少JVM后端开发在使用Kotlin？你认为Kotlin怎样才能在后端开发中变得更受欢迎？</p><p></p><p></p><blockquote>Ward：总的来说，JVM服务器端的Kotlin份额相当小，但它正在迅速增长。例如，谷歌已经见证了Kotlin用于服务器端开发的显著增长。从Java转向其他语言或来自其他语言的开发人员都表示，他们对这种体验非常满意。Null安全性、协程和可表达性通常被认为是Kotlin更有效率、使用起来更有趣的重要因素。</blockquote><p></p><p></p><p></p><blockquote>Kotlin肯定会在服务器端继续发展。Spring、Quarkus和Micronaut已经做了相当多的工作，让Kotlin的使用体验变得非常棒（例如为Reactive提供协同程序互操作性）。企业对新技术的采用通常非常缓慢。尽管如此，对于许多人来说，迁移到Kotlin（在JVM上）比迁移到Rust的风险和破坏性要小得多。此外，Kotlin与Java的互操作性有助于进行增量式的代码迁移，而不是进行重写。我参与过的许多团队只是将Kotlin新代码添加到现有的Java代码库中。</blockquote><p></p><p></p><p>InfoQ：JVM编程语言与其他编程语言相比如何，尤其是在云环境下？Python和JavaScript在谷歌搜索中出现的频率比Java更多，在Stack Overflow上的相关问题也更多。</p><p></p><p></p><blockquote>Ward：如果我要设计一种编程语言，我希望对语言的搜索和提问可以少一些。作为一名具有30多年经验的程序员，我更倾向于使用那些能让我写出更“正确”、更可测试和可重用代码的语言。我不喜欢在生产环境中出现意外，我希望能够毫无畏惧地进行重构。拥有一个可以对程序执行高级验证的编译器是一个基本特性。当然，我可能不能像其他人那样快速地编写代码，但至少可以写出在生产环境中不太可能有bug的代码。如果你将修复生产bug作为开发周期的一部分，那么使用更现代的JVM编程语言可能可以解决许多问题领域提供最高的生产力。</blockquote><p></p><p></p><p>InfoQ：GraalVM生成的原生Java应用程序启动更快，使用更少的内存。这将如何影响JVM语言在云计算中的竞争地位？</p><p></p><p></p><blockquote>Ward：启动速度和内存开销确实阻碍了JVM技术在某些问题领域（无服务器、CLI、Kubernetes Operator等）的采用。GraalVM原生镜像、Kotlin/Native和Scala Native帮助把这些语言带到以前更适合解释语言或原生语言的地方。现在，我们既有了我们的蛋糕（快速启动和最小的内存开销），也可以吃掉它（现代高级语言）。我最近用Kotlin Ktor库创建了一个服务器，我可以在JVM上运行它，或者用Kotlin/Native和GraalVM原生镜像编译成原生程序，启动时间大约为2毫秒，内存使用量为11MB，二进制大小被压缩到700KB。对于许多场景，我们不再需要在原生语言和现代/高级语言之间做出权衡。</blockquote><p></p><p></p><p>InfoQ：Scala为什么如此吸引你？</p><p></p><p></p><blockquote>Ward：Scala的学习曲线很长。学这门语言十多年了，我还是觉得自己像个新手。这对我来说很棒，因为我喜欢学习新的编程语言，并享受挑战。我也确实接受了函数式编程的许多原则，但还没有完全像Haskell那样，所以Scala是一个适合使用基于JVM的函数式编程的好地方。我目前正在和Bruce Eckel、Bill Frasure一起写一本使用Scala 3和ZIO 2进行面向副作用编程的<a href=\"https://github.com/effectorientedprogramming/book?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjI4NzY1NzcsImZpbGVHVUlEIjoiaTlsZlBwS25KU1U2MzFPYSIsImlhdCI6MTY2Mjg3NjI3NywiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.SPb60GdJFzYFQxcEz-yumdrCbV28WkURP8DEGQEuPRw\">书</a>\"。函数式副作用是一种概念，它对我们创建的软件质量有很大的影响，但在Java或Kotlin中还没有得到很好的支持。选择Java或Kotlin有很多原因，但像副作用这样的概念并不在其中。</blockquote><p></p><p></p><p>InfoQ：Scala最适合哪些应用或解决哪些问题？不适合哪些场景？</p><p></p><p></p><blockquote>Ward：有许多因素决定了技术的契合度。在我最近从事的项目中，团队结构决定了Java和Spring Boot是最适合这种环境的。“适合”的最重要的一个因素是团队想要使用这些技术。我认为这与我的Kotlin项目经理工作目标是一致的，就是帮助开发人员使用Kotlin。</blockquote><p></p><p></p><p>InfoQ：JetBrains声称Kotlin是“更好的Java”，但是Java的受欢迎程度仍然是它的5到12倍。你认为Kotlin今天的角色是怎样的？在未来会变成什么样？</p><p></p><p></p><blockquote>Ward：Java语言一直在发展。但正如Java语言架构师Brian Goetz所描述的那样——它有“定局者优势”，在许多情况下都是正确的选择。如果说创业公司的口号是“快速行动，打破现状”，那么企业的口号则是“缓慢行动，什么都不打破”，这与Java语言在过去20年左右的发展是一致的。对我来说，我喜欢比典型的企业更快地发展（由于合规性、安全性、监管和其他原因）。所以，Kotlin在某种程度上是“更好的Java”，但对我来说“更好”并不意味着对每个人都“更好”。JVM和Android同时支持Java和Kotlin——这是一件好事。</blockquote><p></p><p></p><p>InfoQ：在“快乐之路编程”播客的<a href=\"https://anchor.fm/happypathprogramming/episodes/51-James-New-Kotlin-PM-Job-e1c4t0f/a-a66th96?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjI4NzY1NzcsImZpbGVHVUlEIjoiaTlsZlBwS25KU1U2MzFPYSIsImlhdCI6MTY2Mjg3NjI3NywiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.SPb60GdJFzYFQxcEz-yumdrCbV28WkURP8DEGQEuPRw\">第51集</a>\"中，Bruce Eckel谈到了“仍然被困在Java世界中的人们”（大约在33:15），你表示了赞同。请你解释一下为什么你和Bruce会这么认为。</p><p></p><p></p><blockquote>Ward：25年前，我写Java就像写Perl一样。Bruce的《Java编程思想》改变了我对编程的看法。现在，Bruce和我都发现编程范式和经验具有相同的效果，完全改变了我们思考事物的方式。Bruce和我没有在Java中体验过这种颠覆，但在其他语言中有。我相信Bruce和我在那一集中所强调的并不是对Java的抨击，而是希望程序员能够不断学习并找到成长方法，就像Bruce和我所做的那样。</blockquote><p></p><p></p><p>InfoQ：正如Tony Hoare所说的那样，NullPointerException是“十亿美元级别的错误”。语言中的Null安全性是对这个错误的解决方法。Kotlin有，Dart和Swift甚至有<a href=\"https://youtu.be/iYhOU9AuaFs?t=143&amp;accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjI4NzY1NzcsImZpbGVHVUlEIjoiaTlsZlBwS25KU1U2MzFPYSIsImlhdCI6MTY2Mjg3NjI3NywiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.SPb60GdJFzYFQxcEz-yumdrCbV28WkURP8DEGQEuPRw\">全面Null安全性</a>\"（Sound Null Safety），但Java没有，而且似乎在短时间内不会提供。你认为这是为什么？</p><p></p><p></p><blockquote>Ward：在Java中，所有不是原始值的值都是可空的。要改变这一点，需要对整个语言和标准库进行大规模的改革。许多现代语言都有一个基本原则，即通过类型系统来表达可空性。这在后期是非常难或不可能实现的。如前所述，我希望能够编写出在编译时可验证的程序，而显式的可空性是实现我的目标的一种方法。我不再经常使用Java语言的原因之一是很难通过编译器验证的方式来表达可空性。</blockquote><p></p><p></p><p>InfoQ：你说在未来添加Null安全性是“非常困难或不可能的”。但Dart在发布1.0版本7年后为应用程序和库添加了Null安全性。不管怎样，你对希望减少NullPointerException的Java开发人员有什么建议？</p><p></p><p></p><blockquote>Ward：最难的部分不是语言特性，而是API。Java标准库中的所有东西以及Java库生态系统中的大部分东西都是可空的。要让Null安全性变得有用，并且处理起来不那么麻烦，所有基础类型必须正确地表达它们的可空性。这是一个很难或不可能实现的变化。</blockquote><p></p><p></p><p>InfoQ：在同一集“快乐之路编程”播客中，你称Java的默认可变性为“万亿美元级别的错误”（大约在35:05）。请详细说明你为什么这样认为。</p><p></p><p></p><blockquote>Ward：我遇到过很多次生产问题，因为无法“推理”出问题代码，所以很难找出原因。当人们在Twitter上发布类似“这段代码是做什么的”这样的问题时，你就会明白。大多数时候这都是一个谜，因为可变性让我简单的大脑无法推断发生了什么。但你永远不会看到人们以一种纯粹不可变的形式发布同样的问题，因为我们的大脑能够理解不可变的值和纯粹的函数。我确信，我们的程序越能纯粹地实现函数和值，我们构建的程序中出现的Bug就越少。</blockquote><p></p><p></p><p>InfoQ：你认为工具支持（比如IDE和构建工具）对一门编程语言取得成功有多大影响？</p><p></p><p></p><blockquote>Ward：我曾经在没有IDE帮助的情况下（vim算不算）写了很多代码，但现在IDE成了我工作效率的重要组成部分。我之所以喜欢提供了优秀的类型系统的编程语言，其中一个原因是IDE在我编写代码时提供了更好的提示。当我不得不用动态语言编写代码时，我想知道如果没有那么多API可供参考，谁能完成他们想做的事情？如果没有IDE的提示功能，我就什么都做不了。</blockquote><p></p><p></p><p>InfoQ：说到工具，Visual Studio Code在2021年2月拥有1400万用户，在Stack Overflow的“2022年开发者调查”中是第二受欢迎的IDE（第一名是neovim）。我们假设Visual Studio Code成为所有开发人员的默认免费IDE，并且支持所有相关的编程语言和框架，那么这将会如何改变软件开发？</p><p></p><p></p><blockquote>Ward：VS Code是一个很棒的工具，对于许多开发人员来说，它已经比“Sublime Text”、vim或emacs向前迈出了一大步。但是对我来说，它仍然没有IntelliJ（对于JVM的东西）那么有用，特别是在涉及到重构时。所以，我不经常使用它，但我知道它可能是开发人员使用过的最好的代码编辑器（假设他们没有使用过所有的代码编辑器）。</blockquote><p></p><p></p><p>InfoQ：编译器可以暴露代码错误。静态分析器，如Error Prone、Spotbugs或PMD，会显示更多的错误，包括可怕的NullPointerException。为什么这些静态分析器没有得到更广泛的使用？</p><p></p><p></p><blockquote>Ward：一般来说，我喜欢让我的工具链尽可能精简。无论是出于性能、简单性还是协作性的考虑，我更喜欢将尽可能多的验证逻辑放入编译器可以验证的东西（即类型系统）中。对我来说，检查器和静态代码分析工具可以验证的东西都可以放在编译器中验证。不过，语言的限制可能阻碍了这一点。这些工具有助于提高代码质量，但同时也向语言设计者发出了一个强烈的信号，告诉他们应该如何从元编程转向单纯的编程。</blockquote><p></p><p></p><p>InfoQ：你说你“喜欢把尽可能多的验证逻辑放入编译器可以验证的东西中”。Java编译器不验证可空安全性、空else分支等，但是像谷歌Error Prone这样的静态分析器会这么做。你如何看待将这些分析器添加到Java中所带来的好处与它会让工具链复杂化的问题？</p><p></p><p></p><blockquote>Ward：分析器和其他静态代码分析工具暴露了类型系统和编译器检查的局限性。这些限制会一直存在，所以这些工具不会很快消失。但希望它们能够有助于编程模型和编译器的发展，随着时间的推移能够涵盖更多可能的问题。</blockquote><p></p><p></p><p>InfoQ：谷歌的跨平台UI框架Flutter编译一个变更和更新应用程序只需要不到一秒的时间。相比之下，为什么编译和更新JVM应用程序仍然如此缓慢？</p><p></p><p></p><blockquote>Ward：编译器要验证的东西越多，花费的时间就越长。我可以写一些零编译的代码，在生产环境中运行它，然后在运行时发生错误。这不是我想要的软件开发方式。所以对我来说，编译时间必须与编译器的价值相平衡。不过，我确实经常借助热加载（感谢缓存）在一秒钟内用增量的方式运行Java、Kotlin和Scala编译器。这种争论应该从“需要多长时间将包含不确定数量问题的东西部署到生产环境”变成“需要多长时间来纠正或消除错误”。</blockquote><p></p><p></p><p>InfoQ：在我的Spring Boot项目中，频繁的类重载失败抵消了编译速度。关于你的“将包含不确定数量问题的东西部署到生产环境”，我认为Dart（Flutter使用的语言）的编译复杂性可能与Java差不多。尽管如此，大多数情况下，Flutter在移动设备上重新编译和部署只需要1秒钟，但大多数Java项目都做不到。现在，Flutter有了它的整个工具链（编程语言、编译器、运行时、框架和构建工具），但Java还没有（例如，构建工具和应用程序框架）。对于开发人员的生产力来说，JVM语言拥有整个工具链有多重要？</p><p></p><p></p><blockquote>Ward：没有什么能阻止JVM的内部开发周期变快。Android Studio有一个叫作<a href=\"https://developer.android.com/studio/run#live-edit?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjI4NzY1NzcsImZpbGVHVUlEIjoiaTlsZlBwS25KU1U2MzFPYSIsImlhdCI6MTY2Mjg3NjI3NywiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.SPb60GdJFzYFQxcEz-yumdrCbV28WkURP8DEGQEuPRw\">Live Edit</a>\"的新功能，可以基于代码变更即时更新模拟器或设备上的<a href=\"https://developer.android.com/jetpack/compose?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjI4NzY1NzcsImZpbGVHVUlEIjoiaTlsZlBwS25KU1U2MzFPYSIsImlhdCI6MTY2Mjg3NjI3NywiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.SPb60GdJFzYFQxcEz-yumdrCbV28WkURP8DEGQEuPRw\">Jetpack Compose</a>\" App的UI。十年前，Play Framework就已经通过利用一些奇特的类加载器技巧实现了JVM服务器的亚秒级重载。主要的挑战在于如何投入工程时间让体验变得又快又好。但由于某些原因，这并不是JVM生态系统的首要任务。对于服务器框架来说，Quarkus在优化方面做得最好，我相信他们还可以做更多的工作。</blockquote><p></p><p></p><p>InfoQ：你如何定义和衡量一门编程语言成功与否？例如，你可以说Scala是成功的，因为它让函数式编程变得更加主流。你也可以认为Scala不再成功了，因为它把第二大JVM语言的位置让给了Kotlin。</p><p></p><p></p><blockquote>Ward：目标很重要，每个人都有不同的目标。对我来说，这与价值定位有关。我非常欣赏Flix把它的<a href=\"https://flix.dev/principles/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjI4NzY1NzcsImZpbGVHVUlEIjoiaTlsZlBwS25KU1U2MzFPYSIsImlhdCI6MTY2Mjg3NjI3NywiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.SPb60GdJFzYFQxcEz-yumdrCbV28WkURP8DEGQEuPRw\">目标/原则</a>\"写了出来。</blockquote><p></p><p></p><p></p><blockquote>Flix是一门非常成功的编程语言，因为它在实现目标方面做得非常出色。如果Flix设定的目标是拥有1000万活跃的开发人员，那么它肯定已经失败了（但我仍然喜欢它，因为我赞同它的原则）。喜欢一门语言和成功掌握一门语言是两码事。作为一名Kotlin项目经理，我的目标之一是让开发人员可以更容易地构建正确的软件（即更少的Bug）。Kotlin已经被证明可以减少20%的Android应用程序崩溃，这是一个巨大的成功。我想更进一步，通过语言和工具的改进继续减少应用程序和服务器端错误。</blockquote><p></p><p></p><p>InfoQ：软件开发的历史就是抽象层次不断增加的历史，面向对象和函数式编程已经有50多年的历史了。你认为在过去的20年里，抽象层次是如何提升的？你如何看待未来20年的增长？</p><p></p><p></p><blockquote>Ward：直到最近，函数式编程的许多想法仍然被局限在为数学极客（我希望有一天也能成为这样的人）提供的技术中。现在，多亏了Scala（和其他语言），我们开始看到面向对象和函数式编程的融合，使得那些非数学极客也能使用函数式编程。这种融合将会持续一段时间，帮助我们的代码变得更加可测试和可重用。Kotlin就是一个很好的例子，它是许多Java面向对象开发人员通往“轻函数式编程（lite-FP）”的桥梁，而“lite-FP”并不要求开发人员掌握范畴论。这一转变的下一阶段是拥抱“副作用”理念（将纯粹的函数与不具有参考透明性的部分分离开来）。许多新的编程语言已经内置了这个概念——Flix、Unison、Roc等。除了副作用之外，我们可能会看到类似Datalog的概念——一种内置在通用语言中的查询语言。我在Linq中第一次了解到这种想法，然后是Flix。查询是一种非常普遍的需求，无论是对于数据库、透镜（更新不可变的数据结构）还是GraphQL等。因此，使用集成的、经过编译器验证的方式编写查询是一个显著的优势。</blockquote><p></p><p></p><p>InfoQ：哪一种编程语言发展得最好？</p><p></p><p></p><blockquote>Ward：这取决于“最好”是怎么定义的。如果我们从纯粹的学术角度来考虑这个问题，我认为有关Scala的学术研究比我所知道的任何一种语言都多了很多个数量级。Scala的许多特性最终会出现在其他语言中，这对每一个人来说都很有益。Python已经做了惊人的工作，成为一种普遍可接受的语言。我听说许多面向数据的专业人士无法解决大多数典型的编程挑战，但可以使用Python编写复杂的数学算法，或使用Pandas、NumPy等库处理大量的数据集。Kotlin是一种具有Java互操作和多平台功能的现代语言。所以什么是“最好”取决于很多因素。</blockquote><p></p><p></p><p>InfoQ：JVM语言即将到来的哪个新特性最让你感到兴奋？</p><p></p><p></p><blockquote>Ward：在JVM方面，Loom改变了游戏规则。对于大多数Java/JVM开发人员来说，“反应式”编程是一个好主意，但不值得为此承担认知和复杂性方面的负担。Kotlin协程为异步操作提供了类似的零认知成本的想法。然而，对于许多JVM开发人员来说，在Loom进入他们的工作环境之前，反应式编程可能仍然是一个“不错”的特性。因此，在此之前，许多基于JVM的开发人员将在JDK 8上使用诸如Kotlin协程和Scala ZIO Effects这样的并发抽象。考虑到Loom的发布时间线和当前可用的替代方案，我不得不说，在JVM语言中，最让我感到兴奋的是即将到来的Scala无括号语法，它在Scala 3.0中已经完成了一半，并有望在Scala 3.3中全部完成。我希望我的代码相对于我要解决的问题来说少很多视觉上的噪音。我知道这看起来很傻，只是把括号拿掉就能产生这么大的影响。但是Python告诉我们，在大多数组织中，认知开销通常是最高的成本。编写一个正确的程序最困难/最昂贵的部分不是文本到字节码/机器码的转换，而是以计算机能够理解的形式正确地表示和阅读人类想法的成本。这看起来很愚蠢，但是大多数代码中的括号会分散我的注意力，影响我理解代码的意图。</blockquote><p></p><p></p><p>InfoQ：如果你可以对每一种JVM语言都做一个改变，你会做哪些改变?</p><p></p><p></p><blockquote>Ward：Java——我想做很多改变，这听起来像是对Java的控诉。但这并不是因为Java是基于JVM的，你也可以选择另一种语言，或者接受Java缓慢的发展进度，这都没什么问题。如果必须要改变一件事，那可能是更好地支持不可变性。默认的可变性是导致不确定性程序的根源。</blockquote><p></p><p></p><p></p><blockquote>Kotlin——当我在用Kotlin编程时，我最怀念Scala的是它的单体链语法（在Haskell中叫作“do notation”，在Scala中是for）。与Kotlin协程一样，当函数调用被链接起来时，代码看起来就像是命令式的。我不知道该如何将这种东西添加到Kotlin中，但如果做得好，我认为这将是非常棒的。</blockquote><p></p><p></p><p></p><blockquote>Scala——Scala最难的地方在于可以通过多种方式来完成大致相同的事情。例如，在Scala 3中至少有三种方法来实现基本的Sum类型（sealed、enum和逻辑OR)。尽管如此，Scala的复杂性仍然是一个问题，完成大多数相同的事情有多种方法也是一个问题。</blockquote><p></p><p></p><p>InfoQ：COBOL已经有60多年的历史了，现在仍然有人在使用它。你认为在2056年Java 60岁的时候，开发人员还会开发新的Java应用程序吗？</p><p></p><p></p><blockquote>Ward：当然！Java是我们日常使用的许多系统的关键部分。它不会消失，它会通过缓慢而渐进的增强继续演化（不像COBOL那样）。更大的Java生态系统（包括Kotlin、Scala、Clojure、Groovy等）也在继续增长。作为一个整体，它可能是世界上最大的开发者生态系统。新的JVM语言不断涌现，就像Flix一样，这表明创新周期不会很快停止。像Testcontainers、GraalVM和Kalix这样的创新和改变游戏规则的技术继续从Java生态系统中涌现出来，这股力量将推动未来35年（至少）的增长和进步。</blockquote><p></p><p></p><p>InfoQ：请你对2022年JVM编程语言的发展状态做个总结。</p><p></p><p></p><blockquote>Ward：现在是Java、Kotlin和Scala的一个激动人心的时刻！这些工具和语言让我体验到最高的开发效率。从移动端到服务器端，Java技术为我们每天使用的绝大多数关键系统提供支撑。对我来说，能够在一个平台上选择多种不同的编程语言真是太棒了。</blockquote><p></p><p></p><p>InfoQ：James，感谢你接受我们的采访。</p><p></p><h2>总结</h2><p></p><p>Ward很好地解释了播客上的评论——当Eckel谈到“仍被困在Java世界中的人们”时，他指的是使用他和James眼中的Java旧范式（比如过程式和面向对象编程）的开发人员。相比之下，Eckel和Ward在Scala中采用了Java语言中没有的函数式编程概念。可变性让Ward更难理解代码，并最终产生更多的Bug，这与不可变的函数完全不同。</p><p></p><p>作者简介</p><p></p><p>Karsten Silz作为全栈Java开发人员在欧洲和美国工作了23年。2004年，他在美国联合创办了一家软件产品初创公司。Karsten领导产品开发13年，在公司被收购后离开了公司。自2017年以来，他一直是德国和英国的承包商（Spring Boot、Angular、Flutter）。他在2020年以CTO的身份参与创办了软件即服务初创公司“Your Home in Good Hands”。</p><p></p><p>James Ward从1997年开始就是一名专业的软件开发者，大部分时间在帮助开发人员构建高质量的软件。他是纯函数式编程狂热爱好者，为了完成工作可以在理想方面做出妥协。</p><p></p><p>原文链接：</p><p></p><p><a href=\"https://www.infoq.com/articles/james-ward-java-jvm-languages/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjI4NzY1NzcsImZpbGVHVUlEIjoiaTlsZlBwS25KU1U2MzFPYSIsImlhdCI6MTY2Mjg3NjI3NywiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.SPb60GdJFzYFQxcEz-yumdrCbV28WkURP8DEGQEuPRw\">Java Champion James Ward on the State of Java and JVM Languages</a>\"</p>",
    "publish_time": "2022-09-12 11:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "图灵奖得主Yann LeCun：仅靠语言训练的人工智能，永远无法比拟人类智慧",
    "url": "https://www.infoq.cn/article/SNiuc7MjDkgkDzg9jzXO",
    "summary": "<p></p><blockquote>仅靠词汇和语句训练的人工智能系统，可能永远无法比拟人类认知。</blockquote><p></p><p>&nbsp;</p><p>当一位谷歌工程师最近宣布其最新的聊天机器人为人类时，随之而来的是一片混乱。<a href=\"https://www.infoq.cn/article/76gYqPA2YU0YXCDHFvIE\">聊天机器人LaMDA</a>\"是一个大型语言模型（LLM），旨在预测任何一段输入文字可能的下一句话。由于很多对话在一定程度上都是可预测的，因此这些系统可以借此推断如何有意义地将对话进行下去。LaMDA在这方面的出色表现甚至让工程师Blake Lemoine怀疑机器是不是闹鬼了。</p><p>&nbsp;</p><p>人们对Lemoine的说法反应不一：有些人对机器变人的想法嗤之以鼻；有的人认为虽然LLM还不算人，但不保证下一个也不是；还有人说，欺骗人类并不是什么困难事，毕竟我们都能在吐司上看到耶稣基督。</p><p>&nbsp;</p><p>但人们各式各样的反应也凸显了一个更深层次的问题：随着这些LLM变得愈发强大、应用愈发广泛，人们似乎再也无法在对它们的理解上达成共识。</p><p>&nbsp;</p><p>人们曾经坚信的，只有被拥有“同人类一样的完整思考能力”的机器才能够完成的“常识性”语言推理基础，在最近几年内不断被突破，但这些通过测试机器系统却似乎并不具有我们所期望的常识能力，仍旧会文不对题、废话连篇，甚至还会做出做出危险提议。</p><p>&nbsp;</p><p>因此引发了一个令人不安的疑问：这些系统怎么会如此聪明却也显得如此有限？</p><p>&nbsp;</p><p>追根究底，其实是语言的局限性，而非是人工智能的原因。在舍弃了思想与语言必然相关的固有印象后，我们会发现，这些系统注定会拥有浅薄的认知，一种永远无法匹及人类所拥有的，完整思维形式的认知。换句话说，即使是世界上最惊人的人工智能系统，也永远无法比拟人类。</p><p></p><h4>可以谈论任何事情的机器，并不一定真的知道自己在说什么</h4><p></p><p>&nbsp;</p><p>19世纪到20世纪之间一个主流的哲科理论是：知识即是言语。对事物的认知仅限于人们是否使用了正确的语句，在这张由我们所知的所有真实主张所织成的网络中，是否掌握了该事物与其他语句间的联系。</p><p>&nbsp;</p><p>在这套逻辑中，语言的理想形式是纯粹形式化、数字逻辑化的，是由任意符号所组成，由严格推理规则所链接的。在花时间剥去其中模糊性与不确定性后，即使是自然语言也不例外。正如维特根斯坦所说，“真命题的总体就是全部自然科学”。即使是心理学认知图与心理图像的新发现所带来的争议也没能撼动这在20世纪如此根深蒂固的理念，许多人仍坚称，心理学表层之下仍是语言学。</p><p>&nbsp;</p><p>有些聪敏过人的学者仍坚持这套观点：百科全书中包含一切可被知晓的知识，阅读所有可读之物即可全面了解一切。符号AI（依据逻辑规则规则操纵任意符号，使其以不同方式进行组合）的早期作品大都基于此。</p><p>&nbsp;</p><p>在这类研究中，AI所知的一切都在一个庞大数据库中，数据库本身则是由人工根据逻辑串联的真实语句组成。因此，对于系统智能的判断关键在于其是否能够合时宜地反馈正确的语句，或者说，能否正确地操作符号。</p><p>&nbsp;</p><p>这一概念也是图灵测试的基础：一台能够说出该说的一切的机器意味着它知道自己在说什么，因为知道正确的语句以及什么时候该说什么就已经穷尽了知识。</p><p>&nbsp;</p><p>然而，这套标准也有一个一直被避而不谈的问题：可以谈论任何事情的机器，并不一定真的知道自己在说什么。</p><p>&nbsp;</p><p>语言并不能穷尽知识，语言知识一种高度具体且极其有限的知识表述。无论是编程语言、符号逻辑还是口头表达，所有语言都依赖一种特定的表征模式，且擅长以高度抽象的形式表达离散对象和属性以及二者之间的关系。但阅读乐谱与收听音乐录音之间差异巨大，更何论是拥有演奏的技能。</p><p>&nbsp;</p><p>所有的表征模式都会涉及对于事物信息上的压缩，区别只在于压缩过程中留存下来的东西不同。语言的表征模式难以处理十分具体的信息，如对在描述不规则的形状、物体的运动、复杂机制的运作、一幅画的细微笔触，甚至是冲浪等特定环境下的细小动作。</p><p>&nbsp;</p><p>但一些非语言的表征模式在这方面的表述就很好，如包括图像、录像、图表以及地图的标志性知识，或者是训练后神经网络中的分布式知识，后者也常被称作是诀窍和肌肉记忆。每一种模式都有自己所擅长表达的，这些对于其他模式来说，可能会很难，甚至是不可能表达的。想象一下“毕加索或汤比”长什么样子？</p><p></p><h4>经过训练的大型语言模型可以掌握每一句话的背景知识</h4><p></p><p>&nbsp;</p><p>掌握语言表达的独特之处以及其限制所在的方法之一是，认识到单靠语言所能传递的信息有多少。语言在信息传递方面拥有非常“窄”的带宽，脱离词汇或语句这样上下文语境的独立文字所能传达的信息量很小。</p><p>&nbsp;</p><p>更何况还有无数同音异意的词组或代词的存在，让很多句子表述非常模糊：“盒子在笔里”这句话中，笔是指什么？墨水笔（pen）还是小孩的玩具围栏（playpen）？就如Chomsky及其追随者几十年来所坚称的一样，语言并不是一个明确的、毫不含糊的交流工具。</p><p>&nbsp;</p><p>人类并不需要完美的交流工具，因为我们在其他非语言层面共享认知。我们对句意的理解通常依靠句子所在的情景的深入理解，从而可以推断其所要表达的信息。这在对话场景中很明显，我们常常会讨论发生在我们周围的事，如足球比赛，或者是针对特定社会角色的明确目标，如在服务员处点单。</p><p>&nbsp;</p><p>阅读场景中也是如此。不过这部分训练不仅没让AI通过常识测试，甚至连小孩子也没能教育好。这种流行的无语境阅读技能培养，旨在通过一般化阅读理解策略培养孩子对文本的理解，然而有研究表明，孩子所掌握的相关背景知识的内容数量才是决定他是否能够理解文本的关键。</p><p>&nbsp;</p><p></p><blockquote>这些系统注定只会拥有浅薄的理解，永远无法接近人类所能的全身心思考。</blockquote><p></p><p>&nbsp;</p><p>词语和句子所固有的上下文性质是LLM运作的核心。一般来说，神经网络会将知识以技巧方式的形式表示，这是一种掌握上下文高度敏感的模式以及发现具体及抽象规律的熟练能力，也是在精细处理针对性任务输入的必备技能。</p><p>&nbsp;</p><p>在LLM中，这种能力意味着系统可以在已知文本的多个层面上找出规律，既能认知到单个词语在段落中的上下连接，也能分辨句子在文本框架中是如何承上启下的。</p><p>&nbsp;</p><p>其结果是，系统对语言的理解必定是结构化的：不以词汇在字典中的含义为准，而是根据其在语句的集合中所扮演的角色进行认知。因为很多词语几乎只在特定的领域使用，如“化油器”、“菜单”、“调试”，或者“电子”，所以只要带有这些词汇的句子，即使只有一句话，系统也能判断出其背景。</p><p>&nbsp;</p><p>简而言之，经过训练的LLM可以掌握每一句话的背景知识，会在前后文中寻找词语或句子来填补语境的空白。这意味着它们能够接受任何词汇或语句为输入，然后做出合理的方式继续对话或填补文本其余的部分，尽管这些回答很难说是无懈可击的。一个借助人类编写的语句所训练出的系统，并常常与人类交互，是能够拥有合理对话所应具备的一般理解的。</p><p></p><h4>大型语言模型的局限性</h4><p></p><p>&nbsp;</p><p>虽然总有人抗议，不应在这种语境下使用“理解”或者称呼LLM为“智能”，但在目前来看扣字眼似乎并由没什么用。确实如反对者所指责的，这些系统仅仅是在“模仿”，因为LLM对语言的理解虽然很惊人，但也很浅薄。</p><p>&nbsp;</p><p>这种浅薄也很似曾相识：课堂中大谈特谈专业术语的学生们不一定知道他们到底在说什么，他们仅仅是在模仿教授或是正在阅读文本段落。生活就是如此，我们常常很难搞清楚自己到底知道什么，尤其是当这些知识是从语言中获取到的时候。</p><p>&nbsp;</p><p>LLM 对一切的理解就是这样的浅薄。就比如GPT-3，通过遮盖语句或段落中未来词汇，让系统猜测这些词最有可能是什么，猜错便会被纠正，最终系统将能熟练猜测出最可能的词汇，成为一个有效的预测系统。</p><p>&nbsp;</p><p>也就是说，对于任何问题或谜题，正确答案或许只有几个，但我们却可以由无数个错误答案。因此，若想能稳定预测一类问题的正确答案，机器需要学习<a href=\"https://ai.googleblog.com/2022/04/pathways-language-model-palm-scaling-to.html\">特定的语言技能</a>\"，如解释笑话、解决文字问题或者是解开逻辑谜题。</p><p>&nbsp;</p><p>这些技能及相关知识，让机器可以解释复杂原理、简化困难概念，重述复述故事，以及其他一切依赖于语言的能力。同依靠逻辑规则链接的庞大语句数据库符号AI不同，知识以上下文敏感的方法体现，根据给定前文得出一个合理的下一句话。</p><p>&nbsp;</p><p></p><blockquote>抛弃了所有知识都是语言学的观点，将允许我们意识到有多少知识是非语言的。</blockquote><p></p><p>&nbsp;</p><p>然而，从语言学上解释概念与实际的使用是不同的。系统可以解释长除法但却不会进行长除法；可以列出那些话是冒犯性、不该说的，却又在下一秒自己说出这些话。语境知识可以带来玩弄语言的能力，但却不能教会我们做事的方法，如移情或谨慎处理困难的问题。</p><p>&nbsp;</p><p>后者却又是对语言使用者而言必不可少的，尽管这并不能算是语言能力，或者说，不主要是语言能力，语言只是附带的。这也适用于很多概念，甚至是讲座或是书本中学来的知识：虽然科学也会上课，但学生的主要评分还是基于他们的实验表现。除了文科外，解释清楚某件事往往不如让东西正确运作所需的小技巧或技能有用，或者说没有那么的重要。</p><p>&nbsp;</p><p>看透表面后，我们会更轻易地发现这些系统的局限性：它们注意力和记忆力大概只有一个段落。如果我们参与对话的话，这一点很容易被忽略，因为我们往往只关注最后一两句话，只关注我们的下一个回复。</p><p>&nbsp;</p><p>但对于更复杂的对话来讲，能够积极倾听，回忆并重温先前的对话、在不受干扰地维持对话主题并提出具体观点，等等，都需要系统拥有更长久的注意力和记忆。</p><p>&nbsp;</p><p>这进一步暴露了系统所能拥有的理解能力：只需每隔几秒就换个说辞，改变语气或打压系统，就很容易欺骗它们。如果回到过于之前的话题，系统就会重新开始，认定你的新观点是和就观点一致，切换语言或承认它相信你说的任何东西。形成一套连贯的世界观所需的理解远远超出它们现在的能力。</p><p></p><h4>语言之外</h4><p></p><p>&nbsp;</p><p>抛弃所有知识都是语言学的观点，将允许我们意识到究竟有多少知识是非语言学的。虽然书本包含了很多我们可以解压缩和使用的信息，但其他来源也是如此，一家的说明书甚至不屑于在图纸旁边填补文字说明；人工智能的研究者往往会先阅读论文中的图表，掌握大概网络架构后才会去扫一眼文本；游客总是会根据地图上的红点或绿色路线标识在纽约城游览。</p><p>&nbsp;</p><p>不局限于图表、图表或地图，人类通过世界探索学到了很多东西，让我们明白了人类和物体行为上能做和不能做的事。人造物和人类环境的结构直观地传达了很多信息：门把手在手的高度，锤子有较软的抓手，等等。非语言性的心理模拟在动物和人类中都很常见，不仅可以用于规划场景还可以用于逆向设计手工制品。</p><p>&nbsp;</p><p>同理，通过模仿社会习俗和仪式也可以向下一代传达各种技巧，从食物和药品的准备，到如何紧张时期维持和平。我们很多的文化知识都是标志性的，或是有精确的动作形式，可以在师徒间传递。这些细微的信息模式很难用语言来表达和传达，但仍然可以被他人所理解。这也是神经网络所擅长收集和完善的，对环境敏感的精确信息。</p><p>&nbsp;</p><p></p><blockquote>仅靠语言训练的系统永远不会拥有接近人类的智力，即使你将训练时间拖长到宇宙末日为止。</blockquote><p></p><p>&nbsp;</p><p>语言是很重要的，因为它可以在一个小小的格式中传达大量的信息，特别是在印刷厂和互联网诞生之后，可以被复制和广泛使用。但是，在语言中压缩信息并不是没有成本的：要解码一个信息量密集的段落需要花费很多功夫。文科会需要大量的课外阅读，但很大一部分的课堂时间仍然是用来复习困难的段落。建立一个深刻的理解是费时费力的，无论所提供的信息是多么的详尽。</p><p>&nbsp;</p><p>这就解释了为什么一台经过语言训练的机器可以知道这么多，同时却又这么少。它是通过一个小小的瓶颈获得了人类知识的一少部分。但人类知识的这一少部分可以是关于任何东西的，无论是爱情还是天体物理学。也就是说，它有点类似于一面镜子：它给人以深度的错觉，几乎可以反射任何东西，却只有一厘米厚。但如果我们试图探索它的深度，就会撞到脑袋。</p><p></p><h4>人工智能的聪明程度受到限制</h4><p></p><p>&nbsp;</p><p>这并不意味着机器就是蠢笨的，相反，这只是告诉了我们它们的聪明程度是受到限制的。一个仅仅借由语言训练的机器是永远无法比拟人类智慧的，就算你将训练时长延续到世界末日也是一样。语言的知识并不适合启发意识或成长为人，但从表面来看也似乎是足够的。很多情况下，表面就很好了，人类之间很少会真正对彼此进行图灵测试，咄咄逼人地询问他们对事物理解的深度、强迫他们做多位数乘法，大多谈话都只是微交谈。</p><p>&nbsp;</p><p>但是我们不应该把LLM拥有的浅层理解与人类从观察世界的景象、探索世界、在世界中进行实验以及与文化和其他人互动中获得的深层理解相混淆。语言可能是一个有用的组成部分，它扩展了我们对世界的理解，但语言并不能代表智力，这一点从许多物种中可以看出，例如鸟类、章鱼和灵长类动物。</p><p>&nbsp;</p><p>对非语言的深入理解是语言有用的基础，正因为我们拥有对世界的深入了解，才能迅速理解他人在谈论的事情。这种更广泛的，对环境敏感学习和方法是更基础也更古老的知识，是小动物身上出现意识的基础，并让其可以借此生存和繁荣。这也是人工智能研究人员在寻找人工智能常识时关注的更基本的任务，而不是这种语言学的东西。</p><p>&nbsp;</p><p>LLM没有固定的身体或长久存在的世界可以让它们产生知觉，所以他们的知识起始都源于文字，它们的常识也仅限于皮毛。我们的目标是让人工智能系统能够专注于其所谈论的世界，而不是词语本身。LMM还没有找到这二者之间的差别。这种深度理解上的差别是没办法仅仅通过语言弥补的，语言根本就不适合这件事。</p><p>&nbsp;</p><p>和LLM打交道的时间越长，就越能看出仅仅通过语言就能知道的东西有多么少。</p><p>&nbsp;</p><p>作者简介：</p><p>&nbsp;</p><p>Jacob Browning，纽约大学计算机科学系的博士后，研究人工智能哲学。</p><p>Yann LeCun，2018 年图灵奖得主，纽约大学银牌教授。</p><p>&nbsp;</p><p>原文链接：</p><p></p><p><a href=\"https://www.noemamag.com/ai-and-the-limits-of-language/\">https://www.noemamag.com/ai-and-the-limits-of-language/</a>\"</p><p>&nbsp;</p>",
    "publish_time": "2022-09-12 18:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "端到端英语发音检错在作业帮的应用",
    "url": "https://www.infoq.cn/article/ARMLcL0qLpBztICm1XGv",
    "summary": "<p>文 / 杨帆，王强强</p><p></p><h2>背景与需求</h2><p></p><p>目前，英语是世界通用语言，掌握了英语就有了与世界沟通、交流的工具。但是，中国普遍存在的“哑巴英语”、“中式英语”、发音不准等现象，极大地影响了英语学习者的听说能力，以及在实际生活中对英语的使用。近年来，随着素质教育改革，英语口语考试被逐步纳入中高考，学生们提升口语水平的需求也日益凸显。然而，口语学习需要大量的练习、及时的反馈和针对性的指导，但课上、课后都很难有一对一的教学机会；老师通常需要花费数倍于批改书面试卷的时间，才能完整地听完学生的语音并给出全面的反馈。采用计算机辅助语言学习技术，通过检测英语学习者的发音是否正确、错误的具体原因，可以及时、高效、便捷地提供针对性的发音指导，且不受传统面授的时空限制。</p><p></p><h2>行业现状</h2><p></p><p>现有的语音评测应用主要是对学习者的发音进行打分，但是很少反馈失分的具体原因并进行针对性地指导，对学习者改善发音助力有限。近年来，音素级发音检错技术在研究领域获得了越来越多的关注，可以检测学习者发音中多读、漏读和错读的音素，还可以通过根据发音错误诊断推送相应的文字及视频发音教程，给学习者提供针对性的专家级发音指导意见。依托作业帮专业的英语教师团队、丰富的口语练习题库、庞大的下沉市场用户规模、海量的中国学生口语练习数据，英语发音检错技术可以在课上、课后为所有英语学习者提供个性化、精准化的辅导，实现科技助力因材施教、教育普惠、“让优质教育触手可及”。</p><p></p><p>传统的语音评测主要通过强制对齐（Forced Alignment）获得朗读文本中各个音素在音频中的起止时间，然后在各个音素片段内计算目标发音音素与其它音素的概率比值，即GOP（Goodness of pronunciation）分数，最后通过设定阈值等方式判断各个音素的发音是否正确，或者综合各音素的GOP分数回归得到单词、句子的评分。</p><p></p><p>这类方案主要存在以下几点问题：</p><p></p><p>发音错误时强制对齐得到的时间边界可能与实际发音音素序列的时间边界不一致，导致计算的实际发音的概率值偏低，无法提供准确的检错与诊断；若在对齐网络中扩展常见的发音错误，需要专家知识并且很难覆盖实际应用中的各种可能；强制对齐方案无法准确地处理增读、漏读音素的情况，尤其是增读；GOP计算对时间边界比较敏感，但是很难获得含准确的时间边界标注的大批量语料库；传统的帧级识别模型，不论是GMM-HMM还是神经网络模型，训练流程都较为繁琐。近年来，端到端模型也被广泛应用于语音识别领域，并达到了和传统方法可比的性能，大大简化了模型的训练流程。在发音检错场景下，采用端到端音素识别可以直接识别学习者的实际发音音素序列，然后，通过最短编辑距离与目标发音音素序列进行匹配、对比，得到正确朗读、增读、漏读、错读音素的检错与诊断结果。相对于传统的强制对齐方案，该方案不需要精确的时间边界，并且能够很方便地检测增读、漏读音素的情况。</p><p></p><h2>作业帮的实践</h2><p></p><p>为了便于后续讨论，首先介绍我们采用的数据集和评价指标。评价发音检错与诊断任务最常用的数据集是L2-ARCTIC[1]。L2-ARCTIC是由第一语言分别为印地语、韩语、普通话、西班牙语、阿拉伯语和越南语的非英语母语人士录制的英语句子朗读数据，包含音频、提示文本和标注，标注了音频中增读、漏读和错读的音素。发音检错与诊断任务的评价指标主要有：</p><p></p><p>虚警率：实际发音正确的音素中，被检测为发音错误的比例；召回率：实际发音错误的音素中，被检测为发音错误的比例；诊断正确率：正确地判断为发音错误的音素中，识别为实际发音音素的比例。下面介绍端到端发音检错技术在作业帮落地实践过程中遇到的问题与解决方案。</p><p></p><h3>端到端模型选型</h3><p></p><p>目前主流的端到端语音识别技术有CTC（Connectionist Temporal Classification）、基于attention的encoder-decoder（AED）、RNN-T（Recurrent Neural Network Transducer）三类[2]。其中，CTC基于条件独立性假设，即假设序列中的每个元素是互相独立的，而AED和RNN-T模型均采用自回归解码，即每一时刻的输出都依赖于之前的输出，隐式地学习了序列中的语言模型。虽然在语音识别任务上，相对于CTC，AED和RNN-T模型都有更好的效果，但是考虑到在发音检错任务中，学习者发音错误后的音素序列模式可能与常见的音素组合不一致，为了避免语言模型对发音错误召回的影响，我们首先验证了CTC模型的效果。</p><p></p><h3>基于attention的文本信息融合</h3><p></p><p>实验结果表明，仅采用CTC音素识别准确率较低，发音检错虚警率约为21%，这在教学场景下是不可接受的。借鉴人进行发音评价的过程，在无文本参考的情况下转写实际发音音素序列较为困难，但是已知目标发音，判断实际发音与目标发音是否相近，这一任务就相对简单许多。同样的，将目标发音序列也作为模型输入，为模型提供额外的先验知识，可以降低模型学习的难度。</p><p></p><p>参考论文[3]中的实现，模型结构如下图所示：</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/48/54/48e556053c79a11a0bd29a86975f7054.png\" /></p><p></p><p></p><h3>发音错误数据增强</h3><p></p><p>由于标注真实发音错误的音频需要专业人士耗费大量的时间精细地标注，较难大批量获取，因而模型训练集中绝大部分为发音正确的数据。为了增强模型的检错能力，避免原样输出参考音素序列，采用随机替换输入音素序列中的音素来模拟发音错误的情况。</p><p></p><p>优化后，虚警率由原来的21%显著降低至9%左右，同时,诊断正确率也由原来的65%提升至77%。但是，发音错误召回率仅有57%。</p><p></p><h3>确定功能边界</h3><p></p><p>分析发现，高频虚警、高频未召回的音素对主要为发音相近的音素，如将元音/ɪ/误识别为/iː/。相较于明显的发音错误，这类细微的纠音在实际教学活动中优先级较低。为了进一步降低虚警率，鼓励学习者大胆开口说英语，通过与有多年教学经验的教研们沟通，我们约定了对/ʌ/和/ɑː/、/s/和/θ/、词尾的/s/和/z/等发音相近的音素对纠音优先级相对较低。这样，虚警率进一步降低至7%，不考虑此类发音错误，召回率也提升至67%。</p><p></p><p>最终实现的发音检错功能如下图所示：</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/69/d5/697ff2f873821687bc13ec9344746ed5.png\" /></p><p></p><p></p><h2>总结与展望</h2><p></p><p>我们通过将端到端音素识别用于发音检错，避免了传统的强制对齐方案训练流程复杂、时间边界不准、无法处理音素增读漏读的问题。并通过基于attention的文本信息融合、发音错误数据增强，取得了显著的检错效果提升。最后，结合实际教学需求，降低发音相近音素的纠音的优先级，进一步优化了实际应用场景下的效果体验。未来可能的优化方向包括：</p><p></p><p>标注实际应用场景下的真实发音数据；通过multi-task知识迁移的方式，引入发音属性识别等信息，提升模型的音素区分能力；基于音频和视频的多模态特征融合方案，可以在很大程度上尤其是在噪声环境下提升检错准确率。参考文献</p><p></p><p>[1] &nbsp;Zhao G, Sonsaat S, Silpachai A, et al. L2-ARCTIC: A non-native English speech corpus[C]//INTERSPEECH. 2018: 2783-2787.</p><p></p><p>[2] &nbsp;Prabhavalkar R, Rao K, Sainath T N, et al. A Comparison of Sequence-to-Sequence Models for Speech Recognition[C]//Interspeech. 2017: 939-943.</p><p></p><p>[3] &nbsp;Fu K, Lin J, Ke D, et al. A Full Text-Dependent End to End Mispronunciation Detection and Diagnosis with Easy Data Augmentation Techniques[J]. arXiv preprint arXiv:2104.08428, 2021.</p>",
    "publish_time": "2022-09-12 18:30:07",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]