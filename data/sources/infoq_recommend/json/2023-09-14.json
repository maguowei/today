[
  {
    "title": "Java 21：最新进展一览",
    "url": "https://www.infoq.cn/article/QB87kOkWjf6jXxODkd9T",
    "summary": "<p>Oracle Java平台组首席架构师<a href=\"https://www.linkedin.com/in/markreinhold\">Mark Reinhold</a>\"<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-August/008059.html\">宣布</a>\"<a href=\"https://openjdk.java.net/projects/jdk/20/\">JDK 21</a>\"（继<a href=\"https://www.infoq.com/news/2021/09/java17-released/\">JDK 17</a>\"之后的下一个长期支持(LTS)版本）已经进入初始发布候选阶段。主线源码库（在2023年6月初（Rampdown Phase One）fork到JDK<a href=\"https://github.com/openjdk/jdk21\">稳定代码库</a>\"） 定义了JDK 21的特新集合。一些关键错误，如回归或严重的功能问题，可能得到了修复，但这些修复必须通过<a href=\"https://openjdk.java.net/jeps/3#Fix-Request-Process\">Fix-Request</a>\"流程审批。根据<a href=\"https://openjdk.org/projects/jdk/21/#Schedule\">发布时间表</a>\"， JDK 21将于2023年9月19日正式发布。</p><p>&nbsp;</p><p>最终确定的15个新特新按照<a href=\"https://openjdk.java.net/jeps/0\">JEP</a>\"的形式分为四类：核心Java库，Java语言规范，HotSpot和安全库。</p><p>&nbsp;</p><p>被归入为核心Java库的6个新特新：</p><p>&nbsp;</p><p>JEP 431：<a href=\"https://openjdk.org/jeps/431\">序列集合</a>\"JEP 442：<a href=\"https://openjdk.org/jeps/442\">外部函数和内存API(第三次预览)</a>\"JEP 444：<a href=\"https://openjdk.org/jeps/444\">虚拟线程</a>\"JEP 446：<a href=\"https://openjdk.org/jeps/446\">作用域值(预览)</a>\"JEP 448：<a href=\"https://openjdk.org/jeps/448\">Vector API(第六次孵化器)</a>\"JEP 453：<a href=\"https://openjdk.org/jeps/453\">结构化并发(预览)</a>\"</p><p>&nbsp;</p><p>被归入Java语言规范的5个新特性：</p><p>&nbsp;</p><p>JEP 430：<a href=\"https://openjdk.org/jeps/430\">字符串模板(预览)</a>\"JEP 440：<a href=\"https://openjdk.org/jeps/440\">记录模式</a>\"JEP 441：<a href=\"https://openjdk.org/jeps/441\">switch模式匹配</a>\"JEP 443：<a href=\"https://openjdk.org/jeps/443\">未命名模式和变量(预览)</a>\"JEP 445：<a href=\"https://openjdk.org/jeps/445\">未命名类和实例主方法(预览)</a>\"</p><p>&nbsp;</p><p>被归入HotSpot的3个新特性：</p><p>&nbsp;</p><p>JEP 439：<a href=\"https://openjdk.org/jeps/439\">分代ZGC</a>\"JEP 449：<a href=\"https://openjdk.org/jeps/449\">弃用Windows 32位x86移植</a>\"JEP 451：<a href=\"https://openjdk.org/jeps/451\">准备禁止动态加载代理</a>\"</p><p>&nbsp;</p><p>最后，归入安全库的1个新特性：</p><p>&nbsp;</p><p>JEP 452：<a href=\"https://openjdk.org/jeps/452\">密钥封装机制API</a>\"</p><p>&nbsp;</p><p>值得注意的是，JEP 404（<a href=\"https://openjdk.org/jeps/404\">分代Shenandoah(实验特性)</a>\"），最初是针对JDK 21的）已正式从JDK 21的最终特性集中<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-June/007959.html\">移除</a>\"。这是由于“在审查过程中发现了确定性的风险，并且没有足够的时间来进行针对大量代码改动所需的评审。”Shenandoah团队决定“尽他们所能提供最好的分代Shenandoah”，并将JDK 22作为发布目标。</p><p>&nbsp;</p><p>我们研究了其中的一些新特性，以及它们所属的4个主要Java项目——<a href=\"https://openjdk.java.net/projects/amber/\">Amber</a>\"、<a href=\"https://wiki.openjdk.java.net/display/loom\">Loom</a>\"、<a href=\"https://openjdk.java.net/projects/panama/\">Panama</a>\"和<a href=\"https://openjdk.java.net/projects/valhalla/\">Valhalla</a>\"——这些项目旨在孵化一系列组件，并最终包含在JDK中。</p><p>&nbsp;</p><p></p><h4>Project Amber</h4><p></p><p>&nbsp;</p><p>JEP 445（<a href=\"https://openjdk.org/jeps/445\">未命名类和实例主方法(预览版)</a>\"），也就是之前的_灵活的主方法和匿名主类(预览)_和_隐式类和增强的主方法(预览)_，提议“让新手可以很容易地编写他们的第一个Java程序，而无需知道那些为大型程序而设计的语言特性。”Oracle Java语言架构师<a href=\"https://www.linkedin.com/in/briangoetz/\">Brian Goetz</a>\"在2022年9月撰写了博文<a href=\"https://openjdk.org/projects/amber/design-notes/on-ramp\">Paving the on-ramp</a>\"进一步推进了这一JEP。Oracle技术咨询委员会成员<a href=\"https://www.linkedin.com/in/gavin-bierman-a0173075/\">Gavin Bierman</a>\"已<a href=\"https://mail.openjdk.org/pipermail/amber-dev/2023-May/008065.html\">发布</a>\"<a href=\"https://cr.openjdk.org/~gbierman/jep445/jep445-20230502/specs/unnamed-classes-instance-main-methods-jls.html\">规范文档</a>\"初稿，供Java社区评审。关于JEP 445的更多细节可以在InfoQ的<a href=\"https://www.infoq.com/news/2023/05/beginner-friendly-java/\">报道</a>\"中找到。</p><p>&nbsp;</p><p>JEP 440（<a href=\"https://openjdk.org/jeps/440\">记录模式</a>\"）最终确定，并根据前两轮的<a href=\"https://openjdk.java.net/jeps/12\">预览</a>\"反馈进行了改进：在JDK 20中发布的JEP 432（<a href=\"https://openjdk.org/jeps/432\">记录模式(第二次预览)</a>\"）和在JDK 19中发布的EP 405（<a href=\"https://openjdk.org/jeps/405\">记录模式(预览)</a>\"）。这个特性通过_记录模式_来解构记录值。记录模式可以与_类型模式_结合使用，实现“强大的、声明式和可组合的数据导航和处理形式”。类型模式在switch中得到了进一步采用：在JDK 18中发布的JEP 420（<a href=\"https://openjdk.java.net/jeps/420\">switch模式匹配(第二次预览)</a>\"）和在JDK 17中发布的JEP 406（<a href=\"https://openjdk.java.net/jeps/406\">switch模式匹配(预览)</a>\"）。JEP 432最重要的变化是删除了对出现在增强的for语句头中的记录模式的支持。关于JEP 440的更多细节可以在InfoQ的<a href=\"https://www.infoq.com/news/2023/05/java-gets-boost-with-record/\">报道</a>\"中找到。</p><p>&nbsp;</p><p>JEP 430（<a href=\"https://openjdk.org/jeps/430\">字符串模板(预览)</a>\"）提出了用_字符串模版_（包含嵌入表达式的字符串字面量）来增强Java编程语言，这些表达式将在运行时进行验证和求值。关于JEP 430的更多细节可以在InfoQ的<a href=\"https://www.infoq.com/news/2023/04/java-gets-a-boost-with-string/\">报道</a>\"中找到。</p><p>&nbsp;</p><p></p><h4>Project Loom</h4><p></p><p>&nbsp;</p><p>JEP 453（<a href=\"https://openjdk.org/jeps/453\">结构化并发(预览)</a>\"）结合针对前两轮孵化的反馈：在JDK 19中发布的JEP 428（<a href=\"https://openjdk.org/jeps/428\">结构化并发(孵化器)</a>\"）和在JDK 20中发布的JEP 437（<a href=\"https://openjdk.org/jeps/437\">结构化并发(第二轮孵化器)</a>\"）。最新的重大变化包括：TaskHandle接口被重命名为<a href=\"https://cr.openjdk.org/~alanb/sc/api/java.base/java/util/concurrent/StructuredTaskScope.Subtask.html\">`Subtask`</a>\"；修复了handleccomplete()方法的通用签名；修改了取消子任务时的状态和行为；在<a href=\"https://cr.openjdk.org/~alanb/sc/api/jdk.management/com/sun/management/Threads.html\">`Threads`</a>\"类中定义了一个新的currentThreadEnclosingScopes()方法，该方法返回一个包含当前结构化上下文描述的字符串；<a href=\"https://download.java.net/java/early_access/loom/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/StructuredTaskScope.html\">`StructuredTaskScope`</a>\"类的fork()方法返回一个Subtask（之前前的TaskHandle）实例而不是<a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/concurrent/Future.html\">`Future`</a>\"，因为老的TaskHandle接口的get()方法被重构为行为与Future接口的resultNow()方法相同。关于JEP 453的更多细节可以在InfoQ的<a href=\"https://www.infoq.com/news/2023/06/structured-concurrency-jdk-21/\">报道</a>\"中找到。</p><p>&nbsp;</p><p>JEP 446（<a href=\"https://openjdk.org/jeps/446\">作用域值(预览)</a>\"），也就是之前的_扩展局部变量（孵化器）_，现在是JEP 429（<a href=\"https://openjdk.org/jeps/429\">作用域值(孵化器)</a>\"，在JDK 20中发布）之后的一个<a href=\"https://openjdk.org/jeps/12\">预览</a>\"特性。这个JEP建议在线程内部和线程之间共享不可变数据。这比线程局部变量更可取，特别是在使用大量虚拟线程时。</p><p>&nbsp;</p><p>JEP 444（<a href=\"https://openjdk.org/jeps/444\">虚拟线程</a>\"）根据前两轮的预览进行特新的确定：在JDK 20中发布的JEP 436（<a href=\"https://openjdk.org/jeps/436\">虚拟线程(第二次预览)</a>\"）和在JDK 19中发布的JEP 425（<a href=\"https://openjdk.org/jeps/425\">虚拟线程(预览)</a>\"）。该特性为Java平台提供虚拟线程，可以显著减少编写、维护、观察高吞吐量并发应用程序的工作量。来自JEP 436的最重要的变化是虚拟线程现在完全支持<a href=\"https://openjdk.org/jeps/8303683#Thread-local-variables\">线程局部变量</a>\"，取消了不使用这些变量的选项。关于JEP 444的更多细节可以在InfoQ的<a href=\"https://www.infoq.com/news/2023/04/virtual-threads-arrives-jdk21/\">报道</a>\"和Oracle Java平台组Java开发者布道师<a href=\"https://www.linkedin.com/in/jos%C3%A9-paumard-2458ba5/\">José Paumard</a>\"的<a href=\"https://inside.java/2022/06/08/jepcafe11/\">JEP Café</a>\"中找到。</p><p>&nbsp;</p><p></p><h4>Project Panama</h4><p></p><p>&nbsp;</p><p>JEP 448（<a href=\"https://openjdk.org/jeps/448\">Vector API(第六次孵化器)</a>\"）结合了对前五轮孵化反馈的增强：在JDK 20中发布的JEP 438（<a href=\"https://openjdk.org/jeps/438\">Vector API(第五次孵化器)</a>\"）、在JDK 19中发布的JEP 426（<a href=\"https://openjdk.org/jeps/426\">Vector API (第四次孵化器)</a>\"）、在JDK 18中发布的JEP 417（<a href=\"https://openjdk.java.net/jeps/417\">Vector API (第三次孵化器)</a>\"）、在JDK 17中发布的JEP 414（<a href=\"https://openjdk.java.net/jeps/414\">Vector API (第二次孵化器)</a>\"）、在JDK 16中作为<a href=\"https://openjdk.java.net/jeps/11\">孵化器模块</a>\"发布的JEP 338（<a href=\"https://openjdk.java.net/jeps/338\">Vector API (孵化器)</a>\"）。此功能建议增强Vector API，以便可以从外部函数和内存API定义的<a href=\"https://docs.oracle.com/en/java/javase/14/docs/api/jdk.incubator.foreign/jdk/incubator/foreign/MemorySegment.html\">`MemorySegment`</a>\"中加载和存储Vector。</p><p>&nbsp;</p><p>JEP 442（<a href=\"https://openjdk.org/jeps/442\">外部函数和内存API(第三次预览)</a>\"）基于之前的反馈进行了改进，并提供第三次预览：在JDK 20中发布的JEP 434（<a href=\"https://openjdk.org/jeps/434\">外部函数和内存API(第二次预览)</a>\"）、在JDK 19中发布的JEP 424（<a href=\"https://openjdk.org/jeps/424\">外部函数和内存API(预览)</a>\"），以及相关的孵化——在JDK 18中发布的JEP 419（<a href=\"https://openjdk.org/jeps/419\">外部函数和内存API(第二孵化器)</a>\"）和在JDK 17中发布的JEP 412（<a href=\"https://openjdk.org/jeps/412\">外部函数和内存API(孵化器)</a>\"）。这个特性为Java应用程序提供了一个API，可以通过有效地调用外部函数和安全地访问不受JVM管理的外部内存与Java运行时之外的代码和数据进行互操作。来自JEP 434的更新包括：在Arena接口中集中管理本地段的生命周期、增强的布局路径，使用新元素来解引用地址布局、移除VaList类。</p><p>&nbsp;</p><p>开发人员可能会有兴趣了解外部函数和内存API所带来的性能提升，这个API预计将成为JDK 22的最终特性。Oracle技术咨询委员会成员<a href=\"https://www.linkedin.com/in/minborg/\">Per-Åke Minborg</a>\"发表了一篇<a href=\"http://minborgsjavapot.blogspot.com/2023/08/java-22-panama-ffm-provides-massive.html\">博文</a>\"，他在文章中提供了一个关于字符串转换的基准测试，他使用这个API在JDK 21（JEP 442）和JDK 22（JEP Draft 8310626）中与旧的Java本地接口(JNI)调用进行了比较。</p><p>&nbsp;</p><p></p><h4>HotSpot</h4><p></p><p>&nbsp;</p><p>JEP 439（<a href=\"https://openjdk.org/jeps/439\">分代ZGC</a>\"）“通过扩展Z Garbage Collector(ZGC)来为年轻代和老年代象维护单独的代来提高应用程序性能”。这将使ZGC能够更频繁地回收早就成为垃圾的年轻代对象。”关于JEP 439的更多细节可以在InfoQ的<a href=\"https://www.infoq.com/news/2023/07/java-enhance-zgc/\">报道</a>\"中找到。</p><p>&nbsp;</p><p></p><h4>JDK 22</h4><p></p><p>&nbsp;</p><p>目前还没有针对计划于2024年3月发布的<a href=\"https://jdk.java.net/20/\">JDK 22</a>\"的JEP。然而，根据一些JEP候选和草案，特别是那些已经提交的，我们可以推测出哪些额外的JEP有可能包含在JDK 22中。</p><p>&nbsp;</p><p><a href=\"https://openjdk.org/projects/amber/\">Project Amber</a>\"的JEP 447（<a href=\"https://openjdk.org/jeps/447\">super()前置语句</a>\"）提议：允许构造函数中不引用正在创建的实例的语句出现在this()或super()调用之前，并保留现有的安全性和初始化保证。Oracle技术咨询委员会成员<a href=\"https://www.linkedin.com/in/gavin-bierman-a0173075/\">Gavin Bierman</a>\"提供了该JEP的<a href=\"https://cr.openjdk.org/~gbierman/jep447/jep447-20230420/specs/statements-before-super-jls.html\">初始规范</a>\"，供Java社区评审和反馈。</p><p>&nbsp;</p><p>JEP 435（<a href=\"https://openjdk.org/jeps/435\">异步堆栈跟踪虚拟机API</a>\"），一个特性JEP，提议定义一个有效的API，用于从包含Java和本地帧信息的信号处理程序获取异步调用跟踪信息。</p><p>&nbsp;</p><p>JEP 401（<a href=\"https://openjdk.org/jeps/401\">Null-Restricted值对象存储(预览)</a>\"，之前的_原始类(预览)_，属于Project Valhalla），引入了开发人员声明的原始类（Primitive Classes）——由值对象API定义的特殊类型的值类——它们定义了新的原始类型。</p><p>&nbsp;</p><p>JEP草案8307341（<a href=\"https://openjdk.org/jeps/8307341\">为限制JNI使用做准备</a>\"），提议限制使用不安全的Java本地接口(JNI)，并在外部函数和内存(FFM)API中使用受限制的方法，<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-August/008061.html\">这预计将成为JDK 22的最终特新</a>\"。从JDK 22开始，Java运行时将会显示关于使用JNI的警告，除非FFM用户通过命令行启用不安全的本地访问。预计在JDK 22之后的版本中，使用JNI将抛出异常而不是警告。</p><p>&nbsp;</p><p>JEP草案8310626（<a href=\"https://openjdk.org/jeps/8310626\">外部函数和内存API</a>\"），建议经过两轮孵化和三轮预览之后成为最终特新：在JDK 17中发布的JEP 412（<a href=\"https://openjdk.org/jeps/412\">外部函数和内存API(孵化器)</a>\"）、在JDK 18中发布的JEP 419（<a href=\"https://openjdk.org/jeps/419\">外部函数和内存API(第二孵化器)</a>\"）、在JDK 19中发布的EP 424（<a href=\"https://openjdk.org/jeps/424\">外部函数和内存API(预览)</a>\"）、在JDK 20中发布的JEP 434（<a href=\"https://openjdk.org/jeps/434\">外部函数和内存API(第二次预览)</a>\"），以及即将在JDK 21中发布的JEP 442（<a href=\"https://openjdk.org/jeps/442\">外部函数和内存API(第三预览版)</a>\"）。自上一个版本以来的改进包括：一个新的Enable-Native-Access MANIFEST属性，允许可执行JAR包中的代码调用受限制的方法，不需要使用——Enable-Native-Access标志；允许客户端以编程方式构建C函数描述符，避免使用特定于平台的常量；改进对本地内存可变长度数组的支持；本机字符串多字符集支持。</p><p>&nbsp;</p><p>JEP草案8288476（<a href=\"https://openjdk.org/jeps/8288476\">模式、instanceof和switch中的原始类型(预览)</a>\"），提议“允许在所有模式上下文中使用原始类型模式，将原始类型模式的语义与instanceof对齐，并允许将原始常量作为switch的case标签。”</p><p>&nbsp;</p><p>JEP草案8277163（<a href=\"https://openjdk.java.net/jeps/8277163\">值对象(预览)</a>\"），Project Valhalla的一个特性JEP，提议提供值对象——可以指定其实例行为的无标识值类。该草案与仍处于候选状态的JEP 401（<a href=\"https://openjdk.java.net/jeps/401\">原始类(预览)</a>\"）相关。</p><p>&nbsp;</p><p>JEP草案8313278（<a href=\"https://openjdk.org/jeps/8313278\">Java虚拟机的提前编译</a>\"），提议“让Java虚拟机加载编译成本地代码的Java应用程序和库，以实现更快的启动和基线执行。”</p><p>&nbsp;</p><p>JEP草案8312611（<a href=\"https://openjdk.org/jeps/8312611\">计算常量</a>\"），引入了_计算常量_的概念，持有不可变值，最多可被初始化一次。它具备final字段的性能和安全优势，同时在初始化时间方面提供了更大的灵活性。该特新将作为<a href=\"https://openjdk.org/jeps/12\">预览</a>\" API首次亮相。</p><p>&nbsp;</p><p>JEP草案8283227（<a href=\"https://openjdk.org/jeps/8283227\">JDK源代码结构</a>\"），一个信息类JEP，用于描述JDK源代码和JDK代码库中相关文件的总体布局和结构。该JEP建议帮助开发人员适应JEP 201（<a href=\"https://openjdk.java.net/jeps/201\">模块源代码</a>\"，在JDK 9中发布）所描述的源代码结构。</p><p>&nbsp;</p><p>JEP草案8280389（<a href=\"https://openjdk.org/jeps/8280389\">ClassFile API</a>\"），提议提供一个用于解析、生成和转换Java类文件的API。这个JEP最初将作为<a href=\"https://asm.ow2.io/\">ASM</a>\"（Java字节码操作和分析框架）的内部替代方案，并计划将其作为公共API开放出来。Java语言架构师<a href=\"https://www.linkedin.com/in/briangoetz\">Brian Goetz</a>\"称ASM为“带有大量遗留包袱的旧代码库”，并提供了关于该草案将如何演进并最终取代ASM的相关信息。</p><p>&nbsp;</p><p>JEP草案8278252（<a href=\"https://openjdk.org/jeps/8278252\">JDK打包和安装指南</a>\"，一个信息类JEP，提议为构建macOS、 Linux和Windows的JDK安装程序提供指南，以降低在安装不同JDK供应商提供的JDK时出现冲突的风险。其目的是通过形式化安装目录名称、包名称和可能导致冲突的其他元素，为安装JDK更新版本提供更好的体验。</p><p>&nbsp;</p><p>我们预计Oracle很快就会提供JDK 22将包含的JEP。</p><p>&nbsp;</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/09/java-21-so-far/\">https://www.infoq.com/news/2023/09/java-21-so-far/</a>\"</p>",
    "publish_time": "2023-09-14 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]