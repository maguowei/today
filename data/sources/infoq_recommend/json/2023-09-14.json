[
  {
    "title": "Java 21：最新进展一览",
    "url": "https://www.infoq.cn/article/QB87kOkWjf6jXxODkd9T",
    "summary": "<p>Oracle Java平台组首席架构师<a href=\"https://www.linkedin.com/in/markreinhold\">Mark Reinhold</a>\"<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-August/008059.html\">宣布</a>\"<a href=\"https://openjdk.java.net/projects/jdk/20/\">JDK 21</a>\"（继<a href=\"https://www.infoq.com/news/2021/09/java17-released/\">JDK 17</a>\"之后的下一个长期支持(LTS)版本）已经进入初始发布候选阶段。主线源码库（在2023年6月初（Rampdown Phase One）fork到JDK<a href=\"https://github.com/openjdk/jdk21\">稳定代码库</a>\"） 定义了JDK 21的特新集合。一些关键错误，如回归或严重的功能问题，可能得到了修复，但这些修复必须通过<a href=\"https://openjdk.java.net/jeps/3#Fix-Request-Process\">Fix-Request</a>\"流程审批。根据<a href=\"https://openjdk.org/projects/jdk/21/#Schedule\">发布时间表</a>\"， JDK 21将于2023年9月19日正式发布。</p><p>&nbsp;</p><p>最终确定的15个新特新按照<a href=\"https://openjdk.java.net/jeps/0\">JEP</a>\"的形式分为四类：核心Java库，Java语言规范，HotSpot和安全库。</p><p>&nbsp;</p><p>被归入为核心Java库的6个新特新：</p><p>&nbsp;</p><p>JEP 431：<a href=\"https://openjdk.org/jeps/431\">序列集合</a>\"JEP 442：<a href=\"https://openjdk.org/jeps/442\">外部函数和内存API(第三次预览)</a>\"JEP 444：<a href=\"https://openjdk.org/jeps/444\">虚拟线程</a>\"JEP 446：<a href=\"https://openjdk.org/jeps/446\">作用域值(预览)</a>\"JEP 448：<a href=\"https://openjdk.org/jeps/448\">Vector API(第六次孵化器)</a>\"JEP 453：<a href=\"https://openjdk.org/jeps/453\">结构化并发(预览)</a>\"</p><p>&nbsp;</p><p>被归入Java语言规范的5个新特性：</p><p>&nbsp;</p><p>JEP 430：<a href=\"https://openjdk.org/jeps/430\">字符串模板(预览)</a>\"JEP 440：<a href=\"https://openjdk.org/jeps/440\">记录模式</a>\"JEP 441：<a href=\"https://openjdk.org/jeps/441\">switch模式匹配</a>\"JEP 443：<a href=\"https://openjdk.org/jeps/443\">未命名模式和变量(预览)</a>\"JEP 445：<a href=\"https://openjdk.org/jeps/445\">未命名类和实例主方法(预览)</a>\"</p><p>&nbsp;</p><p>被归入HotSpot的3个新特性：</p><p>&nbsp;</p><p>JEP 439：<a href=\"https://openjdk.org/jeps/439\">分代ZGC</a>\"JEP 449：<a href=\"https://openjdk.org/jeps/449\">弃用Windows 32位x86移植</a>\"JEP 451：<a href=\"https://openjdk.org/jeps/451\">准备禁止动态加载代理</a>\"</p><p>&nbsp;</p><p>最后，归入安全库的1个新特性：</p><p>&nbsp;</p><p>JEP 452：<a href=\"https://openjdk.org/jeps/452\">密钥封装机制API</a>\"</p><p>&nbsp;</p><p>值得注意的是，JEP 404（<a href=\"https://openjdk.org/jeps/404\">分代Shenandoah(实验特性)</a>\"），最初是针对JDK 21的）已正式从JDK 21的最终特性集中<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-June/007959.html\">移除</a>\"。这是由于“在审查过程中发现了确定性的风险，并且没有足够的时间来进行针对大量代码改动所需的评审。”Shenandoah团队决定“尽他们所能提供最好的分代Shenandoah”，并将JDK 22作为发布目标。</p><p>&nbsp;</p><p>我们研究了其中的一些新特性，以及它们所属的4个主要Java项目——<a href=\"https://openjdk.java.net/projects/amber/\">Amber</a>\"、<a href=\"https://wiki.openjdk.java.net/display/loom\">Loom</a>\"、<a href=\"https://openjdk.java.net/projects/panama/\">Panama</a>\"和<a href=\"https://openjdk.java.net/projects/valhalla/\">Valhalla</a>\"——这些项目旨在孵化一系列组件，并最终包含在JDK中。</p><p>&nbsp;</p><p></p><h4>Project Amber</h4><p></p><p>&nbsp;</p><p>JEP 445（<a href=\"https://openjdk.org/jeps/445\">未命名类和实例主方法(预览版)</a>\"），也就是之前的_灵活的主方法和匿名主类(预览)_和_隐式类和增强的主方法(预览)_，提议“让新手可以很容易地编写他们的第一个Java程序，而无需知道那些为大型程序而设计的语言特性。”Oracle Java语言架构师<a href=\"https://www.linkedin.com/in/briangoetz/\">Brian Goetz</a>\"在2022年9月撰写了博文<a href=\"https://openjdk.org/projects/amber/design-notes/on-ramp\">Paving the on-ramp</a>\"进一步推进了这一JEP。Oracle技术咨询委员会成员<a href=\"https://www.linkedin.com/in/gavin-bierman-a0173075/\">Gavin Bierman</a>\"已<a href=\"https://mail.openjdk.org/pipermail/amber-dev/2023-May/008065.html\">发布</a>\"<a href=\"https://cr.openjdk.org/~gbierman/jep445/jep445-20230502/specs/unnamed-classes-instance-main-methods-jls.html\">规范文档</a>\"初稿，供Java社区评审。关于JEP 445的更多细节可以在InfoQ的<a href=\"https://www.infoq.com/news/2023/05/beginner-friendly-java/\">报道</a>\"中找到。</p><p>&nbsp;</p><p>JEP 440（<a href=\"https://openjdk.org/jeps/440\">记录模式</a>\"）最终确定，并根据前两轮的<a href=\"https://openjdk.java.net/jeps/12\">预览</a>\"反馈进行了改进：在JDK 20中发布的JEP 432（<a href=\"https://openjdk.org/jeps/432\">记录模式(第二次预览)</a>\"）和在JDK 19中发布的EP 405（<a href=\"https://openjdk.org/jeps/405\">记录模式(预览)</a>\"）。这个特性通过_记录模式_来解构记录值。记录模式可以与_类型模式_结合使用，实现“强大的、声明式和可组合的数据导航和处理形式”。类型模式在switch中得到了进一步采用：在JDK 18中发布的JEP 420（<a href=\"https://openjdk.java.net/jeps/420\">switch模式匹配(第二次预览)</a>\"）和在JDK 17中发布的JEP 406（<a href=\"https://openjdk.java.net/jeps/406\">switch模式匹配(预览)</a>\"）。JEP 432最重要的变化是删除了对出现在增强的for语句头中的记录模式的支持。关于JEP 440的更多细节可以在InfoQ的<a href=\"https://www.infoq.com/news/2023/05/java-gets-boost-with-record/\">报道</a>\"中找到。</p><p>&nbsp;</p><p>JEP 430（<a href=\"https://openjdk.org/jeps/430\">字符串模板(预览)</a>\"）提出了用_字符串模版_（包含嵌入表达式的字符串字面量）来增强Java编程语言，这些表达式将在运行时进行验证和求值。关于JEP 430的更多细节可以在InfoQ的<a href=\"https://www.infoq.com/news/2023/04/java-gets-a-boost-with-string/\">报道</a>\"中找到。</p><p>&nbsp;</p><p></p><h4>Project Loom</h4><p></p><p>&nbsp;</p><p>JEP 453（<a href=\"https://openjdk.org/jeps/453\">结构化并发(预览)</a>\"）结合针对前两轮孵化的反馈：在JDK 19中发布的JEP 428（<a href=\"https://openjdk.org/jeps/428\">结构化并发(孵化器)</a>\"）和在JDK 20中发布的JEP 437（<a href=\"https://openjdk.org/jeps/437\">结构化并发(第二轮孵化器)</a>\"）。最新的重大变化包括：TaskHandle接口被重命名为<a href=\"https://cr.openjdk.org/~alanb/sc/api/java.base/java/util/concurrent/StructuredTaskScope.Subtask.html\">`Subtask`</a>\"；修复了handleccomplete()方法的通用签名；修改了取消子任务时的状态和行为；在<a href=\"https://cr.openjdk.org/~alanb/sc/api/jdk.management/com/sun/management/Threads.html\">`Threads`</a>\"类中定义了一个新的currentThreadEnclosingScopes()方法，该方法返回一个包含当前结构化上下文描述的字符串；<a href=\"https://download.java.net/java/early_access/loom/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/StructuredTaskScope.html\">`StructuredTaskScope`</a>\"类的fork()方法返回一个Subtask（之前前的TaskHandle）实例而不是<a href=\"https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/concurrent/Future.html\">`Future`</a>\"，因为老的TaskHandle接口的get()方法被重构为行为与Future接口的resultNow()方法相同。关于JEP 453的更多细节可以在InfoQ的<a href=\"https://www.infoq.com/news/2023/06/structured-concurrency-jdk-21/\">报道</a>\"中找到。</p><p>&nbsp;</p><p>JEP 446（<a href=\"https://openjdk.org/jeps/446\">作用域值(预览)</a>\"），也就是之前的_扩展局部变量（孵化器）_，现在是JEP 429（<a href=\"https://openjdk.org/jeps/429\">作用域值(孵化器)</a>\"，在JDK 20中发布）之后的一个<a href=\"https://openjdk.org/jeps/12\">预览</a>\"特性。这个JEP建议在线程内部和线程之间共享不可变数据。这比线程局部变量更可取，特别是在使用大量虚拟线程时。</p><p>&nbsp;</p><p>JEP 444（<a href=\"https://openjdk.org/jeps/444\">虚拟线程</a>\"）根据前两轮的预览进行特新的确定：在JDK 20中发布的JEP 436（<a href=\"https://openjdk.org/jeps/436\">虚拟线程(第二次预览)</a>\"）和在JDK 19中发布的JEP 425（<a href=\"https://openjdk.org/jeps/425\">虚拟线程(预览)</a>\"）。该特性为Java平台提供虚拟线程，可以显著减少编写、维护、观察高吞吐量并发应用程序的工作量。来自JEP 436的最重要的变化是虚拟线程现在完全支持<a href=\"https://openjdk.org/jeps/8303683#Thread-local-variables\">线程局部变量</a>\"，取消了不使用这些变量的选项。关于JEP 444的更多细节可以在InfoQ的<a href=\"https://www.infoq.com/news/2023/04/virtual-threads-arrives-jdk21/\">报道</a>\"和Oracle Java平台组Java开发者布道师<a href=\"https://www.linkedin.com/in/jos%C3%A9-paumard-2458ba5/\">José Paumard</a>\"的<a href=\"https://inside.java/2022/06/08/jepcafe11/\">JEP Café</a>\"中找到。</p><p>&nbsp;</p><p></p><h4>Project Panama</h4><p></p><p>&nbsp;</p><p>JEP 448（<a href=\"https://openjdk.org/jeps/448\">Vector API(第六次孵化器)</a>\"）结合了对前五轮孵化反馈的增强：在JDK 20中发布的JEP 438（<a href=\"https://openjdk.org/jeps/438\">Vector API(第五次孵化器)</a>\"）、在JDK 19中发布的JEP 426（<a href=\"https://openjdk.org/jeps/426\">Vector API (第四次孵化器)</a>\"）、在JDK 18中发布的JEP 417（<a href=\"https://openjdk.java.net/jeps/417\">Vector API (第三次孵化器)</a>\"）、在JDK 17中发布的JEP 414（<a href=\"https://openjdk.java.net/jeps/414\">Vector API (第二次孵化器)</a>\"）、在JDK 16中作为<a href=\"https://openjdk.java.net/jeps/11\">孵化器模块</a>\"发布的JEP 338（<a href=\"https://openjdk.java.net/jeps/338\">Vector API (孵化器)</a>\"）。此功能建议增强Vector API，以便可以从外部函数和内存API定义的<a href=\"https://docs.oracle.com/en/java/javase/14/docs/api/jdk.incubator.foreign/jdk/incubator/foreign/MemorySegment.html\">`MemorySegment`</a>\"中加载和存储Vector。</p><p>&nbsp;</p><p>JEP 442（<a href=\"https://openjdk.org/jeps/442\">外部函数和内存API(第三次预览)</a>\"）基于之前的反馈进行了改进，并提供第三次预览：在JDK 20中发布的JEP 434（<a href=\"https://openjdk.org/jeps/434\">外部函数和内存API(第二次预览)</a>\"）、在JDK 19中发布的JEP 424（<a href=\"https://openjdk.org/jeps/424\">外部函数和内存API(预览)</a>\"），以及相关的孵化——在JDK 18中发布的JEP 419（<a href=\"https://openjdk.org/jeps/419\">外部函数和内存API(第二孵化器)</a>\"）和在JDK 17中发布的JEP 412（<a href=\"https://openjdk.org/jeps/412\">外部函数和内存API(孵化器)</a>\"）。这个特性为Java应用程序提供了一个API，可以通过有效地调用外部函数和安全地访问不受JVM管理的外部内存与Java运行时之外的代码和数据进行互操作。来自JEP 434的更新包括：在Arena接口中集中管理本地段的生命周期、增强的布局路径，使用新元素来解引用地址布局、移除VaList类。</p><p>&nbsp;</p><p>开发人员可能会有兴趣了解外部函数和内存API所带来的性能提升，这个API预计将成为JDK 22的最终特性。Oracle技术咨询委员会成员<a href=\"https://www.linkedin.com/in/minborg/\">Per-Åke Minborg</a>\"发表了一篇<a href=\"http://minborgsjavapot.blogspot.com/2023/08/java-22-panama-ffm-provides-massive.html\">博文</a>\"，他在文章中提供了一个关于字符串转换的基准测试，他使用这个API在JDK 21（JEP 442）和JDK 22（JEP Draft 8310626）中与旧的Java本地接口(JNI)调用进行了比较。</p><p>&nbsp;</p><p></p><h4>HotSpot</h4><p></p><p>&nbsp;</p><p>JEP 439（<a href=\"https://openjdk.org/jeps/439\">分代ZGC</a>\"）“通过扩展Z Garbage Collector(ZGC)来为年轻代和老年代象维护单独的代来提高应用程序性能”。这将使ZGC能够更频繁地回收早就成为垃圾的年轻代对象。”关于JEP 439的更多细节可以在InfoQ的<a href=\"https://www.infoq.com/news/2023/07/java-enhance-zgc/\">报道</a>\"中找到。</p><p>&nbsp;</p><p></p><h4>JDK 22</h4><p></p><p>&nbsp;</p><p>目前还没有针对计划于2024年3月发布的<a href=\"https://jdk.java.net/20/\">JDK 22</a>\"的JEP。然而，根据一些JEP候选和草案，特别是那些已经提交的，我们可以推测出哪些额外的JEP有可能包含在JDK 22中。</p><p>&nbsp;</p><p><a href=\"https://openjdk.org/projects/amber/\">Project Amber</a>\"的JEP 447（<a href=\"https://openjdk.org/jeps/447\">super()前置语句</a>\"）提议：允许构造函数中不引用正在创建的实例的语句出现在this()或super()调用之前，并保留现有的安全性和初始化保证。Oracle技术咨询委员会成员<a href=\"https://www.linkedin.com/in/gavin-bierman-a0173075/\">Gavin Bierman</a>\"提供了该JEP的<a href=\"https://cr.openjdk.org/~gbierman/jep447/jep447-20230420/specs/statements-before-super-jls.html\">初始规范</a>\"，供Java社区评审和反馈。</p><p>&nbsp;</p><p>JEP 435（<a href=\"https://openjdk.org/jeps/435\">异步堆栈跟踪虚拟机API</a>\"），一个特性JEP，提议定义一个有效的API，用于从包含Java和本地帧信息的信号处理程序获取异步调用跟踪信息。</p><p>&nbsp;</p><p>JEP 401（<a href=\"https://openjdk.org/jeps/401\">Null-Restricted值对象存储(预览)</a>\"，之前的_原始类(预览)_，属于Project Valhalla），引入了开发人员声明的原始类（Primitive Classes）——由值对象API定义的特殊类型的值类——它们定义了新的原始类型。</p><p>&nbsp;</p><p>JEP草案8307341（<a href=\"https://openjdk.org/jeps/8307341\">为限制JNI使用做准备</a>\"），提议限制使用不安全的Java本地接口(JNI)，并在外部函数和内存(FFM)API中使用受限制的方法，<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-August/008061.html\">这预计将成为JDK 22的最终特新</a>\"。从JDK 22开始，Java运行时将会显示关于使用JNI的警告，除非FFM用户通过命令行启用不安全的本地访问。预计在JDK 22之后的版本中，使用JNI将抛出异常而不是警告。</p><p>&nbsp;</p><p>JEP草案8310626（<a href=\"https://openjdk.org/jeps/8310626\">外部函数和内存API</a>\"），建议经过两轮孵化和三轮预览之后成为最终特新：在JDK 17中发布的JEP 412（<a href=\"https://openjdk.org/jeps/412\">外部函数和内存API(孵化器)</a>\"）、在JDK 18中发布的JEP 419（<a href=\"https://openjdk.org/jeps/419\">外部函数和内存API(第二孵化器)</a>\"）、在JDK 19中发布的EP 424（<a href=\"https://openjdk.org/jeps/424\">外部函数和内存API(预览)</a>\"）、在JDK 20中发布的JEP 434（<a href=\"https://openjdk.org/jeps/434\">外部函数和内存API(第二次预览)</a>\"），以及即将在JDK 21中发布的JEP 442（<a href=\"https://openjdk.org/jeps/442\">外部函数和内存API(第三预览版)</a>\"）。自上一个版本以来的改进包括：一个新的Enable-Native-Access MANIFEST属性，允许可执行JAR包中的代码调用受限制的方法，不需要使用——Enable-Native-Access标志；允许客户端以编程方式构建C函数描述符，避免使用特定于平台的常量；改进对本地内存可变长度数组的支持；本机字符串多字符集支持。</p><p>&nbsp;</p><p>JEP草案8288476（<a href=\"https://openjdk.org/jeps/8288476\">模式、instanceof和switch中的原始类型(预览)</a>\"），提议“允许在所有模式上下文中使用原始类型模式，将原始类型模式的语义与instanceof对齐，并允许将原始常量作为switch的case标签。”</p><p>&nbsp;</p><p>JEP草案8277163（<a href=\"https://openjdk.java.net/jeps/8277163\">值对象(预览)</a>\"），Project Valhalla的一个特性JEP，提议提供值对象——可以指定其实例行为的无标识值类。该草案与仍处于候选状态的JEP 401（<a href=\"https://openjdk.java.net/jeps/401\">原始类(预览)</a>\"）相关。</p><p>&nbsp;</p><p>JEP草案8313278（<a href=\"https://openjdk.org/jeps/8313278\">Java虚拟机的提前编译</a>\"），提议“让Java虚拟机加载编译成本地代码的Java应用程序和库，以实现更快的启动和基线执行。”</p><p>&nbsp;</p><p>JEP草案8312611（<a href=\"https://openjdk.org/jeps/8312611\">计算常量</a>\"），引入了_计算常量_的概念，持有不可变值，最多可被初始化一次。它具备final字段的性能和安全优势，同时在初始化时间方面提供了更大的灵活性。该特新将作为<a href=\"https://openjdk.org/jeps/12\">预览</a>\" API首次亮相。</p><p>&nbsp;</p><p>JEP草案8283227（<a href=\"https://openjdk.org/jeps/8283227\">JDK源代码结构</a>\"），一个信息类JEP，用于描述JDK源代码和JDK代码库中相关文件的总体布局和结构。该JEP建议帮助开发人员适应JEP 201（<a href=\"https://openjdk.java.net/jeps/201\">模块源代码</a>\"，在JDK 9中发布）所描述的源代码结构。</p><p>&nbsp;</p><p>JEP草案8280389（<a href=\"https://openjdk.org/jeps/8280389\">ClassFile API</a>\"），提议提供一个用于解析、生成和转换Java类文件的API。这个JEP最初将作为<a href=\"https://asm.ow2.io/\">ASM</a>\"（Java字节码操作和分析框架）的内部替代方案，并计划将其作为公共API开放出来。Java语言架构师<a href=\"https://www.linkedin.com/in/briangoetz\">Brian Goetz</a>\"称ASM为“带有大量遗留包袱的旧代码库”，并提供了关于该草案将如何演进并最终取代ASM的相关信息。</p><p>&nbsp;</p><p>JEP草案8278252（<a href=\"https://openjdk.org/jeps/8278252\">JDK打包和安装指南</a>\"，一个信息类JEP，提议为构建macOS、 Linux和Windows的JDK安装程序提供指南，以降低在安装不同JDK供应商提供的JDK时出现冲突的风险。其目的是通过形式化安装目录名称、包名称和可能导致冲突的其他元素，为安装JDK更新版本提供更好的体验。</p><p>&nbsp;</p><p>我们预计Oracle很快就会提供JDK 22将包含的JEP。</p><p>&nbsp;</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/09/java-21-so-far/\">https://www.infoq.com/news/2023/09/java-21-so-far/</a>\"</p>",
    "publish_time": "2023-09-14 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "支持几十种业务场景，字节跳动大规模 Sidecar 运维管理实践",
    "url": "https://www.infoq.cn/article/DZEY87Ntr7zNEfHhL8US",
    "summary": "<p>作者 &nbsp;| 字节跳动基础架构 / 服务框架团队研发工程师 - 刘立伟</p><p></p><p></p><blockquote>本文主要介绍了字节跳动 Sidecar 应用场景，以及进行 Sidecar 大规模版本升级的实践和总结。</blockquote><p></p><p></p><p></p><h2>字节 Sidecar 场景介绍</h2><p></p><p></p><p>Sidecar 是一种用于扩展应用程序功能的架构模式。在 Sidecar 架构中，应用程序主进程和一个或多个 Sidecar 进程运行在同一个计算节点中，例如 Pod、物理机等，Sidecar 进程与主进程保持相同的生命周期，为应用程序提供额外的功能支持，例如网络、安全、日志、监控等相关功能。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/c6/c6c45ae79bf3d7758ced1e00efaf1339.png\" /></p><p></p><p>目前，在字节跳动的微服务架构下，有丰富的 Sidecar 应用场景，包括 Service Mesh、网关、风控、流量录制、业务安全等几十种业务场景 Sidecar，支持了抖音、飞书、基础架构等多个业务线 / 部门。</p><p></p><p>以下，对几个典型 Sidecar 应用场景进行介绍。</p><p></p><h3>Service Mesh</h3><p></p><p></p><p>在微服务体系下，RPC 框架是微服务之间通信的核心组件，RPC 框架支持了服务发现、流量调度、负载均衡、访问控制等复杂的服务治理功能。随着微服务规模变大，RPC 框架暴露出一些问题：</p><p></p><p>多语言成本高：服务使用的开发语言分散，包含 Go、Python、C++ 等多种语言，各语言 RPC 框架都要实现完备的服务治理功能，开发、维护成本很高；升级成本高：治理功能更新后，需要升级框架版本，但是推动业务升级成本很高，如果版本有 Bug 也难以收敛；</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/96/96bb8875f23d555ede187f4f3c0d40af.png\" /></p><p></p><p>Service Mesh 解决了上述问题，作为服务通信的基础设施，它实现了一个高性能多协议的数据面代理和一个灵活可扩展的控制面服务，RPC 框架复杂的治理功能下沉到了数据面，数据面以 Sidecar 的形式部署在服务实例中。</p><p></p><p>相比于传统的 RPC 框架，Service Mesh 优势如下：</p><p></p><p>多语言成本低：治理功能收敛到了数据面，各语言 RPC 框架轻量化，维护成本降低；升级成本低：治理功能更新后，只需要升级数据面 Sidecar，Sidecar 与业务代码不耦合，可以单独升级；</p><p></p><h3>分布式 API 网关</h3><p></p><p></p><p>API 网关（APIGateway）以 API 为核心，提供流量调度、稳定性策略、服务治理等全套解决方案。</p><p></p><p>API 网关最初的架构是中心化网关，一个网关集群为多个服务进行分流，存在一些痛点问题：</p><p></p><p>网关变更风险大：网关的逻辑变更发布一旦有问题，将会影响所有业务；业务故障隔离差：多个服务共用同一个网关集群，单服务出现问题可能影响其他服务；大促容量评估难：每年双 11、新春红包活动，上万 API 接口的 QPS 很难评估，不同 API 的 延时、QPS、BodySize 对于网关性能的影响都是不同的，为了网关入口的稳定性，只能大量的扩容；</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/cc/cc02edb67af8ab2fa518fe189a67cc2d.png\" /></p><p></p><p>API 网关团队将网关改造成 Sidecar 部署到服务实例中，实现了分布式网关，并通过 Sidecar 运维平台对分布式网关进行管理。</p><p></p><p>通过分布式网关方案，解决了上述痛点问题：</p><p></p><p>网关变更风险小：网关的更新操作，只影响被变更的服务，粒度可控；业务故障隔离强：不同服务相互隔离，出问题不会互相影响；无容量评估问题：网关部署在服务 Pod 内，服务自行承担成本，自行扩容；</p><p></p><p>除了上述优化，也有其他收益：</p><p></p><p>由于网关和 Service 通信由 RPC 改为了 IPC，延时收益明显，性能得到了提升。</p><p></p><h3>风控 Sidecar</h3><p></p><p></p><p>风控团队为业务提供 API 反爬取、反作弊支持，可以降低业务接口风险，加强 API 安全防护。</p><p></p><p>风控最初提供 SDK 接入方式，用户接入时，需要在业务代码中主动集成风控 SDK，存在以下痛点问题：</p><p></p><p>用户接入成本高：API 防护是基本的安全能力，有大量的 API 服务需接入，但是业务接入仍需修改代码，有一定的接入成本；多语言 SDK 维护成本高：API 服务使用的语言不一致，不同语言均需要实现 SDK，SDK 更新迭代成本高；升级迭代困难：SDK 和业务代码耦合在一起，SDK 升级时需要业务配合升级，版本迭代、问题收敛效率低；</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/d4/d431b1712fddd9d024e70e1f2da1c53c.png\" /></p><p></p><p>为解决以上问题，风控团队和 Service Mesh 团队合作，借助 Sidecar 方案和 Service Mesh 的能力，设计开发了风控 Sidecar：</p><p></p><p>Mesh Proxy 与风控 Sidecar 通信进行 http 请求 / 应答的风控判断处理，Service 不感知风控逻辑；如果风控 Sidecar 拦截 http 请求，请求直接返回，Service 不会处理请求；</p><p></p><p>对比风控 SDK，通过风控 Sidecar 的方案，解决了上述痛点问题：</p><p></p><p>用户接入成本低：通过 Sidecar 运维平台动态注入 Sidecar，业务无感接入，接入成本低；无需维护多语言 SDK：风控逻辑收敛到 Sidecar，只需要迭代 Sidecar；升级迭代简单：风控逻辑更新，仅需升级 Sidecar，不用推动业务升级，升级节奏可控。</p><p></p><h3>MQ Sidecar</h3><p></p><p></p><p>消息队列 MQ 团队提供了 RocketMQ/BMQ 两种消息队列来处理在线、离线场景。为了满足业务接入，目前每种消息队列提供了多个语言的 SDK，存在一些问题：</p><p></p><p>多语言 SDK 维护成本高：功能很难对齐，MQ &nbsp;SDK 需要拓展流量治理、动态配置等能力，完善统一 Log、Metrics 逻辑，支持成本高；SDK 更新迭代速度慢：SDK 版本更新后，需要随业务代码发版，由于使用 MQ 的业务很多，业务发版速度很慢；</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/76/76eb239fa12620946292078184cf3919.png\" /></p><p></p><p>因此，MQ 团队引入 Sidecar 架构方案，实现了 MQ Sidecar：</p><p></p><p>MQ Sidecar 负责对接 MQ，流量治理等复杂逻辑收敛在 MQ Sidecar；保留 MQ SDK，SDK 只有基本 Produce/Consume 逻辑，接口保持一致，业务无需感知 Sidecar；</p><p></p><p>对比 MQ SDK，通过 MQ Sidecar 的方案，解决了上述痛点问题：</p><p></p><p>多语言 SDK 维护成本低：MQ SDK 只保留基本逻辑，更新频率低，减少维护成本；更新迭代速度快：MQ SDK 更新频率低，MQ Sidecar 更新频率高，但是 Sidecar 升级不受业务限制，升级速度快。</p><p></p><h2>Sidecar 架构的优势和挑战</h2><p></p><p></p><h3>优势</h3><p></p><p></p><p>综合对几个典型 Sidecar 应用场景的介绍，可以总结出 Sidecar 架构核心优势如下：</p><p></p><p>多语言维护成本低：业务逻辑收敛到 Sidecar，降低维护多语言 SDK 的成本；用户接入成本低：业务能力以 Sidecar 形式提供，用户可以无感接入，或者低成本接入；版本升级灵活可控：Sidecar 版本更新后，可以单独升级，支持有效的版本收敛、缺陷版本召回。</p><p></p><h3>挑战 - 升级运维</h3><p></p><p></p><p>从上述分析可以看出，Sidecar 架构的关键是 Sidecar 进程可以独立运行、单独升级，因此，只有支持 Sidecar 的升级运维能力，才能使 Sidecar 架构真正发挥出优势。然而，Sidecar 的升级运维面临严峻的挑战。</p><p></p><p>不同于传统的微服务升级，Sidecar &nbsp;升级场景更加复杂：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/5e/5e6dd535e089cc1f2083a86a3378ca3f.png\" /></p><p></p><p>其中最关键的特点，Sidecar 升级面向的服务规模很大，以 Service Mesh Sidecar 举例，生产环境接入情况如下：</p><p></p><p>微服务数量超过 4W实例数量超过 400W</p><p></p><p>在如此大规模的场景下，在进行版本升级的时候，一些问题会被放大：</p><p></p><p>事故风险：不同于升级单个 / 少量服务，升级的服务覆盖面过广时，如果版本有缺陷且扩散到很多服务，可能导致严重的业务受损，甚至出现挂站风险；时间成本：由于服务数量过多，运维人员在进行升级时，需要进行灰度验证、灰度观察、全区域发布等操作，如果发现问题还要操作回滚、修复，这将耗费大量时间，可能影响迭代速度，也耗费大量人力；</p><p></p><h4>事故案例介绍</h4><p></p><p></p><p>以下是一个真实的事故案例，展示了一次 Service Mesh 升级导致业务故障的处理全过程：</p><p></p><p>开始：Mesh 团队操作升级，类型为热升级，升级了一批服务的小流量；业务报警：升级完成后，很快出现多个业务报警，包括 API 5xx、CPU 异常、MEM 异常报警；业务排查：业务开始排查，发现报错的都是小流量实例，怀疑是 Paas 平台异常或者流量调度问题，因此拉了 Paas 和 Mesh Oncall 进行排查；定位：Mesh 团队很快定位到是新版本问题，初步定位是新 feature 引入的 Bug 导致的 CPU 升高；处理：Mesh 团队操作热升级回滚，并对一些回滚失败的实例进行迁移解决；恢复：Mesh 版本回滚后，业务恢复正常；改进：Mesh 团队确认问题并修复，对后续发版流程进行了优化，完善了升级过程监控，加强了灰度验证流程。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/7a/7aaaf2321599babe30d6eafb552f08fc.png\" /></p><p></p><p></p><h4>核心问题：稳定性 &amp; 效率</h4><p></p><p></p><p>在进行大规模 Sidecar 升级时，最核心的两个问题是稳定性和效率。</p><p></p><p>对于稳定性，主要关注业务故障风险：</p><p></p><p>新版本缺陷：新版本可能引入缺陷，比如逻辑 Bug、SDK 兼容问题等，导致业务发生故障；灰度验证有效性：升级新版本时，需要进行灰度验证，但是灰度验证不充分，导致没有发现问题；故障感知与处理：问题发生时，Sidecar 运维人员缺少报警没有及时感知到，并在继续升级的过程中，异常版本大范围扩散，导致回滚、止损成本高。</p><p></p><p></p><blockquote>历史上，Service Mesh 升级导致过 P0 事故，导致业务受损</blockquote><p></p><p></p><p>对于效率，主要关注时间、人力成本：</p><p></p><p>发布周期长：一个版本的发布周期可能很长，发布过程中，会出现多种情况影响发布速度，比如新 feature 随意插入、紧急 feature、缺陷修复等；耗费人力：发布过程中，会有多种原因导致人力耗费严重，比如发布周期长，自动化程度低导致灰度、升级、版本召回繁琐等。</p><p></p><p></p><blockquote>历史上，Service Mesh 进行 1 次大版本升级，历时 5 个月，期间多次 feature 插入、问题修复，共发了 25 个小版本才最终完成升级</blockquote><p></p><p></p><h2>Sidecar 大规模升级 - 思考</h2><p></p><p></p><p>如何设计一套可靠的 Sidecar 大规模升级方案？为应对稳定性和效率两个挑战，主要从变更安全和变更效率两个角度展开思考：</p><p></p><p>变更安全：确保升级过程是安全的，不会对业务造成稳定性影响；变更效率：尽可能缩短升级的时间，减少手工操作，降低人力成本。</p><p></p><h3>变更安全</h3><p></p><p></p><p>要保障升级过程的安全，必须树立对风险的正确意识：问题一定存在！</p><p></p><p>只不过，对于问题，存在已知问题和未知问题，对两种问题有不同的应对措施：</p><p></p><p>杜绝已知问题：对于已知问题，要有严密的机制防止其发生，比如：维护缺陷版本，拦截缺陷版本的升级，拒绝不该升级的服务；谨慎验证未知问题：保证版本验证流程的合理性，尽早的将问题暴露出来，防止扩散。</p><p></p><p>当然，总有问题不可避免的发生，此时需要积极应对已发生问题：</p><p></p><p>主动发现问题：要有主动检测、发现问题的手段，主动、尽早发现问题，缩短影响时间；阻断问题扩散：问题出现，要及时阻断，防止问题扩散面积过大；快速修复：要对问题快速修复，及时止损，比如快速回滚、修复版本快速覆盖等。</p><p></p><h3>变更效率</h3><p></p><p></p><p>为提升变更效率，首先，要完善变更规范：</p><p></p><p>加强准入限制：杜绝随意的 feature 插入，并保证合入的 feature 经过严格测试，防止出现 Bug 影响发布速度；</p><p></p><p>其次，通过技术手段，尽量加快升级速度：</p><p></p><p>自动化：提升灰度验证、逐步扩量、版本召回等流程的自动化水平，减少人的参与，减少人为导致问题的风险；安全加速：在有安全保证的前提下，合理的进行发布加速，提升速度。</p><p></p><h3>总结</h3><p></p><p></p><p>综上，对 Sidecar 大规模升级的思路进行总结：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/92/92c9221eb52d880fafb751f4493a3d0b.png\" /></p><p></p><p>在不同的升级阶段，综合多种策略保障变更安全和变更效率：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/d4/d45d274200faf236267cf947e65dc4cf.png\" /></p><p></p><p>同时，最关键的，要将版本升级流程平台化，将上述策略固化在平台上。</p><p></p><h2>Sidecar 大规模升级 - 方案解析</h2><p></p><p></p><p>我们构建了一套 Sidecar 运维管理系统，在系统上落地了 Sidecar 大规模升级方案，本节对如何进行安全、高效的 Sidecar 大规模升级进行详细解析。</p><p></p><h3>运维管理系统</h3><p></p><p></p><p>Sidecar 运维管理系统提供了一套 Sidecar 应用运维管理解决方案，支持多种云环境下 Sidecar 标准化接入、安全运行、观测运维、版本治理等能力。</p><p></p><p>系统包含以下核心组件：</p><p></p><p>SidecarAgent：与业务进程部署在同一个实例中，负责管理 Sidecar 进程的生命周期，包括启动、升级、退出、异常处理等；SidecarManager：负责存储 Service 启用的 Sidecar 列表及版本信息，并下发给 SidecarAgent；Sidecar 运维平台：负责 Sidecar 运维管理，支持 Sidecar 元信息管理、启 / 停用、升级等运维能力，平台的升级计划功能支持 Sidecar 大规模升级。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/d8/d86a161e69c5ccefc25eac2ca126a65f.png\" /></p><p></p><h3>方案总览</h3><p></p><p></p><p>以下为完整的升级方案总览：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/cc/cce3eb3c61223225342446fb95637fcc.png\" /></p><p></p><p>方案从升级的各个阶段入手，通过引入多项措施控制变更质量，保障变更安全，并在安全的基础上加速升级，提升变更效率。</p><p></p><p>在升级前，严格控制准入，包括：变更准入、版本准入、服务准入等策略。</p><p></p><p>在升级中，平台构建了灰度验证、逐步全量的自动化发布流程，可以谨慎的对版本进行验证，并且谨慎的将版本逐步全量。</p><p></p><p>在问题发生时，平台支持通过快速回滚、修复覆盖的流程，支持快速恢复，快速止损。</p><p></p><p>在升级后，支持版本治理，包括对长尾版本的收敛，以及在版本发现异常后，对版本进行快速的召回。</p><p></p><p>另外，在发布的整个流程中：</p><p></p><p>加强变更管控：平台对齐公司变更管控、封禁策略，杜绝在非可变更窗口进行升级，降低变更风险；主动检测异常：构建了异常检测机制，支持在升级中，对服务进行异常检测，在发现异常后，及时阻断升级。</p><p></p><p>以下，对升级流程中灰度验证、逐步全量和异常检测进行介绍，详细介绍如何将上述策略落地。</p><p></p><h3>升级流程</h3><p></p><p></p><h4>灰度验证</h4><p></p><p></p><p>灰度是逐步将新版本验证稳定、可靠的过程，要在灰度阶段尽可能的验证出问题，不要到全量阶段才暴露出问题，不然会导致更大面积的影响。</p><p></p><p>谨慎验证</p><p></p><p>首先，关于灰度覆盖面，要确保灰度验证的有效性，需要保证足够的覆盖面，这样才能验证到足够多的场景。</p><p></p><p>但是，如何保证足够的覆盖面，对于 Sidecar 新版本可能影响的服务，分为两类：</p><p></p><p>预期内受影响的服务：新版本的逻辑改动，对于预期内会受影响的服务，在升级时会明确关注；</p><p></p><p></p><blockquote>比如：新版本变更了负载均衡算法，升级时会明确关注服务的流量负载情况</blockquote><p></p><p></p><p>预期外受影响的服务：新版本的逻辑改动，意外的影响到了某些服务，这些服务不会被关注到。</p><p></p><p></p><blockquote>比如：一些历史逻辑受影响，或者有用户使用了非公开的特性</blockquote><p></p><p></p><p>但是，「预期外受影响的服务」是很难知道的，如果灰度覆盖不到这些服务，就无法保证灰度的有效性。为了简单起见，我们选择了大力出奇迹的做法，选择对所有服务进行灰度，这样就尽量保证了覆盖面。</p><p></p><p>其次，关于单服务灰度范围，字节的服务部署区分小流量、单机房、全流量的部署阶段，小流量阶段一般只部署少量的实例，业务升级服务时使用该阶段进行新版本验证，因此 Sidecar 也使用小流量阶段进行灰度验证。</p><p></p><p>另外，关于升级方式，要保证灰度版本快速生效，这样有问题才能尽快暴露出来，因此，我们选择使用热升级的方式，热升级后，服务使用的 Sidecar 版本可以立即更新。</p><p></p><p>最后，还构建了特征服务机制，Sidecar 的升级，可能会对特定服务产生影响，比如特定语言、框架、通信协议，或者使用了特殊配置的服务，因此，我们构建了特征集合，并对每种特征选取有代表性的服务集合，灰度验证时，首先对这些服务进行验证，并充分观察服务是否异常。</p><p></p><p></p><blockquote>比如：Service Mesh HTTP 压缩算法调整，影响到了配置特殊 HTTP 压缩算法的服务</blockquote><p></p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/bd/bdbb5ef2ec256a0ce0a087daa93955b0.png\" /></p><p></p><p>防扩散</p><p></p><p>在灰度阶段，要将问题尽早的暴露出来，并防止问题扩散，其中有两个关键点：</p><p></p><p>防扩散到全量阶段：在灰度阶段，将问题验证出来，并及时阻断后续升级流程；防扩散到过大灰度范围：因为要灰度覆盖所有服务，即便是在灰度阶段，出现问题后，也要避免影响过多服务，将业务影响降到最低。</p><p></p><p>为达成防扩散的目标，设计实现了以下方案：</p><p></p><p>首先，控制升级顺序，保障：</p><p></p><p>服务敏感 / 重要程度：不敏感 / 不重要 -&gt; 敏感 / 重要升级后观察充分程度：观察充分 -&gt; 观察不充分</p><p></p><p>具体顺序如下：</p><p></p><p>服务等级：P2 -&gt; P1 -&gt; P0部署区域：线下 -&gt; 线上各区域部署环境：预览环境 -&gt; 生产环境服务分类：特征服务 -&gt; 全量服务</p><p></p><p>基于上述升级顺序，对全量服务进行顺序编排，然后逐步对服务进行灰度升级。</p><p></p><p>其次，控制升级节奏，要防止一次变更影响过多服务，控制好爆炸半径：</p><p></p><p>分批发布：对服务进行合理的批次划分，确定合适的分批间隔，逐个批次进行升级，目前平台支持指数分批、线性分批策略；</p><p></p><p>限制变更数量上限：限制好每批的变更数量上限，也限制好每天的变更数量上限。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/45/4502ba41fd0b500febea2d9775368d08.png\" /></p><p></p><p>分批发布 - 指数分批</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/3e/3e9a46681d39ab80ad9921b58cd649dc.png\" /></p><p></p><p>分批发布 - 线性分批</p><p></p><p>最后，支持异常检测、异常阻断：</p><p></p><p>异常检测：在升级时，创建异常检测任务，对服务异常进行检测；异常阻断：如果检测到异常后，及时阻断升级，并通知用户，进行异常问题确认。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/ae/aecbc74260b774dabfd1060bbe469c16.png\" /></p><p></p><p>检测到异常后的工单详情页面</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/b8/b87f2855bd085ac4415e9b4d7dc4072b.png\" /></p><p></p><p>异常检测详情页面</p><p></p><p></p><h4>逐步全量</h4><p></p><p></p><p>灰度验证完成后，说明新版本已经基本稳定，可以开始全量的发布，但是，仍不排除有特殊问题没有暴露出来，因此，在全量的过程中，也要防范问题的发生。</p><p></p><p>全量阶段，主要目的是进行安全的铺量，在保证安全的前提下，将新版本逐步的升级到全量服务。</p><p></p><p>主要采用了以下策略：</p><p></p><p>安全升级</p><p></p><p>不同于灰度阶段使用热升级的方式，使用安全升级进行全量，安全升级不会让版本立即生效，而是配置好目标版本，跟随业务升级生效。使用安全升级，可以避免热升级可能导致的业务流量受损，并且服务在升级时，有服务负责人进行充分的稳定性观察，相比热升级安全很多。</p><p></p><p>控制顺序</p><p></p><p>和灰度验证类似，安全铺量阶段，也采用相同的升级顺序控制，确保先升级不敏感 / 不重要的服务，保障敏感 / 重要的服务。</p><p></p><p>控制节奏</p><p></p><p>和灰度验证类似，安全铺量阶段，也采用相同的升级节奏控制，进行分批升级，限制变更数量上限，控制好爆炸半径。</p><p></p><p>并行加速</p><p></p><p>由于升级的区域很多，为加速升级速度，对不同的区域进行合理的并行推进，加快推进速度。</p><p></p><h4>流程总结</h4><p></p><p></p><p>对升级流程进行总结，以下为一个升级流程的全貌，包括灰度阶段、全量阶段，以及，升级完成后的版本收敛阶段。</p><p></p><p>平台将这些流程、策略都固化下来，支持了大规模升级流水线，可以支持自动化的版本升级，保障变更安全，提升变更效率。</p><p></p><p></p><blockquote>以 Service Mesh 升级为例，各阶段大概耗时如下：灰度阶段 - 线下：5 个工作日灰度阶段 - 线上各区域：12 个工作日‍全量升级（线下 &amp; 线上）：11 个工作日</blockquote><p></p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/2f/2f7f1e8eef591d10c3fcfac8e6f6504b.png\" /></p><p></p><h3>异常检测</h3><p></p><p></p><p>在 Sidecar 升级过程中，平台支持主动检测、主动发现异常，在出现问题后，平台可以及时的阻断异常，降低故障影响时间，减少业务损失。</p><p></p><p>Sidecar 升级过程中，如果新版本有问题，一般会导致 Sidecar 自身或者业务出现异常问题，比如：</p><p></p><p>Sidecar 异常：Sidecar 异常退出，Sidecar CPU、MEM 出现异常增长；服务异常：服务接口错误率升高、延时升高，调用下游错误率升高，实例 CPU、MEM 出现异常增长，甚至服务出现告警等。</p><p></p><p>这些问题一般能从指标、日志等方面检测出来，也可以从服务告警反映出异常。因此，我们可以对这些指标、日志、服务告警等进行检测，检测是否有异常发生。</p><p></p><p>我们和字节内部上线检测平台（Niffler）合作，构建了 Sidecar 检测模型，在升级过程中对服务、Sidecar 的异常进行检测，检测模型包含以下三类检测指标：</p><p></p><p>基座服务指标：检测服务是否出现进程退出 /Panic，CPU、MEM 占用上涨，接口成功率下降、延时上涨，错误日志增多，出现服务告警等；Sidecar 通用指标：检测 Sidecar 是否发生进程退出 /Panic，CPU、MEM &nbsp;占用上涨等；Sidecar 自定义指标：Sidecar 开发者可以配置自定义指标，检测这些指标是否出现异常。</p><p></p><h2>落地效果</h2><p></p><p></p><p>以 Service Mesh 为例，该大规模升级方案上线后，升级稳定性和效率都有明显收益：</p><p></p><p>在稳定性方面，很多问题在灰度验证时被及时发现，异常检测机制也检测、发现到很多异常，版本升级导致的事故数量、等级明显降低。</p><p></p><p>在升级效率方面，Service Mesh 发布一次大版本，小版本数量和发布耗时都明显下降：</p><p></p><p></p><blockquote>Service Mesh 在一个大版本的升级过程中，会发布小版本进行灰度、全量的全流程，如果小版本成功全量到所有服务，则完成大版本的升级。但是，在小版本发布过程中，如果有紧急 feature、问题修复，则需要重新发布新的小版本，一般要发布多个小版本，才能完成大版本升级。</blockquote><p></p><p></p><p>平均小版本数量：从 10+ 个降低到 8.6 个</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/87/8704f01912d14c64359433a37d60199e.png\" /></p><p></p><p>一次大版本发布，平均耗时：从 4+ 个月降低到 2.1 个月</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/5e/5e2e8c821c6c4d7a18f17b495f7fb2f9.png\" /></p><p></p><h2>下一步计划</h2><p></p><p></p><p>1. 继续提升效率</p><p></p><p>目前，虽然大规模升级效率已经有了明显提升，但是由于字节跳动业务覆盖区域很多，平台缺乏多区域串联能力，目前操作所有区域的升级仍是一件繁琐的事情。因此，我们计划会进一步增强多区域升级的能力，降低多区域操作成本。</p><p></p><p>另外，为了解决升级过程中，如果发现版本缺陷，进行修复并重新升级，对升级速度影响过大的问题，我们也在探索更高效的小版本自动验证机制，进一步加快问题发现能力，加快升级速度。</p><p></p><p>2. 完善异常检测</p><p></p><p>目前，虽然支持了异常检测能力，但是当前的检测模型还比较简单，检测准确率有待提升，存在较多的误报、漏报。因此，我们后续会对检测模型进行进一步调优，提升准确率，以发挥异常检测的更多价值。</p><p></p><p>3. 加强版本收敛</p><p></p><p>目前，虽然设计了版本收敛阶段，但是平台对于版本收敛的功能支持并不好。有些 Sidecar 仍旧会存在比较多的长尾版本，并且如果出现缺陷版本，召回流程也比较繁琐。因此，我们后续会进一步加强版本收敛能力，支持更有效的长尾版本收敛、缺陷版本召回功能。</p><p></p>",
    "publish_time": "2023-09-14 10:27:54",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "实时双向同步：朴朴 Elasticsearch 双活自研实践与思考",
    "url": "https://www.infoq.cn/article/SS5ajVIjWGy1WWlXtkXT",
    "summary": "<p></p><h2>背景</h2><p></p><p></p><p>随着朴朴业务的快速增长，业务中断给公司的品牌、经济以及客户带来影响越来越大，因此业务对容灾的需求越来越迫切，要求在发生灾难时，业务能够快速恢复。显然当前公司采用的数据冷备的方式无法满足这个需求。出于公司长远规划考虑，核心业务需要具备地域级灾难的故障逃逸能力，确保在地域灾难发生时能够在分钟级内快速恢复业务，因此朴朴的双活建设被提上了议程。</p><p></p><p>双活建设包含应用双活建设和数据双活建设。数据双活是指两个数据中心都有完整数据，并且同时承担读写业务。这两个数据中心互为备份且实时同步数据，确保一个数据中心故障后，另一个数据中心可以快速接管业务。目前朴朴需要实现双活的业务数据散布在 MySql、Elasticsearch、Redis、Kafka 等等，要实现双活就要求两个数据中心中的各类数据都能够实时双向同步。不同数据双向同步的实现原理相近，本文主要以 Elasticsearch（之后简称 ES） 双向同步为例进行介绍。</p><p></p><h2>方案调研</h2><p></p><p></p><p>当前业内实现 ES 数据同步的方案主要有两种：</p><p></p><p>通过 ES 官方提供的铂金会员功能 CCR 进行同步;通过双写的方式确保两个数据中心的数据一致。</p><p></p><p>对于 ES 官方提供的 CCR 能够实现单个索引的单向同步，但不能实现单个索引的双向同步，因为其无法解决数据回环以及数据冲突的问题，并且 CCR 是铂金会员才能享有的，是需要收费的。</p><p></p><p>双写是目前比较通用的数据同步方式，双写可以是业务同步双写，也可以是通过 MQ 实现异步双写。业务同步双写是指业务写 ES 时需要同时往两个 ES 集群写入数据，两者都成功了才算写入成功。这种实现方式对业务的侵入性比较高，而且无法保障数据一致性。通过 MQ 实现异步双写的方式是业务不将数据写入 ES，而是将数据直接写入 MQ，然后由 MQ 消费者实现 ES 数据的写入。这种方案能够保障数据一致性，但是引入了 MQ 增加了系统复杂度，并且数据的延时变高。</p><p></p><p>通过以上分析可以看出常规方案都有明显的缺陷，不能满足预期的能够实现双向同步、业务侵入小且实时性又高的要求。那 ES 是否存在像 MySql 的 binlog 那般通过订阅就能够实时拉取到变更日志，然后在另一边进行回放从而达到数据同步效果的机制呢？</p><p></p><p>这当然也是有的，ES 有 translog 能够记录下变更信息，理论上通过监听消费 translog 的变更就能够实现数据同步。这个方案强依赖于 translog，translog 是会被删除的，如果某些数据还未被同步而 translog 文件已被删除，这就会造成数据丢失，从而导致两个集群数据不一致。在 ES 中，当 flush 操作执行完成之后， translog 就会被直接删除，而这个 flush 操作触发的影响因素较多，是不可控的，这意味着 translog 随时都可能被清除，如果用这种方案两个集群的数据一致性就没法保证，因此 translog 的方案也不太合适。</p><p></p><p>除了 translog，ES 从 6.7 版本开始，还提供了软删除机制（应该说是 Lucene 提供，为便于理解之后统一用 ES 描述）。软删除使得更新和删除操作在 merge 时不会被清除，它支持将 ES 的操作记录日志（operation）按照顺序排放，并以递增的 SeqNo 标记每个操作记录日志所处的位置。另一个集群只要监听并实时拉取该操作记录后再回放就能够实现数据实时同步了，同时通过记录 SeqNo 的点位，确保故障后能够断点续传，避免数据丢失。这些更新和删除操作会占用额外的存储空间，如果都不删除会导致资源浪费。这可以通过软删除 + 租约的方式，实现主动控制历史操作记录存放的时间，保障数据同步的同时也能及时清理已同步的历史记录，避免资源浪费。该方式虽然需要进行较大的源码改造，但是整体效果是能够满足预期的实时性高、业务侵入小并且能够实现双向同步的要求。</p><p></p><h2>方案设计</h2><p></p><p></p><h3>实现思路</h3><p></p><p></p><p>由于在数据双活建设过程中有多种数据类型需要实现双向同步，因此在设计之初就计划实现一个通用的数据传输服务，该服务通过实时拉取源的操作变更记录，然后到目标上进行回放从而实现数据同步，以 ES 数据同步为例，其流程如下图所示。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/0d/0d862c5b6d4e0254f563ab87c4574762.png\" /></p><p></p><p>数据传输服务利用 ES 的软删除 + 租约的机制，定期从源集群中拉取操作变更记录。但 ES 的软删除机制是从 6.7 版本开始提供的，在 ES 6.x 版本软删除是默认关闭的，另外获取操作变更记录的接口在开源版本中也是没有的，这些都需要通过改动 ES 源码进行开放。</p><p></p><p>软删除开启后，每个索引的每个分片的操作变更记录（包含更新和删除）都会被按顺序保存下来，并且通过一个递增的 SeqNo 来标记各个变更记录对应的点位。如下图所示，数据传输服务中任务 1 负责拉取 index1 的 分片 1 数据然后再另一个集群进行回放。当前已经拉取到 SeqNo 为 13 的位置，也就是说数据传输服务上已经有 SeqNo 小于 14 的操作记录，只要将这些数据写到集群 2 进行回放就实现数据同步了。同理再起一个任务负责拉取集群 2 中该分片的操作变更记录，然后同步到集群 1 进行回放，这样就实现了分片的双向同步。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/f3/f3a7ed08accbf223999732c378672f3a.png\" /></p><p></p><h3>整体框架</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/5a/5ae66c03ca81c40c16c71124857c32cf.png\" /></p><p></p><p>上图是数据同步平台的系统框架图，主要分为管控层、通用层、数据仓库层以及存储层。其中管控层和通用层主要是负责配置、监控以及任务调度等。数据仓库层主要负责变更数据的抓取、转换、过滤和写入，也就是 ETL 流程，它整个数据同步的核心流程。数据同步平台的具体实现见下图，从图中可以看出数据同步平台在实现时主要分为两个部分：管控服务以及数据传输服务。管控服务实现管控层和通用层的功能，主要服务对象是管理员，为其提供操作以及查看相关的功能。而数据传输服务实现数据仓库层的功能，负责具体的数据同步操作。</p><p></p><p>前文也提到过不同数据源的同步原理基本都是一样的，都是拉取变更日志然后再另一端回放，只不过是具体的通信协议以及报文格式等有差异而已。所以数据传输服务采用的是微内核 + 插件化的架构，核心流程是共用的，要实现不同数据源的同步只需要实现对应插件即可。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d6/d63b5a25775278227efc3b99054ae396.png\" /></p><p></p><h3>核心设计点</h3><p></p><p></p><h4>数据完整性</h4><p></p><p></p><p>数据完整性主要指在故障恢复后不会丢数据，也不需要重新进行全量同步。这要求在设计过程中要考虑故障后的断点续传功能。ES 的数据同步主要是拉取历史操作记录然后进行回放来实现，历史操作记录是包含 SeqNo 的，这是一个递增的游标。为了保证数据完整性，数据传输服务在回放成功之后会及时将 SeqNo 记录到 MQ 中。当出现故障导致数据传输服务器意外退出时，数据传输服务器在启动后会自动从 MQ 中读取上次记录的最新点位，然后继续往后消费，从而保证故障后数据不丢失。</p><p></p><h4>数据冲突</h4><p></p><p></p><p>在进行双向同步时，由于两边数据源都可能对同一份数据进行改动，如果这个改动在同一时刻发生，就出现数据冲突。这里同一时刻的定义并非要求真正意义上时间点一致，而是指在 A 集群修改数据后在同步到 B 集群之前的这段时间内，B 集群如果也有对这条数据做改动，那么就算同一时刻。</p><p></p><p>数据冲突有可能会导致两边数据不一致，因为在数据冲突的时候，无法确定到底应该以哪条记录为准。目前处理数据数据冲突的方案有以下几种，可以根据场景选择某一种或者组合：</p><p></p><p>增加更新时间，以时间较新的数据覆盖旧数据（与时间字段精度和时间准度有关）；数据增加版本号，新版本覆盖旧版本；选取信任源，在出现冲突的时候，总是以信任源的数据为准；做字段同步而非记录同步，减少冲突发生（需要知道变更的字段）；将冲突的数据记录下来，锁定这条数据不让使用，并告警，需要人为介入。其它数据照常消费。</p><p></p><p>方案 1 中采用的是 Last write wins 的方式，通过这种方式，同一条记录的两个 update 语句不论执行顺序如何变化、不论执行多少次，他们执行后的结果是固定的，这个是满足 CRDT 语义的，能够保障数据最终一致性。但是方案 1 强依赖于更新时间，要求不同机器实例时间一致，并且每个同步的索引都需要具备更新时间字段，要求业务在更新数据时也同步更新该时间字段，这会加大业务的改造工作量。</p><p></p><p>方案 2 也能保障数据最终一致性，它是依赖于版本号，需要业务维护版本号，并且保证在分布式场景下这个版本号是递增的。这样增加了业务改造开发工作量以及增加业务复杂度，代价非常大。而方案 3 到 方案 5 虽然实现上比较简单，但是都有可能造成数据较大面积的错误或者是业务阻塞，数据的一致性无法保证。</p><p></p><p>通过以上方案对比，方案 3 、4、5 存在的问题对业务影响大，不予考虑。方案 1 和 方案 2 都能保证数据最终一致性，但相比于方案 2 ，方案 1 的实现难度更低，所以我们选用的方案 1 来解决数据冲突。针对方案 1 强依赖于更新时间的问题，通过 NTP 可以确保机器实例之间的时间误差在一定精度范围内。另外为了避免业务接入过程都需要改造，更新时间字段通过修改 ES 源码将时间字段内置并且主动更新，且该字段对业务无感，这样既能满足方案要求，也不影响业务。</p><p></p><p>数据回环</p><p></p><p>数据回环是指业务将数据写入到 DB1 之后会产生操作记录日志，数据传输服务通过拉取该操作记录日志将数据同步到 DB2。而数据被写入到 DB2 之后也会产生操作记录日志，该日志同样会被数据通过服务拉取并同步到 DB1，如此就形成回环，如下图所示。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/f0/f0a41bdc558d7c2526f84bea98bf508a.png\" /></p><p></p><p>避免数据回环的方案就是要找到能够打断回环的点。如下图所示（图中 DTS 就是数据传输服务），我们采用的方案是数据传输服务在同步时为每条操作记录日志打上来源标识，数据传输服务在同步数据时通过判断该标识是否与目标数据源一致，如果一致就表示该记录是回环数据，应该直接丢弃，这样就避免回环问题。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/fd/fd16bb5f7c1ec13faf648e0c04d121b2.png\" /></p><p></p><p>由数据回环示意图可以看出这个避免回环的来源标识需要落到 DB2 进行存储，这样数据传输服务才能从操作日志记录中拉取到该标识的信息。对于 ES 而已，这个打标可以考虑在索引的 _source 上增加回环标识字段，这样标识就跟着数据走了。但是删除操作时是没有 _source 字段的，因此删除操作需要独立处理，比如利用 ES 现有的元字段信息进行携带或者直接增加元字段。</p><p></p><h4>一致性校验</h4><p></p><p></p><p>尽管已经有对数据冲突进行处理，最终还是可能出现两个数据源的数据不一致的问题。因此还需要有额外的手段进行数据校验，当发现有数据不一致时，给出告警，然后人为介入处理。常用的数据校验方式可以有以下几种，可根据实际情况选择合适的方式进行实现：</p><p></p><p>全量检测。对于正在运行中的数据库实例，采用如截止到指定时间的所有历史数据对比。这种方式准确性高，但代价大；定期抽样检测。每次定期选取一小段时间同时计算两个数据源的数据量是否一致。这种方式代价小，但准确性不高；指定某个索引或者是指定时间段内的全量数据校验。这种方式准确性较高并且代价也相对较小，属于折中方案。</p><p></p><h2>上线问题与处理</h2><p></p><p></p><h3>ES 源集群 CPU 大幅上升</h3><p></p><p></p><p>ES 数据同步功能上线后，某个业务集群开启数据同步时，发现源集群的 CPU 有大幅提升。下面两张图分别是未开启数据同步的 CPU 使用率，以及开启数据同步的 CPU 使用率， 从图中可以看出 CPU 从 25% 直接被提升到 50%。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/20/20cea89b99ba91fbc12799d18d047460.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/00/00c1719c875e8335c5da5c41a8c47bef.png\" /></p><p></p><p>CPU 升高的主要原因是在每次拉取增量数据时，ES 都要将增量数据打成快照并同步给数据传输服务，这个过程是比较耗 cpu 的，高频度数据拉取会造成源集群 cpu 大幅上升。解决方案是通过限流降低拉取频率，同时增加每次拉取的数据量，虽然延迟上有毫秒级的升高，但 cpu 能够大幅降低，CPU 上升幅度控制在 10% 以内。</p><p></p><h3>大批量更新的场景下会出现更新阻塞</h3><p></p><p></p><p>线上某个业务集群在升级了 ES 版本为自研版本时，部分更新操作出现超时，从 prometheus 指标上看，索引写入时长出现突刺，最高写入延迟达到了 20s，指标如下图所示。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/80/80206c2db597a543e4f93b2e6f27aeb8.png\" /></p><p></p><p>通过查看指标发现该索引的 refresh 时间也出现大幅上升，如下图所示，并且 write 队列堆积比较严重。另外将版本降回开源版本后并继续以此压力写入，不会出现写入延迟问题，所以这个是自研版本中引入的变更引起的。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/8d/8d0c095ca6faf3e17766070a49049755.png\" /></p><p></p><p>当前我们使用的 ES 版本是 6.7，在开源版本中默认是不开启软删除的，而在自研版本中软删除被默认开启。我们怀疑是软删除引起写入延迟，便将自研版本的软删除关闭，发现问题确实就不出现了，表现与开源版本无异。之后在社区中也看到软删除开启后，在高频的 update 场景下会导致 refresh 耗时变长的问题。refresh 慢会导致 indexing buffer 的内存来不及 refresh 到磁盘中，当 indexWriter 大于 index_buffer_size 配置的阈值，Elasticsearch 会降低分片的写入速度。</p><p></p><p>这个问题应该算是 lucene 的 bug，lucene 在 8.5 版本中对其做了优化，并且其后的版本中也在持续优化。在不升级 ES 版本的情况下，通过合并 lucene 的优化改造能够缓解这个问题。</p><p></p><h2>总结与展望</h2><p></p><p></p><p>目前 ES 的双向同步建设已经取得了阶段性的进展，并且在部分业务的双活场景上成功落地。但是当前双向同步还只实现了增量同步，业务接入过程还需要 DBA 配合处理存量数据同步，接入双活的流程不够顺滑。因此接下来首先要实现存量数据同步，此外还会在接入流程以及配套辅助工具的建设上投入较大精力，从而降低业务接入和运维成本，助力朴朴双活建设顺利推进。</p>",
    "publish_time": "2023-09-14 10:47:08",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "平安科技数据智能部负责人及总工程师张茜，确认担任 FCon 金融数据治理专题出品人",
    "url": "https://www.infoq.cn/article/BIYAc62z90RiR7HNk1HI",
    "summary": "<p><a href=\"https://fcon.infoq.cn/2023/shanghai/?utm_source=infoqweb&amp;utm_medium=atricle\">FCon 全球金融科技大会</a>\"，将于 11 月在上海召开。平安科技数据智能部负责人及总工程师张茜将担任「<a href=\"https://fcon.infoq.cn/2023/shanghai/track/1590?utm_source=infoqweb&amp;utm_medium=article\">金融数据治理</a>\"」的专题出品人。在此次专题中，你将了解到数据是企业的战略资产，数据治理能力强弱直接影响数据价值的释放，并学习到金融企业在数据治理方面的实践与经验。</p><p></p><p><a href=\"https://fcon.infoq.cn/2023/shanghai/track/1590?utm_source=infoqweb&amp;utm_medium=article\">张茜</a>\"，平安科技数据智能部负责人及总工程师，毕业于纽约大学，曾任美国高盛集团技术架构部 VP，美国私募对冲基金 Point72 市场数据智能部 VP。拥有近 15 年（包括 8 年海外）金融机构大数据领域的专业技术及团队管理经验，专注于大数据在金融领域的赋能和应用，尤其在企业数字化转型、数据驱动赋能业务增长、另类数据投研挖掘分析、流式计算及湖仓一体平台建设等方面有丰富的经验。</p><p></p><p>在平安科技任职期间，成功通过数据建设驱动和加速平安寿险及平安普惠等专业公司的数字化转型，通过构建统一指标体系、画像标签体系、客群挖掘分析及相关数据产品等，支撑业务的全面数字化经营、管理及运营。任职期间，获得 30 余项专利。</p><p></p><p>相信张茜的到来，可以帮助提升此专题的质量，让你了解到，数据治理是一个涉及企业战略、组织架构、数据标准、管理规范、执行落地、技术工具的综合体，同时也是企业数字化转型成功的前提与基石。</p><p></p><p>除上述专题外，FCon 上海还将围绕&nbsp;<a href=\"https://fcon.infoq.cn/2023/shanghai/track/1580?utm_source=infoqweb&amp;utm_medium=atricle\">DevOps&nbsp;在金融企业落地实践</a>\"、<a href=\"https://fcon.infoq.cn/2023/shanghai/track/1591?utm_source=infoqweb&amp;utm_medium=atricle\">金融行业大模型应用</a>\"、<a href=\"https://fcon.infoq.cn/2023/shanghai/track/1576?utm_source=infoqweb&amp;utm_medium=atricle\">创新的金融科技应用</a>\"、<a href=\"https://fcon.infoq.cn/2023/shanghai/track/1577?utm_source=infoqweb&amp;utm_medium=atricle\">金融实时数据平台建设之路</a>\"、<a href=\"https://fcon.infoq.cn/2023/shanghai/track/1588?utm_source=infoqweb&amp;utm_medium=atricle\">金融安全风险管控</a>\"、<a href=\"https://fcon.infoq.cn/2023/shanghai/track/1589?utm_source=infoqweb&amp;utm_medium=atricle\">数据要素流通与数据合规</a>\"等专题进行交流。</p><p></p><p>FCon 上海 2023，相约 11 月！现在购票，前 100 人可享 5 折特惠购票，咨询购票请联系：17310043226（微信同手机号）。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/a8/a8ec7f7fb25c7949931b2b8a5deffddd.png\" /></p><p></p>",
    "publish_time": "2023-09-14 11:30:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]