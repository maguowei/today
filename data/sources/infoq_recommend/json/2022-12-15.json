[
  {
    "title": "如何升级数字化思维，助力企业组织变革？ Part 3 ：建立组织支撑体系",
    "url": "https://www.infoq.cn/article/TZ1gsdGhkWdaafFOOBWY",
    "summary": "<p>发展数字经济，培育数字人才，『 数字思维 』不可或缺。<br />\n数字思维，不是简单用数字来考虑问题，而是以数字为核心生产要素，以数字经济为引擎，系统性配置资源和重塑价值。对于很多企业来说，激发员工的数字思维是实施数字化转型建设的重要任务。<br />\n那么，对企业管理者而言，如何提升数字认知，强化数字思维，帮助员工理解数字战略，推动企业数字转型落地呢？<br />\n我们将邀请涂益华老师、刘正周老师、李海鸥老师、司巧蕾老师来一起探讨！</p>",
    "publish_time": "2022-12-15 00:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "如何升级数字化思维，助力企业组织变革？ Part 4 ：助力组织变革",
    "url": "https://www.infoq.cn/article/adUOPJKg2P4wHiZKKOIf",
    "summary": "<p>发展数字经济，培育数字人才，『 数字思维 』不可或缺。<br />\n数字思维，不是简单用数字来考虑问题，而是以数字为核心生产要素，以数字经济为引擎，系统性配置资源和重塑价值。对于很多企业来说，激发员工的数字思维是实施数字化转型建设的重要任务。<br />\n那么，对企业管理者而言，如何提升数字认知，强化数字思维，帮助员工理解数字战略，推动企业数字转型落地呢？<br />\n我们将邀请涂益华老师、刘正周老师、李海鸥老师、司巧蕾老师来一起探讨！</p>",
    "publish_time": "2022-12-15 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "亚马逊的分布式计算宣言",
    "url": "https://www.infoq.cn/article/gAm4vluWfAMvwIvIxuEh",
    "summary": "<p></p><p>1998 年的西雅图，亚马逊公司的人已经开始重新审视他们的架构。亚马逊 1997 年的销售额为 1.47 亿美元，到了 1998 年就超过了 6 亿美元，这样的增长速度令他们感到措手不及。1998 年，亚马逊的人写了一份分布式计算宣言，描述了他们看到的问题以及他们为这些问题给出的解决方案。Werner Vogels 最近在他的文章（https://www.allthingsdistributed.com/2022/11/amazon-1998-distributed-computing-manifesto.html ）中公布了这份宣言。</p><p></p><p>这篇文章以时间胶囊的方式概述了亚马逊架构的演变，与今天许多关于系统架构的争论以及几乎所有正在演变中的架构都不可避免会面临的挑战紧密相关。</p><p></p><p>宣言中写道：</p><p></p><p></p><blockquote>业务应用程序直接访问数据库，并了解其中的数据模型。这意味着应用程序和数据模型之间存在非常紧密的耦合，即使功能保持不变，修改了数据模型也必须修改应用程序。</blockquote><p></p><p></p><p>尽管分布式计算宣言是在 1998 年写的，但不管从哪一方面来看，1997 年的亚马逊已经是一个分布式系统了。问题出在接口上——数据存储充当组件和关注点之间的接口，导致存储和业务逻辑之间存在紧密耦合。这种架构很难扩展，问题不在于无法提高每秒处理的请求量，而在于很难跟上新的业务线和整体变化的速度。</p><p></p><p></p><blockquote>由于应用程序对数据元素之间的依赖关系非常敏感，因此这种架构不能很好地扩展，基于数据位置的分布和隔离处理也变得很困难。</blockquote><p></p><p></p><p>他们建议的解决方案是进行服务化。这份宣言起草于“微服务”出现之前，但讨论的也差不多就是微服务——将数据移到封装了业务逻辑的接口后面，减少系统不同部分之间的耦合。</p><p></p><p></p><blockquote>我们建议转向三层架构，其中表示层（客户端）、业务逻辑和数据是分离的。这也被称为基于服务的架构。应用程序（客户端）不能够直接访问数据库，只能通过定义良好的接口来访问数据，这些接口封装了执行对应功能所需的业务逻辑。</blockquote><p></p><p></p><p>对于我来说，宣言中最有趣的部分是对文化需要随架构的变化而变化的描述。只是改改架构图根本不足以达到作者想要的结果。</p><p></p><p></p><blockquote>在转向基于服务的架构时，我们必须注意到几个重要的含义……第二个含义（与第一个相关）是所有软件开发人员都需要进行重大的思维转变。我们当前的思维模式是以数据为中心，在为业务需求建模时，我们总是采用以数据为中心的方法。我们的解决方案通常是修改数据库的表或列，并将数据模型嵌入到应用程序中。基于服务的方法要求我们将解决方案至少分解为两个部分。第一部分是数据元素关系的建模，这跟之前的一样，包括数据模型和服务访问数据需要遵循的业务规则。第二部分是我们以前从未做过的，即设计客户端和服务之间的接口，不向客户端公开或不让客户端依赖底层的数据模型。</blockquote><p></p><p></p><p>这种思维模式的转变——从数据库到 API——是面向服务架构和微服务在过去二十年中崛起的基础。现在，到了 2022 年，随着嵌入式数据库和两层架构重新流行起来，我们看到了以数据为中心的思维在某种程度上与以 API 为中心的思维出现了融合。架构呈现多样性是一件好事，但我们希望新一代两层系统的架构师们能够吸取旧单体系统给我们留下的经验教训。</p><p></p><p>宣言的另一个突破是谈到了工作流在分布式架构中的作用。他们发现，尽管订单流在后端是紧密耦合的，但它们已经是工作流了：</p><p></p><p></p><blockquote>我们已经有了一个“订单管道”，从客户下单到发货，各种业务流程都会操作这个管道。我们的大部分处理过程已经是面向工作流的，尽管工作流“元素”是静态的，并且主要驻留在单个数据库中。</blockquote><p></p><p></p><p>这种架构的伸缩性挑战在于：</p><p></p><p></p><blockquote>……数据库工作流模型不能进行很好的伸缩，因为处理过程是针对一个中心实例进行的。随着工作负载的增加……，中心实例的处理负载量将增加到不可持续的极限。对此的一个解决方案是分发工作流，将其从中心实例中卸载。</blockquote><p></p><p></p><p>解决方案：</p><p></p><p></p><blockquote>不是让处理流程来主动接触数据，而是让数据流经处理流程。</blockquote><p></p><p></p><p>大约十年后，我开始在亚马逊工作，我发现这种思维方式很具有启发性。在加入亚马逊之前，我花了一些时间思考雷达仿真分布模型，这是一个有趣的计算和数据密集型工作流问题。谷歌在 2004 年发布了 MapReduce 白皮书，并已成为具有普适性的以数据为中心的分布式通信模型。我们尝试用 MapReduce 来解决我们的问题，但没有成功。我不禁想，如果我当时看到了亚马逊这篇关于工作流的文章，是否会用这种模式取得更大的成功。</p><p></p><p>这份宣言浓缩了一段迷人的历史，涵盖了亚马逊的技术演变，以及 Web 发展对分布式系统架构的影响。从那以后，行业发生了巨大的变化，亚马逊的技术也有了显著的演变，并为我们留下了宝贵的经验教训。</p><p></p><p>原文链接：</p><p></p><p><a href=\"https://brooker.co.za/blog/2022/11/22/manifesto.html\">https://brooker.co.za/blog/2022/11/22/manifesto.html</a>\"</p><p></p><p>声明：本文为 InfoQ 翻译，未经许可禁止转载。</p><p></p><p>今日好文推荐</p><p></p><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651150314&amp;idx=1&amp;sn=dcb0475994e11726fa30c4e65713dfdd&amp;chksm=bdb8afb98acf26af1b1a4fa6edb22bcb1be8a33bb2fe1a15bdc53960d54953cf51be5ea4aea4&amp;scene=21#wechat_redirect\">写“毁灭人类计划书”、错误太多被Stack Overflow封禁，好玩的 ChatGPT 还不能替代程序员</a>\"</p><p></p><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651150044&amp;idx=1&amp;sn=992f096b51264c6e5aff4731e7b83364&amp;chksm=bdb8ae8f8acf27992741dbca190fae12bd2949043ab450529ef1ef62979f6efd05f28e26b668&amp;scene=21#wechat_redirect\">Vue 3是最佳选择吗? 耗时两周从Vue 2迁移到Svelte后：代码执行更快、体验更佳</a>\"</p><p></p><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651149916&amp;idx=1&amp;sn=36f67698ab2744971f9ec92dedde07b5&amp;chksm=bdb8ae0f8acf2719c3a35b55ea5cfd9f8087ef26c386a50d4c0a1f0a422de6011b96ab12e54f&amp;scene=21#wechat_redirect\">当 Rust 成为“巨坑”：拖慢开发速度、员工被折磨数月信心全无，无奈还得硬着头皮继续</a>\"</p><p></p><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651149915&amp;idx=1&amp;sn=b42a72f3bef2febf9bf7e08b9e168169&amp;chksm=bdb8ae088acf271e5356019d5623f7d343613d47e15ef09c307815f4e0da8de46e193efb816e&amp;scene=21#wechat_redirect\">台积电分红曝光：入职 8 个月狂领 44 个月薪水；Elastic 将裁员 13%，付至少 14 周补偿；马斯克和苹果解除“误会”｜Q 资讯</a>\"</p><p></p><p></p><p></p>",
    "publish_time": "2022-12-15 11:05:50",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "为什么闰秒调整将从2035年开始暂停",
    "url": "https://www.infoq.cn/article/VKxvQh8HQxijF5ZgE3Qm",
    "summary": "<p></p><p>国际计量局（BIPM）于周五在法国凡尔赛召开会议，呼吁暂停“闰秒”，“闰秒”指的是偶尔会在协调世界时（UTC）运行的时钟上增加一段小跳跃，以保持 UTC 与地球自转同步。从 2035 年起，闰秒将被废弃 100 年左右，而且很可能永远也不会回归了。专家解释了暂停“闰秒”原因。</p><p></p><p>国际计量局（BIPM）于周五在法国凡尔赛召开会议，呼吁暂停“闰秒”，“闰秒”指的是偶尔会在协调世界时（UTC）运行的时钟上增加一段小跳跃，以保持 UTC 与地球自转同步。</p><p></p><p>从 2035 年起，闰秒将被废弃 100 年左右，而且很可能永远也不会回归了。随着数字世界的兴起，这个问题变得越来越紧迫和严重，现在是时候确切地解决这个问题了。</p><p></p><p></p><h2>为什么会有闰秒？</h2><p></p><p></p><p>追溯到 1972 年，当时高精度原子钟的出现暴露了这样一个事实，那就是一天的长度并不是 86400 标准秒长（即 24 小时，每小时 3600 秒）。</p><p></p><p>这种差异虽只有几毫秒，但却会不可避免地累积。最终，太阳会在“午夜”时出现在头顶，这是计量学家（研究测量科学的人）决心阻止的一种侮辱。更复杂的是，地球的自转，以及一天的长度，实际上是不稳定且无法提前预测的。</p><p></p><p>最终的解决方案是闰秒：在 12 月底和 / 或 6 月底临时实施 1 秒修正。闰秒是为了确保我们都使用的计时系统，协调世界时（UTC），与地球跟踪替代方案世界时（UT1）的时间差不超过 0.9 秒。</p><p></p><p>但这一切都发生在计算机统治地球之前。闰秒最初被提出时是一种优雅的解决方案，但当涉及到软件实现时，它却变成了恶魔。</p><p></p><p>这是因为闰秒是一种突变，它严重破坏了软件中用来表示时间的关键假设。诸如时间永不重复、静止不动或倒退等基本概念，以及其他古怪的概念，例如每分钟恰好持续 60 秒，都会存在风险。</p><p></p><p></p><h2>跃入险境</h2><p></p><p></p><p>问题：还有什么比混用计算机和闰秒更糟糕的吗？答案：将数十亿台互联的联网计算机混合在一起，所有这些计算机都试图在（理论上）同一时间执行闰秒跳跃，其中许多计算机都会以各种各样的方式失败。</p><p></p><p>情况变得更好了：大多数计算机都在从网络本身了解即将到来的闰秒。更妙的是，几乎所有人都在通过互联网与其他称之为时间服务器的计算机通信，并相信这些计算机提供的计时信息，从而不断地同步他们的内部时钟。</p><p></p><p>想象一下这样的场景：在闰秒狂跳期间，一些时间服务器所在的计算机可能会出错，但依赖于它们的客户端计算机并不知道这一点。或者它们可能是对的，但客户端计算机软件不相信它们。或者，客户端和服务器计算机都会跳跃，但时间略有不同，因此软件会变得混乱。或者，也许一台计算机从未收到跳跃正在发生的消息，什么也不做，最终比世界其他地方领先了一秒。</p><p></p><p>在对 2016 年最后一次闰秒事件的计时数据分析中，我们可以看到所有这些情况以及更多的内容。</p><p></p><p>随着时间的推移，计算机的混乱会影响网络系统的方式不胜枚举，难以描述。已经有记录表明，最近的闰秒事件造成了严重中断和影响。</p><p></p><p>但更广泛地说，考虑一下我们世界所赖以运行的网络化关键基础设施，包括电网、电信系统、金融系统，以及航运和航空中的防撞服务等。其中许多都依赖于毫秒级甚至纳秒级的精确计时。一秒钟的错误可能会产生巨大的甚至致命的影响。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/e9/e9d0d75accac925a8d6392242b013630.png\" /></p><p></p><p>俄罗斯投票反对放弃闰秒的决定，部分原因是这将需要对其全球导航卫星系统 GLONASS 进行重大更新，该系统包含了闰秒。Shutterstock</p><p></p><p></p><h2>时间到了！</h2><p></p><p></p><p>由于认识到以计算机为基础的世界的成本在不断增加，从 2015 年起，取消闰秒的想法就被提上了日程。</p><p></p><p>国际电信联盟（International Telecommunications Union）是管理闰秒的标准机构，几次拒绝了这一决定。但压力在多个方面持续增加，包括来自谷歌和 Meta（前 Facebook）等主要科技公司的压力。</p><p></p><p>参与投票的大多数国际参与者，包括美国、法国和澳大利亚，都支持最近就取消闰秒的决定。</p><p></p><p>凡尔赛宫的决定并不是要放弃让日常计时（UTC）与地球保持一致的想法。这更多是承认当前闰秒系统的弊端太大，而且越来越严重了。我们需要在真正糟糕的事情发生之前阻止它！</p><p></p><p>好消息是，我们有能力等待建议的 100 年左右。在这段时间里，差异可能会增加到一分钟，但如果你考虑到我们每年对夏令时的忍受程度，那就不是什么事了。其逻辑是，通过现在就放弃闰秒，我们可以避免其危险，并留出充足的时间来找出破坏性更小的方法来保持时间一致。</p><p></p><p>我们如何处理这个问题呢?</p><p></p><p>一种极端的方法是完全采用抽象的时间定义，放弃时间与地球运动之间长期存在的联系。另一种方法是进行比一秒钟更大的调整，但频率要低得多，而且要有更好的准备来限制危险，也许是在软件已经发展到了超越缺陷的时代。</p><p></p><p>在确定新方法之前，我们愿意让事情发展到什么程度，有它自己的最后期限：国际计量局（BIPM）的下一次会议定于 2026 年举行。与此同时，在 2035 年之前，我们将一直使用闰秒。</p><p></p><p>由于近几十年来地球自转速度出人意料地开始加快，下一个闰秒可能会首次涉及减少一秒来加快 UTC，而不是增加一秒以减慢 UTC。</p><p></p><p>基于这种场景的软件基本上已经到位，但从未在野外进行过测试，所以请准备好跳入未知。</p><p></p><p>原文链接：</p><p></p><p><a href=\"https://theconversation.com/its-time-out-for-leap-seconds-an-expert-explains-why-the-tiny-clock-adjustments-will-be-paused-from-2035-194922\">https://theconversation.com/its-time-out-for-leap-seconds-an-expert-explains-why-the-tiny-clock-adjustments-will-be-paused-from-2035-194922</a>\"</p><p></p><p>声明：本文为 InfoQ 翻译，未经许可禁止转载。</p><p></p><p>今日好文推荐</p><p></p><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651150314&amp;idx=1&amp;sn=dcb0475994e11726fa30c4e65713dfdd&amp;chksm=bdb8afb98acf26af1b1a4fa6edb22bcb1be8a33bb2fe1a15bdc53960d54953cf51be5ea4aea4&amp;scene=21#wechat_redirect\">写“毁灭人类计划书”、错误太多被Stack Overflow封禁，好玩的 ChatGPT 还不能替代程序员</a>\"</p><p></p><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651150044&amp;idx=1&amp;sn=992f096b51264c6e5aff4731e7b83364&amp;chksm=bdb8ae8f8acf27992741dbca190fae12bd2949043ab450529ef1ef62979f6efd05f28e26b668&amp;scene=21#wechat_redirect\">Vue 3是最佳选择吗? 耗时两周从Vue 2迁移到Svelte后：代码执行更快、体验更佳</a>\"</p><p></p><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651149916&amp;idx=1&amp;sn=36f67698ab2744971f9ec92dedde07b5&amp;chksm=bdb8ae0f8acf2719c3a35b55ea5cfd9f8087ef26c386a50d4c0a1f0a422de6011b96ab12e54f&amp;scene=21#wechat_redirect\">当 Rust 成为“巨坑”：拖慢开发速度、员工被折磨数月信心全无，无奈还得硬着头皮继续</a>\"</p><p></p><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651149915&amp;idx=1&amp;sn=b42a72f3bef2febf9bf7e08b9e168169&amp;chksm=bdb8ae088acf271e5356019d5623f7d343613d47e15ef09c307815f4e0da8de46e193efb816e&amp;scene=21#wechat_redirect\">台积电分红曝光：入职 8 个月狂领 44 个月薪水；Elastic 将裁员 13%，付至少 14 周补偿；马斯克和苹果解除“误会”｜Q 资讯</a>\"</p><p></p><p></p><p></p>",
    "publish_time": "2022-12-15 11:12:05",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "从 Styleguidist 迁移到 Storybook",
    "url": "https://www.infoq.cn/article/SSjTSB0H2NPb02wwOJxz",
    "summary": "<p></p><p>提供一流的开发者体验是 Yelp 基础设施和工程效率团队的核心原则之一。随着开发人员不断创建新的 React 组件，我们的 React 代码库一直在增长，但我们现有的 React Styleguidist（本文简称 Styleguidist）开发环境无法并行扩展。从 Styleguidist 到 Storybook 的过渡让我们能够为 React 组件提供一个更快、更加友好的开发环境，并更好地协调开发人员和设计人员的工作流程。在这篇文章中，我们将深入探讨我们是如何以及为什么要迁移到 Storybook。</p><p></p><h2>现状</h2><p></p><p></p><p>Styleguidist 是一个交互式 React 组件开发环境，开发人员用它来开发和查看用户界面。Styleguidist 还可以用于生成静态文档页面（样式指南），并分享给其他利益相关者。文档是用 Markdown 创建的，带有代码块，这些代码块在一个单独的交互式沙盒中渲染 React 组件。一个简单的例子如下所示：</p><p></p><p><code lang=\"xml\">The `` component is used to arrange multiple `<button>`components side-by-side.\n\n```jsx\nconst Button = require('../Button').default;\n\n    \n    </button><button>    \n    </button><button>    \n    </button></code><button><code lang=\"xml\">\n\n</code><p></p><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/1a/1a6dee41e66f1726b8a577ec20b93c01.png\" /></p><p></p><p>一个Styleguidist沙盒示例</p><p></p><p>在 Yelp，我们在使用 Styleguidist 时遇到了各种各样的问题，这些问题导致 React 开发体验欠佳：</p><p>由于没有得到广泛的 Web 社区的支持，Styleguidist 缺少插件生态系统，因此 Styleguidist 的插件必须自己从头开发。在使用大型包时，Styleguidist 不能很好地伸缩，因为它会为包中的每一个示例渲染一个独立的沙盒，导致初始化加载时间和热加载时间变长。开发人员必须为每个组件创建许多排列，以显示组件可能支持的每一种状态。通过编辑 Markdown 来修改组件状态对于开发人员和非技术用户来说并不直观。</p><p></p><h2>为什么选择 Storybook</h2><p></p><p>Storybook 是一个开源的 UI 开发和文档工具，过去几年在 Web 社区中越来越流行。它拥有强大的社区支持和丰富的插件生态系统，可用于易访问性测试、跨浏览器测试和其他用途。</p><p></p><p>在 Storybook 中，用户可以通过 Story 来逐个浏览和开发组件示例。Story 捕获了 React 组件的渲染状态，就像 Styleguidist 的 Markdown 示例一样。这与性能糟糕的 Styleguidist 形成了对比，Styleguidist 总是会渲染包中的每一个组件的每一个示例。</p><p></p><p>在 Styleguidist 中，开发人员经常需要为组件的每一个可视化排列创建一个示例，从而增加了维护负担（例如，在修改组件 API 后需要更新每一个示例）。在 Storybook 中，开发人员可以通过 react-docgen 自动生成控件，用户可以在文档 UI 中直接修改和预览组件。与 Styleguidist 相比，这进一步简化了用户体验，因为文档用户不再需要通过编辑 Markdown 来修改组件的状态。</p><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/21/21e125cbb622dc0894083591cfe6959e.png\" /></p><p></p><p>一个Styleguidist沙盒示例</p><p></p><p></p><h2>迁&nbsp; &nbsp;移</h2><p></p><p>我们的 React 代码库包含了数千个 Styleguidist 文件，每个文件中都有许多个组件示例。手动迁移它们是不可行的，强制要求开发人员手动用新的 Storybook 格式重写他们的示例也是不合理的。为了保持现有 React 组件示例并减少开发人员在迁移过程中的负担，我们列出了以下这些需求：</p><p></p><p>我们现有的 Styleguidist 文件使用了 ES5 风格的导入和语法。我们希望新的 Storybook 语法与组件源代码保持一致，所以将使用 ES6。应该让使用过 Styleguidist 的开发人员对 Storybook 中的文档也感到熟悉。Storybook 支持 MDX，这是一种结合了 Markdown 和 JSX 的文件格式，可以用 Markdown 为文档页面渲染 React 组件，我们可以将现有的 Styleguidist Markdown 转成 MDX。Styleguidist 中的每一个示例代码块都应该被翻译成一个 Story，组件的 stories.js 文件应该包含所有的示例。</p><p></p><p>为了实现这些目标，我们决定使用 Codemods 将我们的 Styleguidist 文件重构为 Storybook 格式。Codemods 是一系列基于脚本的操作，通过编程的方式对代码库进行转换，在不需要手动介入的情况下进行大规模的自动化修改。</p><p></p><p>首先，我们提取 Styleguidist 代码块，Markdown 文件中的其余内容（例如文字描述）可以直接逐字复制到新的 MDX 文件中。为了实现一对一的迁移，我们将每个代码块视为一个 Story。我们可以利用现有的工具，比如用 remark-code-blocks 来提取 JavaScript 代码块，用 5to6-codemod 将这些代码块中的 ES5 语法转换为 ES6 语法。</p><p></p><p><code lang=\"null\">// 之前的代码:// const Button = require('../Button').default;import Button from '../Button';</code></p><p></p><p></p><p>为了减少开发人员在迁移过程中的负担，我们决定将一个组件的所有 Story 都包含在同一个 component.stories.js 文件中，然后显示在 component.stories.mdx 文档页面中。然后我们发现 MDX 代码块是在相同的上下文中运行的，而且我们关于保持沙盒与 Styleguidist 隔离的假设是不对的。在将多个 Styleguidist 示例转换到同一个文件中时，这个问题尤为严重，因为将多个代码块连接在一起会导致重复导入：</p><p></p><p><code lang=\"jsx\">import Button from '../Button';\nFull width `ButtonGroup` example:\n\n(omitted for brevity)\n</code></p><p></p><p><code lang=\"jsx\">import Button from '../Button'; // &lt;-- 这与上面的导入重复了！\nDisabled `ButtonGroup` example:\n\n(omitted for brevity)\n</code></p><p></p><p>在将上面的 Story 合并到同一个 JS 文件中之后，Button 的导入就重复了。我们的 Codemod 需要解析并对这些导入进行去重，以防止出现运行时错误。另外，我们还需要包含 Styleguidist 隐式导入的组件：</p><p></p><p><code lang=\"null\">// ButtonGroup.stories.jsimport Button from '../Button'; // 去重import { ButtonGroup } from './'; // 显式添加隐式导入的组件\n&nbsp; &nbsp; </code></p></button><code lang=\"null\"><button>&nbsp; &nbsp; </button><button>&nbsp; &nbsp; </button></code><button><code lang=\"null\"></code><p></p><p></p><p></p><p>接下来，我们将提取的 Markdown 代码块、去重的导入语句以及 ES 语法写到 component.stories.js 中，并在 component.stories.mdx 文件中写入标准的 Storybook 模板代码：</p><p></p><p><code lang=\"typescript\">// ButtonGroup.stories.mdx\nimport { ArgsTable, Canvas, Description, Meta, Story } from '@storybook/addon-docs';\nimport * as stories from './ButtonGroup.stories.js';\nimport { ButtonGroup } from './';\n\n\n\nThe `` component is used to arrange multiple `</code></p></button><code lang=\"typescript\"></code><button><code lang=\"typescript\">`\ncomponents side-by-side.\n\n<canvas>\n  \n</canvas>\n</code><p></p><p></p><p>最后，我们需要通过 Storybook 让开发人员知道如何构建组件。我们可以用生产环境现有的 webpack 配置来扩展 Storybook 的构建配置，这样就可以保留 Storybook 的自动 docgen 功能，以及其他一些特性，比如代码块预览。使用现有的 webpack 配置也意味着组件的外观和行为与实际页面中的完全一样。</p><p></p><p></p><h2>结&nbsp; 论</h2><p></p><p></p><p>将 React 组件示例从 Styleguidist 迁移到 Storybook 极大地提升了开发者体验和组件性能。我们能够利用 Storybook 的特性，如按需加载，通过在编译时生成更小的包来提升性能，从而缩短沙盒的启动时间。基于我们的 Codemod 迁移策略，我们能够转换代码库中几乎所有的示例，而且不会出现运行时错误，在迁移过程中也不会对开发人员造成阻碍。</p><p></p><p>切换到 Storybook 为 Yelp 打开了新的大门，我们很高兴能在上面添加插件，进一步提升前端开发人员的工作效率。</p><p></p><p>我们希望我们的分享能够为其他面对类似迁移的团队带来有用的信息！</p><p></p><p>原文链接：</p><p></p><p><a href=\"https://engineeringblog.yelp.com/2022/07/migrating-from-styleguidist-to-storybook.html\">https://engineeringblog.yelp.com/2022/07/migrating-from-styleguidist-to-storybook.html</a>\"</p><p></p><p>声明：本文为 InfoQ 翻译，未经许可禁止转载。</p><p></p><p>今日好文推荐</p><p></p><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651150838&amp;idx=1&amp;sn=4915ac418c5c39ccf153fb9c0273db83&amp;chksm=bdb8a1a58acf28b379c0a19edb84433459b53ee89c11a7570eb21b7c410d1cfd63242ca79e6b&amp;scene=21#wechat_redirect\">重磅！阿里开源自研高性能核心搜索引擎Havenask</a>\"</p><p></p><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651150837&amp;idx=1&amp;sn=c90a5c8c1b69e55feddeb85649bab64f&amp;chksm=bdb8a1a68acf28b01ae97fd7b1ea3ce4420b0daa3835b487b060eca6e4ac8e8f2775465509fd&amp;scene=21#wechat_redirect\">程序员离职后为泄私愤远程锁公司服务器硬盘；前程无忧宣传语嘲讽“996”职场人；Twitter 开源工作停摆｜ Q资讯</a>\"</p><p></p><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651150619&amp;idx=1&amp;sn=ffbfc3cb9c2db61b61fc8602c0e74675&amp;chksm=bdb8a1488acf285efe51cabeb7f3f813d3e3922c725bafda08de24976abe225577e38c4a7fa2&amp;scene=21#wechat_redirect\">再不重视软件开发工具就晚了</a>\"</p><p></p><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651150511&amp;idx=1&amp;sn=882407d9b730ebf9500c929e88cf254e&amp;chksm=bdb8a0fc8acf29eaf997981aa0c3106f7ff08ee4aec0eafbcf658bae227f621e3294d1631886&amp;scene=21#wechat_redirect\">“睡车间”、削减一切，马斯克为SpaceX定制的文化，不能照搬到互联网公司</a>\"</p><p></p><p></p><p></p></button></p>",
    "publish_time": "2022-12-15 11:26:54",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "“病毒式”安全编程语言正在接管科技界",
    "url": "https://www.infoq.cn/article/UTGhRTgdJobd6CyJIqiE",
    "summary": "<p></p><blockquote>Rust使得引入一些最常见的安全漏洞变得不可能， 而且它的采用也越快越好了。</blockquote><p></p><p></p><p>无论你是为一家大型组织运营IT部门，还是仅仅拥有一部智能手机，你都会对由于缺陷和安全漏洞而造成的源源不断的软件更新感到非常熟悉。人们总会犯错，所以代码不可避免地会包含你所犯的错误。但是，越来越多的人开始使用一种叫做Rust的语言来编写软件，因为这种代码在一个重要方面是绝对安全的（goof-proof）。根据设计，开发人员在使用Rust编写代码时，不会意外地创建一些最常见的可利用安全漏洞类型，这一区别可能会对日常补丁队列产生巨大影响，并最终会影响全球的基线网络安全。</p><p>&nbsp;</p><p>编程语言中有流行趋势，新的语言来来去去，往往没有持久的影响。现年已经12岁的Rust花了很长一段时间从Mozilla研究院的辅助项目成长为一个强大的生态系统。与此同时，至今仍被广泛使用的其前身语言C，今年已经50岁了。但因为Rust能生成更安全的代码，而且至关重要的是，它不会因此而降低性能，所以该语言一直在稳步地获得拥护者，现在其正处于一个转折点。自2019年以来，微软、谷歌和亚马逊网络服务公司都在使用Rust，这三家公司于2020年与Mozilla和华为共同成立了非营利组织<a href=\"https://foundation.rust-lang.org/\">Rust基金会</a>\"，以维持和发展该语言。经过几年的紧张工作，Linux内核在上个月迈出了实现<a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=8aebac82933ff1a7c8eede18cab11e1115e2062b\">Rust支持的第一步</a>\"。</p><p>&nbsp;</p><p>“作为一种语言，它正在迅速地传播，”安卓安全与隐私工程副总裁Dave Kleidermacher表示。“我们一直在安卓和整个谷歌上投资Rust，很多工程师都在想，‘我该怎么开始做这个呢？这太棒了。’Rust刚刚作为一种被官方认可和接受的语言首次登陆Linux。所以这不仅仅是安卓；任何基于Linux的系统现在都可以开始整合Rust组件了。”</p><p>&nbsp;</p><p>Rust被称为是一种“内存安全”的语言，因为它的设计目的是使程序不能意外地从计算机内存中提取非预期数据。当程序员使用不具备这一特性的可靠语言（包括C和C++）时，他们必须仔细检查程序将要请求的数据的参数以及如何执行请求任务，即使是最熟练、最有经验的开发人员也会偶尔出错。通过使用Rust编写的新软件，即使是业余的程序员也可以确信他们没有在代码中引入任何的内存安全漏洞。</p><p>&nbsp;</p><p>程序的内存是其所有特性和库所使用的共享资源。想象一个用非内存安全语言编写的日历程序。你打开日历，然后输入一个请求2022年11月2日的日期，程序就会从你计算机分配用于存储该日期数据的内存区域中获取所有信息。一切都顺利。但是，如果该程序设计的约束条件不对，并且你请求2022年11月42日的日期，该软件可能不会产生错误或其他故障，而是会尽职尽责地从存储不同数据的内存中返回信息，可能是你用来保护日历的密码，或者是你为高级日历功能而保存的信用卡号。如果你在11月42日把生日派对添加到了日历中，它可能会覆盖内存中不相关的数据，而不是告诉你它无法完成任务。这些被称为“越界”读写缺陷，你可以看到它们是如何潜在被利用，从而使攻击者能够不适当地访问数据，甚至扩展了系统控制。</p><p>&nbsp;</p><p>另一种常见的内存安全漏洞，被称为“释放后使用”（Use-After-Free，UAF漏洞），它涉及到的情况是，程序放弃了对部分内存的使用权（可能你删除了2022年10月的所有日历条目），但错误地保留了访问权限。如果你稍后请求从10月17日开始的数据，该程序可能能获取到那里的任何数据。此外，代码中内存安全漏洞的存在也带来了这样一种可能性：黑客可能精心设计一个恶意的日历邀请，其中包含精心选择的日期或一组事件的详细信息，目的是操纵内存以允许攻击者远程访问。</p><p>&nbsp;</p><p>这些类型的漏洞不仅仅是深奥的软件缺陷。研究和审计一再发现，它们构成了所有软件漏洞的大部分。因此，尽管在使用Rust编程时仍然会出错并产生安全漏洞，但它能消除内存安全漏洞这一点是至关重要的。</p><p>&nbsp;</p><p>软件供应链安全公司Chainguard的首席执行官Dan Lorenc表示：“在所有报告的发生在操作系统、手机和基础设施等关键应用程序中的漏洞中，内存安全问题占了很大很大的比例”。“在过去的几十年里，人们一直在用非内存安全的语言编写代码，我们一直试图改进和构建更好的工具，并教人们如何避免犯这些错误，但告诉人们更努力的做法实际上是有限度的。因此，你需要一种新技术来消除所有这类漏洞，这就是Rust最终的优势所在。”</p><p>&nbsp;</p><p>Rust并非没有怀疑者和批评者。过去两年，在Linux中实现Rust的努力一直备受争议，部分原因在于添加对任何其他语言的支持天生就增加了复杂性，另外部分原因在于如何具体地使其工作的争论。但支持者强调，Rust具备必要的因素，它不会造成性能损失，而且它可以与其他语言编写的软件进行良好的互操作，这很关键，因为它满足了最迫切的需求。</p><p>&nbsp;</p><p>“与其说这是正确的选择，不如说它已经准备好了，”长期开源贡献者和研究员Lorenc说道。“现在除了什么都不做之外，没有其他真正的选择了，而且这已经不再是一种选择。继续使用非内存安全的代码，再过十年，对科技行业、国家安全乃至一切都将是一个巨大的问题。”</p><p>&nbsp;&nbsp;</p><p>然而，向Rust过渡的最大挑战之一，恰恰是开发人员已经花了几十年的时间用非内存安全的语言编写了重要的代码。用Rust编写新软件并不能解决大量的积压问题。例如，Linux内核实现是从外围开始的，它支持基于Rust的驱动程序，即在操作系统和诸如打印机等硬件之间进行协调的程序。</p><p>&nbsp;</p><p>“当你在做操作系统时，速度和性能始终是首要考虑因素，而你在C++或C中运行的部分通常是由于性能原因而无法在Java或其他内存安全语言中运行的部分。”谷歌的Kleidermacher说。“因此，能够运行Rust，并具有相同的性能，但又能获得内存安全真的很酷。但这是一段旅程。你不可能在一夜之间重写5000万行代码，所以我们会仔细挑选安全关键组件，随着时间的推移，我们将会再改进其他组件。”</p><p>&nbsp;</p><p>Kleidermacher表示，在安卓中，许多加密密钥管理功能现在都是用Rust编写的，私有互联网通信功能DNS over HTTPS、新版本的超宽带芯片堆栈、以及谷歌定制的Tensor G2芯片中所使用的新版<a href=\"https://source.android.com/docs/core/virtualization\">安卓虚拟化框架</a>\"也是用Rust编写的。他补充说，安卓团队正在越来越多地将蓝牙和Wi-Fi等连接堆栈转换为Rust，因为它们是基于复杂的行业标准的，往往会<a href=\"https://www.wired.com/story/bluetooth-complex-security-risk/\">包含很多漏洞</a>\"。简而言之，策略是首先将最暴露的或最重要的软件组件转换为Rust，然后再从那里向内推进工作，从而开始获得增量的安全效益。</p><p>&nbsp;</p><p>“是的，这是一项艰巨的工作，工作量很大，但科技行业有多少万亿美元，还有有多少才华横溢的程序员？我们有资源，”负责内存安全倡议Prossimo以及<a href=\"https://www.wired.com/2016/04/scheme-encrypt-entire-web-actually-working/\">免费证书授权Let‘s Encrypt</a>\"的互联网安全研究小组执行主任Josh Aas说。“仅仅需要大量工作的问题都是很伟大的。”</p><p>&nbsp;</p><p>随着Rust向主流应用的过渡，针对内存安全问题的某种解决方案的案例似乎每天都在不断反复出现。就在本周，如果其机制是用内存安全的语言编写的话，那么无处不在的安全通信库OpenSSL中的一个<a href=\"https://www.openssl.org/blog/blog/2022/11/01/email-address-overflows/\">高危漏洞</a>\"就可以被阻止。与2014年那个臭名昭著的<a href=\"https://www.wired.com/2014/04/heartbleedslesson/\">OpenSSL漏洞Heartbleed</a>\"不同，该漏洞潜伏了两年，并使互联网上的网站遭受了数据拦截攻击，尽管已经在努力减少内存安全漏洞了，但这一新漏洞还是在过去几个月被引入到了OpenSSL中。</p><p>&nbsp;</p><p>“现在有多少人因为内存安全漏洞而生活在身份被盗的噩梦中？或者在国家安全层面上，如果我们担心美国遭受网络攻击，那么有多少威胁是内存安全漏洞造成的？”Aas说。“从我的角度来看，现在整个游戏只是在说服人们投入努力。我们是否足够了解这种威胁，我们是否有意愿。”</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.wired.com/story/rust-secure-programming-language-memory-safe/\">https://www.wired.com/story/rust-secure-programming-language-memory-safe/</a>\"</p>",
    "publish_time": "2022-12-15 11:42:31",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "支撑好分期千万级还款的支付系统",
    "url": "https://www.infoq.cn/article/MptX2P3l5XmfQXjaRHsj",
    "summary": "<p></p><h2>前言</h2><p></p><p>在互联网金融公司开展的业务中，支付系统作为连接金融公司与支付渠道的桥梁，丰富的路由策略支撑、高效的业务处理以及高可用的系统架构都是保证金融公司能为客户提供满意的金融业务的技术保障。</p><p>目前在微财的支付系统中，已成功集成了二十余家支付渠道，共计三十余种支付产品；并且支持多种线上支付方式，充分满足了用户不同的支付需求，丰富了用户的支付体验。</p><p></p><p>然而，面对不同的支付方式以及众多的支付产品，如何在每笔支付请求中快速选取出最优的支付渠道，如何平衡支付成功率和支付渠道成本之间的权重关系，如何保障系统本身的高可用性，如何降低个别渠道异常时造成的支付影响，是支付系统最重要的核心功能。</p><p></p><p>微财的支付系统能迅速结合渠道可用性、回盘时效、渠道费用以及支付成功率等多个维度，并可在个别渠道不可用时自动降低渠道路由权重，为用户选取出合适的支付渠道进行金融业务的支撑。接下来为大家针对支付系统的核心技术进行介绍。</p><p></p><h2>支付系统的特点</h2><p></p><p></p><p>对于当前的支付系统而言，已不再是仅仅满足根据渠道成本、成功率等基本原则来选取最优的支付渠道，而是更多的要综合考虑各个渠道实时的可用性、稳定性以及渠道的自身业务限制，这些场景的兼容能让支付系统为金融业务提供更好的支撑，给用户带来更好的服务体验。</p><p></p><p>微财在金融业务的支付环节中，将异常场景也纳入了支付路由的路由策略中，对日均千万级的还款进行了很好的业务支撑。</p><p></p><p>那我们的支付系统是如何在千万级的交易执行过程中，应对渠道异常、系统压力的呢？接下来我们从几个有代表性的功能进行讲解。</p><p></p><h3>系统高可用性保障</h3><p></p><p></p><p>因支付系统需要和大量的三方支付渠道对接，支付渠道交互过程出现异常是家常便饭，如何能在支付渠道异常的情况下保证用户支付行为尽可能的不受影响，是我们需要考虑的重要场景。在某个支付渠道出现异常的情况时，降级和熔断是我们常用的一种方式，但其对用户的还款体验会有较大的影响，且无法更精准的缩小其影响范围。因此我们根据支付渠道降级的业务策略来调控某一渠道异常后的路由权重，通过滑动窗口算法来统计和监控渠道某个时间段内异常的比例和绝对数量，达到一定阈值后负反馈给支付路由引擎，在其对支付渠道进行筛选和排序时降低异常渠道的权重，进而调节该异常渠道的使用情况。在降低影响的同时又不会因部分的异常全部关停该渠道的请求，从而达到智能调控的目的。</p><p></p><h3>1.&nbsp;精准高效的支付路由</h3><p></p><p></p><p>为了达到选出最优支付渠道以及提高性能的效果，微财支付系统还设计了一套支持多场景下的渠道选取的路由算法。</p><p></p><p>渠道决策树算法是以经典的决策树算法作为核心思想结合以路由策略形成的一种渠道路由排序算法。在微财支付系统中，渠道决策树算法会根据支付方式的不同，收集在当前场景下要进行计算的条件作为节点，构建出一个树模型。然后将备选渠道从根节点进入，经由节点的筛选结果流向不同的分支，最终完成备选渠道的排序过程。</p><p></p><p>我们之所以采用渠道决策树算法对渠道进行排序，是因为其两个优势。其一是节点生成灵活简单，可以根据支付方式的不同定制组合不同的排序条件拼装成一个决策树，并且这种拼装方式是可扩展的，在我们丰富路由策略的时候，可以零代码的方式快捷适配新的策略配置。其二就是高效率的特点，在决策排序过程中，利用其分类和归纳的特点在O（nlogn）的复杂度下快速获得结果。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/c3/42/c3c31dbe8fbf6b995efe87955ab41e42.png\" /></p><p></p><p>渠道决策树算法</p><p></p><p>渠道路由的策略包含人工配置的一些渠道客观条件，例如业务支持银行信息、支付限额等，也有些是系统根据渠道的表现自动做出的权重策略调整，例如渠道异常后的自动负反馈调节策略，以下是详细方案介绍：</p><p>负反馈调节算法主要是监控渠道的健康情况，针对渠道出现异常的情况下，统计异常情况并形成一个指标负反馈给支付路由，达到动态调整渠道权重的目的。其沿用的核心思想来自于Sentinel中的一种限流算法滑动窗口算法，它将时间窗口划分为若干个时间片段，每过一个时间片段时间窗口会向右滑动一格，每个时间片段都有独立的计数器。所以统计整个时间窗口的请求数时只需累加所有的时间片段的数据。时间窗口划分的越细，滑动的就越平滑，统计就会越精确。因此，滑动窗口优点是不存在临界值问题，统计精度高，保证统计区间的连续性，渠道异常时可以快速调节等。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/8b/cf/8b6112e22ace19e4a41919447dd26dcf.png\" /></p><p></p><p>负反馈调节算法</p><p></p><p>举例说明，负反馈调节算法以10秒作为统计的时间窗口大小LeapArray，并配置5个样本数SimpleCount。即对应算法的时间窗口大小为10秒，包含5个时间片段，每个时间片段的大小为2秒，存储的数据记作为指标桶MetricBucket，其结构为支付渠道+结算主体+支付方式维度的响应数量以及响应异常数量。其应用效果要分两个阶段，其一在渠道路由请求时，要根据当前时间按照窗口时长进行分段，拿到当前时间对应的分段ID，并取出对应的窗口返回去给对应的统计逻辑进行阈值判断。另外，我们需要在渠道请求的拦截方法中，在得到请求响应后，使用同样的计算方式得到当前时间窗口及时间片段，并通过业务条件判断对total和error等统计指标进行调整，将数据存入当前时间片段的指标桶。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/cd/bd/cdcda03155cc16605fc2bd9f1a9231bd.png\" /></p><p></p><p>&nbsp;</p><p>其中，在渠道路由阶段得到窗口中的统计数据后需要和我们设定的阈值条件作对比，得出当前渠道的健康权重分数。其中我们从两个维度提供了阈值条件：</p><p></p><p>一种是绝对数量，即在同一时间窗口内若有超过10条（该值可通过配置调整）异常的支付请求，则将异常请求的数量n除以该时间窗口10秒内总订单数量m得到结果y1，乘以其权重基准值10，得到结果10y1。</p><p></p><p>另一种是异常比例，即在同一时间窗口内若有超过10%（该值可通过配置调整）的异常支付请求，则以同样的方式计算出异常订单比例结果为y2，乘以其权重基准值10，得到结果10y2。</p><p></p><p>最后通过公式10-（10n/m）得到最终的系统权值评分，分值越高代表支付渠道的权重越高，排序越靠前。</p><p></p><h3>2.&nbsp;系统自适应压力调节能力</h3><p></p><p>任何系统都有业务处理的瓶颈上限，如果没法进行精准的压力识别，导致任务并发量或者资源占用明显超过服务器的支撑范围，则会直接影响线上服务的稳定。我们在系统实现过程中，搭建了压力检测服务，通过该服务动态识别机器、组件的运行压力，进行反向调节业务请求速率、并发等限制，以此来达到保护生产服务稳定性的目的。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/6f/37/6f45d9db694f464e306d5b8d5f163a37.png\" /></p><p></p><p>&nbsp;</p><p>压力检测技术，支付系统除了自身服务节点以外，还关联了多个组件服务。例如MySQL、RabbitMQ等。那如何让系统能自动感知整个支付流程中某个节点出现了性能瓶颈呢？压力指数便是压力检测服务定义的一个性能指标。它不仅包含系统服务节点的压力指标，也包含了系统依赖的组件的一些核心指标。例如服务节点的JVM内存、CPU消耗，MySQL的连接数、主从同步延迟，RabbitMQ队列积压量等。压力检测服务通过将以上多个维度的指标通过一定的权重比计算出压力指数，再根据全链路压测结果以及故障演练等方式总结出一个适当的阈值梯度。</p><p></p><p>压力检测服务计算出的压力指数达到一定的阈值梯度后，会通知支付系统进行限流处理。同时将该指数上报给系统调用方，达到从源头降低压力的效果。当压力指数一直处于高位并保持一段时间后，会触发系统告警，由人工介入排查压力情况是否正常。</p><p></p><h3>3.组件降级提升系统高可用性</h3><p></p><p></p><p>在支付系统中采用了RabbitMQ作为异步消息组件连通了整个支付流程，我们之所以选用RabbitMQ作为消息组件的原因有以下几点：</p><p></p><p>&nbsp;保障金融系的稳定性，需要防止消息丢失，要支持消息持久化。</p><p>2.&nbsp; 考虑业务的复杂性，需要支持队列的延迟特性。</p><p>3.&nbsp; 结合性能和稳定性的综合考量，以及组件的成熟度。</p><p></p><p>RabbitMQ在支付系统中起到一个总线的作用，既然这么重要，那就要考虑这个组件出现异常情况下的降级措施。</p><p></p><p>MQ是不存储任何数据、没有业务逻辑和复杂性的组件，集成在服务中的主要功能是解耦和削峰。那么替代方案中也需要支持解耦和削峰功能的组件，同时尽量避免增加系统的复杂度。通过多种方案的实践筛选后，我们选取Redis作为降级替代组件，在MQ异常的情况下，舍弃部分ack的机制，用Redis的list结构作为异步队列进行异步生产和消费，zset结构作为延迟队列。支付系统在请求RabbitMQ发送消息多次重试都失败后，会将消息体存入Redis数组中，继续由Redis作为替代队列完成消息的生产与消费。同时，为了保证数据的完整性和一致性，我们还需要做到以下几点来完善Redis在整个流程中的MQ效果：</p><p>MQ异常后的快速感知和切换动态调节Redis生产和消费的速率，防止Redis内存占用过大做好消息的幂等消费</p><p></p><p>目前，支付系统的大部分核心队列以及全部非核心流程队列已经支持MQ的故障切换，异常感知和切换时效达到了3秒以内，为服务的高可用性提供了保障。</p><p></p><h2>应用现状</h2><p></p><p></p><p>当前，微财支付系统已经可以稳定支撑好分期线上每日愈1500万笔的支付请求，划扣请求并发可达2000+。当然，这只是基于当前业务量级的场景下，结合服务资源占用以及性能支撑的考量得出的综合指标。在未来流量激增的情况下，我们可以通过横向扩充节点以及自动压力调节和主动降级等方式将支付处理能力快速提高5-10倍的水平。</p><p></p><p>另外，通过压力检测技术、组件降级等方案，支付系统可以在个别渠道异常或组件异常者的情况下，采用自动降低异常渠道权重，限流降级等方式最大限度降低渠道异常对支付系统及用户还款的影响，全面保障系统的高可用性。截至当前，支付系统的最高可用性已经达到99.9%以上，用户支付成功率提升了30%，渠道异常降级触发达40余次，成功避免了上百万笔还款支付因渠道异常导致的失败，稳定支撑微财数百万用户的千万级线上还款操作。</p><p>&nbsp;</p><p>本文作者：</p><p>张修森，微财数科高级工程师</p><p>赵伟伟，微财数科高级工程师</p><p>周正杭，微财数科资深工程师</p><p>曹倩倩，微财数科工程师</p><p>李军，微财数科技术总监</p><p>吴迪，微财数科产品技术负责人</p><p></p><p></p><p></p>",
    "publish_time": "2022-12-15 11:50:24",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]