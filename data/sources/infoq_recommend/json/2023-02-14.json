[
  {
    "title": "Java近期新闻：Helidon 4.0-Alpha4、Spring、GlassFish、Quarkus、Ktor、（重新）引入 RIFE2",
    "url": "https://www.infoq.cn/article/4ulKLNTV8Og2HZy5eX6Z",
    "summary": "<p></p><h4>JDK 20</h4><p></p><p>JDK20<a href=\"https://jdk.java.net/20/\">早期访问构建版本</a>\"中的第<a href=\"https://github.com/openjdk/jdk/releases/tag/jdk-20%2B34\">34</a>\"版已于上周发布，其中包括对第33版各种<a href=\"https://github.com/openjdk/jdk20/compare/jdk-20%2B33...jdk-20%2B34\">问题</a>\"的修复和<a href=\"https://bugs.openjdk.org/issues/?jql=project%20%3D%20JDK%20AND%20fixversion%20%3D%2020%20and%20%22resolved%20in%20build%22%20%3D%20b34%20order%20by%20component%2C%20subcomponent\">更新</a>\"。有关该版本的更多详细信息，请参阅<a href=\"https://jdk.java.net/20/release-notes\">发布说明</a>\"。</p><p></p><h4>JDK 21</h4><p></p><p>JDK 21<a href=\"https://jdk.java.net/21/\">早期访问构建版本</a>\"的第<a href=\"https://github.com/openjdk/jdk/releases/tag/jdk-21%2B8\">8</a>\"版也已于上周发布，其中包括对第7版各种<a href=\"https://bugs.openjdk.org/issues/?jql=project%20%3D%20JDK%20AND%20fixversion%20%3D%2021%20and%20%22resolved%20in%20build%22%20%3D%20b08%20order%20by%20component%2C%20subcomponent\">问题</a>\"的修复和<a href=\"https://github.com/openjdk/jdk/compare/jdk-21%2B7...jdk-21%2B8\">更新</a>\"。有关该版本的更多详细信息，请参阅<a href=\"https://jdk.java.net/21/release-notes\">发布说明</a>\"。</p><p>&nbsp;</p><p>对于<a href=\"https://openjdk.java.net/projects/jdk/20/\">JDK 20</a>\"&nbsp;和<a href=\"https://openjdk.java.net/projects/jdk/21/\">JDK 21</a>\"，均鼓励开发人员通过<a href=\"https://bugreport.java.com/bugreport/\">Java缺陷数据库</a>\"报告缺陷。</p><p></p><h4>Spring Framework</h4><p></p><p><a href=\"https://spring.io/tools\">Spring Tools</a>\" 4.17.2的发布提供了缺陷修复和改进，例如：来自OpenRewrite Java Parser中的 NullPointerException ；使用最新版本的ANTLR运行时更新生成的Java属性解析器；提供了有关“Java源代码协调”定义的更多信息，并且执行Spring Boot 3.0的升级配方会抛出异常。有关该版本的更多详细信息，请参阅<a href=\"https://github.com/spring-projects/sts4/wiki/Changelog#2023-02-01-4172-release-incl-language-servers-version-1440\">发布说明</a>\"。</p><p></p><h4>GlassFish</h4><p></p><p>Eclipse基金会<a href=\"https://github.com/eclipse-ee4j/glassfish/releases/tag/7.0.1\">发布</a>\"了GlassFish 7.0.1，其特性包括：依赖升级；对某些装载器机制进行了大修，以加快操作速度；以及更可靠的服务器关闭监控。GlassFish 7与最低版本为JDK 11的Jakarta EE 10兼容。然而，它可以在JDK11到JDK19上编译和运行，并在JDK20早期访问构建版本的<a href=\"https://github.com/openjdk/jdk/releases/tag/jdk-20%2B30\">第30版</a>\"上成功地进行了初始测试。</p><p></p><h4>Quarkus</h4><p></p><p>在Quarkus 2.16.0发布不到一周后，Quarkus 2.16.1.Final也<a href=\"https://quarkus.io/blog/quarkus-2-16-0-final-released/\">发布</a>\"了，这是一个面向Java社区的<a href=\"https://quarkus.io/blog/quarkus-2-16-1-final-released/\">维护版本</a>\"。该版本附带了缺陷修复、文档改进和依赖升级。Micrometer度量格式已经迁移到Prometheus。有关该版本的更多详细信息，请参阅<a href=\"https://github.com/quarkusio/quarkus/releases/tag/2.16.1.Final\">变更日志</a>\"。</p><p></p><h4>Helidon</h4><p></p><p>甲骨文（Oracle）<a href=\"https://medium.com/helidon/helidon-4-0-0-alpha4-release-d113a9079a97\">发布</a>\"了Helidon 4.0.0-ALPHA4，该版本支持Helidon Níma上的Helidon MP，这是一个基于虚拟线程的微服务框架，并提供了对基于MicroProfile 5.0的应用程序在虚拟线程上运行的全面支持。其他值得注意的变更包括：更有效的Web服务器关闭策略；弃用MicroProfile跟踪规范；以及对Helidon构建器的改进。有关该版本的更多详细信息，请参阅<a href=\"https://github.com/helidon-io/helidon/releases/tag/4.0.0-ALPHA4\">发布说明</a>\"。</p><p></p><h4>Hibernate</h4><p></p><p><a href=\"https://hibernate.org/search/\">Hibernate Search</a>\"的6.1.8.Final和 5.11.12.Final版本已于<a href=\"https://in.relation.to/2023/01/31/hibernate-search-6-1-8-and-5-11-12/\">上周发布</a>\"。</p><p>&nbsp;</p><p>6.1.8版本的特性包括：当修改带有 @OneToOne(mappedBy = ...) @IndexedEmbedded 注解的属性时，将不再跳过自动重建索引；定期测试Hibernate Search 6.1与Hibernate ORM 6.2的兼容性；以及对Hibernate ORM 5.6.12.Final和Jackson 2.13.4的依赖升级。</p><p>&nbsp;</p><p>5.11.12版本的特性是更新/删除一个租户中的实体时，将不再从其他租户的索引中删除具有相同ID的实体。</p><p></p><h4>PrimeFaces</h4><p></p><p>PrimeFaces 12.0.3和11.0.10也已<a href=\"https://www.primefaces.org/primefaces-11-0-10-and-12-0-3-released/\">发布</a>\"，提供了如下的修复： 在JpaLazyDataModel 类中实现了filterMatchMode 属性的 between 和 notBetween 值；违反开放Web应用程序安全项目（OWASP）规则<a href=\"https://github.com/SpiderLabs/owasp-modsecurity-crs/blob/v3.0/master/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf#L133\">941130</a>\"的cookie名称； JpaLazyDataModel 类中定义的 convertToType() 方法抛出 java.util.Date 的 FacesException ；有关这些版本的更多详细信息，请参阅<a href=\"https://github.com/primefaces/primefaces/issues?q=is%3Aissue+label%3A12.0.3+is%3Aclosed\">12.0.3</a>\"版和<a href=\"https://github.com/primefaces/primefaces/issues?q=is%3Aissue+is%3Aclosed+label%3A11.0.10\">11.0.10</a>\"版的问题列表。</p><p></p><h4>阿帕奇软件基金会</h4><p></p><p>Apache Commons CSV 1.10.0已经<a href=\"https://www.mail-archive.com/announce@apache.org/msg07932.html\">发布</a>\"，并进行了显著的更改，例如： CSVRecord 类中定义的 get(Enum) 方法应该使用 name() 方法，而不是 Enum 类中的 toString() 方法； CSVRecord 类中定义的 toList() 方法不提供对新建 List 的写访问；并在 CSVParser 类中标识null、empty和blank头名称中的重复项。有关该版本的更多详细信息，请参阅<a href=\"https://commons.apache.org/proper/commons-csv/changes-report.html#a1.10.0\">发布说明</a>\"。</p><p></p><h4>JHipster</h4><p></p><p>JHipster Lite 0.27.0已经<a href=\"https://github.com/jhipster/jhipster-lite/releases/tag/v0.27.0\">发布</a>\"，其特性包括：引导程序（bootstrapping）的重构；支持Apache Cassandra；Angular前端中定义的一个新的 inject() 函数和自动关闭组件标签；以及一些依赖的升级，其中最值得注意的Angular 15.1.3。</p><p>&nbsp;</p><p>JHipster团队已经完成了向<a href=\"https://spring.io/projects/spring-security\">Spring Security</a>\"&nbsp;6.0的 HttpSecurity 类中定义的 authorizeHttpRequests() 方法的<a href=\"https://twitter.com/mraible/status/1621220421424058368?cxt=HHwWgMC4mcfY3f8sAAAA\">迁移</a>\"，该方法从默认允许行为迁移到默认拒绝行为，以提高安全性。</p><p></p><h4>JetBrains</h4><p></p><p>JetBrains<a href=\"https://twitter.com/JetBrainsKtor/status/1620749039376695296?cxt=HHwWgIDUocGqh_4sAAAA\">发布</a>\"了<a href=\"https://ktor.io/\">Ktor</a>\"的2.2.3版本，这是一个用于创建微服务和Web应用程序的异步框架，其中包括如下的改进：当请求路径较长时， FileStorage 函数会抛出 FileNotFoundException ； HttpRequestRetry 对 FileStorage 引发的 FileNotFoundException 进行重试；而多部分 File 不会上载整个文件，并为较大的文件抛出一个“非预期EOF：超出预期4096字节”异常。有关该版本的更多详细信息，请参阅<a href=\"https://ktor.io/changelog/2.2/#version-2-2-3\">最新动态页面</a>\"。</p><p></p><h4>RIFE2</h4><p></p><p>Moog Music的软件工程和产品经理<a href=\"https://www.linkedin.com/in/gbevin/\">Geert Bevin</a>\"对其原始的RIFE框架<a href=\"https://github.com/gbevin/rife2/releases/tag/1.0.0\">进行了修改和重新引入</a>\"，RIFE框架从2000年到2010年一直处于活动状态，新框架采用了<a href=\"https://rife2.com/\">RIFE2</a>\"的1.0.0版本，这是一个全栈框架，可以用现代Java创建Web应用程序。1.0.0版是最初的稳定版本，其特性包括：对continuations工作流引擎的重新设计和重做；内部并发修复和改进；安全检查，以禁止部署后的路由更改；以及一个新的 MemoryResources 类，它为存储在内存中的资源提供了 ResourceFinder 和 ResourceWriter 接口实现的功能。InfoQ将持续跟进更详细的新闻报道。</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/02/java-news-roundup-jan30-2023/\">https://www.infoq.com/news/2023/02/java-news-roundup-jan30-2023/</a>\"</p>",
    "publish_time": "2023-02-14 10:08:25",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "从 polyrepo 到 monorepo，前端代码仓库改造工程实践",
    "url": "https://www.infoq.cn/article/2WWCPO7WPm0607FLZgav",
    "summary": "<p></p><h2>引言</h2><p></p><p></p><p>随着业务的发展和架构的迭代升级，近一年 FreeWheel 核心业务团队对前端技术栈进行了大规模升级改造，针对多个新业务页面的开发需求，对产品按照业务模块进行了划分，形成了多团队协作开发的 polyrepo 模式。而对于团队之间的组件或模块的共享问题，结合社区的实践和公司内部尝试的经验，我们决定采用 monorepo 模式来满足共享需求，并对将代码仓库改造成 monorepo 进行了技术尝试和落地，下面是具体介绍。</p><p></p><p></p><h2>monorepo 与 polyrepo 对比</h2><p></p><p></p><p>monorepo 和 polyrepo 是两种代码仓库的组织形式。monorepo 是指包含多个不同项目的单一代码仓库，并且内部子项目具有明确定义的关系（如下图）。对，它不只是简单的把多个代码仓库放到一个代码仓库下，而是要去明确的定义这些代码仓库之间的关系。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/76/7628c160109e649dfa4be95403f08739.png\" /></p><p></p><p>而 polyrepo 是指每个应用或库分别拥有各自的代码仓库，不会和其他代码仓库合并（如下图）。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/e5/e594a3f7c6b1ed7e522ac9286c1f3c78.png\" /></p><p></p><p>以下是二者的对比，可以看出，结合二者的特点既可以避免重复的配置，又能够灵活根据团队情况合理控制仓库的数量和大小，并且在 monorepo 模式下，可以结合发包功能来解决多团队之间的共享问题。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/ac/ac5aa1291db5ad84d0045f59476f49fa.png\" /></p><p></p><h2>开发现状</h2><p></p><p></p><p>目前 FreeWheel 核心业务团队就是以 polyrepo 的架构进行多团队迭代开发，整个产品按照功能模块和团队情况进行了拆分，各个页面独立开发独立部署。在 polyrepo 架构下，每个代码仓库内部的共享问题很容易解决，把需要共享的组件或功能提取到合适的文件里再导出即可。但对于不同代码仓库之间的共享问题就不是很容易解决了。对于底层的结构组件，FreeWheel 有一套自建的基础组件库供业务组开发人员使用。但是对于含有业务逻辑的上层组件，目前没有一个灵活统一的方案来满足这一需求。</p><p></p><p>在实践之前，我们明确了实践过程中可能会遇到的问题。</p><p></p><p>第一，已有代码仓库的 monorepo 转化成本问题。其需要对项目结构进行改造，包括但不限于 NodeJS，Yarn 的版本，插件安装配置，项目和各个包的 package.json 和 tsconfig.json，lint 和 format 的配置。这对于中小厂公司或者中小团队来说是不小的开销。如果各自为政，重复造轮子，则是一种低 ROI 的行为。</p><p></p><p>第二，维护多包依赖关系成本问题。当一个 monorepo 里拥有多个包（可发布的子仓库）时，手动维护它们之间的依赖关系是很耗费精力的。如下图的例子所示，这是一个 monorepo 内部的依赖关系图。当 E 包升级发布新版后，由于上层的 C 包和 F 包依赖 E 包，所以 C 包和 F 包需要跟着升级。那么依赖 C 包和 F 包的上上层包，也需要升级。这样递归下去，直到依赖链路上的包都升级完成。显然靠人工来完成升级是件费时费力且易出错的事情。</p><p></p><p>因此，带着这两个问题，我们在接下来的技术选型和实践过程中有倾向性的进行了取舍。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/a5/a5aa19a867a80a61de52f70e8dfaab4b.png\" /></p><p></p><h2>技术选型</h2><p></p><p></p><p>基于以上阐述，我们近期对此上述需求和问题进行了技术调研和实践，尝试在 polyrepo 的基础上，对每个代码仓库进行 monorepo 转化，使每个仓库可以按需拥有多个子仓库，并且拥有发布 npm 包的能力。这样在不破坏现有产品架构的前提下，解决了团队之间代码共享的问题。这里说明一点，本次实践基于的前端项目使用的是 Yarn 3+ 版本，Node.js 16+ 版本，TypeScript 4.8 版本及以上。</p><p></p><p>其实在此之前，公司内部已经进行过一些尝试。我们创建了一个 monorepo，可共享的组件或功能都放在这个 monorepo 里进行统一发布和维护。随着使用发现，开发共享组件需要频繁切换仓库，跨仓库的本地调试不是很方便。并且，组件都放在一个 monorepo 里，对于组件所属哪个团队变得模糊。我们设想，如果在各自团队的代码仓库下也能发布需要共享的组件，这样所属明确，与这个统一的 monorepo 结合使用，也更加灵活方便。</p><p></p><p>因此，我们尝试给各个团队自己的仓库进行 monorepo 转化。目前社区内的 monorepo 工具还是比较丰富的。我们着重调研了以下几个工具。从稳定性、上手成本、功能，需求匹配度及收费情况等方面考虑进行技术选型，最终决定采用 Yarn workspace 来作为前端 monorepo 的管理方案。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/f3/f370d60677829f81133a9cc92118e713.jpeg\" /></p><p></p><p>这里简单介绍一下。在 Yarn 的生态下，Yarn workspace 是 yarn 官方提供的一个 monorepo 管理方案。根据项目中包之间的关系进行链接，避免多个包之间相同依赖的重复安装，以节省空间。同时共享一个 lock 文件，统一各个包依赖的版本。</p><p></p><p>它的使用比较简单，在 package.json 中加入如下设置就可以声明一个 workspace，workspace 内的每一个 folder 都是单独的包，或称为子仓库。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/71/718c948953c028bccf940727ee9b81f4.png\" /></p><p></p><p>同时 Yarn workspace 提供了 workspace 协议，用于在 package.json 声明依赖时实时访问最新代码，有效避免了 yarn link 产生的系统环境污染，示例如下：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/c9/c984acc01be3eab2e752801932bfead3.png\" /></p><p></p><p>针对维护多包依赖问题，Yarn 社区也提供了解决方案——Yarn version plugin。与社区中针对此问题的其他工具（比如 changesets）类似，它可以自动化的管理各个包的升级过程。该插件通过 Yarn git 等一系列内置插件，根据语义化版本的规则，提供了实用的 CLI 命令，比如 yarn version patch，给包升级 patch 版本，后边可以使用 --deferred 并结合 yarn workspace 来实现多包批量升级等等。</p><p></p><p>下面具体阐述我们的实践过程。</p><p></p><h2>monorepo 工程实践</h2><p></p><p></p><h3>实现一键转换与更新的 CLI 命令</h3><p></p><p></p><p>首先，我们针对上文提到的 monorepo 转化成本问题，实现了一个自动化转化 monorepo 的 CLI 工具。其自动化改造的主要过程如下图所示：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/5d/5dcba8f0c084c84827b1423d620625cf.png\" /></p><p></p><p>脚本首先会生成 workspace 由 yarn workspace 来管理。然后为项目更新配置，下载所需插件等，比如下面的自动升级 yarn 及其配置。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/ae/aeb74571e48d7802478faef55573a559.png\" /></p><p></p><p>安装 yarn workspace-tools 和 yarn version 插件。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/7b/7bcf9450c71838c1d097a8a41a53ee8e.png\" /></p><p></p><p>更新项目 package.json。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/f4/f4993bc6360c0979e554efc315cda3f1.png\" /></p><p></p><p>修改 tsconfig.json，方便 packages 里的包配置可以用 extend 方式快速的继承。还可以根据需要修改 eslint，prettier 以及.gitignore 等配置文件。</p><p></p><p>接下来会生成用于快速创建，升级，构建，发布包的各个脚本，并与 husky 集成，后面会做详细阐述。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/13/139f2898f5c8139e388a38a0dc1ab50c.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/6f/6fddfad724f34ce10f79c1848b9e0434.png\" /></p><p></p><p>最后调用生成的脚本自动创建一个 hello-world 包并构建发布，用户可以通过 npx -y 命令快速运行 hello-world 包，来检查项目是否已经改造完成。</p><p></p><p>基于此工具，通过运行下面的一行命令，已有项目仅需几分钟就可以自动地完成改造，转变成开箱即用的 monorepo 项目。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/01/013ab849433042b39b7d849afd1c977c.png\" /></p><p></p><p>此外，为了优化用户体验的，此工具添加了一些常用的参数和命令。-h 用于打印帮助信息，方便用户快速查看可用参数和命令。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/da/da824bceddeb1cb5b8cab08d57209bc2.png\" /></p><p></p><p>-v 用于打印版本。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/4f/4f2872431ce13951f25ab1c74dff3bde.png\" /></p><p></p><p>-c 用于查看功能迭代历史。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/7a/7a958d6c5ac0ae434b125d028dd1ad89.png\" /></p><p></p><p>update 交互式快速更新所需配置以及 update:all 一键更新所有配置。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/4d/4daccc4d691fc7563cb2fa77ce3d66d9.png\" /></p><p></p><h3>实现自动化升级多包依赖的脚本</h3><p></p><p></p><p>下面就来具体看看该工具生成的自动化脚本，主要使用了 yarn workspace，yarn version 插件以及 zx 库。</p><p></p><p></p><h4>pre-push 脚本</h4><p></p><p></p><p>首先，我们基于 husky 拦截了 git push，在 push 之前进行多包升级的检查以及自动更新版本并提交。具体流程可见下图。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/53/53f8ab216ff8eb0108f72ed699f18fc9.png\" /></p><p></p><p>下面来说一下细节。命令首先会执行 git fetch 来更新本地的分支，已获得最新的远端 commit 用于 yarn version 的比较。待使用者选择了具体的提交分支后，脚本会自动通过设置 changesetBaseRefs 来给 yarn version 提供待对比的 commit。接着执行 yarn version 提供的 check 功能，自动的递归检查所有待升级包及其依赖包是否已经设置了升级策略或当前版本是否已存在。如果检查失败，使用者可以利用其提供的交互式命令方便的对各个包的升级策略进行设置，此处的升级策略遵循的就是我们常见的语义化版本规范。设置完成后会生成一个 yml 文件，例子如下。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/f7/f7f1286bca1451548da478cc40846d6f.png\" /></p><p></p><p>接下来脚本会再次验证升级策略是否设置完全，在检查无误后，会执行 yarn version 的消费功能完成特定包 package.json 文件 version 字段的修改，这里的消费指的是消费刚才生成的那个 yml 文件，消费完即删除。所以，该流程不会在 commit 里增添无关的文件改动。结合 FreeWheel 的分支管理策略，在消费阶段，脚本会根据在开始阶段使用者选择的分支来判断是否给包版本打 tag，用以区别是线上紧急修复问题的发版（1.0.5-V1.1）还是平时主分支的发版（1.0.5）。最后，脚本在检查完所有待升级包的新版本无误后，会自动生成一次 commit 并完成 git push。</p><p></p><p>整个过程对使用者来说几乎是自动的和透明的。一旦检查有问题，脚本会返回明确的错误信息和解决办法，无需担心有过多的心智负担。</p><p></p><h4>创建新包脚本</h4><p></p><p></p><p>为了方便开发者快速创建新包，我们也提供了相应的自动化脚本，流程如下图所示。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/59/599d267bcd17d2a451c7bca13445fa23.png\" /></p><p></p><p>命令会检查包名的合理性，检查无误后会在新包的路径下自动创建其所需要的 package.json，tsconfig.json，.npmignore，index.ts，以及组件 app.tsx 等文件。该脚本提供了快速集成单元测试的功能，也会自动创建单元测试所需要的项目配置文件，项目依赖，以及组件的测试用例。目前支持 vitest 单元测试和 react 组件，测试用例包括一个 hook (useState) 以及一个鼠标点击事件，代码如下。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/e6/e6f31bfbe1a859ed81f0bceb0e739c4f.png\" /></p><p></p><p>这样一个带有组件测试用例的可构建发布的包就创建完成了，开发者可以在此基础上自行添加业务逻辑和测试用例，省去了创建新包需要做的一些额外的的配置工作。</p><p></p><h4>交互式更新包脚本</h4><p></p><p></p><p>除了创建新包，工具还提供了手动更新包版本的自动化脚本，流程如下图所示。和 pre-push 的功能一样，命令会去检查多包之间依赖关系，确保需要升级的包都设置了对应的策略，避免漏升。该命令可以方便的修改多包版本，结合 pre-push 脚本使用效率更佳。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/4e/4efad1a21f4cff597f93a75e3cc972cc.png\" /></p><p></p><h4>手动构建发包脚本</h4><p></p><p></p><p>此外，该工具也提供了用于构建和发布包的自动化脚本，流程如下图所示。脚本接收待发布的包名作为参数（可以多个），通过 yarn workspaces 的过滤功能进行遍历，构建和发布，最终结果会打印到终端。该功能可用于需要快速发布一些测试包来进行调试的场景，也可以结合上面更新包的脚本来快速发布线上包。使用者可以自由组合，灵活完成各自的发包需求。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/6d/6d803684633ce286abec849646a814a8.png\" /></p><p></p><h4>集成于 Jenkins 及 Slack 的统一发包 CI Job</h4><p></p><p></p><p>基于 FreeWheel CICD 团队为开发人员提供的一套持续集成持续部署流水线工具，开发人员可以方便的通过简单的配置，自由创建流水线完成各自项目的自动化任务。本次实践也提供了 CI 支持，将构建发包的工作集成到了 Jenkins 流水线，团队在 review &amp; merge 相应代码到指定分支后，流水线会自动触发，在任务里判断是否有需要发布的新包，来自动完成各个包的安装，测试，构建以及发布。同时流水线将结果集成到了指定的 Slack Channel，第一时间通知开发人员发包的结果，实现端到端的自动化。发包的端到端流程图下：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/e1/e148c062f3e867d86e0aa157dacfc20b.png\" /></p><p></p><p>Slack 的通知结果分为 lint，build 以及 publish 三类，方便开发者区分具体的失败原因。如果是 lint 或 build 失败，那很有可能是代码有 bug，需要修复问题并重新 review。如果是 publish 失败，那有可能是版本号已经存在，只需用上述提到的快捷命令更新具体失败的包并再次提交即可。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/6d/6dd60a898a7f2daa3f6d45a4611db8f1.png\" /></p><p></p><p>至此，改造 monorepo 进行升级发包的端到端流程就完成了。</p><p></p><h2>总结</h2><p></p><p></p><p>以上就是本次实践的全部内容，我们在原有 polyrepo 的基础上，对已有代码仓库的 monorepo 转化进行了实践，概括起来实现了以下功能：</p><p></p><p>一键快速（几分钟）改造代码仓库为 monorepo 的 CLI增强 pre-push，自动对项目下的包进行检查和升级生成创建，升级，发布等对包的快捷命令和脚本集成 Jenkins 流水线，自动发布新包并通知开发人员撰写工具帮助文档和在线手册</p><p></p><p>目前我们已经在四个应用级代码仓库实践了 monorepo 方案，发布公共组件数十个。下一阶段我们会持续优化用户体验，比如对自动生成单元测试做进一步完善，对创建新包做更细致的校验，尝试搭建已发布组件的文档系统等。随着使用的团队越来越多，会提供更多实用的功能。</p><p></p><h4>作者介绍</h4><p></p><p></p><p>荣剑英，FreeWheel 高级开发工程师，毕业于天津大学，对前端框架开发，前端工程化等领域感兴趣，热衷新技术的探索与实践。</p>",
    "publish_time": "2023-02-14 10:17:10",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "微软称ChatGPT版Bing将登陆Android和iOS平台，Bing App下载量一夜间猛增10倍",
    "url": "https://www.infoq.cn/article/wyWO1PjbmyLpBMQxVOxy",
    "summary": "<p>2月14日，据 Windows Latest报道，微软在发送给早期使用者的电子邮件表示，目前已正在积极准备ChatGPT版Bing的“移动体验”。也有消息人士表示，目前微软正在优化 <a href=\"https://www.infoq.cn/article/N2DHuiaEtcIEeXvjbVLC\">ChatGPT Bing</a>\" 移动端的页面，预计可能会在未来几周登陆 Android 和 iOS平台。</p><p></p><p>虽然细节不多，但消息人士证实，<a href=\"https://www.infoq.cn/article/9wzrGiMTl8XClRgSfL9A\">微软</a>\"正在为Android和iOS的Bing人工智能聊天功能开发一个\"实质性的优化界面\"，其中包括\"全新的OpenAI驱动的内容\"。不过在发给包括Windows最新版本在内的测试人员的电子邮件中，微软表示移动体验还没有准备好。</p><p></p><p>有趣的是，在微软透露出该消息之前，<a href=\"https://www.infoq.cn/article/FB6BxlokIrMQgNLl3Vzt\">Google</a>\"也宣布了移动版的Brad，并且正计划在本月某个时候为特定用户推出Brad。</p><p></p><p>事实上，微软已经于本周一开始，陆续向申请用户开放新版必应。但略显尴尬的是，嵌入ChatGPT的微软新版Bing将Chrome等浏览器直接拒之门外。因此用户想要申请试用新版Bing，就不得不从Chrome转投到<a href=\"https://www.infoq.cn/article/XTw4I4heyyHZSWHNoh7E\">Edge</a>\"的怀抱，这也使得微软Edge浏览器的下载需求量陡然大增。</p><p></p><p>据第三方数据公司data.ai上一周的分析显示，新版Bing应用程序的全球下载量在一夜之间猛增10倍。这使得该应用蹿升到了苹果App Store应用商店最受欢迎的免费应用榜中的第十位，并使其成为第二大最受欢迎的免费生产力应用，仅次于谷歌邮箱Gmail。微软iOS版Edge浏览器也位居实用类应用程序中的第三名。</p>",
    "publish_time": "2023-02-14 10:29:35",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "改变一个字符后，我的 Go 程序快了 42%",
    "url": "https://www.infoq.cn/article/wYFJDJqDhmQ6BCI9JygI",
    "summary": "<p></p><blockquote>我要先声明通常的基准测试警告：42% 的加速是在我的计算机上运行程序的数据时测量的，所以大家对这个数字请持保留态度。</blockquote><p></p><p></p><h3>这个Go 程序是做什么的？</h3><p></p><p></p><p>c<a href=\"https://github.com/hmarr/codeowners\">odeowners</a>\" 是一个 Go 程序，它根据 <a href=\"https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners#codeowners-syntax\">GitHub CODEOWNERS</a>\" 文件中定义的一系列规则，打印出存储库中每个文件的所有者。可能有这样的规则：所有以 .go 结尾的文件都归 @gophers 团队所有，或者 docs/ 目录下的所有文件都归 @docs 团队所有。</p><p></p><p>当考虑一个给定的路径时，最后匹配的规则获胜。一个简单但天真的匹配算法会向后迭代每条路径的规则，当找到匹配时就会停止。智能算法确实存在，但那是以后的事了。Ruleset.Match 函数如下所示：</p><p></p><p><code lang=\"null\">type Ruleset []Rule\n\n\nfunc (r Ruleset) Match(path string) (*Rule, error) {\n  for i := len(r) - 1; i &gt;= 0; i-- {\n    rule := r[i]\n    match, err := rule.Match(path)\n    if match || err != nil {\n      return &amp;rule, err\n    }\n  }\n  return nil, nil\n}</code></p><p></p><p></p><h3>用 pprof 和 flamegraph 查找“slow bits”</h3><p></p><p></p><p>当在一个中等规模的存储库中运行该工具时，它的运行速度有点慢：</p><p><code lang=\"null\">$ hyperfine codeowners\nBenchmark 1: codeowners\n  Time (mean ± σ):      4.221 s ±  0.089 s    [User: 5.862 s, System: 0.248 s]\n  Range (min … max):    4.141 s …  4.358 s    10 runs</code></p><p></p><p>为了了解程序将时间花在哪里，我用 pprof 记录了一个 CPU 配置文件。你可以通过将以下代码片段添加到 main 函数的顶部来获得生成的 CPU 配置文件：</p><p>&nbsp;</p><p><code lang=\"null\">pprofFile, pprofErr := os.Create(\"cpu.pprof\")\nif pprofErr != nil {\n  log.Fatal(pprofErr)\n}\npprof.StartCPUProfile(pprofFile)\ndefer pprof.StopCPUProfile()</code></p><p></p><p>题外话：我经常使用 pprof，所以我将这段代码保存为<a href=\"https://code.visualstudio.com/docs/editor/userdefinedsnippets\"> vscode 代码片段</a>\"。我只要输入 pprof，点击 tab，就会出现这个代码片段。</p><p></p><p>Go 附带了一个方便的交互式配置文件可视化工具。通过运行以下命令，然后导航到页面顶部菜单中的火焰图视图，将配置文件可视化为火焰图。</p><p></p><p><code lang=\"null\">$ go tool pprof -http=\":8000\" ./codeowners ./cpu.pprof</code></p><p></p><p>正如我所料，大部分时间都花在了 Match 函数上。CODEOWNERS 模式被编译成正则表达式，Match 函数的大部分时间都花在 Go 的正则表达式引擎中。但是我也注意到，很多时间都花在了分配和回收内存上。下面的火焰图中的紫色块与模式 gc|malloc 相匹配，你可以看到它们在总体上表示程序执行时间的一个有意义的部分。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/6e/6e900cddea9e9cf9695e8a48792c63df.png\" /></p><p></p><p></p><h3>使用逃逸分析跟踪搜寻堆分配</h3><p></p><p></p><p>因此，让我们看看是否有任何分配可以消除，以减少 GC 的压力和在 malloc 花费的时间。</p><p></p><p>Go 编译器使用一种叫做逃逸分析（escape analysis）的技术来计算出何时需要在堆上驻留一些内存。假设一个函数初始化了一个结构，然后返回一个指向它的指针。如果该结构是在堆栈中分配的，那么一旦函数返回，并且相应的堆栈框架失效，返回的指针就会失效。在这种情况下，Go 编译器将确定该指针已经“逃离”了函数，并将该结构移至堆中。</p><p></p><p>你可以通过向 go build 传递 -gcflags=-m 来看到这些决定：</p><p></p><p><code lang=\"null\">$ go build -gcflags=-m *.go 2&gt;&amp;1 | grep codeowners.go\n./codeowners.go:82:18: inlining call to os.IsNotExist\n./codeowners.go:71:28: inlining call to filepath.Join\n./codeowners.go:52:19: inlining call to os.Open\n./codeowners.go:131:6: can inline Rule.Match\n./codeowners.go:108:27: inlining call to Rule.Match\n./codeowners.go:126:6: can inline Rule.RawPattern\n./codeowners.go:155:6: can inline Owner.String\n./codeowners.go:92:29: ... argument does not escape\n./codeowners.go:96:33: string(output) escapes to heap\n./codeowners.go:80:17: leaking param: path\n./codeowners.go:70:31: []string{...} does not escape\n./codeowners.go:71:28: ... argument does not escape\n./codeowners.go:51:15: leaking param: path\n./codeowners.go:105:7: leaking param content: r\n./codeowners.go:105:24: leaking param: path\n./codeowners.go:107:3: moved to heap: rule\n./codeowners.go:126:7: leaking param: r to result ~r0 level=0\n./codeowners.go:131:7: leaking param: r\n./codeowners.go:131:21: leaking param: path\n./codeowners.go:155:7: leaking param: o to result ~r0 level=0\n./codeowners.go:159:13: \"@\" + o.Value escapes to heap</code></p><p></p><p>输出有点嘈杂，但你可以忽略其中的大部分。由于我们正在寻找分配，“move to heap”是我们应该关注的短语。回顾上面的 Match 代码，Rule 结构被存储在 Ruleset 片中，我们可以确信它已经在堆中了。由于返回的是一个指向规则的指针，所以不需要额外的分配。</p><p></p><p>然后我看到了--通过分配 rule := r[i]，我们将堆中分配的 Rule 从片中复制到堆栈中，然后通过返回 &amp;rule，我们创建了一个指向结构副本的（逃逸）指针。幸运的是，解决这个问题很容易。我们只需要将 &amp; 号往上移一点，这样我们就引用了片中的结构，而不是复制它：</p><p></p><p><code lang=\"text\"> func (r Ruleset) Match(path string) (*Rule, error) {\n for i := len(r) - 1; i &gt;= 0; i-- {\n-rule := r[i]\n+rule := &amp;r[i]\n match, err := rule.Match(path)\n if match || err != nil {\n-return &amp;rule, err\n+return rule, err\n }\n }\n return nil, nil\n }</code></p><p></p><p>我确实考虑过另外两种方法：</p><p></p><p>将 Ruleset 从 []Rule 更改为 []*Rule，这意味着我们不再需要显式引用该规则。返回 Rule 而不是 *Rule。这仍然会复制 Rule，但它应该保留在堆栈上，而不是移动到堆上。</p><p></p><p>然而，由于此方法是公共 API 的一部分，这两种方法都会导致一个重大的变化。</p><p></p><p>无论如何，在做了这个修改之后，我们可以通过从编译器获得一个新的跟踪并将其与旧的跟踪进行比较来看看它是否达到了预期的效果：</p><p></p><p><code lang=\"null\">$ diff trace-a trace-b\n14a15\n&gt; ./codeowners.go:105:7: leaking param: r to result ~r0 level=0\n16d16\n&lt; ./codeowners.go:107:3: moved to heap: rule</code></p><p></p><p>成功了！分配消失了。现在让我们看看删除一个堆分配会如何影响性能：</p><p></p><p>&nbsp;</p><p><code lang=\"null\">$ hyperfine ./codeowners-a ./codeowners-b\nBenchmark 1: ./codeowners-a\n  Time (mean ± σ):      4.146 s ±  0.003 s    [User: 5.809 s, System: 0.249 s]\n  Range (min … max):    4.139 s …  4.149 s    10 runs\n\n\nBenchmark 2: ./codeowners-b\n  Time (mean ± σ):      2.435 s ±  0.029 s    [User: 2.424 s, System: 0.026 s]\n  Range (min … max):    2.413 s …  2.516 s    10 runs\n\n\nSummary\n  ./codeowners-b ran\n    1.70 ± 0.02 times faster than ./codeowners-a</code></p><p></p><p>由于该分配是针对匹配的每一条路径进行的，因此在这种情况下，删除它会获得 1.7 倍的速度提升（这意味着它的运行速度要快 42%）。对一个字符的变化来说还不错。</p><p></p><p>作者简介：</p><p>&nbsp;</p><p>Harry，在 GitHub 工作，负责领导团队为开发人员开发安全产品。Dependabot 共同创始人之一。</p><p>&nbsp;</p><p>原文链接：</p><p>&nbsp;</p><p>https://hmarr.com/blog/go-allocation-hunting/#circle=on</p>",
    "publish_time": "2023-02-14 11:32:55",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "从谷歌辞职后，我创办了家年营收近百万美元的公司，我一年挣了6000美元，网友：什么都不干，赔钱最慢",
    "url": "https://www.infoq.cn/article/oy53MuMMJiIsixTKMLjR",
    "summary": "<p></p><blockquote>五年之前，我辞去了谷歌那边的开发岗，出来建立了自己的软件公司。</blockquote><p></p><p>&nbsp;</p><p>刚开始那几年，公司业务一直没有起色。月收入甚至就是几百美元的水平，长期处于亏损状态。</p><p>&nbsp;</p><p>到第三年年中，我开发了一款名叫TinyPilot的设备，能帮助用户在不安装任何软件的前提下<a href=\"https://www.infoq.cn/article/9W1zPkwUqT1Zyx0QGt3J\">远程控制</a>\"自己的计算机。这款产品意外走红，也成了我们之后的业务关注重点。</p><p>&nbsp;</p><p>2022年，TinyPilot一共创造了81.2万美元的营收，比2021年增长了76%。</p><p>&nbsp;</p><p>在本文中，我想跟大家好好聊聊自己的白手起家<a href=\"https://archsummit.infoq.cn/2023/beijing/track/1453\">创业</a>\"路，特别是这第五年里的经验和教训。</p><p>&nbsp;</p><p>首先来看下这几年的公司的营收情况，直到去年，TinyPilot年营收增长至81.2万美元。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/9c/9caff51b7ad09ecc1c13db1027af149d.png\" /></p><p></p><p>下面这个表格，是我想让你知道这些钱都花在了哪。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/05/0559c45b80964c6893242c4b11d11510.png\" /></p><p></p><p>&nbsp;营收猛增35万美元听起来确实爽，但一年忙下来就6000美元的纯利润实在有点说不过去。而且我不给自己发工资，所以这6000美元就是过去一整年我从公司身上赚取的全部收入。不过光明的前景还是让我对新的一年充满期待。</p><p>&nbsp;</p><p>去年增加的一项主要成本，就是电气工程。整个2021年，TinyPilot的电气工程供应商都在努力跟进产品发展思路，但效果一般。2021年底，我换了一家更符合需求的新供应商，他们水平更高，但价格也是前一家的3倍。</p><p>&nbsp;</p><p>另外，芯片的持续短缺迫使我们频繁更改设计，这也增加了工程时间和原材料成本。我们往往需要在用完现有物料储备后就重新设计电路板，所以得反复支付额外费用来加快流程。</p><p>&nbsp;</p><p>我们最终到去年9月才摆脱了重新设计的困局。希望第四季度的火热表现也能在2023年稳定延续。第四季度，特准的利润达到了2.86万美元，如果新一年也能保持月均9500美元的平均收益，那我可就太开心了。</p><p></p><h2>TinyPilot有新网站了</h2><p></p><p>&nbsp;</p><p>在2020年刚刚推出<a href=\"https://tinypilotkvm.com/\">TinyPilot</a>\"时，配套上线的网站和徽标只是勉强能用、暂时顶住。之后产品迅速发展，所以我很长一段时间都没余力再做优化。</p><p>&nbsp;</p><p>2022年，我终于招了一家设计机构创作新的徽标，还有重新布置整个网站。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/06/06f761e029732e81e7ebfc0086fbee69.png\" /></p><p></p><p>TinyPilot网站重新设计前后</p><p>&nbsp;</p><p>有经验的朋友肯定知道，跟设计机构合作可说是既费钱又费神，但这次的结果确实让人满意。旧网站明显就是业余爱好级别，而新设计终于有了一家公司的样子。我怀疑之所以销售额迅速提升，有一部分就是新网站所带来的。</p><p>&nbsp;</p><p></p><h3>TinyPilot团队从6人增加到7人</h3><p></p><p>&nbsp;</p><p>2021年底，TinyPilot的团队构成是：</p><p>&nbsp;</p><p>我，唯一的创始人；3名兼职软件开发人员；2名本地兼职员工，负责组装设备和寄送订单；其中1位还兼顾客服工作。</p><p>&nbsp;</p><p>2022年底，我们新增2名支持工程师并调整了职责划分，现在的团队构成是：</p><p>&nbsp;</p><p>我，唯一的创始人；2名兼职软件开发人员；2位本地兼职员工，负责组装设备和寄送订单；2人现在都兼顾客服工作；2名兼职支持工程师。</p><p>&nbsp;</p><p>支持工程师的加入，就像是拼图中缺失的一块终于补齐。在他们加入之前，我就是唯一的<a href=\"https://archsummit.infoq.cn/2023/beijing/track/1456\">技术支持</a>\"负责人，这部分工作花掉了我大概20%的时间。现在，我用在请求支持方面的时间已经低于5%，客户服务已经能够快速到位。</p><p>&nbsp;</p><p>支持工程师还做了不少我没时间完成的工作，比如调查复杂的<a href=\"https://www.infoq.cn/article/eGbSZBSKWEDxspQq8FLh\">bug</a>\"、编写文档和改进诊断工具。</p><p>&nbsp;</p><p>愈发壮大的团队也拓展了我的管理技能。2021年，TinyPilot的工作流程还很简单，几乎每个人都作为独立的单位完成工作。结果要么提交给我，要么直接提交给客户。当员工之间需要相互协调时，沟通双方也肯定是同一职能上的两位同事。</p><p>&nbsp;</p><p>而支持工程师的加入，意味着我得搞清楚不同职能的团队间要如何协作。当支持请求要求履行者和支持工程师共同配合完成时，他们要怎么彼此对接？支持工程师和<a href=\"https://archsummit.infoq.cn/2023/beijing/track/1477\">开发团队</a>\"间的反馈循环又该如何设计？</p><p>&nbsp;</p><p></p><h3>PicoShare成为增速最快的项目</h3><p></p><p>&nbsp;</p><p>过去几年以来，我最讨厌的事情就是通过Google Drive或者Dropbox之类的云存储服务商分享单个文件。他们不会提供直接指向文件的链接，只有指向Web界面的链接，收件人还得注册账户才能查看。如果把视频上传到Google Drive还需要经历重新编码，就算是针对浏览器播放进行了优化，整个过程也至少要15分钟。</p><p>&nbsp;</p><p>作为云存储选项的替代方案，我开发了一款名叫PicoShare的极简文件共享应用。大家只需上传一个文件，它就会生成一条可以直接共享的链接。这多简单！不用重新编码、也不用单独注册，上手就用。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b2/b2908b787ac531603f9e35fc76f83a62.png\" /></p><p></p><p>PicoShare演示</p><p>&nbsp;</p><p>虽然也有其他<a href=\"https://archsummit.infoq.cn/2023/beijing/track/1477\">开源工具</a>\"在提供类似的功能，但PicoShare的独特之处在于它不需要数据库服务器。全部负载都能在单个Docker容器内运行，而其他解决方案往往需要更复杂的编排过程。</p><p>&nbsp;</p><p>PicoShare也成为我发布过的增速最快的开源项目。在发布后的半个月内，它就拿下GitHub 600星；截至本文撰稿时，PicoShare的安装量已超10万次。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/0a/0a7ac0db644415a170d914a18f91fe57.png\" /></p><p></p><h2>经验教训</h2><p></p><p></p><h3>别当那个“最不重要的客户”</h3><p></p><p>&nbsp;</p><p>在TinyPilot网站的整个设计过程中，我犯了不少错误，其中最核心的问题就是前一家设计机构的体量跟TinyPilot根本就不搭调。</p><p>&nbsp;</p><p>那家机构其他客户的预算，基本是TinyPilot的5到20倍。起初我还以为这是好事，毕竟人家是高端设计品牌，能傍上这样的资源说出去都有面子。</p><p>&nbsp;</p><p>但实际上，TinyPilot成了他们优先级最低的项目。由于管理不善，项目成本增加、范围扩大而且成果也未能按期交付。</p><p>&nbsp;</p><p>所以现在挑选新的供应商时，我会询问自己跟他们的其他客户相比有何差异。如果在规模、收入或者所处行业方面区别太大，我就会果断选择其他服务伙伴。</p><p></p><h3>以50%的容量运行</h3><p></p><p>&nbsp;</p><p>如果你的业务能力刚刚好够满足客户需求，那肯定是最佳运营状态吧？这样员工就能在每周保持40小时工作的同时，准时完成每笔订单并回应每个支持请求。他们既不会闲着无聊，也不会累到心慌，一切都完美和谐……</p><p>&nbsp;</p><p>但大家觉得这事可能吗？以100%的容量运行绝对非常可怕，这意味着整个公司没有任何犯错空间。一旦销量激增或者员工临时休假，业务立刻就会陷入混乱。</p><p>&nbsp;</p><p>我的目标是让TinyPilot的每个人都以50%左右的负荷量工作。换句话说，有50%属于必须完成的被动工作，另外50%是需要主动找来做的内容。虽然在某些岗位上达不到50/50的绝对平衡，但大家应该能明白我的意思。</p><p>&nbsp;</p><p>技术支持团队就是50/50的最佳案例：他们把一半时间用来响应支持请求，另一半时间用来寻找防止用户需要申请支持的好办法。这类任务包括修复产品中的bug、编写文档和改进诊断工具。</p><p>&nbsp;</p><p>TinyPilot中的每个团队都由2人组成。这样即使有人不在，另一位也能先放放主动工作、优先处理时间敏感任务，整个体系仍然能够运作得井井有条。比方说，某个人气YouTube频道提到了我们而瞬间拉高了订单数量，那我们也一直有多余的容量消化这部分业务。</p><p><img src=\"https://static001.geekbang.org/infoq/1b/1b1e21bdb82158f0af6e14c7efafda54.png\" /></p><p></p><h3>Ansible和git不是软件分发工具</h3><p></p><p>&nbsp;</p><p>在刚开始设计TinyPilot时，我不知道该怎么分发Linux软件。</p><p>&nbsp;</p><p>所以在TinyPilot原型发布时，我用上了自己了解的工具：bash脚本、Ansible和git。Bash脚本负责引导一个Ansible环境，再执行相应的Ansible playbook。Ansible会安装依赖项，对操作系统做出必要更改，再克隆TinyPilot git代码仓库。</p><p>&nbsp;</p><p>整个安装过程勉强能用，体验不太好。优点就是可靠、不需要用户做手动配置，但缺点是速度慢。</p><p>&nbsp;</p><p>两年之后，TInyPilot的更新过程可说是一团糟。其仍然依赖于当初原型时的基础，只是现在的依赖项体系更复杂了。Ansible角色依赖于Git代码仓库，而Git代码仓库又依赖于其他Ansible角色，后者则依赖于YAML文件中的一大堆参数。任何微小的变更都足以吞噬几个礼拜的开发时间。</p><p>&nbsp;</p><p>而这一切，都是因为我从来没认真学习过标准的Linux打包工具。</p><p>&nbsp;</p><p>到2022年，TinyPilot团队终于学会了使用Debian软件包。其实根本就没我想象中那么难，我本来以为得部署各种包服务器和密钥服务器，但事实证明并不需要。只要找到靠谱的操作指南，整个过程相对来说还是挺简单的。</p><p>&nbsp;</p><p>Debian加快了我们的开发步伐，它能更早发现严重错误，让我们轻松将预发布版本部署到测试设备上。跟现在相比，之前的安装系统实在是太复杂、太笨拙了。</p><p></p><h2>回顾去年定下的目标</h2><p></p><p>&nbsp;</p><p>我为2022年定下了三个高层次目标，下面看看到底完成得怎么样：</p><p></p><h3>将TinyPilot的年营收提升至100万美元</h3><p></p><p>&nbsp;</p><p>结果：TinyPilot的营收增长76%，来到81.2万美元；评分：B</p><p>&nbsp;</p><p>我其实知道100万这个目标定得有点高，恐怕很难达到，但最终结果已经相当接近了，着实令人振奋不已。</p><p></p><h3>每周花20个小时管理TinyPilot</h3><p></p><p>&nbsp;</p><p>结果：跟2021年相比，2022年我花在TinyPilot管理上的时间反而更多了。评分：D</p><p>&nbsp;</p><p>我本来打算把工作尽量分给他人，再做点自动化升级，争取把每周的管理时间缩短到20个小时，但明显没能做到。随着销售额增加、支持工程团队的组建还有芯片短缺问题的蔓延，我的管理时间反而变长了。</p><p></p><h3>推出TinyPilot Voyager 3</h3><p></p><p>&nbsp;</p><p>结果：我们甚至连设计工作都没做完评分：F</p><p>&nbsp;</p><p>TinyPilot之前一直使用Raspberry Pi 4B作为核心硬件。Pi 4B拥有出色的生态系统，但问题是硬件相对昂贵、而且难以与定制芯片相集成。</p><p>&nbsp;</p><p>我为2022年定下的计划，是设计一块定制化电路板来对接更轻薄、更便宜的Raspberry Pi Compute Module 4。这本来可以把制造成本降低最高60%，同时简化我们的硬件设计。</p><p>&nbsp;</p><p>但实际情况是，我们的所有硬件工程时间都花在了解决制造问题和供应短缺上，所以在新产品方面没能取得任何进展。</p><p></p><h2>展望第六年</h2><p></p><p></p><h3>每周花20个小时管理TinyPilot</h3><p></p><p></p><p>我知道去年这个目标没能达成，但现在这真的成了我的首要任务。我对2023年充满希望，过去一年完成的很多工作都为我腾出手来奠定了基础。</p><p>&nbsp;</p><p></p><h3>把净利润推向10万美元</h3><p></p><p></p><p>在TinyPilot诞生的前两年半，我主要关注业务增长。无论每月能售出20台设备还是2000台设备，我所支付的硬件和软件工程成本都是一样的，所以销量必须要达到一定规模才能让业务获得可持续性。</p><p>&nbsp;</p><p>在2023年的大部分时间里，TinyPilot的生产都受到了物料供应的限制。虽然被这方面原因束缚了业务拓展的手脚令人沮丧，但我也可以借此机会放慢脚步、专注于创造更大的利润空间。</p><p>&nbsp;</p><p>TinyPilot一直大致维持着收支平衡。我觉得只要能尽量减少对硬件的重新设计，那新一年把利润推向10万美元并不是太难。其实如果2022年不重新设计硬件，那我在工程支出上省下的开销大致就是10万美元，物料成本也能省下2万美元。所以只要能保持销售稳定并精简硬件设计流程，那2023年应该会成为真正开始盈利的元年。</p><p></p><h3>关闭TinyPilot办公室</h3><p></p><p>&nbsp;</p><p>自2021年初以来，我租了一间办公室，专门负责TinyPilot业务的设备组装、订单履行和库存管理。</p><p>&nbsp;</p><p>保留实体办公室确实有利于快速适应硬件和流程上的变化，但也会带来不少额外开销。今年，我打算把组装业务转移到中国，毕竟产品中用的所有零配件本来就源自中国。至于订单履约，我也打算交给第三方物流仓库去做。</p><p>&nbsp;</p><p>撤掉办公室之后，我就不用维护物理空间、管理库存和跟踪人员轮班了。把制造和订单配送外包出去，也能让TinyPilot团队拥有更灵活的工作时间和地点。&nbsp;</p><p></p><h2>我还爱创业吗？</h2><p></p><p>&nbsp;</p><p>其实每次写年终总结的时候，我都会问自己这个问题……我到底，还热爱自己当初的选择吗？</p><p>&nbsp;</p><p>2022年是艰难的一年，也是我独立生活以来最不容易的一年。虽然算不上痛苦，但我也绝不敢说经历了这样的磨炼，自己仍然热爱创业。</p><p>&nbsp;</p><p>全球芯片短缺，意味着我们始终无法以稳定的方式重复制造产品。不是这个部件缺失、就是那个制造流程断档，我们把主要精力都用在了库存耗尽前调整设计上。我们虽然挺过来了，但期间仍然出现过彻底无货可卖的窘境，而且压力很大。</p><p>&nbsp;</p><p>但这一年也有不少情况提振了我的信心。虽然我没多少时间写文章、做软件开发，但我为自己的产品深感自豪。TinyPilot的组织更大了，这帮我学习并探索出了指导各团队顺畅协同的管理方法。随着公司的发展，我也欣慰地看着各团队不断成长、积累起更深厚的职业技能。</p><p>&nbsp;</p><p>我还是喜欢这种自己当老板的感觉，我仍然热爱创业给我带来的自由感。所以在创业这条道路上，我绝对不会动摇。</p><p>&nbsp;</p><p>2022年对我的独立硬件业务来说，无疑是重要的一年。我们的营收增长至81.2万美元，有了新的产品网站，又新增了一支团队。我们经历了成长的烦恼，但这一切也教会了我：</p><p>&nbsp;</p><p>永远别当那个“最不重要的客户”！</p><p>&nbsp;</p><p>原文链接：</p><p>&nbsp;</p><p><a href=\"https://mtlynch.io/solo-developer-year-5/\">https://mtlynch.io/solo-developer-year-5/</a>\"</p>",
    "publish_time": "2023-02-14 14:18:01",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "AI赋能元宇宙游戏的畅想 | InfoQ《极客有约》",
    "url": "https://www.infoq.cn/article/SoPyPH1zzUuFs0PS9JLw",
    "summary": "<p>元宇宙是当下的顶流概念。在很多业内人士眼中，元宇宙+游戏是一个富有想象力的好故事。这几年，VR/XR、AI等技术的发展，令元宇宙游戏开发不断提速。近一年多来，爆火的AIGC迎来诸多技术创新，进一步释放了游戏行业创新活力。本期《极客有约》，我们邀请到了元宇宙创业公司MultiMetaverse CEO，七创社董事长许怡然，来给我们分享“AI赋能元宇宙游戏的畅想”。</p>",
    "publish_time": "2023-02-14 15:24:58",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Akamai 推出 Akamai Connected Cloud 和全新云计算服务",
    "url": "https://www.infoq.cn/article/9S0xRqYBBjWwcUcUgD8F",
    "summary": "<p>该服务采用一种截然不同的云计算方法，可将核心计算站点和分布式计算站点与大规模边缘网络相集成。</p><p></p><p>InfoQ 2月14日消息 ，负责支持和保护网络生活的云服务提供商<a href=\"https://www.akamai.com/zh\">阿卡迈技术公司</a>\"（Akamai Technologies, Inc.，以下简称：Akamai）（NASDAQ：AKAM），于今日推出 Akamai Connected Cloud，这是一款涵括云计算、安全防护和内容交付的大规模分布式边缘和云<a href=\"https://www.akamai.com/solutions/cloud-computing\">平台</a>\"，可使应用程序和体验更靠近用户，帮助用户远离威胁。</p><p></p><p>全新云计算服务和架构将在亚太地区及日本 (APJ) 推出，支持开发人员在更靠近企业和用户网络接入点的位置构建、运行和保护高性能工作负载。Akamai 的发布内容包括：</p><p></p><p>2023 年，APJ 地区将拥有四个全新的企业级核心云计算站点，分别位于钦奈、大阪、雅加达和奥克兰。与 Akamai 现有的 11 个核心站点（包括新加坡、悉尼、东京和孟买的核心站点）相同，新的区域级站点将连入 Akamai 主干网，从而接入 Akamai 全球分布广泛的大型边缘网络。新站点将承载 Linode（已被 Akamai 收购）的云计算服务，并将作为模板，供 Akamai 计划后续在全球范围内启动的其他核心站点借鉴参考。</p><p></p><p>计划部署更多的分布式站点。除了计划中的新核心站点外，Akamai 还在全球选定了 50 多个城市，并计划于今年起在这些城市部署分布式站点，从而使基本云计算功能覆盖传统云提供商未能充分覆盖的偏远地点。</p><p></p><p>&nbsp;出站流量定价颇具竞争力。 全新的定价结构能够利用 Akamai 的网络优势，为云端数据传输提供类似于 CDN 服务的经济效益，降低云端出站流量的成本。新的出站流量定价模式经过专门设计，旨在提供远低于超大规模云平台运营商和替代云提供商的出站流量费率。</p><p></p><p>新增 ISO、SOC 2 和 HIPAA 标准合规性。 新增的标准合规性不仅体现了 Akamai 高度注重云计算服务及其中存储的客户数据的安全性，而且还支持用户在 Akamai 云平台与其他公有云之间迁移工作负载。</p><p></p><p>Akamai Qualified Computing Partner Program（Akamai 计算合作伙伴计划）。 这项全新的技术合作伙伴计划旨在为&nbsp;Akamai 用户提供可与 Akamai Connected Cloud 交互的基于解决方案的服务。这些服务将由完成全面资格评定流程的 Akamai 技术合作伙伴来提供，进而确保这些服务可轻松在 Akamai 的全球分布式平台上部署和扩展。</p><p></p><p>Akamai 联合创始人兼首席执行官 Tom Leighton 博士表示：“我们如今采用了一种截然不同的云计算方法，其基础是为全球大型公司扩展和保护互联网的 25 年经验积淀。Akamai 正在打造能够满足未来十年需求的云平台。”</p><p></p><p>亚太地区高级副总裁、销售副总裁兼常务董事 Parimal Pandya 表示：“亚太地区及日本的数字化转型进展迅猛，Akamai Connected Cloud 的推出恰逢其时。许多企业都在考虑采用多云和开源架构，以妥善处理不同市场中的多样化基础架构和网络功能，同时满足降低成本、提高敏捷性的需求，因此云技术领域有着巨大的发展机遇。 ”</p><p></p><p>为扩大 Akamai Connected Cloud 的覆盖范围，Akamai 正在为其底层主干网增设核心站点和分布站点，这个主干网也在为其当今覆盖 134 个国家/地区、4100 多个位置的边缘网络提供支持。更具体地说，Akamai 目前致力于让计算、存储、数据库和其他服务更靠近庞大的人口、行业和 IT 聚集中心。最终实现从核心到边缘的连续计算能力，助力公司更高效地构建、部署和保护那些要求单位数毫秒级延迟及全球覆盖的高性能工作负载。如今，媒体、游戏、SaaS 供应商、零售等行业以及政府机构都有这方面的强烈需求。</p><p></p><p>Leighton 说：“Akamai 在边缘的领先地位让我们能扩展所接触到的一切：我们扩展内容，让数字体验更靠近用户。我们扩展网络安全措施，让威胁远离企业和个人。客户了解我们，也信任我们的这种扩展能力。如今，我们计划扩展云计算，以更低廉的成本为客户提供更出色的性能。”</p><p></p><p>根据 IDC 的数据，亚太地区公有云服务市场的体量<a href=\"https://www.idc.com/getdoc.jsp?containerId=prAP49725422\">预计将于 2026 年达到 1652 亿美元</a>\"。据预测，2023年，三分之一的公司<a href=\"https://www.idc.com/getdoc.jsp?containerId=prAP48347921\">的收入中将有超过 30% 的部分</a>\"来自数字化产品和服务。</p><p></p><p>IDC 研究副总裁 Dave McCarthy 指出：“云技术的下一阶段要求开发人员和企业改变思路，重新审视如何使应用程序和数据更靠近客户。这会重新定义行业对性能、扩展能力、成本和安全性等方面的看法，因为工作负载不再仅为一个位置构建，而是会跨广泛的计算环境和地理位置进行交付。 Akamai 运用创新思维重新审视如何实现这方面的目标，如何设计 Akamai Connected Cloud 架构，并借此获得独特优势，开启激动人心的科技新时代，助力企业构建、部署和保护分布式应用程序。”</p><p></p><p>Akamai 已使区域客户能够管理去中心化应用程序架构，并在其区域运营中提供一致的体验。</p><p></p><p>Zolvit 首席技术官 Rajkumar Ganapathy&nbsp;表示：“我们的关键目标之一是整合基础架构，从而改善管理、提高灵活性并节省成本。我们一直在寻找一家能满足我们所有要求的云服务提供商，Akamai Connected Cloud 是我们的首选产品，原因就在于它不仅有着简单、经济且易于访问的基础架构，而且还可提供卓越的支持，能让我们的团队安心无忧。”</p><p></p><p>Akamai Connected Cloud 相关工作的负责人是 Akamai 云技术事业部首席运营官兼总经理 Adam Karon，他负责领导团队专注于使当今领先的媒体、游戏和软件公司能够为使用任何设备、身处任何地点的客户提供理想的大规模体验，并帮助运营商运营高性能、高成本效益的网络。</p><p></p><p>Karon 表示：“云是应对更重大的业务挑战的跳板。企业领导者希望在日渐数字化的世界中延续数字化转型的势头，并为其企业拓展可能性的边界。我们的分布式规模旨在提供高性能云计算，覆盖客户业务接入网络的每一个位置，为他们提供必要的速度、灵活性、性能和连接能力，赋能客户无忧发展、顺畅创新并一直满足客户需求。”</p>",
    "publish_time": "2023-02-14 17:03:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "微软发言人证实旗下LinkedIn平台开始裁员",
    "url": "https://www.infoq.cn/article/5CGARLHYyr6ZL32hXxMq",
    "summary": "<p>&nbsp;</p><p>2月14日，据知情人士称，微软旗下的 LinkedIn已于周一开始裁员。该公司向 The Information 证实，这是微软裁员如何波及这家科技巨头的最新迹象。</p><p>&nbsp;</p><p>微软旗下社交媒体平台LinkedIn，是微软此前宣布的浩浩荡荡裁员大潮中的一部分。此前，微软曾表示将裁员大约1万人。微软发言人告知媒体，某些员工已收到解雇通知书，但被裁员工的具体数字尚未确定。</p><p>&nbsp;</p><p>据此前The Information的报道，LinkedIn 于去年就已经宣布了放缓招聘的计划。2022 年 11 月，首席执行官 Ryan Roslansky 曾告诉 CNBC-TV18，没有裁员计划，但他们将在某些垂直领域实施招聘冻结。</p><p>&nbsp;</p><p>快进到 2023 年，在微软裁员影响了1万多名员工之后，连锁反应已经波及 LinkedIn。今年1月，微软宣布将在全球裁员约5%，以寻求“调整成本结构”来应对营收下降。</p><p>&nbsp;</p><p>大约一周后，这家科技巨头公布了令人失望的季度利润，并警告称，营收放缓预计将在整个2023年持续。在此大背景下，GitHub、Azure 和 Metaverse 下的员工均受到了不同程度的影响。</p><p>&nbsp;</p><p>微软股价今年迄今上涨13%，但过去12个月累计下跌了8%。以微软为成分股的道琼斯工业股票平均价格指数今年迄今上涨了3%，过去一年下跌1%。</p><p></p><p>其实不只是微软，最近科技圈的裁员传闻频出，整个科技行业都在“过冬”。从影响超过1.8万人的亚马逊裁员到影响1.2万人的谷歌裁员，LinkedIn 似乎是最新一家遭受裁员的科技公司。</p><p>&nbsp;</p><p>参考链接：</p><p>&nbsp;</p><p><a href=\"https://www.theinformation.com/articles/microsofts-linkedin-lays-off-staff-amid-hiring-slowdown\">https://www.theinformation.com/articles/microsofts-linkedin-lays-off-staff-amid-hiring-slowdown</a>\"</p>",
    "publish_time": "2023-02-14 17:08:48",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "ChatGPT火爆全球后，OpenAI CEO称“它很酷，但却是个糟糕的产品”",
    "url": "https://www.infoq.cn/article/YYqCPSdRmtkdSl2hhb9Y",
    "summary": "<p><a href=\"https://www.infoq.cn/article/FRcz5vjOvl3bM2d57opX\">“顶流”ChatGPT</a>\" 自去年年底发布以来，用 2 个月时间收获 1 亿用户。但作为它的创造者，OpenAI 联合创始人兼首席执行官 Sam Altman 在近日接受采访时却表示，ChatGPT很酷，但却是个糟糕的产品。</p><p>&nbsp;</p><p>在采访中，Altman 承认了 ChatGPT 当前存在的问题，比如频繁出现错误消息。Altman 说：“人们真的只是去访问一个有时能正常工作，有时会宕机的网站。他们会输入一些东西，一直在尝试，直到他们正确为止，然后他们复制那个答案并将其粘贴到其他地方——然后返回并尝试将其与搜索结果或其他人整合工作流程。”</p><p>&nbsp;</p><p>不过，Altman 也承认 ChatGPT 的 <a href=\"https://www.infoq.cn/article/AWWsrfb54zTvglZ0I5qS\">AI 技术</a>\"“确实很酷”。“人们真的很喜欢它，这让我们很高兴。但没有人会说这是一个伟大的、整合良好的产品……好在它具备一定的价值，所以人们愿意忍受这些瑕疵。”Altman 说道。</p><p>&nbsp;</p><p>自去年年底发布以来，ChatGPT 在互联网上掀起了一场风暴，给科技界带来了很多惊喜。并已经颠覆了教育领域，帮助学生写论文和通过考试。此外，ChatGPT 还相当擅长编写工作申请求职信、代码行和新闻报道。</p><p>&nbsp;</p><p>比尔盖茨评价称，ChatGPT 的技术将“改变我们的世界”。马斯克也在感叹“很多人疯狂地陷入了 ChatGPT 循环中”，“ChatGPT 好得吓人，我们离强大到危险的人工智能不远了”。</p><p>&nbsp;</p><p>但作为新兴技术，<a href=\"https://www.infoq.cn/article/wyWO1PjbmyLpBMQxVOxy\">ChatGPT</a>\" 当前也存在一些问题，比如，ChatGPT 很容易崩溃，它经常告诉用户，目前的容量已满，因而只能拒绝用户的查询。</p><p>&nbsp;</p><p>OpenAI 的另一位联合创始人 Greg Brockman 最近表示，以目前的形式推出 ChatGPT 是该公司的 beta 测试员遇到内部问题后的最后手段。</p>",
    "publish_time": "2023-02-14 17:53:57",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]