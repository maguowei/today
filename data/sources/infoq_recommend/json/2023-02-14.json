[
  {
    "title": "Java近期新闻：Helidon 4.0-Alpha4、Spring、GlassFish、Quarkus、Ktor、（重新）引入 RIFE2",
    "url": "https://www.infoq.cn/article/4ulKLNTV8Og2HZy5eX6Z",
    "summary": "<p></p><h4>JDK 20</h4><p></p><p>JDK20<a href=\"https://jdk.java.net/20/\">早期访问构建版本</a>\"中的第<a href=\"https://github.com/openjdk/jdk/releases/tag/jdk-20%2B34\">34</a>\"版已于上周发布，其中包括对第33版各种<a href=\"https://github.com/openjdk/jdk20/compare/jdk-20%2B33...jdk-20%2B34\">问题</a>\"的修复和<a href=\"https://bugs.openjdk.org/issues/?jql=project%20%3D%20JDK%20AND%20fixversion%20%3D%2020%20and%20%22resolved%20in%20build%22%20%3D%20b34%20order%20by%20component%2C%20subcomponent\">更新</a>\"。有关该版本的更多详细信息，请参阅<a href=\"https://jdk.java.net/20/release-notes\">发布说明</a>\"。</p><p></p><h4>JDK 21</h4><p></p><p>JDK 21<a href=\"https://jdk.java.net/21/\">早期访问构建版本</a>\"的第<a href=\"https://github.com/openjdk/jdk/releases/tag/jdk-21%2B8\">8</a>\"版也已于上周发布，其中包括对第7版各种<a href=\"https://bugs.openjdk.org/issues/?jql=project%20%3D%20JDK%20AND%20fixversion%20%3D%2021%20and%20%22resolved%20in%20build%22%20%3D%20b08%20order%20by%20component%2C%20subcomponent\">问题</a>\"的修复和<a href=\"https://github.com/openjdk/jdk/compare/jdk-21%2B7...jdk-21%2B8\">更新</a>\"。有关该版本的更多详细信息，请参阅<a href=\"https://jdk.java.net/21/release-notes\">发布说明</a>\"。</p><p>&nbsp;</p><p>对于<a href=\"https://openjdk.java.net/projects/jdk/20/\">JDK 20</a>\"&nbsp;和<a href=\"https://openjdk.java.net/projects/jdk/21/\">JDK 21</a>\"，均鼓励开发人员通过<a href=\"https://bugreport.java.com/bugreport/\">Java缺陷数据库</a>\"报告缺陷。</p><p></p><h4>Spring Framework</h4><p></p><p><a href=\"https://spring.io/tools\">Spring Tools</a>\" 4.17.2的发布提供了缺陷修复和改进，例如：来自OpenRewrite Java Parser中的 NullPointerException ；使用最新版本的ANTLR运行时更新生成的Java属性解析器；提供了有关“Java源代码协调”定义的更多信息，并且执行Spring Boot 3.0的升级配方会抛出异常。有关该版本的更多详细信息，请参阅<a href=\"https://github.com/spring-projects/sts4/wiki/Changelog#2023-02-01-4172-release-incl-language-servers-version-1440\">发布说明</a>\"。</p><p></p><h4>GlassFish</h4><p></p><p>Eclipse基金会<a href=\"https://github.com/eclipse-ee4j/glassfish/releases/tag/7.0.1\">发布</a>\"了GlassFish 7.0.1，其特性包括：依赖升级；对某些装载器机制进行了大修，以加快操作速度；以及更可靠的服务器关闭监控。GlassFish 7与最低版本为JDK 11的Jakarta EE 10兼容。然而，它可以在JDK11到JDK19上编译和运行，并在JDK20早期访问构建版本的<a href=\"https://github.com/openjdk/jdk/releases/tag/jdk-20%2B30\">第30版</a>\"上成功地进行了初始测试。</p><p></p><h4>Quarkus</h4><p></p><p>在Quarkus 2.16.0发布不到一周后，Quarkus 2.16.1.Final也<a href=\"https://quarkus.io/blog/quarkus-2-16-0-final-released/\">发布</a>\"了，这是一个面向Java社区的<a href=\"https://quarkus.io/blog/quarkus-2-16-1-final-released/\">维护版本</a>\"。该版本附带了缺陷修复、文档改进和依赖升级。Micrometer度量格式已经迁移到Prometheus。有关该版本的更多详细信息，请参阅<a href=\"https://github.com/quarkusio/quarkus/releases/tag/2.16.1.Final\">变更日志</a>\"。</p><p></p><h4>Helidon</h4><p></p><p>甲骨文（Oracle）<a href=\"https://medium.com/helidon/helidon-4-0-0-alpha4-release-d113a9079a97\">发布</a>\"了Helidon 4.0.0-ALPHA4，该版本支持Helidon Níma上的Helidon MP，这是一个基于虚拟线程的微服务框架，并提供了对基于MicroProfile 5.0的应用程序在虚拟线程上运行的全面支持。其他值得注意的变更包括：更有效的Web服务器关闭策略；弃用MicroProfile跟踪规范；以及对Helidon构建器的改进。有关该版本的更多详细信息，请参阅<a href=\"https://github.com/helidon-io/helidon/releases/tag/4.0.0-ALPHA4\">发布说明</a>\"。</p><p></p><h4>Hibernate</h4><p></p><p><a href=\"https://hibernate.org/search/\">Hibernate Search</a>\"的6.1.8.Final和 5.11.12.Final版本已于<a href=\"https://in.relation.to/2023/01/31/hibernate-search-6-1-8-and-5-11-12/\">上周发布</a>\"。</p><p>&nbsp;</p><p>6.1.8版本的特性包括：当修改带有 @OneToOne(mappedBy = ...) @IndexedEmbedded 注解的属性时，将不再跳过自动重建索引；定期测试Hibernate Search 6.1与Hibernate ORM 6.2的兼容性；以及对Hibernate ORM 5.6.12.Final和Jackson 2.13.4的依赖升级。</p><p>&nbsp;</p><p>5.11.12版本的特性是更新/删除一个租户中的实体时，将不再从其他租户的索引中删除具有相同ID的实体。</p><p></p><h4>PrimeFaces</h4><p></p><p>PrimeFaces 12.0.3和11.0.10也已<a href=\"https://www.primefaces.org/primefaces-11-0-10-and-12-0-3-released/\">发布</a>\"，提供了如下的修复： 在JpaLazyDataModel 类中实现了filterMatchMode 属性的 between 和 notBetween 值；违反开放Web应用程序安全项目（OWASP）规则<a href=\"https://github.com/SpiderLabs/owasp-modsecurity-crs/blob/v3.0/master/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf#L133\">941130</a>\"的cookie名称； JpaLazyDataModel 类中定义的 convertToType() 方法抛出 java.util.Date 的 FacesException ；有关这些版本的更多详细信息，请参阅<a href=\"https://github.com/primefaces/primefaces/issues?q=is%3Aissue+label%3A12.0.3+is%3Aclosed\">12.0.3</a>\"版和<a href=\"https://github.com/primefaces/primefaces/issues?q=is%3Aissue+is%3Aclosed+label%3A11.0.10\">11.0.10</a>\"版的问题列表。</p><p></p><h4>阿帕奇软件基金会</h4><p></p><p>Apache Commons CSV 1.10.0已经<a href=\"https://www.mail-archive.com/announce@apache.org/msg07932.html\">发布</a>\"，并进行了显著的更改，例如： CSVRecord 类中定义的 get(Enum) 方法应该使用 name() 方法，而不是 Enum 类中的 toString() 方法； CSVRecord 类中定义的 toList() 方法不提供对新建 List 的写访问；并在 CSVParser 类中标识null、empty和blank头名称中的重复项。有关该版本的更多详细信息，请参阅<a href=\"https://commons.apache.org/proper/commons-csv/changes-report.html#a1.10.0\">发布说明</a>\"。</p><p></p><h4>JHipster</h4><p></p><p>JHipster Lite 0.27.0已经<a href=\"https://github.com/jhipster/jhipster-lite/releases/tag/v0.27.0\">发布</a>\"，其特性包括：引导程序（bootstrapping）的重构；支持Apache Cassandra；Angular前端中定义的一个新的 inject() 函数和自动关闭组件标签；以及一些依赖的升级，其中最值得注意的Angular 15.1.3。</p><p>&nbsp;</p><p>JHipster团队已经完成了向<a href=\"https://spring.io/projects/spring-security\">Spring Security</a>\"&nbsp;6.0的 HttpSecurity 类中定义的 authorizeHttpRequests() 方法的<a href=\"https://twitter.com/mraible/status/1621220421424058368?cxt=HHwWgMC4mcfY3f8sAAAA\">迁移</a>\"，该方法从默认允许行为迁移到默认拒绝行为，以提高安全性。</p><p></p><h4>JetBrains</h4><p></p><p>JetBrains<a href=\"https://twitter.com/JetBrainsKtor/status/1620749039376695296?cxt=HHwWgIDUocGqh_4sAAAA\">发布</a>\"了<a href=\"https://ktor.io/\">Ktor</a>\"的2.2.3版本，这是一个用于创建微服务和Web应用程序的异步框架，其中包括如下的改进：当请求路径较长时， FileStorage 函数会抛出 FileNotFoundException ； HttpRequestRetry 对 FileStorage 引发的 FileNotFoundException 进行重试；而多部分 File 不会上载整个文件，并为较大的文件抛出一个“非预期EOF：超出预期4096字节”异常。有关该版本的更多详细信息，请参阅<a href=\"https://ktor.io/changelog/2.2/#version-2-2-3\">最新动态页面</a>\"。</p><p></p><h4>RIFE2</h4><p></p><p>Moog Music的软件工程和产品经理<a href=\"https://www.linkedin.com/in/gbevin/\">Geert Bevin</a>\"对其原始的RIFE框架<a href=\"https://github.com/gbevin/rife2/releases/tag/1.0.0\">进行了修改和重新引入</a>\"，RIFE框架从2000年到2010年一直处于活动状态，新框架采用了<a href=\"https://rife2.com/\">RIFE2</a>\"的1.0.0版本，这是一个全栈框架，可以用现代Java创建Web应用程序。1.0.0版是最初的稳定版本，其特性包括：对continuations工作流引擎的重新设计和重做；内部并发修复和改进；安全检查，以禁止部署后的路由更改；以及一个新的 MemoryResources 类，它为存储在内存中的资源提供了 ResourceFinder 和 ResourceWriter 接口实现的功能。InfoQ将持续跟进更详细的新闻报道。</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/02/java-news-roundup-jan30-2023/\">https://www.infoq.com/news/2023/02/java-news-roundup-jan30-2023/</a>\"</p>",
    "publish_time": "2023-02-14 10:08:25",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "从 polyrepo 到 monorepo，前端代码仓库改造工程实践",
    "url": "https://www.infoq.cn/article/2WWCPO7WPm0607FLZgav",
    "summary": "<p></p><h2>引言</h2><p></p><p></p><p>随着业务的发展和架构的迭代升级，近一年 FreeWheel 核心业务团队对前端技术栈进行了大规模升级改造，针对多个新业务页面的开发需求，对产品按照业务模块进行了划分，形成了多团队协作开发的 polyrepo 模式。而对于团队之间的组件或模块的共享问题，结合社区的实践和公司内部尝试的经验，我们决定采用 monorepo 模式来满足共享需求，并对将代码仓库改造成 monorepo 进行了技术尝试和落地，下面是具体介绍。</p><p></p><p></p><h2>monorepo 与 polyrepo 对比</h2><p></p><p></p><p>monorepo 和 polyrepo 是两种代码仓库的组织形式。monorepo 是指包含多个不同项目的单一代码仓库，并且内部子项目具有明确定义的关系（如下图）。对，它不只是简单的把多个代码仓库放到一个代码仓库下，而是要去明确的定义这些代码仓库之间的关系。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/76/7628c160109e649dfa4be95403f08739.png\" /></p><p></p><p>而 polyrepo 是指每个应用或库分别拥有各自的代码仓库，不会和其他代码仓库合并（如下图）。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/e5/e594a3f7c6b1ed7e522ac9286c1f3c78.png\" /></p><p></p><p>以下是二者的对比，可以看出，结合二者的特点既可以避免重复的配置，又能够灵活根据团队情况合理控制仓库的数量和大小，并且在 monorepo 模式下，可以结合发包功能来解决多团队之间的共享问题。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/ac/ac5aa1291db5ad84d0045f59476f49fa.png\" /></p><p></p><h2>开发现状</h2><p></p><p></p><p>目前 FreeWheel 核心业务团队就是以 polyrepo 的架构进行多团队迭代开发，整个产品按照功能模块和团队情况进行了拆分，各个页面独立开发独立部署。在 polyrepo 架构下，每个代码仓库内部的共享问题很容易解决，把需要共享的组件或功能提取到合适的文件里再导出即可。但对于不同代码仓库之间的共享问题就不是很容易解决了。对于底层的结构组件，FreeWheel 有一套自建的基础组件库供业务组开发人员使用。但是对于含有业务逻辑的上层组件，目前没有一个灵活统一的方案来满足这一需求。</p><p></p><p>在实践之前，我们明确了实践过程中可能会遇到的问题。</p><p></p><p>第一，已有代码仓库的 monorepo 转化成本问题。其需要对项目结构进行改造，包括但不限于 NodeJS，Yarn 的版本，插件安装配置，项目和各个包的 package.json 和 tsconfig.json，lint 和 format 的配置。这对于中小厂公司或者中小团队来说是不小的开销。如果各自为政，重复造轮子，则是一种低 ROI 的行为。</p><p></p><p>第二，维护多包依赖关系成本问题。当一个 monorepo 里拥有多个包（可发布的子仓库）时，手动维护它们之间的依赖关系是很耗费精力的。如下图的例子所示，这是一个 monorepo 内部的依赖关系图。当 E 包升级发布新版后，由于上层的 C 包和 F 包依赖 E 包，所以 C 包和 F 包需要跟着升级。那么依赖 C 包和 F 包的上上层包，也需要升级。这样递归下去，直到依赖链路上的包都升级完成。显然靠人工来完成升级是件费时费力且易出错的事情。</p><p></p><p>因此，带着这两个问题，我们在接下来的技术选型和实践过程中有倾向性的进行了取舍。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/a5/a5aa19a867a80a61de52f70e8dfaab4b.png\" /></p><p></p><h2>技术选型</h2><p></p><p></p><p>基于以上阐述，我们近期对此上述需求和问题进行了技术调研和实践，尝试在 polyrepo 的基础上，对每个代码仓库进行 monorepo 转化，使每个仓库可以按需拥有多个子仓库，并且拥有发布 npm 包的能力。这样在不破坏现有产品架构的前提下，解决了团队之间代码共享的问题。这里说明一点，本次实践基于的前端项目使用的是 Yarn 3+ 版本，Node.js 16+ 版本，TypeScript 4.8 版本及以上。</p><p></p><p>其实在此之前，公司内部已经进行过一些尝试。我们创建了一个 monorepo，可共享的组件或功能都放在这个 monorepo 里进行统一发布和维护。随着使用发现，开发共享组件需要频繁切换仓库，跨仓库的本地调试不是很方便。并且，组件都放在一个 monorepo 里，对于组件所属哪个团队变得模糊。我们设想，如果在各自团队的代码仓库下也能发布需要共享的组件，这样所属明确，与这个统一的 monorepo 结合使用，也更加灵活方便。</p><p></p><p>因此，我们尝试给各个团队自己的仓库进行 monorepo 转化。目前社区内的 monorepo 工具还是比较丰富的。我们着重调研了以下几个工具。从稳定性、上手成本、功能，需求匹配度及收费情况等方面考虑进行技术选型，最终决定采用 Yarn workspace 来作为前端 monorepo 的管理方案。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/f3/f370d60677829f81133a9cc92118e713.jpeg\" /></p><p></p><p>这里简单介绍一下。在 Yarn 的生态下，Yarn workspace 是 yarn 官方提供的一个 monorepo 管理方案。根据项目中包之间的关系进行链接，避免多个包之间相同依赖的重复安装，以节省空间。同时共享一个 lock 文件，统一各个包依赖的版本。</p><p></p><p>它的使用比较简单，在 package.json 中加入如下设置就可以声明一个 workspace，workspace 内的每一个 folder 都是单独的包，或称为子仓库。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/71/718c948953c028bccf940727ee9b81f4.png\" /></p><p></p><p>同时 Yarn workspace 提供了 workspace 协议，用于在 package.json 声明依赖时实时访问最新代码，有效避免了 yarn link 产生的系统环境污染，示例如下：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/c9/c984acc01be3eab2e752801932bfead3.png\" /></p><p></p><p>针对维护多包依赖问题，Yarn 社区也提供了解决方案——Yarn version plugin。与社区中针对此问题的其他工具（比如 changesets）类似，它可以自动化的管理各个包的升级过程。该插件通过 Yarn git 等一系列内置插件，根据语义化版本的规则，提供了实用的 CLI 命令，比如 yarn version patch，给包升级 patch 版本，后边可以使用 --deferred 并结合 yarn workspace 来实现多包批量升级等等。</p><p></p><p>下面具体阐述我们的实践过程。</p><p></p><h2>monorepo 工程实践</h2><p></p><p></p><h3>实现一键转换与更新的 CLI 命令</h3><p></p><p></p><p>首先，我们针对上文提到的 monorepo 转化成本问题，实现了一个自动化转化 monorepo 的 CLI 工具。其自动化改造的主要过程如下图所示：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/5d/5dcba8f0c084c84827b1423d620625cf.png\" /></p><p></p><p>脚本首先会生成 workspace 由 yarn workspace 来管理。然后为项目更新配置，下载所需插件等，比如下面的自动升级 yarn 及其配置。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/ae/aeb74571e48d7802478faef55573a559.png\" /></p><p></p><p>安装 yarn workspace-tools 和 yarn version 插件。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/7b/7bcf9450c71838c1d097a8a41a53ee8e.png\" /></p><p></p><p>更新项目 package.json。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/f4/f4993bc6360c0979e554efc315cda3f1.png\" /></p><p></p><p>修改 tsconfig.json，方便 packages 里的包配置可以用 extend 方式快速的继承。还可以根据需要修改 eslint，prettier 以及.gitignore 等配置文件。</p><p></p><p>接下来会生成用于快速创建，升级，构建，发布包的各个脚本，并与 husky 集成，后面会做详细阐述。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/13/139f2898f5c8139e388a38a0dc1ab50c.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/6f/6fddfad724f34ce10f79c1848b9e0434.png\" /></p><p></p><p>最后调用生成的脚本自动创建一个 hello-world 包并构建发布，用户可以通过 npx -y 命令快速运行 hello-world 包，来检查项目是否已经改造完成。</p><p></p><p>基于此工具，通过运行下面的一行命令，已有项目仅需几分钟就可以自动地完成改造，转变成开箱即用的 monorepo 项目。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/01/013ab849433042b39b7d849afd1c977c.png\" /></p><p></p><p>此外，为了优化用户体验的，此工具添加了一些常用的参数和命令。-h 用于打印帮助信息，方便用户快速查看可用参数和命令。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/da/da824bceddeb1cb5b8cab08d57209bc2.png\" /></p><p></p><p>-v 用于打印版本。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/4f/4f2872431ce13951f25ab1c74dff3bde.png\" /></p><p></p><p>-c 用于查看功能迭代历史。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/7a/7a958d6c5ac0ae434b125d028dd1ad89.png\" /></p><p></p><p>update 交互式快速更新所需配置以及 update:all 一键更新所有配置。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/4d/4daccc4d691fc7563cb2fa77ce3d66d9.png\" /></p><p></p><h3>实现自动化升级多包依赖的脚本</h3><p></p><p></p><p>下面就来具体看看该工具生成的自动化脚本，主要使用了 yarn workspace，yarn version 插件以及 zx 库。</p><p></p><p></p><h4>pre-push 脚本</h4><p></p><p></p><p>首先，我们基于 husky 拦截了 git push，在 push 之前进行多包升级的检查以及自动更新版本并提交。具体流程可见下图。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/53/53f8ab216ff8eb0108f72ed699f18fc9.png\" /></p><p></p><p>下面来说一下细节。命令首先会执行 git fetch 来更新本地的分支，已获得最新的远端 commit 用于 yarn version 的比较。待使用者选择了具体的提交分支后，脚本会自动通过设置 changesetBaseRefs 来给 yarn version 提供待对比的 commit。接着执行 yarn version 提供的 check 功能，自动的递归检查所有待升级包及其依赖包是否已经设置了升级策略或当前版本是否已存在。如果检查失败，使用者可以利用其提供的交互式命令方便的对各个包的升级策略进行设置，此处的升级策略遵循的就是我们常见的语义化版本规范。设置完成后会生成一个 yml 文件，例子如下。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/f7/f7f1286bca1451548da478cc40846d6f.png\" /></p><p></p><p>接下来脚本会再次验证升级策略是否设置完全，在检查无误后，会执行 yarn version 的消费功能完成特定包 package.json 文件 version 字段的修改，这里的消费指的是消费刚才生成的那个 yml 文件，消费完即删除。所以，该流程不会在 commit 里增添无关的文件改动。结合 FreeWheel 的分支管理策略，在消费阶段，脚本会根据在开始阶段使用者选择的分支来判断是否给包版本打 tag，用以区别是线上紧急修复问题的发版（1.0.5-V1.1）还是平时主分支的发版（1.0.5）。最后，脚本在检查完所有待升级包的新版本无误后，会自动生成一次 commit 并完成 git push。</p><p></p><p>整个过程对使用者来说几乎是自动的和透明的。一旦检查有问题，脚本会返回明确的错误信息和解决办法，无需担心有过多的心智负担。</p><p></p><h4>创建新包脚本</h4><p></p><p></p><p>为了方便开发者快速创建新包，我们也提供了相应的自动化脚本，流程如下图所示。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/59/599d267bcd17d2a451c7bca13445fa23.png\" /></p><p></p><p>命令会检查包名的合理性，检查无误后会在新包的路径下自动创建其所需要的 package.json，tsconfig.json，.npmignore，index.ts，以及组件 app.tsx 等文件。该脚本提供了快速集成单元测试的功能，也会自动创建单元测试所需要的项目配置文件，项目依赖，以及组件的测试用例。目前支持 vitest 单元测试和 react 组件，测试用例包括一个 hook (useState) 以及一个鼠标点击事件，代码如下。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/e6/e6f31bfbe1a859ed81f0bceb0e739c4f.png\" /></p><p></p><p>这样一个带有组件测试用例的可构建发布的包就创建完成了，开发者可以在此基础上自行添加业务逻辑和测试用例，省去了创建新包需要做的一些额外的的配置工作。</p><p></p><h4>交互式更新包脚本</h4><p></p><p></p><p>除了创建新包，工具还提供了手动更新包版本的自动化脚本，流程如下图所示。和 pre-push 的功能一样，命令会去检查多包之间依赖关系，确保需要升级的包都设置了对应的策略，避免漏升。该命令可以方便的修改多包版本，结合 pre-push 脚本使用效率更佳。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/4e/4efad1a21f4cff597f93a75e3cc972cc.png\" /></p><p></p><h4>手动构建发包脚本</h4><p></p><p></p><p>此外，该工具也提供了用于构建和发布包的自动化脚本，流程如下图所示。脚本接收待发布的包名作为参数（可以多个），通过 yarn workspaces 的过滤功能进行遍历，构建和发布，最终结果会打印到终端。该功能可用于需要快速发布一些测试包来进行调试的场景，也可以结合上面更新包的脚本来快速发布线上包。使用者可以自由组合，灵活完成各自的发包需求。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/6d/6d803684633ce286abec849646a814a8.png\" /></p><p></p><h4>集成于 Jenkins 及 Slack 的统一发包 CI Job</h4><p></p><p></p><p>基于 FreeWheel CICD 团队为开发人员提供的一套持续集成持续部署流水线工具，开发人员可以方便的通过简单的配置，自由创建流水线完成各自项目的自动化任务。本次实践也提供了 CI 支持，将构建发包的工作集成到了 Jenkins 流水线，团队在 review &amp; merge 相应代码到指定分支后，流水线会自动触发，在任务里判断是否有需要发布的新包，来自动完成各个包的安装，测试，构建以及发布。同时流水线将结果集成到了指定的 Slack Channel，第一时间通知开发人员发包的结果，实现端到端的自动化。发包的端到端流程图下：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/e1/e148c062f3e867d86e0aa157dacfc20b.png\" /></p><p></p><p>Slack 的通知结果分为 lint，build 以及 publish 三类，方便开发者区分具体的失败原因。如果是 lint 或 build 失败，那很有可能是代码有 bug，需要修复问题并重新 review。如果是 publish 失败，那有可能是版本号已经存在，只需用上述提到的快捷命令更新具体失败的包并再次提交即可。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/6d/6dd60a898a7f2daa3f6d45a4611db8f1.png\" /></p><p></p><p>至此，改造 monorepo 进行升级发包的端到端流程就完成了。</p><p></p><h2>总结</h2><p></p><p></p><p>以上就是本次实践的全部内容，我们在原有 polyrepo 的基础上，对已有代码仓库的 monorepo 转化进行了实践，概括起来实现了以下功能：</p><p></p><p>一键快速（几分钟）改造代码仓库为 monorepo 的 CLI增强 pre-push，自动对项目下的包进行检查和升级生成创建，升级，发布等对包的快捷命令和脚本集成 Jenkins 流水线，自动发布新包并通知开发人员撰写工具帮助文档和在线手册</p><p></p><p>目前我们已经在四个应用级代码仓库实践了 monorepo 方案，发布公共组件数十个。下一阶段我们会持续优化用户体验，比如对自动生成单元测试做进一步完善，对创建新包做更细致的校验，尝试搭建已发布组件的文档系统等。随着使用的团队越来越多，会提供更多实用的功能。</p><p></p><h4>作者介绍</h4><p></p><p></p><p>荣剑英，FreeWheel 高级开发工程师，毕业于天津大学，对前端框架开发，前端工程化等领域感兴趣，热衷新技术的探索与实践。</p>",
    "publish_time": "2023-02-14 10:17:10",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "微软称ChatGPT版Bing将登陆Android和iOS平台，Bing App下载量一夜间猛增10倍",
    "url": "https://www.infoq.cn/article/wyWO1PjbmyLpBMQxVOxy",
    "summary": "<p>2月14日，据 Windows Latest报道，微软在发送给早期使用者的电子邮件表示，目前已正在积极准备ChatGPT版Bing的“移动体验”。也有消息人士表示，目前微软正在优化 <a href=\"https://www.infoq.cn/article/N2DHuiaEtcIEeXvjbVLC\">ChatGPT Bing</a>\" 移动端的页面，预计可能会在未来几周登陆 Android 和 iOS平台。</p><p></p><p>虽然细节不多，但消息人士证实，<a href=\"https://www.infoq.cn/article/9wzrGiMTl8XClRgSfL9A\">微软</a>\"正在为Android和iOS的Bing人工智能聊天功能开发一个\"实质性的优化界面\"，其中包括\"全新的OpenAI驱动的内容\"。不过在发给包括Windows最新版本在内的测试人员的电子邮件中，微软表示移动体验还没有准备好。</p><p></p><p>有趣的是，在微软透露出该消息之前，<a href=\"https://www.infoq.cn/article/FB6BxlokIrMQgNLl3Vzt\">Google</a>\"也宣布了移动版的Brad，并且正计划在本月某个时候为特定用户推出Brad。</p><p></p><p>事实上，微软已经于本周一开始，陆续向申请用户开放新版必应。但略显尴尬的是，嵌入ChatGPT的微软新版Bing将Chrome等浏览器直接拒之门外。因此用户想要申请试用新版Bing，就不得不从Chrome转投到<a href=\"https://www.infoq.cn/article/XTw4I4heyyHZSWHNoh7E\">Edge</a>\"的怀抱，这也使得微软Edge浏览器的下载需求量陡然大增。</p><p></p><p>据第三方数据公司data.ai上一周的分析显示，新版Bing应用程序的全球下载量在一夜之间猛增10倍。这使得该应用蹿升到了苹果App Store应用商店最受欢迎的免费应用榜中的第十位，并使其成为第二大最受欢迎的免费生产力应用，仅次于谷歌邮箱Gmail。微软iOS版Edge浏览器也位居实用类应用程序中的第三名。</p>",
    "publish_time": "2023-02-14 10:29:35",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "改变一个字符后，我的 Go 程序快了 42%",
    "url": "https://www.infoq.cn/article/wYFJDJqDhmQ6BCI9JygI",
    "summary": "<p></p><blockquote>我要先声明通常的基准测试警告：42% 的加速是在我的计算机上运行程序的数据时测量的，所以大家对这个数字请持保留态度。</blockquote><p></p><p></p><h3>这个Go 程序是做什么的？</h3><p></p><p></p><p>c<a href=\"https://github.com/hmarr/codeowners\">odeowners</a>\" 是一个 Go 程序，它根据 <a href=\"https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners#codeowners-syntax\">GitHub CODEOWNERS</a>\" 文件中定义的一系列规则，打印出存储库中每个文件的所有者。可能有这样的规则：所有以 .go 结尾的文件都归 @gophers 团队所有，或者 docs/ 目录下的所有文件都归 @docs 团队所有。</p><p></p><p>当考虑一个给定的路径时，最后匹配的规则获胜。一个简单但天真的匹配算法会向后迭代每条路径的规则，当找到匹配时就会停止。智能算法确实存在，但那是以后的事了。Ruleset.Match 函数如下所示：</p><p></p><p><code lang=\"null\">type Ruleset []Rule\n\n\nfunc (r Ruleset) Match(path string) (*Rule, error) {\n  for i := len(r) - 1; i &gt;= 0; i-- {\n    rule := r[i]\n    match, err := rule.Match(path)\n    if match || err != nil {\n      return &amp;rule, err\n    }\n  }\n  return nil, nil\n}</code></p><p></p><p></p><h3>用 pprof 和 flamegraph 查找“slow bits”</h3><p></p><p></p><p>当在一个中等规模的存储库中运行该工具时，它的运行速度有点慢：</p><p><code lang=\"null\">$ hyperfine codeowners\nBenchmark 1: codeowners\n  Time (mean ± σ):      4.221 s ±  0.089 s    [User: 5.862 s, System: 0.248 s]\n  Range (min … max):    4.141 s …  4.358 s    10 runs</code></p><p></p><p>为了了解程序将时间花在哪里，我用 pprof 记录了一个 CPU 配置文件。你可以通过将以下代码片段添加到 main 函数的顶部来获得生成的 CPU 配置文件：</p><p>&nbsp;</p><p><code lang=\"null\">pprofFile, pprofErr := os.Create(\"cpu.pprof\")\nif pprofErr != nil {\n  log.Fatal(pprofErr)\n}\npprof.StartCPUProfile(pprofFile)\ndefer pprof.StopCPUProfile()</code></p><p></p><p>题外话：我经常使用 pprof，所以我将这段代码保存为<a href=\"https://code.visualstudio.com/docs/editor/userdefinedsnippets\"> vscode 代码片段</a>\"。我只要输入 pprof，点击 tab，就会出现这个代码片段。</p><p></p><p>Go 附带了一个方便的交互式配置文件可视化工具。通过运行以下命令，然后导航到页面顶部菜单中的火焰图视图，将配置文件可视化为火焰图。</p><p></p><p><code lang=\"null\">$ go tool pprof -http=\":8000\" ./codeowners ./cpu.pprof</code></p><p></p><p>正如我所料，大部分时间都花在了 Match 函数上。CODEOWNERS 模式被编译成正则表达式，Match 函数的大部分时间都花在 Go 的正则表达式引擎中。但是我也注意到，很多时间都花在了分配和回收内存上。下面的火焰图中的紫色块与模式 gc|malloc 相匹配，你可以看到它们在总体上表示程序执行时间的一个有意义的部分。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/6e/6e900cddea9e9cf9695e8a48792c63df.png\" /></p><p></p><p></p><h3>使用逃逸分析跟踪搜寻堆分配</h3><p></p><p></p><p>因此，让我们看看是否有任何分配可以消除，以减少 GC 的压力和在 malloc 花费的时间。</p><p></p><p>Go 编译器使用一种叫做逃逸分析（escape analysis）的技术来计算出何时需要在堆上驻留一些内存。假设一个函数初始化了一个结构，然后返回一个指向它的指针。如果该结构是在堆栈中分配的，那么一旦函数返回，并且相应的堆栈框架失效，返回的指针就会失效。在这种情况下，Go 编译器将确定该指针已经“逃离”了函数，并将该结构移至堆中。</p><p></p><p>你可以通过向 go build 传递 -gcflags=-m 来看到这些决定：</p><p></p><p><code lang=\"null\">$ go build -gcflags=-m *.go 2&gt;&amp;1 | grep codeowners.go\n./codeowners.go:82:18: inlining call to os.IsNotExist\n./codeowners.go:71:28: inlining call to filepath.Join\n./codeowners.go:52:19: inlining call to os.Open\n./codeowners.go:131:6: can inline Rule.Match\n./codeowners.go:108:27: inlining call to Rule.Match\n./codeowners.go:126:6: can inline Rule.RawPattern\n./codeowners.go:155:6: can inline Owner.String\n./codeowners.go:92:29: ... argument does not escape\n./codeowners.go:96:33: string(output) escapes to heap\n./codeowners.go:80:17: leaking param: path\n./codeowners.go:70:31: []string{...} does not escape\n./codeowners.go:71:28: ... argument does not escape\n./codeowners.go:51:15: leaking param: path\n./codeowners.go:105:7: leaking param content: r\n./codeowners.go:105:24: leaking param: path\n./codeowners.go:107:3: moved to heap: rule\n./codeowners.go:126:7: leaking param: r to result ~r0 level=0\n./codeowners.go:131:7: leaking param: r\n./codeowners.go:131:21: leaking param: path\n./codeowners.go:155:7: leaking param: o to result ~r0 level=0\n./codeowners.go:159:13: \"@\" + o.Value escapes to heap</code></p><p></p><p>输出有点嘈杂，但你可以忽略其中的大部分。由于我们正在寻找分配，“move to heap”是我们应该关注的短语。回顾上面的 Match 代码，Rule 结构被存储在 Ruleset 片中，我们可以确信它已经在堆中了。由于返回的是一个指向规则的指针，所以不需要额外的分配。</p><p></p><p>然后我看到了--通过分配 rule := r[i]，我们将堆中分配的 Rule 从片中复制到堆栈中，然后通过返回 &amp;rule，我们创建了一个指向结构副本的（逃逸）指针。幸运的是，解决这个问题很容易。我们只需要将 &amp; 号往上移一点，这样我们就引用了片中的结构，而不是复制它：</p><p></p><p><code lang=\"text\"> func (r Ruleset) Match(path string) (*Rule, error) {\n for i := len(r) - 1; i &gt;= 0; i-- {\n-rule := r[i]\n+rule := &amp;r[i]\n match, err := rule.Match(path)\n if match || err != nil {\n-return &amp;rule, err\n+return rule, err\n }\n }\n return nil, nil\n }</code></p><p></p><p>我确实考虑过另外两种方法：</p><p></p><p>将 Ruleset 从 []Rule 更改为 []*Rule，这意味着我们不再需要显式引用该规则。返回 Rule 而不是 *Rule。这仍然会复制 Rule，但它应该保留在堆栈上，而不是移动到堆上。</p><p></p><p>然而，由于此方法是公共 API 的一部分，这两种方法都会导致一个重大的变化。</p><p></p><p>无论如何，在做了这个修改之后，我们可以通过从编译器获得一个新的跟踪并将其与旧的跟踪进行比较来看看它是否达到了预期的效果：</p><p></p><p><code lang=\"null\">$ diff trace-a trace-b\n14a15\n&gt; ./codeowners.go:105:7: leaking param: r to result ~r0 level=0\n16d16\n&lt; ./codeowners.go:107:3: moved to heap: rule</code></p><p></p><p>成功了！分配消失了。现在让我们看看删除一个堆分配会如何影响性能：</p><p></p><p>&nbsp;</p><p><code lang=\"null\">$ hyperfine ./codeowners-a ./codeowners-b\nBenchmark 1: ./codeowners-a\n  Time (mean ± σ):      4.146 s ±  0.003 s    [User: 5.809 s, System: 0.249 s]\n  Range (min … max):    4.139 s …  4.149 s    10 runs\n\n\nBenchmark 2: ./codeowners-b\n  Time (mean ± σ):      2.435 s ±  0.029 s    [User: 2.424 s, System: 0.026 s]\n  Range (min … max):    2.413 s …  2.516 s    10 runs\n\n\nSummary\n  ./codeowners-b ran\n    1.70 ± 0.02 times faster than ./codeowners-a</code></p><p></p><p>由于该分配是针对匹配的每一条路径进行的，因此在这种情况下，删除它会获得 1.7 倍的速度提升（这意味着它的运行速度要快 42%）。对一个字符的变化来说还不错。</p><p></p><p>作者简介：</p><p>&nbsp;</p><p>Harry，在 GitHub 工作，负责领导团队为开发人员开发安全产品。Dependabot 共同创始人之一。</p><p>&nbsp;</p><p>原文链接：</p><p>&nbsp;</p><p>https://hmarr.com/blog/go-allocation-hunting/#circle=on</p>",
    "publish_time": "2023-02-14 11:32:55",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "从谷歌辞职后，我创办了家年营收近百万美元的公司，我一年挣了6000美元，网友：什么都不干，赔钱最慢",
    "url": "https://www.infoq.cn/article/oy53MuMMJiIsixTKMLjR",
    "summary": "<p></p><blockquote>五年之前，我辞去了谷歌那边的开发岗，出来建立了自己的软件公司。</blockquote><p></p><p>&nbsp;</p><p>刚开始那几年，公司业务一直没有起色。月收入甚至就是几百美元的水平，长期处于亏损状态。</p><p>&nbsp;</p><p>到第三年年中，我开发了一款名叫TinyPilot的设备，能帮助用户在不安装任何软件的前提下<a href=\"https://www.infoq.cn/article/9W1zPkwUqT1Zyx0QGt3J\">远程控制</a>\"自己的计算机。这款产品意外走红，也成了我们之后的业务关注重点。</p><p>&nbsp;</p><p>2022年，TinyPilot一共创造了81.2万美元的营收，比2021年增长了76%。</p><p>&nbsp;</p><p>在本文中，我想跟大家好好聊聊自己的白手起家<a href=\"https://archsummit.infoq.cn/2023/beijing/track/1453\">创业</a>\"路，特别是这第五年里的经验和教训。</p><p>&nbsp;</p><p>首先来看下这几年的公司的营收情况，直到去年，TinyPilot年营收增长至81.2万美元。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/9c/9caff51b7ad09ecc1c13db1027af149d.png\" /></p><p></p><p>下面这个表格，是我想让你知道这些钱都花在了哪。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/05/0559c45b80964c6893242c4b11d11510.png\" /></p><p></p><p>&nbsp;营收猛增35万美元听起来确实爽，但一年忙下来就6000美元的纯利润实在有点说不过去。而且我不给自己发工资，所以这6000美元就是过去一整年我从公司身上赚取的全部收入。不过光明的前景还是让我对新的一年充满期待。</p><p>&nbsp;</p><p>去年增加的一项主要成本，就是电气工程。整个2021年，TinyPilot的电气工程供应商都在努力跟进产品发展思路，但效果一般。2021年底，我换了一家更符合需求的新供应商，他们水平更高，但价格也是前一家的3倍。</p><p>&nbsp;</p><p>另外，芯片的持续短缺迫使我们频繁更改设计，这也增加了工程时间和原材料成本。我们往往需要在用完现有物料储备后就重新设计电路板，所以得反复支付额外费用来加快流程。</p><p>&nbsp;</p><p>我们最终到去年9月才摆脱了重新设计的困局。希望第四季度的火热表现也能在2023年稳定延续。第四季度，特准的利润达到了2.86万美元，如果新一年也能保持月均9500美元的平均收益，那我可就太开心了。</p><p></p><h2>TinyPilot有新网站了</h2><p></p><p>&nbsp;</p><p>在2020年刚刚推出<a href=\"https://tinypilotkvm.com/\">TinyPilot</a>\"时，配套上线的网站和徽标只是勉强能用、暂时顶住。之后产品迅速发展，所以我很长一段时间都没余力再做优化。</p><p>&nbsp;</p><p>2022年，我终于招了一家设计机构创作新的徽标，还有重新布置整个网站。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/06/06f761e029732e81e7ebfc0086fbee69.png\" /></p><p></p><p>TinyPilot网站重新设计前后</p><p>&nbsp;</p><p>有经验的朋友肯定知道，跟设计机构合作可说是既费钱又费神，但这次的结果确实让人满意。旧网站明显就是业余爱好级别，而新设计终于有了一家公司的样子。我怀疑之所以销售额迅速提升，有一部分就是新网站所带来的。</p><p>&nbsp;</p><p></p><h3>TinyPilot团队从6人增加到7人</h3><p></p><p>&nbsp;</p><p>2021年底，TinyPilot的团队构成是：</p><p>&nbsp;</p><p>我，唯一的创始人；3名兼职软件开发人员；2名本地兼职员工，负责组装设备和寄送订单；其中1位还兼顾客服工作。</p><p>&nbsp;</p><p>2022年底，我们新增2名支持工程师并调整了职责划分，现在的团队构成是：</p><p>&nbsp;</p><p>我，唯一的创始人；2名兼职软件开发人员；2位本地兼职员工，负责组装设备和寄送订单；2人现在都兼顾客服工作；2名兼职支持工程师。</p><p>&nbsp;</p><p>支持工程师的加入，就像是拼图中缺失的一块终于补齐。在他们加入之前，我就是唯一的<a href=\"https://archsummit.infoq.cn/2023/beijing/track/1456\">技术支持</a>\"负责人，这部分工作花掉了我大概20%的时间。现在，我用在请求支持方面的时间已经低于5%，客户服务已经能够快速到位。</p><p>&nbsp;</p><p>支持工程师还做了不少我没时间完成的工作，比如调查复杂的<a href=\"https://www.infoq.cn/article/eGbSZBSKWEDxspQq8FLh\">bug</a>\"、编写文档和改进诊断工具。</p><p>&nbsp;</p><p>愈发壮大的团队也拓展了我的管理技能。2021年，TinyPilot的工作流程还很简单，几乎每个人都作为独立的单位完成工作。结果要么提交给我，要么直接提交给客户。当员工之间需要相互协调时，沟通双方也肯定是同一职能上的两位同事。</p><p>&nbsp;</p><p>而支持工程师的加入，意味着我得搞清楚不同职能的团队间要如何协作。当支持请求要求履行者和支持工程师共同配合完成时，他们要怎么彼此对接？支持工程师和<a href=\"https://archsummit.infoq.cn/2023/beijing/track/1477\">开发团队</a>\"间的反馈循环又该如何设计？</p><p>&nbsp;</p><p></p><h3>PicoShare成为增速最快的项目</h3><p></p><p>&nbsp;</p><p>过去几年以来，我最讨厌的事情就是通过Google Drive或者Dropbox之类的云存储服务商分享单个文件。他们不会提供直接指向文件的链接，只有指向Web界面的链接，收件人还得注册账户才能查看。如果把视频上传到Google Drive还需要经历重新编码，就算是针对浏览器播放进行了优化，整个过程也至少要15分钟。</p><p>&nbsp;</p><p>作为云存储选项的替代方案，我开发了一款名叫PicoShare的极简文件共享应用。大家只需上传一个文件，它就会生成一条可以直接共享的链接。这多简单！不用重新编码、也不用单独注册，上手就用。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b2/b2908b787ac531603f9e35fc76f83a62.png\" /></p><p></p><p>PicoShare演示</p><p>&nbsp;</p><p>虽然也有其他<a href=\"https://archsummit.infoq.cn/2023/beijing/track/1477\">开源工具</a>\"在提供类似的功能，但PicoShare的独特之处在于它不需要数据库服务器。全部负载都能在单个Docker容器内运行，而其他解决方案往往需要更复杂的编排过程。</p><p>&nbsp;</p><p>PicoShare也成为我发布过的增速最快的开源项目。在发布后的半个月内，它就拿下GitHub 600星；截至本文撰稿时，PicoShare的安装量已超10万次。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/0a/0a7ac0db644415a170d914a18f91fe57.png\" /></p><p></p><h2>经验教训</h2><p></p><p></p><h3>别当那个“最不重要的客户”</h3><p></p><p>&nbsp;</p><p>在TinyPilot网站的整个设计过程中，我犯了不少错误，其中最核心的问题就是前一家设计机构的体量跟TinyPilot根本就不搭调。</p><p>&nbsp;</p><p>那家机构其他客户的预算，基本是TinyPilot的5到20倍。起初我还以为这是好事，毕竟人家是高端设计品牌，能傍上这样的资源说出去都有面子。</p><p>&nbsp;</p><p>但实际上，TinyPilot成了他们优先级最低的项目。由于管理不善，项目成本增加、范围扩大而且成果也未能按期交付。</p><p>&nbsp;</p><p>所以现在挑选新的供应商时，我会询问自己跟他们的其他客户相比有何差异。如果在规模、收入或者所处行业方面区别太大，我就会果断选择其他服务伙伴。</p><p></p><h3>以50%的容量运行</h3><p></p><p>&nbsp;</p><p>如果你的业务能力刚刚好够满足客户需求，那肯定是最佳运营状态吧？这样员工就能在每周保持40小时工作的同时，准时完成每笔订单并回应每个支持请求。他们既不会闲着无聊，也不会累到心慌，一切都完美和谐……</p><p>&nbsp;</p><p>但大家觉得这事可能吗？以100%的容量运行绝对非常可怕，这意味着整个公司没有任何犯错空间。一旦销量激增或者员工临时休假，业务立刻就会陷入混乱。</p><p>&nbsp;</p><p>我的目标是让TinyPilot的每个人都以50%左右的负荷量工作。换句话说，有50%属于必须完成的被动工作，另外50%是需要主动找来做的内容。虽然在某些岗位上达不到50/50的绝对平衡，但大家应该能明白我的意思。</p><p>&nbsp;</p><p>技术支持团队就是50/50的最佳案例：他们把一半时间用来响应支持请求，另一半时间用来寻找防止用户需要申请支持的好办法。这类任务包括修复产品中的bug、编写文档和改进诊断工具。</p><p>&nbsp;</p><p>TinyPilot中的每个团队都由2人组成。这样即使有人不在，另一位也能先放放主动工作、优先处理时间敏感任务，整个体系仍然能够运作得井井有条。比方说，某个人气YouTube频道提到了我们而瞬间拉高了订单数量，那我们也一直有多余的容量消化这部分业务。</p><p><img src=\"https://static001.geekbang.org/infoq/1b/1b1e21bdb82158f0af6e14c7efafda54.png\" /></p><p></p><h3>Ansible和git不是软件分发工具</h3><p></p><p>&nbsp;</p><p>在刚开始设计TinyPilot时，我不知道该怎么分发Linux软件。</p><p>&nbsp;</p><p>所以在TinyPilot原型发布时，我用上了自己了解的工具：bash脚本、Ansible和git。Bash脚本负责引导一个Ansible环境，再执行相应的Ansible playbook。Ansible会安装依赖项，对操作系统做出必要更改，再克隆TinyPilot git代码仓库。</p><p>&nbsp;</p><p>整个安装过程勉强能用，体验不太好。优点就是可靠、不需要用户做手动配置，但缺点是速度慢。</p><p>&nbsp;</p><p>两年之后，TInyPilot的更新过程可说是一团糟。其仍然依赖于当初原型时的基础，只是现在的依赖项体系更复杂了。Ansible角色依赖于Git代码仓库，而Git代码仓库又依赖于其他Ansible角色，后者则依赖于YAML文件中的一大堆参数。任何微小的变更都足以吞噬几个礼拜的开发时间。</p><p>&nbsp;</p><p>而这一切，都是因为我从来没认真学习过标准的Linux打包工具。</p><p>&nbsp;</p><p>到2022年，TinyPilot团队终于学会了使用Debian软件包。其实根本就没我想象中那么难，我本来以为得部署各种包服务器和密钥服务器，但事实证明并不需要。只要找到靠谱的操作指南，整个过程相对来说还是挺简单的。</p><p>&nbsp;</p><p>Debian加快了我们的开发步伐，它能更早发现严重错误，让我们轻松将预发布版本部署到测试设备上。跟现在相比，之前的安装系统实在是太复杂、太笨拙了。</p><p></p><h2>回顾去年定下的目标</h2><p></p><p>&nbsp;</p><p>我为2022年定下了三个高层次目标，下面看看到底完成得怎么样：</p><p></p><h3>将TinyPilot的年营收提升至100万美元</h3><p></p><p>&nbsp;</p><p>结果：TinyPilot的营收增长76%，来到81.2万美元；评分：B</p><p>&nbsp;</p><p>我其实知道100万这个目标定得有点高，恐怕很难达到，但最终结果已经相当接近了，着实令人振奋不已。</p><p></p><h3>每周花20个小时管理TinyPilot</h3><p></p><p>&nbsp;</p><p>结果：跟2021年相比，2022年我花在TinyPilot管理上的时间反而更多了。评分：D</p><p>&nbsp;</p><p>我本来打算把工作尽量分给他人，再做点自动化升级，争取把每周的管理时间缩短到20个小时，但明显没能做到。随着销售额增加、支持工程团队的组建还有芯片短缺问题的蔓延，我的管理时间反而变长了。</p><p></p><h3>推出TinyPilot Voyager 3</h3><p></p><p>&nbsp;</p><p>结果：我们甚至连设计工作都没做完评分：F</p><p>&nbsp;</p><p>TinyPilot之前一直使用Raspberry Pi 4B作为核心硬件。Pi 4B拥有出色的生态系统，但问题是硬件相对昂贵、而且难以与定制芯片相集成。</p><p>&nbsp;</p><p>我为2022年定下的计划，是设计一块定制化电路板来对接更轻薄、更便宜的Raspberry Pi Compute Module 4。这本来可以把制造成本降低最高60%，同时简化我们的硬件设计。</p><p>&nbsp;</p><p>但实际情况是，我们的所有硬件工程时间都花在了解决制造问题和供应短缺上，所以在新产品方面没能取得任何进展。</p><p></p><h2>展望第六年</h2><p></p><p></p><h3>每周花20个小时管理TinyPilot</h3><p></p><p></p><p>我知道去年这个目标没能达成，但现在这真的成了我的首要任务。我对2023年充满希望，过去一年完成的很多工作都为我腾出手来奠定了基础。</p><p>&nbsp;</p><p></p><h3>把净利润推向10万美元</h3><p></p><p></p><p>在TinyPilot诞生的前两年半，我主要关注业务增长。无论每月能售出20台设备还是2000台设备，我所支付的硬件和软件工程成本都是一样的，所以销量必须要达到一定规模才能让业务获得可持续性。</p><p>&nbsp;</p><p>在2023年的大部分时间里，TinyPilot的生产都受到了物料供应的限制。虽然被这方面原因束缚了业务拓展的手脚令人沮丧，但我也可以借此机会放慢脚步、专注于创造更大的利润空间。</p><p>&nbsp;</p><p>TinyPilot一直大致维持着收支平衡。我觉得只要能尽量减少对硬件的重新设计，那新一年把利润推向10万美元并不是太难。其实如果2022年不重新设计硬件，那我在工程支出上省下的开销大致就是10万美元，物料成本也能省下2万美元。所以只要能保持销售稳定并精简硬件设计流程，那2023年应该会成为真正开始盈利的元年。</p><p></p><h3>关闭TinyPilot办公室</h3><p></p><p>&nbsp;</p><p>自2021年初以来，我租了一间办公室，专门负责TinyPilot业务的设备组装、订单履行和库存管理。</p><p>&nbsp;</p><p>保留实体办公室确实有利于快速适应硬件和流程上的变化，但也会带来不少额外开销。今年，我打算把组装业务转移到中国，毕竟产品中用的所有零配件本来就源自中国。至于订单履约，我也打算交给第三方物流仓库去做。</p><p>&nbsp;</p><p>撤掉办公室之后，我就不用维护物理空间、管理库存和跟踪人员轮班了。把制造和订单配送外包出去，也能让TinyPilot团队拥有更灵活的工作时间和地点。&nbsp;</p><p></p><h2>我还爱创业吗？</h2><p></p><p>&nbsp;</p><p>其实每次写年终总结的时候，我都会问自己这个问题……我到底，还热爱自己当初的选择吗？</p><p>&nbsp;</p><p>2022年是艰难的一年，也是我独立生活以来最不容易的一年。虽然算不上痛苦，但我也绝不敢说经历了这样的磨炼，自己仍然热爱创业。</p><p>&nbsp;</p><p>全球芯片短缺，意味着我们始终无法以稳定的方式重复制造产品。不是这个部件缺失、就是那个制造流程断档，我们把主要精力都用在了库存耗尽前调整设计上。我们虽然挺过来了，但期间仍然出现过彻底无货可卖的窘境，而且压力很大。</p><p>&nbsp;</p><p>但这一年也有不少情况提振了我的信心。虽然我没多少时间写文章、做软件开发，但我为自己的产品深感自豪。TinyPilot的组织更大了，这帮我学习并探索出了指导各团队顺畅协同的管理方法。随着公司的发展，我也欣慰地看着各团队不断成长、积累起更深厚的职业技能。</p><p>&nbsp;</p><p>我还是喜欢这种自己当老板的感觉，我仍然热爱创业给我带来的自由感。所以在创业这条道路上，我绝对不会动摇。</p><p>&nbsp;</p><p>2022年对我的独立硬件业务来说，无疑是重要的一年。我们的营收增长至81.2万美元，有了新的产品网站，又新增了一支团队。我们经历了成长的烦恼，但这一切也教会了我：</p><p>&nbsp;</p><p>永远别当那个“最不重要的客户”！</p><p>&nbsp;</p><p>原文链接：</p><p>&nbsp;</p><p><a href=\"https://mtlynch.io/solo-developer-year-5/\">https://mtlynch.io/solo-developer-year-5/</a>\"</p>",
    "publish_time": "2023-02-14 14:18:01",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "AI赋能元宇宙游戏的畅想 | InfoQ《极客有约》",
    "url": "https://www.infoq.cn/article/SoPyPH1zzUuFs0PS9JLw",
    "summary": "<p>元宇宙是当下的顶流概念。在很多业内人士眼中，元宇宙+游戏是一个富有想象力的好故事。这几年，VR/XR、AI等技术的发展，令元宇宙游戏开发不断提速。近一年多来，爆火的AIGC迎来诸多技术创新，进一步释放了游戏行业创新活力。本期《极客有约》，我们邀请到了元宇宙创业公司MultiMetaverse CEO，七创社董事长许怡然，来给我们分享“AI赋能元宇宙游戏的畅想”。</p>",
    "publish_time": "2023-02-14 15:24:58",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]