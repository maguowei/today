[
  {
    "title": "高度关注！2022 开放原子开源峰会最新议程一览",
    "url": "https://www.infoq.cn/article/0c776b47371ec5455a2a29d4c",
    "summary": "<p>鉴于北京市疫情防控相关要求，原定于&nbsp;2022 年 7 月 25—27 日举办的 2022 开放原子全球开源峰会 ，调整为&nbsp;2022 年 7 月 27—29 日在北京亦创国际会展中心举办。对于峰会时间的调整，给诸位嘉宾、参会人员及共建单位等造成的不便，我们深表歉意！请您关注开放原子开源基金会官网（www.openatom.org）及开放原子公众号，了解最新峰会相关信息。</p><p>峰会最新议程如下：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/29/29432fcbb99e34b3f8762da6c95488bf.png\" /></p><p></p><p>根据防疫要求，为保障与会嘉宾及参会人员的健康安全，大会期间视情从严管控。所有与会嘉宾及参会人员须提供北京健康宝绿码、北京 48 小时核酸阴性证明方可入场。在坚持知情、同意、自愿原则下，鼓励接种新型冠状病毒疫苗。</p><p>温馨提示：所有与会嘉宾及参会人员亦须提前完成在线注册方可进行现场签到，否则无法进入会场。</p><p>&nbsp;</p><p>报名通道现已开启，火热报名</p><p><a href=\"https://www.bagevent.com/event/sales/k3iy7bn7z7k8mvwbe6he2mi7hq1j3n2z\">https://www.bagevent.com/event/sales/k3iy7bn7z7k8mvwbe6he2mi7hq1j3n2z</a>\"</p><p>请访问此网页，立即报名</p><p>开放征集：</p><p>诚邀您与我们共同开源共建（议题申报、峰会共建），探索中国开源繁荣生态的未来！</p><p>联系我们</p><p>2022 开放原子全球开源峰会组委会</p><p>2022summit@openatom.org</p>",
    "publish_time": "2022-07-21 10:19:51",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "C++将被取代？谷歌发布开源编程语言Carbon：与C++能双向互操作",
    "url": "https://www.infoq.cn/article/vJVZMZWbipYjHUT0B74G",
    "summary": "<p>在7月15日至21日举行的多伦多北部C++开发者大会（The Northern C++ Conference）上，谷歌工程师Chandler Carruth宣布了名为“Carbon”的全新开源开发语言，并称它将是C++的继任者。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/e2/e28d032b440b601a082dd2a243bd19f7.png\" /></p><p></p><p>&nbsp;Carbon项目地址：&nbsp;<a href=\"https://github.com/carbon-language/carbon-lang\">https://github.com/carbon-language/carbon-lang</a>\"</p><p>&nbsp;</p><p>Chandler Carruth表示，<a href=\"https://github.com/carbon-language/carbon-lang\">Carbon</a>\"就是谷歌内部构建的最新编程语言，它拥有与C++的“双向互操作性”，也就是说开发者可以直接在Carbon语言的程序中使用C++，这大大提升了项目迁移的便捷性。</p><p>&nbsp;</p><p>多年来，<a href=\"https://www.infoq.cn/article/76gYqPA2YU0YXCDHFvIE\">谷歌</a>\"构建出了多个新兴的编程语言，其中一些已经在业内有了很高的知名度。</p><p>&nbsp;</p><p>例如，Golang（或简称 Go）是为了改进服务器和分布式系统的开发而创建的，并已被公众采用。此外，最初旨在替代 <a href=\"https://www.infoq.cn/article/m48tvaz8w2BbblIQKZZF\">JavaScript </a>\"的<a href=\"https://www.infoq.cn/video/qd7bu4DxKQ9DVvr7oc0b\"> Dart </a>\"编程语言在Flutter 发布后也开始成为主流编程语言。</p><p>&nbsp;</p><p>在出席此次C++开发者大会上，Chandler Carruth分享了他对于Carbon这个新编程语言的愿景。Carruth 展示了当今最流行的编程语言中有多少个语言是有继任者的，这些所谓的继任者可以让开发人员快速提高生产力并利用更现代、或者更简洁的语言设计程序。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/54/54fba0dd7cf12f566e78644094721da2.jpeg\" /></p><p></p><p>Android 开发者很清楚 Kotlin 是 Java 的继任者，正如 iOS 开发者知道 Swift 是 Objective-C 的继任者一样。</p><p>&nbsp;</p><p>来自 Microsoft 的 TypeScript 彻底增强了 JavaScript性能，同时能够让开发者便捷地使用TypeScript并能够“转译”回 JavaScript。C++ 在谷歌中得到了大量使用，它有点像古老的C语言的继任者。</p><p>&nbsp;</p><p>虽然有些人可能会认为 Rust 最初是一个 Mozilla 项目，后来它拥有了大量追随者，但如果要说Rust是C++ 的继任者，也并不准确。不可否认，Rust的确是一种很好的启动新项目的语言，但它不像 Java 和 Kotlin 那样具有“双向互操作性”，因此很难稳定地迁移。</p><p>&nbsp;</p><p></p><blockquote>如果 Rust 今天适合你，你应该使用它。但是将 C++ 生态系统迁移到 Rust 是很困难的。</blockquote><p></p><p>&nbsp;</p><p>为此，虽然 Carbon 与<a href=\"https://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;mid=2247526072&amp;idx=1&amp;sn=107be44f568cb45c9db02beacbb268ba&amp;chksm=e8d4997adfa3106c1395208c991a685f188e7b49de7ab552cc81e99b838019478614d880dca3&amp;scene=27#wechat_redirect\"> Rust </a>\"有许多相同的目标，例如帮助开发人员创建“性能关键软件”，但 Carbon 还旨在与现有的 C++ 代码实现完全互操作。此外，如果需要，目标是尽可能轻松地从 C++ 迁移到 Carbon。</p><p>&nbsp;</p><p>至于为什么 C++ 开发人员可能要考虑将 Carbon 引入他们的代码库，Carruth在会上还分享了该语言的许多亮点。</p><p>&nbsp;</p><p>Introducer keywords和简单的语法函数输入参数是只读值使用表达式来命名类型通过包名导入 API强大的、经过定义检查的泛型......</p><p>&nbsp;</p><p>在Carbon的README.md文件中，Carbon团队提到，虽然C++现在依旧是有着主导性地位的语言，并有着庞大的代码库，但由于数十年的技术积累，想要持续改进C++已经是极其困难的一件事。</p><p>&nbsp;</p><p>而Carbon则不同，它在继承了C++现有特性与生态的基础上，足够年轻，也足够“现代化”，拥有更为广阔的优化空间，潜力更大。</p><p>&nbsp;</p><p>同时，Carbon团队还表示，该项目的所有代码将全部公开托管在GitHub上，并开放PR，这使得任何开发者都有了根据自己的需求优化改进Carbon语言的可能。</p><p>&nbsp;</p><p>参考链接：</p><p>&nbsp;</p><p><a href=\"https://9to5google.com/2022/07/19/carbon-programming-language-google-cpp/\">https://9to5google.com/2022/07/19/carbon-programming-language-google-cpp/</a>\"</p><p><a href=\"https://twitter.com/code_report/status/1549384029308338176/photo/1\">https://twitter.com/code_report/status/1549384029308338176/photo/1</a>\"</p><p><a href=\"https://github.com/carbon-language/carbon-lang\">https://github.com/carbon-language/carbon-lang</a>\"</p>",
    "publish_time": "2022-07-21 11:47:10",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "从0到1开启一个全新的 TypeScript 项目",
    "url": "https://www.infoq.cn/article/Ev7LVAWjNI8aYu34dkJh",
    "summary": "<p></p><blockquote>文由极客时间整理自 FreeWheel 核心业务团队高级软件工程师陈芸在 <a href=\"https://time.geekbang.org/qconplus/home\">QCon+ 案例研习社</a>\"的演讲《<a href=\"https://time.geekbang.org/qconplus/detail/100091377\">TypeScript 在 FreeWheel 核心业务团队的项目实践（上）</a>\"》。</blockquote><p></p><p></p><p>作者｜陈芸</p><p>编辑｜贾亚宁</p><p></p><p>热衷前端技术的小伙伴都知道 TypeScript 这几年的需求呈现指数级增长的趋势，越来越多的开源项目开始使用 TypeScript 进行重构，出于对 TypeScript 究竟好不好，好在哪里的好奇，我们也对它进行了探索与尝试。</p><p></p><p>我本次的分享主要分为以下两个部分：首先探讨一下是否要引入 TypeScript，其次我们挑选了部门内比较典型的 TypeScript 项目，来带你尝试开启一个全新的 TypeScript 项目。</p><p></p><h4>是否引入 TypeScript</h4><p></p><p></p><p>第一部分我们先抛出一个疑问，我的项目是否应该引入 TypeScript？</p><p></p><p>想要引入一门新的语言肯定是有诉求的，如果原来的 JavaScript 对我们的开发来说非常完美，那大可不必做这样的尝试。既然 JavaScript 存在着问题，那我们就总结一下最大的痛点，看看 TypeScript 是否可以帮助来解决。</p><p></p><p>首先，找一找你平时经常遇到的前端 bug，很大一部分可能都是缺少“约束”导致的。缺少“约束”是什么意思呢？就是你制定了一个逻辑规则，但是并没有完整地描述这个规则，使得你获得的结果集合中总是会出现你期望之外的可能。我们先来看一个简单的例子：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/2b/2b0d6162c1a022e64c686f63c9a4ae2c.png\" /></p><p>这个 function 功能非常常见，就是从一个 list 中 filter 出某一项。看这三个结果，我期望这里的 item 包含匹配属性 id，且必须是 number 类型，这里的“必须包含以及类型限制”就是一种约束。</p><p></p><p>这个例子非常简单，但是我们在实际的项目中会有很多复杂的逻辑，经常会忘记当时写代码时思考清晰的约束逻辑，合作的小伙伴也不知道有这样的约束，就可能会触发 bug。那么这样的约束逻辑是不是可以显式地写在代码里，而不是只维护在作者的脑子里，这时我们就可以借助 TypeScript。当然有人会说我们可以借助测试来提前发现这样的 bug，但是对于大型项目而言，测试很难做到覆盖所有的逻辑。</p><p></p><p>这之后，我们还想提高开发效率。</p><p></p><p>我们在项目开发中常常会调用很多第三方的包，这些包怎么使用，我们往往需要去查看文档，还要注意版本是否一致，有时甚至需要去看源码，这是非常耗时的。不仅仅是第三方包，就是我们公司内部开发的 lib 库，在调用时也存在着同样的问题。尤其是项目团队中人员比较多的情况下，当我们需要互相调用对方开发的组件时，往往需要付出比较大的沟通成本。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/f3/f34a91f45149cf1c46d2ab46b1e0bdab.png\" /></p><p>这个问题，TypeScript 也可以很好地帮助到我们，尤其是它的编辑器有友好的类型提示功能，还可以自动补齐代码，在提升开发效率的同时，还可以减少引用的出错。</p><p></p><p>既然 TypeScript 可以帮我们解决这些痛点，那我们就动手实践一下，看看是不是真如外界说的那么好，同时也看看它会带来哪些问题。</p><p></p><h4>开启全新的 TypeScript 项目</h4><p></p><p></p><p>首先，我们遇到了一个契机，公司要开启一个新的前端项目，这个项目是把原来系统中一个高度复杂的业务模块进行改版。</p><p></p><p>这个项目的规模，大概 15 万行的代码量，前端开发团队大概十几人。项目的特点是逻辑非常复杂、上线时间紧迫、测试可覆盖的面比较小。接下来我们从以下三个方面来介绍我们是如何开启一个全新的 TypeScript 项目的：项目配置和目录设计方案，以及一些常见问题的处理方案。</p><p></p><p>首先说一下我们的项目配置方案：大家都知道 TypeScript 被诟病的一个很大的问题就是它的 compile 耗时，对于一个大型项目而言，每一次改动需要等待多长时间才能生效将严重影响到前端的开发效率，所以选择什么样的编译方式是我们面临的第一个问题。</p><p></p><p>先来看一份数据对比：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/0a/0a0663e57cb66f93e6ba3edec6ca784b.png\" /></p><p>首先 ts-loader 是一个 webpack 上针对 TypeScript 的加载器，ts-loader 内部是调用 TypeScript 的官方编译器 tsc 实现的，它整个编译过程包含类型检查和语言转换，我们知道这里的类型检查是非常耗时的，常见的一种解决方式是把 option 中的 transpileOnly 设置为 true, 这样就只做语言转换而不进行类型检查，相当于只是把类型剔除掉，然后我们再通过别的辅助方式在一个单独的进程里做类型检查，可以看到 compile 的耗时减少了。</p><p></p><p>那么可不可以更快呢？大家都知道 esbuild 是一个基于 Go 的打包工具，它的运行效率是非常高的，所以我们用 esbuild-loader 替换了 ts-loader，它的运行过程也是剔除类型进行语言转化，同样我们可以用别的插件来单独解决类型检查的问题，可以看到耗时又显著减少了。</p><p></p><p>当文件越来越多，这个差距也会越来越大。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/93/932b4bd1b7da38e852376b91cd7ffac2.png\" /></p><p>从上面这个图中可以看到，我们项目使用了 webpack5+esbuild 来进行 bundle。在另一个进程中使用插件来进行类型检查，由于是另起进程，所以它不会阻塞主进程的 bundle 过程。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/bc/bc90ae4b29bee07481eafc2bdf7f4fe4.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/67/67aed9dcfa5efa6a94302f11ac5fbd6d.png\" /></p><p></p><p>对应到实际 webpack 配置文件，我们使用了 esbuild-loader 作为 TypeScript 文件的加载器，使用了插件 fork-ts-checker-webpack-plugin 来进行类型检查。其他的 webpack 配置和 JavaScript 项目是一致。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/e9/e9886067447268f2db3b09f19d20ea6c.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/61/617819304631778e08f422cffa85dd65.png\" /></p><p>使用 fork-ts-checker-webpack-plugin 的效果如上图所示，在 Terminal 中可以查看 compile error 的详细信息，如果编译通过，则显示 no issue found。但如果只是这样其实还是不够的，因为我们完全可以忽略类型检查报的错，继续提交代码，那 TypeScript 也就没有意义了，怎么约束呢？</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/f6/f64b2ee01d2cd6c8e3b532e68cd67364.png\" /></p><p>我们的做法是把 tsc 作为 lint 的一部分，无论是本地提交代码，还是线上打包，lint 不过时无法完成的，这就起到了强制的作用。从这个命令中我们还可以看到，除了 tsc 以外，我们还使用了 eslint 来对 TypeScript 做代码检查。</p><p></p><p>2019 年 1 月，TypeScirpt 官方决定全面采用 ESLint 作为代码检查的工具，并创建了一个新项目 typescript-eslint。</p><p></p><p>有人会觉得，JavaScript 非常灵活，所以需要代码检查。而 TypeScript 已经能够在编译阶段检查出很多问题了，为什么还需要代码检查呢？因为有许多非类型问题是 tsc 所不关注的，比如代码风格方面可以用 eslint 来约束。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/52/52666c7eca94e3dc27bec610fd8fc68a.png\" /></p><p>上图是我们的 eslint 配置，具体每一条官方文档都有清楚的解释，这里就不逐条解说了，我就拿 no-empty-interface 为例，当我们代码里写了这样的 code：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/b0/b06476943ec0514ddc6e34ac3afc9902.png\" /></p><p>首先是空的 interface, 我们知道在实际代码中定义一个没有任何值的空对象是没有什么意义的，所以相应地也不应该出现这样的类型定义。然后是一个 interface 继承另一个类型后不做任何扩展，这样的写法相当于这两个类型就是完全相等的，也不应该出现这样的写法。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/8a/8abb66689c946fb8ba294fbc51cc6553.png\" /></p><p>诸如此类的问题 tsc 都是不会报错的，但这样的写法可能会给将来埋下隐患，所以我们通过 eslint 检查来规避一下。这里顺便提一下，有一些代码格式方面的约束比如缩进、空行、空格等之类的，我们并没有通过 eslint 来做，而是通过 prettier 来帮助完成。</p><p></p><p>接下来我们来介绍一下 TypeScript 项目最重要的 tsconfig 配置，下图是我们项目使用的配置方案：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/f9/f9c1c0e6b70b0e8337eea46d1c7d59cd.png\" /></p><p>这里我重点挑了几个参数：首先我们把 noEmit 设置成了 true，因为在我们项目中 tsc 只负责进行类型检查，并不真实输出 js 和.d.ts 文件。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/e2/e22e93c8d1763f83d9fb93cdf3043d12.png\" /></p><p>然后是 paths, 是用来 alias（取别名）的，配合 webpack 中的 alias，我们在 import 一些包的时候会用 alias 代替相对路径，那么在 TypeScript 类型检查的时候也需要知道这些别名才能找到对应的模块，完成检查。</p><p><img src=\"https://static001.geekbang.org/wechat/images/ef/efbde6c5e7c396168992ac089a31d9da.png\" /></p><p>最后是 include 和 exclude，include 指定某些路径下的文件被包含进来，exclude 排除一些路径。“include”的默认值是当前目录及其子目录下的所有 TypeScript 文件，“exclude”默认情况下会排除 node_modules、bower_components、jspm_packages 和目录，这里的 exclude 其实我们也可以省略。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/6b/6bedae60458556a44c1d53a60086adaa.png\" /></p><p>此外还有两个我们项目中没有使用，但可能大家会用到的参数：首先是 files，如果想明确指定某几个 TypeScript 文件加入到 include 中，可以用“files”这个参数来添加。需要注意的是，通过“files”属性明确指定的文件总是会被包含在内，不受 exclude 的约束。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/c3/c3b7a5861645924596e6f4c996c7ba88.png\" /></p><p>然后是 typeRoots，它默认值是 node_module 下的 @type，以及各个子路径下的 node_modules /@types。它的作用是：我们代码中 import 的一些第三方库，这些库的类型文件有全局声明，只有把他们添加进来，全局声明才会生效。需要注意，如果自定义 typeRoots，那么默认值就失效了，不要忘记手动把 node_modules/@type 也添加进去。</p><p></p><p>现在我们项目的框架已经搭好了，接下来介绍一下项目中的文件目录结构安排，通过项目实践，我们调整出的目录结构是好维护并有利于扩展的。下图展示了项目的文件目录结构，是一种我们比较推荐的 practic。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/92/92cc7371958fc46ce8e06fbe7580aaf5.png\" /></p><p>除了最外层的项目配置文件外，首先，一个 component 下会有以 component 为前缀的四个文件，分别是 hook.ts、.css、.types.ts 以及 component 本身，类型定义相关的代码会被放到单独的.types.ts 文件中，这样做是为了使 component 仅仅只包含业务逻辑代码。</p><p></p><p>其次，有许多公共类型会被多次调用，这样的类型我们通常会放到 lib/types 下。当然，全局 declare 的类型也会放在这里。这里有一个点值得说一下，关于.d.ts 和.ts 的区别：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/3c/3c1f448e1758d552d6617319c081e8c3.png\" /></p><p>.d.ts 是编译器从你的.ts 代码中分离出来的非 js 的部分，类似于接口定义规范。从上图中可以看出.d.ts 是给 js 文件提供类型声明的，通常来说它是 tsc 自动生成的。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/7c/7cf028485293fb05da9338dc4b8fdd02.png\" /></p><p>当然还有一种情况，代码不是用 TypeScript 写的，而我们希望调用方可以得到类型信息，这时我们需要手动写.d.ts 来提供一份对外的 type。比如项目中会引入许多第三方库，而这些库是基于 JavaScript 开发的，通常这些库的类型声明文件会放到 node_modules/@type 下。比如这里的 react，就是通过.d.ts 文件来提供类型声明的。</p><p></p><p>最后回到我们的文件中，由于我们项目的特性，我们并没有大量写.d.ts 文件，但由于我们会需要用到全局声明，通常我们习惯会把全局 declare 放在.d.ts 里。</p><p></p><p>然后我们说一下通常哪些类型会被当做公共数据类型放到 lib/types 下面：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/84/84442348bb089dc324f6377646913615.png\" /></p><p>首先是后端接口数据类型，看这个例子，这里定义的 ListAllChangeHistoryInfoResponse 就是后端返回的数据类型，其中每一项的类型是 ChangeHistoryInfo。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/88/88ce463a69f0fdcd668e646540f6bbd3.png\" /></p><p></p><p>由于前端的页面展示的内容是以后端返回数据为基础的，这也决定了这样的类型会被多个上层类型定义所调用。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/15/15a26de47a589aca8c781b8c1eb5edc9.png\" /></p><p></p><p>这里还有一个隐含的好处，我们在项目中期，引入了前后端接口同步方案，这个后面会提到，是我们自己发布了一个第三方 type 库来集中提供各种与接口相关的数据类型。那么在 adopt 的过程中，我们不需要全局逐个文件地改这个被替换的接口，只需要在 lib/type 下做一次这样的修改即可。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/ce/cedff294edfee51532d5a4c0a9cb3de9.png\" /></p><p>还有一类是公共组件或者通用方法的某些参数的类型，从右边的代码中可以看到，这里的 TreeSelect 有一个属性是 flatOptions, 它的类型就是左侧定义的 TreeOptionItem 所组成的 list,我们在项目中一个常见的场景是请求回后端数据，经过一个数据转换的函数，把数据 format 成 option 类型的数据，传给 TreeSelect 做展示。</p><p></p><p>由于这样的场景非常多见，针对于不同的后端数据，会需要不同的数据处理，所以这个 TreeOptionItem 就会被多个上层 component 所调用。因此我们也推荐放到 lib/types 下。</p><p></p><p>最后一部分是常见问题处理，我们在项目中遇到了各种问题，在这里总结两个比较典型的问题。</p><p></p><p>当我们用 ts 编译器做类型检查时，出现 compile error 很常见，通常我们也可以通过修正 type 的定义来 fix，但如果我们 import 的是一些 css、png 这样的文件该怎么办呢？</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/a2/a21d28e14dfef5ad94b3e1d6c7eb9ecf.png\" /></p><p>由于这些文件本身无法定义类型，最直接的想法是加上 @ts-except-error，这确实可以解决问题，但是需要注意，如果使用了 ts-expect-error，加下来的代码中没有真实的类型错误，编译器会提示：Unused ‘@ts-expect-error’ directive，而使用 ts-ignore 则无论下面的语句有没有编译错误，编译器都会忽略。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/43/43f7f6ff447d8cc02111e74639647521.png\" /></p><p>但无论是哪一条命令，这样做的缺点是每次 import 都必须加，有没有一劳永逸的方式呢？</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/ea/ea8be2683174d020e760194c565e5f59.png\" /></p><p>我们推荐使用全局 declare 的方式，像一个配置文件一样，在项目初期就把这样一个文件放到 lib/types 下，那么此类问题都不会出现了。需要注意的是，全局 declare 不可以在最外层包含 import、export 这样的语句，否则它会被当做局部声明而无法全局生效。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/d1/d15fb0ffb02c7c46d5b952b7b4b820db.png\" /></p><p>第二个问题是引入第三方库没有 type 或者 type 定义有问题该怎么办？这里同样可以通过全局 declare 的方法解决。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/65/658d8ad68b668bc0105fefbba35f1308.png\" /></p><p>同时，我们更加推荐把声明文件发布到 DefinitelyTyped 上，让更多的人可以受益。</p><p></p><p></p><h4>作者介绍</h4><p></p><p></p><p>陈芸   FreeWheel 核心业务团队高级软件工程师</p><p></p><p>主要负责前端开发工作，对前端前沿技术非常热衷，致力于提升产品质量，优化用户体验。前豆瓣全栈开发工程师，对 ToB，ToC 的项目都有深刻的理解。</p>",
    "publish_time": "2022-07-21 12:50:32",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "TypeScript 项目实践：四步走高效改造现有的 JavaScript 项目",
    "url": "https://www.infoq.cn/article/PzkgsYi2OqY89o0KLjBW",
    "summary": "<p></p><blockquote>本文由极客时间整理自 FreeWheel 高级软件工程师陈芸在 <a href=\"https://time.geekbang.org/qconplus/home\">QCon+ 案例研习社</a>\"的分享《<a href=\"https://time.geekbang.org/qconplus/detail/100091378\">TypeScript 在 FreeWheel 核心业务团队的项目实践（下）</a>\"》。</blockquote><p></p><p></p><p>作者｜陈芸</p><p>编辑｜严强</p><p></p><p>你好，我是陈芸，目前就职于 FreeWheel 核心业务团队，主要负责前端开发工作。我想和你分享一下我在改造现有 JavaScript 项目上的实践经验，手把手带你一起把现有的 JavaScript 项目 TypeScrip 化。</p><p></p><h3>改造背景</h3><p></p><p></p><p>先介绍一下改造背景。</p><p></p><p>TypeScript 作为 JavaScript 的类型化超集，弥补了静态、弱类型的 JavaScript 的缺陷，具有静态类型声明，可以减少不必要的类型判断和人工查看类型的成本，开发过程中进行静态类型检查和类型提示，对提高开发效率有正向作用。基于 TypeScript 的优点和我们面临的现状，FreeWheel 核心业务前端开发团队决定将前端开发语言从 JavaScript 向 TypeScript 切换。</p><p></p><p>我们改造的项目业务非常复杂，参与开发的人员非常多（代码行数 8 万多行，前端开发人员 40 多人），以及在可预见的将来，项目会有大量的功能迭代。</p><p></p><p>P.S.：在引入 TypeScript 的时候，我们使用的 TypeScript 版本是 4.2.2。</p><p></p><h3>改造过程</h3><p></p><p></p><p>接下来我会从以下 3 个方面来介绍我们是如何把 JavaScript 项目 TypeScrip 化的：</p><p>迁移方式探讨类型定义公约代码改造实操迁移后的收获</p><p></p><h4>迁移方式探讨</h4><p></p><p></p><p>第一部分，我们来探讨一下迁移方式。</p><p></p><p>在决定把一个 JavaScript 项目 TypeScript 化的时候，首先我们需要去判断我们这个项目的属性以及我们本身具备的一些条件。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/58/58172bb1c1ae7149fb81b852c0c30e21.png\" /></p><p></p><p>如图所示，第一个条件：判断是否一个稳定的组件。这个意思就是在比较久的一段时间内并不会有一些功能迭代进来。在这样的项目下，我们推荐你手动去维护一份.d.ts 的文件，可以做到只是对外提供类型，方便第三方的调用。如果不是一个稳定的组件，我们需要在将来不停地去维护它。</p><p></p><p>如果有新的功能加进来的话，那我们就来看第二个条件：是否有足够的时间窗口。如果有足够的时间的话，我们推荐使用 TypeScript 来对原来的 JavaScript 代码进行完整的重构。因为 TypeScript 的设计思维和 JavaScript 是不同的，它比较推荐接口设计先于代码实现，所以在很大程度上，原来的 JavaScript 代码是不能匹配这样的设计而写出来的。我们推荐用 TypeScript 重构，这样会比较符合。</p><p></p><p>如果我们没有足够的时间窗口该怎么办？以我们的项目为例，我们选择的方式是给模块逐个添加类型来达到进行类型约束的目的。当然给模块添加类型也是有顺序的，推荐把底层的模块先加类型，然后再是上层的模块。</p><p></p><h4>类型定义公约</h4><p></p><p></p><p>接下来是我们在这个项目中组内约定的类型定义公约。约定这样的类型定义公约目的有两个：第一明确迁移进度，第二更好地做类型约束。</p><p></p><p>我们约定了一些必须要遵守的公约：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/75/752cb62952b5c466a03d4187521534e8.png\" /></p><p></p><p>第一条，定义 type 尽量不使用 any。我们都知道，在代码中大量的使用 any 其实可以明显地降低移植难度，但是我们引入 TypeScript 的初衷是为了给代码进行类型约束，那么使用了 any 之后就失去了这种类型约束的作用，所以我们这里把 eslink 中，这一条 no-explicit-any 设置成了 warn，我们并不会完全去禁止使用 any，但是不建议。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/52/52e7d9b9ea628a9a6ef3d62f3d2531ae.png\" /></p><p></p><p>其他三条，都是规定了在代码中哪些位置是需要定义 type 的，分别是 Component 的 props、function/hook 的输入输出以及 state。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/84/84edfa56cb87354c4bb28ac68552b8d2.png\" /></p><p></p><p>看一下这个例子，useDate 是一个 hook，它里面包含了一个 state。Header 是一个 component，它有 props。左图中，我们没有很好地在这些位置定义清楚各自的类型。而右图中，我们给 useDate 的返回值定义了类型，给 state 定义好了类型，同时给 Header 的 props 也定义好了类型。</p><p></p><p>我们知道，当我们把一段代码单独提取出来成为一个 function，或者成为一个 Component，我们默认这样的代码是会被多次调用的。那么，在这些代码被定义了类型之后，当我们去调用这样的 function 或者 component，TypeScript 会给我们带来怎么样的帮助呢？</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/6e/6e59721eab658c2b8ea4dae6b16dd8b3.png\" /></p><p></p><p>首先，我们刚才定义了 useDate 的返回值，包含了三个值，它们的类型分别是 string，string 以及 function。那么我们在调用这个 hook 的时候，如果想要拿它的第四个返回值，这时编译器就会告诉我们这个值已经超出了它的返回值的范围，是有问题的，不可以这样使用。</p><p></p><p>我们刚才定义的 hook 第三个返回值其实是一个 function，它包含了两个 string 类型的参数，它的返回值是 void。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/f0/f02c424a7c99e60af6bccdb9ef842bed.png\" /></p><p></p><p>在我们调用这个 function 时，如果我们给它的第二个参数传入的值是 number 类型，编译器就会告诉我们这里的 number 类型并不被允许，我们只能传入一个 string 类型的值。这就可以帮助我们提前发现这里传入参数是否正确。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/8f/8fa7251ca472d60440c698dc11f22e21.png\" /></p><p></p><p>然后是 Component，我们刚才定义了它的 props 的类型，它只包含了一个属性 getData。我们在调用 Component 的时候，如果给它传入别的参数，编译器同样会告诉我们这个属性并不被 Component 所接收。</p><p></p><p>完成了以上这几处类型的定义，许多代码中别的类型都可以通过类型推导来得到。这也就是用最小的工作量发挥 TypeScript 最大的好处的情况。所以我们约定了完成以上这几处类型的定义，就算完成本阶段的代码迁移。</p><p></p><p>接下来介绍一些我们推荐遵守的公约，这些公约主要是为了帮助我们能够更好地实现类型约束。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/67/6755567d9d67f9efdd96cc5234a8e00c.png\" /></p><p></p><p>第一条，尽量避免类型重复定义。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/85/854bc34aa76e86ade154486ab00cf151.png\" /></p><p></p><p>看这个例子，PowerUser 它的一些属性其实是 User 和 Admin 的一个合集，同时它有特殊的 type。我们如果把左图中的写法，改成右图中这样，去掉 User 中 type 属性，去掉 Admin 中 type 属性，同时和它自定义的 type 组成它自己的类型，这样其实更符合代码逻辑。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/f1/f105b5817c4205a78b3d48590ca2b27e.png\" /></p><p></p><p>还有这样的一种情况，上面的写法其实是一种函数重载，这里的 diff() 支持输入一个参数，支持输入两个参数，也支持输入三个参数。我们推荐把这样的情况写成下面这样的类型定义：第一个参数是 require 的，后面两个参数都可以设置成 optional 的。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/e8/e826b968ebaa71db33f0233633343c9d.png\" /></p><p></p><p>这样的例子在代码中很常见，比如这里的 ignoreErrors，shouldAutoReload，isEditIO 这三个参数在 function 内部都是有默认值的。也就是说，我们在调用这种方法的时候并不是必须去传入这样的参数的。对于这种有默认值的属性，在定义 type 时，我们推荐直接将它们设置成 optional。为什么要这样做？首先它可以使我们的代码更加简洁清晰。其次，由于以上写法更符合代码逻辑，所以也就决定了它维护起来更加方便。</p><p></p><p>第二条，推荐使用 keyof 对 object 中的 key 进行约束。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/b5/b5c7b62b74cd0aad0ab9c44437858679.png\" /></p><p></p><p>首先看上面这个代码段，这个写法会存在两个比较大的问题：第一，我们无法确定返回值类型；第二，我们的参数把它定义为了 string，但是很可能会出现拼写错误，而使这个 function 发生运行时的错误。</p><p></p><p>我们推荐下面这种写法，使用泛型 T 配合 keyof 来对这个 object 进行约束，同时也对它的 key 进行约束，就可以很好的解决这两个问题。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/35/351445569f46dd8e991f81b16471073c.png\" /></p><p></p><p>来看一下项目实例，这个函数它主要负责处理 URL 相关的一些功能。它从 URL 的 search 参数中得到一些键值对，并且把这些键值对转化成一个 object 类型然后输出。这里的 currentQuery 就是 object 类型。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/e4/e42f1b81c0e412d142a7b23e1d407d3e.png\" /></p><p></p><p>其次，它还提供了一个 deleteQueries 的 function。这个 function 支持输入参数 keys，然后去除 search 中的一些键值对，并且把新得到的 search 反向 push 回 URL。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/34/34ec1a4c4b07d22e88269e3b030f4586.png\" /></p><p></p><p>我们在代码中使用了泛型 T 对它的 object 进行约束，可以看到这里的第一个返回值就是泛型 T。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/c1/c1897261dae33fb57b4e741b57c54b71.png\" /></p><p></p><p>然后我们使用 keyof T 对它的参数 filters 以及 useCallback 的参数 keys 进行了约束。filters 的作用是可以指定返回的 object 中包含哪些 key，而 keys 是指定了在 deleteQueries 中需要具体去删除哪些 key。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/e1/e104c5c0d36350065df9578561b4269c.png\" /></p><p></p><p>看一下实际的调用情况。在我们调用这个 hook 的时候传入了一个指定类型 URLQueryForCampaignPage。这个类型包含了四个属性，分别是 insertion_order_id、placement_id、pagelink_id 以及 step。当我们传入这样类型的时，就决定了我们得到的第一个返回值 Query 的类型被约束为只能包含这四个 key。那么当我们想去拿 Query 中的某一个属性，比如要拿 test 属性时，编译器会直接告诉我们这个属性并不包含在这个 object 中。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/27/270ed6be552ef37adbe8113e2d658efd.png\" /></p><p></p><p>定义它的第二个返回值，deleteQueries 这个 Callback，它的参数用 keyof T 约束了必须是这个 object 中的这些属性所组成的 list。这时如果我们手动输入某一个值，比如说 test 或一种拼写错误，编译器也会直接告诉我们这个 test 不在 object 中，从而提前发现了 bug。</p><p></p><p>第三条，推荐用 tuple 来代替 array 来约束数组长度。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/4f/4f5024126852fbafbc45b95a708b33eb.png\" /></p><p></p><p>看这两个代码段，上面的写法是用 array 来定义数组类型，下面的写法是用 tuple 来定义数组类型。这两种写法都是可以的，但如果明确知道数组的长度，我们更推荐使用 tuple，为什么呢？</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/29/29586f713a53d6a581f6d810f43c79f9.png\" /></p><p></p><p>看这个代码实例。这个例子的 useMemo()，返回了两个 number 类型的值组成的 list。如果我们用 array 来定义数组类型，要拿第三个返回值的时候，编译器并不能检查出错误，可能会导致运行时的 bug。只有我们把它定义成了下面这样的情况，编译器才能提前知道第三个属性已经超出了返回值的范围，提前发现错误。</p><p></p><p>最后一条，id 尽量不要模糊定义它的类型（string | number），推荐把 id 明确定义为 string 或者 number。这是我们在项目中实际踩过的坑，如果可以，我们希望能在项目初期就规避这样的问题。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/01/011e6ad748bef7cda96585ca0183a908.png\" /></p><p></p><p>比如这个 Message，我们的 id 可以明确成 string 话，千万不要定义为 string | number 这样的类型。为什么这么说？我们知道，后端返回给前端的数据可能来自不同的 service, 他们的 id 往往无法保证统一，有些接口的 id 是 number, 有些接口的 id 是 string。而 id 通常会作为唯一标识做匹配或者构建新的对象， 这就会给代码造成额外的处理负担，也增加了出错率。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/f7/f77190591fe124320d630169d97a4561.png\" /></p><p></p><p>比如这个实例，这里的 BFInfo 的 ioId 实际是 string 类型的，我们把它定义成了 number | string。这时 IOInfo 的 id 是 number 类型的。当我们要从 BFInfo 这个 list 中去匹配某一项 IOInfo 时，我们会写如下语句。这段代码在类型检查的时候是会成功通过的，但事实上这里隐藏着一个 bug。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/2b/2bf50cec923c776f890b18ae1fb53c1f.png\" /></p><p></p><p>可以看到，如果我们把刚才的 BFInfo 的 ioId 定义成了 string，那编译器会直接告诉我们一个 number 类型的值。如果想跟一个 string 类型的值作比较，它的返回值永远是 false，就说明这个语句是没有意义的。只有我们把它们的类型明确了，我们才能提前发现这里有问题，才可以相应地去做代码修改，比如把这两个值统一转成 number 类型或者 string 类型后再去作比较。</p><p></p><h4>代码改造样例</h4><p></p><p></p><p>讲了上面两部分之后，我们用具体实例来实际演示一下代码改造的过程。</p><p></p><p></p><p></p><p></p><h4>迁移后的收获</h4><p></p><p></p><p>最后总结一下我们在把 JavaScript 项目 TypeScrip 化的过程中遇到的问题和获得的收获。</p><p></p><p>第一个难点，在迁移阶段，整个项目处于 JavaScript 和 TypeScrip 并存的状态，项目的配置方案也因此变得比较复杂。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/e9/e91396eb46f4a351efa02d34ca4de05b.png\" /></p><p></p><p>左侧是我们的 webpack 配置，我们针对 JavaScript 和 TypeScrip 引入了不同的加载器。而右侧是 ESlint，我们针对 JavaScript 和 TypeScrip 又使用了不同的 rule 配置。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/74/7405e58072722eec6bba5ebae7583e66.png\" /></p><p></p><p>第二个难点是我们原先的代码设计很多时候并不利于类型化。</p><p></p><p>看这个例子，由于原来的代码设计，function 的某个参数 data 分别可以是三种完全不同的数据结构，而代码中通过 if else 去对不同的数据进行处理。像这样的代码其实是非常不利于进行类型约束的。推荐的做法是把这样的方法进行重构，但是由于我们在项目迁移的过程中仍然有大量的功能迭代进来，为了尽量地避免冲突以及把风险降到最低，我们选择了这样的折中的方式来进行约束。</p><p></p><p>有遇到问题，但收获也是非常大的。TypeScrip 化给我们带来的第一份惊喜是让我们发现了原先代码中隐藏的 bug。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/31/31f93d811076f4c8b303a9e7fefd2eed.png\" /></p><p></p><p>第一个 bug 是我们在调用这个 function 给它传参的时候，把这里的 key 和 value 直接给写反了。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/aa/aa8d53406fc030ddc5f444a47830c962.png\" /></p><p></p><p>第二个 bug 隐藏得比较深。component 有一个参数 value，value 值的属性是 number 或者 string 的一个 list。而我们在 component 中定义了 state，这个 state 的类型是这里的 TreeOptionItem 所组成的 list。可以知道 string or number 和 TreeOptionItem 是两个完全不同的类型，我们在写代码的时候，把 value 作为 state 的默认值这样的写法肯定是有问题的。这个在类型检查的时编译器直接告诉了我们。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/50/503cf36f9728522cbfca487a1273f4aa.png\" /></p><p></p><p>第三个例子也非常常见。我们在代码中做一次 rename 之后可能忘记了去修改，这个文件中也引用到了这个参数，就导致这里的参数已经找不到了。像这样的问题，tsc 也很容易就告诉了我们。</p><p></p><h3>总结</h3><p></p><p></p><p>最后，我们建议：对于多人参与开发的大中型项目，引入 TypeScript 将非常有利于后期的代码维护。对于个人的小型项目，引入 TypeScript 的必要性并没有那么强，但如果个人感兴趣的话，推荐你依据个人喜好而定。比如你想要去体会 TypeScript 带来的好处的话，小型项目也可以明显感觉到。</p><p></p><p>送给你一句话，听得再多东西都是别人的，亲手试一试才能成为自己的。</p><p></p><p></p><h4>作者介绍</h4><p></p><p></p><p>陈芸   FreeWheel&nbsp;核心业务团队高级软件工程师</p><p></p><p>就职于 FreeWheel 核心业务团队，主要负责前端开发工作，对前端前沿技术非常热衷，致力于提升产品质量，优化用户体验。前豆瓣全栈开发工程师，对 ToB，ToC 的项目都有深刻的理解。</p>",
    "publish_time": "2022-07-21 13:18:46",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "无方向盘自动驾驶汽车来了！“人均一个数字人”的时代也要来了？百度的AI世界上新",
    "url": "https://www.infoq.cn/article/kso0s8Dl1QWabtcPWTTA",
    "summary": "<p>7月21日，在2022百度世界大会上，百度发布了多款百度最新AI技术成果，包括没有方向盘的自动驾驶汽车Apollo RT6，希加加虚拟数字人，全球首个航天领域的大模型...</p><p></p><h2>“人均一个数字人”的时代已来</h2><p></p><p></p><p>虚拟数字人可以说是这次百度世界大会的“主角”了。</p><p></p><h3>“希加加”、度晓晓站上“C位”</h3><p></p><p></p><p>百度AI数字人家族的新成员“希加加”是本次大会的 AI 策划官、副主持人和开场嘉宾，与撒贝宁一起同台主持。她连同另一位数字人度晓晓出现在整场大会的多个环节中。“希加加”还具备作画、写诗、作曲、说多国语言、实时直播等多项“超能力”。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/8f/46/8fe0965a8498219864dfa28644f58546.png\" /></p><p></p><p>百度集团资深副总裁、百度移动生态事业群组（MEG）总经理何俊杰表示，“人均一个数字人’的时代已经到来。”</p><p></p><p>何俊杰展示了百度AI数字人“度晓晓”的最新进展。他认为，度晓晓扮演着“AI大使”的角色，连接起科技到用户的最后一公里。</p><p></p><p>“度晓晓”是百度搜索能力的重要进化。目前，“度晓晓”已经上线百度App，用户直接在百度App搜索“你好”，即可召唤度晓晓。</p><p></p><p>据悉，在百度App内，度晓晓可以连接所有的智能生活服务：面对用户的个性化提问，度晓晓通过百度“问一问”快速匹配专业答主，提供一对一真人咨询服务，目前“问一问”已覆盖法律、情感、心理、政务等19个领域超4万名答主。</p><p></p><p>百度AI创造的数字人度晓晓、希加加所具备的理解和生成能力，可以令其自动生成创意作品。会上，龚俊数字人与度晓晓一起表演了AIGC单曲《每分 每秒 每天》。度晓晓可以40秒完成40篇高考作文，几十秒完成一幅美术作品，24小时不间断情感互动，还能创作脱口秀、直播带货等。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/a4/f7/a42134d17cae2070e1b7yyfea403e5f7.png\" /></p><p></p><p></p><p>百度创始人、董事长兼首席执行官李彦宏分享了对AIGC领域的思考，“未来十年，AIGC将颠覆现有内容生产模式，可以实现以‘十分之一的成本’，以百倍千倍的生产速度，去生成AI原创内容。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/c1/41/c117bb96c4ce9a0b81b79f2f09d62e41.png\" /></p><p></p><p></p><p>李彦宏判断，AIGC将走过三个发展阶段：第一个阶段是“助手阶段”，AIGC用来辅助人类进行内容生产；第二个阶段是“协作阶段”，AIGC以虚实并存的虚拟人形态出现，形成人机共生的局面；第三个阶段是“原创阶段”，AIGC将独立完成内容创作。</p><p></p><h3>超写实数字人直播平台发布</h3><p></p><p></p><p>“全新发布的数字人直播平台，能让AI数字人自己做直播，我们全年无休，和用户互动，帮助那些不太擅长做电商的山区农家叔伯、小微企业，改善他们的生活。”会上，AI数字人希加加这样介绍百度智能云的曦灵数字人直播平台。该平台主要聚焦电商直播、品牌营销、互动娱乐等领域，做到超写实数字人24小时纯AI直播。</p><p></p><p>当下，直播行业炙手可热。但直播爆火的背后，真人主播稳定性弱、直播硬件及场景成本高、运营门槛高、闲时流量无法有效利用，也成为其发展的制约因素。</p><p></p><p>创匠科技CEO刘卫表示：“以团队搭建电动牙刷售卖直播间为例，仅硬件成本至少7万元，还不包含场地及主播”。百度智能云曦灵通过AI驱动的方式，无需真人主播和中控人员，实现内容快速生成，降低运行成本。</p><p></p><p>判断一位真人主播的受欢迎度，核心原因不过有三：首先，主播的表现力强，外观形象、穿搭风格都令人有记忆点；第二，有个性、很能聊，与观众谈天说地，机智回复；第三，不停更，渗透进大众生活的每一个时间缝隙。要让直播间里的数字人无限接近真人，核心考验的就是数字人的表达力和交互力。</p><p></p><p>在表达力层面，当前市场上大多产品的数字人精度低，“纸片人”很容易让观众“出戏”。百度智能云在超写实数字人制作方面已研发3年，通过数字人自然动作引擎等技术，数字人直播平台生产的AI数字人形象亲切、毫发毕现，动作平滑自然，用户能感受到AI数字人带着“真情实感”的。</p><p></p><p>在交互力层面，主播的本质是内容。依靠视觉、NLP、语音交互等底层全栈AI技术以及PLATO百亿参数对话大模型，百度智能云的数字人直播平台能让数字人像真人一样，与观众捧哏逗趣，机智回复。同时，AI大模型所支撑的智能创作，也将助力数字人在未来拥有“原创能力”。</p><p></p><p>想要实现“人均一个”数字人，标准化产品将成为降低运营门槛的关键。</p><p></p><p>曦灵数字人直播平台，作为一款saas化产品，可实现“即插即用”，无需要完整的运营团队、昂贵的直播硬件设备，一个人就可完成全部流程，让数字人直播与写文档、做PPT一样简单。同时，数字人直播平台还打通了服务全流程，为合作伙伴提供直播代运营托管、中之人培训等服务。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/a4/e0/a413f7e8db9f2f7e8219bf93163e57e0.png\" /></p><p></p><p></p><p>百度智能云AI及应用产品副总经理刘倩表示，“数字人直播平台的推出，将让大家可以低门槛拥有更稳定、超写实、智能化的数字主播，真正解放企业生产力”。</p><p></p><p>超写实数字人向前发展，对视觉技术也提出了新的挑战。百度视觉技术部、增强现实技术部总监丁二锐表示，百度即将发布“照片引导形象生成技术”，手机摄像头拍摄几张甚至一张照片，即可生产一个拟真、美观且可驱动的超写实数字人人像，相较传统制作流程效率将提升90%。</p><p></p><p>据悉，当前，百度智能云曦灵打造的几十位数字人已经落地各行各业，央视网小C、央视新闻AI手语主播，以及希加加等，都曾参与过大型直播。</p><p></p><h2>百度第六代量产无人车Apollo RT6发布</h2><p></p><p></p><p>会上，百度发布了第六代量产无人车 —— Apollo RT6。</p><p></p><p>基于自动驾驶技术上的突破，Apollo RT6不但具备城市复杂道路的无人驾驶能力，而且成本仅为25万元。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/8e/7c/8ea4e66706d3d6f9d630a7b9b3c2967c.png\" /></p><p></p><p></p><p>李彦宏表示：百度把自动驾驶汽车的成本，降低至业界的十分之一，相当于一辆普通新能源汽车的价格。无人驾驶汽车成本的大幅下降，以至于我们可以部署上万辆这样的车在全国各地了。 未来打无人车，要比现在打车便宜一半。</p><p></p><p>根据规划，Apollo RT6会于2023年率先在萝卜快跑上投入使用，未来可以在全国部署上万辆。它的量产落地，将加速无人车规模化部署。</p><p></p><p>Apollo RT6是百度面向未来出行自主研发、正向设计的量产车，整车针对乘客需求和无人驾驶出行场景进行了深度设计。</p><p></p><p>据介绍，Apollo RT6外观采用了贯穿一体的空间飞梭车身及银河腰线，突出科技感与安全感；创新性的龙骨天窗，将车顶传感器与天窗结构高度集成融为一体，革新了自动驾驶改装车的造型；为了进一步提升出行便利性，车辆还配置了具有识别和提示功能的灵犀交互灯语、智能电动侧滑门等功能。</p><p></p><p>智能座舱方面，Apollo RT6打造了百变智能空间。Apollo RT6支持有方向盘、无方向盘两种模式，前排可根据不同出行场景配置座椅、售卖机、办公桌、游戏机等，满足乘客办公、娱乐等多元需求。此外，Apollo RT6后排1050mm大空间、独立座椅以及智能交互系统后移设计，实现A级车的尺寸、B级车的空间、C级车的体验。</p><p></p><p>Apollo RT6源自百度自研的「阿波罗星河」架构平台，作为该平台的首款车型，Apollo RT6实现了100%车规级和整车全冗余系统，相较于市面上的改装车可靠性高出两到三个数量级，保障乘客出行安全。Apollo RT6硬件上，具备架构冗余、计算单元冗余、制动系统冗余等七重全冗余系统，任何单一零部件或系统失效，备用的冗余系统都可以瞬时完成补位；软件上，搭载了整车+自动驾驶系统一体的故障诊断及风险降级体系。</p><p></p><p>百度集团资深副总裁、智能驾驶事业群组总经理李震宇表示，**Apollo RT6既是一辆车，也是一位好司机，它自带的自动驾驶技术，相当于拥有20年驾龄的司机。**Apollo RT6搭载了百度最新一代无人驾驶系统，具备比上一代车型更强的L4级自动驾驶能力，可应对城市各类复杂道路和场景。Apollo RT6配备的车规级高算力主冗双计算单元，算力可达1200Tops。全车38个传感器深度融合，实现远中近三重检测能力全覆盖，具有更精准感知能力。</p><p></p><p>过去9年来，百度Apollo共推出了六代无人车。相较于前五代车型，Apollo RT6实现了AI技术和车辆工程的深度融合，具备高安全、高质量、低成本等优势。</p><p></p><h2>AI帮助实现“绿灯自由”</h2><p></p><p></p><p>百度认为，未来的城市智能交通，不仅要有“聪明的车”，还要有“智慧的路”。</p><p></p><p>车路协同能有效解决安全、拥堵、碳排放等重要问题。李彦宏认为，“以车路协同为基础的智能交通，可以让通行效率提升15%-30%，推动GDP每年2.4%-4.8%的绝对增长；随着智能交通的深入实践，四年之内中国的一线城市将不再需要‘限购’‘限行’。智能交通系统，有望降低90%交通安全事故。”</p><p></p><p>根据大会上披露的最新数据，百度智能交通方案已经在广州、保定等全国50多个城市得到实践和验证，其中，尤以AI信控技术最具优势。</p><p></p><p>这次会上，百度展示的智慧交通成果，更侧重将AI渗透进人们的实际生活中。百度通过三个案例展现了智能交通建设如何助城市管理者精准决策，为普通百姓带来“绿灯自由”。</p><p></p><p>我国有1700万卡车司机，在卡车物流运输场景，大雾、暴雨等极端天气导致高速封路往往会延误交货时间，也存在安全问题。在京雄高速上应用的百度智慧高速系统，突破了准全天候通行的技术难题，在雾天等不利天气状况下，司机可以收到智能终端发出的天气、车距、车速、前方碰撞等驾驶信息的提醒，保障司机顺畅、安全通行。同时，凭借融合感知、AI算法的提升，将设备的部署距离成功扩展至1公里，成本降低30%。</p><p></p><p>在重庆永川区，AI可以帮助交警“指挥”交通。在AI参与下，信号灯可以自动配时，还有截流控制、动态绿波等应用，不断优化城市交通。一线交警无需站在烈日下指挥交通，可以在智慧城市指挥大厅，宏观把握拥堵情况。数据显示，应用上AI后，交通警情处置效率提升了35%。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/a4/a7/a45924a89fb6a5ae4ae1c5ea9aa01ea7.png\" /></p><p></p><p></p><p>在北京这样的超大型城市，交通拥堵频繁发生，尤其上下班路上经常是“一路堵途”。北京亦庄的智能路口建设，解决了这一痛点。百度集团资深副总裁、智能驾驶事业群总经理李震宇将智能路口的效果形容为“灯数车”，他表示，智能路口建设让市民一路绿灯出行不再靠运气。例如，在332个智能路口作用下，一趟就能为用户杨晓芳减少20分钟通勤时间。</p><p></p><h2>世界首个航天领域大模型发布</h2><p></p><p></p><p>百度CTO王海峰与中国探月工程副总指挥、国家航天局探月与航天工程中心主任刘继忠发布了世界上第一个航天领域大模型——“航天-百度·文心大模型”。</p><p></p><p>航天-百度·文心从航天领域的数据和知识中融合学习，可以对航天数据进行智能采集、分析和理解，助力深空智能感知、规划和控制等技术突破。</p><p></p><p>刘继忠表示，“‘航天-百度·文心大模型’的应用，可以促使科研人员有更多精力投入到创新、创造的工作中。未来，双方将充分发挥各自优势，在深空探测智能技术研发、应用平台开发及项目实施、太空科创科普传播和人才培养等方面开展全面深入合作。”</p><p></p><p>王海峰还分享了飞桨产业级深度学习开源开放平台助力牧民、农民、电厂工人用上AI的实践应用。例如在牧场，基于飞桨开发的母羊分娩预测和预警系统，减少母羊分娩过程的人工看护工作量、降低母羊难产率；农学专家利用飞桨，保障无人驾驶拖拉机等智能农机按照预定的轨迹精准作业；在电厂，基于飞桨打造的电厂设备故障智能预判系统，可智能诊断设备故障，高效检修。</p><p></p><p>数据显示，目前，飞桨已汇聚477万名开发者。在产业级知识增强文心大模型方面，目前文心家族已经发布了20多个大模型，包括联合发布的鹏城-百度·文心、国网-百度·文心和浦发-百度·文心等。</p><p></p><p>值得一提的是，百度在大会现场用AI复原了中国十大传世名画之一《富春山居图》的残卷。基于文心大模型“补全”传世名画《富春山居图》残卷，隔三百年的山水合而为一，并题诗一首，，“一峰一状百树迎，天水合璧两岸情”。现在，在百度APP搜索“富春山居图”，每个人都可以参与《富春山居图》的“虚拟补全”，创作属于自己的《富春山居图》。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/c6/8a/c64583e8bec07c6b1ac9c91eb930788a.png\" /></p><p></p><p></p><h2>百度智能云的新成绩单：发布开物、九州</h2><p></p><p></p><p>百度集团执行副总裁、百度智能云事业群组负责人沈抖分享了百度在企业智能化升级的技术成果。</p><p></p><p>数字化转型升级已是当下和未来不可忽视的科技趋势。其中，云计算是推动数字化转型的重要基础设施之一。百度智能云侧重将其“云智一体”的能力，先从重点行业的核心场景切入，积累行业经验，再把不同行业的通用需求沉淀到通用AI产品中，打造成标准化产品，降低AI使用门槛，帮助企业从数字化驱动进阶为智能化牵引。</p><p></p><p>在帮助传统产业进行智能化改造方面，百度展示了在电力、能源、水力、制造、农业等行业的应用案例。应用实践和数据显示，AI风机巡检可以代替电力工人冲在一线最危险的地方，让巡检效率最高提升10倍；在石家庄城市社区供暖系统的智能化改造项目中，通过智能化管理和调度，整个石家庄城市热网节能20%....</p><p></p><p>为助力传统产业智能化改造，降低AI使用门槛。沈抖现场发布了全新版本的开物2.0工业互联网平台和九州区县大脑。目前，开物2.0累积超过200个工业解决方案，沉淀了3.8万个工业模型，覆盖质量管控、安全生产、节能减排、生产制造等9大领域，为工业领域企业上云、用数、赋智提供数字化服务。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/6a/8a/6a2912e974b4389d649e3524dd99ac8a.png\" /></p><p></p><p></p><p>除开物2.0之外，大会还发布了百度智能云九州区县大脑，用数字技术助推基层城乡治理，孵化地方产业、文化、生态场景的数字化应用。</p><p></p><h2>AI智能硬件：小度构建“未来的家”</h2><p></p><p></p><p>在AI智能硬件方面，小度科技CEO景鲲现场发布了三款围绕健康的新品——小度添添智能健身镜M30、小度语音智能闹钟及小度大屏护眼学习机P20。</p><p></p><p>据悉，小度添添智能健身镜M30可以改善健身枯燥、难坚持等痛点，内置17类健身课程，拥有体感游戏、双人游戏、多人在线连麦健身模式等，满足全年龄段人群的健身需求，增强运动的趣味性和互动感。小度添添智能健身镜还具有 “AI火柴人投影技术”及智能动作指导等功能。除健身功能外，小度添添智能健身镜M30还能听歌、K歌、投屏、刷短视频、播报天气和新闻。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/f2/3c/f2657f4296b5a643638f5723f7afaa3c.png\" /></p><p></p><p></p><p>小度语音智能闹钟由小度和中国科学院脑科学与智能技术卓越创新中心等多位睡眠领域专家联合打造，可基于专业的睡眠测试，为用户推荐适合的白噪音、轻音乐，打造专属助眠解决方案。小度语音智能闹钟还能在睡眠期间监测睡眠质量及环境，并生成睡眠质量报告。小度语音智能闹钟还具备红外远程遥控功能，一句话控制家中的新老家电，创造易眠环境。</p><p></p><p>小度大屏护眼学习机P20，搭载15.6英寸AI护眼屏幕，具备防蓝光、防眩光无频闪、AI屏幕光线自适应调节等20重护眼功能。同时基于AI摄像头能力，能够实时监测孩子坐姿，当发现错误坐姿时，会主动发出语音提醒给予纠正。此外，涵盖学前教育、整个义务教育阶段在内的全学科内容，同时搭载AI精准学系统，帮助学生诊断出学习中的难点和薄弱项等。</p><p></p><p>景鲲在现场还宣布，未来将在线下增设100家全屋智能体验门店，加速小度“未来的家”落地。</p>",
    "publish_time": "2022-07-21 13:38:34",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "一文读懂 BizDevOps：数字化转型下的技术破局",
    "url": "https://www.infoq.cn/article/7U3GVJ451dNfNqjcQhhj",
    "summary": "<p>我们正迈向数字经济时代，数字化转型成为普遍行动。未来绝大多数业务都将运行在数字基座之上，软件系统成为业务创新和发展的核心引擎。在这一趋势下，产品研发的交付能力面临巨大挑战，产品研发的交付实践和方法亟待变革。</p><p></p><p>BizDevOps 将是这一变革的主题，是数字化时代的技术破局之道。</p><p></p><p>本文将分成 3 个部分，系统介绍 BizDevOps 体系，它们分别是：</p><p></p><p>1）BizDevOps 产生的背景；</p><p>2）BizDevOps 要解决的核心问题和基本解法；</p><p>3）BizDevOps 的数字化模型和实践体系。</p><p></p><p>我们将从数字化转型这一背景开始，理解 BizDevOps。</p><p></p><p></p><h2>数字化转型将重塑业务和技术的关系</h2><p></p><p></p><h3>数字化统一了质量、效率和体验，是一次历史性的飞跃</h3><p></p><p></p><p>“统一质量和效率”，是工业时代的最大成就之一。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/4c/4c8e155eef2146511dd3a6c61c803ed4.png\" /></p><p></p><p>图⒈ 工业时代实现了质量和效率的统一，是人类史上的一次伟大飞跃</p><p></p><p>手工业时代的特征是“慢工出细活”，质量和效率不可兼得。进入工业时代，通过规模化和标准化的过程，从流水线上源源不断产出的产品既好又便宜，实现了质量和效率的统一，这是人类史上的一次伟大飞跃。</p><p>规模化、标准化加上科学技术的应用，一同造就了 20 世纪的繁荣，其影响不仅限于制造业。标准服务流程（SoP）的应用，让服务业的效率和质量也同步跃升。但，它是以牺牲个性化体验为代价的，正如福特先生的幽默表述：“你可以要任何颜色的汽车，只要它是黑色的”。</p><p></p><p>标准化天然排斥个性化。受限于技术条件，为了质量和效率，牺牲个性化体验是不得已的选择。而，数字化将彻底改变这一切。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/be/bef7ca32f7187200a55283060bc3bb45.png\" /></p><p></p><p>图⒉ 数字化时代在质量和效率的基础上进一步统一了体验</p><p></p><p>数字化技术让企业在实现高效和高质的同时，满足个性化的体验需求。</p><p></p><p>如果，工业时代的主题是“规模化标准制造”；那么，数字化时代的主题就是：“规模化定制”。定制的既包含实体产品，也包含服务。在数字技术支持下，精准医疗、个性化教育都将成为普惠的服务。在工业时代，这绝无可能。</p><p></p><p>从规模化标准制造到规模化定制，这是继工业革命统一效率和质量之后，人类历史上的又一次里程碑意义的飞跃，它将是未来业务竞争的胜负手。为此数字化转型将是每一个企业所必须回答的命题。</p><p></p><p>问题是，数字化转型何以能够，又将如何实现这一飞跃呢？</p><p></p><p></p><h3>数字化转型的三个核心能力</h3><p></p><p></p><p>为了统一效率、质量和体验，通过数字化转型要建设三个核心能力。如图 3 所示，它分别包括业务、技术和数据 3 个方面。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/4e/4e96ffbb3cbaf7431627d5f793c4dae5.png\" /></p><p>图⒊ 数字化转型的三个核心能力</p><p></p><p>第一个核心能力是：从业务视角关注出发，连接价值交付连路。它体现为图 3 的横坐标，也就是从关注各个独立业务环节，到打通价值交付链路。</p><p></p><p>IT 应用的早期，通常从各个独立的业务环节开始，站在企业内部视角，提高现有业务模式的运行效率。</p><p></p><p>在数字化转型中，为了满足个性化的体验，必须从企业内部视角，切换到用户视角，连接从需求的获取、还原、设计、生产、交付、服务的端到端过程，这样才可能去精准满足每个用户的个性化需求。</p><p></p><p>连接端到端的价值链路，是数字化转型的第一步，也是最基础的一步。但，它并非数字化转型所特有。数字化转型的本质不同是，它在满足个性化体验的同时，保障效率和质量。做到这一点就需要数字化技术的加持，这也是数字化转型的第二个核心能力。</p><p></p><p>第二个核心能力是：从技术视角出发，实现全链路的数字化。它体现为图 3 的纵坐标，也就是从信息传递到数据共享。</p><p></p><p>信息化是将已有的业务搬上线。比如，早期的 OA 系统，会计电算化系统，以及各个业务环节的信息支持系统，都属于此类。此时一方面，数字世界和物理世界之间需要通过信息的传递，来保持同步；另一方面，不同业务环节，也需要通过信息的传递来实现集成。</p><p></p><p>信息化带来的直接好处提高运作效率和规范性。数字化则要对个性的用户需求快速、精准的响应，并保障效率和质量。为此，数字化必须从信息传递进化为数据共享。</p><p></p><p>数据共享体现为两个方面：</p><p>1）数字世界和物理世界的数据共享，数字世界应该能够与物理的世界实时的同步与互操作。数字世界建模并反映物理世界的实时状况，数据在数字世界的算法处理后，能够转化为物理世界的动作，并即时反馈到数字世界；</p><p>2）业务链路上的数据共享。价值交付链路应该实时共享同一份数据，并且都能够理解和应用这一份数据。</p><p></p><p>只有通过以上两点，数字化才能够发挥真正的作用，即时响应用户的需求，并精准和高效的满足它们。</p><p></p><p>为了做到这两点，数字化首先要还原业务的本质，基于对业务的本质理解，建立底层数字化模型，在各个环节的实现数据连通和共享，并实时连接数字世界和物理世界。</p><p></p><p>综合第一和第二个能力，就实现了数字化转型的基础目标，也就是图 3 中的第一象限——用户价值驱动的全链路数字化，它为统一质量，效率和体验奠定基础。同时，在数字化运作过程中将产生高质量的可用数据。数据的应用，让让数字化的效益倍增。这也是数字化转型的第三个核心能力。</p><p></p><p>第三个核心能力是：从数据视角关注数据应用和数据智能，它体现为图 3 的顶部的内容。</p><p></p><p>依赖高质量的数字化模型和运作过程，就能够产生高可用数据，它具备三个特点，分别是：</p><p>1）全量——业务运作过程被完整记录；</p><p>2）全要素——数据从各个维度反映和还原业务；</p><p>3）实时——数据在业务运作过程中实时产生。</p><p></p><p>全量、全要素和实时的数据，是数据应用和数据智能的基础。通过数据应用，一方面可以保障和持续改进数字化运作的效率和质量；另一方面，更重要的是数据本身将成为核心业务资产，而挖掘和应用这些资产的价值，将会创造全新的业务模式和用户体验。</p><p></p><p></p><h3>数字化转型将重塑业务和技术的关系</h3><p></p><p></p><p>数字化转型的 3 个核心能力，共同作用同步提升业务运行的效率、质量和体验，并赋能数字化时代业务的发展和创新。</p><p></p><p>而这三个核心能，不管是连接价值交付链路，还是全链路的数字化，或者是数据应用和数据智能，都必须建立在 IT 技术之上，以技术为核心来构建。</p><p></p><p>数字时代，技术将成为业务的内核。技术与业务的关系也将因之被重塑。技术与业务之间关系的重塑是一个持续的过程，图 4 大致反映了这一历程。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/88/882859eeda72868778078dffa37acd82.png\" /></p><p></p><p>图⒋ 技术成为数字业务创新和发展的核心动力</p><p></p><p>早期的信息化时代，技术与业务的典型关系是：Biz 与 Dev 相互分离，Dev 和 Ops 相互分离。信息化的目标是将已有业务搬到线上，改进运营效率。此时，业务的确定性较高，技术的任务则是响应并分析来自业务的明确需求，设计、实现和交付软件系统。与之对应，主流的 IT 协作和交付方式是瀑布式流程方法。</p><p></p><p>本世纪初，我们进入互联网时代，技术与业务的关系发生了变化： Dev 和 Ops 融合，Biz 与 Dev 更紧密的协同，技术在支撑业务的发展同时，也拓展了业务的边界，诸如电子商务、互联网金融都是这个时代的产物。</p><p></p><p>同时，业务的不确定性也持续增加，对迭代、反馈和持续交付的诉求越来越高。与之对应，敏捷和精益方法成为主流，DevOps 实践体系逐渐完备。</p><p></p><p>今天我们正在进入数字化时代，未来几乎所有业务都将运行在技术底座之上，其发展和创新都离不开技术的支撑，技术已成为业务创新和发展的核心动力，甚至有人提出 IT 即业务，业务即 IT。与之对应，数字化时代需要自己的实践体系，它是 DevOps 运动的延续和发展，也就是在 Dev 和 Ops 融合基础上，Biz 与包括 Dev 和 Ops 在内的技术进一步融合，我们将其定义为 BizDevOps。</p><p></p><p>BizDevOps 是数字化时代，业务和技术关系重塑的必然要求和结果。接下来，我们将解析数字化时代技术和业务所面临的挑战和问题，并从这些问题出发构建 BizDevOps 的数字化模型和实践体系。</p><p></p><p></p><h2>产品研发的数字化转型和 BizDevOps 体系</h2><p></p><p></p><h3>数字化对产品研发的交付效能带来极大挑战</h3><p></p><p></p><p>数字化时代，技术交付的复杂度持续提升。首先，打通端到端的价值交付链路，意味着经常需要跨业务和产品的协同才能交付完整价值，协作的复杂度变大；其次，系统复杂度的提升，以及全面的数字化带来的包括云、IOT、边缘设备和各类终端的联动，让工程复杂度极大提升；最后，随着技术和业务的融合，业务本身的不确定性和复杂度也在提升。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d2/d27b5d8f98b177c270a2881dbd2ae605.png\" /></p><p></p><p>图⒌ 数字化时代 IT 的交付效能急需提升</p><p></p><p>随着协作、工程和业务复杂的提升，如果保持过去的实践不变，研发的交付效能必然会有降低的趋势。然而，数字化时代，业务发展和创新对系统交付的依赖越来越强，业务对交付能力的要求也越来越高，不管是质量、效率和有效性的诉求都在提高。</p><p></p><p>如图 5 所示，一方面效能有下降的趋势；另一方面对产品研发的期待不断提高。在效能的期望与现实之间就产生了巨大的差距。为了弥补这一差距，首先要弄清楚背后有哪些具体的问题。</p><p></p><p></p><h3>数字化时代产品研发挑战背后的 3 个核心问题</h3><p></p><p></p><p>在着手提升技术交付效能前，首先要弄清楚效能背后的核心问题是什么，然后才是落地解决问题的实践方法。否则问题没定义清楚，就很难有好的结果。我将提升效能要解决的问题，归纳为 3 个效能不等式。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/a1/a1cd62e9f17342690f1a567c9674fee6.png\" /></p><p>图⒍ 数字化时代产品技术交付的三大核心挑战</p><p></p><p>第一个不等式：局部效率不等于高效交付。</p><p></p><p>相信，很多人会感同身受。当我们去问各个部门或者个人时，他们都觉得很忙，效率很高。但是，我们去问业务部门或用户，却是另外一回事，他们会抱怨产品研发响应慢、交付迟、质量也不好。</p><p></p><p>这就是组织内部视角的局部效率并不等于用户视角的高效交付。这个是提升研发效能要面对的首要问题。解决它需要更有效的组织协同、更合理交付模式，和更好的过程质量。接下来的问题是，高效交付就够了吗？这就引出了第二个效能不等式。</p><p></p><p>第二不等式，高效交付能不等于持续高效。</p><p></p><p>很多时候为了高效的交付，我们会成立临时项目并集中办公，沟通协作会更便捷，这可能会达成一时的高效。但是，如果缺乏长期质量思维，当我们在做下一个项目，往往会发现问题。之前的代码和设计存在各种问题，可复用性和可维护性都很差，为后续项目留下的是负债而不是资产，长期的效率无法维持。</p><p></p><p>如何从高效交付转变成持续的高效，这是研发效能要解决的第 2 个问题。它对我们的工程和技术能力和实践都提出了要求。</p><p></p><p>第三个不等式，高效交付不等于业务成功。</p><p></p><p>产品交付的目的是支持业务发展和业务创新。我们必须保证交付的东西，能解决用户问题，并构建可持续的商业模式，否则交付再多也没有意义。</p><p></p><p>今天，市场和用户的不确定持续增加，破解这一问题不容易。它需要整个组织能够聚焦用户问题，快速交付和试错，并形成有效反馈调整的闭环。做到这三点才能让高效交付转化为业务成功。这是提升研发效能要解决的第三个核心问题。</p><p></p><p>研发效能提升的本质就是要化解上面的三个不等式，从而把组织内的局部效率转化为持续的用户可感知的高效交付，从而赋能数字业务的创新和发展。</p><p></p><p></p><h3>面对挑战，产品技术团队自身更需要数字化转型</h3><p></p><p></p><p>面对上面的 3 个效能不等式，如果把产品研发也当做一类业务，那它本身就迫切需要数字化转型——通过产品研发的数字化，实现效率、质量和体验的同步提升。这里的体验具体到产品研发中，指的是交付的有效性。</p><p></p><p>为了理解产品研发的数字化转型，我们将引用前述的数字化转型 3 个核心能力，它同样适用于产品研发。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/6f/6f639e2d27cecfca8def65c005828ed3.png\" /></p><p>图⒎ BizDevOps 的三个核心能力</p><p></p><p>首先，业务上寻求连接业务需求交付链路。也就是用户价值驱动，打通从业务（Biz）到开发（Dev）到运维（Ops）的端到端业务需求交付链路和反馈闭环；</p><p></p><p>其次，技术上寻求全链路数字化。也就是连通协作和工程及各个子领域，建立统一的数字化模型，并共享底层数据，实现组织协同、工程活动的全链路数字化和有效连接，保证整个交付链路的效率、质量和有效性。</p><p></p><p>最后，数据上寻求数据支持的持续改进。也就是基于全量、全要素和实时的数据，从场景目标出发，设计和应用系统的度量，保障产研交付的执行并持续改进交付效能。</p><p></p><p>建设以上三个能力，实现产品研发的数字化转型，其结果就是打造 BizDevOps 体系。</p><p></p><p>我们将 BizDevOps 体系的总体目标表述为：</p><p></p><p></p><blockquote>打通组织中的各个职能环节，实现业务、开发和运维的一体化运行，形成高效和精准的业务交付、业务反馈和业务调整闭环，赋能数字业务的发展和激发数字业务的创新。</blockquote><p></p><p></p><p>BizDevOps 的实施，首先需要构建产品研发的数字化模型，并以此为基础构建 BizDevOps 实践体系。接下来，我们将分别介绍 BizDevOps 背后的数字化模型，以及 BizDevOps 的实践体系。</p><p></p><p></p><h2>BizDevOps 的数字化模型和实践体系</h2><p></p><p></p><h3>从价值交付链路出发构建 BizDevOps 的标准数字化模型</h3><p></p><p></p><p>产品研发数字转型一个重要的基础工作是，建立产品研发的数字化模型。一个好的数字模型，可以极大提升产品研发的数字转型的成功概率和效率。</p><p></p><p>构建有效的数字化模型，应该从分析价值链路开始，并识别主要价值链路上的价值流动单元。例如图 7 中：业务价值交付链路对应的价值流动单元是业务需求；产品交付链路对应的价值单元是产品需求；工程变更链路对应的价值单元是变更；质量管理链路上，主要的价值单元是缺陷。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b3/b3c3dd3afb76679b4cff171e2bff847e.png\" /></p><p>图⒏ BizDevOps 数字化标准模型之极简版</p><p></p><p>上图是我们定义的 BizDevOps 数字化模型的极简版。其中，红色框是各个主要链路上的价值单元，这些链路相互关联，是产品研发数字化的内核，确保该模型可以支持全链路的数字化实践。我会在后续的文章或标准中给出更细节的模型定义，并解读模型设计背后的原则和方法。</p><p></p><p></p><h3>BizDevOps 的实践体系框架</h3><p></p><p></p><p>数字化模型是产品研发的数字化的基础，要落地 BizDevOps，更重要的是提供完整的应对数字化时代产品研发效能挑战的实践体系。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/17/17c1f70d29f0fbfab933887a0543ecf1.png\" /></p><p>图⒐ BizDevOps 实践体系框架</p><p></p><p>上图是对 BizDevOps 实践体系的完整框架，它综合了我和同事以及合作伙伴们多年的实践探索。</p><p></p><p>BizDevOps 实践框架从上到下分为三个层次，分别是：</p><p></p><p>1）价值链路层面。任务是打通业务交付的协作和工程链路；</p><p>2）技术交付层面。任务是提供高效的团队协作和工程数字化实践，确保协作和工程的基础效率、质量以及可持续性；</p><p>3）实践方法层面。提供数字化之外的实践方法支撑，如需求分析和领域建模实践，它为数字化运作的效率提供基础的保障。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/9c/9c302f5e36b9c757610988f3ae851352.png\" /></p><p>图⒑ BizDevOps 实践体系框架与产品技术交付的挑战的对应</p><p></p><p>BizDevOps 实践体系的不同部分，分别解决前文所述 3 个效能不等式，这些实践相互协同构成一个完整体系，确保产品研发团队可以持续地顺畅高质量交付有效价值。</p><p></p><p>下面，我将分别简要的介绍这些实践。</p><p></p><h4>需求和协作实践</h4><p></p><p></p><p>BizDevOps 实践框架图（图 9）的左侧是需求和协作实践。它解决的问题是：如何把局部效率转化为高效交付。它可以细分为三组实践。从下到上分别是：</p><p></p><p>以终为始的需求分析和设计。它解决的具体问题是：如何分析业务和设计需求，确保输入质量，为高效、高质量的交付有用价值创造前提？</p><p></p><p>产品导向的交付模式。它解决的具体问题是：如何组织交付团队，高效交付需求的同时，持续迭代产品，改进能力，提升交付效能？</p><p></p><p>业务驱动的协作模式。它解决的具体问题是：如何让整个组织围绕业务目标有效协同，快速响应和交付业务需求，并形成业务反馈闭环 ？</p><p></p><p>这三组实践，从需求输入到团队交付再到组织协同，共同确保局部的效率可以转化为高效的交付。</p><p></p><h4>技术和工程实践</h4><p></p><p></p><p>BizDevOps 实践框架图的右侧是技术和工程实践。它解决的问题，是如何把高效交付转化为持续的高效。它又可以细分为三组实践。从下到上分别是：</p><p></p><p>领域驱动的架构和实现。它解决的具体问题是：如何从业务出发，设计系统和服务架构并转化为高质量的代码实现，保障技术开发的长期效率？聚合和管理研发资产及工程活动。它解决的具体问题是：如何组织研发资产和研发活动，并有效的管理和演进它们，持续提高工程响应和交付能力？建设持续的业务发布能力。它解决的具体问题是：如何适配场景落地工程交付流程，并连接工程交付与业务响应，实现业务需求的高效发布，并形成有效的反馈闭环？</p><p></p><p>这三组实践，从技术实现到应用变更到业务发布，共同确保高效的交付可以转化为持续的高效。</p><p></p><h4>度量和改进实践</h4><p></p><p></p><p>BizDevOps 实践框架图的底部中间部分是度量和改进实践。它是支撑性的实践，解决的问题是如何设计和落地有效数据和度量体系，保障研发交付的落地执行，并指导研发效能的改进。</p><p></p><p>度量和改进实践具体包含三个方面，分别是：</p><p></p><p>1）以数字化模型为基础产出全量、全要素和实时的基础数据；</p><p>2）从场景目标出发设计可靠的度量；</p><p>3）以度量为支撑保障执行并持续提高效能。</p><p></p><h4>业务创新实践</h4><p></p><p></p><p>BizDevOps 实践框架图的中间部分是业务创新实践。它解决的问题是如何让高效交付转化为业务成功，也就是以 BizDevOps 实践体系为基础，建立高效的业务探索、交付和 反馈调整机制，赋能数字业务的创新和发展？</p><p></p><p></p><h2>总结：赋能数字业务的发展和创新</h2><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/96/968057329053c042d26fa4f87d58adec.png\" /></p><p>图⒒ 特斯拉创始人马斯克关于设计工厂和汽车的推文</p><p></p><p>特斯拉的创始人埃隆.马斯克曾经在推文中说到：“设计生产机器（汽车）的机器（汽车生产流水线），比制造机器（汽车）本身要困难十倍、百倍。而人们经常不能很好的理解这一点”。同样，打造支持数字化业务的流水线，比设计单个数字化业务本身要困难十倍、百倍。</p><p></p><p>我们正加速进入数字化时代，BizDevOps 的使命是打造数字化业务背后的流水线，持续赋能数字化业务的创新和发展。为此，BizDevOps 将打破技术和业务的隔阂，重塑两者的关系。BizDevOps 更需要定义数字化模型，完善需求、协作、工程和技术实践，并将它们整合为完整的数字化体系，用数字化的方式来支持数字化业务的创新和发展。</p><p></p><p>本文介绍了 BizDevOps 产生的背景，定义了 BizDevOps 解决的核心问题，并以此为基础总结了 BizDevOps 的实践框架，希望对你在数字化时代实现技术破局有所启发。</p><p></p><p>不过本文并未深入到各个具体的实践。今后的文章中，我将以这个框架为蓝本，对各个专项的实践做深入的介绍，与大家共同探讨 BizDevOps 的实践。</p><p></p><p>作者简介：</p><p></p><p>何勉，畅销书《精益产品开发：原则、方法与实施》作者</p>",
    "publish_time": "2022-07-21 15:21:37",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "用现代化的开发方法和思维，打跑遗留系统“拦路虎”",
    "url": "https://www.infoq.cn/article/rSeHKjVRzQSRl5mvJRJO",
    "summary": "<p>嘉宾 | 姚琪琳</p><p>编辑 | 严强</p><p></p><p>随着技术的不断升级进步，系统也需要逐步升级换代，而遗留系统就像是一只只“拦路虎”，阻挡着转型之路。</p><p></p><p>要想治理遗留系统，就要弄清楚遗留系统到底是什么。但对于遗留系统的定义，可谓是众说纷纭。到底什么样的系统才会被称为是遗留系统？在治理遗留系统之前，我们需要做哪些准备工作？我们又如何在不影响业务的同时，以更安全、更高效、更低成本的方式将这些遗留系统进行改造，使之更好地支持业务的拓展，适应技术的发展方向？</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/ff/ffb6396c22722155a83b39cba7b342de.png\" /></p><p></p><p>基于以上问题，我们邀请了 Thoughtworks 数字化转型与运营部门资深咨询师姚琪琳老师来分享关于遗留系统现代化的实践经验，希望能够给你带来启发。同时姚琪琳老师也在 <a href=\"https://time.geekbang.org/qconplus/home\">QCon+ 案例研习社</a>\"【遗留系统怎么办？将改造进行的到底！】专题，带来了<a href=\"https://time.geekbang.org/qconplus/detail/100110403\">遗留系统现代化的原则、模式与实践</a>\"的分享，欢迎收看！</p><p></p><p>以下是对姚琪琳老师的专访：</p><p></p><p>InfoQ：你最近在负责什么样的工作呢？</p><p></p><p>姚琪琳：我现在的身份是技术教练和技术顾问，主要帮助客户解决一些软件技术方面的问题，包括但不限于代码重构、架构治理、DDD 改造、微服务改造、敏捷转型、人才赋能等等。最近的话，是帮助一家企业对他们的遗留系统进行现代化。有意思的是，我从入行到现在，几乎一直都在跟各种遗留系统打交道，可以说已经被“虐”习惯了。</p><p></p><p></p><p>InfoQ：对于遗留系统，有不同的定义，从个人角度，你认为什么样的系统才会被称为是遗留系统呢？</p><p></p><p>姚琪琳：这是个好问题，我们在治理遗留系统的时候，一定要先搞明白什么是遗留系统，什么不是。对于遗留系统，维基百科的定义是“一种使用旧的方法和技术的、过时的，却仍旧在使用的计算机系统。”Garnter 的定义是“基于过时技术但对日常运营至关重要的信息系统。”从这些定义可以看出来，“技术陈旧、过时、重要、仍在使用”这些就是遗留系统的特点。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/69/69bb272a2c0ce0dc9f70a00acec988c8.png\" /></p><p></p><p></p><p>“技术陈旧”和“过时”这两个词语不言而喻，符合绝大多数人对遗留系统的认知。但“重要”和“仍在使用”就比较有意思了，它们说明了遗留系统对于企业运营的重要作用。假设一下，一个没人使用的旧报表系统是遗留系统吗？如果按照上述定义，它就不是，因为它不是“仍在使用”和“对日常运营至关重要”。所以遗留系统的定义隐含了一个信息就是，企业很难无视它，如果它本身很庞大、很复杂，也很难被替代。</p><p></p><p></p><p>InfoQ：面对一个遗留系统，我们该如何入手去改造它呢？在开始之前有哪些注意点？</p><p></p><p>姚琪琳：其实我比较反对用遗留系统“改造”这个词来描述遗留系统的治理工作，因为改造不一定能改好，如果方法不对，很可能越改越糟糕。我见过很多遗留系统，改之后和改之前相比并没有特别大的差别。也有很多改了一半改不动了，只能不了了之。</p><p></p><p>我习惯使用的是“遗留系统现代化”这个名词。因为“现代化”意味着你的目标是现代的，那么无论从代码、架构还是各种技术上，都要引入现代化的东西。但这并不意味着什么都要用最新的，新的不一定适合你的系统和团队能力，一定要量力而行。</p><p></p><p>所以我说的现代化是指现代化的开发方法和架构思维。比如在写生产代码时要添加测试，在做架构选型时要注重认知负载，搭建 DevOps 平台来实现持续集成等等。</p><p></p><p>当然，在开始一个遗留系统现代化项目时，也有很多技术之外的事情要做。首先就是要明确现代化的目标，并制定度量指标，然后以假设驱动的方式来进行验证。很多遗留系统改造的项目在一开始都比较盲目，是为了改而改。比如，将单体拆分为微服务，只是觉得微服务是流行的系统架构，但并没有想过它给整个系统带来的好处是什么，以及如何评价这个好处。所以等改完上线之后，只要没有大的 bug 就算验收了。</p><p></p><p>但实际上，这会给业务方带来非常糟糕的体验，下次再想“合作”来治理系统，就难上加难了。如果可以在改之前就明确有业务意义的度量指标，每次迭代上线时都监控这些指标，并随时展示给业务方看，就能自然而然地得到他们的认同和支持。</p><p></p><p>其次，在项目开始之前，还要跟业务方、运营方沟通好，尽量不要在这期间上线新的需求。因为改进和新需求同时做的难度非常大，会凭空增加很多工作量，加大改进的风险。</p><p></p><p></p><p>InfoQ：你印象最深的一次遗留系统改造的实践是什么？为什么令你印象最深刻？</p><p></p><p>姚琪琳：印象最深的与其说是遗留系统改造，不如说是如何避免一个运转良好的系统成为遗留系统。这其中用到的技能和知识与遗留系统的现代化差不多，但客户的心态却完全不一样。</p><p></p><p>如果客户的诉求就是治理遗留系统，那我们的大多数举措都会得到支持。但如果客户是想做一个软件，他就会更多地关注我们交付的价值，而不是如何对代码和架构进行维护。然而这部分工作又是十分重要的，否则就是在通往遗留系统的道路上一去不返。</p><p></p><p>客户的态度决定了我们被赋予的资源，包括时间、人力等等。如何在有限的资源下守护住代码和架构，是对一个架构师最大的考验。</p><p></p><p></p><p>InfoQ：在这过程中遇到了哪些困难？你是通过怎样的努力解决的，有哪些沉淀和启发？</p><p></p><p>姚琪琳：困难有很多。比如我上面提到的，如果客户想要做单体架构的拆分，他们就会给你时间和人员去做这件事，但如果你是在一个单体架构的项目上做软件交付，想说服客户去做架构的治理是很难的，有时候只能挤时间做。</p><p></p><p>我曾参与的一个项目有一次终于说服了客户去做架构拆分，但是资源十分有限，只有 80 个人天左右。这对于一个有点规模的单体来说是远远不够的。但少总比没有强，于是团队成员撸起袖子就开干了。然而过程很艰辛，效果却并不理想，以至于以后再和客户去聊类似的问题时，都会吃闭门羹。</p><p></p><p>吃一堑，长一智。在认真复盘后我们发现，一味地从技术方面去和客户谈判是徒劳的，要从业务出发，去告诉客户技术改进可以给业务带来的价值。比如，如果把系统忙季较常使用的服务剥离出来独立部署和演进，就可以在忙季对这个服务进行扩容，从而更好地支撑业务。同时单个服务的扩容比整个单体的扩容需要的资源更少，也更省钱。再比如，我们抽出两个人专门做两周的部署流水线的优化，可以将代码提交到部署上线的时间缩短 20%，提升业务的敏捷性。当我们拿出的不是技术方案而是价值时，客户的态度自然也就缓和了。</p><p></p><p>当然这一切都不容易，因为指标的度量都无法准确地估算。</p><p></p><p>虽然我说的这些是与客户相关的，但其实这和与业务方、运营方的沟通是一样的。大多数软件项目所面临的问题其实都不是技术问题，而是人的问题、利益的问题和价值的问题。</p><p></p><p></p><p>InfoQ：业内有哪些优秀的实践和工具能帮助我们更好地改造遗留系统呢？</p><p></p><p>姚琪琳：其实一个系统之所以成为遗留系统，就是因为从一开始没有引入现代化的开发方法和思维模式，或者一开始引入了，但没有随技术的进化而跟着演进，没有与时俱进。</p><p></p><p>我们要做的，就是重新引入这些优秀的实践。比如一个遗留系统没有测试，那我们就引入测试；如果业务都位于前端的 JSP，那我们就把 JSP 中的 Java 代码移动到后端，进行前后端的分离；如果模块之间职责不清，那就和业务人员一起讨论，用 DDD 的方式重新划分上下文；如果项目中没有 CI/CD，我们就引入 CI/CD……自动化测试、前后端分离、DDD、部署流水线……这些都是现代化的开发方法，把它们循序渐进地引入到遗留系统中，那么遗留系统的现代化也就完成了。</p><p></p><p>提到工具，其实有很多代码分析、模块分析的工具可以帮助我们发现系统中的问题。比如可能所有项目都已经有的 Sonar，它是一个十分优秀的代码分析工具，可以帮助我们发现代码中的很多潜在问题。但恐怕大多数项目都只是引入了这个工具而已，至于是否有计划去改进 Sonar 扫描出来的问题，可能不提也罢。</p><p></p><p>依赖分析工具包括 Backstage、Aplas、Honeycom、Systems 等，它们可以帮助我们建立一张遗留系统的地图，这样就可以快速知道一个业务是由哪些模块组成的。</p><p></p><p></p><p>InfoQ：当下你都在关注哪些新的技术热点和趋势？</p><p></p><p>姚琪琳：这个问题有点难住我了，因为我突然发现自己近期关注的热点和趋势都跟“技术”不沾边。我最近关注的是 Cynefin、Team Topologies、Domain Storytelling、元宇宙和认知心理学。</p><p></p><p>Cynefin 是一个认知框架，它将问题划分为 Clear、Complicated、Complex 和 Chaotic 几个区域，每个区域有不同的应对方式。这个框架对我们这种问题解决者特别有用，它可以让我先将问题归类，再选择应对策略。</p><p></p><p>还是拿遗留系统来说，如果单纯是技术问题，它就位于 Complicated 域，应对策略是引入专家，进行分析和分解，将繁杂问题分解为很多 Clear 的简单问题。我以前一直都是这么认为的，但直到后来我发现，遗留系统现代化不是一个纯粹的技术问题，它里面包含开发人员、业务人员、测试人员、架构师等各种角色。这些人带来的不确定性，使这个问题变成了一个 Complex 问题。那应对方案就变成了先试验，找出一个可以探索的方向，然后再摸着石头过河。因此，这个先定位问题，再寻找解决方案的框架，让我少走了很多弯路。</p><p></p><p>Team Topologies 翻译过来是团队拓扑学，我特意在后面多了一个“学”字，因为我认为它未来很可能成为与敏捷齐名的软件开发方法论。虽然它看上去很浅显，只是包含了四种团队结构和三种协作方式，但实际上它提出的 team first 的思想，是远远领先于业内的。这个概念的两位缔造者出了一本同名的书，中文版叫《高效能团队模式》，感兴趣的同学可以看看。</p><p></p><p>长久以来在大型软件系统的建模领域，似乎就只有 Event Storming 这一种方法，而近年冒出来的 Domain Storytelling 填补了这一空白。它通过讲故事的方法来为领域进行建模，十分有意思。</p><p></p><p>元宇宙是最近非常火的一个热点，它对我的吸引力就在于这个重命名操作。如果还叫虚拟世界或其他名字，我可能还不会感冒。但是元宇宙这个名字太好了，它给了我无限的遐想。它把这个概念从游戏、社交等有限的场景中跳出来，赋予了无限广阔的可能。仅仅是医疗领域，我就能想到借助于体感衣的远程问诊、模拟手术以提高成功率等等很多使用场景，可以极大地改变人们的生活。</p><p></p><p>对于认知心理学的关注源自 Team Topologies 中提出的认知负载，这本是认知心理学的概念，我就顺着看了一些认知心理学的书，然后就产生了极大的兴趣。还有一个原因就是我需要辅导五年级女儿的学习，对于如何记忆知识、如何学习知识的好奇，也让我找到了认知心理学。</p><p></p><p></p><p>InfoQ：最后，你是如何走上这条职业道路的呢？和大家分享一些你的成长与进阶经验吧！</p><p></p><p>姚琪琳：这个说起来我也算是半路出家吧，本科和研究生拿的都是管理学的学位，接触编程的时间也比较晚，不像很多大牛在小学时就开始参加竞赛。我甚至连大学时唯一和编程有关的课程的大作业都是请学长帮我做的。但就是那一次，学长一边跟我聊天，一边就做完了一个系统，谈笑风生且剑指如飞。“这简直太酷了，我也要像他一样”的想法就应运而生了。</p><p></p><p>再后来就跟很多人一样，从程序员到架构师，就一路走来了。</p><p></p><p>最后，和对遗留系统感兴趣的小伙伴分享一些心得体会吧。其实我想说的是，没有人会对遗留系统感兴趣，没有人愿意工作在遗留系统上。但是，就像我的同事，重构和微服务的缔造者，软件开发领域的泰斗，Martin Fowler 说过的那样：Let’s face it, all we are doing is writing tomorrow’s legacy software today.</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/88/88c793d37c78e141a73042bf9d972b24.png\" /></p><p></p><p>你今天写的每一行代码，明天都会变为遗留系统。所以你即使没有工作在遗留系统上，也即将工作在它上面了。</p><p></p><p>因此，你应该调整好心态，积极面对，多喝热水……</p><p></p><p></p><p></p><p>嘉宾介绍</p><p></p><p>姚琪琳</p><p>Thoughtworks 数字化转型与运营资深咨询师，技术书籍译者。拥有超过十年的软件开发、设计和架构经验。近年来在企业遗留系统现代化、领域驱动设计、敏捷软件开发、整洁代码和重构等方面持续精进，并通过理论指导、实战演练等方式为企业研发团队赋能。参与翻译或审校多本技术书籍，包括《领域特定语言》、《.NET 性能优化》、《深入理解 C#》等。</p><p></p>",
    "publish_time": "2022-07-21 17:30:56",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "专访百度副总裁侯震宇：企业如何解决“用好云”的进阶问题？",
    "url": "https://www.infoq.cn/article/G7yrYfN7x530ltUMmypb",
    "summary": "<p>据 Flexera 的一份调研报告显示，大多数公司每年在云上的花费超过 100 万美元，多达三分之一的云计算资源没有被有效地使用或被浪费。可见，虽然按需弹性是云计算的优势，但如果资源规划、配置以及利用的方式不当，都会造成巨大的资源浪费。</p><p></p><p>企业到底如何实现“用好云”的目标？又该如何使资源效能发挥出最大的优势，带来成本结构的优化改善？7 月 21 日，<a href=\"https://baiduworld.baidu.com/m/world/2022/?sfrom=baiduappsearch\">百度世界</a>\" 2022 在线上召开，大会主论坛以“云智一体赋能实体经济发展”为主题，介绍了百度在能源、工业以及智慧城市的深入实践。此外，围绕降本增效、云智一体等话题，百度副总裁侯震宇等嘉宾在百度世界的子栏目《AI 可见度》中，又进行了深入地解读。为了挖掘企业“用好云”的关键路径以及百度集团上云的实战经验，InfoQ 也有幸对百度集团副总裁侯震宇进行了一次独家专访。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/0a/0a81f4f7bacf926ebd21759261886c72.png\" /></p><p></p><h1>从企业 IT 资源优化的关键路径说起</h1><p></p><p></p><p>作为数字经济的强大底座，云计算不仅要保持高稳定、高性能，还要具备高性价比的特性。目前，我们看到云服务已经基本能够满足上述提到的因素，但与此同时，无论是互联网企业还是传统企业，大家依然有持续降本增效的需求。因此，当企业走过了“上云”和“用云”的初期阶段，“用好云”则成为了更进阶的问题。</p><p></p><p>企业“用好云”的关键路径究竟是什么？侯震宇在采访中提到：“企业要想真正用好云，需要重新思考业务战略目标、技术理念以及组织能力三方面因素，从而实现真正意义上的云原生。”</p><p></p><p>企业需要围绕业务战略明确“上云”“用云”的目标，判断如何选择更加高效的基础服务。通常来说，想清楚这一步是企业实现持续用好云的关键。其次，为了满足业务创新和持续发展的要求，企业还需要将 IT 技术架构进行改造和升级，具体可以分为以下三个方面：</p><p></p><p>第一，选择“用好云”的基础架构。企业需要意识到，云服务的核心优势不仅仅停留在虚拟化和弹性，其还具备多形态的算力、产品以及增值等能力。例如，如果常规业务能够接受多样的算力形态，使用弹性、竞价抢占、潮汐算力等特性，相比常驻资源，成本预计会降低 2/3 以上；而对于在容器 K8s 上的业务，如果开启混部等能力，CPU 资源利用率可以提升到 45% ，甚至更高；</p><p></p><p>第二，设计面向云的业务架构。这就要求企业的 IT 团队在设计业务架构时，让业务架构具备服务化、弹性伸缩、可迁移性、可观测性以及韧性等云原生架构特性，从而把“上云”“用云”的价值发挥到最大；</p><p></p><p>第三，面向云的组织建设也同样重要。企业需要把云、基础架构、业务架构、运维等团队有机地结合在一起，建立专门的资源运营团队负责把控和规划，建立专业的服务体系连接云和各个业务方，最终让公司和每个业务都取得目标收益。</p><p></p><p>当然，企业在上云的过程中势必会带来短期的额外成本，如人力投入、资金投入等等，但从长远的角度来看，上云也将带来研发效能和资源效能的最大化，企业需要用长期主义的思维进行决策，坚定上云的选择。</p><p></p><h1>“一明一暗”两条线，百度的资源治理实践</h1><p></p><p></p><p>一直以来，百度自身就是云原生技术的实践者。侯震宇在采访时透露，约在五年前，百度就开始建设面向未来的基础架构，推进业务容器上云。在整个实践的过程中，资源治理也成为了百度要解决的一个首要问题。在降本增效目标的驱动下，百度也启动了为期 3 年的云上战略，总结来说就是“一明一暗”两条线。</p><p></p><p>在明线上，开展产品 &amp; 硬件云网融合，产品技术统一规划，全面覆盖研发环境、应用架构和基础设施：首先，通过百度智能云，在绿色低碳 IDC、AI 服务器、昆仑 XPU、自研 DPU、高性能存储、网络等全栈云原生基础设施的加持下，实现了客户和百度集团业务的计算、存储等资源共池，资源灵活周转、调度和高效交付；面对超万台节点规模的大型业务单元需求，实现一周内全面交付。</p><p></p><p>其次，结合超大规模云原生混部调度、容量预测和智能弹性技术，在保障资源质量和安全隔离的基础上，让整体资源利用效率提升 45%+，单位 IT 成本下降超过三分之一，利用独特的潮汐算力技术，实现内外分时复用，让极致的绿色算力全面落地；</p><p></p><p>最后，打造了一站式云原生平台，结合云原生数据库、云原生实时数仓等技术，构建了全链条云原生生态。目前，百度超过 95% 的业务应用已经全面云原生化，所有核心业务都具备高弹性高可用和敏捷迭代的能力。</p><p></p><p>在暗线上，百度启动了大资源运营体系建设，围绕 IT 资源的生命周期，针对资源效能目标进行拆解、量化、分析，对集团经营管理侧、业务用云侧进行牵引指导，开展了诸如零基预算、需求报备、定价结算、韧性供应链等体系化产品建设，并分别从容量、质量、交付、成本多个维度进行度量评价，不仅推动了经营理念从 TCO 到 TVO 的变革，还实现了供给端 &amp; 消费端理念和机制的转变。最终，变革后的预算管理机制，让内部各个业务线对资源的看待视角发生了转变，基础设施资源和云化资源管理拉通以后，每年还能持续为百度贡献约 10 亿元的成本优化。</p><p></p><p>不难发现，百度资源治理的实践其实与 FinOps 理念是不谋而合的，不仅帮助企业通过财务的视角，思考、规划应该如何使用这朵云，也让企业在享受云原生化技术红利的同时，又实现了 IT 资源降本增效的目标。</p><p></p><h1>全栈基础设施云原生化，提供强大的后坐力</h1><p></p><p></p><p>目前，百度已经将内部孵化出的技术能力挪到了云上，以期为更多用户提供强大的基础设施。要知道，百度的业务是非常复杂的，各种类型的应用，各种各样的数据，都依赖于百度强大的基础架构。说到这里，如果你依旧不能清晰地感知到百度业务的复杂性，或许可以通过这组数据进行参考：百度总容量已经达到数十 EB，每天新增的数据量就有数十 P，每天处理的数据超过百 P，峰值处理每秒达 10TB。</p><p></p><p>而百度智能云之所以具备稳定、高性能等特性，自然也离不开底层技术的支持。一直以来，百度智能云都在关注整个技术发展领域，在 AI 成为技术潮流的背景下，百度智能云实现了全栈自研，建设了最适合跑 AI 的基础设施。</p><p></p><p>随着数字经济时代全面开启，数据中心的建设规模不断扩大，数据中心的绿色低碳发展也成为各方关注的焦点。基于此，百度在低碳计算方面也投入了很大精力，自建 PUE 领先的数据中心，使用“市电 +HVDC Offline”供电方案，应用“冰川”相变冷却技术，采用基于百度“飞桨”智能控制系统实时监测数据并调优，能效最高单体数据中心年均 PUE 低至 1.08。</p><p></p><p>此外，为了打造出最适合跑 AI 的基础设施，百度还需要在整个计算体系层面上提高效率，正如 Intel 中国区物联网事业部首席技术官张宇在《AI 可见度》分论坛提到的那样：“面对不断演进的数字化需求，英特尔将继续深化与包括百度在内的生态伙伴的合作，以“绿色、低碳”为出发点，将更多优秀的技术和解决方案推向市场，为个人、产业和社会创造更多的便利和价值。”</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/2d/2dfcfbf2e177509710dd01ff12376f66.jpeg\" /></p><p></p><p>为此，百度不仅和 Intel 联合打造了百度定制的 Intel CPU，还自研了多类芯片、设计了为 AI 场景优化的服务器，如百度自研的昆仑芯片、智能网卡、IPU、以及超级 AI 计算机 X-MAN 等。与此同时，随着现在 CPU 的处理能力越来越强，各个计算节点之间的数据交换也会变得更加密集，需要有非常好的低延时网络服务来支撑，所以，在软件层面上，百度智能云定义了自己的网络协议栈，建设了超低时延网络。</p><p>“从最底层的低碳绿色数据中心，到我们自研的芯片，再到多芯片的适配，最后到上层集群和软件，我们希望能够打造出全国面向 AI 环境最领先的 AI 超算集群。”侯震宇在《AI 可见度》分论坛中总结道。</p><p>作为最适合跑 AI 的基础设施，百度智能云提供了丰富的 GPU 容器虚拟化、推理 / 训练加速、数据 / 镜像加速等能力，全面使用这些能力，会让 GPU 利用率达到 80% 甚至更高，作业效率更能够有 3-5 倍的提升。</p><p></p><h1>写在最后</h1><p></p><p></p><p>“云服务，原来只是一个简单、算得过账的工具，如今已经演变成一个能给企业提供生命力的新系统，甚至能够成为企业可持续发展的重要组成部分。”侯震宇说道。</p><p></p><p>可以预见的是，在 AI 技术的强烈冲击下，传统的通用型算力架构已经被时代所抛弃，企业更需要的是面向智能的计算能力，以提供更高效、稳定、高性价比的计算平台。目前，百度智能云已经将 AI 的能力以及软件层面的能力，真正地注入到了云底座，基于百度智能云提供的“云智一体”服务，可以帮助企业在节省芯片、算法等硬性投入的同时，降低对专业人才的依赖。</p><p></p><p>回归到开篇的提问：企业到底如何才能实现“用好云”的目标，相信可以在百度智能云中找到捷径和答案。</p><p></p>",
    "publish_time": "2022-07-21 18:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]