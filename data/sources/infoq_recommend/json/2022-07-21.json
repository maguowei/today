[
  {
    "title": "高度关注！2022 开放原子开源峰会最新议程一览",
    "url": "https://www.infoq.cn/article/0c776b47371ec5455a2a29d4c",
    "summary": "<p>鉴于北京市疫情防控相关要求，原定于&nbsp;2022 年 7 月 25—27 日举办的 2022 开放原子全球开源峰会 ，调整为&nbsp;2022 年 7 月 27—29 日在北京亦创国际会展中心举办。对于峰会时间的调整，给诸位嘉宾、参会人员及共建单位等造成的不便，我们深表歉意！请您关注开放原子开源基金会官网（www.openatom.org）及开放原子公众号，了解最新峰会相关信息。</p><p>峰会最新议程如下：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/29/29432fcbb99e34b3f8762da6c95488bf.png\" /></p><p></p><p>根据防疫要求，为保障与会嘉宾及参会人员的健康安全，大会期间视情从严管控。所有与会嘉宾及参会人员须提供北京健康宝绿码、北京 48 小时核酸阴性证明方可入场。在坚持知情、同意、自愿原则下，鼓励接种新型冠状病毒疫苗。</p><p>温馨提示：所有与会嘉宾及参会人员亦须提前完成在线注册方可进行现场签到，否则无法进入会场。</p><p>&nbsp;</p><p>报名通道现已开启，火热报名</p><p><a href=\"https://www.bagevent.com/event/sales/k3iy7bn7z7k8mvwbe6he2mi7hq1j3n2z\">https://www.bagevent.com/event/sales/k3iy7bn7z7k8mvwbe6he2mi7hq1j3n2z</a>\"</p><p>请访问此网页，立即报名</p><p>开放征集：</p><p>诚邀您与我们共同开源共建（议题申报、峰会共建），探索中国开源繁荣生态的未来！</p><p>联系我们</p><p>2022 开放原子全球开源峰会组委会</p><p>2022summit@openatom.org</p>",
    "publish_time": "2022-07-21 10:19:51",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "C++将被取代？谷歌发布开源编程语言Carbon：与C++能双向互操作",
    "url": "https://www.infoq.cn/article/vJVZMZWbipYjHUT0B74G",
    "summary": "<p>在7月15日至21日举行的多伦多北部C++开发者大会（The Northern C++ Conference）上，谷歌工程师Chandler Carruth宣布了名为“Carbon”的全新开源开发语言，并称它将是C++的继任者。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/e2/e28d032b440b601a082dd2a243bd19f7.png\" /></p><p></p><p>&nbsp;Carbon项目地址：&nbsp;<a href=\"https://github.com/carbon-language/carbon-lang\">https://github.com/carbon-language/carbon-lang</a>\"</p><p>&nbsp;</p><p>Chandler Carruth表示，<a href=\"https://github.com/carbon-language/carbon-lang\">Carbon</a>\"就是谷歌内部构建的最新编程语言，它拥有与C++的“双向互操作性”，也就是说开发者可以直接在Carbon语言的程序中使用C++，这大大提升了项目迁移的便捷性。</p><p>&nbsp;</p><p>多年来，<a href=\"https://www.infoq.cn/article/76gYqPA2YU0YXCDHFvIE\">谷歌</a>\"构建出了多个新兴的编程语言，其中一些已经在业内有了很高的知名度。</p><p>&nbsp;</p><p>例如，Golang（或简称 Go）是为了改进服务器和分布式系统的开发而创建的，并已被公众采用。此外，最初旨在替代 <a href=\"https://www.infoq.cn/article/m48tvaz8w2BbblIQKZZF\">JavaScript </a>\"的<a href=\"https://www.infoq.cn/video/qd7bu4DxKQ9DVvr7oc0b\"> Dart </a>\"编程语言在Flutter 发布后也开始成为主流编程语言。</p><p>&nbsp;</p><p>在出席此次C++开发者大会上，Chandler Carruth分享了他对于Carbon这个新编程语言的愿景。Carruth 展示了当今最流行的编程语言中有多少个语言是有继任者的，这些所谓的继任者可以让开发人员快速提高生产力并利用更现代、或者更简洁的语言设计程序。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/54/54fba0dd7cf12f566e78644094721da2.jpeg\" /></p><p></p><p>Android 开发者很清楚 Kotlin 是 Java 的继任者，正如 iOS 开发者知道 Swift 是 Objective-C 的继任者一样。</p><p>&nbsp;</p><p>来自 Microsoft 的 TypeScript 彻底增强了 JavaScript性能，同时能够让开发者便捷地使用TypeScript并能够“转译”回 JavaScript。C++ 在谷歌中得到了大量使用，它有点像古老的C语言的继任者。</p><p>&nbsp;</p><p>虽然有些人可能会认为 Rust 最初是一个 Mozilla 项目，后来它拥有了大量追随者，但如果要说Rust是C++ 的继任者，也并不准确。不可否认，Rust的确是一种很好的启动新项目的语言，但它不像 Java 和 Kotlin 那样具有“双向互操作性”，因此很难稳定地迁移。</p><p>&nbsp;</p><p></p><blockquote>如果 Rust 今天适合你，你应该使用它。但是将 C++ 生态系统迁移到 Rust 是很困难的。</blockquote><p></p><p>&nbsp;</p><p>为此，虽然 Carbon 与<a href=\"https://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;mid=2247526072&amp;idx=1&amp;sn=107be44f568cb45c9db02beacbb268ba&amp;chksm=e8d4997adfa3106c1395208c991a685f188e7b49de7ab552cc81e99b838019478614d880dca3&amp;scene=27#wechat_redirect\"> Rust </a>\"有许多相同的目标，例如帮助开发人员创建“性能关键软件”，但 Carbon 还旨在与现有的 C++ 代码实现完全互操作。此外，如果需要，目标是尽可能轻松地从 C++ 迁移到 Carbon。</p><p>&nbsp;</p><p>至于为什么 C++ 开发人员可能要考虑将 Carbon 引入他们的代码库，Carruth在会上还分享了该语言的许多亮点。</p><p>&nbsp;</p><p>Introducer keywords和简单的语法函数输入参数是只读值使用表达式来命名类型通过包名导入 API强大的、经过定义检查的泛型......</p><p>&nbsp;</p><p>在Carbon的README.md文件中，Carbon团队提到，虽然C++现在依旧是有着主导性地位的语言，并有着庞大的代码库，但由于数十年的技术积累，想要持续改进C++已经是极其困难的一件事。</p><p>&nbsp;</p><p>而Carbon则不同，它在继承了C++现有特性与生态的基础上，足够年轻，也足够“现代化”，拥有更为广阔的优化空间，潜力更大。</p><p>&nbsp;</p><p>同时，Carbon团队还表示，该项目的所有代码将全部公开托管在GitHub上，并开放PR，这使得任何开发者都有了根据自己的需求优化改进Carbon语言的可能。</p><p>&nbsp;</p><p>参考链接：</p><p>&nbsp;</p><p><a href=\"https://9to5google.com/2022/07/19/carbon-programming-language-google-cpp/\">https://9to5google.com/2022/07/19/carbon-programming-language-google-cpp/</a>\"</p><p><a href=\"https://twitter.com/code_report/status/1549384029308338176/photo/1\">https://twitter.com/code_report/status/1549384029308338176/photo/1</a>\"</p><p><a href=\"https://github.com/carbon-language/carbon-lang\">https://github.com/carbon-language/carbon-lang</a>\"</p>",
    "publish_time": "2022-07-21 11:47:10",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "从0到1开启一个全新的 TypeScript 项目",
    "url": "https://www.infoq.cn/article/Ev7LVAWjNI8aYu34dkJh",
    "summary": "<p></p><blockquote>文由极客时间整理自 FreeWheel 核心业务团队高级软件工程师陈芸在 <a href=\"https://time.geekbang.org/qconplus/home\">QCon+ 案例研习社</a>\"的演讲《<a href=\"https://time.geekbang.org/qconplus/detail/100091377\">TypeScript 在 FreeWheel 核心业务团队的项目实践（上）</a>\"》。</blockquote><p></p><p></p><p>作者｜陈芸</p><p>编辑｜贾亚宁</p><p></p><p>热衷前端技术的小伙伴都知道 TypeScript 这几年的需求呈现指数级增长的趋势，越来越多的开源项目开始使用 TypeScript 进行重构，出于对 TypeScript 究竟好不好，好在哪里的好奇，我们也对它进行了探索与尝试。</p><p></p><p>我本次的分享主要分为以下两个部分：首先探讨一下是否要引入 TypeScript，其次我们挑选了部门内比较典型的 TypeScript 项目，来带你尝试开启一个全新的 TypeScript 项目。</p><p></p><h4>是否引入 TypeScript</h4><p></p><p></p><p>第一部分我们先抛出一个疑问，我的项目是否应该引入 TypeScript？</p><p></p><p>想要引入一门新的语言肯定是有诉求的，如果原来的 JavaScript 对我们的开发来说非常完美，那大可不必做这样的尝试。既然 JavaScript 存在着问题，那我们就总结一下最大的痛点，看看 TypeScript 是否可以帮助来解决。</p><p></p><p>首先，找一找你平时经常遇到的前端 bug，很大一部分可能都是缺少“约束”导致的。缺少“约束”是什么意思呢？就是你制定了一个逻辑规则，但是并没有完整地描述这个规则，使得你获得的结果集合中总是会出现你期望之外的可能。我们先来看一个简单的例子：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/2b/2b0d6162c1a022e64c686f63c9a4ae2c.png\" /></p><p>这个 function 功能非常常见，就是从一个 list 中 filter 出某一项。看这三个结果，我期望这里的 item 包含匹配属性 id，且必须是 number 类型，这里的“必须包含以及类型限制”就是一种约束。</p><p></p><p>这个例子非常简单，但是我们在实际的项目中会有很多复杂的逻辑，经常会忘记当时写代码时思考清晰的约束逻辑，合作的小伙伴也不知道有这样的约束，就可能会触发 bug。那么这样的约束逻辑是不是可以显式地写在代码里，而不是只维护在作者的脑子里，这时我们就可以借助 TypeScript。当然有人会说我们可以借助测试来提前发现这样的 bug，但是对于大型项目而言，测试很难做到覆盖所有的逻辑。</p><p></p><p>这之后，我们还想提高开发效率。</p><p></p><p>我们在项目开发中常常会调用很多第三方的包，这些包怎么使用，我们往往需要去查看文档，还要注意版本是否一致，有时甚至需要去看源码，这是非常耗时的。不仅仅是第三方包，就是我们公司内部开发的 lib 库，在调用时也存在着同样的问题。尤其是项目团队中人员比较多的情况下，当我们需要互相调用对方开发的组件时，往往需要付出比较大的沟通成本。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/f3/f34a91f45149cf1c46d2ab46b1e0bdab.png\" /></p><p>这个问题，TypeScript 也可以很好地帮助到我们，尤其是它的编辑器有友好的类型提示功能，还可以自动补齐代码，在提升开发效率的同时，还可以减少引用的出错。</p><p></p><p>既然 TypeScript 可以帮我们解决这些痛点，那我们就动手实践一下，看看是不是真如外界说的那么好，同时也看看它会带来哪些问题。</p><p></p><h4>开启全新的 TypeScript 项目</h4><p></p><p></p><p>首先，我们遇到了一个契机，公司要开启一个新的前端项目，这个项目是把原来系统中一个高度复杂的业务模块进行改版。</p><p></p><p>这个项目的规模，大概 15 万行的代码量，前端开发团队大概十几人。项目的特点是逻辑非常复杂、上线时间紧迫、测试可覆盖的面比较小。接下来我们从以下三个方面来介绍我们是如何开启一个全新的 TypeScript 项目的：项目配置和目录设计方案，以及一些常见问题的处理方案。</p><p></p><p>首先说一下我们的项目配置方案：大家都知道 TypeScript 被诟病的一个很大的问题就是它的 compile 耗时，对于一个大型项目而言，每一次改动需要等待多长时间才能生效将严重影响到前端的开发效率，所以选择什么样的编译方式是我们面临的第一个问题。</p><p></p><p>先来看一份数据对比：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/0a/0a0663e57cb66f93e6ba3edec6ca784b.png\" /></p><p>首先 ts-loader 是一个 webpack 上针对 TypeScript 的加载器，ts-loader 内部是调用 TypeScript 的官方编译器 tsc 实现的，它整个编译过程包含类型检查和语言转换，我们知道这里的类型检查是非常耗时的，常见的一种解决方式是把 option 中的 transpileOnly 设置为 true, 这样就只做语言转换而不进行类型检查，相当于只是把类型剔除掉，然后我们再通过别的辅助方式在一个单独的进程里做类型检查，可以看到 compile 的耗时减少了。</p><p></p><p>那么可不可以更快呢？大家都知道 esbuild 是一个基于 Go 的打包工具，它的运行效率是非常高的，所以我们用 esbuild-loader 替换了 ts-loader，它的运行过程也是剔除类型进行语言转化，同样我们可以用别的插件来单独解决类型检查的问题，可以看到耗时又显著减少了。</p><p></p><p>当文件越来越多，这个差距也会越来越大。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/93/932b4bd1b7da38e852376b91cd7ffac2.png\" /></p><p>从上面这个图中可以看到，我们项目使用了 webpack5+esbuild 来进行 bundle。在另一个进程中使用插件来进行类型检查，由于是另起进程，所以它不会阻塞主进程的 bundle 过程。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/bc/bc90ae4b29bee07481eafc2bdf7f4fe4.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/67/67aed9dcfa5efa6a94302f11ac5fbd6d.png\" /></p><p></p><p>对应到实际 webpack 配置文件，我们使用了 esbuild-loader 作为 TypeScript 文件的加载器，使用了插件 fork-ts-checker-webpack-plugin 来进行类型检查。其他的 webpack 配置和 JavaScript 项目是一致。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/e9/e9886067447268f2db3b09f19d20ea6c.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/61/617819304631778e08f422cffa85dd65.png\" /></p><p>使用 fork-ts-checker-webpack-plugin 的效果如上图所示，在 Terminal 中可以查看 compile error 的详细信息，如果编译通过，则显示 no issue found。但如果只是这样其实还是不够的，因为我们完全可以忽略类型检查报的错，继续提交代码，那 TypeScript 也就没有意义了，怎么约束呢？</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/f6/f64b2ee01d2cd6c8e3b532e68cd67364.png\" /></p><p>我们的做法是把 tsc 作为 lint 的一部分，无论是本地提交代码，还是线上打包，lint 不过时无法完成的，这就起到了强制的作用。从这个命令中我们还可以看到，除了 tsc 以外，我们还使用了 eslint 来对 TypeScript 做代码检查。</p><p></p><p>2019 年 1 月，TypeScirpt 官方决定全面采用 ESLint 作为代码检查的工具，并创建了一个新项目 typescript-eslint。</p><p></p><p>有人会觉得，JavaScript 非常灵活，所以需要代码检查。而 TypeScript 已经能够在编译阶段检查出很多问题了，为什么还需要代码检查呢？因为有许多非类型问题是 tsc 所不关注的，比如代码风格方面可以用 eslint 来约束。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/52/52666c7eca94e3dc27bec610fd8fc68a.png\" /></p><p>上图是我们的 eslint 配置，具体每一条官方文档都有清楚的解释，这里就不逐条解说了，我就拿 no-empty-interface 为例，当我们代码里写了这样的 code：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/b0/b06476943ec0514ddc6e34ac3afc9902.png\" /></p><p>首先是空的 interface, 我们知道在实际代码中定义一个没有任何值的空对象是没有什么意义的，所以相应地也不应该出现这样的类型定义。然后是一个 interface 继承另一个类型后不做任何扩展，这样的写法相当于这两个类型就是完全相等的，也不应该出现这样的写法。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/8a/8abb66689c946fb8ba294fbc51cc6553.png\" /></p><p>诸如此类的问题 tsc 都是不会报错的，但这样的写法可能会给将来埋下隐患，所以我们通过 eslint 检查来规避一下。这里顺便提一下，有一些代码格式方面的约束比如缩进、空行、空格等之类的，我们并没有通过 eslint 来做，而是通过 prettier 来帮助完成。</p><p></p><p>接下来我们来介绍一下 TypeScript 项目最重要的 tsconfig 配置，下图是我们项目使用的配置方案：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/f9/f9c1c0e6b70b0e8337eea46d1c7d59cd.png\" /></p><p>这里我重点挑了几个参数：首先我们把 noEmit 设置成了 true，因为在我们项目中 tsc 只负责进行类型检查，并不真实输出 js 和.d.ts 文件。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/e2/e22e93c8d1763f83d9fb93cdf3043d12.png\" /></p><p>然后是 paths, 是用来 alias（取别名）的，配合 webpack 中的 alias，我们在 import 一些包的时候会用 alias 代替相对路径，那么在 TypeScript 类型检查的时候也需要知道这些别名才能找到对应的模块，完成检查。</p><p><img src=\"https://static001.geekbang.org/wechat/images/ef/efbde6c5e7c396168992ac089a31d9da.png\" /></p><p>最后是 include 和 exclude，include 指定某些路径下的文件被包含进来，exclude 排除一些路径。“include”的默认值是当前目录及其子目录下的所有 TypeScript 文件，“exclude”默认情况下会排除 node_modules、bower_components、jspm_packages 和目录，这里的 exclude 其实我们也可以省略。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/6b/6bedae60458556a44c1d53a60086adaa.png\" /></p><p>此外还有两个我们项目中没有使用，但可能大家会用到的参数：首先是 files，如果想明确指定某几个 TypeScript 文件加入到 include 中，可以用“files”这个参数来添加。需要注意的是，通过“files”属性明确指定的文件总是会被包含在内，不受 exclude 的约束。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/c3/c3b7a5861645924596e6f4c996c7ba88.png\" /></p><p>然后是 typeRoots，它默认值是 node_module 下的 @type，以及各个子路径下的 node_modules /@types。它的作用是：我们代码中 import 的一些第三方库，这些库的类型文件有全局声明，只有把他们添加进来，全局声明才会生效。需要注意，如果自定义 typeRoots，那么默认值就失效了，不要忘记手动把 node_modules/@type 也添加进去。</p><p></p><p>现在我们项目的框架已经搭好了，接下来介绍一下项目中的文件目录结构安排，通过项目实践，我们调整出的目录结构是好维护并有利于扩展的。下图展示了项目的文件目录结构，是一种我们比较推荐的 practic。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/92/92cc7371958fc46ce8e06fbe7580aaf5.png\" /></p><p>除了最外层的项目配置文件外，首先，一个 component 下会有以 component 为前缀的四个文件，分别是 hook.ts、.css、.types.ts 以及 component 本身，类型定义相关的代码会被放到单独的.types.ts 文件中，这样做是为了使 component 仅仅只包含业务逻辑代码。</p><p></p><p>其次，有许多公共类型会被多次调用，这样的类型我们通常会放到 lib/types 下。当然，全局 declare 的类型也会放在这里。这里有一个点值得说一下，关于.d.ts 和.ts 的区别：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/3c/3c1f448e1758d552d6617319c081e8c3.png\" /></p><p>.d.ts 是编译器从你的.ts 代码中分离出来的非 js 的部分，类似于接口定义规范。从上图中可以看出.d.ts 是给 js 文件提供类型声明的，通常来说它是 tsc 自动生成的。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/7c/7cf028485293fb05da9338dc4b8fdd02.png\" /></p><p>当然还有一种情况，代码不是用 TypeScript 写的，而我们希望调用方可以得到类型信息，这时我们需要手动写.d.ts 来提供一份对外的 type。比如项目中会引入许多第三方库，而这些库是基于 JavaScript 开发的，通常这些库的类型声明文件会放到 node_modules/@type 下。比如这里的 react，就是通过.d.ts 文件来提供类型声明的。</p><p></p><p>最后回到我们的文件中，由于我们项目的特性，我们并没有大量写.d.ts 文件，但由于我们会需要用到全局声明，通常我们习惯会把全局 declare 放在.d.ts 里。</p><p></p><p>然后我们说一下通常哪些类型会被当做公共数据类型放到 lib/types 下面：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/84/84442348bb089dc324f6377646913615.png\" /></p><p>首先是后端接口数据类型，看这个例子，这里定义的 ListAllChangeHistoryInfoResponse 就是后端返回的数据类型，其中每一项的类型是 ChangeHistoryInfo。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/88/88ce463a69f0fdcd668e646540f6bbd3.png\" /></p><p></p><p>由于前端的页面展示的内容是以后端返回数据为基础的，这也决定了这样的类型会被多个上层类型定义所调用。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/15/15a26de47a589aca8c781b8c1eb5edc9.png\" /></p><p></p><p>这里还有一个隐含的好处，我们在项目中期，引入了前后端接口同步方案，这个后面会提到，是我们自己发布了一个第三方 type 库来集中提供各种与接口相关的数据类型。那么在 adopt 的过程中，我们不需要全局逐个文件地改这个被替换的接口，只需要在 lib/type 下做一次这样的修改即可。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/ce/cedff294edfee51532d5a4c0a9cb3de9.png\" /></p><p>还有一类是公共组件或者通用方法的某些参数的类型，从右边的代码中可以看到，这里的 TreeSelect 有一个属性是 flatOptions, 它的类型就是左侧定义的 TreeOptionItem 所组成的 list,我们在项目中一个常见的场景是请求回后端数据，经过一个数据转换的函数，把数据 format 成 option 类型的数据，传给 TreeSelect 做展示。</p><p></p><p>由于这样的场景非常多见，针对于不同的后端数据，会需要不同的数据处理，所以这个 TreeOptionItem 就会被多个上层 component 所调用。因此我们也推荐放到 lib/types 下。</p><p></p><p>最后一部分是常见问题处理，我们在项目中遇到了各种问题，在这里总结两个比较典型的问题。</p><p></p><p>当我们用 ts 编译器做类型检查时，出现 compile error 很常见，通常我们也可以通过修正 type 的定义来 fix，但如果我们 import 的是一些 css、png 这样的文件该怎么办呢？</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/a2/a21d28e14dfef5ad94b3e1d6c7eb9ecf.png\" /></p><p>由于这些文件本身无法定义类型，最直接的想法是加上 @ts-except-error，这确实可以解决问题，但是需要注意，如果使用了 ts-expect-error，加下来的代码中没有真实的类型错误，编译器会提示：Unused ‘@ts-expect-error’ directive，而使用 ts-ignore 则无论下面的语句有没有编译错误，编译器都会忽略。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/43/43f7f6ff447d8cc02111e74639647521.png\" /></p><p>但无论是哪一条命令，这样做的缺点是每次 import 都必须加，有没有一劳永逸的方式呢？</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/ea/ea8be2683174d020e760194c565e5f59.png\" /></p><p>我们推荐使用全局 declare 的方式，像一个配置文件一样，在项目初期就把这样一个文件放到 lib/types 下，那么此类问题都不会出现了。需要注意的是，全局 declare 不可以在最外层包含 import、export 这样的语句，否则它会被当做局部声明而无法全局生效。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/d1/d15fb0ffb02c7c46d5b952b7b4b820db.png\" /></p><p>第二个问题是引入第三方库没有 type 或者 type 定义有问题该怎么办？这里同样可以通过全局 declare 的方法解决。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/65/658d8ad68b668bc0105fefbba35f1308.png\" /></p><p>同时，我们更加推荐把声明文件发布到 DefinitelyTyped 上，让更多的人可以受益。</p><p></p><p></p><h4>作者介绍</h4><p></p><p></p><p>陈芸   FreeWheel 核心业务团队高级软件工程师</p><p></p><p>主要负责前端开发工作，对前端前沿技术非常热衷，致力于提升产品质量，优化用户体验。前豆瓣全栈开发工程师，对 ToB，ToC 的项目都有深刻的理解。</p>",
    "publish_time": "2022-07-21 12:50:32",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "TypeScript 项目实践：四步走高效改造现有的 JavaScript 项目",
    "url": "https://www.infoq.cn/article/PzkgsYi2OqY89o0KLjBW",
    "summary": "<p></p><blockquote>本文由极客时间整理自 FreeWheel 高级软件工程师陈芸在 <a href=\"https://time.geekbang.org/qconplus/home\">QCon+ 案例研习社</a>\"的分享《<a href=\"https://time.geekbang.org/qconplus/detail/100091378\">TypeScript 在 FreeWheel 核心业务团队的项目实践（下）</a>\"》。</blockquote><p></p><p></p><p>作者｜陈芸</p><p>编辑｜严强</p><p></p><p>你好，我是陈芸，目前就职于 FreeWheel 核心业务团队，主要负责前端开发工作。我想和你分享一下我在改造现有 JavaScript 项目上的实践经验，手把手带你一起把现有的 JavaScript 项目 TypeScrip 化。</p><p></p><h3>改造背景</h3><p></p><p></p><p>先介绍一下改造背景。</p><p></p><p>TypeScript 作为 JavaScript 的类型化超集，弥补了静态、弱类型的 JavaScript 的缺陷，具有静态类型声明，可以减少不必要的类型判断和人工查看类型的成本，开发过程中进行静态类型检查和类型提示，对提高开发效率有正向作用。基于 TypeScript 的优点和我们面临的现状，FreeWheel 核心业务前端开发团队决定将前端开发语言从 JavaScript 向 TypeScript 切换。</p><p></p><p>我们改造的项目业务非常复杂，参与开发的人员非常多（代码行数 8 万多行，前端开发人员 40 多人），以及在可预见的将来，项目会有大量的功能迭代。</p><p></p><p>P.S.：在引入 TypeScript 的时候，我们使用的 TypeScript 版本是 4.2.2。</p><p></p><h3>改造过程</h3><p></p><p></p><p>接下来我会从以下 3 个方面来介绍我们是如何把 JavaScript 项目 TypeScrip 化的：</p><p>迁移方式探讨类型定义公约代码改造实操迁移后的收获</p><p></p><h4>迁移方式探讨</h4><p></p><p></p><p>第一部分，我们来探讨一下迁移方式。</p><p></p><p>在决定把一个 JavaScript 项目 TypeScript 化的时候，首先我们需要去判断我们这个项目的属性以及我们本身具备的一些条件。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/58/58172bb1c1ae7149fb81b852c0c30e21.png\" /></p><p></p><p>如图所示，第一个条件：判断是否一个稳定的组件。这个意思就是在比较久的一段时间内并不会有一些功能迭代进来。在这样的项目下，我们推荐你手动去维护一份.d.ts 的文件，可以做到只是对外提供类型，方便第三方的调用。如果不是一个稳定的组件，我们需要在将来不停地去维护它。</p><p></p><p>如果有新的功能加进来的话，那我们就来看第二个条件：是否有足够的时间窗口。如果有足够的时间的话，我们推荐使用 TypeScript 来对原来的 JavaScript 代码进行完整的重构。因为 TypeScript 的设计思维和 JavaScript 是不同的，它比较推荐接口设计先于代码实现，所以在很大程度上，原来的 JavaScript 代码是不能匹配这样的设计而写出来的。我们推荐用 TypeScript 重构，这样会比较符合。</p><p></p><p>如果我们没有足够的时间窗口该怎么办？以我们的项目为例，我们选择的方式是给模块逐个添加类型来达到进行类型约束的目的。当然给模块添加类型也是有顺序的，推荐把底层的模块先加类型，然后再是上层的模块。</p><p></p><h4>类型定义公约</h4><p></p><p></p><p>接下来是我们在这个项目中组内约定的类型定义公约。约定这样的类型定义公约目的有两个：第一明确迁移进度，第二更好地做类型约束。</p><p></p><p>我们约定了一些必须要遵守的公约：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/75/752cb62952b5c466a03d4187521534e8.png\" /></p><p></p><p>第一条，定义 type 尽量不使用 any。我们都知道，在代码中大量的使用 any 其实可以明显地降低移植难度，但是我们引入 TypeScript 的初衷是为了给代码进行类型约束，那么使用了 any 之后就失去了这种类型约束的作用，所以我们这里把 eslink 中，这一条 no-explicit-any 设置成了 warn，我们并不会完全去禁止使用 any，但是不建议。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/52/52e7d9b9ea628a9a6ef3d62f3d2531ae.png\" /></p><p></p><p>其他三条，都是规定了在代码中哪些位置是需要定义 type 的，分别是 Component 的 props、function/hook 的输入输出以及 state。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/84/84edfa56cb87354c4bb28ac68552b8d2.png\" /></p><p></p><p>看一下这个例子，useDate 是一个 hook，它里面包含了一个 state。Header 是一个 component，它有 props。左图中，我们没有很好地在这些位置定义清楚各自的类型。而右图中，我们给 useDate 的返回值定义了类型，给 state 定义好了类型，同时给 Header 的 props 也定义好了类型。</p><p></p><p>我们知道，当我们把一段代码单独提取出来成为一个 function，或者成为一个 Component，我们默认这样的代码是会被多次调用的。那么，在这些代码被定义了类型之后，当我们去调用这样的 function 或者 component，TypeScript 会给我们带来怎么样的帮助呢？</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/6e/6e59721eab658c2b8ea4dae6b16dd8b3.png\" /></p><p></p><p>首先，我们刚才定义了 useDate 的返回值，包含了三个值，它们的类型分别是 string，string 以及 function。那么我们在调用这个 hook 的时候，如果想要拿它的第四个返回值，这时编译器就会告诉我们这个值已经超出了它的返回值的范围，是有问题的，不可以这样使用。</p><p></p><p>我们刚才定义的 hook 第三个返回值其实是一个 function，它包含了两个 string 类型的参数，它的返回值是 void。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/f0/f02c424a7c99e60af6bccdb9ef842bed.png\" /></p><p></p><p>在我们调用这个 function 时，如果我们给它的第二个参数传入的值是 number 类型，编译器就会告诉我们这里的 number 类型并不被允许，我们只能传入一个 string 类型的值。这就可以帮助我们提前发现这里传入参数是否正确。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/8f/8fa7251ca472d60440c698dc11f22e21.png\" /></p><p></p><p>然后是 Component，我们刚才定义了它的 props 的类型，它只包含了一个属性 getData。我们在调用 Component 的时候，如果给它传入别的参数，编译器同样会告诉我们这个属性并不被 Component 所接收。</p><p></p><p>完成了以上这几处类型的定义，许多代码中别的类型都可以通过类型推导来得到。这也就是用最小的工作量发挥 TypeScript 最大的好处的情况。所以我们约定了完成以上这几处类型的定义，就算完成本阶段的代码迁移。</p><p></p><p>接下来介绍一些我们推荐遵守的公约，这些公约主要是为了帮助我们能够更好地实现类型约束。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/67/6755567d9d67f9efdd96cc5234a8e00c.png\" /></p><p></p><p>第一条，尽量避免类型重复定义。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/85/854bc34aa76e86ade154486ab00cf151.png\" /></p><p></p><p>看这个例子，PowerUser 它的一些属性其实是 User 和 Admin 的一个合集，同时它有特殊的 type。我们如果把左图中的写法，改成右图中这样，去掉 User 中 type 属性，去掉 Admin 中 type 属性，同时和它自定义的 type 组成它自己的类型，这样其实更符合代码逻辑。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/f1/f105b5817c4205a78b3d48590ca2b27e.png\" /></p><p></p><p>还有这样的一种情况，上面的写法其实是一种函数重载，这里的 diff() 支持输入一个参数，支持输入两个参数，也支持输入三个参数。我们推荐把这样的情况写成下面这样的类型定义：第一个参数是 require 的，后面两个参数都可以设置成 optional 的。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/e8/e826b968ebaa71db33f0233633343c9d.png\" /></p><p></p><p>这样的例子在代码中很常见，比如这里的 ignoreErrors，shouldAutoReload，isEditIO 这三个参数在 function 内部都是有默认值的。也就是说，我们在调用这种方法的时候并不是必须去传入这样的参数的。对于这种有默认值的属性，在定义 type 时，我们推荐直接将它们设置成 optional。为什么要这样做？首先它可以使我们的代码更加简洁清晰。其次，由于以上写法更符合代码逻辑，所以也就决定了它维护起来更加方便。</p><p></p><p>第二条，推荐使用 keyof 对 object 中的 key 进行约束。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/b5/b5c7b62b74cd0aad0ab9c44437858679.png\" /></p><p></p><p>首先看上面这个代码段，这个写法会存在两个比较大的问题：第一，我们无法确定返回值类型；第二，我们的参数把它定义为了 string，但是很可能会出现拼写错误，而使这个 function 发生运行时的错误。</p><p></p><p>我们推荐下面这种写法，使用泛型 T 配合 keyof 来对这个 object 进行约束，同时也对它的 key 进行约束，就可以很好的解决这两个问题。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/35/351445569f46dd8e991f81b16471073c.png\" /></p><p></p><p>来看一下项目实例，这个函数它主要负责处理 URL 相关的一些功能。它从 URL 的 search 参数中得到一些键值对，并且把这些键值对转化成一个 object 类型然后输出。这里的 currentQuery 就是 object 类型。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/e4/e42f1b81c0e412d142a7b23e1d407d3e.png\" /></p><p></p><p>其次，它还提供了一个 deleteQueries 的 function。这个 function 支持输入参数 keys，然后去除 search 中的一些键值对，并且把新得到的 search 反向 push 回 URL。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/34/34ec1a4c4b07d22e88269e3b030f4586.png\" /></p><p></p><p>我们在代码中使用了泛型 T 对它的 object 进行约束，可以看到这里的第一个返回值就是泛型 T。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/c1/c1897261dae33fb57b4e741b57c54b71.png\" /></p><p></p><p>然后我们使用 keyof T 对它的参数 filters 以及 useCallback 的参数 keys 进行了约束。filters 的作用是可以指定返回的 object 中包含哪些 key，而 keys 是指定了在 deleteQueries 中需要具体去删除哪些 key。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/e1/e104c5c0d36350065df9578561b4269c.png\" /></p><p></p><p>看一下实际的调用情况。在我们调用这个 hook 的时候传入了一个指定类型 URLQueryForCampaignPage。这个类型包含了四个属性，分别是 insertion_order_id、placement_id、pagelink_id 以及 step。当我们传入这样类型的时，就决定了我们得到的第一个返回值 Query 的类型被约束为只能包含这四个 key。那么当我们想去拿 Query 中的某一个属性，比如要拿 test 属性时，编译器会直接告诉我们这个属性并不包含在这个 object 中。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/27/270ed6be552ef37adbe8113e2d658efd.png\" /></p><p></p><p>定义它的第二个返回值，deleteQueries 这个 Callback，它的参数用 keyof T 约束了必须是这个 object 中的这些属性所组成的 list。这时如果我们手动输入某一个值，比如说 test 或一种拼写错误，编译器也会直接告诉我们这个 test 不在 object 中，从而提前发现了 bug。</p><p></p><p>第三条，推荐用 tuple 来代替 array 来约束数组长度。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/4f/4f5024126852fbafbc45b95a708b33eb.png\" /></p><p></p><p>看这两个代码段，上面的写法是用 array 来定义数组类型，下面的写法是用 tuple 来定义数组类型。这两种写法都是可以的，但如果明确知道数组的长度，我们更推荐使用 tuple，为什么呢？</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/29/29586f713a53d6a581f6d810f43c79f9.png\" /></p><p></p><p>看这个代码实例。这个例子的 useMemo()，返回了两个 number 类型的值组成的 list。如果我们用 array 来定义数组类型，要拿第三个返回值的时候，编译器并不能检查出错误，可能会导致运行时的 bug。只有我们把它定义成了下面这样的情况，编译器才能提前知道第三个属性已经超出了返回值的范围，提前发现错误。</p><p></p><p>最后一条，id 尽量不要模糊定义它的类型（string | number），推荐把 id 明确定义为 string 或者 number。这是我们在项目中实际踩过的坑，如果可以，我们希望能在项目初期就规避这样的问题。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/01/011e6ad748bef7cda96585ca0183a908.png\" /></p><p></p><p>比如这个 Message，我们的 id 可以明确成 string 话，千万不要定义为 string | number 这样的类型。为什么这么说？我们知道，后端返回给前端的数据可能来自不同的 service, 他们的 id 往往无法保证统一，有些接口的 id 是 number, 有些接口的 id 是 string。而 id 通常会作为唯一标识做匹配或者构建新的对象， 这就会给代码造成额外的处理负担，也增加了出错率。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/f7/f77190591fe124320d630169d97a4561.png\" /></p><p></p><p>比如这个实例，这里的 BFInfo 的 ioId 实际是 string 类型的，我们把它定义成了 number | string。这时 IOInfo 的 id 是 number 类型的。当我们要从 BFInfo 这个 list 中去匹配某一项 IOInfo 时，我们会写如下语句。这段代码在类型检查的时候是会成功通过的，但事实上这里隐藏着一个 bug。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/2b/2bf50cec923c776f890b18ae1fb53c1f.png\" /></p><p></p><p>可以看到，如果我们把刚才的 BFInfo 的 ioId 定义成了 string，那编译器会直接告诉我们一个 number 类型的值。如果想跟一个 string 类型的值作比较，它的返回值永远是 false，就说明这个语句是没有意义的。只有我们把它们的类型明确了，我们才能提前发现这里有问题，才可以相应地去做代码修改，比如把这两个值统一转成 number 类型或者 string 类型后再去作比较。</p><p></p><h4>代码改造样例</h4><p></p><p></p><p>讲了上面两部分之后，我们用具体实例来实际演示一下代码改造的过程。</p><p></p><p></p><p></p><p></p><h4>迁移后的收获</h4><p></p><p></p><p>最后总结一下我们在把 JavaScript 项目 TypeScrip 化的过程中遇到的问题和获得的收获。</p><p></p><p>第一个难点，在迁移阶段，整个项目处于 JavaScript 和 TypeScrip 并存的状态，项目的配置方案也因此变得比较复杂。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/e9/e91396eb46f4a351efa02d34ca4de05b.png\" /></p><p></p><p>左侧是我们的 webpack 配置，我们针对 JavaScript 和 TypeScrip 引入了不同的加载器。而右侧是 ESlint，我们针对 JavaScript 和 TypeScrip 又使用了不同的 rule 配置。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/74/7405e58072722eec6bba5ebae7583e66.png\" /></p><p></p><p>第二个难点是我们原先的代码设计很多时候并不利于类型化。</p><p></p><p>看这个例子，由于原来的代码设计，function 的某个参数 data 分别可以是三种完全不同的数据结构，而代码中通过 if else 去对不同的数据进行处理。像这样的代码其实是非常不利于进行类型约束的。推荐的做法是把这样的方法进行重构，但是由于我们在项目迁移的过程中仍然有大量的功能迭代进来，为了尽量地避免冲突以及把风险降到最低，我们选择了这样的折中的方式来进行约束。</p><p></p><p>有遇到问题，但收获也是非常大的。TypeScrip 化给我们带来的第一份惊喜是让我们发现了原先代码中隐藏的 bug。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/31/31f93d811076f4c8b303a9e7fefd2eed.png\" /></p><p></p><p>第一个 bug 是我们在调用这个 function 给它传参的时候，把这里的 key 和 value 直接给写反了。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/aa/aa8d53406fc030ddc5f444a47830c962.png\" /></p><p></p><p>第二个 bug 隐藏得比较深。component 有一个参数 value，value 值的属性是 number 或者 string 的一个 list。而我们在 component 中定义了 state，这个 state 的类型是这里的 TreeOptionItem 所组成的 list。可以知道 string or number 和 TreeOptionItem 是两个完全不同的类型，我们在写代码的时候，把 value 作为 state 的默认值这样的写法肯定是有问题的。这个在类型检查的时编译器直接告诉了我们。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/50/503cf36f9728522cbfca487a1273f4aa.png\" /></p><p></p><p>第三个例子也非常常见。我们在代码中做一次 rename 之后可能忘记了去修改，这个文件中也引用到了这个参数，就导致这里的参数已经找不到了。像这样的问题，tsc 也很容易就告诉了我们。</p><p></p><h3>总结</h3><p></p><p></p><p>最后，我们建议：对于多人参与开发的大中型项目，引入 TypeScript 将非常有利于后期的代码维护。对于个人的小型项目，引入 TypeScript 的必要性并没有那么强，但如果个人感兴趣的话，推荐你依据个人喜好而定。比如你想要去体会 TypeScript 带来的好处的话，小型项目也可以明显感觉到。</p><p></p><p>送给你一句话，听得再多东西都是别人的，亲手试一试才能成为自己的。</p><p></p><p></p><h4>作者介绍</h4><p></p><p></p><p>陈芸   FreeWheel&nbsp;核心业务团队高级软件工程师</p><p></p><p>就职于 FreeWheel 核心业务团队，主要负责前端开发工作，对前端前沿技术非常热衷，致力于提升产品质量，优化用户体验。前豆瓣全栈开发工程师，对 ToB，ToC 的项目都有深刻的理解。</p>",
    "publish_time": "2022-07-21 13:18:46",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "无方向盘自动驾驶汽车来了！“人均一个数字人”的时代也要来了？百度的AI世界上新",
    "url": "https://www.infoq.cn/article/kso0s8Dl1QWabtcPWTTA",
    "summary": "<p>7月21日，在2022百度世界大会上，百度发布了多款百度最新AI技术成果，包括没有方向盘的自动驾驶汽车Apollo RT6，希加加虚拟数字人，全球首个航天领域的大模型...</p><p></p><h2>“人均一个数字人”的时代已来</h2><p></p><p></p><p>虚拟数字人可以说是这次百度世界大会的“主角”了。</p><p></p><h3>“希加加”、度晓晓站上“C位”</h3><p></p><p></p><p>百度AI数字人家族的新成员“希加加”是本次大会的 AI 策划官、副主持人和开场嘉宾，与撒贝宁一起同台主持。她连同另一位数字人度晓晓出现在整场大会的多个环节中。“希加加”还具备作画、写诗、作曲、说多国语言、实时直播等多项“超能力”。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/8f/46/8fe0965a8498219864dfa28644f58546.png\" /></p><p></p><p>百度集团资深副总裁、百度移动生态事业群组（MEG）总经理何俊杰表示，“人均一个数字人’的时代已经到来。”</p><p></p><p>何俊杰展示了百度AI数字人“度晓晓”的最新进展。他认为，度晓晓扮演着“AI大使”的角色，连接起科技到用户的最后一公里。</p><p></p><p>“度晓晓”是百度搜索能力的重要进化。目前，“度晓晓”已经上线百度App，用户直接在百度App搜索“你好”，即可召唤度晓晓。</p><p></p><p>据悉，在百度App内，度晓晓可以连接所有的智能生活服务：面对用户的个性化提问，度晓晓通过百度“问一问”快速匹配专业答主，提供一对一真人咨询服务，目前“问一问”已覆盖法律、情感、心理、政务等19个领域超4万名答主。</p><p></p><p>百度AI创造的数字人度晓晓、希加加所具备的理解和生成能力，可以令其自动生成创意作品。会上，龚俊数字人与度晓晓一起表演了AIGC单曲《每分 每秒 每天》。度晓晓可以40秒完成40篇高考作文，几十秒完成一幅美术作品，24小时不间断情感互动，还能创作脱口秀、直播带货等。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/a4/f7/a42134d17cae2070e1b7yyfea403e5f7.png\" /></p><p></p><p></p><p>百度创始人、董事长兼首席执行官李彦宏分享了对AIGC领域的思考，“未来十年，AIGC将颠覆现有内容生产模式，可以实现以‘十分之一的成本’，以百倍千倍的生产速度，去生成AI原创内容。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/c1/41/c117bb96c4ce9a0b81b79f2f09d62e41.png\" /></p><p></p><p></p><p>李彦宏判断，AIGC将走过三个发展阶段：第一个阶段是“助手阶段”，AIGC用来辅助人类进行内容生产；第二个阶段是“协作阶段”，AIGC以虚实并存的虚拟人形态出现，形成人机共生的局面；第三个阶段是“原创阶段”，AIGC将独立完成内容创作。</p><p></p><h3>超写实数字人直播平台发布</h3><p></p><p></p><p>“全新发布的数字人直播平台，能让AI数字人自己做直播，我们全年无休，和用户互动，帮助那些不太擅长做电商的山区农家叔伯、小微企业，改善他们的生活。”会上，AI数字人希加加这样介绍百度智能云的曦灵数字人直播平台。该平台主要聚焦电商直播、品牌营销、互动娱乐等领域，做到超写实数字人24小时纯AI直播。</p><p></p><p>当下，直播行业炙手可热。但直播爆火的背后，真人主播稳定性弱、直播硬件及场景成本高、运营门槛高、闲时流量无法有效利用，也成为其发展的制约因素。</p><p></p><p>创匠科技CEO刘卫表示：“以团队搭建电动牙刷售卖直播间为例，仅硬件成本至少7万元，还不包含场地及主播”。百度智能云曦灵通过AI驱动的方式，无需真人主播和中控人员，实现内容快速生成，降低运行成本。</p><p></p><p>判断一位真人主播的受欢迎度，核心原因不过有三：首先，主播的表现力强，外观形象、穿搭风格都令人有记忆点；第二，有个性、很能聊，与观众谈天说地，机智回复；第三，不停更，渗透进大众生活的每一个时间缝隙。要让直播间里的数字人无限接近真人，核心考验的就是数字人的表达力和交互力。</p><p></p><p>在表达力层面，当前市场上大多产品的数字人精度低，“纸片人”很容易让观众“出戏”。百度智能云在超写实数字人制作方面已研发3年，通过数字人自然动作引擎等技术，数字人直播平台生产的AI数字人形象亲切、毫发毕现，动作平滑自然，用户能感受到AI数字人带着“真情实感”的。</p><p></p><p>在交互力层面，主播的本质是内容。依靠视觉、NLP、语音交互等底层全栈AI技术以及PLATO百亿参数对话大模型，百度智能云的数字人直播平台能让数字人像真人一样，与观众捧哏逗趣，机智回复。同时，AI大模型所支撑的智能创作，也将助力数字人在未来拥有“原创能力”。</p><p></p><p>想要实现“人均一个”数字人，标准化产品将成为降低运营门槛的关键。</p><p></p><p>曦灵数字人直播平台，作为一款saas化产品，可实现“即插即用”，无需要完整的运营团队、昂贵的直播硬件设备，一个人就可完成全部流程，让数字人直播与写文档、做PPT一样简单。同时，数字人直播平台还打通了服务全流程，为合作伙伴提供直播代运营托管、中之人培训等服务。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/a4/e0/a413f7e8db9f2f7e8219bf93163e57e0.png\" /></p><p></p><p></p><p>百度智能云AI及应用产品副总经理刘倩表示，“数字人直播平台的推出，将让大家可以低门槛拥有更稳定、超写实、智能化的数字主播，真正解放企业生产力”。</p><p></p><p>超写实数字人向前发展，对视觉技术也提出了新的挑战。百度视觉技术部、增强现实技术部总监丁二锐表示，百度即将发布“照片引导形象生成技术”，手机摄像头拍摄几张甚至一张照片，即可生产一个拟真、美观且可驱动的超写实数字人人像，相较传统制作流程效率将提升90%。</p><p></p><p>据悉，当前，百度智能云曦灵打造的几十位数字人已经落地各行各业，央视网小C、央视新闻AI手语主播，以及希加加等，都曾参与过大型直播。</p><p></p><h2>百度第六代量产无人车Apollo RT6发布</h2><p></p><p></p><p>会上，百度发布了第六代量产无人车 —— Apollo RT6。</p><p></p><p>基于自动驾驶技术上的突破，Apollo RT6不但具备城市复杂道路的无人驾驶能力，而且成本仅为25万元。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/8e/7c/8ea4e66706d3d6f9d630a7b9b3c2967c.png\" /></p><p></p><p></p><p>李彦宏表示：百度把自动驾驶汽车的成本，降低至业界的十分之一，相当于一辆普通新能源汽车的价格。无人驾驶汽车成本的大幅下降，以至于我们可以部署上万辆这样的车在全国各地了。 未来打无人车，要比现在打车便宜一半。</p><p></p><p>根据规划，Apollo RT6会于2023年率先在萝卜快跑上投入使用，未来可以在全国部署上万辆。它的量产落地，将加速无人车规模化部署。</p><p></p><p>Apollo RT6是百度面向未来出行自主研发、正向设计的量产车，整车针对乘客需求和无人驾驶出行场景进行了深度设计。</p><p></p><p>据介绍，Apollo RT6外观采用了贯穿一体的空间飞梭车身及银河腰线，突出科技感与安全感；创新性的龙骨天窗，将车顶传感器与天窗结构高度集成融为一体，革新了自动驾驶改装车的造型；为了进一步提升出行便利性，车辆还配置了具有识别和提示功能的灵犀交互灯语、智能电动侧滑门等功能。</p><p></p><p>智能座舱方面，Apollo RT6打造了百变智能空间。Apollo RT6支持有方向盘、无方向盘两种模式，前排可根据不同出行场景配置座椅、售卖机、办公桌、游戏机等，满足乘客办公、娱乐等多元需求。此外，Apollo RT6后排1050mm大空间、独立座椅以及智能交互系统后移设计，实现A级车的尺寸、B级车的空间、C级车的体验。</p><p></p><p>Apollo RT6源自百度自研的「阿波罗星河」架构平台，作为该平台的首款车型，Apollo RT6实现了100%车规级和整车全冗余系统，相较于市面上的改装车可靠性高出两到三个数量级，保障乘客出行安全。Apollo RT6硬件上，具备架构冗余、计算单元冗余、制动系统冗余等七重全冗余系统，任何单一零部件或系统失效，备用的冗余系统都可以瞬时完成补位；软件上，搭载了整车+自动驾驶系统一体的故障诊断及风险降级体系。</p><p></p><p>百度集团资深副总裁、智能驾驶事业群组总经理李震宇表示，**Apollo RT6既是一辆车，也是一位好司机，它自带的自动驾驶技术，相当于拥有20年驾龄的司机。**Apollo RT6搭载了百度最新一代无人驾驶系统，具备比上一代车型更强的L4级自动驾驶能力，可应对城市各类复杂道路和场景。Apollo RT6配备的车规级高算力主冗双计算单元，算力可达1200Tops。全车38个传感器深度融合，实现远中近三重检测能力全覆盖，具有更精准感知能力。</p><p></p><p>过去9年来，百度Apollo共推出了六代无人车。相较于前五代车型，Apollo RT6实现了AI技术和车辆工程的深度融合，具备高安全、高质量、低成本等优势。</p><p></p><h2>AI帮助实现“绿灯自由”</h2><p></p><p></p><p>百度认为，未来的城市智能交通，不仅要有“聪明的车”，还要有“智慧的路”。</p><p></p><p>车路协同能有效解决安全、拥堵、碳排放等重要问题。李彦宏认为，“以车路协同为基础的智能交通，可以让通行效率提升15%-30%，推动GDP每年2.4%-4.8%的绝对增长；随着智能交通的深入实践，四年之内中国的一线城市将不再需要‘限购’‘限行’。智能交通系统，有望降低90%交通安全事故。”</p><p></p><p>根据大会上披露的最新数据，百度智能交通方案已经在广州、保定等全国50多个城市得到实践和验证，其中，尤以AI信控技术最具优势。</p><p></p><p>这次会上，百度展示的智慧交通成果，更侧重将AI渗透进人们的实际生活中。百度通过三个案例展现了智能交通建设如何助城市管理者精准决策，为普通百姓带来“绿灯自由”。</p><p></p><p>我国有1700万卡车司机，在卡车物流运输场景，大雾、暴雨等极端天气导致高速封路往往会延误交货时间，也存在安全问题。在京雄高速上应用的百度智慧高速系统，突破了准全天候通行的技术难题，在雾天等不利天气状况下，司机可以收到智能终端发出的天气、车距、车速、前方碰撞等驾驶信息的提醒，保障司机顺畅、安全通行。同时，凭借融合感知、AI算法的提升，将设备的部署距离成功扩展至1公里，成本降低30%。</p><p></p><p>在重庆永川区，AI可以帮助交警“指挥”交通。在AI参与下，信号灯可以自动配时，还有截流控制、动态绿波等应用，不断优化城市交通。一线交警无需站在烈日下指挥交通，可以在智慧城市指挥大厅，宏观把握拥堵情况。数据显示，应用上AI后，交通警情处置效率提升了35%。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/a4/a7/a45924a89fb6a5ae4ae1c5ea9aa01ea7.png\" /></p><p></p><p></p><p>在北京这样的超大型城市，交通拥堵频繁发生，尤其上下班路上经常是“一路堵途”。北京亦庄的智能路口建设，解决了这一痛点。百度集团资深副总裁、智能驾驶事业群总经理李震宇将智能路口的效果形容为“灯数车”，他表示，智能路口建设让市民一路绿灯出行不再靠运气。例如，在332个智能路口作用下，一趟就能为用户杨晓芳减少20分钟通勤时间。</p><p></p><h2>世界首个航天领域大模型发布</h2><p></p><p></p><p>百度CTO王海峰与中国探月工程副总指挥、国家航天局探月与航天工程中心主任刘继忠发布了世界上第一个航天领域大模型——“航天-百度·文心大模型”。</p><p></p><p>航天-百度·文心从航天领域的数据和知识中融合学习，可以对航天数据进行智能采集、分析和理解，助力深空智能感知、规划和控制等技术突破。</p><p></p><p>刘继忠表示，“‘航天-百度·文心大模型’的应用，可以促使科研人员有更多精力投入到创新、创造的工作中。未来，双方将充分发挥各自优势，在深空探测智能技术研发、应用平台开发及项目实施、太空科创科普传播和人才培养等方面开展全面深入合作。”</p><p></p><p>王海峰还分享了飞桨产业级深度学习开源开放平台助力牧民、农民、电厂工人用上AI的实践应用。例如在牧场，基于飞桨开发的母羊分娩预测和预警系统，减少母羊分娩过程的人工看护工作量、降低母羊难产率；农学专家利用飞桨，保障无人驾驶拖拉机等智能农机按照预定的轨迹精准作业；在电厂，基于飞桨打造的电厂设备故障智能预判系统，可智能诊断设备故障，高效检修。</p><p></p><p>数据显示，目前，飞桨已汇聚477万名开发者。在产业级知识增强文心大模型方面，目前文心家族已经发布了20多个大模型，包括联合发布的鹏城-百度·文心、国网-百度·文心和浦发-百度·文心等。</p><p></p><p>值得一提的是，百度在大会现场用AI复原了中国十大传世名画之一《富春山居图》的残卷。基于文心大模型“补全”传世名画《富春山居图》残卷，隔三百年的山水合而为一，并题诗一首，，“一峰一状百树迎，天水合璧两岸情”。现在，在百度APP搜索“富春山居图”，每个人都可以参与《富春山居图》的“虚拟补全”，创作属于自己的《富春山居图》。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/c6/8a/c64583e8bec07c6b1ac9c91eb930788a.png\" /></p><p></p><p></p><h2>百度智能云的新成绩单：发布开物、九州</h2><p></p><p></p><p>百度集团执行副总裁、百度智能云事业群组负责人沈抖分享了百度在企业智能化升级的技术成果。</p><p></p><p>数字化转型升级已是当下和未来不可忽视的科技趋势。其中，云计算是推动数字化转型的重要基础设施之一。百度智能云侧重将其“云智一体”的能力，先从重点行业的核心场景切入，积累行业经验，再把不同行业的通用需求沉淀到通用AI产品中，打造成标准化产品，降低AI使用门槛，帮助企业从数字化驱动进阶为智能化牵引。</p><p></p><p>在帮助传统产业进行智能化改造方面，百度展示了在电力、能源、水力、制造、农业等行业的应用案例。应用实践和数据显示，AI风机巡检可以代替电力工人冲在一线最危险的地方，让巡检效率最高提升10倍；在石家庄城市社区供暖系统的智能化改造项目中，通过智能化管理和调度，整个石家庄城市热网节能20%....</p><p></p><p>为助力传统产业智能化改造，降低AI使用门槛。沈抖现场发布了全新版本的开物2.0工业互联网平台和九州区县大脑。目前，开物2.0累积超过200个工业解决方案，沉淀了3.8万个工业模型，覆盖质量管控、安全生产、节能减排、生产制造等9大领域，为工业领域企业上云、用数、赋智提供数字化服务。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/6a/8a/6a2912e974b4389d649e3524dd99ac8a.png\" /></p><p></p><p></p><p>除开物2.0之外，大会还发布了百度智能云九州区县大脑，用数字技术助推基层城乡治理，孵化地方产业、文化、生态场景的数字化应用。</p><p></p><h2>AI智能硬件：小度构建“未来的家”</h2><p></p><p></p><p>在AI智能硬件方面，小度科技CEO景鲲现场发布了三款围绕健康的新品——小度添添智能健身镜M30、小度语音智能闹钟及小度大屏护眼学习机P20。</p><p></p><p>据悉，小度添添智能健身镜M30可以改善健身枯燥、难坚持等痛点，内置17类健身课程，拥有体感游戏、双人游戏、多人在线连麦健身模式等，满足全年龄段人群的健身需求，增强运动的趣味性和互动感。小度添添智能健身镜还具有 “AI火柴人投影技术”及智能动作指导等功能。除健身功能外，小度添添智能健身镜M30还能听歌、K歌、投屏、刷短视频、播报天气和新闻。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/f2/3c/f2657f4296b5a643638f5723f7afaa3c.png\" /></p><p></p><p></p><p>小度语音智能闹钟由小度和中国科学院脑科学与智能技术卓越创新中心等多位睡眠领域专家联合打造，可基于专业的睡眠测试，为用户推荐适合的白噪音、轻音乐，打造专属助眠解决方案。小度语音智能闹钟还能在睡眠期间监测睡眠质量及环境，并生成睡眠质量报告。小度语音智能闹钟还具备红外远程遥控功能，一句话控制家中的新老家电，创造易眠环境。</p><p></p><p>小度大屏护眼学习机P20，搭载15.6英寸AI护眼屏幕，具备防蓝光、防眩光无频闪、AI屏幕光线自适应调节等20重护眼功能。同时基于AI摄像头能力，能够实时监测孩子坐姿，当发现错误坐姿时，会主动发出语音提醒给予纠正。此外，涵盖学前教育、整个义务教育阶段在内的全学科内容，同时搭载AI精准学系统，帮助学生诊断出学习中的难点和薄弱项等。</p><p></p><p>景鲲在现场还宣布，未来将在线下增设100家全屋智能体验门店，加速小度“未来的家”落地。</p>",
    "publish_time": "2022-07-21 13:38:34",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]