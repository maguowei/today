[
  {
    "title": "消除了“泡沫”的数据中台如今怎么样了？《2023数据中台调研报告》问卷启动",
    "url": "https://www.infoq.cn/article/eQ89yuYWOTwOC0kVCEwu",
    "summary": "<p>自2020年<a href=\"https://www.infoq.cn/article/4PXxXJ*ZOmPVlAtB2Ttb\">《数据中台已成下一风口，它会颠覆数据工程师的工作吗？》</a>\"文章发布以来，数据中台的热度从火速蹿红到稳定落地，正处于全面开花阶段，正如两年之前作者预测的那样，数据中台的生命力和商业化能力远高于业务中台。</p><p></p><p>两年过去，众多企业都已经建设了数据中台，数据中台成为了一个新的本土细分市场。虽然业界对数据中台的争议声也接连不断。但是，仍然有不少企业把数据中台始终作为数字化能力建设的关键部分。那么，到底数据中台是否产生了业务价值？企业数据中台的建设究竟处于什么样的进展？企业对此是否有了更进一步的需求和洞见?</p><p></p><p>为了为深入了解中国企业对数据中台的最新认知和需求，以及数据中台在企业数字化转型中的现实价值，现发放《2023数据中台的数据调研》，调研收集的数据将被统计分析写入《2023数据中台调研报告：让数据的价值被看见》。扫码参与问卷填写，即可获得报告全文。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/de/26/dea9d848cc7ef3ebf5b6d5ece3dc8126.png\" /></p><p></p>",
    "publish_time": "2023-01-03 09:21:10",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "下一代前端语言之争，JavaScript 要被新语言反超？",
    "url": "https://www.infoq.cn/article/4Et0wIAxWFbVez5wbMCC",
    "summary": "<p></p><p>假如大家正在编写<a href=\"https://www.infoq.cn/topic/Front-end\">前端</a>\"代码，那么会选择哪种编程语言？目前来看，最有希望的选手主要有三个：首先是最常规的 <a href=\"https://xie.infoq.cn/article/9c44692def1e3a908c9121c8f\">JavaScript</a>\"，然后是能编译为 <a href=\"https://www.infoq.cn/article/Q02piNCyvfAM0YJobfVq\">WebAssembly</a>\"（Wasm）的语言，最后则是能编译成 JavaScript 的语言。</p><p></p><p>常规 JavaScript 需要的配套工具最少，但代价是调试起来相当麻烦，代码可读性也差。虽然选择 JS 确实门槛较低，不过除了一味痴迷“极简主义”的铁粉以外，我个人觉得这个选项只能说一般。</p><p></p><p>能编译为 Wasm 的语言虽然越来越多，但总体上还是新生事物。这些语言往往带有大量的二进制文件，因为其中大多需要配合额外的运行时。Interop 距离发展成熟还差得远。另外，即使两种语言都能编译成 Wasm，也不代表它们之间就能良好实现互操作。再有，这个阵营的生态储备还远远比不上积累了几十年的 JavaScript DOM 库。在 Wasm 这边，React 和 Svelte 应该是最好的选项了。大家千万别误会，我可不是在唱衰 Wasm。它已经拥有专属于自己的表现舞台，如果大家想要在浏览器中运行高计算量原生代码，但 Wasm 就是最完美的选项。可如果不是这种情况，我个人不太推荐用它进行日常前端开发。</p><p></p><p>最后剩下的就是能编译成 JavaScript 的语言了。但这个阵营形成了一家独大的局面，其中的老大我们稍后会具体讨论。相比之下，ClojureScript、Elm、ReScript、Dart 等语言都形成了颇具体量的社区，但未来市场份额还能不能进一步扩大尚未可知。这就很尴尬了，毕竟能编译成 JavaScript 的语言代表的基本就是浏览器上的最佳编程体验。在它们的支持下，我们既能享受 JS 所不具备的良好功能，比如静态类型、强类型、不变性、宏等，同时也能通过 bindings 支持 JS 及其广泛的生态系统。而且，它们还不需要笨拙的大型运行时。</p><p></p><p>由于 Wasm 的存在，我怀疑 JS 编译阵营会有所保留，毕竟很多人觉得前者才是浏览器上的最佳编译目标。我其实并不同意这种观点，能编译成 JavaScript 的语言还是越多越好。总之，我想借这篇文章跟大家聊聊现有及未来可能出现的前端语言，应该朝着哪个方向发展。</p><p></p><h4>TypeScript 还行吗？</h4><p></p><p></p><p>这就是我前文提到的 JS 编译阵营中的“老大”——TypeScript。TypeScript 是种很棒的语言，显著改善了开发者体验。它还新增了安全层，促进工具质量提升，并大大降低了使用门槛。考虑到生态系统的繁荣现状以及对 JS 类型检查难题的妥善解决，TypeScript 确实取得了非凡的成就。</p><p></p><p>当然，也有不少针对 TypeScript 的非议值得关注。首先就是这门语言的性能和健全性问题。需要注意的是，TypeScript 团队其实很清楚这两大顽疾，而其根源是开发团队在项目之初做出的明确权衡。在我看来，这些权衡是当时为了提高执行效率而做出的正确选择。</p><p></p><p>话虽如此，但性能确实是 TypeScript 最受诟病的问题。TypeScript 是自实现的，而且这种实现非常复杂。它的类型系统本身可以算是种迷你编程语言，这导致类型检查的速度极其缓慢。</p><p></p><p>第二个问题就是健全性。这事的讨论热度没那么高，但在编程爱好者群体内部还挺受关注。概括来讲，TypeScript 一身都是“缺陷”——allwJs 配置选项、any 类型和 intersection 类型，其类型系统根本无法保证代码的类型安全。换言之，我们编写的 TypeScript 很可能会触发运行时 bug。另外，除了极其简单的场景之外，TypeScript 还缺乏可靠的类型推断，所以开发者在很多地方都得明确标出类型注释。</p><p></p><p>但同样的，这两点也是项目权衡的结果。</p><p></p><p>引导编译器的存在对于 TypeScript 的内部测试至关重要，这能帮助项目开发者理解 TypeScript 这种语言用起来的真实感受。具体来讲，项目团队要体验如何编写大型 JS 代码库，再逐步采用代码库中的类型。在健全性方面放松一点，开发者才能在现有 JS 代码库中逐步引入 TypeScript，也能轻松使用 any 类型来直接摆脱类型系统的束缚。</p><p></p><p>光是这部分就够单独写篇文章了。在我看来，TypeScript 可能是第一种更多关注开发者体验、而非自身语义的编程语言。它并没有添加任何运行时结构、不插手性能，而是添加了一套类型系统，并让整个语言社区接纳了这种不用类型也行、没高质量工具也行，还不强调正确性的生态氛围。这简直是个不可思议的壮举。</p><p></p><h4>下一代前端语言是什么样？</h4><p></p><p></p><p>所有这一切都表明，TypeScript 早在十年前就做出了一众对自身产生巨大影响的权衡。而随着时间推移，我觉得是时候通过新语言再做一轮权衡了。确切来讲，我们需要一种具备健全性、类型推断和更快编译速度的语言。</p><p></p><p>要求明确了，但我们该拿什么来换？</p><p></p><h5>健全性</h5><p></p><p></p><p>先从健全性说起。下一代语言不再努力对各种 JS 模式进行类型检查，而是以独立语言的形态通过更简单的类型系统将代码编译成 JS。它会将现有 JS 代码视频外部互操作对象，对 JS 代码执行显式运行时类型检查，而且依靠不同的原生语言来实现。</p><p></p><p>为什么要这样？首先，我个人特别喜欢具备既健全、又相对简单的类型系统的语言。我希望这种语言能够在浏览器中运行良好，而且能顺畅适配现有 Web 生态系统。那些能编译成 Wasm 的语言经常忽略 Web 生态系统中的其余部分，总想在浏览器中建立起基于像素的原生 UI。我觉得这个想法不错，只是跟我的观念相悖。我只想用下一代语言开发常规网站；我不想要纯函数式语言，而更倾向于跟 C 的老派风格相似的语言（对不起了，Elm！）；我希望这种语言能体现出我在工具设计上的想法。</p><p></p><p>那为什么下一代前端语言应该诞生在现在这个时间点？俗话说得好，种一棵树最好的时机是十年前，其次是现在。这十年来，JS 社区已经发生了很大变化。人们开始学习 TypeScript，也习惯于关注编译器并通过类型进行数据建模。现在，很多开发者开始使用 Rust、Swift 和 Kotlin 等语言，也意识到高质量工具的重要性。我不是说十年前的人们会抵抗强调类型安全的语言，但那时候的普及难度确实更高。</p><p></p><p>明确表达了需求，有些朋友可能觉得这说的不就是 ReScript/ReasonML 吗？没错，确实有几分相像。但在理想情况下，我期待的下一代语言应该能对 JS 代码和特性进行显式运行时类型检查。运行时类型检查是达成良好互操作性的前提，这样我们就能更轻松地随意使用 JS 库。</p><p></p><p>同样地，我觉得 traits 对用户来说也很重要，它们可以跟其他语言特性映射起来，比如 Java 接口和 C++ 概念。这可太方便了，比如轻松通过 Display trait 输出任意类型。这类需求听起来简单，但确实能大大提升语言的可用性，消除“我该怎么输出这个？”或者“为什么 + 代表整数加法，而 +. 代表浮点加法？”之类特别劝退的问题。再有，我还想去掉一些没用的东西，比如对象、链表、多态变体等。这些都是 ReScript/ReasonML 做不到的，而且我上次试用的时候，ReScript 的开发体验和错误消息也没给我留下深刻印象。</p><p></p><p>也就是说，我不排除 ReScript 代表着正确方向的可能性。毕竟上次尝试已经是几年之前了，也许是我记错了、也许它已经变得更好了。而且随着同 OCaml 的剥离，ReScript 确实成了很好的前端语言选项，我有必要再确认一下。</p><p></p><h5>类型安全</h5><p></p><p></p><p>对于下一代前端语言，我希望能用一种更系统的方法实现类型安全。具体来说，我觉得用 Rust 处理非安全代码块的方式实现 JS 互操作性的好办法。基本上，在调用 JS 的过程中，我们需要将代码打包在一个非安全代码块中。这会是个明确的标志，提醒开发者要认真阅读这段代码。接下来的目标，就是在这些指向 JS 库的非安全代码块上实现 bindings。起初这个过程需要手动完成，但后续应该会有类似 bindgen 和 cxx 的工具出现。</p><p></p><p>在 JS 中使用非安全代码块好像有点反直觉，毕竟 JS 的安全性又不像 C 那么糟糕。但很多人似乎没意识到，安全的意义并不仅限于安全本身。所谓安全，是指可以任意使用一个值、而不必担心其是否为 null 的保障能力。所谓安全，是在不致引入 Bug 或混乱的前提下保证可变性的能力。Rust 的非安全块概念允许用户既维护自己的安全区，又能与大量非安全代码交互。下一代浏览器语言也该做到这一点。</p><p></p><p>至于运行时检查，我觉得它仍然物有所值。我们已经在 JS 当中进行过大量模式验证，只是以往只能通过 zod 这类临时性机制完成。在下一代前端语言中，这类功能也许是在运行时出错时对语言类型执行自动转换，也许能对 JS 值进行模式匹配。</p><p></p><p>对于 WebAssembly，我还是很看好它的发展前景的。但要说它一定能成为浏览器的通用运行时，我个人还是持怀疑态度。也许未来我的态度会有转变，但目前我更多是将 Wasm 看作一种硬件加速器。</p><p></p><p>当用户的高强度计算任务要求调用固定宽度整数和静态函数时，大家就会使用 Wasm；这就像在需要执行并行计算时，大家会选择 GPU 一样。在这样的模型中，我看到了支持异构编译的潜力——其中部分代码可以被编译成 JS，另一部分代码则可编译为 Wasm。这项工作可以由用户显式完成，由分析自动完成，甚至可以即时完成。通过对 JS 和 Wasm 代码的同时控制，编译器就能最大限度减少跨越语言边界的次数，从而提高性能水平。我觉得未来甚至可以有某种机制将部分代码发送给 WebGPU。</p><p></p><p>在这样的模型之上，也许我们可以更轻松地编写计算密集型程序，比如机器学习模型、电子游戏和渲染软件。</p><p></p><p>这种对 Wasm 和 JS 进行分别编译的概念，可以在下一代前端语言中体现出来。我希望其中能有显式整数和浮点类型，最好还能有 Rust 中 usize 那样的显式索引类型。这样如果需要把代码编译成 Wasm，新语言就能利用 Wasm 的固定宽度整数。</p><p></p><p>还有另一种可能性，就是为语言创建一个子集，在这里整合闭包、垃圾收集等动态特性以提升 Wasm 编译质量。要跟这个子集交互，开发者需要使用 unsafe 代码块，比如 strict 块，或者让该子集通过 dynamic 块跟外部代码交互。这些都是假设，但我觉得其中确有探究的价值。</p><p></p><h5>具体实现</h5><p></p><p></p><p>这种新语言可能会用 Rust 来实现。毕竟我个人是 Rust 的粉丝，而且相信代数数据类型、相对更高的代码性能、受限但可用的可变性，以及比较丰富的库组合足以支撑起一套优秀的编译器。</p><p></p><p>如果 Wasm 后续发展得够好、性能几乎逼近原生水平，那我也会考虑使用由编译为高速 Wasm 代码的语言子集来引导编译器。但这应该不着急，毕竟一个 Rust 编译器应该就够用好多年了。</p><p></p><h4>总结</h4><p></p><p></p><p>大家可能已经注意到，类型安全和 Wasm 部分其实就是在从系统语言（例如非安全概念和硬件加速）中汲取灵感，再把它们应用到基于浏览器的语言当中。这是设计使然，毕竟不少最有趣的编程语言都是从系统层面衍生出来的。我只希望这些好点子也能在浏览器上有所体现。</p><p></p><p>这里我要澄清一下，我所指的下一代前端语言绝不是单一语言，我希望能有多种语言齐头并进、朝着前面提到的方向共同探索。我想激励更多朋友在浏览器语言领域不断创新。当然，我个人也会参与其中，目前正在研究的是名叫 vicuna 的实现方案，但还处于非常早期的阶段。</p><p></p><p>原文链接：</p><p><a href=\"https://uptointerpretation.com/posts/the-next-browser-language/\">https://uptointerpretation.com/posts/the-next-browser-language/</a>\"</p><p></p><p></p><p></p>",
    "publish_time": "2023-01-03 09:46:31",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "了解下 Rust 的所有权机制",
    "url": "https://www.infoq.cn/article/9f588494f0f8634aaabb48cdc",
    "summary": "<p></p><h2>what's ownership?</h2><p></p><p>常见的高级语言都有自己的 Garbage Collection（GC）机制来管理程序运行的内存，例如 Java、Go 等。而 Rust 引入了一种全新的内存管理机制，就是 ownership（所有权）。它在编译时就能够保证内存安全，而不需要 GC 来进行运行时的内存回收。</p><p></p><p>在 Rust 中 ownership 有以下几个规则：</p><p></p><p>每个值都有一个 woner（所有者）在同一时间，每个值只能有一个 owner当 owner 离开作用域，这个值就会被丢弃</p><p></p><h2>Scope (作用域)</h2><p></p><p>通过作用域来划分 owner 的生命周期，作用域是一段代码的范围，例如函数体、代码块、if 语句等。当 owner 离开作用域，这个值就会被丢弃。</p><p></p><p>example:</p><p></p><p><code lang=\"rust\">fn main() {\n    let s = String::from(\"hello\"); // 变量 s 进入作用域，分配内存\n\n    // s 在这里可用\n\n} // 函数体结束，变量 s 离开作用域，s 被丢弃，内存被回收\n</code></p><p></p><h2>ownership transfer（所有权转移）</h2><p></p><p>和大多数语言一样，Rust 在栈上分配基本类型的值，例如整型、浮点型、布尔型等。而在堆上分配复杂类型的值，例如 String、Vec 等。所以，这里就引入了两个概念，move 和 clone。</p><p></p><h3>move</h3><p></p><p>move 操作会将变量的所有权转移给另一个变量，这样原来的变量就不能再使用了。这里需要注意的是，move 操作只会发生在栈上的值，因为在堆上的值是不可复制的，所以只能通过 clone 操作来复制。</p><p></p><p>example:</p><p></p><p><code lang=\"rust\">fn main(){\n    let s1 = String::from(\"hello\");\n    let s2 = s1;\n    print!(\"s1 = {}, s2 = {}\", s1, s2);\n}\n</code></p><p></p><p>在上面的代码例子中，如果你执行就会在编译时报错：</p><p></p><p><code lang=\"bash\">  --&gt; src/main.rs:11:32\n   |\n9  |     let s1 = String::from(\"hello\");\n   |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait\n10 |     let s2 = s1;\n   |              -- value moved here\n11 |     print!(\"s1 = {}, s2 = {}\", s1, s2);\n   |                                ^^ value borrowed here after move\n</code></p><p></p><p>编译器提示我们，s1 在赋值给 s2 时发生了 move 的操作，它把字符串 hello 的所有权移交给了 s2，此时 s1 的作用域到这里就结束了，所以后面再使用 s1 就会报错。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/0f/0f9b3b9f97745f9f3cd430cc33d645e7.jpeg\" /></p><p></p><h3>clone</h3><p></p><p>clone 操作会将变量的值复制一份，这样原来的变量和新的变量就都可以使用了。这里需要注意的是，clone 操作只会发生在堆上的值，因为在栈上的值是可复制的，所以只能通过 move 操作来转移所有权。</p><p></p><p>example:</p><p></p><p><code lang=\"rust\">fn main(){\n    let s1 = String::from(\"hello\");\n    let s2 = s1.clone();\n    print!(\"s1 = {}, s2 = {}\", s1, s2);\n}\n</code></p><p></p><p>我们对 s1 进行 clone 操作，这样 s1 和 s2 都可以使用了，而且 s1 的所有权也没有被转移，所以后面还可以继续使用 s1。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ac/acca66b7e0e92473e94ddfdda665d3d6.jpeg\" /></p><p></p><h3>copy</h3><p></p><p>如果一个类型实现了 copy 这个 trait，使用它的变量不会移动，而是被简单地复制，使它们在分配给另一个变量后仍然有效。</p><p></p><p>example:</p><p></p><p><code lang=\"rust\">fn main() {\n    let x = 5;\n    let y = x;\n    print!(\"x = {}, y = {}\", x, y);\n}\n</code></p><p></p><p>当 x 赋值给 y 后，x 和 y 都可以使用，而且 x 的所有权也没有被转移，所以后面还可以继续使用 x。这是因为 i32 这个类型实现了 copy 这个 trait，所以 x 的值被复制了一份，所以 x 和 y 都可以使用。</p><p></p><p>以下这些数据类型实现了 copy 这个 trait：</p><p></p><p>所有的整数类型，例如：u32、i32。布尔类型，bool，有 true 和 false 两个值。所有的浮点数类型，例如：f64、f32。字符类型，char。元组，当且仅当它们的元素类型都实现了 copy 这个 trait。例如，(i32, i32) 实现了 copy，但是 (i32, String) 就没有实现。</p><p></p><h2>References and Borrowing（引用和借用）</h2><p></p><p>我们将创建引用的动作称为借用。就像在现实生活中一样，如果一个人拥有某样东西，你可以向他们借用。完成后，您必须将其归还。你不拥有它。引用有以下几个规则：</p><p></p><p>在任何给定时间，你可以拥有任意数量的引用，但是只能拥有一个可变引用。引用必须总是有效的。</p><p></p><p>example1:</p><p></p><p><code lang=\"rust\">fn main() {\n    let s1 = String::from(\"hello\");\n    let len = calculate_length(&amp;s1);\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &amp;String) -&gt; usize {\n    s.len()\n} // s 作用域失效，但是由于 s 是一个引用，没有所有权，所以不会发生任何事情\n</code></p><p></p><p>上面代码中，我们使用符号 &amp; 来创造一个变量的引用。这里我们使用 &amp;s1 来把这个引用指向 s1。函数 calculate_length 的参数 s 的类型是 &amp;String，这意味着它是一个指向 String 类型的引用，然后在函数体内获取 s 的长度并返回给调用者。</p><p></p><p>example2:</p><p></p><p><code lang=\"rust\">fn main(){\n    // 同一时间可以拥有多个不可变引用\n    let s1 = String::from(\"hello\");\n    let s2 = &amp;s1;\n    let s3 = &amp;s1;\n    println!(\"s1 = {}, s2 = {}, s3 = {}\", s1, s2, s3);\n\n}\n</code></p><p></p><h3>Mutable References（可变引用）</h3><p></p><p>可变引用指的是可以改变引用值的引用。在同一作用域中，同一时间只能有一个可变引用。</p><p></p><p>example:</p><p></p><p><code lang=\"rust\">fn main(){\n    let mut s = String::from(\"hello\");\n    change(&amp;mut s);\n    println!(\"{}\", s);\n}\n\nfn change(some_string: &amp;mut String) {\n    some_string.push_str(\", world\");\n}\n</code></p><p></p><p>上面代码中，我们用 mut 先创建了一个可变变量 s,然后使用 &amp;mut s 创建了一个指向 s 的可变引用。函数 change 的入参也是一个指向 String 类型的可变引用，这样我们就可以在函数 change 中改变 s 的值了。</p><p></p><p>example2:</p><p></p><p><code lang=\"rust\">fn main() {\n    let mut s = String::from(\"hello\");\n    let r1 = &amp;mut s;\n    let r2 = &amp;mut s;  // 在这里。编译器会报错，因为在同一作用域中，同一时间只能有一个可变引用。\n\n    println!(\"{}, {}\", r1, r2);\n}\n</code></p><p></p><p><code lang=\"bash\">  --&gt; src/main.rs:41:14\n   |\n40 |     let r1 = &amp;mut s;\n   |              ------ first mutable borrow occurs here\n41 |     let r2 = &amp;mut s;\n   |              ^^^^^^ second mutable borrow occurs here\n42 |\n43 |     println!(\"{}, {}\", r1, r2);\n   |                        -- first borrow later used here\n</code></p><p></p><h3>Dangling References（悬垂引用）</h3><p></p><p>悬垂引用是指引用一个不存在的值。在 Rust 中，这是不可能的，因为编译器会在编译时就检查这种情况。下面是一个例子：</p><p></p><p><code lang=\"rust\">fn main() {\n    let reference_to_nothing = dangle(); // 获得一个指向不存在值的引用\n}\n\nfn dangle() -&gt; &amp;String {\n    let s = String::from(\"hello\"); // s 进入作用域\n\n    &amp;s // 返回 s 的引用\n} // s 作用域结束，s 被丢弃，内存被释放\n</code></p><p></p><p><code lang=\"bash\">  --&gt; src/main.rs:51:16\n   |\n51 | fn dangle() -&gt; &amp;String {\n   |                ^ expected named lifetime parameter\n</code></p><p></p><p>因为变量 s 的作用域只在 dangle 函数内，当 dangle 函数返回 s 的引用时，s 已经被释放了，所以这个引用就是悬垂引用了。解决这个的方法是返回一个 String 而不是一个引用，这样 s 就不会被释放，而是把 s 的所有权转移给了调用者，也就不存在悬垂引用了。</p><p></p><p><code lang=\"rust\">fn dangle() -&gt; String {\n    let s = String::from(\"hello\");\n    s\n}\n</code></p><p></p>",
    "publish_time": "2023-01-03 10:28:02",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "反Twitter平台用户激增250万，这名29岁程序员如何凭一己之力扛住超8倍流量增长？",
    "url": "https://www.infoq.cn/article/j56P0ocglkyiKSBG6OGD",
    "summary": "<p></p><blockquote>作为 Twitter 的替代品，Mastodon 越来越受欢迎，但这个平台背后，只有一名全职员工。面对激增而来的用户，凭一己之力运营Mastodon是个什么感受？</blockquote><p></p><p>&nbsp;</p><p>Mastodon明显需要感谢Twitter的CEO马斯克。马斯克于10 月下旬正式接管 Twitter，Mastodon 用户数量就开始激增。仅在马斯克接掌Twitter的几天之后，Mastodon宣称其用户已从30万涨到了65万5千人。这段时间，马斯克削减开支、大幅裁员和对平台进行混乱更改，在这些神操作下，越来越多用户涌向了Mastodon平台，终于在12月底，每月活跃用户增加到了250万。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/48/48a75ba0d60999e8404b116ac2ee87fb.png\" /></p><p></p><p>除了普通用户，还有些组织也宣布入驻 Mastodon。12月20日， Firefox 浏览器的开发商<a href=\"https://blog.mozilla.org/en/mozilla/mozilla-launch-fediverse-instance-social-media-alternative/\">Mozilla宣布将开始运行Mastodon“实例”</a>\"，并计划于明年初进行公开测试，正式开启了在该平台上建立业务的热潮。</p><p>&nbsp;</p><p>资金也希望能够流入 Mastodon，据<a href=\"https://www.ft.com/content/de808736-2e05-4c3b-a53c-55b170ae9efd\">《金融时报》消息</a>\"，来自硅谷风险投资公司对 Mastodon充满了兴趣，但Mastodon创始人为了保持这个社交媒体平台的非营利地位，在近几个月里数次拒绝了他们的投资提议。</p><p>&nbsp;</p><p>Mastodon的名气不断上升，马斯克不得不承认链接到 Twitter 竞争对手是一个错误，他一度禁止掉了所有指向竞争对手服务的链接，还封禁了不少相关用户账户。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/63/634e4b4cac64d34955fe6e6b1562df06.png\" /></p><p></p><p></p><h2>用户多了，创始人的压力也更大了</h2><p></p><p>&nbsp;</p><p>Mastodon由一位名叫Eugen Rochko的德国程序员创立。2016 年，Twitter 平台将信息流改为采用算法驱动的乱序默认时间线，当时，Rochko刚从一所德国大学里获得计算机科学学位，因为对Twitter平台的不满，他决定实现一个自己的社交媒体。</p><p>&nbsp;</p><p>Mastodon被设计成为了一个开源的社交媒体平台，建立在 Fediverse 去中心化网络上，这是由数千个独立服务器连接的应用程序和网站构成的在线世界。目前 Fediverse 上大约有 5,700 台 Mastodon 服务器。该软件<a href=\"https://www.w3.org/TR/activitypub/\">使用名为ActivityPub</a>\"的协议，由 Ruby on Rails 后端、JavaScript 前端、Sidekiq 作业管理和 PostgreSQL 关系数据库组成。作为反Twitter平台，Mastodon 没有使用推荐算法，也不会尝试向用户推荐任何东西，也没有统一的审核机制，各分支可以按照自己的规则来决定哪些人可以加入、哪些内容可以发布。</p><p>&nbsp;</p><p>2017 年，Rochko发布了第一版代码，但用户增长一直十分缓慢，最开始Mastodon的追随者都是技术作家和黑客，这也是创建时的目标人群，而且对“权力下放”和“开源”的强调只会让最精通技术的人感到鼓舞和受到吸引。</p><p>&nbsp;</p><p>2021 年，美国前总统特朗普团队使用了 Mastodon 的源代码，开发了他们的新社交媒体平台，即所谓的 Truth Social，并获得了上百万的独立访问用户，这才让 Mastodon 名声大噪。特朗普团队最初还隐瞒了使用了 Mastodon 代码这一事实，但该行为违反了 GNU 开源协议。后来这一事实被 Mastodon 团队发现了，他们给 Truth Social 的开发人员发了律师函，特朗普团队才不得不公布了源代码。Truth Social 也是最著名的 Mastodon 实例。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/f2/f2999d4126331441b397282c0f21394a.png\" /></p><p></p><p>作为该项目唯一一个全职员工，Eugen Rochko 曾说：“我们没有办法控制成功何时才能到来，只能不断为它奠定基础。”现在，因为马斯克的神操作，Mastodon用户激增，这位现年29岁的德国程序员也在几周之内突然再次闻名全球，同时也让他压力倍增。</p><p>&nbsp;</p><p>新增的上百万 Mastodon 帐户，使流行的服务器不堪重负，新手介绍、问题和投诉淹没了现有用户的时间线。自从马斯克接管 Twitter 以来，Rochko 一直在长时间工作以保持自己的服务器<a href=\"https://mastodon.social/\">Mastodon.Social</a>\"正常运行，同时还准备对 Mastodon 进行重大升级。</p><p>&nbsp;</p><p>今年11月，Rochko在接受 Wired 采访时表示，自从该网络上个月人气暴涨以来，他每天需要工作 14 个小时。</p><p>&nbsp;</p><p>与巨头竞争对手Twitter相比，Mastodon 的规模和结构看起来非常不同。在公司 2021 年的年度报告中，罗奇科是唯一的固定雇员，他在在德国东部一个小镇的家中编程，每月收入 2,400 欧元，团队中还有一些合同工。去年社区向运行 Mastodon 的非营利性组织<a href=\"https://www.patreon.com/posts/mastodon-annual-61911077\">捐款总计 55,000 欧元</a>\"，但该团队只花了 23,000 欧元。</p><p>&nbsp;</p><p>随着服务变得越来越流行， Mastodon 实例的托管成本也显着增加，Mastodon不得不扩大规模并为服务器支付更多费用。“但是 Mastodon和 Fediverse网络提供了将负载分散到多个不同参与者的能力。我可以在我的服务器上关闭注册，其他服务器和网络将立即接收正在尝试注册的人。”</p><p>&nbsp;</p><p>值得强调的是，跟 Twitter 是单一的一个网站不同，Mastodon 并不是一个单独的平台。它也不是一个实实在在的“东西”，不是由某个人或某个公司拥有。Mastodon 的核心是 Rochko 提供的开源软件系统，任何人都可以在自己的服务器上部署这样一个系统，运作自己的 Mastodon 服务，每个服务也可以称为“实例”(instance)。每一个 Mastodon 服务器，都是一个自给自足的“微型”社交网络，可以有它自己的主题，比如金融、数码、生活、职场等等。用户在注册 Mastodon 的时候，必须选择其中一个。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/0a/0a3a0b8fecfed2f725d62d53da816f25.png\" /></p><p></p><p>当所有Mastodon服务器连接在一起，才形成了一个非集中性的网络。这也是去中心化平台的粉丝们所喜欢的一个特点，因为这种平台不会像Twitter那样容易被控制。</p><p>&nbsp;</p><p>虽然作为一个全球分布式现代应用程序，但激增的用户也会给维护这些服务器的人员和团队带来挑战。就像Rochko所说的，当压力增大时，有的服务器可以在不堪重负的情况下选择关闭注册，将压力分摊给其他服务器或网络。</p><p></p><h2>在压力下，运行Mastodon服务器的技术人</h2><p></p><p>&nbsp;</p><p>Jaz-Michael King就是其中一位运营Mastodon服务器中的人。他是一名威尔士人，经营一家美国互联网公司，业余时间运营着一个叫作Toot Wales的Mastodon服务器。与其他Mastodon服务器一样，在马斯克接管Twitter后，Toot Wales用户活跃度呈指数级增长。</p><p>&nbsp;</p><p>“在马斯克抱着水槽走进Twitter办公室之前，我们每天大概处理15万条消息……现在每天要处理300万到400万条消息。我们的注册用户是之前的3倍，活跃度也大大增加了。”</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e0/e0275530a5ea37df7075347bdb17cf37.png\" /></p><p></p><p>Toot Wales</p><p>&nbsp;</p><p>为了运营好Toot Wales，King选择了一家知名的托管公司mastohost。“我对技术了解得足够多，可以要求他们做出任何我想要的调整，但我还是尽量不去这么做。我的另一个原则是我们只运行主分支，不使用任何试验性的东西，也不使用不稳定的软件更新。我想要稳定的、功能性的、经过实战测试的代码。我在边缘部分做了一些改动——我以前会在前端做很多改动，最近升级到Mastodon 4.0后，我甚至把前端大部分东西都去掉了，所以它非常简洁。我想要知道我运营的是什么，想要知道什么是有效的，但我尽量不去动它。”</p><p>&nbsp;</p><p>他还对设计做了一些修改。主要是为了让非技术用户不会对Mastodon的用户界面感到厌烦——即使是最狂热的信徒也应该承认，与Twitter的用户体验相比，Mastodon的用户界面略显逊色。Mastodon的布局看起来有点像TweetDeck（一款Twitter客户端），有多个列。虽然这对于关注列表或标签搜索很有用，但它的实现不如TweetDeck的好。他说：“我所能做的是改进用户体验。我坚信我们不需要多列视图，我们是一个提供单列试图的服务器。”</p><p>&nbsp;</p><p>尽管他尽量不插手托管方技术上的事情，但自从发生Twitter收购事件以来，King一直忙于处理社区和内容方面的事情。“内容和社区管理，包括内容审核，一直是一个沉重的负担。我们需要巧妙地向人们描述我们为什么存在，以及为什么我们并非另一个特推——很多人以为Mastodon是在不久前创建的，目的是为了替代Twitter。因此，我们需要向人们解释他们使用的其实是几年前就有的东西，然后管理现有的和即将到来的社区期望，并找到中间地带。”</p><p>&nbsp;</p><p>King希望Mastodon在社区管理功能方面做出改进。首先，他希望“在产品中加入比现在更多的联邦和去联邦服务。”他指的是与其他服务器通信的方法，比如阻止清单。他想要一种在服务器之间“谨慎、合乎道德、谨慎地共享”信息的方法。</p><p>&nbsp;</p><p>作为一个开源软件项目，Mastodon的一个设计是不鼓励用户使用关键字搜索。默认情况下，你可以搜索话题标签，但（与Twitter不同）不能输入搜索关键字——比如“马斯克”——然后等待结果。这在不同的服务器之间的实现是不同的，有些服务器可以搜索到自己发的或参与的帖子，但从更大的范围来看，并没有结果。</p><p>&nbsp;</p><p>Mastodon的GitHub主页有一个关于搜索限制的争议。King对此表示，从Twitter迁移过来的用户期望他们能够搜索关键字，因为他们在Twitter上已经习惯了，但他仍然对此持抵制态度。Toot Wales的用户甚至不能搜索自己的帖子。King考虑过开启这个选项，但他担心这会对他的服务器造成影响。“我们可以开启搜索功能的增强特性，让用户可以搜索自己的内容。说实话，我认为它不值得浪费CPU资源。”</p><p>&nbsp;</p><p>撇开用户喜好不谈，King通过Toot Wales为威尔士在线社区提供了很好的服务。他没有从中赚到钱，这个网站的运营主体实际上是King创立的一个美国慈善机构。</p><p>&nbsp;</p><p>参考链接：</p><p><a href=\"https://joinmastodon.org/zh/servers\">https://joinmastodon.org/zh/servers</a>\"</p><p><a href=\"https://github.com/mastodon/mastodon\">https://github.com/mastodon/mastodon</a>\"</p><p><a href=\"https://www.section.io/blog/mastodon/\">https://www.section.io/blog/mastodon/</a>\"</p><p><a href=\"https://www.wired.com/story/the-man-behind-mastodon-eugen-rochko-built-it-for-this-moment/\">https://www.wired.com/story/the-man-behind-mastodon-eugen-rochko-built-it-for-this-moment/</a>\"</p><p><a href=\"https://www.lemonde.fr/en/m-le-mag/article/2022/11/21/who-is-eugen-rochko-the-young-creator-behind-mastodon_6005052_117.html\">https://www.lemonde.fr/en/m-le-mag/article/2022/11/21/who-is-eugen-rochko-the-young-creator-behind-mastodon_6005052_117.html</a>\"</p><p><a href=\"https://www.euronews.com/next/2022/11/25/the-anti-elon-musk-meet-eugen-rochko-the-man-behind-twitter-rival-mastodon\">https://www.euronews.com/next/2022/11/25/the-anti-elon-musk-meet-eugen-rochko-the-man-behind-twitter-rival-mastodon</a>\"</p><p><a href=\"https://thenewstack.io/what-its-like-to-run-a-mastodon-server-in-the-musk-twitter-era\">https://thenewstack.io/what-its-like-to-run-a-mastodon-server-in-the-musk-twitter-era</a>\"</p><p>&nbsp;</p>",
    "publish_time": "2023-01-03 11:09:33",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "平台工程中认知负荷的挑战",
    "url": "https://www.infoq.cn/article/doz4HmWsaZwH4hi6FqXX",
    "summary": "<p>在<a href=\"https://platformengineering.org/blog/cognitive-load\">最近的一篇文章中</a>\"，Syntasso首席运营官<a href=\"https://www.linkedin.com/in/paulalkennedy/\">Paula Kennedy</a>\"分享了她对开发团队所承受的不断增加的认知负荷的看法。她解释说，平台工程方式试图减轻开发团队的一些认知负荷，但这可能是以将认知负荷转移给平台团队为代价的。</p><p>&nbsp;</p><p><a href=\"https://en.wikipedia.org/wiki/Cognitive_load\">认知负荷理论（CLT）</a>\"由John Sweller于1988年首次提出，它认为人类的认知是工作记忆和长期记忆的结合。工作记忆的容量有限，由负责引导注意力和协调认知过程的多个组成部分组成。另一方面，长期记忆具有无限的存储容量，可以根据需要与工作记忆一起检索信息。</p><p>&nbsp;</p><p>CLT最初被设计为一种改善课堂教学的手段，但也有应用于软件开发。Sweller确定了三种类型的认知负荷：内在的、外在的和增生的。内在认知负荷是与手头任务相关的努力。在数学课上，这可能是2+2或尝试化简一个多项式方程。用教学术语来说，这通常被认为是不可变的。</p><p>&nbsp;</p><p>外在认知负荷产生于强加给执行任务的个人的任务本身及任务之外的要求。它可能包括分散注意力的信息、糟糕的指令或以不理想的方式传达的信息。例如，口头向某人提供配置负载平衡器的步骤，而不是以书面文档的形式提供。</p><p>&nbsp;</p><p>正如Psychologist World的<a href=\"https://www.psychologistworld.com/memory/cognitive-load-theory\">一篇文章</a>\"所述，增生认知负荷是：</p><p>&nbsp;</p><p></p><blockquote>通过构建模式生成，被认为是可取的，因为它有助于学习新技能和其他信息。</blockquote><p></p><p>&nbsp;</p><p>在认知科学中，模式是一种先入为主观念的心理构造，就像是一个代表世界各方面的框架。虽然内在认知负荷被认为是不可变的，但我们希望最小化外在认知负荷，并尽量最大化增生认知负荷。</p><p>&nbsp;</p><p>对平台工程中开发人员体验的关注是对负责整个产品开发生命周期的团队所承受的沉重认知负荷的一种回应。Puppet的区域首席技术官<a href=\"https://twitter.com/nigelkersten\">Nigel Kersten</a>\"<a href=\"https://www.youtube.com/watch?v=dFqp-p1-1ZI&amp;ab_channel=PlatformEngineering\">解释说</a>\"，实施完全自主DevOps团队的组织，尤其是大型企业，可能会对局部进行优化，但会以牺牲其他团队为代价：</p><p>&nbsp;</p><p></p><blockquote>这可以很好地为特定的价值流团队或应用程序进行局部优化。但它并不是针对整个组织进行优化，而是为审计人员、IT资产管理人员以及所有围绕成本控制和安全的治理问题创造了认知负荷。你如何从一个团队切换到另一个团队？所有这些都会变得非常非常复杂。</blockquote><p></p><p>&nbsp;</p><p>随着对开发团队需求的增加，我们开始触及可处理信息量的极限。沉重的认知负荷会对有效完成任务的能力产生负面影响。Kennedy指出：</p><p>&nbsp;</p><p>&nbsp;</p><p></p><blockquote>对于任何试图驾驭复杂技术环境的人来说，这是一场持续的斗争。每天都会有新工具发布，跟上新功能、评估工具、为工作选择合适的工具，更不用说理解这些工具如何相互交互以及它们如何适用于你的技术堆栈，这都是一项艰巨的任务。</blockquote><p></p><p>&nbsp;</p><p>这些活动与分配给业务流（stream-aligned）团队的关键任务无关，因此会干扰实现业务基本优先级的快速流动。对于业务流开发团队来说，交付业务价值是团队应该花费大量时间和精力的任务。对于大多数公司来说，像更新新的CI/CD工具或最新的安全威胁之类的任务对其所销售的产品来说并不是直接至关重要的。</p><p>&nbsp;</p><p>MYOB架构主管<a href=\"https://www.linkedin.com/in/evanbottcher/?originalSubdomain=au\">Evan Bottcher</a>\"将平台<a href=\"https://martinfowler.com/articles/talk-about-platforms.html\">描述</a>\"为：</p><p>&nbsp;</p><p>数字平台是自助服务API、工具、服务、知识和支持的基础，它们被分配为一个引人注目的内部产品。自主交付团队可以利用该平台以更快的速度交付产品功能，同时减少协作。</p><p>&nbsp;</p><p>这就是为什么开发人员的经验对于一个设计良好的平台来说是如此重要的原因。一个引入了额外外部认知负荷的平台，或者不是一个促进健康增生认知负载的模式，实际上会增加使用它的开发人员的认知负荷。一个不以最终用户为中心、不欣赏用户体验的平台将无法成功地改善它们的交付。</p><p>&nbsp;</p><p>正如Amenitiz的高级工程师<a href=\"https://www.linkedin.com/in/cristobalgarcia/\">Cristóbal García García</a>\"和Thoughtworks的技术主管<a href=\"https://www.linkedin.com/in/ctford/\">Chris Ford</a>\"<a href=\"https://martinfowler.com/articles/platform-prerequisites.html#ProductThinking\">所言</a>\"：</p><p>&nbsp;</p><p>你永远不要忘记，你正在开发的产品是为了取悦它们的客户——你的产品开发团队。任何阻碍开发人员顺利使用你的平台的因素，无论是API可用性方面的缺陷还是文档方面的差距，都会威胁到平台商业价值的成功实现。</p><p>&nbsp;</p><p>从认知负荷理论的角度看，愉悦感成为了一种限定平台为开发团队及其在完成任务的工作中所带来的认知负担的方式。正如Kennedy所描述的那样，平台团队的主要关注点是“提供‘开发人员愉悦”，同时避免技术膨胀，避免陷入构建不满足开发人员需求且未被采用的平台的陷阱。”</p><p>&nbsp;</p><p>她接着指出了铺砌路径（也称为黄金路径）的重要性：</p><p>&nbsp;</p><p>通过向开发人员提供黄金路径，平台团队可以鼓励他们使用业务首选的服务和工具。这有助于简化提供的工具数量，减少过多选项的认知负荷，并减少平台的技术膨胀。</p><p>&nbsp;</p><p>应用认知负荷理论，铺砌路径是一种增加增生认知负荷的方法，它为开发团队提供了一种模式，以更好地理解他们所处的问题空间。</p><p>&nbsp;</p><p>在<a href=\"https://twitter.com/matthewpskelton/status/1581191123300913152\">最近的一条推文</a>\"中，《团队拓扑》的合著者<a href=\"https://www.linkedin.com/in/matthewskelton/\">Matthew Skelton</a>\"回应了这种观点以及遵循良好模式所能带来的价值：</p><p>&nbsp;</p><p>如果“平台工程”中最重要的部分是维护一个高质量的wiki，它具有经过验证的共情模式，以供业务流团队遵循，那该怎么办？</p><p>&nbsp;</p><p>在教育学领域，有大量的研究表明，提供实际的例子有助于提高学习。正如Dan Williams<a href=\"https://set.et-foundation.co.uk/resources/the-importance-of-cognitive-load-theory\">所指出</a>\"的那样，</p><p>&nbsp;</p><p>这些步骤为学习者提供了指导和支持，帮助他们创建如何解决问题/任务或“好”的心理模型。另一方面，发现或基于问题的学习会给工作记忆带来负担，因为学习者没有足够的先验知识来支持他们的学习。</p><p>&nbsp;</p><p>铺砌路径和经过验证的模式有助于为开发团队提供从包含合规性和治理等领域的整体问题空间中获得良好的外观。由于大多数开发工作都是模仿基于问题的学习，因此开发团队的认知负荷已经非常高了。铺砌路径，以及相关的平台工具，可以简化问题空间，减少外在认知负荷。</p><p>&nbsp;</p><p>Kennedy确实担心，在给团队分配建立这个平台的任务时，我们不仅仅是均匀地分散认知负荷，而是把它推给了平台团队。她注意到</p><p>&nbsp;</p><p>这些团队已经开始负责提供开发人员体验了，但由于需要整合许多工具，以及合规性和治理等其他问题，他们面临着巨大的认知负荷。这通常是一个投资不足的团队，但他们还要负责提供支持客户价值交付的平台。</p><p>&nbsp;</p><p>Kennedy想知道，除了当前对开发人员体验的关注之外，我们是否还应该讨论并改善平台工程师的体验。</p><p>&nbsp;</p><p>InfoQ与Kennedy进行了坐谈，更详细地讨论了这篇文章。</p><p>&nbsp;</p><p>InfoQ：通过将负担转移到平台工程师身上，你表明我们实际上是把认知负荷往下推，而不是把它均匀地分摊出去。这感觉就像是我们在试图解决应用程序工程师当前的困境时，引入了一个新的问题。你建议我们如何确保平台团队不会超载呢？</p><p>&nbsp;</p><p></p><blockquote>Paula Kennedy：在过去几年中，有很多关于如何改善开发人员体验或“DevEx”的讨论和关注，以使开发人员更容易交付并减轻他们的认知负荷。不幸的是，这种认知负荷并没有消失，而且通常只是转移给其他人来管理了，比如平台工程师。&nbsp;为了帮助减轻这一负荷，我很乐意看到有人谈论平台团队体验以及我们如何改进它。无论平台团队是管理云提供商、运行现成的PaaS，还是在Kubernetes之上构建了自己的平台，我认为我们都需要为这些平台团队提供更多的资源和工具，以使它们能更容易地规划支持其组织的平台。随着对平台工程主题的讨论越来越多，我很高兴看到出现了帮助解决这一挑战的模式和工具。</blockquote><p></p><p>&nbsp;</p><p>InfoQ：你注意到，平台团队“负责提供支持客户价值交付的平台”，但通常投资不足。你认为这是为什么？平台团队可以做些什么来纠正这一问题？</p><p>&nbsp;</p><p></p><blockquote>Kennedy：根据我的经验，平台工程通常是有机发展，而不是刻意组建的平台团队，我们至少在三个方面看出这一点。&nbsp;首先，当组织接受DevOps文化并使团队能够自主地将其软件交付到生产中时，这些DevOps团队最终会在无需任何额外资源的情况下管理平台级的关注点。&nbsp;其次，一些组织认为任何内部平台都是基础设施团队的责任，被视为另一个需要最小化的基础设施成本。&nbsp;最后，我看到一些组织引入了一个由供应商支持的平台即服务，希望它能够解决所有的内部平台挑战，并且只需要最少的维护，因为一切都“开箱即用”的——但事实并非如此。&nbsp;在所有这些情况下，都没有理解管理内部平台所需的技能和资源，从而导致投资不足。&nbsp;值得庆幸的是，我们看到越来越多分享平台工程和平台团队可以带来的好处的资源和经验。《团队拓扑》是一本我经常推荐的书，因为它提供了一个词汇表来描述如何通过明确的团队职责和减少团队之间的摩擦来实现价值在整个组织中的流动，并最终流入客户手中。&nbsp;在《团队拓扑》中，作者主张拥有一个支持多个业务流团队的平台团队，这些团队应该协作来理解彼此的需求并建立同理心，同时推动X-As-a-Service模式，在这个模型中，平台团队确保业务流团队能够自助提供所需的工具和服务。随着越来越多关于平台团队为软件交付生命周期所带来的价值示例被公开分享，公司开始认识到投资于该团队的重要性，以确保他们拥有正确的技能和工具来支持更广泛的组织。&nbsp;平台团队还可以采取措施在内部展示其价值，方法是通过考虑对其组织非常重要的指标或关键绩效指标（KPI），以及他们的工作是如何有助于改进这些指标的。这可能看起来像是运行价值流映射练习，确定哪里存在浪费或重复，并演示平台团队如何提供集中服务来改善这一点。&nbsp;如果合规性是一个组织的关键问题，那么平台团队可以推动与合规团队和应用程序团队之间的密切合作，通过内置的合规步骤来创建无摩擦的生产路径，确保更快、更合规地交付软件。内部指标或KPI在很大程度上与具体环境密切相关，但通过旨在度量对业务重要的内容，平台团队可以随着时间的推移证明其价值及其所做的改进。</blockquote><p></p><p>&nbsp;</p><p>InfoQ：你提到DevOps在试图纠正因Dev和Ops分离而产生的问题时，导致开发人员背负了更多的认知负荷。平台工程范式正试图通过将部分负荷转移到一个自助平台上来解决这一问题，该平台可以处理将代码投入生产并处理支持代码的大部分负荷。我们是否正面临着重新引入DevOps试图打破的孤岛风险呢？</p><p>&nbsp;</p><p>&nbsp;</p><p></p><blockquote>Kennedy：“DevOps”这个术语对不同的人来说有着不同的含义，尽管这个术语已经出现了十多年，但它仍然经常引起混淆。就我个人而言，我喜欢引用Patrick Debois在2010年的定义：&nbsp;Devops运动是周围着这样一群人建立的，他们相信适当的技术和态度的结合应用可以彻底改变软件开发和交付的世界。&nbsp;DevOps运动的核心绝对是减少孤岛，增加团队之间的沟通和同理心，以及提高自动化，并努力实现持续交付。对我来说，拥有一个内部平台团队只是DevOps的自然演进，尤其是规模上的DevOps。&nbsp;平台团队的成员负责他们的内部平台产品，他们既需要开发该平台以满足其用户（应用程序团队）的需求，也需要日常运维这个平台。&nbsp;对于专注于向最终客户提供功能的软件开发人员，他们负责开发其软件，并使用平台团队支持的自助服务工具进行操作。在这个模型中，每个人都在做“DevOps”，即每个人都在开发和运维自己的软件。但要想真正发挥作用，避免出现更多的孤岛，还需要考虑一个重要的文化因素，这就是平台团队将其平台视为产品的思维方式转变。&nbsp;在过去的几年里，我曾多次谈到这一问题，但这取决于平台团队在组织中的演变，这可能会带来巨大的挑战。当将内部平台视为产品时，这包括理解用户需求（应用程序团队）、分批交付以寻求反馈、提供高质量的用户体验以取悦开发人员、内部营销和平台宣传等等。只要平台团队接受这种思维方式，我们就能看到显著的好处，如Puppet 2021DevOps状态报告（Puppet State of DevOps Report 2021）等行业研究所证明的那样：“并不是每个平台团队都会自动获得成功，但成功的团队会将它们的平台视为一种产品。”</blockquote><p></p><p>&nbsp;</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/cognitive-load-platform-engineering/\">https://www.infoq.com/articles/cognitive-load-platform-engineering/</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/7porVp7qVF03BVc2tDd6\">DevOps 已死，平台工程才是未来</a>\"</p><p><a href=\"https://www.infoq.cn/article/HQDbVRQq70wp0XLdSmuG\">滴滴工程效能平台建设之路</a>\"</p>",
    "publish_time": "2023-01-03 11:50:40",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]