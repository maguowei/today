[
  {
    "title": "分布式软件团队协作技巧：减少会议，异步优先",
    "url": "https://www.infoq.cn/article/RkUrtwmzlG3MuNuXskuK",
    "summary": "<p>本文要点：</p><p>在分布式团队中，以会议为中心的工作方式可能会破坏深度工作和流程、包容性、工作灵活性，长期来看还会妨碍知识共享。会议也不适合规模化。异步协作是这种以会议为中心的方法的有效替代方案。“异步优先”并不意味着“仅限异步”。也就是说，要充分认识异步沟通和同步沟通模式的优势，并根据需要做出选择。当然，大多数情况下默认采用异步协作方式。要采用异步优先的方法，就必须找到可行的异步协作替代方案，例如用现代化的任务看板代替状态更新会议，或者用可以自行安排观看节奏的视频代替入职培训。对当前团队使用分布式工作实践的成熟度做基线评估，帮助你确定异步协作可以在哪些方面带来改进。为了加速向“异步优先”转变，请务必记录工作流程，简化决策过程，创建团队手册，并进行会议审计。你是在分布式团队中工作吗？如果是，你就会知道，开会是一件非常耗时的事。虽然会议可能有其价值，但如果我们把它们作为默认的工作方式，就可能会在无意中导致团队日历的碎片化。安排被打乱可能会降低生产力，对于需要有时间专注于深度工作的知识工作者来说尤其如此。</p><p></p><p>在本文中，我们将讨论异步协作的好处及其实现方式。</p><p></p><p></p><h2>会议实在是太多</h2><p></p><p></p><p>“我们的会议太多了！”作为分布式团队的领导者或成员，你可能经常会听到这样的抱怨。如果你上次听到这个词是在开会的时候，那没什么可奇怪的。大流行增加了我们参加会议的次数，而许多团队一直是采用以会议为中心的协作方法。</p><p></p><p>设计讨论、状态更新、电话报告、日常站会、计划会议、开发启动、初步验收（desk check）、演示、审核和回顾，平均每个软件开发迭代都包含这样几次“同步”保障。而且，我们的会议还不止这些！</p><p></p><p>即时交谈、故障排除会议、头脑风暴、问题解决和决策——这些都成为分布式团队的会议。</p><p></p><p>2021 年至 2022 年期间，我对印度 1800 多名技术人员进行了非正式调查，希望借此了解他们的分布式工作模式。</p><p></p><p>除其他问题外，那次调查还要求受访者估计他们每周参加多少个小时的会议。此外，该调查还要求人们估计他们每天查看即时消息的次数。我们收到的回复令人震惊。</p><p></p><p>技术人员平均每周要花 14 个小时开会，相当于每年要花 80 天开会。你可能已经猜到，最有经验的技术人员会面临更大的会议负担。根据反馈，人们平均每天要被打断 18 次。罪魁祸首是什么？即时通讯——我们用来“快速响应”的工具。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/27/27f4f4035c19b28a74dddc8d45c001a0.jpg\" /></p><p></p><p>部分调查结果</p><p></p><p>本质上讲，软件开发是一个创造性的过程，无论你是在写代码、制作交互还是设计屏幕。领导软件团队也是一种创造性的活动。我们中的许多人会把时间花在构建技术路线图、阐明架构决策、原型设计、设计算法和分析代码上。正如 Paul Graham 在他 2009 年发表的文章中所指出的那样，软件开发是“创客”工作（即创造性工作），它需要“创客时间表”。“你不可能在一个小时内写好程序。这几乎不够工作准备的时间，”Graham 那天说。在创客时间表上，时间“至少要以半天为单位”，而会议和干扰可谓生产力的克星。</p><p></p><p>不出所料，我在调查中也遇到了这种看法。技术人员希望平均每周深度工作 20 个小时，但实际上只有 11 个小时。想象一下，如果我们能以某种方式找回那些失去的深度工作时间，每个团队能取得多大的成就。</p><p></p><p>现在我们来看下“异步优先（async-first）”协作。这个概念很简单，就是优先考虑异步协作而不是同步协作。我通过以下三个基本原则来描述它。</p><p></p><p>会议是最后的依仗而不是最初的选项。以文字作为分布式团队信息沟通的主要方式。团队中的每个人都非常习惯沟通中的合理延迟。</p><p></p><p>如果你对第一项原则感到惊讶，我能理解。在许多组织环境中，会议确实是领导者开展工作的主要工具。不过，对于以下两点，我相信我们可以达成共识。</p><p></p><p>对于团队中的大多数人来说，随时开会可能会导致工作被打断，一天都不安心，甚至效率低下。作为领导者，我们有责任为我们的团队创造一个工作环境，让他们能够体验到心流状态。许多会议之所以效率低下，是因为缺乏准备，缺少记录跟踪，对应参会人员的识别也不够准确。当我们采用“异步优先”方法时，我们也必须能够在需要时为同步交互做好准备。这可以帮助我们思考需要谁参加会议，以及如何将会议结果传达给没有参会的人。</p><p></p><p>所以，下次你想和同事合作的时候，与其去开会，不如考虑下，一种速度慢一点的异步媒介是否会更有效。你可以使用支持内置讨论区、Wiki、录制视频甚至收发消息和电子邮件的协作文档。</p><p></p><p>下面我将探讨下，为什么你和你的团队将受益于这种异步优先的思维方式，以及如何在你自己的环境中采用它。</p><p></p><p></p><h2>异步优先的六大优势</h2><p></p><p></p><p>自从大流行引发的远程工作革命以来，知识工作者现在希望雇主提供灵活的工作地点和时间。尽管有许多雇主要求员工回办公室办公，但可以这样假设，我们本就有一些同事对我们来说永远是远程的。除此之外，即使在经济衰退时期，企业也难以完全填补空缺的技术职位。市场终将回升，在某个时候，科技人才会显得更加稀缺。公司将不得不从其他能够招到人的地方招聘，并使他们融入到自己的团队中。技术团队“默认就将是分布式的”。有鉴于此，“异步优先”协作方法较当前以会议为中心的方法的优势就体现出来了。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/3b/3bbae05f5a963066b6651ff51006cbee.jpeg\" /></p><p></p><p>在异步优先的文化中，我们偏爱行动。我们会在当下做出最好的决策，记录下来，然后继续前进。重点是把事情做好。如果出了问题，我们会从中吸取教训，进行重构和调整。对行动的偏爱提高了团队做出并记录决策的能力。毕竟，决策是高绩效团队的能量之源。</p><p></p><p>除了这些好处之外，异步优先文化还能帮助你提高会议效率。当你把会议当作最后的手段时，你所参加的会议就是你所需要的。你找回了自己的时间和注意力，并让那些少数的、目的明确的会议对每个参加的人都有用。</p><p></p><p></p><h2>异步优先并非仅限异步</h2><p></p><p></p><p>采用异步优先并不意味着同步交互没有价值。异步和同步协作之间的良好平衡会使团队受益。在分布式团队中，这种平衡应该偏向于异步，以免每个人的日历上都有一年 80 天的会议。话虽如此，你也不能忽视同步协作的价值。</p><p></p><p>书面沟通的速度慢，你有足够的时间深思熟虑。你可以独自写一些东西，并分享给你的同事，而不必打电话。它还能让你达到在快节奏实时对话中无法达到的深度。你写的所有内容都可以在将来重用和引用。这就是异步沟通非常有效的原因。让我们看几个例子。</p><p></p><p>想象一下，架构师记录使用新库的提案并用文字从各个维度（例如集成计划、测试、验证、风险和替代方案）进行了描述。这可以在短时间内帮助整个团队和业务利益相关者参与进来。当团队成员在他们的工作流程中记录项目时，通过诸如会议纪要、架构决策记录、提交消息、拉取请求、创意论文或设计文档等，他们就构建了项目团队的集体记忆。这有助于你追溯项目，解释项目是如何到达当前状态的。上面的每个例子都可以从团队成员和领导者的协作中受益。例如，当领导者提议使用新库时，团队成员可以在 Wiki 页面上发表评论，分享关注点、想法、反馈和建议。使用类似的方式，初级团队成员可以创建拉取请求来触发代码审查，而团队领导者必须在审查拉取请求时提供有用的反馈。如此一来，书面沟通就成了一种协作实践。另一方面，同步沟通可以帮助你解决紧急问题。这就需要借助实时消息或视频会议了。不过，并非所有的活动都是紧急的。将同步工作模式应用于非紧急活动，通常要付出工作流中断的“代价”。这就是为什么我们必须在同步和异步之间进行平衡！</p><p></p><p>同样，当你必须在短时间内处理许多话题时，或者当你想要获得自发的、未经过滤的反应和想法时，你就会希望采用同步方式。你肯定也会同意，大多数人都希望与同事建立一些“人类”的联系，特别是在远程和分布式团队中。这也是同步沟通的优势所在。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/d0/d0dde6aecaf4059dfa01cb6f9a5ea25f.jpg\" /></p><p></p><p></p><h2>异步 vs 同步沟通——价值平衡</h2><p></p><p></p><p>所以请记住——“异步优先”并非“仅限异步”。要根据需要对团队的协作模式进行权衡取舍。为正确的目的选择合适的模式。</p><p></p><p></p><h2>采用异步优先的障碍</h2><p></p><p></p><p>异步优先的概念看似简单。少见面，多书面，接受延迟——咒语很简单。然而，我发现许多团队在采用这种方法时都遇到了困难。这有几方面的原因。</p><p></p><p>每个人都认同的协作模式才会起作用。那样才会产生“网络效应”。如果一些人以异步优先的方式工作，而其余的人以会议为中心的方式工作，你就不太可能获得你想要的好处。团队已经习惯了许多在日历上重复出现的同步做法——例如站会、私下商议、电话报告和计划。如果不仔细考虑，很难用异步过程取代这些惯常的做法，同时仍然保留其价值。协作模式的任何变革都会导致一段时间的迷惑与混乱。在此期间，团队在看到任何好处之前会首先看到生产力的下降。没有为这种生产力下降做好计划的团队可能在得到好处之前就放弃了变革。因此，任何新的工作方式想要持续下去，首先需要业务部门和团队的支持。然后，还必须一次又一次地实践，确保你在引入新的做事方式时不会失去任何价值。异步优先协作也是如此。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/70/700c73cfa1afeaa26d935dcff3ecc429.jpg\" /></p><p></p><p>工作方式的成功变革需要什么</p><p></p><p></p><h2>和你的团队一起开启“异步优先”</h2><p></p><p></p><p>假设业务部门和团队都看到了会议太多的问题，那么你应该已经从这些利益相关者那里得到了一些支持。为了对你关注的领域划分个优先级，我建议你对团队做个调查，看看他们最看重那六个好处中的哪一个。</p><p></p><p>反思团队当前协作实践的状态是为异步优先做准备的一个好方法。我建议问下面这四组问题。</p><p></p><p>你在工作过程中创建工件时有多勤奋、多仔细？例如，决策记录、提交消息、自述文件和拉取请求。在异步优先文化中，这样的工件是基础。你对自己主持的会议纪律要求有多严格？想想那些预先设定好的议程、指定的主持人、时间盒和会议记录。人们是否可以心安理得地拒绝那些他们不会增加或获得价值的会议？会议规模是否通常很小，8 人或更少？有效的会议是有效的异步优先工作方式的一个附带效果。你有多少时间可以用于深度工作？你每天想要多少时间？团队想要的时间和已经得到的时间之间有多大的差距？让一个人加入你的团队有多容易？一个人在访问了你的系统后，第一次提交需要多少时间？入职流程是对工作方式记录是否完善的一个测试。上述问题将帮助你为团队的分布式工作实践成熟度建立一条基线。它还将帮助你确定你可以有针对性的进行改进的领域，以实现向异步优先方式的转变。我建议使用一个调查工具来评估这个基线，因为那样比较简单，而且……嗯…异步！</p><p></p><p>将调查结果发布给团队，并突出显示差距，以便每个人都能清楚地了解差距在哪。这样一来，你就可以清楚地了解为什么使用异步优先，以及希望获得什么好处。</p><p></p><p></p><h2>基本转变</h2><p></p><p></p><p>根据我的经验，每个团队向异步优先工作方式的转变过程都不一样。实际上，在完成我所推荐的基线活动后，团队通常会选择不同的领域利用异步协作进行改进。我建议每个团队都做一些基本的转变。</p><p></p><p></p><h3>定义工作流程</h3><p></p><p></p><p>在工作中，我们都认可“自组织团队”和“自主权”的重要性。然而，正如 Cal Newport 在其著作《没有电子邮件的世界》中所说，知识工作是“工作执行”和“工作流程”的结合。虽然每个人对自己的工作执行都应该有自主权，但团队必须明确定义他们的工作流程，而不是让人去猜测。例如，请看下图，这是我当前所在的团队采用的双轨开发方法。它阐述了每个人的责任，以及工作如何在我们团队的系统中流转。我们还设置了团队任务板来贯彻这个工作流程。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/67/671f97a07821a82323aeca21bd285890.jpg\" /></p><p></p><p>定义工作流程，避免异步优先团队中出现混乱</p><p></p><p>当你以这种方式记录开发过程时，它会减少由于不知道谁该做什么或下一步该做什么而需要召开的会议。对于团队的新成员，它也是一份现成的参考。你不需要开会向新同事解释开发过程。一次编写，多次运行！</p><p></p><p></p><h3>把决策推到最底层</h3><p></p><p></p><p>团队做出的每一项决策往往都需要召开会议。这种协调不仅是有成本的，而且还会导致数次工作中断。这也会导致团队不愿意承担风险。首先，与团队一起定义项目上下文中不可逆决策的类别。这样的类别很少，不要为此感到惊讶。持续交付实践已经非常成熟，几乎所有的软件决策都是可逆的，除了那些具有财务、遵从性或监管影响的决策。只有这些决策需要共识式决策。其他可逆决策可以采用更轻量级的方法。</p><p></p><p>例如，每当有人想要决定某件事并希望寻求其他人的意见时，他们可以写下决策记录并邀请其它人进行评论。如果这个决策是可逆的，而且又没有什么顾虑，他们就会按照可行的建议行事。你甚至可以按照特性或能力线，将大型团队组织成两到三个人的短期小型团队，如下图所示。每个小团队都有一个直接负责人（DRI），对团队决策负责。DRI 的地位应该和团队中的其他人对等，他应该是“同侪之首”（FaE）。这种组织方式有三个明显的特点。</p><p></p><p>个体仍然可以采用异步决策技术，但当存在意见分歧时，DRI 可以发挥决定性作用；缩小了沟通范围，尤其是当你需要开会的时候。小团队对它正在构建的东西有自己的决定权。他们做出决策，然后在一个所有其他小团队都能看到的地方分享决策记录。为了促进知识共享，增加团队弹性，人员仍然可以在不同的小团队之间轮转。这样可以提高决策的自主性，同时还可以帮助团队成员熟悉整个代码库。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/fd/fdabd9e7f25b814da8885a53b5995e42.jpg\" /></p><p></p><p>将大型团队组织成小团队，缩小决策范围</p><p></p><p></p><h3>创建团队手册</h3><p></p><p></p><p>高质量的文档是异步协作的催化剂。每个软件团队都应该有一个地方来存储团队的知识和文档，包括决策记录、报告、说明书、设计文档、建议等。我称之为“团队手册”。如果你的团队已经使用了一些广泛应用的工具，则可以使用它们来实现这个目的，如 Confluence、GitLab、SharePoint、Notion、Almanac、Mediawiki 等。</p><p></p><p>花一些时间和你的团队一起规划手册的初始结构，通过组织轻量级的谷仓建造活动创建第一个版本。自此之后，团队就有了自己的手册，就像他们拥有代码库一样。随着团队需求的变化对团队手册进行改进和结构调整。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/9b/9b5f4c70631d81f1f46b2d5c66e4f1b6.jpg\" /></p><p></p><p>团队手册示例</p><p></p><p></p><h3>减少会议数量</h3><p></p><p></p><p>已经在一起工作过一段时间的团队通常会积累很多固定程序和承诺。在分布式团队中，这些承诺以会议的形式出现在团队日历上。对于团队来说，每个冲刺要预留 10 个小时的会议，这种情况很常见。为了采用异步优先，就要精简团队的会议列表，只保留必要的会议，这是有帮助的。我使用一个我称之为“ConveRel 象限”的框架来帮助团队确定哪些会议是必要的，哪些会议可以用异步沟通代替。</p><p></p><p>其框架是一个标准的 2x2 矩阵。X 轴代表沟通的性质。右边是“传达（conveyance）”，一个例子是单向信息传递。左侧是“汇聚（convergence）”，一个例子是在一个研讨会上做出一个高风险的决策。</p><p></p><p>Y 轴表示参与沟通的人之间的关系强弱。上半部分表示强关系，下半部分表示弱关系。</p><p></p><p>你可以将团队会议绘制到这个矩阵的象限中，以确定当采用异步优先时它们将如何变化。</p><p></p><p>如果你只是想把信息传达给与你关系密切的人，那就不要开会。相反，通过共享文档或维基页面，或通过发送电子邮件或消息，只要使信息可以通过网络访问即可。这事再简单不过了。大多数状态更新和报告电话都属于这个象限。如果你们的关系很弱，那么你就可能需要一些互动来建立这种关系。传递信息可以是建立友情的一种手段。当关系变强后，再用异步交互代替这些交互。如果你们的关系很弱，而你又希望在一个决定上达成一致，我建议你默认采用会议的方式。最后，如果你们的关系很牢固，并且希望在一个决定上达成一致，那么你们应该异步收集所有的输入，会议之外做能做的事情就在会议之外做，只在最后一步时才聚在一起。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/4a/4a351b56ca22c44178f6592eb69f7387.jpg\" /></p><p></p><p>ConveRel 象限</p><p></p><p>使用 ConveRel 象限进行简单的会议审计，不仅可以帮助你确定可以用异步流程替换的会议，还可以帮助你改进你选择保留的会议。</p><p></p><p>有了这些基本的转变，你就可以做一些最大的改进，从而帮助你异步开展工作。现在，你可以与团队一起评估你通过临时视频会议进行的每一项实践，并找出异步替代方案。这需要时间，所以每个开发周期都要做一两个改进，然后看看进展如何。</p><p></p><p></p><h2>小结</h2><p></p><p></p><p>异步优先协作可以帮助你的分布式团队变得更高效、更包容、更周到、更有趣。不过，这不是一夜之间可以完成的。我们中的许多人都默认采用了同步工作方式，因为它模仿了疫情前我们所处的办公室文化。据我们了解，那会让团队日历上满是会议！</p><p></p><p>如果你希望帮助你的团队更多地采用异步工作方式，那么你不仅必须获得他们的支持，还必须获得业务部门的支持，这样你才能获得变革所需的空间。作为变革过程的一部分，检查团队的协作过程，并确保找到可行的异步替代方案。这样做的目的不仅是减少中断，而且要保留同步方式给团队带来的价值。</p><p></p><p>在指导这种转变时，要注意反思。评估团队分布式工作成熟度的基线活动将帮助你标记起点。从这一点来看，受你影响所进行的每一项变革都应该有助于推动团队实现它所寻求的利益。首先与你的团队合作，记录你的工作流程，简化决策过程，创建团队手册，并进行会议审计。这些初始工作可以奠定一个不错的基础，让你可以针对每个协作过程进行其他比较小的迭代改进。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/asynchronous-collaboration-software-teams\">https://www.infoq.com/articles/asynchronous-collaboration-software-teams</a>\"</p>",
    "publish_time": "2024-01-02 09:57:40",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "构建国际化框架，Web开发让语言无阻",
    "url": "https://www.infoq.cn/article/BOyU4gzuPBfadox13A0z",
    "summary": "<p></p><h3>快速阅读</h3><p></p><p></p><p>国际化（i18n）和本地化是 Web 开发中的关键流程，能够确保软件适用于不同的语言和地区，并确保软件实际适配这些特定的需求。尽管以 JavaScript 为核心的 i18n 库（如 i18next、react-intl 和 react-i18next）是该领域的主流工具，可帮助开发人员高效地处理翻译和本地化相关的配置，但它们仅适用于基于 JavaScript 的 Web 应用。我们需要一个与语言无关的国际化框架。JSON 是一种广泛接受的格式，可用于存储翻译和本地化相关的配置，无论使用何种语言和框架，都能在各种应用程序中轻松集成和动态替换内容。内容分发网络（Content Delivery Network，CDN）可被战略性地用于高效提供本地化相关的配置文件，从而减轻加载大型配置文件潜在的弊端。构建自定义国际化框架，并将其与数据库或数据存储解决方案集成，可以实现动态和上下文感知的翻译，从而增强不同地区和语言的用户体验。</p><p></p><p>你是否已经涉足 Web 开发的汪洋大海？如果答案是肯定的，那你很快就会意识到，Web 不仅仅是为英语使用者服务的，它是面向全球的。假设法国用户看到了一条令人困惑的纯英文错误信息，在你被类似的投诉淹没之前，我们先来讨论一下什么是国际化（internationalization，通常简写为 i18n）和本地化。</p><p></p><p></p><h2>i18n 这个流行词是什么意思？</h2><p></p><p></p><p>想象一下，在这个世界上，无论每个人的母语是什么，你的软件都可以与他们流畅地交流。这就是国际化和本地化要实现的目标。虽然乍看上去没啥特别之处，但是请记住，本地化应用程序不仅仅是翻译文本。而是要根据用户的文化、地区和语言偏好提供量身定制的体验。</p><p></p><p>但是，这里有个障碍在等着你。深入了解 i18n 库的工具箱，你会发现以 JavaScript 为核心的解决方案占据了主导地位，尤其是那些围绕 React 的解决方案（如 i18next、react-intl 和 react-i18next ）。</p><p></p><p>如果跳出 JavaScript 的范畴，可选的方案就会越来越少。更糟糕的是，这些现成的工具通常都带有“一刀切”的特点，缺乏适配特定用例的能力。</p><p></p><p>不过，不必担心！如果鞋子不合适的话，为何不自己动手做呢？请继续往下阅读，我们将指导你从头开始构建一个国际化框架：一个为你的应用程序量身定制、跨语言和跨框架的解决方案。</p><p></p><p>准备好为你的应用程序签发全球通行证了吗？让我们开始这段旅程吧。</p><p></p><p></p><h2>基础的方式</h2><p></p><p></p><p>掌握国际化精髓的一个简单方法就是使用一个函数，该函数能够根据用户所在的地域获取信息。如下是一个使用 Java 编写的样例，它提供了一个基本但有效的方法：</p><p></p><p><code lang=\"null\">public class InternationalizationExample {\n\n    public static void main(String[] args) {\n        System.out.println(getWelcomeMessage(getUserLocale()));\n    }\n\n    public static String getWelcomeMessage(String locale) {\n        switch (locale) {\n            case \"en_US\":\n                return \"Hello, World!\";\n            case \"fr_FR\":\n                return \"Bonjour le Monde!\";\n            case \"es_ES\":\n                return \"Hola Mundo!\";\n            default:\n                return \"Hello, World!\";\n        }\n    }\n\n    public static String getUserLocale() {\n        // This is a placeholder method. In a real-world scenario,\n        // you'd fetch the user's locale from their settings or system configuration.\n        return \"en_US\";  // This is just an example.\n    }\n}</code></p><p></p><p>在上面的样例中，getWelcomeMessage 根据 locale 指定的语言返回欢迎信息。语言是由 getUserLocale 方法确定的。这种方法虽然非常基础，但是展示了根据用户特定的本地语言提供内容的原则。但是，随着内容的进展，我们将深入研究更先进的技术，并了解为何这种基础的方式对于大型应用程序可能无法具备可扩展性和高效率。</p><p></p><p></p><h3>优点</h3><p></p><p></p><p>覆盖面广：由于所有的翻译都嵌入在代码中，因此我们可以使用多种语言，而不必担心外部依赖或缺失翻译。无网络调用：翻译直接从代码中获取，无需任何网络开销或从外部源获取翻译相关的延迟。便利的代码搜索：由于所有的翻译都是源码的一部分，因此搜索特定翻译或排查相关的问题变得很简单易行。可读性：开发人员可以立即理解选择特定翻译背后的流程和逻辑，从而简化调试和维护。减少外部依赖：无需依赖外部翻译服务或数据库，这意味着应用程序中少了一个故障点。</p><p></p><p></p><h3>缺点：</h3><p></p><p></p><p>更新操作需要发布新的版本：在移动应用或独立应用的场景中，添加新语言或调整现有的翻译需要用户下载并更新最新版本的应用。冗余代码：随着要支持语言数量的增加，switch 和条件语句也会相应地增加，从而导致代码的重复和臃肿。合并冲突：由于多个开发人员可能会对各种语言进行添加或修改，所以版本控制系统中出现合并冲突的风险会随之增加。代码维护所面临的挑战：随着时间的推移，应用程序会进行扩展并支持更多的本地语言，直接在代码中管理和更新翻译会变得繁琐且容易出错。灵活性有限：采用这种静态的方式很难添加像复数形式、特定上下文的翻译或动态获取翻译等特性。性能开销：对于大规模应用而言，加载大块的翻译数据却仅使用其中很小的一部分会导致资源紧张，造成效率低下。</p><p></p><p></p><h2>基于配置的国际化</h2><p></p><p></p><p>在前一种方法的基础之上，我们努力保留其优点，同时解决其缺点。为了实现这一点，我们将代码库中的硬编码字符串值过渡到基于配置的设置。我们会为每种本地语言使用单独的配置文件，并以 JSON 格式进行编码。这种模块化方式简化了翻译的添加和修改，无需进行代码的变更。</p><p></p><p>如下是英语和西班牙语本地语言的配置文件：</p><p></p><p>文件名：en.json</p><p></p><p><code lang=\"null\">{    \"welcome_message\": \"Hello, World\"}\n</code></p><p></p><p>文件名：es.json</p><p></p><p><code lang=\"null\">{    \"welcome_message\": \"Hola, Mundo\"}\n</code></p><p></p><p></p><h3>Java 中的实现：</h3><p></p><p></p><p>首先，我们需要一种读取 JSON 文件的方式。这通常会使用像 Jackson 或 GSON 这样的库。在本例中，我们将使用 Jackson。</p><p></p><p><code lang=\"null\">import com.fasterxml.jackson.databind.ObjectMapper;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class Internationalization {\n\n    private static final String CONFIG_PATH = \"/path_to_configs/\";\n    private Map translations;\n\n    public Internationalization(String locale) throws IOException {\n        ObjectMapper mapper = new ObjectMapper();\n        translations = mapper.readValue(new File(CONFIG_PATH + locale + \".json\"), Map.class);\n    }\n\n    public String getTranslation(String key) {\n        return translations.getOrDefault(key, \"Key not found!\");\n    }\n}\n\npublic static class Program {\n\n    public static void main(String[] args) throws IOException {\n        Internationalization i18n = new Internationalization(getUserLocale());\n        System.out.println(i18n.getTranslation(\"welcome_message\"));\n    }\n\n    private static String getUserLocale() {\n        // This method should be implemented to fetch the user's locale.\n        // For now, let's just return \"en\" for simplicity.\n        return \"en\";\n    }\n}</code></p><p></p><p>Internationalization 类在实例化的时候，会根据提供的本地语言读取上述代码中相关的 JSON 配置。getTranslation 方法使用标识符获取所需的翻译字符串。</p><p></p><p></p><h3>优点：</h3><p></p><p></p><p>保留了上述方式的所有优点：覆盖面广，加载后无需使用网络就能进行翻译，代码易于搜索和阅读。动态加载：可根据用户的本地语言动态加载翻译。只需加载必要的翻译，从而带来潜在的性能优势。可扩展性：添加新语言更容易。只需为该语言添加一个新的配置文件，应用程序就能处理它，无需任何代码修改。更整洁的代码：逻辑与翻译分离，代码更简洁、更易维护。中心化的管理：所有的翻译都集中在一个文件中，因此更易于管理、审查和更新。这种方法提供了一种更可扩展、更简洁的国际化处理方式，尤其适用于大型应用程序。</p><p></p><h3>缺点：</h3><p></p><p></p><p>可能会导致配置文件过大：随着应用程序的增长和对多种语言的支持，这些配置文件可能会变得相当大。这可能会导致应用程序的初始加载出现滞后，尤其是在配置文件需要前期加载的情况中。</p><p></p><p></p><h2>从 CDN 抓取配置</h2><p></p><p></p><p>缓解可能出现大型配置文件的一种方法是将其托管到内容分发网络（Content Delivery Network，CDN）上。通过这种方式，应用程序可以根据用户的本地语言只加载必要的配置文件。这样既能保证应用程序的运行速度，又能减少用户不必要下载的数据量。当用户切换本地语言或探测到不同的本地语言时，可以根据需要从 CDN 获取配置。这为大规模应用程序提供了速度和灵活性之间的最佳平衡。为了简单起见，我们考虑使用基础的 HTTP 库来获取配置文件。在这个 Java 样例中，我们将使用虚构的 HttpUtil 库：</p><p></p><p><code lang=\"null\">import java.util.Map;\nimport org.json.JSONObject;\n\npublic class InternationalizationService {\n\n    private static final String CDN_BASE_URL = \"https://cdn.example.com/locales/\";\n\n    public String getTranslatedString(String key) {\n        String locale = getUserLocale();\n        String configContent = fetchConfigFromCDN(locale);\n        JSONObject configJson = new JSONObject(configContent);\n        return configJson.optString(key, \"Translation not found\");\n    }\n\n    private String fetchConfigFromCDN(String locale) {\n        String url = CDN_BASE_URL + locale + \".json\";\n        return HttpUtil.get(url);  // Assuming this method fetches content from a given URL\n    }\n\n    private String getUserLocale() {\n        // Implement method to get the user's locale\n        // This can be fetched from user preferences, system settings, etc.\n        return \"en\";  // Defaulting to English for this example\n    }\n}</code></p><p></p><p>注意：上述代码只是一个简化的样例，在实际的场景中可能需要错误处理、缓存机制和其他优化。</p><p></p><p>这里的想法是根据用户的本地语言直接从 CDN 获取必要的配置文件。用户的本地语言决定了配置文件的 URL，获取到之后，就会对配置文件进行解析，以获得所需的翻译。如果找不到相应地键，就会返回默认信息。这种方法的好处是，应用程序只需加载必要的翻译，从而确保了最佳性能。</p><p></p><p></p><h3>优点</h3><p></p><p></p><p>继承了前一种方法的所有优势。易于为新的本地语言组织和添加翻译。只需获取必要的翻译，因此加载效率高。</p><p></p><p></p><h3>缺点：</h3><p></p><p></p><p>配置文件体积庞大，可能会降低应用程序的初始化速度。字符串必须是静态的。无法直接支持动态字符串或需要运行时计算的字符串。如果需要在翻译中插入动态数据，这可能是一个限制。依赖外部服务（CDN）。如果 CDN 遇到故障或出现问题，应用程序将无法获取翻译内容。</p><p></p><p>但是，要解决这些缺点，我们可以采取如下措施：第一个缺点可以通过在 CDN 上存储配置文件并在需要时加载来缓解。第二个缺点可以通过在静态字符串中使用占位符并在运行时根据上下文替换来解决。第三个缺点则需要一个健壮的错误处理机制和一些潜在的后备策略。</p><p></p><p></p><p></p><h2>动态字符串处理</h2><p></p><p></p><p>如果要翻译的字符串有一部分内容是动态的，那么就需要一种更灵活的解决方案。以 Facebook 为例，在 News Feed 中，我们会看到这里使用了自定义的字符串来表示每篇文章的“Likes”信息。比如，如果文章只有一个“Likes”信息，那么你可能会看到“John likes your post.”。如果有两个“Likes”信息，那么你可能会看到“John and David like your post.”。如果有两个以上的“Likes”信息，你可能会看到“John, David and 100 others like your post.”。在这种情况下，需要进行一些自定义。动词“like”和“likes”是根据喜欢文章的人数来确定的。如何做到这一点呢？</p><p></p><p>考虑如下的样例：“John, David and 100 other people recently reacted to your post.”，在这里“David”、“John”、“100”、“people”和“reacted”都是动态元素。</p><p></p><p>我们来分析一下：</p><p></p><p>“David”和“John”可以是从与用户相关的方法或数据库中获取的用户名。“100”可以是从与文章相关的方法或数据库中获取的对文章做出反应的总人数，其中不包括 David 和 John。当代指一个集体时，“people”可以是名词“人”的复数形式。“reacted”可用于用户以爱心、关注或愤怒等图标对文章做出反应，而不能是表示喜欢的图标。</p><p></p><p>实现此类动态内容的一种方法是在配置文件中使用占位符，并在运行时根据上下文替换它们。</p><p></p><p>如下是一个 Java 样例：</p><p></p><p>配置文件（适用于英语）</p><p></p><p><code lang=\"null\">{\n      oneUserAction: {0} {1} your post,\n      twoUserAction: {0} and {1} {2} your post,\n      multiUserAction: {0}, {1} and {2} other {3} recently {4} to your post,\n      people: people,\n      likeSingular: likes,\n      likePlural: like,\n}</code></p><p></p><p>配置文件（适用于法语）：</p><p></p><p><code lang=\"null\">{\n      oneUserAction: {0} {1} votre publication,\n      twoUserAction: {0} et {1} {2} votre publication,\n      multiUserAction: {0}, {1} et {2} autres {3} ont récemment {4} à votre publication,\n      people: personnes,\n      likeSingular: aime,\n      likePlural: aiment,\n}</code></p><p></p><p>Java 实现：</p><p></p><p><code lang=\"null\">import java.util.Locale;\nimport java.util.ResourceBundle;\n\npublic class InternationalizationExample {\n\n    public static void main(String[] args) {\n        // Examples\n        System.out.println(createMessage(\"David\", null, 1, new Locale(\"en\", \"US\"))); // One user\n        System.out.println(createMessage(\"David\", \"John\", 2, new Locale(\"en\", \"US\"))); // Two users\n        System.out.println(createMessage(\"David\", \"John\", 100, new Locale(\"en\", \"US\"))); // Multiple users\n\n        // French examples\n        System.out.println(createMessage(\"David\", null, 1, new Locale(\"fr\", \"FR\"))); // One user\n        System.out.println(createMessage(\"David\", \"John\", 2, new Locale(\"fr\", \"FR\"))); // Two users\n        System.out.println(createMessage(\"David\", \"John\", 100, new Locale(\"fr\", \"FR\"))); // Multiple users\n    }\n\n    private static String createMessage(String user1, String user2, int count, Locale locale) {\n        // Load the appropriate resource bundle\n        ResourceBundle messages = ResourceBundle.getBundle(\"MessagesBundle\", locale);    \n\n        if (count == 0) {\n            return \"\"; // No likes received\n        } else if (count == 1) {\n            return String.format(\n                  messages.getString(\"oneUserAction\"),\n                  user1,\n                  messages.getString(\"likeSingular\")\n            ); // For one like, returns \"David likes your post\"\n        } else if (count == 2) {\n            return String.format(\n                  messages.getString(\"twoUserAction\"),\n                  user1,\n                  user2,\n                  messages.getString(\"likePlural\")\n            ); // For two likes, returns \"David and John like your post\"\n        } else {\n            return String.format(\n                  messages.getString(\"multiUserAction\"),\n                  user1,\n                  user2,\n                  count,\n                  messages.getString(\"people\"),\n                  messages.getString(\"likePlural\")\n                  ); // For more than two likes, returns \"David, John and 100 other people like your post\"\n        }\n    }\n}</code></p><p></p><p></p><h2>结论</h2><p></p><p></p><p>无论规模大小，开发有效的国际化（i18n）和本地化（l10n）框架对于软件应用都至关重要。这种方法可以确保你的应用能够与用户的母语和文化背景产生共鸣。虽然字符串翻译是 i18n 和 l10n 的一个重要组成部分，但它只是软件全球化这一更广泛挑战的一个方面而已。</p><p></p><p>有效的本地化不仅仅是翻译，还要解决其他的关键问题，例如书写方向，阿拉伯语等语言的书写方向（从右到左）和文本长度或大小各不相同，泰米尔语等语言的文字可能比英语更长。通过精心定制这些策略来满足特定的本地化需求，你就可以为软件提供真正全球化的、适用于不同文化的用户体验。</p><p></p><p></p><h5>原文链接：</h5><p></p><p></p><p><a href=\"https://www.infoq.com/articles/internationalization-framework/\">https://www.infoq.com/articles/internationalization-framework/</a>\"</p><p></p><h5>相关阅读：</h5><p></p><p></p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5ODIzNDQ3Mw%3D%3D&amp;chksm=beca256b89bdac7d4234c85f248d75aace542c31322afcd2181035933b448fb7e52a9115a80d&amp;idx=1&amp;mid=2649970029&amp;scene=27&amp;sn=dd41f58ff643b44d9284f20eb6fe5e8d&amp;utm_campaign=geek_search&amp;utm_content=geek_search&amp;utm_medium=geek_search&amp;utm_source=geek_search&amp;utm_term=geek_search#wechat_redirect\">你可以错过&nbsp;Web3，但不要错过&nbsp;Web5</a>\"</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5ODIzNDQ3Mw%3D%3D&amp;chksm=beca257f89bdac69029d839f0cdc2eea79bfde2f6acdf293d2925bd2dd79a88dfe95da36a637&amp;idx=1&amp;mid=2649970041&amp;scene=27&amp;sn=d365251428eb72019a23f528dc78b94e&amp;utm_campaign=geek_search&amp;utm_content=geek_search&amp;utm_medium=geek_search&amp;utm_source=geek_search&amp;utm_term=geek_search#wechat_redirect\">别人不会告诉你的&nbsp;Web3 未来</a>\"</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5ODIzNDQ3Mw==&amp;mid=2649969927&amp;idx=1&amp;sn=cc8a7cee992d36202d86ee5068fcc66e&amp;chksm=beca250189bdac17511f9649f03ab3b0c6fee72a33cb1957ff5a6017924fe10b7c7d5581eb98&amp;scene=27#wechat_redirect\">Web3当下，最佳投资就是投资自己</a>\"</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5ODIzNDQ3Mw==&amp;mid=2649969873&amp;idx=1&amp;sn=8cc0a44a1ab3255ea5973d41520a4c39&amp;chksm=beca24d789bdadc1f9085e3853dffff525aaa28a09a46c50169585b66650a1ac26ae67db9b57&amp;scene=27#wechat_redirect\">Web3的反思，不要抱怨</a>\"</p>",
    "publish_time": "2024-01-02 10:10:19",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "React正在杀死Angular吗？",
    "url": "https://www.infoq.cn/article/PdymzksX2dxHgwC59qFU",
    "summary": "<p>这是一个老生常谈的争论（在技术时代，这是在所难免的）：Angular 对战 React。这就像“先有鸡还是先有蛋”的难题，不过这个问题是针对 Web 开发人员的。在过去的几年间，如果你曾经出现在开发人员的咖啡机旁或者参加过技术论坛，那么你可能会听到关于哪个框架才是霸主的窃窃私语、争论，甚至是偶尔出现的键盘对决。</p><p></p><p>现在，我们明确一下对战的双方。一边是经验丰富的战士 Angular。它经历过风雨，见证了潮流的起起落落，并拥有炫酷的特性。而另一边则是 React，它是年轻的神童。它来到这个世界，惊艳了所有人。随着它的迅速走红，有人开始怀疑 React 是否就是那个让老将 Angular 望尘莫及的后起之秀。有传言说，React 花哨的行为正在侵蚀 Angular 稳扎稳打的基石。</p><p></p><p>但是，对于 Angular 来说，React 真的是歌利亚的大卫吗（按照传说，歌利亚是身材巨大，拥有无穷力量的巨人，最后牧童大卫用投石弹弓打中歌利亚的脑袋，并将其杀死，日后这个牧童成为了著名的大卫王——译者注）？或者这只是一个技术神话，就像“重启能够解决 99% 的 IT 问题一样”？（好吧，这个说法也许就是真的）请继续关注我们对这场争论的深入探讨，一起揭开炒作背后的真相！</p><p></p><p></p><h2>简史</h2><p></p><p></p><p></p><h3>Angular：从默默无闻到技术王者</h3><p></p><p></p><p>我们将时光拨回到 2010 年，当时，jQuery 是最酷的东西，世界各地的开发人员都在与臭名昭著的意大利面条式代码抗争。就像超级英雄突然从阴影中现身一样，谷歌为我们引入了 AngularJS。AngularJS 拥有双向数据绑定和依赖注入等有趣的功能，许多开发人员自己都没有意识到这就是他们需要的英雄。将时间快进一些，AngularJS 长大了，也去掉了“JS”，变成了威严的“Angular”。就像我们最喜欢的电影系列一样，它会不断推出续集（也就是技术术语中的版本），让我们目不暇接！</p><p></p><p></p><h3>React：酷炫的新浪潮</h3><p></p><p></p><p>现在，我们把时间推移到 2013 年。就在 Angular 掀起热潮的时候，一个新的玩家进入了这个领域。从 Facebook 天才实验室直接走出来的 React 突然登上了舞台。但 React 并不是普通的初出茅庐者，它就像一个新生，第一天就在才艺表演上让所有人惊叹不已。凭借其创新性的虚拟 DOM 和基于组件架构的全新用户界面，React 很快成为整个领域的焦点。它简单易用的特性和灵活性使其备受青睐，很快就从新生儿变成了舞会之王！</p><p></p><p></p><h2>React 的优势</h2><p></p><p></p><p></p><h3>基于组件的架构</h3><p></p><p></p><p>还记得小时候玩过的乐高积木吗？只要把五颜六色的积木拼接在一起，你就能搭建出任何东西，从城堡到宇宙飞船。React 基于组件的架构就像是 Web 开发中的乐高积木。它允许开发人员将 UI 分解成可重用的组件，使得构建和维护复杂的应用程序就像是玩儿心爱的积木一样有趣和简单。最棒的一点是什么呢？那就是如果你需要更换一个组件，你不必拆除整个城堡。</p><p></p><p></p><h3>虚拟 DOM</h3><p></p><p></p><p>在 Web 开发领域，速度是最重要的。React 的虚拟 DOM 就像是这个领域的超级英雄。React 不会更新整个页面，而是聪明地只更新发生变化的部分，因此它的速度非常快。这就好比你有一个私人助理，他知道你把钥匙落到了什么地方，这样你就不用把整个房子翻个底朝天了。</p><p></p><p></p><h3>灵活性</h3><p></p><p></p><p>React 就像是一把方便的瑞士军刀，你希望每次露营都带上它。如果你需要与不同的库集成？React 会助你一臂之力。无论你是将它与 Redux 搭配进行状态管理，还是与 Axios 搭配进行 HTTP 请求，React 都能很好地与其他库配合，确保你具备探险所需的所有工具。</p><p></p><p></p><h3>强大的社区支持</h3><p></p><p></p><p>每个优秀的工具背后都有一个更强大的社区。React 也不例外。React 社区拥有一支由开发者、爱好者和向导组成的大军，这可以说是一座金矿。从教程到第三方库，如果你有问题，很可能早就已经有人回答过了。这就像拥有一个全天候的技术支持团队，不过这要比它酷得多。</p><p></p><p></p><h2>Angular 的优势</h2><p></p><p></p><p></p><h3>综合的框架</h3><p></p><p></p><p>想象一下，如果你入住一个度假胜地，从 SPA 中心到美食餐厅，一切都触手可及。这就是 Angular，它不仅仅是一个框架，还是一个完整的生态系统，具备大量可开箱即用的工具。无需寻找任何第三方库，Angular 为你提供了开发过程中可能需要的一切。</p><p></p><p></p><h3>双向数据绑定</h3><p></p><p></p><p>还记得在童话故事里那些能够同时显示现在和未来的魔镜吗？Angular 的双向数据绑定与之颇有几分神似。它在模板（视图）和组件（模型）之间搭起了一座桥梁，确保其中的任何一项发生变化都能反映到另外一项中。这就像有一个私人神仙教母，能够确保你的舞会礼服（在本例中，也就是用户界面）始终保持完好无损。</p><p></p><p></p><h3>依赖注入</h3><p></p><p></p><p>你可以将 Angular 的依赖注入视为代码中的近藤麻理惠（《怦然心动的人生整理魔法》一书的作者，以整理家庭内务而著名——译者注）。它能确保每段代码都处在自己恰当的位置上，从而增强模块化和可重新性。有了 Angular 的依赖注入，组件就能轻松获取它们所需的服务，让你的代码库变得整洁且令人愉悦。</p><p></p><p></p><h3>TypeScript</h3><p></p><p></p><p>我们都有一个对语法很挑剔的朋友，对吧？对于 Angular 来说，TypeScript 就是这位朋友。通过提供强类型，TypeScript 可以确保你在编译时就能捕获到那些讨厌的错误，而不是在用户试图查看购物车的时候。这就像为你的代码配备了一个内置校对员，确保一切都处于最佳状态。</p><p></p><p></p><h3>Angular CLI</h3><p></p><p></p><p>如果你曾经希望有一根魔法棒可以简化你的开发过程，那就来看看 Angular CLI 吧。借助其强大的命令，你可以创建项目、添加特性，甚至只需挥挥手（或者更确切地说，一个简单的命令）就能运行测试。这就像在终端里有一个精灵，随时准备实现你的开发愿望。</p><p></p><p></p><h2>React 和 Angular 的主要区别</h2><p></p><p></p><p></p><h3>理念</h3><p></p><p></p><p>就其本质而言，React 就像一位信奉极简主义的朋友。他只有五件衣服，但是每件衣服的搭配都非常漂亮。它是一个库，只关注视图层，在项目的其他方面，允许你去自由探险。</p><p></p><p>而 Angular 则像是一位拥有复式衣帽间和各种小玩意儿的朋友。它是一个完整的框架，提供了开箱即用的路由、状态管理、HTTP 客户端等解决方案。它包罗万象，能够为你带来连贯的开发体验。</p><p></p><p></p><h3>学习曲线</h3><p></p><p></p><p>React 因其简单易用而受到广泛称赞。它采用了基于组件的方式，就像在初学者赛道上练习滑雪，因此深受希望涉足 web 开发的初学者的喜爱。</p><p></p><p>Angular 的综合性更像是挑战顶级难度的滑雪道。一开始，它可能令人望而生畏，尤其是其独特的术语和理念，但是一旦你掌握了窍门，你就能像专业人士那样应对 web 开发的挑战了。</p><p></p><p></p><h3>社区和生态系统</h3><p></p><p></p><p>随着 React 的广泛采用，它成为了一个热闹的社区，就像乡村中的集市那样。每个需求都有一个摊位，无论是使用 Redux 进行状态管理，还是使用 React-Router 进行路由选择。社区充满了活力，拥有大量的资源、插件和第三方库。</p><p></p><p>有谷歌强大支持的 Angular 则像一个盛大的狂欢节。它拥有庞大的官方库、丰富的工具和经受了考验的社区，为成熟而广阔的生态系统做出了贡献。</p><p></p><p></p><h3>性能</h3><p></p><p></p><p>在性能方面，React 和 Angular 就像精英速滑运动员，各有千秋。React 采用虚拟 DOM，确保了高效更新，使其能够快速高效。而 Angular 则通过预先编译（AOT）和变更探测，确保始终能够领先一步，提供一流的性能。</p><p></p><p></p><h2>真实现状：采用趋势</h2><p></p><p></p><p></p><h3>React 与 Angular 的采用数据对比</h3><p></p><p></p><p>首先，我们看一下统计数据。虽然受欢迎程度并不代表一切 (只要问问流量电影的主角就知道了)，但它确实能够让我们了解开发者领域的趋势。</p><p></p><p>React：自诞生以来，React 便迅速崛起。在 npm 上每周有数百万的下载量，很明显这个库已经打动了全世界的开发者。这不仅仅是数量的问题，用 React 构建的项目和应用程序的质量也令人印象深刻。Angular：Angular 在受欢迎程度方面也不逊色，一直保持着自己的地位。凭借稳定的下载量和庞大的社区，Angular 的综合性显然引起了许多人的共鸣。它就像一个可靠的朋友，当你需要搬家时，尽可以打电话给他，它可能并不新颖夺目，但它能完成任务。</p><p></p><p></p><h3>大联盟：知名代言人</h3><p></p><p></p><p>现在，我们来谈谈代言人。就像运动员有自己的赞助商一样，框架和库也有自己的知名用户。在这个领域，React 和 Angular 都有一些重量级的用户。</p><p></p><p>React：从社交媒体巨头 Facebook（毕竟是他们创造了 React）到流媒体巨头 Netflix，许多科技大公司都因 React 的灵活性和性能而采用了它。不仅是科技界，各行各业的公司，无论是酒店业的 Airbnb 还是媒体业的《纽约时报》，都搭上了 React 的列车。Angular：Angular 背后的策划者谷歌在其多个平台上都使用了 Angular，这充分说明了 Angular 的可靠性。但它的粉丝俱乐部并不止于此。像福布斯、宝马，甚至美国国家航空航天局（NASA，没错，就是太空人！）等公司都在其数字领域中使用了 Angular。</p><p></p><p></p><h2>影响选择 React 和 Angular 的因素</h2><p></p><p></p><p>这是一个古老的难题，到底是该选择 React 还是 Angular？这就像在巧克力和香草、海滩度假和登山度假之间做出选择一样。两者各有其长处，但最佳选择往往取决于具体的情况。让我们来分析一下哪些因素可能会促使我们倾向于选择其中的某一个。</p><p></p><p></p><h3>项目需求</h3><p></p><p></p><p>React：我们可以把 React 想象成时髦的定制西装。它非常适合需要特定功能而不需要额外装饰的项目。基于组件的特性使其支持高度定制，因此非常适合需要量身定制的独特项目。Angular：而 Angular 就像一套成衣。它配备了你所需要的一切。对于需要内置功能的综合解决方案的项目，Angular 可能是你的首选。</p><p></p><h3>团队专长</h3><p></p><p></p><p>团队的专业知识会在很大程度上影响你的选择。如果你的团队精通 React 并已使用多年，那么坚持使用自己熟悉的产品可能会更有合理。反之，如果你的团队中有 Angular 专家，又何必冒险进入陌生的领域呢？</p><p></p><p></p><h3>长期维护</h3><p></p><p></p><p>在可维护性方面来看，React 和 Angular 都有各自的特点。请考虑项目的长期目标。你需要易于扩展的产品吗？是否需要定期更新？React 的库方式提供了灵活性，而 Angular 包罗万象的特性可能会简化更新和扩展。</p><p></p><p></p><h2>总结</h2><p></p><p></p><p>在结束这次启蒙之旅的时候，让我们来澄清一下。React 并没有“杀死”Angular，而 Angular 也没有将 React 推向被遗忘的境地。它们就像两位才华横溢的艺术家，各有其风格和天赋。</p><p></p><p>在 React 和 Angular 之间做出选择，并不是要追赶最新的潮流或选择“哪一个更好”。而是了解自己的需求，评估自己的资源，然后做出明智的决定。毕竟，最好的工具是能完成工作的工具，而不是炒作最多的工具。</p><p></p><p></p><h5>原文链接：</h5><p></p><p></p><p><a href=\"https://blog.stackademic.com/is-react-killing-angular-the-truth-behind-the-hype-6294e2cf6688\">https://blog.stackademic.com/is-react-killing-angular-the-truth-behind-the-hype-6294e2cf6688</a>\"</p><p></p><h5>相关阅读：</h5><p></p><p></p><p><a href=\"https://www.infoq.cn/article/Tv3SyqoivXMWUoj8qSMT\">从新&nbsp;React&nbsp;文档看未来 Web 的开发趋势</a>\"</p><p><a href=\"https://www.infoq.cn/article/CZKMjHaxbf1Z7xcSzisX\">我被&nbsp;React&nbsp;劫持了，很痛苦又离不开</a>\"</p><p><a href=\"https://xie.infoq.cn/article/7baec545b8202471064494a69\">2023 重学 Angular</a>\"</p><p><a href=\"https://www.infoq.cn/article/oONc5r5opJF64kBCtzIv\">Angular v15 发布：可以脱离 NgModules 构建组件了</a>\"</p>",
    "publish_time": "2024-01-02 10:56:09",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]