[
  {
    "title": "黄剑龙：汽车行业趋势下的人才挑战 ｜ DTDS 8 月",
    "url": "https://www.infoq.cn/article/TWoXV48fu73etZKLyuiP",
    "summary": "<p>在工业和信息化部人才交流中心和中国移动通信联合会教育与考试中心的大力支持与指导下，由极客时间企业版、培训杂志共同举办，甫瀚咨询联合举办的 DTDS 全球数字人才发展线上峰会于 8 月 9 日拉开帷幕。</p>\n<p>经过多年在企业数字人才发展领域的耕耘，极客时间于 2022 年发布了数字人才粮仓模型，深入定义了五层数字人才，收获了来自各行各业的企业客户的认可。我们也看到许多企业都在加大对数字人才的培养，并且希望向行业标杆学习，完善自己的数字人才培养体系，融入数字人才标准和生态。</p>\n<p>为此，DTDS 峰会汇聚了来自政府和产业的权威，以及金融、汽车、制造、ICT、零售、互联网、风控审计企业的数字化先锋人物，旨在建立数字人才培养“朋友圈”，让大家从多维视角了解企业数字化转型，人才发展，和组织变革的先进经验。</p>",
    "publish_time": "2022-09-06 00:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "微软发布Dev Box公开预览版：面向开发人员的云端工作站",
    "url": "https://www.infoq.cn/article/osfct6YzPXLPxKgX1Bc5",
    "summary": "<p><a href=\"https://www.infoq.cn/topic/Azure\">Azure</a>\"最近发布了<a href=\"https://azure.microsoft.com/en-us/blog/announcing-microsoft-dev-box-preview/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjI0MjU1NzQsImZpbGVHVUlEIjoiVnozZkhSeG1rZ1kwcHN0UyIsImlhdCI6MTY2MjQyNTI3NCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.ryWH_EdDsnhQV3HxSaqcGPbgJgHGAh0LxXl2NrziETs\">Microsoft Dev Box公开预览版</a>\"，这是一款面向开发人员的云端工作站。这项新服务与Windows 365集成，支持任意的开发者IDE、SDK或运行在Windows上的工具，并简化了新开发者的上手过程。</p><p></p><p>Microsoft Dev Box在5月份的<a href=\"https://www.infoq.cn/topic/Microsoft\">微软</a>\"开发者大会上发布了<a href=\"https://www.infoq.com/news/2022/05/introducing-microsoft-dev-box/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjI0MjU1NzQsImZpbGVHVUlEIjoiVnozZkhSeG1rZ1kwcHN0UyIsImlhdCI6MTY2MjQyNTI3NCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.ryWH_EdDsnhQV3HxSaqcGPbgJgHGAh0LxXl2NrziETs\">私有预览版</a>\"，是一项Azure服务，可为任意规模的团队提供安全的按需使用工作站。Visual Studio Core首席团队PM Anthony Cangialosi解释说：</p><p></p><p></p><blockquote>在使用Microsoft Dev Box时，开发人员可以专注于编写他们能够编写的代码，而不是花时间搭建一个可以构建和运行代码的工作环境。Dev Box为编码做好了准备，并为开发人员预先配置了他们要完成项目和任务所需的所有工具。</blockquote><p></p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/news/2022/08/microsoft-dev-box/en/resources/170146287-bcf2-4161-a82b-080798e18fce-1660972566419.png\" /></p><p></p><p>图片来源：<a href=\"https://azure.microsoft.com/en-us/blog/announcing-microsoft-dev-box-preview/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjI0MjU1NzQsImZpbGVHVUlEIjoiVnozZkhSeG1rZ1kwcHN0UyIsImlhdCI6MTY2MjQyNTI3NCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.ryWH_EdDsnhQV3HxSaqcGPbgJgHGAh0LxXl2NrziETs\">https://azure.microsoft.com/en-us/blog/announcing-microsoft-dev-box-preview/</a>\"</p><p></p><p>Sopra Steria云技术布道师Marius Sandbu写了一篇关于如何使用Microsoft Dev Box的文章。他解释说：</p><p></p><p></p><blockquote>从操作的角度来看，它结合了Windows 365前端门户（开发人员可以访问虚拟机的自助前端）和Azure虚拟桌面的RDS组件，这意味着它在底层运行着很多相同的核心组件。</blockquote><p></p><p></p><p>微软高级程序经理、Babylon.js的联合作者David Rousset在推特上写道：</p><p></p><p></p><blockquote>Microsoft Dev Box对团队新加入者的上手真的有很大帮助。</blockquote><p></p><p></p><p>新服务与Windows 365和Azure虚拟桌面共享许多特性，旨在为开发者在Azure中提供VDI桌面。根据微软的说法，新服务支持任何IDE、SDK或运行在Windows上的工具，开发者可以用它来构建桌面、移动、物联网和Web应用程序。它支持使用Windows子系统（Linux）和Windows子系统（Android）构建跨平台应用程序。Sandbu总结道：</p><p></p><p></p><blockquote>到目前为止，作为预览版，它似乎已经相当可靠。我喜欢他们设计产品的方式，然而我想自己定义计算SKU，而不是被微软已定义的资源绑定，所以这意味着我被绑定到微软在Dev Box中定义的特性。GitHub CodeSpaces也应该是其中的一部分，或者至少作为一个替代特性。</blockquote><p></p><p></p><p>工作站的休眠功能目前还不能使用，但应该会在未来几周的预览版中添加。Microsoft Dev Box预览版在Azure Portal中可用，提供了一个基于消耗的计算和存储定价模型。在公开预览期间，Dev Box 8vCPU和32 GB内存SKU每个月的前15个小时是免费的。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2022/08/microsoft-dev-box/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjI0MjU1NzQsImZpbGVHVUlEIjoiVnozZkhSeG1rZ1kwcHN0UyIsImlhdCI6MTY2MjQyNTI3NCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.ryWH_EdDsnhQV3HxSaqcGPbgJgHGAh0LxXl2NrziETs\">Microsoft Dev Box Now in Public Preview</a>\"</p>",
    "publish_time": "2022-09-06 08:56:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "删掉编程中的 Switch 语句",
    "url": "https://www.infoq.cn/article/59sGhvVrEr70MYiAsdQO",
    "summary": "<p>多重方法是一种有趣的方式，可以帮你摆脱令人讨厌的switch。而且，这也有助于提升代码的可读性。所以，在决定继续坚持使用switch之前，一定要先试一试。</p><p>&nbsp;</p><p>本文最初发布于Bits and Pieces。</p><p></p><p>很多开发者都讨厌switch语句，包括我。并不是因为这个语句没用，也不是因为它太难了。</p><p>&nbsp;</p><p>理解switch语句的工作原理非常简单，问题是当你真的遇到它时，就必须停下手头的一切工作，集中精力阅读它，以确保不会遗漏任何东西，比如，缺少break语句可能会导致一些意想不到的行为，或者一个case中大约有20行代码。</p><p>&nbsp;</p><p>关键是，原谅我使用一个花哨的术语：理解switch语句（在现实世界中）所需要的认知负荷相当重。我相信，作为开发人员，我们的目标是编写方便人类阅读的代码。在这方面，这个语句提供不了什么帮助。</p><p>&nbsp;</p><p>但是，我写这篇文章不是为了对它进行抨击，我是要向你（<a href=\"https://betterprogramming.pub/stop-using-switch-in-typescript-3-alternatives-to-use-instead-aef014c9b31d\">之前也包括我</a>\"）展示三个关于如何避免使用switch语句的示例，让我们来看一种函数式编程技术：多重方法。</p><p>&nbsp;</p><p></p><h1>什么是多重方法？</h1><p></p><p>&nbsp;</p><p>我第一次听到这个词，还是在播客“<a href=\"https://podcast.20minjs.com/\">20 MinJS</a>\"”中采访Yehonathan Sharvit时。当时的采访是关于他即将由Manning出版的著作《<a href=\"https://www.manning.com/books/data-oriented-programming\">面向数据的编程</a>\"》。</p><p>&nbsp;</p><p>他提出这一概念是为了从功能上取代继承，这无疑是可行的。在这个过程中，他展示了switch语句是如何被取代的。因此，让我们暂时把OOP放在一边，只关注第二部分：消除代码中丑陋的switch。</p><p></p><p>什么是多重方法？它只是一个能够根据接收到的参数选择最佳实现的函数。换句话说，想象一下，如果你把丑陋的switch语句放在函数中，然后对所有人隐藏实现。</p><p>&nbsp;</p><p>唯一的区别是，你的解决方案只适用于一个函数。今天我们将讨论如何在运行中生成多个多重方法。</p><p>&nbsp;</p><p></p><h2>多重方法是什么样子？</h2><p></p><p>&nbsp;</p><p>当然，每种语言都有自己的变体，但我今天主要讲JavaScript。</p><p>&nbsp;</p><p>在这种语言中，多重方法的使用方法如下：</p><p></p><p><code lang=\"text\">//我们将使用的数据\nconst myDog = {\n    type: \"dog\",\n    name:\"Robert\"\n}\nconst myCat = {\n    type: \"cat\",\n    name: \"Steffan\"\n}\n//自定义函数实现\nfunction greetDogs (dog) {\n    console.log(\"Hello dear Dog, how are you today\", dog.name, \"?\")\n}\nfunction greetCats(cat) {\n    console.log(\"What's up\", cat.name, \"?\")\n}\n//定义我们的多重方法\nlet greeter = null\ngreeter = multi(\n    animal =&gt; animal.type,\n    method(\"dog\", greetDogs),\n    method(\"cat\", greetCats)\n)(greeter)\n// 调用多重方法\ngreeter(myDog)\ngreeter(myCat)</code></p><p></p><p>这个例子做了很多事，让我来说明下：</p><p></p><p>我定义了2个对象myCat和myDog，我将把它们作为参数，多重方法将根据它们确定自己的行为。我定义了2个自定义函数greetDogs和greetCats，它们的实现稍有不同。它们将代表switch中每个case语句里的代码。然后我调用一些函数，尤其是multi和method，来定义多重方法greeter。multi函数接收3个属性：一个分配器（dispatcher），我们将用它返回的值来确定要执行的逻辑片段；还有两个方法，分别代表switch的一个case语句。请注意，每次调用method时，要首先指定触发第二个参数的值（这是实际的逻辑所在）。最后，我使用同一个函数（我的多重方法）来执行两个不同的逻辑片段，而不需要在任何地方使用switch或if语句。</p><p></p><p></p><h2>多重方法有什么好处？</h2><p></p><p></p><p>当然，我们在这里没有施展任何类型的魔法，我们只是重写了决策逻辑的表达方式，类似下面这样的switch语句：</p><p></p><p><code lang=\"text\">switch(animal.type) {\n  \n  case \"dog\":\n    greetDogs(animal);\n  break;\n  case \"cat\":\n    greetCats(animal);\n break;\n}</code></p><p></p><p>那么，如果我们可以直接这样做，为什么还要大费周章地使用多重方法呢？问题的关键是可读性。</p><p>&nbsp;</p><p>switch语句非常开放，显示了我们的决策逻辑的实现。换句话说，这个语句是命令式的。它向你展示了决策树的内部运作情况，这意味着阅读代码的人将不得不在头脑中解析代码。因此，我们又回到了认知负荷的概念。这使得开发者要阅读并在头脑中解析代码。</p><p>&nbsp;</p><p>你要知道，大多数开发人员在遇到像上面这样的switch时，不会有什么反应。但是，这也不是一个实际的例子。通常情况下，case语句包含的代码更多，也更难阅读。</p><p>&nbsp;</p><p>而多重方法隐藏了决策逻辑的内部结构，你所知道的只是你对它做了设置，它将以某种方式工作。你更关心的是功能而不是实际的实现。这被称为“声明式编程”，有助于提高代码的可读性，同时降低开发人员的认知负担。这是因为它在逻辑上增加了一层抽象，为我们提供了更接近人类语言的表达工具。</p><p>&nbsp;</p><p>如果这还不能说服你，还有一个优点：可扩展性。</p><p>&nbsp;</p><p>如果你需要在switch中添加另一个选项，就必须回到代码中修改同一个switch，如果你，比如说，碰巧忘记添加break语句，就有可能造成问题，就像下面这样：</p><p></p><p><code lang=\"text\">switch(animal.type) {\n  case \"rabbit\":\n    greetRabbits(animal);\n  case \"dog\":\n    greetDogs(animal);\n  break;\n  case \"cat\":\n    greetCats(animal);\n break;\n}</code></p><p></p><p>还是个非常简单的例子，但如果是真实世界中一段更长的代码，那么这种情况出现的几率就更大了。</p><p>&nbsp;</p><p>以防你对这种行为不熟悉，请让我做个说明。第一个case中缺失break，会导致在动物类型为“rabbit”时也执行第二个case下的逻辑。</p><p>&nbsp;</p><p>然而，有了多重方法，我们就可以不断地根据需要对它进行扩展：</p><p></p><p><code lang=\"text\">let extendedGreeter = multi(\n    animal =&gt; animal.type,\n    method(\"parrot\", sayHiParrot)\n)(greeter)</code></p><p></p><p>现在，这个新方法extendedGreeter对“dog”、“cat“、”parrot“就都有效了，而我们不必再回去修改已有的代码。</p><p>&nbsp;</p><p>这是一个很大的好处，因为我们都知道，每次我们触碰可以正常工作的代码时，都有一点可能引入Bug。在这里，我们把可能性降低到0。</p><p>&nbsp;</p><p></p><h1>实现一个多重方法库</h1><p></p><p>&nbsp;</p><p>首先，你要知道，已经有一些库在处理这个问题了，其中一个例子是<a href=\"https://github.com/caderek/arrows/tree/master/packages/multimethod\">@arrows/multimethod</a>\"。</p><p>&nbsp;</p><p>尽管如此，对这些实现进行逆向工程总是很有趣，所以让我们看一看如何实现一个基本的多重方法库，以适应到目前为止所展示的例子。</p><p>&nbsp;</p><p>理解这个问题的关键是，我们需要一个分配器函数来给提供一个实际的值，我们将用它作为判断执行哪个方法的键。而且，我们不能对switch语句进行硬编码，因为选项的数量是不固定的。</p><p>&nbsp;</p><p>不能光说不练，下面是实现：</p><p></p><p><code lang=\"text\">\nfunction method(value, fn) {\n    return {value, fn}\n}\nfunction multi(dispatcher, ...methods) {\n    return (originalFn) =&gt; {\n        return (elem) =&gt; {\n            let key = dispatcher(elem)\n            let method = methods.find( m =&gt; m.value === key)\n            if(!method) {\n                if(originalFn) {\n                    return originalFn(elem)\n                } else {\n                    throw new Error(\"No sure what to do with this option!\")\n                }\n            }\n            return method.fn(elem)\n        }\n    }\n}</code></p><p></p><p>method函数只是把键和实际的逻辑耦合在一起，没有别的。multi函数中的代码才有趣，它返回一个匿名函数，以原始函数为参数并返回一个新函数，后者根据分配器代码（我们的第一个参数）返回的值执行不同的东西。</p><p>&nbsp;</p><p>让我们逐行看下：</p><p></p><p>首先，调用第8行的函数时提供一个属性（比方说myDog）。第9行的分配器逻辑会获取myDog并返回其类型，即“dog”。然后在第10行，我们找到第一个与该类型匹配的方法。如果没有方法匹配，但我们有一个有效的“originalFn”（也就是说，我们正在扩展一个原始的多重方法），我们会让它来处理这种情况。否则，我们将抛出一个异常，因为我们对此无能为力。然而，如果找到了匹配的方法，就在第18行执行它，并将原始属性“myDog”传递给它。</p><p>&nbsp;</p><p>就是这样。没那么复杂，对吗？当然，如果你想提供“默认”情况处理而不是抛出一个异常，或者你想处理多属性决策（比如根据属性type和name决定逻辑，而不是只根据第一个属性），就得编写更多的代码了。</p><p>&nbsp;</p><p>不过，还是那句话，如果你打算使用多重方法，建议你使用一个现有的库，而不是自己去实现。</p><p>&nbsp;</p><p>多重方法是一种有趣的方式，可以帮你摆脱令人讨厌的switch。而且，这也有助于提升代码的可读性。所以，既然你已经了解了多重方法，那么在决定继续坚持使用switch之前，一定要先试一试。</p><p>&nbsp;</p><p>你过去尝试过重多方法吗？你有什么看法？欢迎留言交流！</p><p>&nbsp;</p><p>查看英文原文：<a href=\"https://blog.bitsrc.io/drop-the-switch-statement-for-this-functional-programming-technique-faa193d903ae?gi=5a06fcb9545c\">Drop the Switch Statement for this Functional Programming Technique</a>\"</p>",
    "publish_time": "2022-09-06 10:46:33",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]