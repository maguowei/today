[
  {
    "title": "详解命令模式本质及其在高复杂调用中的实践案例",
    "url": "https://www.infoq.cn/article/8c74cb9796ad9fbe8c6493a10",
    "summary": "<p>作者：范灿华  阿里同城履约物流技术团队</p><p></p><p></p><blockquote>命令模式是一种设计模式，总结了在特定场景下的最佳设计实践。本文将为大家介绍命令模式的模式本质及灵活运用，并通过一个真实的电商履约系统中的库存调用需求为案例，分享其在高复杂调用中的实践。</blockquote><p></p><p></p><p></p><h1>一、前言</h1><p></p><p></p><p>本文是一篇基于同城履约业务中台与库存系统的协同设计过程中使用到命令模式并获得很好成果而撰写的技术分享文章。命令模式是一种设计模式，总结了在特定场景下的最佳设计实践，它是一种间接经验。为了将这种间接经验变为我们可以使用的直接经验，我们需要做到两点：看清模式本质和灵活运用。</p><p></p><p>1）模式本质：掌握一个设计模式的关键在于发现其核心关注点。每个模式都有一个关注点，例如命令模式的关注点是调用过程，而策略模式和状态模式的类图看起来相似，但它们的运作机制却完全不同：前者关注外部引起的算法变化，后者则关注内部状态的转变变化。通过找到模式的本质关注点，才能真正掌握它。</p><p></p><p>2）灵活运用：在实际应用中，设计模式的实现方式可能会与教科书上的类图略有不同甚至完全不同。因此，我们不能一味地套用模式，而应该根据实际需求进行量身定制和改进。这意味着我们需要深入了解模式本质，然后根据自己的需求来适当调整模式的用法。有时，你可能会意外地创造出一种新的模式。</p><p></p><p>针对以上两点，本文首先特别地会从OOA（面向对象分析）的角度去介绍命令模式的模式本质（2.1. 封装调用），然后列举命令模式的不同玩法及其中的原理用作展示该模式的运用灵活性（3. 灵活运用）。最后一个真实的电商履约系统中的库存调用需求为案例（4. 应用案例），这个案例刚需要隔离的变化点是调用，非常适合命令模式。</p><p></p><p></p><h1>二、模式本质</h1><p></p><p></p><p></p><h2>2.1 封装调用</h2><p></p><p></p><p>直接的调用：命令模式在设计模式的分类中属于行为型模式，它关注的是一种对象之间的调用行为，不管如何，调用行为必然涉及两个角色，他们就是：调用者（Invoker） 和&nbsp;被调用者（Receiver），基本上他们对应的就是两个对象类，并且Invoker类静态编码依赖Receiver类方法进行调用。如果在不考虑其他因素的情况下，这两者的行为关系可以描述为下图：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/94/94ffebbc26fcae960cb8b6a3f97d460c.png\" /></p><p></p><p>然后我们来说一下上面的调用特点：</p><p></p><p>上面的调用只有2个对象，调用者（Invoker）和被调用者（Receiver）；其中调用者（Invoker） 是代码静态依赖被调用者（Receiver）的；调用在上面是一个请求过程，这个过程在图中用虚线圈表示；</p><p></p><p>对象化调用：命令模式就是在以上场景下，把上图中虚线圈调用这个调用过程给显式化、抽象化、实例化。本来只是一个调用的过程，我们把它（这个过程）刻画出来封装为一个具体的对象（Concrete Command），这个对象就是命令对象。调用方将会利用命令对象这个代理来帮忙调用被调用方，所以以上的调用过程就变为了下图所示：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/91/91c5c1caa3af35eceb02d3e522ec51ac.png\" /></p><p></p><p>这样一来，调用方和被调用方就没有了直接的耦合关系，也就是说他们 “解耦” 了，概括一下这几对象协作的特点：</p><p></p><p>我们多了一个新的具体命令对象（Concrete Command） 对象的职责就是完成调用请求；命令对象持有被调用方Receiver的引用和请求参数，并描述了如何执行请求，被调用方可以被参数化设置到命令对象中；静态代码依赖变成了调用者（Invoker）依赖命令对象（Concrete Command），命令对象（Concrete Command）依赖被调用者（Receiver）调用者（Invoker）可以完全不知道被调用者接口以及执行请求的具体方式和细节，把这些委托打包给命令对象，从而可以少写很多无谓的执行细节代码。</p><p></p><p>隔离调用变化：把调用封装起来后，我们解开了调用者（Invoker）和被调用者（Receiver）依赖，那么就可以轻易的允许调用发生变化，这一点很重要，我们很多时候封装调用都因为调用本身在未来容易发生变化，下面列举一些常见的变化：</p><p></p><p>不同场景下，调用者（Invoker）需要调用不同的 被调用者（Receiver）；被调用对象的方法发生变化，例如换了一个新版本API；请求需要延迟执行，或者一次调用突然需要调用2个被调用者（Receiver）；</p><p></p><p>使得调用的变化可以做到开闭原则的方式很简单，我们给命令对象实现一个命令接口 （Command），让调用者代码只依赖命令接口，这个接口的每一个具体的命令对象代表了一种变化，真正执行的具体命令是可以在运行态确定的，调用方不再依赖具体的调用命令：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d3/d3a00c1826ef8975261c79fab51e5eb6.png\" /></p><p></p><p>提出变化的角色：如果读者对控制反转比较熟悉的话，那么就很自然知道上述中要实现隔离变化的代码编写，其实就是面向超类型编程。面向超类型编程是把设置实例的控制权交给了依赖关系中的最外层（也就是细节层），在命令模式中，我们把这一层称之为客户端（Client）。换句话说，把调用者（Invoker）、 被调用者（Receiver）和命令对象（Concrete Command）隔离开为互相独立的组件后，自然也需要一个角色去组织起来，道理很简单，积木也是需要有人搭才能千变万化，想变成怎样就是客户端（Client）的需求了。</p><p></p><p>现在我们又多了一个角色客户端（Client），整个命令模式的基本参与者都全了，可以整体看一下命令模式的类图。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/f8/f83b2ae1c8e706cf5656cd1483186860.png\" /></p><p></p><p>上面是一个比较标准的命令模式的类图，上图中可能大家会比较疑惑的一个点就是被调用者（Receiver）能不能直接实现Command接口，这当然是可以的，但是解耦程度会比较低，我们尽量参数化被调用者，然后做一个傻瓜式的命令。要掌握命令模式，我们还得懂得如何灵活变化去运用它，下面我们看看命令模式的一些基本玩法。</p><p></p><p></p><h1>三、灵活运用</h1><p></p><p></p><p></p><blockquote>Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.—— From GoF</blockquote><p></p><p></p><p>设计模式提出者“四人帮”对命令模式的总结非常精辟：参数化请求、记录请求、队列化请求，还可以支持撤销操作。另外还有一种说法是：回调请求就是命令模式的面向对象版。可见在命令对象上面做文章，可以衍生出多种玩法，本章将会详细列举常见的几种。</p><p></p><p></p><h2>3.1&nbsp;组装命令</h2><p></p><p></p><p>命令模式最大优点是解开调用者和被调用者（接收方）的耦合，因此我们可以轻易在一个调用中更换调用请求的接收方，而解开后的组装方式有两种：</p><p></p><p>第一是在Client角色中进行静态代码编写；第二种是实现配置化在运行时动态组装；</p><p></p><p>其中第二种动态组装和拓展点的实现原理是一样的，会根据动态的参数来决定具体执行的命令。我把这种组装的原理描述为下图：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/9d/9d84b0f5d13d6bbf3af21ff3e4d59b09.png\" /></p><p></p><p>目前有不少框架有类似拓展点的功能的实现，如TMF，IFBF，COLA等。利用拓展点的功能帮忙，我们可以轻松实现以上的方案，当然我建议自己在项目种开发一套，因为你随时都有可能面对框架做不到的变态需求。</p><p></p><p></p><h2>3.2&nbsp;记录命令</h2><p></p><p></p><p>如果我们把调用记录下来，我们就能完成很多不可思议的事情。调用能被记录下的信息主要有：调用的顺序、调用的出入参数、调用的状态等。有了历史记录，就可以对调用的历史执行进行回放或者倒退。下面分别介绍 命令撤销 和 命令日志 的两种回放玩法。</p><p></p><p>命令撤销：命令撤销是发生在命令簇（4.3节有介绍，表示关联关系的命令组）中的一种需求。其实它的原理非常简单，因为命令基本会改变状态，我们给命令接口一个反向的恢复状态的方法（如下面的undo），并且把调用过的命令对象都记录下来，就可以在一个撤销按钮中完成状态恢复操作。（读者可以参考Head First Design Parrtern命令模式的撤销操作）</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ba/babc5ef3617321c48a7d58f127459a1f.png\" /></p><p></p><p>调用者具有多个命令插槽，每个插槽可以设置一个命令实例，共同形成一个命令簇（是个List）；调用者维护一个栈，其实是命令插槽的调用历史栈，每一次调用者执行命令就把该命令入栈顶；用户需要倒退命令的时候，将栈顶命令退栈，并执行undo方法，利用栈后进先出的特点完成了历史状态回退功能；</p><p></p><p>命令日志：我们看一个利用函数式编程的不变性来恢复数据的原理，即在不同的时间或者空间节点中只要执行相同的事件函数调用，就一定会达到一个相同的状态。这个原理被广泛应用于很多系统中，例如数据库系统使用binLog事件和数据快照进行备份恢复，Redis使用RDB快照和AOF事件进行数据恢复，Excel文档数据保存等都是经典的应用场景。</p><p></p><p>具体来说，对于大型的数据结构而言，我们难以每时每刻都快速存储下它的状态，为了完成记录每时每刻的状态，我们可以通过上次检查点（CheckPoint）之后的所有操作命令（包括参数）都记录下来，当我们需要恢复数据结构的状态的时候，只需从检查点开始按顺序应用这些操作即可。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d3/d3251485fcbda2f6797a86e0e54b24fd.png\" /></p><p></p><p></p><h2>3.3&nbsp;组合命令</h2><p></p><p></p><p>如果一个命令设计的本身，就是用作封装其他不同命令的组织，我们称这个命令为宏命令。宏命令是一个通用的命令实现类，它类似一种组合模式，持有其他命令的引用，并依次执行他们。因此宏命令最大的作用是我们可以在一次调用中，调用多个命令，宏命令代码如下：</p><p></p><p><code lang=\"null\">public class MacroCommand implements Command {\n  \n  Command[] commands;\n  \n  public MacroCommand(Command[] commands){\n    this.commands = commands;\n  }\n  \n  public void execute(){\n    for(int i = 0; i &lt; commands.length; i++){\n      commands[i].execute();\n    }\n  }\n  \n}</code></p><p></p><p>特别注意：特别注意这个模式的特点是宏命令完全是不需要特殊开发的，它是一个可以组合其他命令的容器命令，也等同于普通的命令。只要对3.1节中命令组装工厂进行适当改造，我们也可以把宏命令用在动态的命令组装上，他可以让调用者在一次调用中完成多个调用请求。4.1 节，我们将会把宏命令用到实际的例子中。</p><p></p><p></p><h2>3.4&nbsp;异步命令</h2><p></p><p></p><p>异步命令：如果场景允许，我们可以把同步调用设计为异步调用。异步调用对象化后的异步命令对象（Concrete Command）打包了整个请求过程细节，对象本身具有状态，所以可以存储，也可以被传递。</p><p></p><p>对于调用者和被调用者而言，一般同步的都是强依赖，而异步则是弱依赖，因此这个解耦很大程度上是一个设计问题。同时我们也应该注意到，异步调用设计有着极大的好处也有自身的缺点。</p><p></p><p>同步调用需要阻塞流程，异步调用不阻塞，并立即返回对性能友好；异步具有削峰填谷的能力，可以堆积命令调用，用时间换计算资源；同步编程简单，异步编程比较复杂；同步的程序状态追求强一致性，异步的程序状态追求最终一致性；</p><p></p><p>队列调度：异步命令对象本质上打包了运算块（参数+接受者+一组操作），所以它可以被不同调用者执行放在任意地址，任意时间执行。例如客户端/调用者可以设置好命令submit到某个队列中（具体实现产品可能是一种中间件，或者定时器），让其他调度者（不同线程）从队列中获取命令执行，从而可以实现请求堆积、请求被按需调度执行（定时调度）等需求。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/96/960ee4d696831d5b4412bdf4e8049949.png\" /></p><p></p><p>回调通知：在异步编程中，如果我们想要得到异步的调用结果，我们可以设置一个回调函数，让异步过程执行完毕后通知发起异步的一方。如果这个回调函数设计为接口，并在接口的实现中封装真正的接受者和其操作，这正好就是命令对象的用法，只是看问题的角度不同，所以可以认为命令模式是回调的面向对象的版本。</p><p></p><p></p><h1>四、应用案例</h1><p></p><p></p><p>介绍完上面的命令模式本质和基础玩法后，这节将介绍一个同城履约中台域的真实案例。该案例应用到了以上提到的组装命令、宏命令、队列化请求等玩法。同城履约域主要负责近场零售商品的配送调度管理，它需要承接多种商家多种配送玩法（业态）的配送需求。其中对商品的物流操作的调度管理有多个通用的节点，包括创单、出库、运输、揽收和妥投等，而这些节点都可能需要去驱动库存的信息流变化，下面从出库节点的「仓单打包出库」服务作为例子介绍履约域与库存的关系。</p><p></p><p></p><h2>4.1&nbsp;识别调用变化</h2><p></p><p></p><p>例子：我们用一个设计良好的领域服务组件开始介绍，如下图所示：假设我们有一个「仓单打包出库」的通用领域服务，完成仓单出库履约系统要做的事情有：</p><p></p><p>1）记录数据：记录真实的出库数量；</p><p>2）设置状态：设置仓单为出库状态；</p><p>3）操作库存：把占用的业务库存正式扣减掉；</p><p>4）推进履约单；推动对应的履约单状态；</p><p></p><p>库存调用的变化：现在有两个不同的业务身份（淘系商家、外部商家），他们在「仓单打包出库」操作库存是调用不同的库存系统的，如果是直接硬代码编写（大家熟知的if大法），就需要每一次不同的业务身份变更，都要变更这个领域服务。这样的系统是无法维护的，因为履约域具有数百个业务身份，而且所对接的库存系统也是多种多样。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b0/b03d4522436c3ff9ba62adb59dc8b229.png\" /></p><p></p><p>结合上图所示，一个类似这种「仓单打包出库」服务的库存操作步骤可能存在哪些变化点呢？</p><p></p><p>被调用者变化：针对一个履约域的领域服务（如上面的【仓单打包出库】），不同的业务身份都可能调用不同的库存系统；调用者变化：针对同一个库存系统，它可能会被履约域中的其他领域服务调用，如【缺货处理】、【妥投处理】等；调用参数变化：针对同一个库存系统，不止有扣减，还可以有其他调用类型和参数，例如占用、释放、加在途等等；调用过程变化：上面库存的调用，可是需要一次性调用不同的库存系统组合，2个或者3个都有可能；</p><p></p><p></p><h2>4.2&nbsp;实现命令组装</h2><p></p><p></p><p>我们意识到了调用的变化，就需要完全的解开库存系统和履约系统的耦合。首先设计一个库存系统代理接口Inventory Receiver，接口的每一个实例都是被调用者（Receiver），它用作封装库存系统提供的API接口，并代表着一个库存系统的一种调用类型。而调用者就是履约域的各个节点，然后，我们再把调用的过程实例化为命令（Command），整体做成了一个完整的命令模式。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/42/426dcc4f55701ad69b35b6c5a1d6bce5.png\" /></p><p></p><p>调用配置化实现：设计为命令模式后，【仓单打包出库】领域服务成为一个通用的服务，每一步都抽象出一个稳定的步骤，远离具体细节的变化。其中第三步：操作库存，则调用的是库存命令组装服务。这个组装服务实现了根据不同业务身份创建拥有不同Receiver的库存命令实例，整体一个调用变化为下图所示：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/73/739f88a73af2a0a3f96a1d9523576def.png\" /></p><p></p><p>正如3.1节提到，目前也有很多框架都能轻松做到这种动态组装，当然手写一个这样的机制也不是什么难事。具体的运行机制很简单，简单描述如下：</p><p></p><p>右边一个通用的领域服务有4个步骤，其中第三步「操作库存」调用的是一个通用的库存组装服务；左边的实现A、B、C是封装了具体库存系统API的Receiver，他们都实现了接口：Inventory Receiver；config.xml是bean的装配配置文件，库存组装服务在运行时根据不同的商家身份，获取对应的Receiver实例设置到Concret Command中成为库存操作命令，并执行该命令；</p><p></p><p>组合调用：注意，上面的案例中，淘宝商家不仅要调用AIC系统，还需要调用IPM系统，这要求我们在一个Command接口的一次调用中实现AIC和IPM2个系统的调用，我们有两种实现方式：</p><p></p><p>方式1：在Command的接口实现中，把调用AIC Receiver和调用IPM Receiver的代码都写完，提供一个臃肿的接口实现；方式2：设计一个宏命令模式实现（机制见3.2节介绍）：把AIC Receiver和IPM Receiver 添加到到宏命令容器中；宏命令接口的逻辑就是依次调用宏命令容器里面的命令；</p><p></p><p>针对组合调用的需求，上面的方式1的解耦程度是不如方式2的，因为如果出现某个业务身份在该领域服务下仅仅只需调用AIC或者IPM的情况，或者又有需要在一个Command接口实现中调用3个库存系统，方式1都需要开发代码，而方式2仅仅配置即可，所以上面的实现2不仅可以代替方式1，还更具有灵活性，这就是松耦合的魅力。</p><p></p><p></p><h2>4.3&nbsp;识别命令簇</h2><p></p><p></p><p>在大家熟知的《Head First Design Parttern》书籍中，里面例子重点介绍了一种「遥控器」的设计，遥控器具有多个插槽，也就是可以在一个调用者里面设置多个命令，形成一个命令簇。如果我们能在实际应用中发现这种调用组，而且他们具有关联关系，那么命令模式就可以把这种命令簇及其关联逻辑封装起来，用作应对软件变化。</p><p></p><p>库存命令簇：上面只给到一个领域服务，但是一个完整的履约域是具有多个状态节点的，而其中在一次履约过程中就有不少节点中的领域服务需要和库存系统交互，例如【履约单取消】、【仓单打包出库】、【缺货处理】、【妥投处理】、【退货回仓】等等，他们不仅有顺序关系，而且通常在设计编码中都有很多共同逻辑，这些有相关性的调用集合，就是一个命令簇。而且，更深一层考虑，他们本身就可以形成一个子领域，配合下图，我们把相关特点列举如下：</p><p></p><p>业务身份：库存调用子领域应该有自己独立的业务身份，并以业务身份为维度组织命令的配置，组装出关联命令簇；库存流程：一个业务订单完整的生命周期中，库存的命令簇必然按顺序调用，有顺序关系的命令簇形成库存调用流程；库存跟踪：库存跟踪是综合了库存流程的实例化和数据化的结果，它刻画的是整个库存调用的生命周期；监控运维：考虑命令簇和多业务身份，调用量会变得极大，那么系统异常问题、库存不足问题、库存查询问题等就需要用到系统自动化级别的监控运维手段，实现这些需求需要库存跟踪的基础；</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/7d/7d1b72f9009162fd2ddd672ae9cbb379.png\" /></p><p></p><p>配置命令簇：如下表所示，每个业务身份都有自己的调用节点组，一个组形成了完整的调用流程。作为一个履约中台系统，经常会新加或者减少业务身份，因此配置化方式组织命令簇及库存调用流程就显得非常必要，当开展新业务的时候，只需一个新的组合配置即可支持，符合软件开发开闭原则，配置化具有以下特点：</p><p></p><p>针对履约域的一个节点（如【履约单创建】），不同的业务身份都可能调用不同的库存系统（下面的AIC\\TIC\\GSI）；不同业务身份即使使用同一个库存系统（如AIC系统），他们的库存协调所需要的命令组合也可能是不一样的；针对同一个节点（如【履约单创建）和同一个库存系统，不同业务身份调用的参数也可能不一样，因此参数也可以配置化；</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/89/8984dde058bc0492a0457b26c7e04d0f.png\" /></p><p></p><p>空命令（NoCommand）：上表所示，一行代表一个命令簇，一个命令簇可能在某个节点（如「缺货处理」）是不做任何事的，这个时候我们可以用到NoCommand。NoCommand 对象是一个空对象的例子，当你不想返回一个对象的时候，空对象就很有用，如上图所示，「外单」的业务身份在「缺货处理」这个节点上，是不需要执行库存调用的，但返回null给调用者就会出现异常，所以这个时候我们可以把不调用任何库存系统的NoCommand实现返回。</p><p></p><p>库存调用跟踪：我们以业务身份为维度组织了命令簇，实现了命令簇组织的配置化，并且以命令簇的顺序执行特性绘制了库存执行流程。然而命令簇配置和库存流程都是静态的，为了运维和管控好库存调用，我们还需要关注每个订单的执行情况，做到对每个调用都精确跟踪。</p><p></p><p>想要跟踪履约单的库存调用，我们需要履约单当前库存状态和历史的库存执行流水。我们可以用库存跟踪单刻画一个订单实例当前状态，把命令的每次执行结果作为库存的执行流水，并用库存跟踪单把业务履约单和命令对象、命令流水等库存的串联关联起来，串联的ER图如下：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/01/011e450c100e49079cb09a1fa2b44a11.png\" /></p><p></p><p>库存跟踪单可以告诉我们的信息大概有以下几点：</p><p></p><p>该订单命中了哪个业务身份配置；该订单库存生命周期有哪些调用组，调用的顺序是怎样的；该订单当前在执行哪个调用，该调用是被什么履约域事件触发的；该订单历史上执行过哪些调用（命令），调用的出入参是什么，是否成功等；</p><p></p><p>命令簇顺序管理：另一方面，库存的跟踪还包括保证正确的库存调用顺序，例如某个业务的调用组的执行流程如下：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/2a/2a39fa872c53edfe7329e0b63920f848.png\" /></p><p></p><p>假设以上的调用都是异步调用，通过接收履约域的标准异步消息进行，因为是异步，所以就有可能「退货」消息先到，然后「妥投」消息后到，发生这种情况，就会导致库存调用出现各种可能的问题。解决该方法也很简单，利用一个可以处理当前状态和事件的库存状态机+延迟执行（Scheduler的队列命令）就可以保证流程的正确执行。</p><p></p><p></p><h2>4.4&nbsp;识别调用边界</h2><p></p><p></p><p>这一节中，我们围绕库存调用把范围拓展到了命令簇，并且为命令簇为基础刻画了一个业务的完整库存调用生命周期，实现了从静态的库存流程设计到动态的库存跟踪掌控。这个过程我们发现库存的调用内容完全和履约主业务没有强关联，所以我们可以考虑把这些内容从履约业务系统中隔离出来，给他们划分一个清晰的边界。</p><p></p><p>库存界限上下文：库存调用作为履约系统的子域属于一个小分支，并不在核心流程内，即使不做库存操作，也不会影响一个履约主流程的运行，所以他属于弱依赖，因此，我们可以出于组件独立性的考虑，把库存调用和核心域（履约主系统）划分一个明确系统边界，让库存独立形成一个库存界限上下文。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/f2/f218049205f6e25c74c440b28ad52317.png\" /></p><p></p><p>如上图所示，除了为库存调用划分边界，成立库存界限上下文外，核心域（履约主系统）在调用上还可以划分其他边界和上下文。假设履约域还要驱动计费的流转，那么我们还可以划分出一个计费界限上下文，不过这就是另一个话题了。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/5f/5fa911e827f3aa9069f4e4d6671a06c3.png\" /></p><p></p><p>库存调用协同系统：综合上面上下文中的大规模的配置化管理、库存的流程管理、库存的跟踪、监控、运维后，我们完全有理由为这个库存调用上下文建立一个独立部署的系统，其作用类似中间件的作用。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/94/94c91deec21a1001b52f029eb0569021.png\" /></p><p></p><p>现在，我们所有的库存需求都可以在该系统中实现，而且部署、变更都不会影响履约主系统，这是一个很好的实践。下面我们从监控运维、查询可视化、新业务接入分别看看这个围绕库存调用的系统所能做的事情。</p><p></p><p>调用监控运维：方法调用都需要面临一个调用失败的问题，失败的原因可能有业务异常、系统异常，这些异常可能是可以重试成功的，有些则无法重试成功，只能人工插入管理。在一些比较小的系统，或者调用量不大的系统，发生这样的问题次数不多，我们可以通过系统日志简单运维，但像履约域每日上百万，超千万级别的调用，量表到质变，管理运维就是一个新的问题了。</p><p></p><p>调用状态记录：那么这些调用异常的状态应该记录在哪里？现在我们有一个很好的答案就是用命令对象（Command），并可以把命令对象持久化到数据库中等待使用。我们记录调用的状态包括很多，调用的出入参数、命中的业务配置，触发调用的事件等等调用失败重试：对于系统宕机，网络异常等调用失败问题，我们可以通过重试一定次数来解决，而重试本身也是一个问题，从失败记录、批量发现、定时重试都可以通过一个统一的模块管理，和业务流程无关。调用异常报表：对于无法重试成功的异常调用，简单的日志告警容易使人疲劳，或许这个时候定期出一个调用异常报表更适合，在数据库中的命令对象离线化后，做这种事就很简单。调用数据订正：当我们发现库存调用问题后，我们很大情况下解决方案是需要订数据，然后重试，因为命令对象记录了调用参数，因此修改参数重试命令也是简单可行。</p><p></p><p>我们现在从调用的监控运维视角，看一下系统对调用监控运维自动化的运作流程：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/41/41745b5e2d3eab39e5b0996af8e84b21.png\" /></p><p></p><p>命令调用可视化：在一个调用如此庞大的系统，即使是在日志加加了trace日志作为跟踪，可能也容易造成混乱，让运维人员在库存查询时变得很痛苦，但如果我已经用库存跟踪单刻画了所有调用的状态信息，那么我基本可以通过一个订单id，找到该库存跟踪单，并可以在数据库中查到该跟踪单的所有库存调用命令和调用流水。我们把这些数据可视化，将会节省运维和开发排查问题的大量时间。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b1/b11d2cc03c6271c56a0d0480e3e28aa4.png\" /></p><p></p><p>新业务开发流程：现在我们回归业务，一个系统设计再厉害，如果在应变新需求的时候需要大动干戈的修改旧代码，那这个系统必然是一个设计失败的系统。所以我们现在讨论一下库存系统的新需求接入流程，用以评估系统的可用性，我们将分别从命令变化的几个方面的需求进行讨论：</p><p></p><p>1）新业务身份接入：履约中台系统，承接各种订单的近场履约服务，而业务总是有新模式，所以就会有新的业务身份，也可能会产生新的库存调用变化，但因为履约域、库存系统都是通用的，消息/接口也是标准的，所以新的业务身份，只需要加配置文件（配置调用组、流程、调静态用参数）即可运行。</p><p></p><p>2）新库存系统接入：如果新的业务身份需要调用的库存系统之前没接入过呢？对比新业务身份接入，我们只是缺少配置的Receiver而已，因此只需要创建新的Receiver实例，封装需要接入的库存系统API，即可完成需求。完全也是拓展化开发。</p><p></p><p>3）新调用节点的接入：一个新的业务身份要调用新的节点，或者某个旧的业务身份需要加一个新节点，因为履约域的系统是标准的消息，所以也不需要修改，配置即可。</p><p></p><p>4）新的调用系统的接入：如果除了履约域要接入外，其他系统也需要接入库存调用系统，那么就需要做一个防腐层，把新系统的消息转化为库存协同系统的标准消息即可。</p><p></p><p>库存系统的所有变化，无非就是以上几个方面，开发应对基本的新代码及新配置，做到了节点，Receiver的完全解耦复用，同时复用系统所有能力（如可视化、监控运维等）。而且最重要的是，即使新增平台的能力，也是所有业务可以享用的 。到这里，库存系统的基本功能介绍完毕，而且实践各个方面都能证明它能极大提升我们的生产力。</p><p></p><p></p><h1>五、结束语</h1><p></p><p></p><p>相比起一般的设计模式例子，本文的案例更系统的是把请求调用进行了多方位的管理，包括命令组织为流程、调用的可视化、调用的批量处理等等，而做这些的前提都是把请求调用封装起来，本质上并没有变化，我们的关注点一直都在调用上面。</p><p></p><p>另外，文中围绕命令模式的本质，总结出了几种经典玩法背后的形式，几乎涵盖了调用变化的主流场景。当发现一个应用场景主要变化点在调用的时候，我们就可以考虑是否利用重构工具把请求封装起来，以便在需求再次变化的时候，尝试通过记录命令、配置命令、组合命令、异步命令等方式进行拓展性开发，最大限度降低开发风险和维护成本。命令模式如此，其他设计模式也是如此。</p><p></p><p>最后，一个设计模式的应用范围也不要限制在一个独立部署的系统内，也可以拓展到系统之间的设计中。例如经典的观察者模式，在系统之间的应用就非常之广。本文案例中的命令模式也是跨系统的应用，甚至可以跨组织架构之间的应用。为什么不需要被系统所限制呢？因为系统与系统之间的调用本质依旧是组件和组件之间的调用，只是其中的边界和方式有所改变。</p><p></p><p></p><h2>引用</h2><p></p><p></p><p>《Head First设计模式》Eric Freeman &amp; Elisabeth Freeman with Kathy Sierra &amp; Bert Bates [著].O`Beilly Taiwan公司[译].2007.中国电力出版社</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/0a/0a182daf38208273d04db744f256587f.png\" /></p><p></p>",
    "publish_time": "2023-03-10 13:26:26",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "如何基于 Apache Doris 构建简易高效的用户行为分析平台？",
    "url": "https://www.infoq.cn/article/EIDCeKCqX9SHIlsItDud",
    "summary": "<p>从上世纪 90 年代初 Bill Inmon 在《building the Data Warehouse》一书中正式提出数据仓库这一概念，至今已有超过三十年的时间。在最初的概念里，数据仓库被定义为「一个面向主题的、集成的、相对稳定的、反映历史变化的数据集合，用于支持管理决策」，而<a href=\"https://www.infoq.cn/article/G-NGJllXC8zhCjpWhbl9\">数据湖</a>\"最初是为了解决数仓无法存储海量且异构的数据而构建的集中式存储系统。</p><p></p><p>时代的发展与用户数据应用诉求的演进，催生了数据架构的不断革新，也衍生了更复杂的技术形态。可以清晰看到现代数据架构从计算到存储都在向着融合统一的方向发展，新的数据湖范式被提出，这也是 Lakehouse 诞生的背景。作为一种全新的、开放式的数据管理架构，Lakehouse 提供了更强的数据分析能力与更好的数据治理能力，也保留了数据湖的灵活性与开放式存储，为用户带来更多价值：</p><p></p><p>从存储的角度：统一数据集成，避免冗余存储以及跨系统间 ETL 带来的繁重工程和失败风险；从治理的角度：支持 ACID、Schema Evolution 与 Snapshot，数据与元数据皆可治理；从应用的角度：多引擎访问支持、可插拔，通过统一接口进行数据访问，同时适用于多种工作负载 Workload；……</p><p></p><p>如果我们把 Lakehouse 从系统层面进行解构，会发现除了需要 Apache Iceberg、Apache Hudi 以及 Delta Lake 等数据湖表格式（Table Format）以外，高性能分析引擎更是充分发挥湖上数据价值的关键。</p><p></p><p>作为一款极速易用的开源实时 OLAP 数据库，<a href=\"https://www.infoq.cn/article/0MiKpHhupXlSOFjbxQrV\">Apache Doris </a>\"自 0.15 版本即开始尝试在 Apache Iceberg 之上探索与数据湖的能力结合。而经过多个版本的优化迭代，Apache Doris 在数据湖分析已经取得了长足的进展，一方面在数据读取、查询执行以及优化器方面做了诸多优化，另一方面则是重构了整体的元数据连接框架并支持了更多外部存储系统。因此 Apache Doris 已经完全具备了构建极速易用的 Lakehouse 架构的能力，并且也已在多个用户的真实业务场景中得到验证和推广，我们希望通过 Apache Doris 能为用户在更多场景中带来价值：</p><p></p><p>湖仓查询加速利用 Apache Doris 优秀的分布式执行引擎以及本地文件缓存，结合数据湖开放格式提供的多种索引能力，对湖上数据及文件提供优秀的查询加速能力，相比 Hive、Presto、Spark 等查询引擎实现数倍的性能提升。统一数据分析网关利用 <a href=\"https://www.infoq.cn/video/45SWKZgG1z7Xh0bHFRvK\">Apache Doris </a>\"构建完善可扩展的数据源连接框架，便于快速接入多类数据源，包括各种主流关系型数据库、数据仓库以及数据湖引擎（例如 Hive、Iceberg、Hudi、Delta Lake、Flink Table Store 等），提供基于各种异构数据源的快速查询和写入能力，将 Apache Doris 打造成统一的数据分析<a href=\"https://www.infoq.cn/article/Hpu9ifGK71ElKaptHwUN\">网关</a>\"。统一数据集成基于可扩展的连接框架，增强 Doris 在数据集成方面的能力，让数据更便捷的被消费和处理。用户可以通过 Doris 对上游的多种数据源进行统一的增量、全量同步，并利用 Doris 的数据处理能力对数据进行加工和展示，也可以将加工后的数据写回到数据源，或提供给下游系统进行消费。该能力使得 Apache Doris 能够成为业务的统一数据枢纽，降低数据流转成本。更加开放的数据生态通过对 Parquet/ORC 等数据格式以及开放的元数据管理机制的支持，用户不用再担心数据被特定数据库引擎锁定，无法被其他引擎访问，也不用再为数据的迁移和格式转换付出高昂的时间和算力成本，降低用户的数据迁移成本和对数据流通性的顾虑，更便捷、放心地享受 Apache Doris 带来的极速数据分析体验。</p><p></p><p>基于以上的场景定位，我们需要进一步去思考在构建 Lakehouse 过程中需要如何去设计和改造系统，具体包括：</p><p></p><p>如何支持更丰富的数据源访问以及更便捷的元数据获取方式；如何提升湖上数据的查询执行性能；如何实现更灵活的资源调度与负载管理；</p><p></p><p>因此本文将重点介绍 Apache Doris 在 Lakehouse 上的设计思路和技术细节，同时会为大家介绍后续的发展规划。</p><p></p><h1>元数据连接与数据访问</h1><p></p><p>截至最新的 1.2.2 版本，Apache Doris 已经提供了十余种的数据湖格式和外部数据源的访问支持。同时也支持通过 Table Value Function 直接对文件进行分析。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/1b/1b181997febeadb60abe5c1d75b219c7.png\" /></p><p></p><p>为了支持这些数据源，Apache Doris 分别在元数据连接和数据访问两方面做了大量的架构调整和性能优化 。</p><p></p><h2>元数据连接</h2><p></p><p>元数据包括数据源的库、表信息、分区信息、索引信息、文件信息等。不同数据源的元信息格式、组织方式各有不同，对于元数据的连接需要解决以下问题：</p><p></p><p>统一的元数据结构：屏蔽不同数据源的元数据差异。可扩展的元数据连接框架：低成本、快速地接入数据源。高效的元数据访问能力：提供可靠、高效的元数据访问性能，并支持实时同步元数据变更。自定义鉴权服务：能够灵活对接外部的权限管理系统，降低业务迁移成本。</p><p></p><h3>统一的元数据结构</h3><p></p><p>在过去 Apache Doris 的元数据只有 Database（数据库） 和 Table（表）两个层级，当外部数据目录 Schema 发生变化或者外部数据目录的 Database 或 Table 非常多时，需要用户手工进行一一映射，维护量非常大。因此在 Apache Doris 1.2.0 版本中新增了 Catalog（数据目录）层级，提供了快速接入外部数据源的能力。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/51/513630b002c9573fec02262947be702d.png\" /></p><p></p><p>Catalog 层级的引入解决以下问题：</p><p></p><p>数据源层级的映射：用户不再需要在 Database、Table 层级进行一一映射，可以通过 Catalog 直接映射整个数据源，自动同步其中的所有元信息，简化元数据映射逻辑数据源统一信息管理：在 Catalog 层级统一维护指定数据源的属性，如连接信息、权限信息、同步方式等，更方便的管理多个数据源。</p><p></p><p>引入 Catalog 层级后，我们也对 Doris 的元数据进行调整和划分：</p><p></p><p>Internal Catalog：原有的自管理的 Table 和 Database 都归属于 Internal Catalog。External Catalog：用于对接其他非自管理的外部数据源。比如 HMS External Catalog 可以连接到一个 Hive Metastore 管理的集群、Iceberg External Cataog 可以连接到 Iceberg 集群等。</p><p></p><p>用户可以使用 SWITCH语句切换不同的 Catalog，也可以通过全限定名方便的进行跨数据源的联邦查询，如：</p><p></p><p><code lang=\"text\">SELECT * FROM hive.db1.tbl1 a JOIN iceberg.db2.tbl2 b\nON a.k1 = b.k1;\n</code></p><p></p><p>相关文档：https://doris.apache.org/zh-CN/docs/dev/lakehouse/multi-catalog</p><p></p><h3>可扩展的元数据连接框架</h3><p></p><p>基于新的元数据层级，用户可以通过 CREATE CATALOG语句方便的添加新的数据源：</p><p></p><p><code lang=\"text\">CREATE CATALOG hive PROPERTIES (\n    'type'='hms',\n    'hive.metastore.uris' = 'thrift://172.21.0.1:7004',\n);\n</code></p><p></p><p>在数据湖场景下，目前 Doris 支持的元数据服务包括：</p><p></p><p>Hive Metastore 兼容的元数据服务Aliyun Data Lake FormationAWS Glue</p><p></p><p>同时，开发者也可以自行扩展 External Catalog，只需要实现对应的访问接口，即可在 Doris 中快速接入新的元数据服务。</p><p></p><h3>高效的元数据访问</h3><p></p><p>元数据存储在外部数据源中，而对外部数据源的访问受到网络、<a href=\"https://archsummit.infoq.cn/202303/beijing/track/1448\">数据源资</a>\"源等限制，性能和可靠性是不可控的。所以 Doris 需要提供高效、可靠的元数据服务以保证线上服务的稳定运行，同时 Doris 也需要实时感知元数据的变更，提升数据访问的实时性。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/70/708eaf383c299d6f9e2649e6d1303bb7.png\" /></p><p></p><p>Doris 通过内存中的元数据缓存提供高效的元数据服务。元数据缓存包括列信息缓存，分区缓存，文件缓存。 通过元信息缓存，可以显著提升元数据访问性能并降低对外部元数据服务的请求压力，使得Doris 可以应对数千张表，数十万分区场景下，毫秒级别的元数据查询响应。</p><p></p><p>Doris 支持在 Catalog/Database/Table 级别，对元数据缓存进行手动刷新。同时，针对 Hive Metastore，Doris还支持通过监听 Hive Metastore Event 自动同步元数据，提供元数据秒级实时更新能力。</p><p></p><h3>自定义鉴权服务</h3><p></p><p>外部数据源通常拥有自己的权限管理服务，而很多企业也会使用统一的权限管理系统（例如 Apache Ranger）来管理多套数据系统。Doris支持通过自定义鉴权插件对接企业内部已有的权限管理系统，从而可以低成本的接入现有业务，完成授权、审计、<a href=\"https://www.infoq.cn/article/EAMArVeEdjp3ZtjVjgC8\">数据加密</a>\"等操作。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ef/ef001433107b277cfa6938dcd65ef2ea.png\" /></p><p></p><p>具体实现上，用户可以基于 Doris 的 AccessController 接口实现插件对接相应的权限管理系统，并在创建 Catalog 时，指定对应的鉴权插件。通过这种机制，所有通过 Doris 对外部<a href=\"https://archsummit.infoq.cn/202303/beijing/track/1477\">数据</a>\"源的访问，都将统一使用自定义的插件完成鉴权、审计等操作。</p><p></p><h2>数据访问</h2><p></p><p>外部数据源的数据访问，主要集中在对存储系统的访问支持上。在数据湖场景下，主要是对 HDFS 以及各种 S3 兼容的对象存储的支持。目前 Apache Doris 支持的存储系统如下，并且仍在不断增加中：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/8a/8aef34ea47b4e37490eaf442d0947773.png\" /></p><p></p><h1>性能优化</h1><p></p><p>在实现数据源的连接和访问后，下一个问题是我们如何结合 Apache Doris 自身优异的查询性能以及各类存储系统的特性，进行针对性的查询性能优化，这也是在 构建 Lakehouse 过程中最需要解决的问题和权衡的因素。在具体实现过程中，Apache Doris 分别在数据读取、执行引擎、优化器方面进行了诸多优化。</p><p></p><h2>数据读取</h2><p></p><p>湖上数据通常存储在远端存储系统上，相较于本地存储，在数据的访问延迟、并发能力、IO 带宽上天然存在一定劣势。因此，在数据读取上，Apache Doris 从减少远端读取频率，降低读取量等方面出发进行了细致的优化。</p><p></p><h3>Native File Format Reader</h3><p></p><p>Parquet 和 ORC 是最常见的开放数据格式，这些数据格式本身提供了包括索引、编码、统计信息在内的多种特性，如何针对格式特性来提升文件读取效率是性能优化的关键一步。在早期的实现中，Apache Doris 是通过 Apache Arrow 来读取 Parquet/ORC 数据文件的，但这种方式存在以下问题：</p><p></p><p>数据格式转换的开销：Arrow Reader 需要先将文件读取成 Arrow 的内存格式，再转换到 Doris 自己的内存格式，两次数据转换带来额外的开销。无法支持高级文件格式特性。如不支持 Parquet 的 Page Index，不支持 Bloom Fitler，无法实现谓词下推、延迟物化等功能。</p><p></p><p>基于以上问题，我们对 Flile reader 进行了重构，实现了全新的 Native File Format Reader。这里我们以 Parquet Reader 为例，介绍 Doris 的文件格式读取方面所做的优化：</p><p></p><p>减少格式转换。新的 File Reader 直接将文件格式转换成<a href=\"https://www.infoq.cn/article/ve1ZIGW6fCjw4LMhjeOf\"> Doris </a>\"的内存格式，并可以直接利用字典编码等功能转换到对应的更高性能的内存格式，以提升数据转换和处理的效率。细粒度的智能索引。支持了 Parquet 的 Page Index，可以利用 Page 级别的智能索引对 Page 进行过滤。相比之前只能在 Row Group 级别过滤，Page Index 过滤粒度更细、过滤效果更好。谓词下推和延迟物化。延迟物化的基本逻辑是先读取有过滤条件的列，再使用过滤后的行号读取其他列。这种方式能显著降低文件的读取量。这一点在远程文件读取场景下尤为重要，可以最大限度减少不必要的数据读取。数据预读。 将多次文件读取合并成一次，充分利用远端存储高吞吐、低并发的特性，提高数据的总体吞吐效率。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/fb/fbf4168dd1db96029948d88a0df8633a.png\" /></p><p></p><h3>File Cache</h3><p></p><p>利用本地高性能磁盘对远端存储系统中的文件进行本地缓存，能最大限度的减少远程数据读取的开销，同时可以提供接近 Doris 内部表数据的访问性能。在本地文件缓存方面 Doris 进行了如下优化：</p><p></p><p>文件块缓存（Block Cache） 。支持对远端文件进行 Block 级别的缓存。Block 的大小会根据读取请求自动调整，从 4KB 到 4MB 不等。Block 级别的缓存能有效减少缓存导致的读写放大问题，优化缓存冷启动场景下的数据读取延迟。缓存一致性哈希。通过一致性哈希算法对缓存位置和数据扫描任务进行管理和调度，充分利用已缓存的数据提供服务，并避免节点上下线导致缓存大面积失效的问题，提升缓存命中率和查询服务的稳定性。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/96/960d6dc8a961774b760151ef18d08f15.png\" /></p><p></p><p>通过 Flie Cache，在命中缓存的情况下，Apache Doris 可以提供和本地表一致的查询性能。</p><p></p><h2>执行引擎</h2><p></p><p>在执行引擎层面，我们希望能够完全复用 Apache Doris 的向量化执行引擎以及各类执行层面的算子优化，为数据湖提供极速的查询体验。因此，Apache Doris 对数据扫描（Scan）节点进行了重构，使得每一种新的数据源的接入，开发者只需要关注数据源本身的访问逻辑，无需重复地开发通用功能。</p><p></p><p>通用查询能力的分层</p><p></p><p>包括内表在内的所有数据查询，都会使用相同的 Join、Sort、Agg 等算子。唯一不同在于数据源的访问方式上，例如对本地内部格式数据的读取，或存储在 S3 上的 Parquet 格式数据的读取。因此 Doris 将不同数据源的查询逻辑差异下推到最底层的 Scan 节点上。Scan 节点之上，所有查询逻辑统一，Scan 节点之下，由具体的实现类负责不同数据源的访问逻辑。</p><p></p><p>Scan 算子的通用框架</p><p></p><p>对于 Scan 节点，不同数据源也有很多共性的方面，如子任务的拆分逻辑、子任务的调度、IO 的调度、谓词下推以及 Runtime Filter 的处理等。因此我们也对这一部分架构进行了重构。首先，将共性部分都以接口的形式对外暴露，如子任务的拆分、下推谓词的处理等；其次，对子任务实现了统一的调度管理逻辑，可以由统一的调度器管理整个节点 Scan 任务的执行。调度器拥有节点全局的信息，可以方便的实现更细粒度的Scan 任务调度策略。在这样的统一的数据查询框架下，大约 1 人周就可以完成一种新数据源接入。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/bc/bcb5c1fd08aab34a371bbe38c70f45ea.png\" /></p><p></p><h2>查询优化器</h2><p></p><p>查询优化器层面的优化集中在统计信息收集和代价模型的推导方面。</p><p></p><p>Apache Doris 支持对不同数据源的统计信息收集，如 Hive Metastore、Iceberg Metafile、Hudi MetaTable 中存储的统计信息等。同时在代价模型推导方面，我们也针对外部数据源的特性做了细致的调整。基于这些优化，Doris 可以为复杂的外表查询提供更优的查询规划。</p><p></p><h2>性能对比</h2><p></p><p>以上优先项，我们分别在宽表场景（Clickbench）和多表关联场景（TPC-H）下与 Presto/Trino 进行了 Hive 数据集的查询性能对比。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d3/d3bc4fde9398fca8225c418c9b5ba93a.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/40/40cde829687e8f5f8854da6f5f03a0c3.png\" /></p><p></p><p>可以看到，在相同计算资源和数据集下，无论是宽表场景或多表关联场景，绝大多数 SQL Apache Doris 的查询耗时都是大幅低于 Presto/Trino ，整体性能 相比 Presto/ Trino 有 3-10 倍的提升。</p><p></p><h1>负载管理与弹性计算</h1><p></p><p>对外部数据源的查询并不依赖 Doris 的数据存储能力，这也为 Doris 实现弹性的无状态计算节点成为可能。在即将发布的 2.0 版本中，Apache Doris 还实现了弹性计算节点功能（Elastic Compute Node），可以专门用于支持外部数据源的查询负载。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/bf/bfea84a78c712f1aff996922b271a559.png\" /></p><p></p><p>由于计算节点是无状态的，因此我们可以对这类节点进行快速扩缩容，以灵活地应对峰谷期的查询负载，在查询性能与成本消耗之间取得更好的平衡。</p><p></p><p>同时，Doris 也针对 k8s 场景下的集群管理和节点调度进行了优化，Master 节点可以自动管理弹性计算节点的上下线，方便业务在云原生场景、混合云场景下都能便捷的管理集群负载。</p><p></p><h1>案例实践</h1><p></p><p>随着以上功能的完善与性能的提升，Apache Doris 已经被多家社区用户应用于数据湖分析，在真实业务中发挥着重要的作用，在此以某金融企业的风控场景为例。</p><p></p><p>金融风控场景往往对数据的实时性有着更高的要求，早期基于 Greenplum 和 CDH 搭建的风控数据集市已经无法满足其高时效性的需求，T+1 的数据生产模式成为业务迅速发展的掣肘，因此该企业于 2022 年引入 Apache Doris 并改造了整个数据生产和应用流程，实现对 Elasticsearch、Greenplum 以及 Hive 的联邦分析，整体效果包括：</p><p></p><p>只需创建一个 Hive Catalog 即可对现存的数万张 Hive 表进行查询分析，查询性能得到极大幅度提升；利用 Elasticsearch Catalog 实现对 ES 实时数据的联邦分析，数据时效性从过去的分钟级提升至秒级甚至毫秒级，满足了风控策略的实时性要求；将日常跑批与统计分析进行解耦，降低资源消耗的同时使系统稳定性得到进一步增强。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/6b/6b78110aa36b17525cdeb863e95552f5.png\" /></p><p></p><h1>未来规划</h1><p></p><p>后续 Apache Doris 将持续在 Lakehouse 方向进行迭代和升级，下一步的工作将围绕在更丰富的数据源支持、数据集成和资源隔离与调度等方面：</p><p></p><h2>更丰富的数据源支持</h2><p></p><p>随着数据湖在各种业务场景中的不断落地，数据湖本身的功能也在不断迭代以满足越来越多样的业务需求。Doris也将和各个开源社区紧密合作，提供更完善的数据湖分析支持。</p><p></p><p>Hudi Merge-On-Read 表的 Incremental Query 支持利用 Iceberg/Hudi 丰富的索引功能，结合查询优化器提供更低延迟的分析性能。支持包括 Delta Lake、Flink Table Store 等更多数据湖格式。</p><p></p><h2>数据集成</h2><p></p><p>具体到功能层面，数据集成可以分为数据的读取和写回两部分。</p><p></p><p>数据读取方面，Doris 将进一步整合数据湖的数据访问特性，包括：</p><p></p><p>数据湖 CDC 的接入以及增量物化视图的支持，为用户提供近实时的数据视图。支持 Git-Like 的数据访问模式，通过多版本、Branch 等机制，在数据安全、数据质量等方面为用户提供更便捷的数据管理模式。</p><p></p><p>数据写回功能的支持，帮助 Doris 进一步完善统一数据分析网关的生态闭环。用户可以使用 Doris 作为统一数据管理入口，管理各个数据源中的数据，包括加工后数据的写回、数据导出等，对业务提供统一的数据视图。</p><p></p><h2>资源隔离与调度</h2><p></p><p>随着越来越多数据源的接入，Doris 也在逐步承接不同的工作负载，比如在提供低延迟的在线服务的同时，对 Hive 中 T-1 的数据进行批量处理。所以同集群内的资源隔离会愈发重要。</p><p></p><p>Doris 会持续优化弹性计算节点在不同场景下的调度管理逻辑，同时会支持更细粒度的节点内资源隔离，如 CPU、IO、内存等，帮助 Doris 支持多样且稳定的工作负载。</p>",
    "publish_time": "2023-03-10 14:50:58",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "集成ChatGPT后必应日活量首破亿！微软推出Azure OpenAI ChatGPT 服务，GPT-4下周发布",
    "url": "https://www.infoq.cn/article/5u0r3ANaikQ5u3k4D736",
    "summary": "<p></p><p>微软表示，客户可以立即开始使用 ChatGPT，定价为 0.002 美元 /1000 tokens。这与 3 月 1 日推出的ChatGPT API的价格相同。</p><p></p><h2>ChatGPT 现已登陆&nbsp;Azure OpenAI Service</h2><p></p><p></p><h3>Azure OpenAI Service 提供 ChatGPT 预览版</h3><p></p><p></p><p>3 月 9 日，微软宣布 ChatGPT 已经开始在 Azure OpenAI Service 中提供预览版。</p><p></p><p>微软表示，借助 Azure OpenAI Service，已有过千家客户开始应用各类先进 AI 模型——包括 Dall-E 2、GPT-3.5、Codex 以及其他由 Azure 超级计算与企业功能所支持的大语言模型。</p><p></p><p>自去年底 ChatGPT 亮相以来，其已经在各类场景下都有了出色的应用，包括内容总结、草拟电子邮件副本，帮助用户解决软件编程问题等。</p><p></p><p>现在，借助 Azure OpenAI Service 中的 ChatGPT 预览版，开发人员能够将定制化 AI 体验直接集成至自己的应用程序当中，包括增强现有机器人以处理意外问题、复述客服中心对话以加快客户支持速度、建立具有个性化的新广告文案、自动处理索赔流程等。各类认知服务将能够与 Azure OpenAI 相结合，为企业打造新型用例。</p><p></p><p>微软表示，客户可以立即开始使用 ChatGPT，定价为 0.002 美元 /1000 tokens。这与 3 月 1 日推出的ChatGPT API的价格相同。微软表示，所有 ChatGPT 服务将于 3 月 13 日开始计费。</p><p></p><p></p><h2>商业价值</h2><p></p><p></p><p>微软表示，其在各行各业的客户已经感受到了使用 Azure OpenAI Service 所带来的商业价值。</p><p>例如，ODP Corporation、新加坡智能国家和数字政府办公室以及 Icertis 等组织，都将继续应用 Azure OpenAI 和 ChatGPT 模型在业务中应用。</p><p></p><p></p><blockquote>“Azure OpenAI Service 提供的 ChatGPT AI 技术将帮助我们推动业务的持续转型，更有效地探索新的可能性，同时设计更多创新解决方案我们正在构建一款由 ChatGPT 驱动的聊天机器人，用以支持我们的内部业务部门，特别是人力资源部门。该聊天机器人已经成功改进了 HR 文档审查流程、可生成新的职位描述，并加强了员工之间的沟通。借助 ChatGPT 的自然语言处理和机器学习功能，我们简化了内部运营并推动业务成功。这项技术的应用，也将提高我们在市场上的竞争优势并增强客户体验。”—— Carl Brisco，ODP Corporation 产品与技术副总裁</blockquote><p></p><p></p><p>除了利用 Azure OpenAI Service 实现商业价值之外，微软内部也在开展工作，将来自 OpenAI 大语言模型的强大功能与 Azure 的 AI 优化型基础设施相结合，帮助向其消费者和企业产品引入新体验：</p><p></p><p>例如：</p><p></p><p>• &nbsp; &nbsp;GitHub Copilot 利用 Azure OpenAI Service 中的 AI 模型，帮助开发者与 AI 结合工作以加速代码编写。</p><p>• &nbsp; &nbsp;Microsoft Teams Premium 包含智能回顾和 AI 生成的章节，可帮助个人、团队和组织提高工作效率。</p><p>• &nbsp; &nbsp;Microsoft Viva Sales 的全新 AI 支持型卖家体验，能够根据电子邮件内容和数据驱动见解提供建议，帮助销售团队专注于有针对性的战略销售活动。</p><p>• &nbsp; &nbsp;Microsoft Bing 引入了 AI 聊天选项，以全新方式增强消费者的搜索体验。</p><p></p><p>用户还可以使用 Azure OpenAI Studio 中的无代码方法创建新的智能应用和解决方案。Azure OpenAI Studio 除了开放对服务内各个模型的定制选项外，还提供独特的 ChatGPT 自定义界面，确保其配置和组织保持统一。</p><p></p><h2>负责任的 AI 实现方法</h2><p></p><p></p><p>微软还致力于确保 AI 系统以负责任的方式开发实现，使其能够按预期工作，并为人们提供值得信赖的使用体验。</p><p></p><p>以 ChatGPT 或 Dall-E 图像生成模型为例，它们虽然能够生成新的工件，但这种能力也给模型带来新的挑战。例如，它们可能会生成看似有理、但却充满谬误的文本，或者创建出令人真假难辨的虚构图像。</p><p></p><p>为此，微软立足四个层级建立起了缓解措施，希望依据微软的负责任 AI 标准来应对这些挑战。</p><p></p><p>首先，是由客户负责的应用程序级保护，例如 AI 只负责文本输出，用户负责内容的解释和批准；</p><p></p><p>第二是引入输入输出内容过滤等技术保护手段；</p><p></p><p>第三是流程和政策保护，涵盖系统、滥用报告乃至服务水平协议；</p><p></p><p>第四是公布设计指南与透明度说明等文档，解释模型的好处和我们已经测试过哪些内容。</p><p></p><p></p><h2>Bing 每日活跃用户已突破 1 亿</h2><p></p><p></p><p>在推出带有聊天机器人 AI 的新 Bing 一个月后，微软发布了最新进展。</p><p></p><p>据微软负责现代生活、搜索和设备的副总裁 Yusuf Mehdi 称，必应聊天机器人 AI 推出一个月后，每日 活跃用户已突破 1 亿。</p><p></p><p>他提到，微软非常清楚自己在搜索市场上只是“一家渺小卑微的低份额厂商”。对，但也别忘了 Bing 的巨大影响力。在 Bing 新版本发布之后，微软吸引到了众多之前从不用他家搜索服务的新受众。Medhi 发现，如今多达三分之一的 Bing 使用者为新用户。</p><p></p><p>“我们认为新 Bing 的这种吸引力证实了我们的观点，即搜索需要重新发明，以及将‘搜索 + 答案 + 聊天 + 创造’结合在一种体验中的独特价值主张，” Yusuf Mehdi 说。</p><p></p><p>除了数量增加之外，微软显然也享受着参与度的增长，更多的人正在进行更多的搜索。</p><p></p><p>微软将此次胜利归功于两个因素，首先是 Edge 使用率的增长，这很可能得益于 Bing 的聊天 AI 作为一项新功能的加入。微软还表示，其 Prometheus AI 模型的推出使 Bing 的搜索结果更具相关性，因此人们一直在更多地使用，或至少尝试搜索引擎。</p><p></p><p>显然，Bing 每日预览用户中约有三分之一每天都在使用其聊天 AI 进行查询。平均而言，微软在每次会话中看到三个聊天。自推出新的 Bing 以来，聊天次数超过 4500 万次。此外，在 15% 的聊天会话中，人们一直在使用 Bing 来生成新内容。Bing 的 AI 聊天机器人在手机上的 推出也将搜索引擎的受欢迎程度推向了一个新的高度，并使得每日活跃用户比推出之前增加了六倍。</p><p></p><p></p><h1>GPT-4将于下周发布</h1><p></p><p></p><p>还有一个令人振奋的好消息。</p><p></p><p>下周，GPT-4就要来了。</p><p></p><p>3 月 9 日，微软德国 CTO Andreas Braun 在一场名为 “AI in Focus - Digital Kickoff” 的活动中表示，GPT-4 将在下周发布，将提供多模态模型。</p><p></p><p>&nbsp;Andreas Braun表示，我们将在下周推出 GPT-4，我们将有多模态模型，提供完全不同的可能性。Andreas Braun认为，大型语言模型是 “游戏规则的改变者”，因为它们教机器理解自然语言，然后以统计学方式理解以前只能由人类阅读和理解的内容。同时，该技术已经发展到了基本上 “适用于所有语言” 的程度。“你可以用德语问一个问题，得到意大利语的回答。通过多模态，微软/OpenAI 将 “使模型变得全面”。</p><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/2f/2f0a537dedc63e4985ea20739500a555.jpeg\" /></p><p></p><p>参考链接：</p><p></p><p>https://azure.microsoft.com/en-us/blog/chatgpt-is-now-available-in-azure-openai-service/?cdn=disable</p><p>https://www.engadget.com/microsoft-bing-crossed-100-million-daily-active-users-080138371.html</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU2OTY2OTQ0MA==&amp;mid=2247522146&amp;idx=1&amp;sn=07c9c67d31b6d5865387fe2d0bdef928&amp;scene=21#wechat_redirect\">https://mp.weixin.qq.com/s/oOgYn2ZtLwgiOAa3-BZMzQ</a>\"</p>",
    "publish_time": "2023-03-10 15:00:44",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Google开源Service Weaver，让你无需纠结到底选择单体还是微服务",
    "url": "https://www.infoq.cn/article/GeVe9RdwiVQkPWJlicui",
    "summary": "<p>事情总是这样，在单体和微服务哪个更好之间来回摇摆。</p><p></p><p>不同的人会给出不同的答案，因为他们的经历不同。但在大多数情况下，那往往取决于许多因素，比如公司规模，需要为之服务的流量，以及所提供的产品。</p><p></p><p>实际上，这两种方法都各有利弊。但是，如果可以两全其美呢？这就是谷歌开源这个新框架的目标，让我们来仔细了解一下！</p><p>&nbsp;</p><p></p><h1>Service Weaver是什么？</h1><p></p><p>&nbsp;</p><p><a href=\"https://opensource.googleblog.com/2023/03/introducing-service-weaver-framework-for-writing-distributed-applications.html\">Service Weaver</a>\"是谷歌开发的一个框架，目前处于早期开发阶段。这个框架是开源的，也就是说任何人都可以使用和贡献。目前，该框架只能用于 Go 开发，不过如果成功的话，就可以将这种方法复制到其他任何语言中。</p><p></p><p>这是一个构建分布式应用程序的框架，它的特点是：在本地作为一个模块化单体运行，但一旦部署，就会作为一个分布式微服务架构运行。</p><p>&nbsp;</p><p></p><h2>什么是模块化单体？</h2><p></p><p>&nbsp;</p><p>模块化单体是一种架构，整个架构被编写成单个应用程序，存储在单个代码库中。模块化的意思是，单体被分割成独立的组件，不同组件之间有清晰的接口。</p><p>&nbsp;</p><p>下面是一个例子：</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/38/385c75406db40d9ac5f09a2653480f99.png\" /></p><p></p><p>这是一个用Mermaid创建的模块化单体的例子。要学习更多关于Mermaid的知识，可以读下我写的这本书&nbsp;<a href=\"https://www.amazon.com/dp/1680509837?maas=maas_adg_265A9C302E256D26C2E10C30DA1AA728_afap_abs&amp;ref_=aa_maas&amp;tag=maas\">Creating Software with Modern Diagramming Techniques</a>\"。</p><p>&nbsp;</p><p>这个单体包括三个组件：订单、付款和配送。每个组件都实现了单体的一个特定部分。重要的是，每个组件的大部分都是私有的，组件之间的任何通信都是通过明确定义的接口进行的。</p><p></p><p>这样，组件内部的更改和更新不会影响任何其他组件，只要没有更改或破坏接口就行。</p><p></p><p>当多个团队共同开发一个单体时，这非常有助于设置清晰的团队边界，使每个组件的开发都独立于任何其他组件，而且组件之间的依赖关系很清晰。</p><p></p><p>单体在部署时是作为单个应用程序部署的，单体的每个实例会有单独的进程。例如，如果是部署到 AWS，那么单体的每个实例都将作为 EC2 实例上的一个进程运行。</p><p>&nbsp;</p><p></p><h2>Service Weaver与传统的模块化单体有何不同？</h2><p></p><p>&nbsp;</p><p>我们已经了解了什么是模块化单体。现在，我们来看一看，为什么 Service Weaver 不是一个构建标准模块化单体的框架。</p><p></p><p>在开发应用程序时，实际看起来与上面的示例没什么不同。使用 Service Weaver 构建应用程序时，也是在单个存储库中构建组件。如上所述，每个组件都定义了清晰的接口，用于支持不同组件之间的通信。</p><p></p><p>Service Weaver 与传统模块化单体的区别在于部署。在部署使用 Service Weaver 构建的应用程序时，不会部署成一个包含所有组件的大进程，在同一台机器上运行。</p><p></p><p>相反，每个组件都是作为微服务单独部署。这相当聪明，因为你可以将所有代码放在一个存储库中，轻松地在本地进行开发，同时还能获得运行分布式架构的好处——根据需要扩展每个组件，例如内存、CPU 和实例数量。</p><p></p><p>很漂亮，对吧？让我们看看 Service Weaver 是如何做到这一点的！</p><p>&nbsp;</p><p></p><h1>Service Weaver是如何工作的？</h1><p></p><p>&nbsp;</p><p>正如文章开头所提到的，Service Weaver 完全是用 Go 编写的，至少目前是这样。在构建应用程序时，必须将每个组件定义为一个接口。你可以将此看成是为给定组件定义公共 API，列出其他组件可以使用的方法。例如，反转字符串的组件可能是下面这样的：</p><p>&nbsp;</p><p><code lang=\"null\">type Reverser interface {\n    Reverse(context.Context, string) (string, error)\n}</code></p><p>&nbsp;</p><p>其他任何想要反转字符串的组件都可以调用这个反转组件，反转字符串的内部逻辑包含在反转组件中，是私有的。</p><p></p><p>然后像往常一样，你可以通过组件之间的方法调用来扩展组件。你完全可以在本地构建和测试它，而 Service Weaver 将处理组件之间的交互，将它们视为本地方法调用。</p><p></p><p>到目前为止，其他任何框架或单体都没有什么变化。</p><p></p><p>然而，一旦部署并作为独立的微服务运行，组件之间的调用就不能在本地进行了。相反，Service Weaver将在组件之间进行远程过程调用（<a href=\"https://en.wikipedia.org/wiki/Remote_procedure_call\">RPC</a>\"）。</p><p>&nbsp;</p><p>简单来说，它使用<a href=\"https://protobuf.dev/\">协议缓冲区</a>\"来序列化和反序列化组件之间传递的数据。你无需为此操心，因为所有这些都是在后台发生的。你不考虑微服务之间的网络调用，也不用管调用是在本地进行还是远程进行。</p><p>&nbsp;</p><p>代码方面，你可以按照自己习惯的方式编写代码，至于是本地调用还是远程调用由框架来处理。在上面的Reverser示例中，你的代码将只需调用Reverse，而不需要关心调用是在本地进行还是在远程进行。</p><p>&nbsp;</p><p></p><h2>使用Service Weaver组合微服务</h2><p></p><p>&nbsp;</p><p>为了增进理解，请看下图谷歌对不同部分如何组合在一起的说明：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/01/014281c51d84db40fc90c546187ad0f9.png\" /></p><p></p><p>&nbsp;Service Weaver 编程库从开发到执行的流程图</p><p>&nbsp;</p><p>下面我们看下 Service Weaver 的多面性。传统的微服务有一个缺点，就是经常会导致界面非常繁琐。毕竟，没有人能预见未来，也没有人能预见随着时间的推移架构会如何变化。</p><p></p><p>然后，你要么就忍受不断增加的延迟和不断提升的网络调用失败率，要么就花时间将这两个微服务融合起来。</p><p>&nbsp;</p><p>而 Service Weaver 解决了这个问题。上图中定义的 4 个模块，当部署为微服务时，你会注意到，A 和 B 是在一起的，C 和 D 则是单独的微服务。</p><p></p><p>使用 Service Weaver，你可以自由地定义将哪些组件部署在何处。你可以选择在单个微服务中同时运行多个组件，也可以将所有组件部署为单独的微服务。如果随着应用程序的演进，两个作为独立微服务运行的组件交互变得非常频繁，那么你可以很容易地将它们组合在一起，而不需要更改代码，只需要在 Service Weaver 中快速更改配置即可。</p><p>&nbsp;</p><p></p><h1>云部署选项</h1><p></p><p>&nbsp;</p><p>你可能想知道，Service Weaver 应用程序要部署到哪里。由于它是谷歌开发的，所以你可能会想，谷歌云是唯一的部署选项，而且无疑，它与 GCP 集成得很好。</p><p></p><p>不过，它任何云都支持，比如 AWS 或 Azure。它使用 TOML 文件来定义配置，我一直认为那很容易使用。下面是谷歌的另一副图，说明 Service Weaver 在不同环境下的工作情况：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/da/da3d31842fb838974ed598b675a28d0b.png\" /></p><p>Service Weaver Libraries 部署程序实施的流程图</p><p>&nbsp;</p><p>上图展示了如何构建应用程序及其组件，然后是一系列如何运行该应用程序的选项。你可以用 go run. 在本地运行它，或使用 weaver gke deploy 部署到云中。</p><p></p><p>目前似乎是 Kubernetes 部署，未来是否提供其他部署方案还有待观察。我认为，在底层，组件之间的通信大量使用了 Kubernetes。</p><p>&nbsp;</p><p></p><h1>如何使用Service Weaver</h1><p></p><p>&nbsp;</p><p>以上就是对 Service Weaver 的初步介绍，如果你想尝试一下，可以访问 Service Weaver 官方网站。</p><p></p><p>该网站提供了所需的所有内容，包括框架的架构、安装手册，当然还有入门用的“hello world“示例。</p><p></p><p>在我看来，这种方法很吸引人，解决了许多我们在单体和微服务之间做选择时需要考虑的问题。它是否能做到这一点还有待观察，但我很期待 Service Weaver 的发展！</p><p></p><h5>原文链接：</h5><p></p><p><a href=\"https://betterprogramming.pub/service-weaver-a-framework-from-google-for-balancing-monoliths-and-microservices-583e69b274dd\">https://betterprogramming.pub/service-weaver-a-framework-from-google-for-balancing-monoliths-and-microservices-583e69b274dd</a>\"</p><p></p><h5>相关阅读：</h5><p></p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;mid=2247557757&amp;idx=1&amp;sn=2694b825a027e7f0688c5d45ad03011b&amp;chksm=fa4b9dcccd3c14da7b9fc3682a49e491d57a9998b54b600ceea14c06152836ca3ce2b12124d9&amp;scene=27#wechat_redirect\">别再造轮子了，Google 开源的 Guava 工具库真心强大！</a>\"</p><p><a href=\"https://xie.infoq.cn/article/b1df213b3a6dfaacd94b73cd9\">Flutter - Google 开源的移动 UI 框架</a>\"</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NDkxMTgyNw==&amp;mid=2653073361&amp;idx=1&amp;sn=85a4b9a65f621d07b5da52571089b78e&amp;chksm=bd568ced8a2105fb3ead0f5b745d6c440d90fa307e80c6d0f03cf72f10d2ee516eafacc33022&amp;scene=27#wechat_redirect\">Google 强势开源 Carbon 语言，号称要替代 C++</a>\"</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&amp;mid=2247501594&amp;idx=3&amp;sn=2608b59c88847cba7737a94759dccbc2&amp;chksm=fbea7ed5cc9df7c3947561606c84542d368f2fd13c7a82f5a6424a8313db606b54a9e2143c5c&amp;scene=27#wechat_redirect\">谷歌开源框架 FUSS，让声音分离不再成为难题</a>\"</p>",
    "publish_time": "2023-03-10 15:18:33",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "全世界都在跟风ChatGPT，它的真正价值到底是什么？｜直播预约",
    "url": "https://www.infoq.cn/article/pkzVJ26fmHcY8evAGEvo",
    "summary": "<p></p><p><img src=\"https://static001.geekbang.org/infoq/57/57865d719f681f8384cd4540147a245f.jpeg\" /></p><p></p><p>ChatGPT“军备竞赛”已渐入高潮，尤其是大型科技公司间的 AI 竞赛日趋白热化。ChatGPT 爆火也让大模型卷了起来，已有多位 AI 大牛宣布杀入大模型领域创业。</p><p></p><p>上个月，InfoQ 发起了极客有约特别栏目之《极客圆桌派：狂飙的 ChatGPT 》，一起探讨了 ChatGPT 到底“是什么”和“为什么”的问题；</p><p></p><p>3 月 10 日，InfoQ 联合微软发起了《极客圆桌派：ChatGPT 点燃 AI 狂潮》直播，邀请了 4 位技术大咖再聊 ChatGPT。这一次，我们更聚焦 ChatGPT 的真正的最大价值。</p><p></p><p>我们试图回答这样一些问题：ChatGPT 到底能为企业和开发者带来什么？企业如何借力和追赶 LLM/ChatGPT 创造出实际的价值？ChatGPT 所卷起的 AI 大模型热潮将如何影响开发者和企业？ChatGPT 背后的伦理挑战和风险问题又该如何应对？</p><p></p><p></p><h4>主题介绍：</h4><p></p><p></p><p></p><h4>直播主题：</h4><p></p><p></p><p>《极客圆桌派：ChatGPT 点燃 AI 狂潮》</p><p></p><p></p><h4>直播时间：</h4><p></p><p></p><p>2023 年 3 月 10 日 20:15-22:15</p><p></p><h4>直播核心议题：</h4><p></p><p></p><p>ChatGPT 真正的最大价值是什么？企业和 LLM/ChatGPT 的关系哪些企业需要自己的 LLM，垂直行业如何应对？小语种如何应对 LLM 的冲击如何评判一个大模型？链接大模型与领域模型的方法为什么全世界都在“跟风”ChatGPT？风暴过去，什么会留下来？ChatGPT 在中国会出现吗？如果没有出现会怎样？从 ChatGPT 看负责任的生成式&nbsp;AI终局预测：会有几个大模型一统江湖？</p><p></p><p></p><h4>嘉宾介绍</h4><p></p><p></p><p>主持 &amp; 嘉宾</p><p></p><p>Mingke，MRS.ai 联合创始人兼 CEO 。组建面向未来的智能网络，《人工智障》系列作者。</p><p></p><p>圆桌嘉宾：</p><p></p><p>李争，微软 (中国) 有限公司技术顾问。专注于微软公有云平台 Azure 的解决方案和架构设计、Azure 应用的实施，以及 Azure 上的开源技术等工作。曾在微软企业服务区作为原厂技术支持工程师工作多年，承担企业开发者代码调试和技术支持、Web 应用前端后图案代码跳优，一级级 IIS 的问题诊断、跳优、培训等工作。具有丰富的企业客户临场解决严重系统问题的经验。拥有四十多门微软认证证书，涵盖了几乎全部微软开发相关技术，同时也是一位具有十多年丰富授课经验的微软认证讲师 (MCT)。</p><p></p><p>郝杰，明略科技集团首席技术官（CTO）。毕业于清华大学，曾先后担任东芝（中国）首席科学家、五八集团技术专家和 OPPO 语音语义首席科学家，主导研发成功了国内早期量产的个人语音助理、汽车前装语音导航，世界上早期量产的电视机语音唤醒、离线口语翻译手机软件等，曾带领团队多次获得 WMT、IWSLT、CCMT、Blizzard Challenge、SemEval、VoxSRC、AISHELL 等 AI 领域的比赛和 leaderboard 的第一名。</p><p></p><p>张大卫，竞智科技 GamesMind 创始人 &amp;CEO。毕业于北京大学，曾任微软亚洲研究院研究员，研究领域包括自然语言处理、知识图谱、推荐系统等，曾负责微软概念知识图谱和微软下一代广告系统。</p><p>如何看直播？</p><p></p><p>扫描下图海报【二维码】，预约 InfoQ 视频号，直播开始有提醒。</p><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/6c/6c3c490e615df6cac7188a9dc2bf64c1.png\" /></p><p></p><p></p><h2>如何向讲师提问？</h2><p></p><p></p><p>点击：https://www.infoq.cn/form/?id=907 填写提问表单，讲师会在直播中为你解答。</p><p></p><h2>更多福利</h2><p></p><p></p><p>除了分享干货，直播进行中，我们会在参与直播的同学安排幸运观众抽奖福袋，赠送定制无线充电器敬请期待哦～</p><p></p><p>欢迎大家加入 InfoQ AIGC 微信群，社群将定期分享关于 AIGC 技术领域的各种资源，包括最新的研究成果、技术趋势以及来自领域专家的专业见解。除此之外，我们还会举办线上技术交流活动，让大家可以更深入地了解这个领域的最新动态和趋势。</p><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/32/32a40e4427564205db9a2aeb174c0433.png\" /></p><p></p><p></p><p><a href=\"\">阅读原文</a>\"</p>",
    "publish_time": "2023-03-10 15:26:29",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "“鼎新杯”案例精选 | 中国联通数字化研发低代码平台为一线赋能",
    "url": "https://www.infoq.cn/article/1e77db09f145c68809c8b9404",
    "summary": "<p></p><h4>引言</h4><p></p><p></p><blockquote>在2022年举办的首届“鼎新杯”数字化转型应用征集活动中，中国联通软件研究院在数字技术创新专题，共有7个案例分别斩获一二三等奖，并被收录到《鼎新杯数字化转型应用案例汇编》中。本文选取“中国联通数字化研发低代码平台”进行展示。该平台的使用大大加快了业务交付效率，为一线人员进行数字技术赋能，在集团、子公司、省分广泛应用，并获得了多方好评。</blockquote><p></p><p></p><p></p><h3>一、新挑战：业务集约化后如何快速响应大量个性化业务需求？</h3><p></p><p>近年来，联通集团各省分公司大力推行各类集约模式，将原先碎片化、分散于一线部门的专业岗位统一集中到省一级，而一线部门则主要承担市场销售职责。</p><p>在推行过程中，由于业务受理岗位与客户经理分属不同部门和不同层级，因此各省分公司的线上协同需求大量产生，而同时发现标准系统只能支撑集团统一的核心业务，这就导致大量省级业务、非核心业务个性化需求集中爆发。</p><p>&nbsp;</p><p>原有IT管理模式难以快速响应，出现支撑不充分、不到位、不敏捷等问题，一线需求和研发瓶颈形成尖锐矛盾。以业务受理集约为例，联通有31个省分公司，每个省有数百款产品，且各省之间的个性化产品属性、业务流程、管理模式都存在差异，如果用纯代码的开发方式来应对这类个性化产品的集中开发，那将是个极度庞大、复杂的工程。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/4d/4d792b8ac266ec60d9b0cbb09631016e.png\" /></p><p></p><h3>二、低代码平台满足业务快速交付需求</h3><p></p><p>基于以上挑战和需求，中国联通软件研究院开发了中国联通数字化研发低代码平台，为企业人员提供了一个集流程、架构、运维、工具一体化的云原生低代码智能化平台。</p><p>&nbsp;</p><p>该平台可以配置业务单据、工作流、业务规则，能够可视化地与联通内部的其他核心业务系统进行低代码的集成、调度，改变生产流程和模式，以数字化的方式驱动生产要素按需组织，实现敏捷、灵活、高质量的端到端业务受理全流程支撑。</p><p>&nbsp;</p><p>低代码平台向上连接前端的行业业务，向下连接云计算的海量能力，以云开发作为底层支撑。云原生能力将应用搭建的全链路打通，提供高度开放的开发环境，提供了应用开发的一站式低代码开发服务，帮助用户专注于业务场景，快速搭建应用，助力数字化转型。</p><p>&nbsp;</p><p></p><h3>三、中国联通数字化研发低代码平台架构</h3><p></p><p>中国联通数字化研发低代码平台包含工作台和管理控制台，工作台用于创建应用、可视化设计、应用发布等，包括模型与对象设计、表单设计、页面设计、流程设计、图表设计等；管理控制台是专为平台、组织和应用管理而设计的一体化运维管理平台，包括对应用内部的权限体系控制等。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/26/26f6e34dfedc645ecfd8d323da8a84b2.jpeg\" /></p><p></p><p>模型设计：进行应用模型的创建维护。模型与实体关联，用户可自行设计表的属性、字段、索引并预览；对象设计：通过选择模型、设置关联关系，实现领域模型的代码映射，支持灵活的规则配置与控制；页面设计：通过拖拽式的方式设计页面，多页面布局选择、多控件可配、多样式可定义；流程设计：提供了对页面流转的审批控制，将流程图与表单进行关联，设置任务参与者实现不同的申请和审批；图表设计：提供对大屏可视化的设计支持，丰富的可视化组件，设置数据联动，快速生成数据的可视化，方便敏捷决策。</p><p></p><h3>四、中国联通数字化研发低代码平台特点</h3><p></p><p>低代码平台为传统企业数字化转型提供工作模式的创新，通过低代码，降低技术门槛，提升研发效能，赋能一线人员忽略代码编写过程，聚焦业务，完成场景快速实现，并通过原子化的持续集成持续部署工具对接底层云平台，加快应用的开发部署进程。</p><p>&nbsp;</p><p>打通联通内部核心系统，一线人员快速上手</p><p>能够可视化地与联通内部核心业务系统进行低代码的集成、调度，改变生产流程和模式，解决业务人员缺乏代码知识的问题，赋能一线人员快速构建应用，实现数字化互动能力从总部到省分，从组织到个人。</p><p>&nbsp;</p><p>支持低代码化的CICD（持续集成于持续部署）</p><p>提供将各个功能节点抽象为独立原子并输出创建原子的能力，可根据实际情况创建符合场景需要的原子，不再受制于流水线原子所提供功能的局限，缓解编写Pipeline脚本压力（该部分产生2篇专利）。</p><p>&nbsp;</p><p>支持低代码化的编排部署</p><p>提供对生成应用的资源管理文件编写的文件模版，在不具备编写YAML文件能力下，可通过模版配置实现对资源对象的编排部署。</p><p>&nbsp;</p><p></p><h3>五、中国联通数字化研发低代码平台应用成效</h3><p></p><p>中国联通数字化研发低代码平台以服务支撑好运营商特色IT需求为使命，在降低开发门槛的同时，聚焦业务场景，孵化出符合联通不同业务场景的低代码开发模板，实现业务的快速导入投产，帮助个性化需求不再定制开发，业务人员无代码配置即可自助上线使用，流程需求的 IT 支撑周期由原来的数月缩短到分钟级，全面赋能全集团全面数字化转型。</p><p>&nbsp;</p><p>目前，低代码已累计多次省分培训推广，在集团、子公司、省分广泛应用，多项应用支撑，尤其在联通政企业务线，其中累计加载政企业务86项，占联通政企中台支撑业务总数的44%。均运行良好，无故障产生，无投诉产生，收到多个省分子公司的一致好评、多封表扬信。</p><p>&nbsp;</p><p>以联通政企业务线的两个应用实例为例，截止2021年底，通过“销售服务业务”低代码开发模板支撑的政企业务达84款，月均出账160万+，全年估算累计收入1920万。以常规政企业务销售模块的需求、研发、测试全流程工作量平均2人月估算，预计提升2倍研发效能，估算节约研发成本250万。</p><p></p><p></p><h4>关于 “鼎新杯”数字化转型应用征集</h4><p></p><p>“鼎新杯”数字化转型应用征集活动，以落实国家“十四五”规划关于“加快数字化发展，建设数字中国”的总体要求为目的，意在打造一批具有产业引领与推广应用效应的企业数字化转型应用示范案例。</p><p>&nbsp;</p><p>首届活动于2022年3月正式启动，由中国信息通信研究院与中国通信企业协会联合主办，云计算与大数据研究所政企数字化转型部承办，2023年第二届“鼎新杯”数字化转型应用征集活动将于3月21日正式启动，敬请期待！</p><p></p><p>说明：</p><p>为进一步探讨交流数字化转型相关话题，我们建立了微信群，您可添加董老师微信号，注明身份后，申请加入。</p><p>联系人：董老师&nbsp; 13810413143（微信同号）</p><p></p><p></p><p></p>",
    "publish_time": "2023-03-10 15:35:18",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]