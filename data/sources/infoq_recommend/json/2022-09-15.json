[
  {
    "title": "高管空降数字化，怎样应对局面？ | 第三期完整版（中）",
    "url": "https://www.infoq.cn/article/UipwTesLtZvD0hmAIr3f",
    "summary": "<p>《行知数字中国》第三期，InfoQ邀请到了过去30年亲历过中美高科技行业、零售业、金融业和制造业等不同行业的 IT 老兵向江旭。</p>\n<p>他曾在引领科技创新潮流的硅谷深耕技术研发，回国后赶上中国蓬勃发展的移动互联网时代，又以技术管理者的身份亲历了数家企业的数字化转型历程，在一次次跨越边界、不断探索的过程中，他对”数字化转型“的理解始终如一。在本期视频中，他将结合其亲身经历，分享数字化转型和创新的经验和教训。</p>\n<p>本视频为第三期完整版的（上）集。</p>",
    "publish_time": "2022-09-15 00:06:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "如何通过业务集成中心简化系统集成",
    "url": "https://www.infoq.cn/article/RzI87zDlJ3Gi6ha3lSs2",
    "summary": "<p>如果你问一个小学生如何解决代数问题，他们会告诉你从化简开始。对于大多数数据集成问题，我们从一开始就让数据变得太过复杂——我们使用了基于标准的XML格式，这看起来似乎很奇怪。</p><p></p><p>来自<a href=\"https://www.merge.dev/\">Merge.dev</a>\"、<a href=\"https://www.codat.io/\">Codat.io</a>\"、<a href=\"https://www.stedi.com/\">Stedi.com</a>\"等公司的新一代集成工具与这种趋势背道而驰，我非常喜欢他们的解决方案。这些集成工具简化了大多数常见业务数据对象（供应商、客户、员工、票据等）的数据模型，并提供了从流行的软件包（或EDI、电子数据交换、Stedi的格式）中获取数据的连接器，并将其转换为简化的模型。</p><p></p><p>这将使你的集成工作变得更容易，因为你不需要了解每个系统的特性，可以专注于将数据从一种简化格式转换为另一种格式。</p><p></p><p>这种新型集成公司与之前的公司之间的关键区别在于，它们不仅仅是从一个系统到另一个系统的管道，而实际上是以一种简化的格式转换和存储你的数据。你可以不将其视为管道，而将其视为一个中心，它将数据从源系统同步到简化数据中心，再从简化数据中心同步到目标系统。</p><p></p><p>这种“枢纽”极大地改变了集成的经济模式。如果我们只是将其与中心辐式机场模型和点对点机场模型之间的效率效益差异作为类比，实际上低估了中心辐式集成方法的优势。</p><p></p><p>Merge和Codat称自己为通用或统一的API，而Stedi将自己视为构建通用API的工具，但为了强调他们的解决方案和这些解决方案所产生的效率之间的联系，我将在本文中称它们为业务集成中心。</p><p></p><p>本文研究了业务集成中心的出现、这种解决方案的好处和风险，并简要介绍了其中三个案例，并评估了这种解决方案的竞争和未来。</p><p></p><h2>集成的四个阶段</h2><p></p><p>我认为我们目前正处于集成工具发展的第四个阶段。</p><p></p><p>这四个阶段（彼此之间存在重叠）是：</p><p></p><p>直接集成；定制的管道；API/连接器；转换。在第一阶段（直接集成），直接通过编写针对数据库的SQL查询来连接内部系统，并使用XML或文本分隔标准（如cXML、X12 EDI和OASIS）与客户和供应商系统集成。集成项目只适用于具有大量事务和大量持续手动工作的系统。</p><p></p><p>下一阶段（定制管道）见证了Snaplogic、Jitterbit、Talend等公司的崛起，这些公司通过编写定制的集成管道从遗留系统中推送和提取数据。</p><p></p><p>从这里开始，出现了两条平行的路径，它们都与API有关。一方面，企业开始使用Mulesoft等软件在托管系统上公开API端点。另一方面，Zapier、Tray.io和n8n.io等公司开始将API端点放在SaaS软件上。</p><p></p><p>我们现在处于转换阶段。在这个阶段，参与前几个阶段集成的公司正在构建它们的转换能力，以加速集成。认证和连接器不再是集成系统中最耗时的部分——最耗时的部分是将数据从一个系统转换为适合放入另一个系统的格式。Tray.io和n8n.io正在构建非常好的数据转换能力，使得连接两个系统的速度比以往任何时候都要快。</p><p></p><p>业务集成中心在这方面更进一步，对于许多集成任务，你不需要进行任何数据转换，即使不得不自己进行转换，也只需要从一个简化的数据格式开始，并将其转换为另一个简化的格式。</p><p></p><p>Stedi.com可能是最好的例子。你可能已经猜到，Stedi是一个EDI数据转换系统。他们构建了一个工具，可以将EDI数据转换成JSON文档，然后再转换回来。这是一个相当令人难以置信的壮举，因为EDI数据格式看起来非常枯燥，而且处理起来非常困难。因此，与其浪费时间学习每种EDI文档中的片段是怎么回事，还不如使用它们的工具或你喜欢的编程语言开始编写转换。</p><p></p><p></p><blockquote>“在Stedi，我们为开发人员提供了定义他们自己模式的工具，这些模式符合（有时也不符合）各种EDI标准。例如，<a href=\"https://www.stedi.com/docs/guides\">Stedi Guides</a>\"帮助开发人员定义他们自己对X12 EDI 810（票据）的‘看法’，并基于该结构构建他们自己的集成。现在，用户可以构建系统，以相同的EDI标准与几乎任何贸易伙伴通信，而不管他们内部使用的是什么系统或API。” ——David Kanter，<a href=\"https://www.stedi.com/\">Stedi.com</a>\"客户运营</blockquote><p></p><p>Merge.dev和Codat正在解决问题的不同部分。他们为大多数通用财务文档定义了JSON模式，并建立了连接到不同源系统的工作流。完成这些工作后，他们现在正在构建自己的连接器，以覆盖尽可能多的系统。</p><p></p><h2>好处</h2><p></p><p>使用业务集成中心的最大好处是，一旦将事务系统连接到集成中心，与多个系统集成就变得很简单了。如果你将Netsuite作为财务套件，将Salesforce作为CRM，将BambooHR作为人力资源系统，那么你可以将所有这些连接到你的集成中心，并轻松地在它们之间交换数据。当然，所有这些都可以通过像Tray.io或n8n.io这样的点对点集成工具来实现，但将所有数据存储成通用的简化模型会使这一切变得更加容易。</p><p></p><p>为了更好地理解这些好处，我们以中心辐式机场模型的经济效益作为类比。航空公司在很大程度上是按照中心枢纽的方式组织起来的。当你从田纳西州的纳什维尔飞往新墨西哥州的阿尔伯克基，你无法乘坐直飞航班，你必须经过达拉斯枢纽（美国航空公司）或丹佛枢纽（联合航空公司）。这是因为从纳什维尔到阿尔伯克基的客流量不足，无法使航空公司在经济方面无法直接建立和运营这条航线。但是，他们可以把所有从许多城市前往阿尔伯克基的乘客带到枢纽，然后就可以很容易地在枢纽和阿尔伯克基之间每天提供几次航班。系统集成的原理与之相同。在系统之间建立良好的管道是非常耗时的，使用中心枢纽总会带来经济优效益势。</p><p></p><p>如果说集成中心和机场中心枢纽之间的类比存在突破点，那应该表现在集成中心的优势方面。当你乘坐飞机时，你总是希望选择中途停留次数最少的航线。而在系统集成的世界里，这个并不重要。是直接将数据从源格式转换为目标格式，还是在两者之间使用简化表示，这通常是个个人喜好问题。作为一个做过大量集成的人，我发现将数据从源格式转换为更简单的格式，然后再从更简单的格式转换为目标格式比直接进行转换更容易。</p><p></p><p></p><blockquote>集成两个系统最困难的部分是映射和转换数据。解决这个问题的关键是标准化，这就是为什么我们花费数年时间在一些最复杂的财务数据领域（会计和商业）改进我们的数据模型。这是我们的用户能够真正感知到我们所提供的价值和质量的地方。—— Dave Hoare，Codat公司首席技术官兼联合创始人</blockquote><p></p><p></p><h2>风险</h2><p></p><p>但这些好处也伴随着两个重大风险：</p><p></p><p>你所有的数据现在都在一个地方，它们安全吗？你的数据存储成简化的模型，这些能够满足你的需要吗？如果大中型企业开始使用业务集成中心，它们需要确保数据治理和安全性。以下是Merge.dev对这个问题的看法：</p><p></p><p></p><blockquote>“保持数据安全不是一件简单的事情。我们有义务向客户证明，我们不仅保护了他们的数据，而且遵守了世界各地的各种法规。Merge对静止和传输中的数据进行加密，然后使用存储在外部服务中的密钥再次加密。我们还将欧盟和美国的数据存储在完全隔离的环境中，以确保我们的客户能够遵守GDPR。”—— Gil Feig，<a href=\"https://www.merge.dev/\">Merge.dev</a>\"联合创始人</blockquote><p></p><p></p><h2>竞争</h2><p></p><p>集成中心解决方案很有意义，但这并不意味着早期玩家最终会成为赢家。他们将面临以下类型公司的竞争。</p><p></p><p>现有集成公司，如tray.io和n8n.io。微软Azure、谷歌云平台、亚马逊云科技等云平台。Snowflake等数据湖公司；RPA公司，如AutomationAnywhere和UIPath。</p><p></p><h2>这是一个赢家通吃的类别吗</h2><p></p><p>我们不认为集成中心（每个企业都必须成为集成中心的一部分）会是一个赢家通吃的类别。当然，在每个集成中心中都有网络效应在起作用，但它们很弱。例如，如果你的几个贸易伙伴使用特定的集成中心，并且你使用了相同的集成中心，那么与他们集成就会更容易。但集成中心的竞争对手之间也会有相通的路径，所以这可能不会有太大影响。</p><p></p><p>例如，我们可以很容易地想象未来美国的一家五金连锁店采用Stedi作为他们的EDI平台。如果供应商1使用Codat集成中心，他们可以将连接Codat到Stedi。如果供应商2使用Merge.dev集成中心，他们也可以很容易地连接到Stedi。而且，如果供应商1和供应商2想要一起做一些联合营销，他们将能够在Codat和Merge.dev之间同步他们的CRM数据。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/business-system-integration/en/resources/3figure-1-1660901938176.jpg\" /></p><p></p><h2>来自现有集成供应商的竞争</h2><p></p><p>现有的集成公司，如Tray.io和n8n.io将是集成中心要面对的第一批竞争对手（尽管集成中心处理的本质上只是Tray或n8n.io的一个子集）。这几乎是一个哲学问题，是在不同的系统之间进行点对点集成更好，还是将数据同步到集成中心并利用它们的现有连接更好？</p><p></p><h2>云平台竞争对手</h2><p></p><p>每一家SaaS公司都需要评估一下，如果大型云服务提供商（微软Azure、谷歌云平台和亚马逊云科技）取得成功，它们会有何反应。</p><p></p><p>除了微软可能有点例外，我们不认为这三大云平台会在这个领域扮演重要角色。对于它们来说，这些位于技术栈的上层，所以它们服务不好，这一点可以通过Azure的Dataverse和亚马逊云科技的Appflow看出来。</p><p></p><p>微软Dataverse是一个位于SQL Server数据库之上的层，它定义了常用的表，如供应商、客户、票据和账单。当它第一次出现时，我非常兴奋，但实际上，它并不比实际编写SQL查询容易多少。</p><p></p><p>亚马逊云科技的Appflow是AWS集成服务的起点。看起来它将成为SaaS系统之间非常健壮的管道，但它没有将任何模式强加到集成上，而是将其留给了最终用户。这对于某些场景来说很好，但对于集成中心应用场景来说却不是。</p><p></p><p>GCP的解决方案让我感到困惑（Trifacta、Cloud Composer、Workflow、AA等），所以我把它留给读者来解释给我听:)</p><p></p><h2>Snowflake</h2><p></p><p>Snowflake公司在打造真正的集成中心方面处于非常有利的位置。直到最近，Snowflake公司还在专注于分析数据而不是运营数据，但他们最近发布的Unistore公告表明，他们正在向事务性存储解决方案迈进。Snowflake最大的挑战是专注。在吮吸了多年大型企业的乳汁后，他们会考虑销售面向中小企业的产品吗？</p><p></p><h2>RPA</h2><p></p><p>RPA（机器人过程自动化）软件在过去的十年中发生了很大的变化。RPA不仅仅是一种使用用户界面让数据出入遗留系统的方法，它现在也是一种完全成熟的集成工具。</p><p></p><p>为了成为一个可靠的业务集成中心，他们有一些有利的因素。首先，他们有大型的开发者社区，每天与标准的业务数据对象进行交互，如客户、供应商、票据、工单等。这个开发社区对数据从一种形式转换到另一种形式的过程有着深刻的理解。其次，RPA公司的市场提供了一种方式来分发由社区开发的连接器，甚至是为社区构建连接器提供补偿。</p><p></p><p>但是，与Snowflake一样，销售和分发可能会是一个问题。对于RPA销售团队来说，与集成中心展开竞争可能需要迈出非常大的一步。</p><p></p><h2>挑战</h2><p></p><p>除了上面提到的风险之外，最大的挑战在于如何在易用性和处理大多数集成场景的复杂性之间游走。任何看过“Hello World”教程的人都知道，技术可能看起来很简单，但随着你不断深入，会很快变得非常难。我对集成中心的建议是——让简单的事情变简单，并为更专业的用户提供更多功能，让他们为你完成困难的事情。</p><p></p><p>一个很好的例子就是Merge.dev最近宣布的直通功能。如果你的会计数据位于Merge.dev中，并且需要连接到Merge.dev的财务系统，但你需要的端点尚未为Merge.dev做好配置，你仍然可以使用它们的身份验证功能，但要带上自己的连接器。</p><p></p><h2>未来</h2><p></p><p>作为一种集成模式，集成中心的未来看起来很光明。对于大多数集成任务（在某些情况下进行立即集成，在不可能进行立即集成时进行简化转换）来说，以简化的格式存储数据的好处是不可忽视的。渐渐地，集成工作将是在集成中心之间进行，而不是在软件系统之间。</p><p></p><p>时间会告诉我们当前这些集成中心最终是否会取得成功，但使用业务集成中心的经济效益肯定会显现出来。</p><p></p><p>作者简介：</p><p></p><p>Doug Hudgeon是Managed Functions的首席执行官。这是一家集成公司，专门帮助SaaS公司扩展集成能力。Managed Functions是解决方案无关的，它会根据客户的需求为每个作业选择最好的工具。他也是Manning《商业机器学习》一书的合著者。</p><p></p><p>原文链接：</p><p></p><p><a href=\"https://www.infoq.com/articles/business-system-integration/\">Business Systems Integration is About to Get a Whole Lot Easier</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/qrvLruwaMWIeoz2zbrdI\">InfoQ 2022 年趋势报告：DevOps 与云计算篇</a>\"</p><p></p>",
    "publish_time": "2022-09-15 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "【精通内核】Linux内核写锁实现原理与源码解析",
    "url": "https://www.infoq.cn/article/ae8840310d31b7aaa68224a8c",
    "summary": "<p></p><blockquote>前言📫作者简介：<a href=\"https://www.infoq.cn/u/xiaoming/publish\">小明java问道之路</a>\"，专注于研究计算机底层/Java/Liunx 内核，就职于大型金融公司后端高级工程师，擅长交易领域的高安全/可用/并发/性能的架构设计📫&nbsp;🏆 InfoQ 签约博主、CSDN 专家博主/Java 领域优质创作者/CSDN 内容合伙人、阿里云专家/签约博主、华为云专家、51CTO 专家/TOP 红人 🏆🔥如果此文还不错的话，还请👍关注、点赞、收藏三连支持👍一下博主~</blockquote><p></p><p></p><p></p><h1>本文导读</h1><p></p><p>Linux内核读锁实现原理，描述自旋锁时，已经顺带描述了读写自旋锁，所以本节将不再描述自旋锁的读写锁实现。读者是否能想到，既然自旋锁有相关的读写锁实现，信号量也应该有呢？答案是一定的。所以可以到，读写锁实际上是在原有锁上进行优化读写的操作。下面讨论源码实现。</p><p></p><h1>一、Linux内核读写锁核心结构解读</h1><p></p><p>定义一个结构体rw_semaphore代表读写信号量，然后义一宏定义表明读写信号量的偏移值。具体源码如下。</p><p><code lang=\"c\">struct rw_semaphore{\n    // 符号长整型，看到long类型，读者就知道，这又是将一个long类型长度大小切割成不同部分来使用的\n    // 由于使用i38632位来作为例子，因此这里long为32位，同样我们分割为高16位和低16位来使用 \n    signed long count;\n    \n    #define RWSEM UNLOCKED VALUE 0x0000 0000   // 无锁状态值为0\n   \n    #define RWSEM_ACTIVE_BIAS 0x0000 0001   // 锁活动偏移值1\n    \n    // 锁活动位数为4(4个16进制)*4(一个16进制等于4个二进制)=16，即2^16次方个锁位\n    #define RWSEM ACTIVE MASKOx0000 ffff\n    \n    #define RWSEM_WAITING BIAS(-0x00010000)  // 锁等待偏移量，即 0xffff 0000\n\n    #define RWSEM ACTIVE READ_BIASRWSEM_ACTIVE_BIAS // 读锁偏移量\n\n    // 写锁偏移量0xffff0001 为负数\n    #define RWSEM ACTIVE WRITE BIAS (RWSEM_WAITING_BIAS+RWSEM_ACTIVE_BIAS)\n    \n    spinlock twait_lock;    // 保护等待链表的自旋锁\n    struct list_head wait_list;// 等待链表\n};\n\n//等待读写信号量的任务结构体 \nstruct rwsem_waiter{\n    struct list_head list;\n    \n    struct task_struct*task;\n    unsigned int flags;// 标志位声明为等待读锁还是写锁\n\n    #define RWSEM_WAITING_FOR_READ 0x00000001\n    #define RWSEM_WAITING_FOR_WRITE 0x00000002\n};</code></p><p></p><h1>二、Linux内核获取写锁源码解读</h1><p></p><p>首先原子性减0xffff0001，然后判断原来的状态是否为 0，如果是，则表明获取写锁成功；</p><p>否则需要调用 rwsem_down_write_failed 函数进行阻塞排队操作。</p><p><code lang=\"java\">static inline void_down_write(struct rw_semaphore *sem) {\n    int tmp=RWSEM_ACTIVE_WRITE BIAS; \n    _asm__volatile_(\n        //原子性减0xffff001即写锁偏移量，返回旧值被放到edx寄存器中 \n        LOCK_PREFIX\" xadd %%edx,(%%eax)\"\n        \n        //查看之前的count值是否为0，因为只有为0，才是无锁状态\n        \" testl %%edx,%%edx\"\n        \n        //如果不为0，则获取锁失败跳到标号2处执行\n        \" jnz 2f\"\"1:\"\n        LOCK_SECTION_START(\"\")\n        //保存ecx，然后调用rwsem_down_write_failed进行阻塞排队操作\n        \"2:\"\n        \" pushl%%есx\"\n        \" call  rwsem_down_write failed\"\n        \" popl%%eсx\"\n        \" jmp1b\"\n        LOCK_SECTION_END\n        : \"=m\"(sem-&gt;count), \"=d\"(tmp)\n        : \"a\"(sem)，\"1\"(tmp), \"m\"(sem-&gt;count)\n        : \"memory\", \"cc\");\n}\n\n// 处理写锁上锁失败逻辑\nstruct rw_semaphore *rwsem_down_write_failed(struct rw_semaphore *sem) {\n    // 创建等待节点\n    struct rwsem waiter waiter;\n    waiter.flags=RWSEM WAITING FOR WRITE;\n    // 调用公共处理逻辑执行等待操作。-RWSEM ACTIVE BIAS =Oxffff fff \n    rwsem_down_failed_common(sem,&amp;waiter,-RWSEM_ACTIVE BIAS); \n    return sem;\n}</code></p><p></p><h1>三、Linux内核释放写锁源码解读</h1><p></p><p>首先将锁状态变为无锁状态，如果发现有任务正在等待唤醒，那么调用rwsem_wake 唤醒等待的任务</p><p><code lang=\"c\">static inline void_up_write(struct rw_semaphore *sem) {\n    _asm__volatile_(\n        \" movl %2,%%edx\" // 将写锁偏移量取负数后的值，即0x0000 ffff 放入edx中\n        // 尝试从Oxffff0001(持有写锁且无等待任务的状态，因为写写、读写互斥)变为 0x00000000 \n        LOCK PREFIX\" xaddl %%edx,(%%eax)\"\n        \" jnz 2f\"//如果之前count值不为0，则有任务正在等待，跳到标号2处执行\n        \" 1:\"\n        LOCK_SECTION_START(\"\")\n        \"2:\"\n        // 对dx也就是释前的lock值低16位自减，看看是否为0，即看看是否有活动的任务 \n        \" decw %%dx\"\n        // 如果不为0，则表示写锁被释放后有任务获得了锁，退出;\n        // 否则，调用rwsem_wake唤醒等待任务\n        \" jnz 1b\"\n        \" pushl%%ecx\"\n        \" callrwsem_wake\"\n        \" popl%%eсx\"\n        \" jmp1b\"\n        LOCK SECTION END\n        : \"=m\"(sem-&gt;count)\n        : \"a\"(sem), \"i\"(-RWSEM_ACTIVE_WRITE_BIAS),\"m\"(sem-&gt;count)\n        : \"memory\", \"cc\", \"edx\");\n}\n</code></p><p></p><h1>四、Linux内核读写锁锁降级源码解读</h1><p></p><p>有时候我们需要在获取到写锁后，进行降级为读锁，这可以通过 downgrade_write 方法进行锁降级有先原子性的降锁状态从写锁状态置为读锁状态，如果结果小于0，则表明有任务正在等待被唤醒，此时可以调用rwsem_downgrade_wake 函数唤醒等待读锁的任务，因为此时写锁已经被释放，可以让等待读锁的任务一起并行执行。</p><p><code lang=\"c\">// 写锁降级为读锁\nstatic inline void___downgrade_write(struct rw_semaphore*sem) {\n    _asm__volatile_(\n        LOCK PREFIX\" addl %2，(%%eax)\"//将状态从0xZZZZ0001变为0xYYYY0001\n        // 如果小于0，即锁正在等待被释放，则跳到标号2处执行rwsem_downgrade_wake函数，降级唤醒操作\n        \" js 2f\"\n        \"1:\"\n    LOCK_SECTION_START(\"\")\n        \"2:\"\n        \" pushl%%ecx\"\n        \" pushl%%edx\"\n        \" callrwsem_downgrade_wake\"  // 调用rwsem_downgrade_wake 函数\n        \" popl%%edx\"\n        \" popl%%есx\"\n        \" jmp1b\"\n    LOCK_SECTION_END\n        : \"=m\"(sem-&gt;count)\n        : \"a\"(sem), \"i\"(-RWSEM_WAITING_BIAS), \"m\"(sem-&gt;count): \n        : \"memory\", \"cc\");\n}\n\n\n// 接下来查看rwsem_downgrade_wake 函数实现过程。\nstruct rw_semaphore*rsem_downgrade_wake(struct rw_semaphore*sem){\n    // 获取自旋锁\n    spin_lock(&amp;sem-&gt;wait lock);\n    // 如果等待队列不为空，那么调用_rwsem_do_wake函数唤醒\n    // 注意，这里传入为0，表明只唤醒读任务 if(!list_empty(&amp;sem-&gt;wait list))\n    sem=___rwsem_do_wake(sem,0); // 释放自旋锁\n    spin_unlock(&amp;sem-&gt;wait lock); \n    return sem;\n}</code></p><p></p><h1>五、Linux内核读写锁唤醒线程过程</h1><p></p><p>首先获取保护等待队列的自旋锁，然后检测队列是否为空，如果不为空，那么调用 rwsem_do_wake 函数唤醒等待的任务。</p><p><code lang=\"c\">struct rw_semaphore *rwsem wake(struct rw semaphore*sem) {\n    spin lock(&amp;sem-&gt;wait lock); // 获取自旋锁\n    // 如果等待链表为空，则什么也不做，否则调用rwsemdo wake函数唤醒任务 \n    // 注：这里传入为0，表名只唤醒读任务\n    if(!listempty(&amp;sem-&gt;wait list)) \n        sem =_rwsem_do_wake(sem，1);// 1表明唤醒写任务 \n        spin_unlock(&amp;sem-&gt;wait_lock); \n        return sem;\n}\n\n// 真正唤醒流程\nstatic inline struct rw_semaphore*__rwsem_do_wake(struct rw_semaphore *sem,int wakewrite) {\n    struct rwsem waiter *waiter; \n    struct list head *next; \n    signed long oldcount; int woken, loop;\n    // 如果不唤醒写任务，那么直接跳转到 dont_wake_writers执行 \n    if(!wakewrite)\n        goto dont_wake_writers; \n    try again:\n    oldcount =rwsem_atomic_update(RWSEM_ACTIVE_BIAS,sem)-RWSEM_ACTIVE_BIAS;\n\n    // 如果之前count与上RWSEM_ACTIVE_MASK不为0，也就是还有活动的任务，则还原修改之前的值\n    if (oldcount &amp; RWSEM_ACTIVE_MASK)\n        goto undo;\n\n    // 否则取出下一个等待任务，如果下一个等待的任务不是一个写任务，那么调用readers_only\n    //函数唤醒读任务\n    waiter =list_entry(sem-&gt;wait_list.next,struct rwsem_waiter,list); \n    if(!(waiter-&gt;flags&amp;RWSEM_WAITING_FOR_WRITE))\n        goto readers_only;\n\n    //否则将写者从队列中移出，修改 flags 为0，调用wake_up_process函数唤醒任务，并且退出 \n    list_del(&amp;waiter-&gt;list); \n    waiter-&gt;flags =0;\n    wake_up_process(waiter-&gt;task);\n    goto out;\n\n不唤醒写者操作流程，取出下一个等待者，如果等待者是写者，那么直接退出 \ndont wake writers:\n    waiter =list_entry(sem-&gt;wait_list.next,struct rwsem_waiter,list); \n    if(waiter-&gt;flags &amp;RWSEM_WAITING_FOR_WRITE)\n        goto out;\n\n// 只唤醒读者操作流程，遍历等待链表，直到等待者为写者时停下 \nreaders_only:\n    woken =0; \n    do {\n        woken++;\n        if (waiter-&gt;list.next==&amp;sem-&gt;wait_list)\n            break;\n        waiter =list_entry(waiter-&gt;listnext，struct rwsem_waiter,list);\n    } while (waiter-&gt;flags &amp;RWSEM_WAITING_FOR_READ); \n    loop=woken;\n    woken *= RWSEM_ACTIVE_BIAS-RWSEM_WAITING_BIAS; woken-=RWSEM_ACTIVE_BIAS;\n    rwsem_atomic_add(woken，sem);// 更新counter 值\n    next = sem-&gt;wait_list.next;//  获取循环开始节点\n    for (; loop&gt;0;loop--){    //  从当前节点一直遍历唤醒所有读等待任务\n        waiter =list_entry(next,struct rwsem_waiter,list); \n        next = waiter-&gt;list.next; \n        waiter-&gt;flags =0;\n        wake_up_process(waiter-&gt;task);\n        \n        //  然后将唤醒了的一系列链表断开链接 sem-&gt;wait_list.next=next; next-&gt;prev = &amp;sem-&gt;wait_list;\n// 退出流程 \nout:\n    return sem;\n//还原操作流程 \nundo:\n// 再次判断，如果还有活动任务，则退出\n    if (rwsem_atomic_update(-RWSEM_ACTIVE_BIAS，sem)!=0)\n        goto out; \n        goto try_again;\n}</code></p><p></p><h1>总结</h1><p></p><p>实际上，针对读写信号量，如果我们用C语言代码高级语言来描述的话，则十分简单，即一个公平的读写锁。也就是说，当有读锁持有时，如果有读任务，则可以直接获得读锁;但如果此时有写仕务在等待的情况下，那么将会导致读锁获取失败，转而进入等待状态。当读锁释放后返回看看有没写者在等待，如果有写者在等待且传入了唤醒写者的标识1，那么看看等待列表的下一个等待任务是1是写节点，如果不是，那么遍历等待列表，唤醒所有读者，直到遇到一个写节点。然而，如果在持有写锁的情况下，那么读锁肯定获取失败，然后进入等待队列中，写锁被释放后，如果有锁等待，那会唤醒等待任务。</p>",
    "publish_time": "2022-09-15 00:21:29",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "范珂：数字化时代下，数据驱动决策组织文化的打造",
    "url": "https://www.infoq.cn/article/k0Lr2oVo3EdPqVR6CLo0",
    "summary": "<p>各位朋友，大家好，今天跟大家分享的主题是数字化时代下数据驱动决策组织文化的打造。首先做一个自我介绍。我叫范珂，目前在一家民营化妆品企业担任首席人力官。在加入这家公司之前，在一家跨国汽车公司担任亚太区人力资源总监，还在另一家跨国半导体公司做过亚太区人力资源总监。在工作之余，我也参与了一些英文经典HR方面的著作翻译，比如说《奈飞文化手册》、《高绩效的HR》《卓越领导之旅》等。</p><p></p><h1>数据驱动决策的文化</h1><p></p><p></p><p>在2003年的世界经济论坛上，提出了“Data is the new oil”这句口号。怎么来理解这句话呢？大家都知道因为石油的发现推动了第二次工业革命，后来因为互联网技术的发展，我们有了更多的工具和手段来收集数据，分析数据，用数据为组织去创造价值，所以数据受到了越来越多的组织的重视。根据波士顿咨询发布的报告，在影响组织变革的十二项力量中，其中一项就是人才需求变化方面的大数据和高级数据分析。随着有越来越多的手段可以去收集、处理、分析数据，组织对数据分析方面人才的需求非常旺盛。越来越多的企业开始注重培养组织的数据分析能力，培养数据驱动决策的文化。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/38/3850d98bec60cba6932be3365795bdd4.png\" /></p><p></p><p>不久前我读了一本书，这本书应该还没有在中国市场面世。这本书的名字叫《Think like Amazon》，翻译过来就是《像亚马逊一样思考》。这是亚马逊早期创业阶段的一位副总监写的一本书，他曾经参与了亚马逊早期电商平台的搭建。在书里面他提到，如果从亚马逊所有的成功因素里面挑出一个最重要的话，那就是数据指标（Metrics），或者说数据驱动决策的文化。</p><p></p><p>在亚马逊公司内部的决策流程里面，数据起到了非常关键的作用，亚马逊把对数据的管理落实到了每个月、每周甚至每天的工作中。通过对指标进行分析，不遗余力地深挖问题发生的根本原因，并不断改进；设计出一套体系和指标，以方便对业务的各个方面进行实时的监控和评估；召集以经营数据分析为核心任务的日常业务经营会，让所有利益相关方真正承担起责任并采取行动，从而推动整个组织不断实现高目标。</p><p></p><p>无独有偶，前谷歌首席人才官拉斯洛·博克所写的《重新定义团队》一书中，也花了很大的篇幅来介绍谷歌内部的决策文化，这种决策文化用一句话来概括就是数据驱动决策。我对他书里面的一句话印象非常深刻，“谷歌的HR决策从来都不是来自哪个最佳实践，一定只会是来自内部数据的分析。”</p><p></p><h1>数据驱动决策的组织文化特点</h1><p></p><p></p><p>越来越多的组织开始讨论数字化转型。我们可以比较下传统型组织和完成了或者正在进行数字化转型的组织，两者在组织文化层面存在着以下四个方面的区别。</p><p></p><p>第一，决策方式。传统型组织更多的是靠经验、直觉去做决策，而在数字化组织里面，因为可以通过技术手段去收集和分析大量的数据，所以在这些组织里面一定是通过数据说话，通过数据分析对未来趋势做出预测，以此来影响商业决策。</p><p></p><p>举个例子，曾经有人说到我们公司的品牌，凭感觉认为喜欢我们品牌的人可能会中年人居多，但是后来我们把后台的销售数字拉出来发现30岁以下的年轻群体其实占了非常大的比例。我们的大量销售是通过电商平台完成的，所以可以很容易地去拉出消费者的数据。通过数据分析发现品牌的重点受众是年轻人群，那未来的产品研发和品牌营销等都应该瞄准年轻人群，这就是一种通过数字去驱动决策的方式。</p><p></p><p>第二，组织设计。传统型组织的组织设计更偏向于科层式，也就是从上到下的金字塔结构。上级做出决定，然后一层一层地传递到基层。但是今天数字化组织面临着快速多变的市场环境，信息传递需要更加快速敏捷，因此，数字化组织的设计更加扁平化，缩短信息传递的距离。</p><p></p><p>同时，在数字化组织里面，会更强调发展组织的数据分析能力，所以会把组织的各个部门划分为前-中-后台。其中在中台要建立一支非常强大的数据分析团队以支持前端团队。前端团队直接服务于终端消费者，后端则通常包括为整个组织提供基础设施的团队，比如法务、财务、人力资源等。</p><p></p><p>第三，管理方式。在传统型组织里面，因为是金字塔式的组织结构，所以更强调以严格的流程去管控决策。而在数字化组织里面，为了随时跟上外界的变化，它的管理方式更倾向于赋能一线，让一线能够去做出决定，让听得见炮火的人来做决策。</p><p></p><p>第四，人员能力。传统型的组织对人员能力的要求更多的是强调有效决策，团队管理能力、执行力比较强。数字化的组织模式则决定了对人员的能力要求更多的是创新和流程再造，也要求组织里的每一个人具备相应的数据分析能力。</p><p></p><p>由于传统组织和数字化组织之间的这些区别，组织在寻求数字化转型的过程中往往要面临以下四个方面的痛点。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/c4/c42b1bad1855c02618695964e792e5f2.png\" /></p><p></p><h1>组织数据处理能力的四步走</h1><p></p><p></p><p>接下来我分享一下关于组织人员数据分析能力的观点。组织的数据分析能力，一般根据难度、复杂度以及对组织带来的价值可以分为四个阶段。</p><p></p><p>第一阶段，也是最基础的一个能力是描述性分析。指的是可以把组织里的大量数据所呈现出的趋势描述出来的能力。</p><p></p><p>第二阶段，诊断性分析。即根据收集到的数据，推导可能出现的问题并及时解决这些问题的能力。就像医生给病人做诊断一样，根据数据发现问题、诊断问题，然后解决问题。</p><p></p><p>第三阶段，预测性分析。可以根据历史数据来预测未来趋势。比如说大家如果登录淘宝、京东会发现，系统能够准确地把你可能喜欢的商品推送给你，原因就是系统可以根据用户画像去预测用户可能喜欢买的物品，这是预测性分析，目前预测性分析用到了很多相关的人工智能技术。</p><p></p><p>最后一个阶段叫指导性分析。指导性分析是在预测性分析的基础又进一步，可以实现对数据自动处理及分析，还可针对组织面临的运营问题、销售问题提供解决方案，且不需要随时的人工介入。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/67/6719cb0159b7f0dc27d14c2a8c28a2b7.png\" /></p><p></p><p>如今大数据时代下的数据分析相较传统的数据分析，更强调综合系统化的数据分析能力。传统的数据分析往往是独立的、分割的状态。举个例子，分析财务数据的时候，如果只看财务报表上面的数据，这就是一种很独立的数据分析。而当把财务、人力、销售、市场数据整合在一起，才能从普通的数据分析上升到系统的数据分析能力。</p><p></p><p>系统化的数据分析不止可以反映表象，更能深入到数据的底层去挖掘其背后的联系和原因，找出原因才方便去解决问题。此外，系统化的数据分析可以在分析过去和现在的状态基础上更进一步做到洞察未来。</p><p></p><p>最后一点，普通的数据分析更多的还是去做一些简单的图表呈现，比如我们经常会用PPT或者Excel做出一些简单的数据呈现。进入大数据的时代，要去做系统化数据分析的时候，就需要借助先进的数据分析的工具，比如说常见的Python编程、R语言编程等，去实现更加复杂、大量的数据分析；同时也可以通过Power BI等工具将数据进行数据化的呈现。</p><p></p><p></p><h1>数据分析团队的搭建</h1><p></p><p></p><p>说完组织数据分析的能力，我们再聊聊数据分析团队的搭建。在我看来，数据分析团队里面，通常可以分成三阶。</p><p></p><p>第一阶，数据信息的分析。这个岗位的职责是要保证数据的完整性和准确性，能够熟练地使用数据收集系统及时准确地、完整地去收集到公司所需要的数据，是最基本的一阶。</p><p></p><p>第二阶岗位，商业分析。这个岗位需要既懂数据分析，也要懂商业领域的知识，能够透过现象去看本质，对数据更加深层次的分析得出有价值的结论或解决方案。</p><p></p><p>第三阶，也是最高的一阶，叫做业务伙伴。在HR领域有一个岗位叫BP， Business Partner。在数据分析团队，其实也需要这样的Business Partner，基于对业务的深刻理解，通过数据分析的结果能够真正去影响业务的决策。</p><p></p><p>以上是我对数据分析团队三个阶段的定义，大家可以对照看下自己组织的数据分析团队处于哪个阶段。</p><p></p><p>接下来，我们再聊聊如何发展个人的数据分析能力，我认为可以从以下五个方面入手。</p><p></p><p>一，业务的敏锐度。就是要了解并全面理解业务，脱离业务去学习数据能力那就是本末倒置了，数据分析能力一定是要服务于业务目标的。</p><p></p><p>二，通过学习统计学、数据科学建立基本的数据分析的能力。</p><p></p><p>三，跨部门的知识和经验。只有实现真正跨部门的分析，分析结果才是真正有价值的。否则，很可能会因为缺失整个组织层面的视野而忽略一些非常重要的问题。</p><p></p><p>四，商业咨询和商务沟通技能。对数据做出了分析之后，还需要组织好你的分析结果，形成逻辑清晰的商业报告，将结果有效地沟通给你的商业客户。</p><p></p><p>最后，当需要向高层领导或者说更高级别的受众去呈现数据分析结果的时候，高效的演示、演讲能力就显得尤为重要，需要从数字里提炼出生动的线索，以讲故事的形式有重点地呈现出来。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/a1/a1f22a7a9b46396eb88e797a987dff2a.png\" /></p><p></p><h1>如何从零打造组织的数据驱动决策能力</h1><p></p><p></p><p>如果你所在的组织现在还停留在传统组织的层面，还没有真正转型为数字化组织，但又想在组织里面打造数据驱动决策的组织文化的话，应该从哪里开始入手呢？在这里，我给大家几个建议。</p><p></p><p>第一个建议是要建立起一套完整的、充分的业务数据的收集体系。数据分析就像炒菜一样，如果没有合适的原材料，没有数据又何谈实现数字化转型？所以首先就要建立非常完整的数据收集体系。</p><p></p><p>以人力资源为例，以前大家没有数据驱动决策意识的时候，人力资源同事在收集员工的人力资源数据的时候，只会去关注学历、年龄、籍贯这样的数据。但现在大家知道数据可以带来更大的价值，就会有意识再去收集员工喜好、性格特征、行为特征等更多的数据，这些都需要靠一套完整的数据收集体系才能够完成。</p><p></p><p>第二点，要建立一套组织的核心绩效指标。这个绩效指标需要有结果指标，比如收入、利润等，同时还需要有过程指标，比如拜访了多少客户，开发了多少客户资源等。如果不关注过程只追踪结果指标的话，等到发现结果不好的时候，也错过了解决问题的时机和方案。既追过程又追结果，结果才能够得到保证。</p><p></p><p>第三点，要把主要业务部门的数据系统打通来做数据分析，财务、市场、销售、人力等部门都需要打通。</p><p></p><p>第四点，要在组织里面要建立起标准的周报和月报制度，通过周报、月报来跟踪结果指标和过程指标，当然主要是可以跟踪过程指标，当指标的变化出现偏出常规的趋势的时候，可以及时介入去处理这些问题，解决这些问题，只有这样结果才会自然地变好。</p><p></p><p>第五点，在整个的数据监控、数据处理、数据分析的过程中，绝不能放过任何一个表现异常的指标，而且绝对不能停留在表面上，要不断地去深挖根源。</p><p></p><p>在丰田有一个管理方法叫“五个为什么”，就是当发现任何一个问题的时候，要不断地去追问原因，当连续问五个“为什么会这样”的时候，比较明显的答案可能就浮现出来了。这也是在数据分析里面需要具备的一种意识，千万不要放过任何一个表现异常的指标。为什么这个月成本上升了？原因是部门多招了人。为什么要多招人？因为缺人。为什么缺人？是不是因为组织的原因，或者是因为领导的原因导致人员的离职率偏高等。就是要一步一步地去深挖，通过不断地去问为什么找到问题的根源，从而才能解决问题。</p><p></p><p>最后，在数据分析的过程中，一方面要跟自己组织的历史做对比，确保自己在不断地提升。另一方面还要横向地跟行业内的领先公司做比较。以我们公司为例，当竞争对手出了季报、半年报、年报之后，我们都会去把这些公司的市场表现、财报数据找过来，然后一一地去分析我们和竞对公司的成本、毛利率、人效等等。</p><p></p><p>只有这样才会发现和这些行业领先公司之间的差距，然后去深挖原因，找到可以从哪些地方去做工作，给自己定出下一阶段的目标，从而不断缩小和行业领先公司之间的差距。管理就是在不断的精进过程中才能够真正得到提升，才能够最终实现整个组织的目标。</p><p></p><p>以上是我归纳出来大家可以从零开始打造组织数据驱动决策能力的一些方法。非常感谢大家的时间，期待未来有更多的机会跟大家做更深入的交流，谢谢。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/9e/9e7926882dc833bdaf80644024cb033c.jpeg\" /></p><p></p><h4>关于极客时间企业版</h4><p></p><p></p><p>极客时间企业版由极客邦科技倾力打造，是企业级一站式数字技能学习平台，是具备好内容、好产品、好服务的“三好平台”，助力企业打造行业领先的数字人才团队，驱动企业的数字化转型与高质量发展。</p><p></p><p>自 2019 年以来，极客时间企业版已服务近 3000&nbsp;家技术驱动型企业，覆盖银行、金融科技、保险、互联网、移动通信、软件、工业制造、教育等行业客户。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e3/e3c148931b18c1c7305e2fa67698f7ba.jpeg\" /></p><p></p>",
    "publish_time": "2022-09-15 12:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]