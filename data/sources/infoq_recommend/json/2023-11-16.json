[
  {
    "title": "Java近期新闻：JDK 22的JEP、Spring Shell、Quarkus、Apache Camel、JDKMon、J-Fall 2023",
    "url": "https://www.infoq.cn/article/rlyAMUAq5w6EJej8lXxv",
    "summary": "<p></p><h4>OpenJDK</h4><p></p><p>在结束了审查之后，<a href=\"https://openjdk.org/jeps/460\">JEP 460，Vector API（第七轮孵化）</a>\"已从JDK 22的Proposed to Target状态<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-November/008440.html\">提升</a>\"为Targeted状态。该JEP由<a href=\"https://openjdk.org/projects/panama/\">Panama</a>\"项目赞助，整合了对前六轮孵化反馈的改进：JEP 448，<a href=\"https://openjdk.org/jeps/448\">Vector API (第六轮孵化)</a>\"，在JDK 21中交付；JEP 438，<a href=\"https://openjdk.org/jeps/438\">Vector API (第五轮孵化)</a>\"，在JDK 20中交付；JEP 426，<a href=\"https://openjdk.org/jeps/426\">Vector API (第四轮孵化)</a>\"，在JDK 19中交付；JEP 417，<a href=\"https://openjdk.java.net/jeps/417\">Vector API (第三轮孵化)</a>\"，在JDK 18中交付；JEP 414，<a href=\"https://openjdk.java.net/jeps/414\">Vector API (第二轮孵化)</a>\"，在JDK 17中交付；以及JEP 338，<a href=\"https://openjdk.java.net/jeps/338\">Vector API (孵化器)</a>\"，在JDK 16中作为<a href=\"https://openjdk.java.net/jeps/11\">孵化器模块</a>\"发布。JEP 448最重要的变更包括对<a href=\"https://docs.oracle.com/en/graalvm/enterprise/20/docs/reference-manual/compiler/#graalvm-compiler\">JVM编译器接口</a>\"（JVMCI）的增强，以支持Vector API值。</p><p>&nbsp;</p><p>JEP 459：<a href=\"https://openjdk.org/jeps/459\">字符串模板（第二次预览版）</a>\"，已从JDK 22的Candidate状态<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-November/008441.html\">提升</a>\"为Proposed to Target状态。这个JEP提供了第一轮预览的第二个预览版本：JEP 430，<a href=\"https://openjdk.org/jeps/430\">字符串模板（预览版）</a>\"，在JDK 21中交付。该特性通过字符串模板增强了Java编程语言，字符串模板包含嵌入式表达式，在运行时对嵌入式表达式进行求值和验证。有关JEP 430的更多详细信息可以在InfoQ的<a href=\"https://www.infoq.com/news/2023/04/java-gets-a-boost-with-string/\">新闻报道</a>\"中找到。其审查预计将于2023年11月15日结束。</p><p>&nbsp;</p><p>甲骨文（Oracle）的技术人员顾问<a href=\"https://www.linkedin.com/in/gavin-bierman-a0173075/\">Gavin Bierman</a>\"<a href=\"https://mail.openjdk.org/pipermail/amber-spec-observers/2023-November/004150.html\">发布</a>\"了JEP 463，<a href=\"https://openjdk.org/jeps/463\">隐式类和实例主方法（第二次预览版）</a>\"的<a href=\"https://draft specification\">规范草案</a>\"，以供Java社区审查。</p><p>&nbsp;</p><p></p><h4>JDK 22</h4><p></p><p>JDK 22<a href=\"https://jdk.java.net/22/\">早期访问构建版本</a>\"中的第<a href=\"https://github.com/openjdk/jdk/releases/tag/jdk-22%2B23\">23</a>\"版于上周发布，其中包括对第22版的<a href=\"https://github.com/openjdk/jdk/compare/jdk-22%2B22...jdk-22%2B23\">更新</a>\"以及各种<a href=\"https://bugs.openjdk.org/issues/?jql=project%20%3D%20JDK%20AND%20fixversion%20%3D%2022%20and%20%22resolved%20in%20build%22%20%3D%20b19%20order%20by%20component%2C%20subcomponent\">问题</a>\"的修复。有关该版本的更多详细信息，请参阅<a href=\"https://jdk.java.net/22/release-notes\">发布说明</a>\"。</p><p>&nbsp;</p><p>对于JDK 22，鼓励开发人员通过<a href=\"https://bugreport.java.com/bugreport/\">Java Bug Database</a>\"报告缺陷。</p><p>&nbsp;</p><p></p><h4>Spring框架</h4><p></p><p><a href=\"https://spring.io/projects/spring-shell\">Spring Shell</a>\"的3.2.0-M3、3.1.5、3.0.9和2.1.14版本已经<a href=\"https://spring.io/blog/2023/11/08/spring-shell-2-1-14-3-0-9-3-1-5-and-3-2-0-m3-are-now-available\">发布</a>\"，并且包含一些值得注意的更改，例如：升级到<a href=\"https://github.com/jline/jline3/blob/master/README.md\">JLine</a>\"&nbsp;3.24.1，以解决 stdout 在非交互模式下重定向到 stderr 的问题；终端用户界面（<a href=\"https://docs.spring.io/spring-shell/reference/tui/index.html\">Terminal UI</a>\"）的改进，尤其是自动配置能力；并且解决了tab补全可能因延迟初始化而失败的问题。这些版本分别基于Spring Boot 3.1.0-RC2、3.1.5、3.0.12和2.7.17构建。有关这些版本的更多详细信息，请参阅版本<a href=\"https://github.com/spring-projects/spring-shell/releases/tag/v3.2.0-M3\">3.2.0-M3</a>\",、版本<a href=\"https://github.com/spring-projects/spring-shell/releases/tag/v3.1.5\">3.1.5</a>\"、版本<a href=\"https://github.com/spring-projects/spring-shell/releases/tag/v3.0.9\">3.0.9</a>\"和版本<a href=\"https://github.com/spring-projects/spring-shell/releases/tag/v2.1.14\">2.1.14</a>\"的发布说明。</p><p>&nbsp;</p><p></p><h4>Quakrus</h4><p></p><p><a href=\"https://quarkus.io/\">Quarkus</a>\"&nbsp;3.5.1的<a href=\"https://quarkus.io/blog/quarkus-3-5-1-released/\">发布</a>\"带来了一些值得注意的变更，例如：修复了OIDC作用域为空时权限映射的问题；改进了<a href=\"https://quarkus.io/guides/dev-services#keycloak\">Keycloak</a>\"&nbsp;DevService中的错误消息和文档；以及由于不稳定而临时禁用Windows操作系统上的 VertxMDCTest 类。有关该版本的更多详细信息，请参阅<a href=\"https://github.com/quarkusio/quarkus/releases/tag/3.5.1\">变更日志</a>\"。</p><p>&nbsp;</p><p>同样，Quarkus 3.2.8的<a href=\"https://quarkus.io/blog/quarkus-3-2-8-final-released/\">发布</a>\"也带来了一些值得注意的变更，例如：修复了在 AccessTokenRequestReactiveFilter 类中定义的 propagateToken() 方法，该方法使用承载方案复制了授权标头；在 QuarkusSecurityTestExtension 类中定义的 afterEach() 方法不应在未使用 @TestSecurity 注释的情况下调用 CDI 类中指定的 current() 方法；以及修复了由于使用 ForwardedProxyHandler 类而导致的 NullPointerException ，该类在找不到记录时允许 null 值。有关该版本的更多详细信息，请参阅<a href=\"https://github.com/quarkusio/quarkus/releases/tag/3.2.8.Final\">变更日志</a>\"。</p><p>&nbsp;</p><p>这两个版本都解决了<a href=\"https://access.redhat.com/security/cve/cve-2023-5720\">CVE-2023-5720</a>\"的问题，在这种漏洞情况下，攻击者可以通过应用程序访问构建系统中的潜在敏感信息，因为在Quarkus中发现了一个缺陷，它无法正确清理使用Gradle插件创建的构件。所以这样可以保留某些构建系统信息。</p><p>&nbsp;</p><p></p><h4>Apache软件基金会</h4><p></p><p>&nbsp;</p><p>Apache Camel 3.14.10的<a href=\"https://camel.apache.org/blog/2023/11/RELEASE-3.14.10/\">发布</a>\"提供了漏洞修复、依赖项升级和一些改进：更改了<a href=\"https://camel.apache.org/components/3.20.x/sftp-component.html\">SFTP</a>\"组件选项 chmodDirectory 中的目录权限；以及在<a href=\"https://camel.apache.org/components/4.0.x/micrometer-component.html#MicrometerComponent-registry\">Meter Registry</a>\"组件中收集授权数据。有关该版本的更多详细信息，请参阅<a href=\"https://camel.apache.org/releases/release-3.14.10/\">发布说明</a>\"。</p><p>&nbsp;</p><p>为了与Quarkus保持一致，<a href=\"https://github.com/apache/camel-quarkus/blob/main/README.adoc\">Camel Quarkus</a>\" 3.2.2也已<a href=\"https://camel.apache.org/blog/2023/11/camel-quarkus-release-3.2.2/\">发布</a>\"，但没有任何记录在案的重大修复、依赖升级或改进。有关该版本的更多细节，请参阅<a href=\"https://camel.apache.org/releases/q-3.2.2/\">发布说明</a>\"。</p><p>&nbsp;</p><p></p><h4>JDKMon</h4><p></p><p><a href=\"https://github.com/HanSolo/JDKMon\">JDKMon</a>\"是一个监视并更新已安装JDK的工具，其<a href=\"https://github.com/HanSolo/JDKMon/releases/tag/17.0.81\">17.0.81</a>\"版本已于上周发布。这个新版本由Azul的首席工程师<a href=\"https://de.linkedin.com/in/gerritgrunwald\">Gerrit Grunwald</a>\"创建，提供了依赖项升级、Gradle 8.4的构建升级，以及一些新功能：能够从列表中选择JEP、JSR或OpenJDK项目，并在默认浏览器中打开该选择；JDK发行版的工具提示现在也会显示磁盘上的模块数量和大小。</p><p>&nbsp;</p><p></p><h4>Arquillian</h4><p></p><p><a href=\"https://arquillian.org/\">Arquillian</a>\" 1.7.2.Final已<a href=\"https://github.com/arquillian/arquillian-core/releases/tag/1.7.2.Final\">发布</a>\"，其为参数化测试的失败提供了修复，尽管测试失败，仍能报告通过。有关该版本的更多详细信息，请参阅<a href=\"https://github.com/arquillian/arquillian-core/compare/1.7.1.Final...1.7.2.Final\">问题列表</a>\"。</p><p>&nbsp;</p><p></p><h4>Gradle</h4><p></p><p><a href=\"https://gradle.org/\">Gradle</a>\"&nbsp;8.5.0发布了<a href=\"https://github.com/gradle/gradle/releases/tag/v8.5.0-RC1\">第一个候选版本</a>\"，包括：完全支持在JDK 21上编译、测试和运行；对<a href=\"https://docs.gradle.org/8.5-rc-1/userguide/kotlin_dsl.html\">Kotlin DSL</a>\"的改进，包括在预编译的Kotlin脚本插件中<a href=\"https://docs.gradle.org/8.5-rc-1/release-notes.html#faster-first-use\">更快地首次使用</a>\"和<a href=\"https://docs.gradle.org/8.5-rc-1/release-notes.html#catalog-precompiled\">版本目录支持</a>\"；改进了错误和警告的报告。有关该版本的更多详细信息，请参阅<a href=\"https://github.com/arquillian/arquillian-core/compare/1.7.1.Final...1.7.2.Final\">发布说明</a>\"。</p><p>&nbsp;</p><p></p><h4>J-Fall 2023</h4><p></p><p>上周，2023 <a href=\"https://jfall.nl/\">J-Fall</a>\"会议在荷兰Ede的<a href=\"https://www.pathe.nl/bioscoop/ede\">Pathé Ede</a>\"举行，庆祝其成立20周年，来自Java社区的<a href=\"https://jfall.nl/speakers-2023/\">演讲者</a>\"在会前<a href=\"https://jfall.nl/preconference/\">研讨会</a>\"、主题演讲、50分钟的会议和<a href=\"https://jfall.nl/timetable/\">会议议程上</a>\"发表了闪电演讲。有关J-Fall 2023的详细报告请参阅Eclipse基金会Jakarta EE开发人员倡导者<a href=\"https://www.linkedin.com/in/ivargrimstad/\">Ivar Grimstad</a>\"的<a href=\"https://www.agilejava.eu/2023/11/11/j-fall-2023/\">博客文章</a>\"。</p><p>&nbsp;</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/11/java-news-roundup-nov06-2023/\">https://www.infoq.com/news/2023/11/java-news-roundup-nov06-2023/</a>\"</p>",
    "publish_time": "2023-11-16 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Angular v17亮点解读：全新功能提升开发者体验",
    "url": "https://www.infoq.cn/article/TqCmpDM6KtvjZchqiXZM",
    "summary": "<p>上个月举办了Angular红色盾牌的13周年庆。曾几何时，AngularJS是通过JavaScript框架满足日益增加的web开发体验需求的先锋队。今天在v17版本中，我们将以全新品牌形象、面向未来的功能设计，和大家一起重新定义应用性能和开发体验的新标准。</p><p>&nbsp;</p><p>很高兴为大家介绍v17版本带来的新功能：</p><p></p><p>延迟视图将性能和开发体验提高到了新高度相对于行业标准，基于内置控制流的循环性能提高了90%在构建速度上，混合渲染模式和客户端渲染模式，分别提高87%和67%全新的外观，体现着Angular功能的先进性全新的互动式学习体验还有数十个新特性和能力增强</p><p>&nbsp;</p><p></p><h1>面向未来的品牌形象</h1><p></p><p></p><p>过去几个版本中，Angular一直都在复兴之路上狂奔。我们通过改进诸如基于信号的响应式编程、hydration（译注：服务端渲染客户端激活的模式）、独立组件、组合指令等数十项特性，不断增强发展势头。尽管Angular的发展迅速，但其品牌形象却未能跟上这种快速的演变——自从AngularJS早期以来，它的品牌形象几乎没有变化。</p><p>&nbsp;</p><p>今天，这个被数百万开发者使用和喜爱的框架将展现出全新的面貌，这一新形象也衬托了其面向未来的开发体验和卓越性能！</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/d5/d5bb4c099265b677450c7a98499f655f.png\" /></p><p></p><p>&nbsp;</p><p></p><h1>面向未来的文档</h1><p></p><p></p><p>随着新品牌的推出，我们为Angular文档也打造了一个崭新的家园——<a href=\"https://angular.dev/\">angular.dev网站</a>\"。在这个全新的文档网站中，我们重新设计了结构，编写了新的指南，优化了内容，并构建了一个交互式的学习平台，使开发者能够按照自己的节奏在浏览器中深入学习Angular和Angular CLI。</p><p>&nbsp;</p><p>新的交互式的学习平台采用了<a href=\"https://webcontainers.io/\">WebContainers</a>\" 技术，因此开发者可以在任何现代的网络浏览器中充分使用Angular CLI的强大功能！</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/b8/32/b8f09b7a8c68a2391975f9d0ef346c32.gif\" /></p><p></p><p>基于<a href=\"https://webcontainers.io/\">WebContainers</a>\"的Angular交互式体验页面</p><p>&nbsp;</p><p>今天，我们推出了angular.dev的体验版，并计划在v18版本中将其作为Angular的默认网站。开发者可以在“<a href=\"https://blog.angular.io/announcing-angular-dev-1e1205fa3039\">angular.dev的官方发布</a>\"”这篇文章中了解更多关于Angular新品牌形象和以及<a href=\"https://angular.dev/\">angular.dev</a>\"网站的信息。</p><p>&nbsp;</p><p>现在，让我来把在v17版本中那些迫不及待想要告诉大家的新功能做个详细介绍！</p><p>&nbsp;</p><p></p><h1>内置控制流</h1><p></p><p>&nbsp;</p><p>为了提升开发体验，我们发布了一种新的块模板语法。基于该语法，只需使用简单、声明式的API即可实现强大的功能。在底层，Angular编译器会将这种语法转换成高效的JavaScript指令，这些指令可以执行流程控制、懒加载等操作。</p><p>&nbsp;</p><p>基于新的块模板语法，我们做了内置控制流的优化。通过用户调研，我们发现许多开发者在使用*ngIf、*ngSwitch和*ngFor时经常面临重重困难。甚至包括我本人在内也是如此，虽然我个人从2016年就开始使用Angular，且作为Angular团队成员也有5年之久，但在使用*ngFor和trackBy时，依然需要查阅文档才能确保正确使用。在收集了社区、合作伙伴的反馈，并进行了<a href=\"https://blog.angular.io/meet-angulars-new-control-flow-a02c6eee7843\">用户体验调研</a>\"之后，我们为Angular开发了一种新的内置控制流！</p><p>&nbsp;</p><p>新的内置控制流带来了如下好处：</p><p></p><p>更贴近JavaScript语法，更符合开发者使用习惯，更直观，从而减少了查阅文档的需求得益于更优化的类型收敛（type narrowing），类型检查得到了很好的改善内置控制流是构建阶段核心处理的部分，除了大大减少运行时的消耗（甚至直接消失）之外，还将使你的应用程序包大小整体减少30KB之多，从而进一步提高应用的核心网络指标（Core Web Vital）的得分无需额外导入，即可在模版中通过变量来使用显著的性能提升，稍后我们会专门介绍</p><p>&nbsp;</p><p></p><h1>条件语句</h1><p></p><p></p><p>让我们来看一个在当前版本和v17版本中使用*ngIf的对比：</p><p>&nbsp;</p><p><code lang=\"null\"></code></p><div><code lang=\"null\">\n  The user is logged in\n</code></div><code lang=\"null\">\n\n  The user is not logged in\n</code><p></p><p>&nbsp;</p><p>使用内置if语句之后：</p><p>&nbsp;</p><p><code lang=\"null\">@if (loggedIn) {\n  The user is logged in\n} @else {\n  The user is not logged in\n}</code></p><p></p><p>与传统的*ngIf通过使用模块替换来实现else相比，能够直接编写@else内容是一个重大的简化。当前的控制流也使得@else if的支持变得非常简单，而这在之前的版本中这是无法实现的。</p><p>&nbsp;</p><p>在*ngSwitch中，使用内置控制流改进后显现出来的易用性就更加突出了：</p><p>&nbsp;</p><p><code lang=\"null\"></code></p><div><code lang=\"null\">\n  \n  \n  \n</code></div><p></p><p>&nbsp;</p><p>使用内置switch语句之后：</p><p>&nbsp;</p><p><code lang=\"null\">@switch (accessLevel) {\n  @case ('admin') {  }\n  @case ('moderator') {  }\n  @default {  }\n}</code></p><p>&nbsp;</p><p>在新的控制流中，在@switch的条件分支上更好、更显著地实现了类型收敛，而这在老的 *ngSwitch中是无法做到的。</p><p>&nbsp;</p><p></p><h1>内置循环</h1><p></p><p></p><p>内置循环是我最喜欢的更新之一，它在改善开发体验的同时，还将Angular的渲染速度提升到了一个新的级别。</p><p>&nbsp;</p><p>下面是基础示例：</p><p>&nbsp;</p><p><code lang=\"null\">@for (user of users; track user.id) {\n  {{ user.name }}\n} @empty {\n  Empty list of users\n}</code></p><p>&nbsp;</p><p>我们经常看到应用程序由于*ngFor缺少trackBy函数而产生的性能问题。因此，为了保证差异对比运算的性能，强制使用track函数，是新的@for循环语句的首要变更。此外，在使用上@for也更加简单，因为它只是一个表达式，而不是组件类中的一个方法。同时，内置的@for循环还通过一个可选的@empty块语法为空集合提供了快捷处理方式。</p><p>&nbsp;</p><p>@for语句使用了新的差异算法，相对于*ngFor指令，在实现上做了非常多的优化，这也使得其在执行速度上相对于<a href=\"https://krausest.github.io/js-framework-benchmark/current.html\">社区框架基线</a>\"提高了90%。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/43/43b483b80cf80a0f6e98da6fe6938c4e.png\" /></p><p></p><p>&nbsp;内置for语句与 js-framework-benchmarks 中 *ngFor 的性能比较，数据来源：</p><p><a href=\"https://krausest.github.io/js-framework-benchmark/current.html\">https://krausest.github.io/js-framework-benchmark/current.html</a>\"</p><p>&nbsp;</p><p></p><h1>体验</h1><p></p><p></p><p>今天，在v17的开发体验版中就可以体验内置控制流的全部功能！</p><p>&nbsp;</p><p>内置控制流的设计目标之一，就是实现让开发者通过CLI命令就可以自动完成已有项目的完整迁移。因此，开发者可以在已有项目中，通过执行使用如下命令来完成自动迁移：</p><p>&nbsp;</p><p><code lang=\"null\">ng generate @angular/core:control-flow</code></p><p>&nbsp;</p><p></p><h1>下一步计划</h1><p></p><p></p><p>我们已经和JetBrains进行了紧密合作，开发者在JetBrains的产品中可以使用内置控制流体验最新的语言服务。于此同时，我们也在和<a href=\"https://github.com/sosukesuzuki\">Sosuke Suzuki</a>\"联系，以确保Prettier可以正确的支持Angular模板格式。</p><p>&nbsp;</p><p>在处理内容预测上，内置的控制流与*ngIf、*ngFor和*ngSwitch还存在一些差异，我们将在接下来的几个月中努力解决这些问题。尽管如此，我们依然对内置控制流的实现和稳定性充满信心，所以你今天就可以尝试使用了！我们之所以将其保留在开发体验版本中，直到下一个主要版本才发布，是因为我们希望借此机会发现问题，从而有机会进一步提升开发者体验和修复一些可能存在的向后不兼容的问题。</p><p>&nbsp;</p><p></p><h1>延迟视图</h1><p></p><p></p><p>现在，让我们来谈谈懒加载功能！基于新研发的块状语发糖，我们全新设计了一个强大的机制来实现延迟视图，从而使开发者的应用程序跑得更快。正如本文开篇所说，延迟视图将应用性能和开发者体验都提升到了一个新水平。这是因为它们开创性地实现了基于声明式的懒加载。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/4d/4d8b12b7681e144c790d011a878c0235.png\" /></p><p>此组件树中左边的子树被懒加载</p><p></p><p>&nbsp;</p><p>假设你有一个博客，你想要实现评论列表的懒加载。那么在当前的版本中，你需要使用ViewContainerRef来实现，同时还需要处理诸如：清理、加载异常、显示占位符等复杂逻辑。与此同时，还需要兼顾一些边界情况，因此代码会变得非常复杂，甚至无法调试和测试。</p><p>&nbsp;</p><p>然而，在v17版本中，通过新的延迟视图功能，你只需要通过一行声明式的代码就可以实现评论列表及其所有传递依赖项的懒加载：</p><p>&nbsp;</p><p><code lang=\"null\">@defer {\n  \n}</code></p><p>&nbsp;</p><p>最令人难以置信的是，这一切都是在编译期间通过转换技术来实现的：Angular抽象了延迟视图的全部复杂逻辑。编译期间，Angular通过找到在@defer块中声明的组件、指令和管道，自动将其转为动态导入，同时还会自动管理目标组件的加载和状态切换的全过程。</p><p>&nbsp;</p><p>当组件的懒加载是通过某个DOM元素进入视窗来触发时，通常需要结合IntersectionObserver API编写复杂逻辑来实现。然而，Angular却将IntersectionObservers的使用，变得只需要简单的添加一个延迟视图触发器即可实现！示例代码如下：</p><p>&nbsp;</p><p><code lang=\"null\">@defer (on viewport) {\n  \n} @placeholder {\n  <!-- A placeholder content to show until the comments load -->\n  <img src=\"https://www.infoq.cn/article/comments-placeholder.png\" />\n}</code></p><p>&nbsp;</p><p>在上面的例子中，Angular首先渲染通过@placeholder声明的占位符。当组件准备进入视窗中时，Angular就会开始加载该组件。在加载完成之后，Angular会立刻移除占位符并渲染该组件。</p><p>&nbsp;</p><p>下面是包含处理加载过程和异常处理的示例代码：</p><p><code lang=\"null\">@defer (on viewport) {\n  \n} @loading {\n  Loading…\n} @error {\n  Loading failed :(\n} @placeholder {\n  <img src=\"https://www.infoq.cn/article/comments-placeholder.png\" />\n}</code></p><p>&nbsp;</p><p>就是这样！Angular为你处理了许多隐藏在幕后的复杂逻辑。</p><p>&nbsp;</p><p>延迟视图支持的触发器非常多，例如：</p><p></p><p>on idle——当浏览器没有执行任何繁重任务时，触发延迟视图加载on immediate——以不阻塞浏览器的方式，自动触发延迟视图加载on timer(<time>)——通过定时器触发延迟视图加载on viewport和on viewport()——viewport触发器还支持设置一个锚点元素，当指定的锚点元素可见时，触发延迟视图加载on interaction和on interaction()——允许你在用户与特定元素交互时触发延迟视图加载on hover和on hover()——当用户鼠标悬停在元素上时触发延迟视图加载when ——通过返回promise，实现通过自定义条件触发延迟视图加载</time></p><p>&nbsp;</p><p>延迟视图还提供了在渲染它们之前预先获取依赖项的能力。只需要在defer块中简单的添加一个 prefetch语句即可为延迟视图添加预获取功能。所有和viewport相同类型的触发器，都支持添加预获取功能，示例代码如下：</p><p>&nbsp;</p><p><code lang=\"null\">@defer (on viewport; prefetch on idle) {\n  \n}</code></p><p>&nbsp;</p><p>大家今天就可以在v17的开发体验版中体验延迟视图功能！如果想了解更多、更详细的关于延迟试图功能，请阅读这份<a href=\"https://angular.io/guide/defer\">指南</a>\"。</p><p>&nbsp;</p><p></p><h1>下一步计划</h1><p></p><p></p><p>延迟试图完全可以被正式使用，同时我们也强烈建议开发者尝试去使用该功能！该功能之所以依然在开发体验版中，是因为我们希望收集到更多的使用反馈。同时，和框架其他功能一样，我们会按照语义化版本的方式不断迭代该功能的API，直到稳定为止。</p><p>&nbsp;</p><p>目前，在服务端渲染时，针对延迟试图，会使用一个特殊的占位符取代。一旦框架完成应用加载且延迟试图被激活，那么延迟视图就会按照上文所描述的那样执行。</p><p>&nbsp;</p><p>我们的下一步计划是探索defer中声明的内容在服务端渲染和客户端按需激活的能力。这将意味着，在被触发之前，客户端将不会下载延迟试图的代码。当延迟视图被触发时，Angular将下载相关的JavaScript代码并仅对视图的这一部分进行水合处理。</p><p>&nbsp;</p><p>还将会有更多令人兴奋的，结合signals实现的功能，敬请期待！</p><p>&nbsp;</p><p></p><h1>改进的混合渲染体验</h1><p></p><p></p><p>今天，我们还为开发者带来了基于交互式命令的SSR（服务端渲染）和SSG（静态网站生成/预渲染）功能，下面是使用ng new命令的示例：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/a1/a1c5e17e253dbfd2a88e6ed22fb41306.gif\" /></p><p></p><p>&nbsp;这是一个我们一直想做的改变，但是首先我们想先保证Angular的SSR开发者体验的稳定性。</p><p>&nbsp;</p><p>或者，你可以用以下方式在新项目中启用SSR：</p><p>&nbsp;</p><p><code lang=\"null\">ng new my-app --ssr</code></p><p>&nbsp;</p><p></p><h1>Hydration从开发体验版毕业</h1><p></p><p></p><p>在过去的 6 个月里，我们看到数千个应用程序采用了hydration。 今天，我们很高兴地宣布，hydration正式从开发体验版中移除，且在所有使用了服务器端渲染的新应用中默认开启！</p><p>&nbsp;</p><p></p><h1>新的@angular/ssr包</h1><p></p><p></p><p>我们将Angular中的通用代码库存迁移移至Angular CLI代码库中，从而使服务器端渲染成为了我们工具产品中更加不可或缺的一部分。</p><p>&nbsp;</p><p>因此，从今天开始，可以通过如下命令为历史项目添加混合渲染的支持：</p><p>&nbsp;</p><p><code lang=\"null\">ng add @angular/ssr</code></p><p>&nbsp;</p><p>此命令在为应用会生成服务端入口点、添加SSR能力和SSG构建能力的同时默认开启hydration。@angular/ssr提供了与@nguniversal/express-engine（该库当前处于维护模式）等效的功能。如果你使用的是express-engine，那么Angular CLI将会自动为你将代码更新为@angular/ssr。</p><p>&nbsp;</p><p>Virgin Media O2通过将他们历史平台的混合渲染技术迁移至最新的Angular混合渲染技术，销售额增长了 112%。通过将NgOptimizedImage与支持DOM Hydration的Angular SSR结合使用，其平台的CLS（<a href=\"https://web.dev/articles/cls?hl=zh-cn\">累计布局偏移</a>\"）指标平均降低了99.4%。</p><p>&nbsp;</p><p></p><h1>SSR应用部署</h1><p></p><p></p><p>为了进一步增强开发人员体验，我们与云提供商密切合作，确保基于Angular的SSR应用可以丝滑的部署到他们的云平台上。</p><p>&nbsp;</p><p>通过Firebase的最新发布的<a href=\"https://firebase.google.com/docs/hosting/frameworks/angular?hl=zh-cn\">框架感知CLI</a>\"，开发者几乎不用任何配置，就可以将自己的Angular应用程序部署到该平台上。</p><p>&nbsp;</p><p><code lang=\"null\">firebase experiments:enable webframeworks\nfirebase init hosting\nfirebase deploy</code></p><p>&nbsp;</p><p>框架感知CLI可以自动识别应用中用到的SSR、i18n和图像优化等功能，这使你能够经济且高效的在无服务器基础设施上为用户提供高性能的web应用服务。</p><p>&nbsp;</p><p>对于那些拥有复杂Angular monorepos项目或偏爱原生工具链的人们，AngularFire允许你使用ng deploy将应用部署到Firebase：</p><p>&nbsp;</p><p><code lang=\"null\">ng add @angular/fire\nng deploy</code></p><p>&nbsp;</p><p>为了支持边缘环境部署，我们在Angular的服务器端渲染中不但提供了ESM的支持，为<a href=\"https://github.com/angular/angular/pull/50247\">HttpClient做服务端适配</a>\"，还与<a href=\"https://developers.cloudflare.com/pages/framework-guides/deploy-an-angular-site/\">CloudFlare</a>\"合作简化了部署流程。</p><p>&nbsp;</p><p></p><h1>新的生命周期hooks</h1><p></p><p></p><p>虽然从长远来看，为了提高Angular的SSR和SSG的性能，我们倾向于移除DOM的模拟和直接操作。但与此同时，在大多数应用的生命周期中，很难避免诸如实例化第三方库、测量元素大小等和DOM元素相关的交互行为。</p><p>&nbsp;</p><p>为此，我们新增了两个生命周期hooks：</p><p>&nbsp;</p><p>afterRender — 注册一个回调函数，每次应用完成渲染时调用afterNextRender — 注册一个回调函数，应用下次完成渲染时调用</p><p>&nbsp;</p><p>这两个hooks只会在浏览器端才会被调用，因此开发者可以安心的在其中使用DOM操作逻辑。例如，如果你想实例化一个图表库，可以通过afterNextRender来实现：</p><p>&nbsp;</p><p><code lang=\"null\">@Component({\n  selector: 'my-chart-cmp',\n  template: `</code></p><div><code lang=\"null\">{{ ... }}</code></div><code lang=\"null\">`,\n})\nexport class MyChartCmp {\n  @ViewChild('chart') chartRef: ElementRef;\n  chart: MyChart|null;\n\n  constructor() {\n    afterNextRender(() =&gt; {\n      // 这里需要操作真实DOM，必须保证DOM已经具备了\n      this.chart = new MyChart(this.chartRef.nativeElement);\n    }, {phase: AfterRenderPhase.Write});\n  }\n}\n</code><p></p><p>&nbsp;</p><p>每个hooks都支持设置一个阶段值（如读取、写入），Angular将使用该阶段值来择机执行回调，以减少布局抖动并提高性能。</p><p>&nbsp;</p><p></p><h1>新项目默认开启Vite和esbuild</h1><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ae/aefc98b7b5b4133be7c0e8b3907a5e17.png\" /></p><p></p><p>vite和esbuild为ng server和ng build助力</p><p>&nbsp;</p><p>如果不是一开始就对Angular CLI的构建流程进行彻底的改造，那么Angular将不可能支持SSR！</p><p>&nbsp;</p><p>在v16的开发体验版中，我们就引入了基于esbuild+Vite的构建能力。 从那时起，就有许多开发者和部分企业合作伙伴试用了该功能，数据报告显示他们的一些应用的构建时间缩短了 67%！今天，我们很高兴地宣布，新的应用程序构建器正式从开发体验版中毕业，并且为所有新应用程序默认开启！</p><p>&nbsp;</p><p>此外，我们还升级了混合渲染场景的构建流程。 在SSR和SSG应用程序中，ng build的执行速度提高了87%，ng serve的实时编辑反馈速度提高了80%。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/0d/0d4edf487054ae46d6e8b071ba063045.png\" /></p><p></p><p>基于esbuild+vite的新构建流程和基于webpack的老构建流程的性能对比</p><p>&nbsp;</p><p>在未来的minor版本中，我们将为历史项目升级混合渲染（使用 SSG 或 SSR 进行客户端渲染）提供自动脚本。如果你今天就想试用新的应用程序构建流程，可以查看这份<a href=\"https://angular.io/guide/esbuild\">升级指南</a>\"。</p><p>&nbsp;</p><p></p><h1>DevTools中的依赖注入调试</h1><p></p><p></p><p>去年，我们向大家演示了在Angular DevTools中进行依赖注入调试的功能。在过去的几个月里，我们实现了全新调试API，通过这些API，开发者可以直接插入框架的运行时进行注入树的检查。</p><p>&nbsp;</p><p>基于这些 API，我们构建了一个检查注入依赖的用户界面，通过此界面开发者可以预览如下信息：</p><p>&nbsp;</p><p>基于组件监听的组件的依赖关系注入树和依赖解析路径每个注入的提供者信息</p><p>&nbsp;</p><p>你可以在下面的动画中快速预览这些功能。 也可以在<a href=\"https://angular.io/guide/devtools\">angular.io</a>\"上了解有关Angular DevTools 的更多信息。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/d9/d98f0eedb43f38f8e0060e215d26ff22.gif\" /></p><p></p><p>&nbsp;接下来我们将继续打磨注入层次结构、提供者信息和路径解析等方面的视图UI，为开发者提供更好的可视化能力。</p><p>&nbsp;</p><p></p><h1>开启独立API时代</h1><p></p><p></p><p>在经历一年半的持续收集独立组件、指令和管道的使用反馈并不断完善了它们的DevEx之后，我们有信心立刻在所有新应用程序中启用它们。 所以，现在所有的ng generate命令都将构建独立的组件、指令和管道。</p><p>&nbsp;</p><p>与此同时，我们还重新审视了<a href=\"https://angular.io/\">angular.io</a>\"和<a href=\"https://angular.dev/\">angular.dev</a>\"的全部文档，从而确保了一致的学习体验、开发实践和建议。</p><p>&nbsp;</p><p>虽然，在未来的一段时间内，我们将继续保留NgModules，但当看到新的独立API的好处之后，我们依然强烈建议你在项目中逐步执行迁移动作。 同时，我们还提供了一个迁移脚本，该脚本可以为你自动完成大部分工作：</p><p>&nbsp;</p><p><code lang=\"null\">ng generate @angular/core:standalone</code></p><p>&nbsp;</p><p>有关更多信息，请查看我们的<a href=\"https://angular.io/guide/standalone-migration\">迁移指南</a>\"。</p><p>&nbsp;</p><p></p><h1>响应式的下一步计划</h1><p></p><p></p><p>Angular新的基于信号的响应系统是我们在该框架中所做的重大转变之一。 为了确保与基于 Zone.js的变更检测的向后兼容性和互操作性，我们一直在努力制作原型并设计推进的线路。</p><p>&nbsp;</p><p>今天，我们很高兴地宣布Angular的基于Signals的响应式实现从开发体验版中毕业。 目前，我们将把effect函数继续保留在开发者体验中，以便我们可以进一步迭代它的语义。</p><p>&nbsp;</p><p>在接下来的几个月中，我们将开始逐步推出基于信号的输入、视图查询等功能。 到明年5月，在Angular v18中，我们将提供更多的功能来进一步改善开发人员使用Signals的体验。</p><p>&nbsp;</p><p></p><h1>测试的下一步计划</h1><p></p><p></p><p>我们正在持续试验Jest，以并确保我们可以构建一个高性能、灵活且直观的解决方案，从而更好地满足开发人员的需求。 与此同时，我们还开始尝试Web Test Runner，并为初始实施提供了一个开放的<a href=\"https://github.com/angular/angular-cli/pull/25860\">PR</a>\"。在不久的将来，我们可能会优先关注Web Test Runner，以解放那些渴望摆脱Karma的项目。</p><p>&nbsp;</p><p></p><h1>Material 3的下一步计划</h1><p></p><p></p><p>在为Angular Material引入<a href=\"https://m3.material.io/foundations/design-tokens/overview\">设计令牌</a>\"的重构中，我们一直与谷歌的Material Design团队努力合作。该设计系统将为组件提供更多的自定义选项并启用<a href=\"https://m3.material.io/\">Material 3</a>\"的支持。 虽然我们还没有准备好在v17中支持设计令牌和M3，但预计很快会在v17的某个小版本中会得到支持。</p><p>&nbsp;</p><p>在2022年第四季度，我们宣布了推出基于MDC的新Angular Material组件，并弃用具有相同功能但DOM结构和样式不同的旧组件。我们在v15中弃用了旧组件，并将在v17中将其移除。 虽然它们不再属于Angular Material v17包的一部分，但你仍然可以将应用程序更新到Angular v17的同时依然使用v16版本的Angular Material包。在v18之前，此兼容将一直支持，但在此之后新版本的Angular将不再兼容Angular Material v16。当然，为了防止你暂时无法执行项目迁移，我们与<a href=\"https://www.herodevs.com/support\">HeroDevs</a>\"进行了合作，他们将提供持续的付费支持。</p><p>&nbsp;</p><p></p><h1>开发者体验增强</h1><p></p><p></p><p>除了所有这些前瞻性的功能，我们还发布了一系列针对开发人员体验的小型增强功能！</p><p>&nbsp;</p><p></p><h1>实验阶段的视图转换功能支持</h1><p></p><p></p><p><a href=\"https://developer.chrome.com/docs/web-platform/view-transitions/\">视图转换API</a>\"可在DOM更改时实现视图的平滑转换。现在，在Angular路由器中，我们可以通过withViewTransitions功能直接支持此API。因此，在路由切换时，开发者可以通过浏览器的原生导航创建过渡动画。</p><p>&nbsp;</p><p>现在，通过修改启动函数中路由声明的配置，就可以为你的应用添加此功能，示例代码如下：</p><p>&nbsp;</p><p><code lang=\"null\">bootstrapApplication(App, {\n  providers: [\n    provideRouter(routes, withViewTransitions()),\n  ]\n});</code></p><p>&nbsp;</p><p>withViewTransitions接受带有onViewTransitionCreated属性的可选配置对象，该属性为开发者提供一些额外控制的回调：</p><p>&nbsp;</p><p>决定是否要跳过特定动画向文档添加样式类以实现自定义动画以及在动画完成时删除这些类等等</p><p>&nbsp;</p><p></p><h1>图像指令的自动预连接</h1><p></p><p></p><p>现在Angular的图像指令可以基于你提供的图片加载域来自动生成预连接链接。如果图像指令不能自动识别源和判断是一个LCP图像的预连接链接，那么它将在开发阶段就发出警告。</p><p>&nbsp;</p><p>可以在<a href=\"https://angular.io/guide/image-directive\">图像指令指南</a>\"中了解更多有关此功能的信息。</p><p>&nbsp;</p><p></p><h1>动画模块的延迟加载</h1><p></p><p></p><p>此功能可以使开发者应用包的初始体积减少60KB（gzip之后是16KB）。 该功能是由社区贡献者<a href=\"https://github.com/JeanMeche\">Matthieu Riegler</a>\"提出并实现，借助此功能，开发者可以通过提供异步函数来实现动画模块的延迟加载，示例代码如下：</p><p>&nbsp;</p><p><code lang=\"null\">import { provideAnimationsAsync } from '@angular/platform-browser/animations-async';\n\nbootstrapApplication(RootCmp, {\n  providers: [provideAnimationsAsync()]\n});</code></p><p>&nbsp;</p><p></p><h1>输入值转换</h1><p></p><p></p><p>通常我们会有一个接收布尔值的组件，但是，在给此类组件传值的时候是有限制的。例如，我们定了Expander组件：</p><p>&nbsp;</p><p><code lang=\"null\">@Component({\n  standalone: true,\n  selector: 'my-expander',\n  template: `…`\n})\nexport class Expander {\n  @Input() expanded: boolean = false;\n}</code></p><p>&nbsp;</p><p>然后我们会像下面这样使用：</p><p>&nbsp;</p><p><code lang=\"null\"></code></p><p>&nbsp;</p><p>此时，你会收到“字符串不能分配给布尔值”的错误提示。 借助输入值转换功能，通过配置输入装饰器就可以解决此问题，示例代码如下：</p><p>&nbsp;</p><p><code lang=\"null\">@Component({\n  standalone: true,\n  selector: 'my-expander',\n  template: `…`\n})\nexport class Expander {\n  @Input({ transform: booleanAttribute }) expanded: boolean = false;\n}</code></p><p>&nbsp;</p><p>可以在GitHub上找到此功能原始需求：</p><p><a href=\"https://github.com/angular/angular/issues/14761\">https://github.com/angular/angular/issues/14761</a>\"</p><p>&nbsp;</p><p></p><h1>作为字符串的Style和styleUrls</h1><p></p><p></p><p>Angular的每个组件都支持多样式表。然而多数情况下，当我给组件添加样式的时，在其样式数组中要么只有一个内联样式，要么只有一个外联样式。新功能做了如下调整：</p><p><code lang=\"null\">@Component({\n  styles: [`\n    ...\n  `]\n})</code></p><p>&nbsp;</p><p><code lang=\"null\">...\n@Component({\n  styleUrls: ['styles.css']\n})\n...</code></p><p>&nbsp;</p><p>更简单、更合逻辑写法：</p><p>&nbsp;</p><p><code lang=\"null\">@Component({\n  styles: `\n    ...\n  `\n})</code></p><p>&nbsp;</p><p><code lang=\"null\">...\n@Component({\n  styleUrl: 'styles.css'\n})\n...</code></p><p>&nbsp;</p><p>虽然我们会继续支持基于数组的多样式表。但新语法符合开发使用习惯，更直观，并且与自动格式化工具配合使用效果会更好。</p><p>&nbsp;</p><p></p><h1>社区Schematics</h1><p></p><p></p><p>为了支持社区Schematics的开发，我们在@schematics/angular/utility中提供了一些实用方法。现在开发者直接在Angular应用根目录导入表达式和添加提供者，同时将依赖项所具备的功能添加到package.json中即可完成Schematics集成。</p><p>&nbsp;</p><p>你可以通过<a href=\"https://angular.io/guide/schematics-for-libraries\">脚手架开发指南</a>\"这篇文章了解更多信息：</p><p><a href=\"https://angular.io/guide/schematics-for-libraries\">https://angular.io/guide/schematics-for-libraries</a>\"</p><p>&nbsp;</p><p></p><h1>用Angular构建未来</h1><p></p><p></p><p>在过去的六个月里，我们通过发布一些新功能不断提升开发体验和应用性能，从而持续Angular的复兴之路。 今天，我们很高兴在Angular的全新品牌和基于<a href=\"https://angular.dev/\">angular.dev</a>\"的全新学习体验中，看到了Angular复兴的势头。</p><p>&nbsp;</p><p>非常期待，下个版本中Angular在基于信号的响应式、混合渲染和学习体验上所带来的重大升级。</p><p>&nbsp;</p><p>我们很荣幸能够成为你使用Angular构建未来应用的一部分！ 感谢！</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://blog.angular.io/introducing-angular-v17-4d7033312e4b\">https://blog.angular.io/introducing-angular-v17-4d7033312e4b</a>\"</p><p></p><p></p><h5>相关阅读：</h5><p></p><p><a href=\"https://xie.infoq.cn/article/7baec545b8202471064494a69\">2023 重学 Angular</a>\"</p><p><a href=\"https://www.infoq.cn/article/oONc5r5opJF64kBCtzIv\">Angular v15 发布：可以脱离 NgModules 构建组件了</a>\"</p><p><a href=\"https://xie.infoq.cn/article/61e968dd45368e77c03fcbe10\">谈谈企业级前端 Angular 应用的定制化二次开发话题</a>\"</p><p><a href=\"https://xie.infoq.cn/article/ec0a13741cd7c4a72eea370ae\">如何快速上手 angular.js</a>\"</p>",
    "publish_time": "2023-11-16 10:19:02",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "百度资深研发工程师、文心一言 APP 技术负责人樊中恺，确认担任 QCon LLM 时代的大前端技术专题出品人",
    "url": "https://www.infoq.cn/article/cyBA56ToQEPYGDZKCu3X",
    "summary": "<p><a href=\"https://qcon.infoq.cn/2023/shanghai/?utm_source=infoqweb&amp;utm_medium=teacherart&amp;utm_campaign=7&amp;utm_term=1116&amp;utm_content=fanzhongkai\">QCon 全球软件开发大会</a>\"，将于 12 月在上海召开。百度资深研发工程师、文心一言 APP 技术负责人樊中恺将担任「<a href=\"https://qcon.infoq.cn/2023/shanghai/track/1599?utm_source=infoqweb&amp;utm_medium=teacherart&amp;utm_campaign=7&amp;utm_term=1116&amp;utm_content=fanzhongkai\">LLM 时代的大前端技术</a>\"」的专题出品人。在此次专题中，你将了解到 LLM 时代的大前端技术发展趋势与企业级应用开发的机遇和挑战。</p><p></p><p><a href=\"https://qcon.infoq.cn/2023/shanghai/track/1599?utm_source=infoqweb&amp;utm_medium=teacherart&amp;utm_campaign=7&amp;utm_term=1116&amp;utm_content=fanzhongkai\">樊中恺</a>\"，百度资深研发工程师，文心一言 APP 技术负责人，2008 年接触前端开发，2012 年开始移动端开发至今，曾先后负责百度浏览器、文库、阅读、百度 APP 前端技术架构、搜索前端架构、推荐前端架构、Paddle.js 等研发工作，对于端智能、工程化、前端架构等方向有较为丰富的经验。<a href=\"https://qcon.infoq.cn/202309/beijing/presentation/5408?utm_source=infoqweb&amp;utm_medium=teacherart&amp;utm_campaign=7&amp;utm_term=1116&amp;utm_content=fanzhongkai\">QCon 北京 2023 「明星讲师」</a>\"。</p><p></p><p>相信樊中恺的到来，可以帮助提升此专题的质量，通过对 LLM 时代大前端技术的解读，能够让你对大前端技术有更深入的了解，为企业面临相关机遇和挑战，提供了有效的解决思路。</p><p></p><p>除上述专题外，QCon 上海还将围绕&nbsp;<a href=\"https://qcon.infoq.cn/2023/shanghai/track/1595?utm_source=infoqweb&amp;utm_medium=teacherart\">GenAI和通用大模型应用探索</a>\"、<a href=\"https://qcon.infoq.cn/2023/shanghai/track/1596?utm_source=infoqweb&amp;utm_medium=teacherart\">AI&nbsp;Agent&nbsp;与行业融合应用的前景</a>\"、<a href=\"https://qcon.infoq.cn/2023/shanghai/track/1597?utm_source=infoqweb&amp;utm_medium=teacherart\">LLM&nbsp;时代的性能优化</a>\"、<a href=\"https://qcon.infoq.cn/2023/shanghai/track/1598?utm_source=infoqweb&amp;utm_medium=teacherart\">智能化信创软件&nbsp;IDE</a>\"、<a href=\"https://qcon.infoq.cn/2023/shanghai/track/1602?utm_source=infoqweb&amp;utm_medium=teacherart\">面向人工智能时代的架构</a>\"、<a href=\"https://qcon.infoq.cn/2023/shanghai/track/1604?utm_source=infoqweb&amp;utm_medium=teacherart\">性能工程：提升效率和创新的新方法</a>\"等专题进行交流。</p><p></p><p>QCon 上海 2023，相约 12 月！ 7 折优惠仅剩最后 2 天，现在购票，立减￥2040！咨询购票请联系：17310043226（微信同手机号）。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/01/0113b3dfb187d5f9988b7eb16d2e0594.png\" /></p><p></p>",
    "publish_time": "2023-11-16 11:33:24",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "OceanBase：中国场景推动树立分布式数据库四项新标准",
    "url": "https://www.infoq.cn/article/Mu0894he9sGM1JvWzlm4",
    "summary": "<p>11月16日，在OceanBase2023年度发布会上，OceanBase CEO杨冰介绍，中国数字经济的蓬勃发展催生了对分布式数据库的强大需求，这种需求也牵引了OceanBase坚定投入自主研发，从而推动树立了分布式数据库的四项新标准。据了解，四项新标准分别是：</p><p>&nbsp;</p><p>性能新标准：刷新TPC-C、TPC-H性能榜，3次打破世界纪录，可在高并发场景下按需实现不停机、不改应用的扩缩容和性能的线性增长，同时实现一份数据同时支持事务处理与实时分析；</p><p></p><p>容灾新标准：自研首个“三地五中心”容灾架构，建立城市级故障自动无损容灾新标准，满足国标金融6级容灾标准，保障城市级业务持续高可用；</p><p></p><p>高可用新标准：业内首个实现RPO=0、RTO＜8s，故障恢复进入秒级时代，时刻保障企业用户关键业务顺利运行；</p><p></p><p>架构新标准：单机分布式一体化，打破分布式技术的不可能，首次突破分布式数据库技术的单机性能瓶颈，适应企业全生命周期的业务需求。</p><p>&nbsp;</p><p>13年前，中国移动互联网爆发式增长，带来了前所未有的海量数据以及数据高并发，如何应对这一全球独一无二的海量数据处理问题，OceanBase选择了完全自研之路。杨冰介绍：“刚开始举步维艰，但当我们完成了支付宝核心系统替换，轻舟已过万重山。对代码完全的掌控力和掌控权也使OceanBase能够逢山开路遇水搭桥，厚积薄发。”</p><p>&nbsp;</p><p>2010年，OceanBase&nbsp;关注到中国独特场景带来的海量数据处理挑战，从0起步，致力于完全自研国产分布式数据库。2022年，&nbsp;OceanBase&nbsp;发布单机分布式一体化数据库OceanBase 4.0“小鱼”，突破分布式数据库的边界，让分布式数据库真正走向通用。</p><p>&nbsp;</p><p>这背后是13年来，OceanBase&nbsp;持续的自研投入，在性能、高可用、性价比和单机分布式一体化架构上不断达到技术新高度，得到行业认可，推动树立分布式数据的新行业标准</p><p>&nbsp;</p><p>OceanBase首席科学家阳振坤在发布会现场表示，唯有完全自研才能真正掌握核心代码，主导产品发展，成为国际一流的数据库系统。“OceanBase用十年构筑了分布式关系数据库的根技术，OceanBas的初心是让数据处理越来越普惠，为此OceanBase会在技术上坚持自研、持续突破。”</p>",
    "publish_time": "2023-11-16 11:48:49",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]