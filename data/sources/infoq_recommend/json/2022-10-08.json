[
  {
    "title": "架构师（2022 年 10 月）",
    "url": "https://www.infoq.cn/article/kHgvXNRNW124to0AJFeG",
    "summary": "<h2>卷首语：Go 语言专家曹大谈十年技术生涯：有理想，但不理想化</h2>\n<p><strong>作者｜贾亚宁</strong></p>\n<p>每一个互联网从业者可能都思考过这样的问题：如何能从人才大军中脱颖而出，如何能更高效率地获得成长和发展？关于这个话题，我们对 Go 语言专家曹大（曹春晖）老师进行了采访，一起来看看他的实践和思考吧。</p>\n<p><strong>InfoQ：你的职业生涯中印象最深刻的挑战是什么？你是如何解决的呢？</strong></p>\n<p>曹春晖：技术的挑战都不算什么大事，工程方面的问题一定可以找到解决方案，找不到方案的那就是世界难题了。在公司里最大的挑战是有 idea 的时候，要说服老板去做（碰到太多次了），因为公司里的老板背景各异，不同的人不可能对一件事情有相同的看法，这时候要达成共识就需要反复沟通，拉齐、磨合、开会，摆出各种软件工程系统架构理论，再搬出硅谷的 FAANG 是怎么做的，很心累。能说服老板的话，其它事情都是小事，这很难避免，因为大公司都是这样的。</p>\n<p><strong>InfoQ：方便分享一下你的职业发展路径吗？你认为影响技术人的职业发展的重要因素有哪些？</strong></p>\n<p>曹春晖：我的职业发展参考价值不大，其实这么多年看下来，在同样靠谱的前提下，职业的发展顺利与否主要都是看运气……了解了一些公司运作的规律和招人的潜规则以后，很多事情比较无奈，不太好说（真心话）。</p>\n<p>学习方面给各位技术人的建议是要养成终生学习的习惯，不要学到某个程度就固步自封，即使是后端技术，五年前和现在其实差别已经挺大的了。我以前写过一篇《工程师应该如何学习》，介绍过一些学习的渠道和方法，可以参考。工作中打过交道的人，其实很多工作十年的人跟刚毕业的学生没什么区别，你看看你们公司的架构师，CRUD 都能搬出 100 种理论来说明为什么要这么设计，这才是真水平。</p>\n<p>另外，写代码以外的技能也是要刻意训练的，比如口才、演技等，很多踏实写代码的人其实在大公司里很吃亏，要理解什么是一定程度上的按闹分配。</p>\n<p><strong>InfoQ：作为常年在 Go 语言世界里探索的人，你认为什么是学习 Go 语言最高效的方法？</strong></p>\n<p>曹春晖：入门的话就看《The Go Programming Language》，最好的学习方法就是把书上的例子都抄一遍。可以翻翻优秀的 Go 项目来学习他们是如何使用这门语言的，前面也提到了，awesome-go 里有很多这样的项目。直到你觉得 Go 的所有语法都了熟于心，就算是入门了吧。</p>\n<p>进阶要去学习怎么定位 Go 在线上系统的问题，成为一个 Go 的高级工程师。这部分需要大家了解一些 Go 的底层知识，学习基于 goroutine 和 channel 的各种并发编程模式，以及常用的工具链：比如 pprof 怎么用，怎么用 --base 去找内存泄露，出了性能问题怎么做优化等等。要达到的目标是：线上的 Go 系统出了问题，能够通过自己的知识储备快速定位。Go 的底层知识现在国内比 java 圈还卷，文章很泛滥，可以随意搜搜，择优阅读。</p>\n<p>下一步是要通过多接触各种场景（比如大流量，高并发的，业务的，基础设施的等等），同时与其它语言横向做对比，了解 Go 语言在各种场景下的优缺点，不要成为一个语言原教旨主义者，比如我在工作的过程中就看到过不少 Go 其实就没法应付的场景，大家硬着头皮用，硬着头皮 hack，项目搞到最后优化起来也很痛苦，可能还不如直接去用 Rust。尽量多思考，也不要忌讳与其它语言的熟手交流。</p>\n<p>相比 PHP 之类的语言，Go 的最大好处是可以跨越很多领域，从业务到基础设施，如果你业务干腻了，技术储备又足够，也可以去玩玩基础设施开发 (当然，我不建议你总是换， 实在手痒可以业余时间给一些开源基础设施项目提提 PR)。也就是大家的工作内容选择范围会大很多，这又需要考验你的智慧了，选择哪个领域才能赚到钱，我没法给出很具体的建议，哈哈。</p>\n<p><strong>InfoQ：你是如何做到长期内容输出的呢？对想要开始的小伙伴有什么建议吗？</strong></p>\n<p>曹春晖：要给自己设立一个简单的目标，同时不要影响到工作，我之前写了很多年 blog，体感最合适的是一个月两篇文章。内容可以和工作相关，也可以无关。两周一篇，压力也不太大，可以没事想起来就写写。</p>\n<p>输出是很重要的，费曼学习法告诉我们，你要把知识讲得明白，才能确定自己是真的会了，只是应付工作里的那点东西，很多时候人会变得懒惰，慢慢也就不想思考了。我曾经在某公司听到一个很高级别的人自豪地说他很多年没看一本书，还很骄傲地讲给他的下属听，我不认为新进入行业的人能够有像这位一样靠公司起飞的运气，还是要把学习当回事的。</p>\n<p>因为增加了输入，这些输入一定会在某个时间点对你的工作产生帮助。在某大公司的时候我也看到内网上一些优秀的文章作者，他们基本上都保持了持续内容输出的习惯，这也意味着他们看了非常非常多的书。有些人的读书速度能快到匪夷所思的程度 (一年 68 本)，不知道他们是怎么做到的。</p>\n<p>多积累一些知识以后的输出是很有价值的，我之前写的系统设计的文章被人看到以后会来问我是怎么做的，说不定聊着聊着就成同事了。</p>\n<h2>目录</h2>\n<p><strong>热点 | Hot</strong><br />\nJavaScript 框架大战已结束，赢家只有一个<br />\n接手了一座年收入 2000 万美元的代码“屎山”，我到底是该重写还是该跳槽？<br />\n谷歌推出 Carbon 后，我在思考为什么 Rust 没能成为 C++ 的正式继任者</p>\n<p><strong>理论派｜Theory</strong><br />\n理想汽车：从 Hadoop 到云原生的演进与思考<br />\n去哪儿旅行微服务架构实践</p>\n<p><strong>推荐文章 | Article</strong><br />\n从一线研发到公司创始人，基础软件创业者迷雾中与市场赛跑<br />\n作为现代开发的基础，为什么 TDD 没有被广泛采用？</p>\n<p><strong>观点 | Opinion</strong><br />\nReact 老矣，我建议大家用用别的框架</p>",
    "publish_time": "2022-10-08 09:34:04",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "去哪儿网 Service Mesh 落地实践：100%容器化打底，业务友好是接入关键",
    "url": "https://www.infoq.cn/article/USjDHBrY4DtG9BjOKE3A",
    "summary": "<p>自 2011 年引入 Dubbo 框架至今，去哪儿网的微服务架构已经有了十多年的历史。时至今日，去哪儿网架构已经形成了 Dubbo、HTTP 协议为主，多语言共存的格局。</p><p></p><p>根据去哪儿网基础架构部高级技术总监朱仕智分享的数据，现在去哪儿网 Dubbo 服务接口有 18,000 多个、HTTP 域名超过 3500 个，内部大约有 Java、Golang、Node 和 Python 等 5 种语言的技术栈，其中以 Java 和 Node 为主。此外，去哪儿网在线运行的应用大约 3000 多个、MQ 应用主题超 13,000 个。</p><p></p><p>随着业务的不断发展，多语言、多协议给基础架构团队带来了不小的治理问题。</p><p></p><p>首先，多语言的复杂性主要在于 SDK 的重复实现，每个治理逻辑需要开发不同的语言版本，此后还要一直对其进行维护，这是一份冗余且负担很重的工作。</p><p></p><p>在多协议治理上，一方面，去哪儿网内部有 Cactus 平台对 Dubbo 进行治理，治理功能相对完善。另一方面，去哪儿网对 HTTP 的治理主要通过 OpenRestry，治理能力相对薄弱，一些必需的治理需求零散分布在多个平台，对开发同学很不友好。</p><p></p><p>Dubbo 和 HTTP 治理能力不统一导致了重复造轮子情况，增加了业务的开发和维护成本。</p><p></p><p>此外，业务和中间件强耦合，但业务部门与基础架构部门对升级更新的意愿并不同步。基础架构部门不断升级更新来完善中间件，但业务研发在不影响使用情况下并不希望频繁更新。所以每次发布新版本后，基础架构团队要花很长的时间进行推广，致使整个迭代周期变长。</p><p></p><p>而 Service Mesh 将服务治理能力下沉到了 sidecar，SDK 只需要负责编解码、与 sidecar 通信，通用逻辑基本不用修改，只要对 sidecar 修改就可以应用到所有语言和框架，于是在去年，去哪儿网开始组织团队引入 Service Mesh 来解决自身多语言、多框架的治理难题。</p><p></p><h2>容器化基础</h2><p></p><p></p><p>在去哪儿网资深开发工程师李佳龙看来，容器化下比较适合引入 Service Mesh。</p><p></p><p>大概从 2014 年起，去哪儿网便开始使用 Docker、Mesos、Kubernetes（以下简称 K8s）等来解决测试环境构建困难的问题，也逐渐尝试基于容器部署 ES、MySQL 等中间件服务。到了 2021 年底，去哪儿网全面实现容器化，业务服务基本完成上云。从效果数据来看，容器化虚拟比例从 1：17 提升到 1：30，资源利用率提升 76%，宿主运维时间由天变成了分钟级，环境稳定性差、交付慢、可扩展性差和服务器成本高等问题都得到了有效解决。</p><p></p><p>经过多年积累，去哪儿网已经为引入 Service Mesh 打下了坚实的基础。引入 Service Mesh，本质上也是去哪儿网步入云原生实践新阶段——多方向探索的体现之一。</p><p></p><p>在去年加入去哪儿网后，李佳龙主要负责 Service Mesh 的落地工作。团队基于去哪儿网的现状，明确了对新服务治理体系的期望：多语言、多协议统一治理、治理能力增强，同时可以将治理能力下沉，实现基础组件开发周期和业务开发周期解耦。</p><p></p><p></p><h2>如何做技术选型</h2><p></p><p></p><p>整个实践过程主要分为三个阶段：调研、开发和推广。调研阶段的主要任务是技术选型。去哪儿网团队用了两周左右的时间，调研了其他企业的落地情况。</p><p></p><p>自 2011 年引入 Dubbo 框架至今，去哪儿网的微服务架构已经有了十多年的历史。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/9b/9bf57db4a99936c49b30d031c5d32f25.png\" /></p><p></p><p>如何找到适合自己的产品呢？首先，由于业界已经有成熟的产品，因此去哪儿网没有选择重复造轮子，而是基于业内已有开源软件进行选型。其次，去哪儿网团队还从产品是否成熟、社区活跃度、性能是否满足公司需求，以及开发和维护难度等方面进行了考察。</p><p></p><p>最终，去哪儿网选择了蚂蚁开源的 MOSN 作为数据面。MOSN 经过了阿里双十一几十万容器生产级别验证，产品自身已经成熟。另外，MOSN 社区比较活跃，迭代也较快，更新周期基本维持在了两个月左右。</p><p></p><p>语言也是重要的考虑因素。由于在 C++ 技术栈方面人才储备有限，团队放弃了流行的 Envoy。MOSN 的开发语言是 Go，在性能、开发、维护难度和灵活性上有优势，虽然不是去哪儿网使用的主要语言，但开发人员入门和上手都比较快。MOSN 既可以替代 Envoy，也可以集成 Envoy 在网络层高性能的优势，并将其作为自己的网络插件使用。</p><p></p><p>控制面上，去哪儿网选择了 Istio，并根据自身需要对其进行了二次开发。Istio 使用 XDS 协议与数据面进行交互，是很多企业的首选，去哪儿网选择紧跟社区的脚步。但原生的 Istio 有个问题，就是和 K8s 耦合非常严重：主要体现在 K8s 既是注册中心又是配置中心，以及 sidecar 注入、启动配置和网络模型等。这导致去哪儿网团队面临着以下问题：</p><p></p><p>K8s 存储是以应用为维度，但 Dubbo 是以 Service 为维度，维度不统一问题怎么解决？去哪儿网内部容器要和 KVM 共存，如何解决兼容问题?公司内部已有比较成熟的注册中心和配置中心，一刀切必然会引入很多适配和运维成本问题。如果遇到定制化需求，是否会影响 K8s 集群的稳定？</p><p></p><p>去哪儿网希望 K8s 更多的用于服务编排，因此在最初商定方案时，选择解耦 K8s，采用内部使用多年的注册中心和配置中心。于一些启动配置，则依赖去哪儿网内部的配置中心（QConfig），同时团队自研了 McpServer 模块替代 K8s 来对接 Istio。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/18/1810e4652b6f805e8aff74a9ad9bc3dd.png\" /></p><p></p><p>整体架构</p><p></p><p></p><h2>具体实践如何？</h2><p></p><p></p><p>接入 Mesh 后，业务主要关心的就是性能、治理能力和问题排查。因此在做好技术选型后，去哪儿网团队便开始设计实践方案，并花了数月的时间进行研发。</p><p></p><p></p><h3>流量管理</h3><p></p><p></p><p>目前，业界将流量从 SDK 拦截到 sidecar 的方式主要有两种：iptables 拦截和流量转发。但由于 iptables 的可运维性和可观察性较差，配置较多时还会出现性能下降的问题，因此很多公司选择了流量转发的方式，去哪儿网也是如此。</p><p></p><p>去哪儿网主要使用了两种流量转发方式：一是升级 SDK，在 SDK 中直接将请求转发到本机 sidecar；二是域名拦截，例如使用 dnsMasa 将 xx.qunar.com 的请求转发到本机 sidecar。</p><p></p><p>李佳龙提醒道，引入 Service Mesh 后，流量安全值得特别关注，因为之前两个服务的调用变成了四个服务间的调用，大大增加了不稳定性。对此，去哪儿网主要采取了四方面的措施来保证流量的安全：</p><p></p><p>SDK 自动调用降级。当业务进程与 sidecar 连接断开 (基于健康检查) 时，调用降级为直连调用。sidecar 节点故障剔除。sidecar 会对 upstream 的节点列表进行健康检查，一旦发现连接异常就快速剔除。用户可以在新的统一治理平台 Captain 上一键切入 / 切出 Mesh 模式。柔性可用。为保证可用性，当控制面出现问题时，sidecar 会使用缓存数据；当注册中心或配置中心出现异常，MCPServer 以及 Istio 也可以使用缓存数据。</p><p></p><p></p><h3>Sidecar 管理</h3><p></p><p></p><p>对于 sidecar 的配置、部署、升级、回滚和灰度等，去哪儿网团队将其整合到了运维面上。</p><p></p><p>以 sidecar 的升级为例，Sidecar 的升级可以分为两个场景：原地升级和服务部署时升级。前者不需要重新部署服务，但需要确保升级对用户透明、流量无损。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/ef/ef4d992e6d64bec1e16ab805754ce4e7.png\" /></p><p></p><p>Sidecar 的注入和升级</p><p></p><p>对于原地升级，由于 sidecar 容器和业务容器是同属一个 pod 的两个独立容器，基础架构团队将 MosnAgent 作为 sidecar 容器的 1 号进程，用于管理 sidecar 的生命周期，例如启停、健康状态检查和升级等。新版本发布时，会将 sidecar 镜像推送到镜像仓库，同时将二进制包推送到对象存储。</p><p></p><p>基础架构团队通过 sidecar 管理平台，可以对 sidecar 容器发送升级指令，MosnAgent 会拉取对应版本的 mosn 包，之后启动新版本 mosn，并通过 fd 迁移机制，完成无损升级流程。</p><p></p><p>而部署时升级，发布平台会请求 sidecar 管理平台来获取 sidecar 配置，包括是否注入、sidecar 版本、环境变量、配额信息等，然后生成服务的 yaml 配置。注意在部署时，有可能遇到 sidecar 容器、业务容器的启用顺序问题。如果 sidecar 容器未启动成功或者配置未拉取成功、但业务容器已经 ready，那么请求就会失败。基础架构团队设置成 sidecar 先于业务容器启动，并通过配置 K8s 的 postStart 钩子函数，来保证正确的启动顺序。</p><p></p><p>需要注意的是，Istio 下发配置时，也可能发生顺序异常问题。去哪儿网团队通过 Istio merkeltree 来跟踪资源下发进度，通过暴露接口来查询每个资源是否全量下发到 sidecar。</p><p></p><p>另外，运维面还负责对接内部系统，如内部配置中心、全链路监控系统、报警系统、镜像仓库及对象存储等。</p><p></p><p></p><h3>性能优化</h3><p></p><p></p><p>在性能优化方面，首先由于业务容器与 sidecar 容器同属一个 pod，基础架构团队选择了使用 unix domain socket 进行通信，以此规避网络栈、优化性能。</p><p></p><p>其次，团队对 Dubbo 协议进行了优化。sidecar 接收到请求后的第一步是获取路由信息，用以服务寻址。按照 Dubbo 原来的设计，路由信息 (service/method/group 等) 存放在 body 中，但为了避免不必要的 body 反序列化，团队扩展了内部 Dubbo 协议，将路由信息放置到了扩展 header 中。</p><p></p><p>再者，团队选择按需加载 xDS 数据方式。Sidecar 启动时会请求控制面拉取 xds 数据，但是原生的 Istio 会拉取当前集群中所有服务数据，导致 sidecar 资源占用过多以及推送风暴，大大制约了 Service Mesh 的集群规模，这也是很多公司落地 Service Mesh 要解决的问题。去哪儿网的解决方式是配合内部 Spring Cloud Qunar 框架，在编译器采集订阅关系，并扩展 xds 协议，来实现按需加载。</p><p></p><p>除了按需加载配置，基础架构团队也在优化推送性能，统一服务注册模型等。</p><p></p><p></p><h3>治理能力</h3><p></p><p></p><p>针对之前治理功能分散、能力不统一的问题，基础架构团队将 Dubbo 和 HTTP 统一到了新的 Captain 平台。</p><p></p><p>“在设计时，Captain 要尽量做到服务治理与协议无关。”李佳龙说道。比如，之前 Dubbo 服务需要在项目中配置参数支持调权预热、HTTP 在发布平台配置支持引流预热或者自定义接口预热，引入 Service Mesh 后就可以很方便地支持 Dubbo/HTTP 调权、引流两种预热模式。</p><p></p><p>此外，Captain 增强了很多服务治理能力，例如多维度的限流策略，包括基于应用粒度限流和基于优先级限流。业务团队既可以根据应用的不同来设置不同的限流阈值，也可以根据不同的流量来源设置不同的优先级，优先处理有价值的请求。</p><p></p><p>如下图所示，当流量达到设定的阈值时会触发限流，这时流量会进入到多个优先级队列，可以按照优先级处理。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/50/50bbf6e1dea36c7366f388949b3f3f77.png\" /></p><p></p><p>此外很多情况下，业务会将超时时间、限流阈值设置得比较大或比较小，这未能起到应尽的作用，基础架构团队根据监控数据和合理算法，会智能推荐超时、限流等参数。</p><p></p><p></p><h2>如何进行推广</h2><p></p><p></p><p>目前，去哪儿网已经在基础平台、机票等部门开始推广和试行 Service Mesh。</p><p></p><p>“推广是最为关键、也是比较容易出现阻塞的地方。因为对于用户来说，让系统最稳定的做法就是不轻易做变动。”李佳龙说道。</p><p></p><p>那么，如何让业务更容易接受 Service Mesh 呢？去哪儿网团队先是在内部做了关于 Service &nbsp;Mesh 基本认识的分享，让业务了解接入 Mesh 后都能得到哪些收益。</p><p></p><p>然后对于新服务治理平台，基础架构团队也注意保留了很多业务的使用习惯。比如在实际使用中，超时时间等治理参数与路由的相关度较低，业务更习惯作为服务提供方配置某个接口的超时时间，或者作为服务调用方配置要调用服务的超时时间。但在 xDS 协议中，超时时间等治理参数配置在服务提供方，并且与路由绑定。因此，基础架构团队做了部分扩展，业务可以从服务提供方、调用方两个角度来进行配置，并以接口为维度，这些配置包括超时、重试、备份请求、负载均衡策略等。</p><p></p><p>便捷性对业务来说也是非常重要的，业务希望切到 Mesh 后能够方便地查询问题，日志、trace、监控报警等内部系统的打通也是推广的前提。</p><p></p><p>基础架构团队现在提供了两种 Mesh 接入方式：第一种是接入新的开发框架 Spring Cloud Qunar，业务需要做部分改动；第二种是无侵入地一键接入，业务不需要修改代码，这也是接受度较高的一种方式。</p><p></p><p>另外，去哪儿网提供了按照接口级别的接入方式，业务可以按照百分比来切入 Mesh，而不是一刀切地接入。基础架构团队的策略是让业务先从一个小的接口、小的流量来接入，业务接受了之后再扩大接入范围。</p><p></p><p>在李佳龙看来，便捷易用性问题一定程度上确实阻碍了 Service Mesh 的落地。</p><p></p><p>一方面，从业务角度看，使用者更加在意 Mesh 接入后是不是好用、操作是不是简单、切换起来是不是安全和方便、需求是不是能够满足、能不能保留之前的研发习惯等等。另一方面，从开发角度看，企业开发 Service Mesh 时通常有很多工作，比如进行二次开发并与内部系统打通，还有诸如 xDS 按需下发，sidecar 管理等目前没有统一标准的工作，这些都需要维护成本。公司基础设施之间有差异，这些都需要决策者考虑清楚。</p><p></p><p></p><h2>结束语</h2><p></p><p></p><p>Service Mesh 不是一个很新的概念，它的本质就是解耦，具体实现起来就是语言 SDK 负责编码以及与 sidecar 的通信，这部分比较固定，不包含治理功能。虽然还是多个实现，但是复杂度降低了一个量级，从而将更多的功能实现，抽离到独立的 sidecar 进程，只需要实现一次。“所以本质上，解决多语言多协议的复杂问题，是分离了变与不变，这也是去哪儿网进行软件架构时的常用方式。”李佳龙说道。</p><p></p><p>那么对于企业来说，是不是要容器化后才能够接入 Service Mesh 呢？李佳龙表示这不一定。</p><p></p><p>“只能说，Service Mesh 天然比较适合容器化的场景，比如 Istio 方案默认使用者已经具备 K8s 的基础设施了，但是我们仍然可以有多种方式支持虚机接入服务网格，只要解决掉 sidecar 注入、升级，流量拦截，服务注册发现等。而且我们设计之初去除了 K8s 的耦合，接入虚机也变得更方便。按照去哪儿的云原生的发展来看，容器化作为云原生架构的底座，在容器之上能更好的支持 Service Mesh、Serverless 等。”</p><p></p><p>就中小企业而言，李佳龙表示，中小企业首先考虑的更多是业务。业务越来越多、越来越复杂后，才可能会出现多语言、多框架的问题。只有确实出现这个问题时，才应该开始考虑是否引入 Service Mesh。此外还需要考虑自身的基础设施、团队技术储备等是否支持落地。Service Mesh 是利用低复杂的技术去解决高复杂度的问题，如果本身复杂度不高，引入 Service Mesh 这样的技术只会增加复杂度，得不偿失。</p><p></p><p>还有一个值得关注的方面就是性价比。引入 Service Mesh 的新增成本包括 sidecar 所占有的资源，比如每个 sidecar 占用的 CPU、内存、磁盘以及其他如 trace 存储、日志存储等存储资源。另外，像请求耗时增加、系统开发维护等会产生相应成本，因此去哪儿网目前对于各类日志是按需开启，只打印耗时高的 trace 信息。</p><p></p><p>”不过目前看，Service Mesh 确实带来了很多好处。”李佳龙说道，“首先便是统一了多语言、多框架的治理能力，提供丰富的治理功能。另外对业务开发透明，减少了业务的使用成本。与业务解耦后，我们的推广周期也大大缩短。”</p><p></p><p>“Service Mesh 应该会是未来的一个发展趋势。”李佳龙表示，“之后去哪儿网会在可观察性、性能优化、多语言支持上持续发力。”</p><p></p><p>嘉宾介绍</p><p></p><p>李佳龙，2021 年加入去哪儿网基础架构部，担任资深开发工程师，近五年专注于云原生、基础架构等领域，负责去哪儿内部 Service Mesh 和新服务治理平台 Captain 的研发落地等工作。</p><p></p><p></p>",
    "publish_time": "2022-10-08 10:37:39",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Unstructured Data Summit 2022《2022首届非结构化数据峰会》1",
    "url": "https://www.infoq.cn/article/De3kqyQGPuD0vwdfoWOc",
    "summary": "<p>2022 年 9 月 24-25 日，首届非结构化数据峰会（2022 Unstructured Data Summit）在线上举行。本次峰会由 Zilliz 主办，主题为「矩阵革命，向量连接世界」，峰会设置了一系列 Keynote 和分论坛演讲，围绕人工智能在非结构化搜索领域的顶尖技术、热门话题、前沿观察展开分享和探讨，共同探索行业发展的新风向。<br />\n本期视频为非结构化数据峰会 24 日上午场。</p>",
    "publish_time": "2022-10-08 14:47:35",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Unstructured Data Summit 2022《2022首届非结构化数据峰会》3",
    "url": "https://www.infoq.cn/article/JtGhroQY6HYwaK17CKdT",
    "summary": "<p>2022 年 9 月 24-25 日，首届非结构化数据峰会（2022 Unstructured Data Summit）在线上举行。本次峰会由 Zilliz 主办，主题为「矩阵革命，向量连接世界」，峰会设置了一系列 Keynote 和分论坛演讲，围绕人工智能在非结构化搜索领域的顶尖技术、热门话题、前沿观察展开分享和探讨，共同探索行业发展的新风向。<br />\n本期视频为非结构化数据峰会 25 日上午场。</p>",
    "publish_time": "2022-10-08 14:47:41",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Unstructured Data Summit 2022《2022首届非结构化数据峰会》4",
    "url": "https://www.infoq.cn/article/QDRmW3Mp1Q1WGyZ22rxt",
    "summary": "<p>2022 年 9 月 24-25 日，首届非结构化数据峰会（2022 Unstructured Data Summit）在线上举行。本次峰会由 Zilliz 主办，主题为「矩阵革命，向量连接世界」，峰会设置了一系列 Keynote 和分论坛演讲，围绕人工智能在非结构化搜索领域的顶尖技术、热门话题、前沿观察展开分享和探讨，共同探索行业发展的新风向。<br />\n本期视频为非结构化数据峰会 25 日下午场。</p>",
    "publish_time": "2022-10-08 14:47:47",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Unstructured Data Summit 2022《2022首届非结构化数据峰会》2",
    "url": "https://www.infoq.cn/article/hTJ3SXq5vS6mFa8UxTbP",
    "summary": "<p>2022 年 9 月 24-25 日，首届非结构化数据峰会（2022 Unstructured Data Summit）在线上举行。本次峰会由 Zilliz 主办，主题为「矩阵革命，向量连接世界」，峰会设置了一系列 Keynote 和分论坛演讲，围绕人工智能在非结构化搜索领域的顶尖技术、热门话题、前沿观察展开分享和探讨，共同探索行业发展的新风向。<br />\n本期视频为非结构化数据峰会 24 日下午场。</p>",
    "publish_time": "2022-10-08 14:47:51",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "深圳国际金融科技大赛「绿色金融科技分享」",
    "url": "https://www.infoq.cn/article/zoWTxiawoZwaHoSscI3Y",
    "summary": "<p><img alt=\"\" src=\"https://static001.infoq.cn/resource/image/1f/22/1f34cba351e799a6dac2f29348ce2422.jpg\" /></p>",
    "publish_time": "2022-10-08 15:39:15",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "MySQL 分布式事务的“路”与“坑”",
    "url": "https://www.infoq.cn/article/yGfFSW7sPVRCIoKOkXiD",
    "summary": "<p></p><h2>一、数据库事务</h2><p></p><p></p><h4>1.1 普通本地事务</h4><p></p><p></p><p>分布式事务也是事务，事务的 ACID 基本特性依旧必须符合：</p><p>A：Atomic，原子性，事务内所有 SQL 作为原子工作单元执行，要么全部成功，要么全部失败；C：Consistent，一致性，事务完成后，所有数据的状态都是一致的。如事务内A给B转100，只要A减去了100，B账户则必定加上了100；I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。</p><p></p><p>普通的非分布式事务，在一个进程内部，基于锁依赖于快照读和当前读，比较好实现 ACID 来保证事务的可靠性。但分布式事务参与方通常在不同机器的不同实例上，原来的局部事务的锁不能保证分布式事务的 ACID 特性，需要引入新的事务框架，MySQL 的分布式事务是基于 2PC（二阶段提交）实现，下面详细介绍下 2pc 分布式事务。</p><p></p><h4>1.2 基于 2pc 的分布式事务</h4><p></p><p></p><p>分布式事务有多种实现方式，如2PC（二阶段提交）、3PC（三阶段提交）、TCC（补偿事务）等，MySQL 是基于 2PC 实现的分布式事务，下面介绍 2PC 分布式事务实现方式。</p><p></p><p></p><blockquote>两阶段提交：Two-Phase Commit , 简称 2PC，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法。&nbsp;</blockquote><p></p><p></p><p>2PC的算法思路可以概括为，参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报，决定各参与者是否要提交操作还是中止操作。这里的参与者可以理解为 Resource Manager (RM)，协调者可以理解为 Transaction Manager（TM)。</p><p></p><p>下图说明了RM和TM在分布式事务中的运作过程：</p><p>第一阶段提交：TM 会发送 Prepare 到所有RM询问是否可以提交操作，RM 接收到请求，实现自身事务提交前的准备工作并返回结果。&nbsp;第二阶段提交：根据RM返回的结果，所有RM都返回可以提交，则 TM 给 RM 发送 commit 的命令，每个 RM 实现自己的提交，同时释放锁和资源，然后 RM 反馈提交成功，TM 完成整个分布式事务；如果任何一个 RM 返回不能提交，则涉及分布式事务的所有 RM 都需要回滚。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/45/45c019bb573c9398a6c947b4af392789.png\" /></p><p></p><p></p><h2>二、MySQL 分布式事务 XA</h2><p></p><p></p><p>MySQL 分布式事务 XA 是基于上面的 2pc 框架实现，下面详细介绍 MySQL XA 相关内容。</p><p></p><h4>2.1 XA事务标准</h4><p></p><p><img src=\"https://static001.geekbang.org/infoq/52/52f92590b12aebfa8d6dd70bc9fde97d.png\" /></p><p></p><p></p><blockquote>X/Open 这个组织定义的一套分布式XA事务的标准，定义了规范和API接口，然后由厂商进行具体的实现。</blockquote><p></p><p></p><p>XA 规范中分布式事务由 AP、RM、TM 组成：</p><p></p><p>如上图，应用程序 AP 定义事务边界（定义事务开始和结束），并访问事务边界内的资源。资源管理器 RM 管理共享的资源，也就是数据库实例。事务管理器 TM 负责管理全局事务，分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚、失败恢复等。MySQL 实现了 XA 标准语法，提供了上面的 RMs 能力，可以让上层应用基于它快速支持分布式事务。</p><p></p><h4>2.2 MySQL XA语法</h4><p></p><p></p><p>XA START xid:开启一个分布式事务 xid。XA END xid: 将分布式事务 xid 置于 IDLE 状态，表示事务内的 SQL 操作完成。XA PREPARE xid: 事务 xid 本地提交，成功状态置于 PREPARED 失败则回滚。XA COMMIT xid:&nbsp; 事务最终提交，完成持久化。XA ROLLBACK xid: 事务回滚终止。XA RECOVER: 查看 MySQL 中存在的 PREPARED 状态的 XA 事务。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/60/60f4326f8bfc5f62bd252e79f1859dce.png\" /></p><p></p><p></p><h5>（1）语法要点</h5><p></p><p></p><p>参与分布式事务的实例之间，在数据库内核视角没有直接关联，互相不感知状态，且一个分布式事务中各个节点上的子事务均可单独执行无依赖，他们之间的关联是通过全局事务号在应用层建立的。</p><p></p><p>与普通事务比，XA 事务开启时多了一个全局事务号，结束时多了一个 end 动作 和 prepare 动作。</p><p></p><p>XA START, 开启一个分布式事务，需要指定分布式事务号。XA END，在内部仅是一个状态变化，声明当前XA事务结束，不允许追加新的sql语句，无其它作用，业界有人提出XA事务框架去掉这一步，减少一次网络交互，提高性能。XA PREPARE，写 binlog 和 redo log，预提交事务，并将分布式事务信息保存到全局内存结构，让其它连接可以查询、回滚、提交，如果 prepare 失败则回滚。XA COMMIT，真正提交事务，修改事务状态，释放锁资源。如果实例上 XA PREPARE 已经成功，那么它的 XA COMMIT 一定能成功。</p><p></p><p>XA 事务示例：201 用户给 202 用户转账 1000 元，简化如下：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/f5/f5b72aff7edff971619bdd692776651a.png\" /></p><p></p><p>第 1 步，开启一个分布式事务，xa_ts:10001 是应用层定义的全局事务号，实例 1 和实例 2 通过它来构建分布式事务。</p><p></p><p>第 2、3 步是普通事务语句。</p><p></p><p>第 4 步，声名 xa 事务结束，在此之后不能再追加更新插入查询等语句，不属于这个分布式事务也不允许，其它语句放在 xa commit 或 xa rollback 之后。</p><p></p><p>第5步，prepare 成功后，上层应用可以发起第 6 步提交事务。注意，必须是所有参与这个分布式事务的全部节点均 prepare 成功，即实例 1 和实例 2 都完成 prepare，应用端才能发起提交，两阶段提交的框架核心点就在此。</p><p></p><p>如果有节点在前 5 步不能成功，所有参与分布式事务的节点都必须回滚。如实例 2 是账户加 1000 元，基本上什么情况都能成功，肯定能成功执行第 5 步，但实例 1 就未必了，账户要扣 1000 元，可能资金不够，会出错回滚，若实例 1 不能执行到 prepare，所有分布式事务参与者也必须回滚，所以实例 2 也要回滚。如果第 5 步全部成功，有一个节点执行了第 6 步提交了事务，那么所有节点必须要均提交，否则就会导致数据不一致。处于 xa prepare 不提交会占用资源，残留 xa 事务等价于存在长事务，对刷脏和 purge 等都有影响，业务层最好要立即提交。</p><p></p><p>（2）残留 XA 事务如何处理</p><p></p><p>上面说到 xa 事务不提交等价于长事务，一旦 prepare 成功要立即提交，否则会带来很多问题。但是数据库 crash 或应用系统出错 crash 等原因都可能导致 xa 事务未能全部提交，这些残存 XA 事务如何处理？这就要用到上面的 XA RECOVER 语法了，执行 xa recover 查看未提交 XA 事务，选择对应的进行 rollback 或 commit。如果仅 gtrid_length 字段有值一般可以直接 xa rollback/commit &nbsp;xid 方式回滚或提交，xid 就是 xa recover 中 data。</p><p></p><p>如果 gtrid_length 和 bqual_length 都有值，回滚或提交则相对复杂一些，需要以下面方式提交或回滚：</p><p><img src=\"https://static001.geekbang.org/infoq/58/58d358ada7a273e20a5e5b72c33a63e1.png\" /></p><p></p><p>gtrid 和 bqual 被拼接在 data 字段中，需要按他们长度切分，以下面未提交 xa 事务里第一个为例，gtrid_length 为 34，表示 data 中前 34 个字符为 gtrid, bqual_length 为22，表示 data 中后 22 个字符为 bqual，那么对对其回滚或提交方式可表示如下：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e9/e96d15eced27cb6d2c00b7b2569dba62.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/7c/7c17a7542f9d6d2decbe8840df7dba0a.png\" /></p><p></p><p>如果 data 中有其它特殊字符，也可以转成 16 进制整数方式处理，执行语句如下：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/18/18e64405f70ed664569e77d1c87b10cf.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/06/0699a8da5d924fde01d937e52efcb88c.png\" /></p><p></p><p>因为是 16 进制数，字符做了转换，data 中字符数会翻倍，回滚或提交内容要同步调整，将 data 中字符也要翻倍再拆分，如上 grtrid 长度 34，则 data 中前 34*2 个 16 进制数字是 gtrid，bqual 长度 22，则后 44 个 16 进制数字是 bqual，回滚或提交语法如下：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b4/b4ee768b6c5f3fd64a0df664d2fbe9fb.png\" /></p><p></p><p>注意：上面的提交或回滚都可能报 xid 不存在，这不一定是 xid 写错了，也可能是开启这个 XA 事务的连接并未断开，其它连接不能处理这个 XA 事务，这里是 MySQL 报错不准确。</p><p></p><h5>（3）提交还是回滚的依据</h5><p></p><p></p><p>上面给出如何进行提交或回滚的方法，但是提交 or 回滚应该选择哪个？</p><p></p><p>残留 XA 事务是提交还是回滚，必须要由业务决定，谁开启 XA 事务，构建了分布事务管理器 TM，谁就必须为这个事务负责到底。</p><p></p><p>单个数据库视角无法判断出这个XA事务是应该提交还是应该回滚，不管选哪种都可能会导致全局数据出错，运维同学在处理时一定要与业务方确定好该事务是提交还是回滚，获得授权后再操作。以上面转账为例，201 用户给 202 转 1000 元，都 prepare 成功，发起 commit，此时 202 用户实例发生故障重启，未完成 commit，重启之后有残留 XA 事务，此时若 201 提交成功，那么 202 必须提交，如果 201 未成功，202 可以先 201 一起提交或一起回滚，由应用层事务管理器 TM 来决定。假如 201 提交成功，202 回滚则 201 扣了 1000，202 未收到，对账则钱少了。如 201 回滚了，202 提交，则 202 加了1000，201 未扣，对账则钱多了。</p><p></p><h4>2.3 MySQL XA 事务设计上的“坑”</h4><p></p><p></p><h5>（1）设计上的缺陷</h5><p></p><p></p><p>基于 binlog 的主从复制是<a href=\"https://xie.infoq.cn/article/7ae9b597e18981ae58c9db7dd\"> MySQL </a>\"高可用的基石，这也是<a href=\"https://xie.infoq.cn/article/ad357dffe11eeda5ebfa265ec\"> MySQL </a>\"能广泛流行使用的最重要因素。在 MySQL 内部，对于普通事务(非XA事务），innodb 等引擎和 binlog 为了保持数据的一致性，就是用的 2PC ，为了区分于 XA 事务的 2PC ，称之为内部两阶段提交。内部 2pc 使用 binlog 是作为协调者（TM），内部 prepare 时先写 redo 再写 binlog，都持久化（受刷盘参数策略影响）后再提交。当发生 Crash 重启时，会先恢复出所有 prepare 成功的事务，把里面的 xid 事务号取出来，再到协调者 Binlog 中去找，如果 binlog 中有这个 xid 则说明 innodb 和 binlog 都执行成功，等价于外部 xa 事务两个参与节点都 prepare 成功，则继续提交，如果 binlog 中找不到，刚说明只在引擎层完成，需要回滚，如果某个进行的事务 xid 在 prepare 中未找到，则说明 prepare 未完成，直接回滚，这个顺序一定是先写 Redo log，最后写 Binlog。</p><p></p><p>那么处于 XA prepare 状态的分布式事务到底是一个什么样的状态？分布式 XA 事务也是基于普通事务实现，实际上就是一个支持挂起，支持让其它会话继续提交或回滚，支持 crash 或重启之后还能恢复这种挂起状态的普通事务。</p><p></p><p>普通事务的 prepare 动作是发生在显式 commit 之后，先写 redo 后再写 binlog。XA 事务的 prepare 发生在显式 XA commit 之前，它需要生成 binlog，然后再写 redo，这与普通事务是相反的，这就导致这个外部 2pc 事务的内部 2pc 提交缺少了一个协调者，某些情况下会导致数据库不一致。</p><p></p><p>一个 XA 事务的 binlog 由两部分组成，从 xa start 到 xa prepare 是一个不可分原子语句块，xa commit 又是一个原子语句块，且分别有各自的 gtid，如下图 binlog：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/8d/8d6cc4269021af5c3d227678bb813471.png\" /></p><p></p><p>事务号为 &nbsp;X'7831',X'',1 的分布式事务 prepare 之后，中间插入了很多普通事务，然后再执行的 xa commit。</p><p></p><p>一个 XA 事务的 binlog 被切分成了两个独立的部分，如果在主节点在生成 XA prepare binlog 之后发生crash， 还没有在引擎层做 prepare，重启之后引擎层中因没有完成 prepare 动作而回滚。但在主从架构中，只要 binlog 正常产生就可能会同步到 Slave 机，这种情况下会导致 slave 机上多了这个 xa prepare 的中间状事务，最终复制出现问题。这个问题已经被发现多年，官方确认了 bug，一直未修复（<a href=\"https://bugs.mysql.com/bug.php?id=87560\">https://bugs.mysql.com/bug.php?id=87560</a>\"）。</p><p></p><h5>（2）遇到该问题处理思路</h5><p></p><p></p><p>虽然我们要尽量避免出现故障，但也做好面对任何故障的准备，谋而后动，有招不乱！</p><p></p><p>在常规连接中，MySQL 的 XA 事务执行 prepare 之后，通常不能执行其它非 xa 语句，会报错提醒当前正在 xa 事务中。但在复制的 sql 回放线程中，执行完 xa prepare 之后，可以直接执行其它非此 xa 事务的 sql，因为在 master 端生成的 XA 事务 Binlog 可能就是分开的，如上图例子就是。所以 slave 机 sql线程执行完 xa prepare 的 binlog 后，是被允许接着正常执行其它事务的 binlog 的。如果 xa preapre 过程 master 上发生 crash，刚好生成了 binlog，但没有做完后续的 prepare 动作，备机收到了这个 xa  preare 动作的 binlog，master 重启后会回滚掉这个事务，不会再生成这个 xa 事务后续 binlog，这会导致备机执行完 xa prepare 后一直挂起，占用的锁等资源不会释放，直到新同步过来的 binlog 与之冲突报错，才会暴露问题。</p><p></p><p>要修复分两种情况处理：</p><p></p><p>情况1：基于 gtid 的复制，应该直接会报 gtid 重复错误（推测，本地没能复现）。master上重启应该会回滚掉了前半个 XA 事务，后面事务会重新生成这个相同 gtid 的事务，导致复制出错，此时停止复制，将备机上这半个 XA 事务回滚，并 reset gtid 到之前的 gtid，重建复制即可。注意这里可能有多个 XA 事务在 Binlog 中处于 prepare 状态，需要解析 binlog 仔细确定要回滚的事务是哪个。</p><p></p><p>情况2：未开 gtid 的复制，此时比上面情况要麻烦，没有 gtid 来确定 binlog 事务是否重复，只要后面事务不涉及到这半个 xa 事务锁定的资源，备机就可以正常维持复制体系，一直同步数据，等到有冲突数据出现错误，回放线程重试超过一定次数后（slave_transaction_retries 重试参数控制），sql 线程报出相应错误，复制中断后才能被感知。恢复数据和上面差不多，回滚这个 XA 事务，重建主从，但是这个事务的 binlog 不一定能找到，因为没有 gtid 不会立即报错，可能几分钟后报错，也可能几个月后报错，取决于业务什么时候产生冲突数据。并且在这个事务之后，从机又同步了很多数据，这些数据是否可靠需要评估。线上强烈建议开启 Gtid 复制模式，非 gtid 的复制官方已经在淘汰！</p><p></p><p></p><h2>三、分布式事务的一致性</h2><p></p><p></p><p>使用到分布式事务，就必须要保证分布式事务的一致性。</p><p></p><p>分布式事务的一致性又分写一致性和读一致性，写一致性 XA 框架 XA prepare 和XA commit已经解决，只要保证有提交全提交，有回滚全回滚就能保证写一致性。</p><p></p><p>读一致性则要复杂的多，先看看 MySQL 官方对 XA 事务在读一致性上的“只言片语”：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/2d/2d485aba33f773b7794c44ffadc92f27.png\" /></p><p></p><p>上面内容是从官方说明文档里截取，里面对 XA 读一致性略有介绍：如果应用程序对读敏感，首选 SERIALIZABLE 隔离级别，RR 级别不足以用于分布式事务，官方没有对这里的不足做具体说明，但我们可以构建一个例子来分析这个“may not be sufficien”来描述读一致性是否恰当。</p><p></p><p>如下图，有 A、B 两个账户在两个实例上，假设每个账户初始都 100 块，A 给 B 转账 20，时间线左边为 A 账户实例上的操作，右边为 B 账户实例上的操作，中间 T1 到 T6 为不同时间点。</p><p><img src=\"https://static001.geekbang.org/infoq/09/09a1a0034389a864f59c13de564b1b82.png\" /></p><p></p><p>T1 时刻：初始均 100。T2 时刻：AB账户均完成 xa prepare 操作，一个减 20，一个加 20。T3 时刻：A帐户节点 XA commit 成功。T5 时刻：B帐户 XA commit 成功。</p><p></p><p>当处在 RR 或 RC 隔离级别时，发起一个对账操作，统计 AB 帐户资金总额，当只有他们相互转账时，总金额应该恒为 200。T6 时刻时，查询 A 为 80，B 为 120，总账为 200，无问题。T4 时刻查询 A 账户为80，查询 B 账户时由于 MVCC 机制，会读到上个快照中的值 100，加一起为 180，总账不对。因为是操作不同实例，当开始做 xa commit 之后，可能由于网络等原因，并不能保证所有节点的 XA commit 同时到达所有节点，在一个高并发场景，导致上面的问题几乎是必然的。因此，当使用 <a href=\"https://xie.infoq.cn/article/ff7b6300bcbdf50d05b48f0e3\">MySQL </a>\" 原生 XA 分布式事务时，若无其它手段来保障读一致性，而应用又有跨节点读的应用场景，应当使用序列化（SERIALIZABLE）隔离级别，“may not be sufficien”显然是不恰当的，没有任何一个业务能接受这种数据统计不对的。</p><p></p><p>如果是序列化隔离级别，T4 时刻读到 A 为 80，读 B 时会等待，直到 T5 时刻 XA commit 成功之后， 才能读到 B 为 120，总账 200，无问题。序列化隔离级别只有读-读不阻塞，读-写，写-读，写-写均会阻塞，而 RC、RR 仅写-写阻塞，因此只有序列化隔离级才能充分保障 MySQL XA 事务的读一致性。但它阻塞太多，性能也是各种隔离级别中最差的，所以如无必要，通常不会使用这一隔离级别。业界有很多方案来解决分布式事务 RR、RC 下的读一致性问题，以提高数据库性能，但原生的 MySQL 不具备这种能力，因此使用 MySQL 原生 XA 事务的业务需要谨慎选择隔离级别。</p><p></p><h2>四、小结</h2><p></p><p></p><p>只要我们小心面对残留 XA 事务，谨慎处理 Crash 之后的可能存在的多余 binlog 数据，认真评估使用 RR、RC 隔离级别是否有读一致性读问题等问题之后，MySQL 的 XA 事务基本没有其它问题，可以作为 RM 完备提供跨节点分布式事务能力，MySQL 已经实现了 X/Open 组织定义的分布式事务处理规范中的语法功能，完全可以放心放业务在这条路上奔跑！</p><p></p><p></p><p>本文作者简介：</p><p>Flyfox，高级后端工程师。从事数据库内核工作十多年，深度参与多个基于 PostgreSQL、MySQL 自研数据库项目，目前负责 RDS 产品研发团队工作。</p>",
    "publish_time": "2022-10-08 16:06:45",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]