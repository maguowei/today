[
  {
    "title": "慢的不是 Ruby，而是你的数据库",
    "url": "https://www.infoq.cn/article/zm0xbqblQfclgll1PvLx",
    "summary": "<p>许多人不停抱怨 Ruby 运行缓慢。诚然，它的确不如人意，然而这并非致命伤，因为问题的根源在于你的数据库速度缓慢，成为了瓶颈。因此，这个标题也可以改为 “Ruby 虽慢，但对你而言无关紧要”。</p><p></p><p>在编写一个在现有的 Postgresql 数据库中提供键值存储的 gem，并对其进行基准测试时，我不断地念叨：Ruby 可不慢，数据库才慢。因此，我决定搜集这些基准数据，以支持我的观点。</p><p></p><p>在业界，这被称为 I/O 密集型（I/O-bound），与 计算密集型（CPU-bound）性能相对立。我所协助解决的大部分 Ruby 性能问题都属于前者。Ruby 的缓慢并未引发任何问题。</p><p></p><h4>Ruby 很慢，但不重要</h4><p></p><p></p><p>让我们明确一点：Ruby 很慢。垃圾收集器、JIT 编译器、其高度动态的特性、更改代码运行时的能力等等，所有这些加在一起，都使得 Ruby 显得较为迟缓。</p><p></p><p>然而，当人们抱怨 “Ruby 很慢” 时，当深入研究时，通常可以细分为以下三类：</p><p></p><p>Ruby 很慢，这对我们的用例来说是个问题。Ruby 很慢，但实际上对我们来说并不重要。Ruby 应用程序很慢，但实际上它是堆栈，而不仅仅是语言。</p><p></p><p>我想更深入地研究最后一个问题，但在此之前，我们先解决前两个问题。</p><p></p><p>Ruby 每年都在提高性能，这受到了大家欢迎，但从更大的角度来看，这可能并不重要：</p><p></p><p></p><blockquote>速度并不是减缓 Ruby 应用的主要因素。大多数使用 Ruby 的人并不要求它更快。他们固然热衷于免费的提升，但并非因速度而避之不及。——https://www.fastruby.io/blog/ruby/performance/why-wasnt-ruby-3-faster.html</blockquote><p></p><p></p><p>因为性能确实非常依赖于环境：</p><p></p><p></p><blockquote>[……] 你的系统需要多快？它现在的速度又有多快？如果你能测试它目前的性能，并且了解优秀的性能指标，那么你就应该有信心做出改变。有时候，为了获得其他优势而适度放缓某些需要是明智的决策，尤其是如果这种放缓仍在可接受的范围内。——《构建微服务》（Building Microservices）Sam Newman 著</blockquote><p></p><p></p><p>因此通常情况下，Ruby 的速度缓慢并不重要，因为你的应用场景无需 Ruby 所追求的规模、速度或吞吐量。做好这种权衡是值得的。通常情况下，开发迅速、成本低廉、发布迅速，这些都是值得为应用程序投入额外资源（如服务器、硬件、SAAS）以保持性能可接受的。</p><p></p><p>虽然并非始终如此，但时常亦是如此。</p><p></p><h4>快速基准测试</h4><p></p><p></p><p>为了再次验证 Ruby 的性能不佳，我进行了一项快速的基准测试，在我近期遇到的一个（简化版）实际工作中，比较了 Ruby 和 Rust 的性能：解析 CSV，从一列中提取一个数字，然后进行桶计数（bucket-count）。这是一个简化版本（而我实际版本使用的 CSV 是这里使用的例子的十倍）。这个例子计算了一部电影的票数，并对这些票数进行分组：0 到 10 票之间，10 到 100 票之间等等。</p><p></p><p>为了进行对比，我尝试用 Rust 和 Ruby 创建了一个内部尽可能相似的版本。结果令人失望，Ruby 和 Rust 的性能都很差劲，甚至存在一些错误，而且都没有进行性能优化。我确信 Ruby 和 Rust 版本都可以进一步改进（尽管作为 Ruby 专家和 Rust 新手，我已经意识到 Rust 版本比 Ruby 版本更容易进行进一步优化）。所有的基准测试代码都可以在 GitHub repo 中找到。</p><p></p><p>这并不是一项严谨的科学实验，但它揭示了一个显而易见的事实：Ruby 的确较慢 [1]。</p><p></p><p>Rust： </p><p></p><p><code lang=\"text\">ber@berkes:db_benchmarks ⌁ time ./target/release/movie_ratings \nSome(0..=10): ###################### - 445\nSome(10..=100): ############################################################ - 1208\nSome(100..=1000): ############################################################################################################### - 2229\nSome(1000..=10000): ############################################# - 914\nSome(10000..=18446744073709551615):  - 7\n\nreal    0m0,162s\nuser    0m0,146s\nsys 0m0,016s</code></p><p></p><p>Ruby：</p><p><code lang=\"text\">ber@berkes:db_benchmarks ⌁ time ruby movie_ratings.rb \n10000..:  - 7\n1000..10000: ############################################# - 914\n100..1000: ############################################################################################################### - 2229\n10..100: ############################################################ - 1208\n0..10: ###################### - 445\n\nreal    0m1,491s\nuser    0m1,389s\nsys 0m0,103s</code></p><p></p><p>Rust 版本的速度大约是 Ruby 版本的十倍，这是一个令人咋舌的差距！然而，在处理更大的数据集时，这种速度差异并非呈线性增长，而是呈现出不规则的变化。其中一部分时间是由启动时间（在这个用例中很难测量）和 JIT 编译器占据的，而另一部分则是 Ruby 中垃圾回收机制的任意启动和停止所有进程所造成的问题。处理大型数据集，使这成为一个真实而恼人的问题。</p><p></p><p>但两者的绝对差异又如何呢？Ruby 版本仅慢 1.2 秒多一点。这在测试和开发过程中已经足够令人恼火了。当你一遍又一遍地运行此操作时，这一天只需要几分钟的时间：在开发过程中运行大约 20 次的脚本上总共需要 1.2 秒，然后可能每周运行一次。</p><p></p><p>虽然我只关注 CPU，但内存也是一个重要问题。然而，在现代软件的典型用例中，内存使用并不明显：客户与服务器软件交互时会感到缓慢，但并不会直接体验到内存的使用。然而，不深入探讨这个问题的主要原因是对内存进行基准测试相当复杂。</p><p></p><p>因此，可以说 Ruby 的确较慢，并且使用较多的资源。它做出了权衡，因此可能包括开发在内的整体成本更低。这取决于具体情况，没有绝对的定论。</p><p></p><h4>让它变慢的是堆栈，而不仅仅是语言</h4><p></p><p></p><p>让我们来深入探讨一个不容忽视的问题：Ruby on Rails。虽然有些 Ruby 项目不使用 Rails，但大部分生产中运行的 Ruby 代码都是基于 Rails 开发的。我个人主要使用 Ruby 编写代码，但很少涉及 Rails（因为我不太喜欢它），不过我是个例外。在 Ruby 开发中，几乎总是采用 “用 Rails 进行 Web 开发” 的方式。</p><p></p><p>其中一个 Rails 的问题是它与数据库的高度耦合（也可以说是一种好处）。Rails 专注于掌控数据库的一切。没有数据库，Rails 将毫无用处，甚至可能阻碍工作进展，而不是提供帮助 [2]。此外，Rails 专注于 Web 开发。虽然你可以在 Rails 中处理非 Web 相关的任务，但这毫无意义。Rails 的目标是处理 HTTP 请求-响应。而且，Rails 的规模相当庞大 [3]。与 Ruby 语言类似，它更侧重于人机工程学（对开发者友好度）而非性能。这是好事！然而，这也导致在 Rails 中性能成为一个问题，甚至比在 Ruby 中更加突出。</p><p></p><p>因此，“堆栈” 指的是 “使用数据库的 Ruby on Rails”。由于 Rails 专注于 Web 开发，并且只处理 HTTP 请求 - 响应，我们将仅从 Web 服务的角度看待 Ruby。</p><p></p><p>为了深入分析这个问题，我将会比较一些非 Rails、非 HTTP、纯 Ruby 的脚本。</p><p></p><p>Ruby 在处理大量数据方面并不擅长，但从本质上讲，这正是 Web 服务所需要的。为了说明相对性能的差异，我们进行了一项实验，比较了在不同源上写入和读取一百万条记录时的表现：内存、内存中的 SQLite 数据库和 Postgresql 数据库。</p><p></p><p>显然，这并不令人惊讶，内存比其他任何选项都要快得多 [7]。在这里的 Postgresql 是一个 docker 容器，只占用 CPU 资源，而且根本不需要调整配置。这与绝对数值无关，所以具体设置 Postgresql 并不重要。重要的是差异的程度。</p><p><code lang=\"text\">ber@berkes:db_benchmarks ⌁ ruby ruby_slow.rb \n                           user     system      total        real\nMem write              0.005277   0.000000   0.005277 (  0.005271)\nSqlite mem write       0.080462   0.000000   0.080462 (  0.080464)\nPostgres write         0.665662   0.151700   0.817362 (  3.068891)\nMem read               0.002772   0.000000   0.002772 (  0.002767)\nSqlite mem read       10.323161   0.021355  10.344516 ( 10.345039)\nPostgres read          8.296689   0.041118   8.337807 (  8.682667)</code></p><p></p><p>数据库写入速度缓慢。即使经过索引和负载状态调优，读取速度依旧无法改善。</p><p></p><p>然而，这一现象仍需深入探究原因。他们未指明导致缓慢的具体因素。令人意外的是，这也是 ORM 栈的一环。我选择使用 Sequel，因为它相对简单，方便我们剖析问题。</p><p></p><p>请见以下两幅火焰图，显示在插入数据时，Postgresql 成为瓶颈。这并不奇怪，因为此时数据库需处理大量工作。我们的表只有一项索引，而且是最轻类型的索引。</p><p></p><p>数据库写入速度之慢令人咋舌，以至于其他时间变得微不足道。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/22/2206be1bc7e450aac0935c181fa4552e.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/45/45833bfa9efb48684b597ca088dc14a5.png\" /></p><p></p><p>在读取方面，Postgresql 表现卓越。这归功于其简单的查找操作，无需连接，仅使用一个索引，所需数据量也很少等等。然而，解析（处理数据）却耗费了大量时间：DateTime::parse。换言之，DateTime::parse的性能问题相当显著，以至于它在数据库中耗费的时间微乎其微。</p><p></p><p>我们已经明确了堆栈中的两大性能瓶颈：Postgresql 和 ORM。</p><p></p><p>需要明确的是：这并不意味着 Sequel 性能低下，或者 DateTime::parse 存在问题 [8]。相反，这表明我们加入堆栈的工具越多，性能就越糟糕。再强调一次：这是显而易见的，并不令人意外。然而，值得重申。</p><p></p><p>在对整个 Rails 进行全面基准测试之前，我们先来审视一下 Rails 中的 ORM：ActiveRecord。同样地，由于查询操作非常简单，不涉及复杂内容，因此在数据库中所花费的时间非常有限。</p><p></p><p><code lang=\"text\">\n                           user     system      total        real\nPostgres Sequel write  0.679423   0.112094   0.791517 (  2.963639)\nPostgres Sequel read   8.798584   0.011155   8.809739 (  9.194935)\nPostgres AR write      1.741980   0.189130   1.931110 (  4.404335)\nPostgres AR read       1.551020   0.040676   1.591696 (  1.922000)</code></p><p></p><p>通过 ActiveRecord 写入：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/4f/4ffc9708976a126b884c146f8b6e431e.png\" /></p><p></p><p>通过 ActiveRecord 读取：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/94/946fc6f346a3de9ccafa7eb84f1b28ba.png\" /></p><p></p><p>通过 Sequel 读取：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/cc/cc4d8d596b1230e60e9a975ca32acdfa.png\" /></p><p></p><p>通过 Sequel 写入：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/59/59425f5d99dab2978ab5195701adb1d6.png\" /></p><p></p><p>我们可以清楚地看到，Sequel 中的 DateTime::parse 问题依然存在。我推测，ActiveRecord 采用了一种更高效的策略，将 Postgresql 中的日期时间转换为本地 DateTime。</p><p></p><p>尽管如此，Ruby 的糟糕性能相对来说并不重要。如果最快的数据库查询需要 150 毫秒，那么 Ruby 暂停 15 毫秒进行垃圾回收并没有太大关系。JIT 的开销、Rack 和 Rails 的 HTTP 解析和转发的多层堆栈，除了向数据库插入查询耗时 190ms 之外，对整体性能影响不大。</p><p></p><p>这个例子展示了从表中获取一条记录的操作，虽然它并非关系型数据库所擅长的领域，但它揭示了 ORM 存在的实际性能问题：缺乏连接、排序、过滤和计算等操作。</p><p></p><p>因此，即使 ORM 性能较差，数据库仍然是主要的耗时组件。</p><p></p><h4>扩大规模</h4><p></p><p></p><p>我们都曾遇到过这样的情况：Ruby/Rails 代码变得错综复杂，设置糟糕透顶，以至于堆栈（或自定义代码）成为瓶颈。问题看似简单解决：只需增加额外服务器。尽管单个请求速度不变，但至少服务器负载不再影响其他用户性能。应用虽未变快，却能容纳更多用户。</p><p></p><p>起初，这很容易实现，直到数据库再次成为瓶颈。写入关系数据库始终是个难题：只能垂直扩展，即增加更强大的数据库服务器。至于查询（读取）方面，可以通过增加复杂性来解决：读取副本（曾称为 “从属”）。几乎所有常见的关系数据库服务器都支持此方法。虽然并不简单，因为它将“最终一致性”引入了一个设置/框架，这个设置/框架从来没有被设计成最终一致，但这是可行的。写入（创建、插入、更新、删除等）则不然：数据库可能在某个时刻成为瓶颈。除非永远如此：但性能从一开始就并非问题。</p><p></p><p>解决 Ruby 代码中的性能问题轻而易举：只需增加更多服务器。然而，解决数据库性能问题就没那么容易了，因为扩大关系数据库规模困难重重，甚至有时不可能。</p><p></p><p>因此，为保持代码可扩展性，应尽量在代码中保留逻辑、转换等元素。将业务逻辑、约束、验证和计算推入数据库，等于放弃了最简单、通常也最经济的性能提升手段：“增加更多服务器”。</p><p></p><p>Rails</p><p></p><p>正如多次提到的，Rails 的复杂性导致了真正难以解决的性能问题。让我们深入探讨一下。</p><p></p><p>引用 DHH 在 Rails 的一句话：</p><p></p><p></p><blockquote>“所有花哨的优化都是为了让你更接近于如果你没有使用这么多技术就会得到的性能”☝️https：//macwright.com/2020/05/10/spa-fatigue.html——https://twitter.com/dhh/status/1259644085322670080</blockquote><p></p><p></p><p>Rails 的内部复杂性对性能有两大影响。首先，它包含大量抽象，被批评为 “黑魔法”。其次，在典型的 HTTP 循环中，数据需要经过所有这些层和所有这些复杂性，直到请求响应完成。</p><p></p><p>由于 Ruby 处理数据相对较慢（参见下文），数据传递的代码越多，结果就越慢。这对所有软件都是如此，但 Ruby 放大了这一点。Rails 的 163500 行 Ruby 代码当然无助于加快速度。</p><p></p><p>“代码行” 并非性能指标，但它们是一种指示。即使是最小的 Rails 项目也包含数十万行代码，即使你只使用其中一小部分数据。</p><p></p><p>针对 Rails 的基准测试已经进行了许多次。我现在将获得更多元数据，而不是继续讨论整个堆栈的 “基准” 和火焰图。少谈数字，多谈概念。因为对于 Rails，我确信性能问题是概念性的。如上所述，技术性能问题是由 Ruby 而不是 Rails 引起的。</p><p></p><p>ActiveRecord（Rails 中的实现，而非模式 per-sé）是对系统（关系数据库）的抽象，需要大量详细知识来保持性能。ActiveRecord （模式）不仅是一个漏洞的抽象，更多地是一个抽象，隐藏了一些不应被隐藏的细节。</p><p></p><p>更实际的情况是：几年前我为了修复一个 N+1 查询而加入的 User.active.includes(:roles) <a href=\"https://axiomq.com/blog/better-performance-for-rails-app-with-joins-and-eager-loading/\">动态地选择它认为你需要的内容</a>\"。它可能会“突然地、神奇地、动态地”开始构建其他连接和查询，从而降低性能。（好吧，不是从一分钟到下一分钟的运行时，而是经过小的更改）。</p><p></p><p>我曾在一个拥有百万级用户的应用程序中，导致数据库服务器集群崩溃：原因在于一个无关控制器的简单更改，使 Rails 切换到一个外部连接，该连接具有巨大物化视图，本不应以这种方式连接（用于报告）。然而，Rails 的魔力使其从此开始使用这一特性。每次页面加载都会导致大约 2 秒钟的数据库查询，占用数据库服务器上的所有 CPU 和 IO。</p><p></p><p>当然，这是个愚蠢的错误。我们没有看到这一点，因为在开发和测试中，性能从未下降。但我们应该注意到的是，这种错误在代码库中比比皆是。这些项目之所以继续运行，唯一的原因是 Heroku 服务器的巨大成本（1200 美元 / 月），能为数百访问者提供服务一天。这样的错误不会导致数据库集群崩溃，而是逐渐累积成昂贵且性能糟糕的应用程序。20 毫秒的减速几乎无法衡量，数百个 20 毫秒的速度减慢在几个月内逐渐增加，使响应变得令人无法接受。最糟糕的是，这些 “错误” 被团队贴上了 “以 Rails 方式完成” 的标签。</p><p></p><p>Rails 里到处都是这样的 footgun（footgun，意即伤自己的脚的枪，Rails 称其为“<a href=\"https://rubyonrails.org/doctrine#provide-sharp-knives\">尖刀</a>\"”。译注：指在一个产品上添加一个新东西，容易让枪打着自己脚。表明设计不好，促使用户不敢加东西。）。其中大部分本身是无害的。很容易以次优的方式连接表，对未索引的列进行排序或过滤。Active-record 充满了一些工具，可以很容易地滥用数据库，无需警告。我开发的 Rails 应用程序数量惊人，其中包含某种形式的 .sort(params[:sort by])：仅在 2021 年，我就开发了三个独立的 Rails 应用程序，所有这些应用程序都可以通过使用 ?sort=some_unindexed_field 触发请求来处理数据库。虽然这个例子很极端，可能被视为安全问题，但它说明了让应用程序性能变差是多么容易。</p><p></p><p>sorting-by-un-indexed-field  示例揭示了 Rails 与数据库的耦合如何使其许多性能问题成为数据库问题。</p><p></p><p>根据我的经验，Rails 中的性能问题总是：</p><p></p><p>N+1 个查询。易于检测。难以修复（不引入大量耦合问题）。未优化的连接。添加简单的 has_many 太容易了，这使得开发人员可以在数据库中启动过于繁重的查询。一旦通过应用程序引入和传播，这几乎不可能解决。总有一些代码最终运行类似 User.with_access_to(project).notifications.last.sent_to 的代码。而且它会查询五个连接表并且连接到至少一个索引上，而这个索引并不是为此准备的。导致大约 800 毫秒的查询。在每次页面加载时。未优化的 where、group 和 order 调用。使用难以筛选、分组或排序或优化不佳的列。使用非索引列。我的经验法则是，每个添加或删除的 where、has_many、group 或任何此类 active-record 方法都必须伴随着数据库迁移。因为只有当你已经有了以前没有使用过的索引时，才需要为这种新的查询方式优化数据库（这意味着它以前优化得很差）。另一种情况是当你重用现有索引时，在这种情况下，你很可能应该重构以将查询转移到单一责任（例如，命名范围）。</p><p></p><p>使用 Rails 人性化的 active-record API，很容易忘记你仍然只是在查询一个复杂的关系数据库。它需要微调、调优和调整，以便在合理的时间内为你提供数据。</p><p></p><p>使用 Rails，很容易累积许多小错误，从而使数据库成为瓶颈。但是，即使所有这些都在你的控制之下，高性能的数据库调用仍然比许多其他调用慢很多。</p><p></p><p>从内存和代码中填充某个数组，然后从数据库中填充该数组，速度仍然要快一千倍或更多。正如我在第一段中所展示的那样。</p><p></p><p>所以，该怎么办呢？我采用的一些经验法则是：</p><p></p><p>在可以避免的情况下，不要使用数据库。这总是比我想象的更频繁。我不需要将世界上 195 个国家存储在数据库中，并在显示国家下拉列表时加入。只需硬编码或在启动时输入配置读取。见鬼，也许你的电子商务网站的整个产品目录可以是一个单独的 YAML 启动时读取？这适用于比我通常认为的更多的对象。将逻辑与数据库分离，因为数据库是最慢且最难扩展的地方。谨慎处理 sort()、where()、join() 等调用。如果添加（或删除）了索引，它们必须伴随着至少调优索引的迁移。保持所有数据库调用简单。尽可能少的连接，尽可能少的过滤器和排序。一般来说，数据库可以更容易地为此进行优化。这也使应用程序与实际的数据库细节分离。N+1 个查询并不总是坏事。有时甚至是首选。因为它们使业务逻辑保留在代码中。并将获取内容的逻辑保存在一个地方，从而允许在那里进行性能优化。保持对实际性能问题的了解。根据性能是 I/O 密集型的还是计算性的，主动扩大规模。并祈祷它是计算性的。</p><p></p><p>内文注释：</p><p></p><p>[1] 不过，我要强调的是：作为 Rust 新手，我花了一个多小时编写 Rust 版本，而作为 Ruby 资深用户（10 年以上），我只用了不到 10 分钟。我需要运行两个版本 2000 多次，然后我花在开发 Rust 版本上的额外时间才能在等待它运行的额外时间中得到回报。</p><p></p><p>[2] 我确信你可以给我展示一个项目，在那里你不用数据库就可以运行 Rails，而且这很有意义。这些案例是存在的。我遇到的一些问题是：“我已经知道 Rails，但不知道 Sinatra”，或者“管理要求我们在类似的代码库上运行一切”。实际上，最后一个理由不成立。大多数都是合理的理由，除了最后一个：这是选择 Rails 的一个可怕的理由。</p><p></p><p>[3] 一个快速 grep：超过 9000 个类，超过 33000 个方法；不包括所有神奇的动态方法，比如围绕数据库模型的方法。这还不包括 rails 本身附带的 70 多个依赖项。</p><p></p><p>[4] 一个常见的 Rails 应用程序将发送电子邮件，可能会生成 pdf，接收 CSV 或导出 CSV，但所有交互通常都通过 HTTP 进行。我知道 Rails 只用于运行 cron 作业、ETL 管道甚至媒体编码的例外情况（我曾研究过），但这些确实是例外情况。</p><p></p><p>[5] 具有讽刺意味的是，在这种非 http、非 rails 的环境中，性能问题变得不那么明确了，然而在这些情况下，人们通常会因为 ruby 的性能问题而将其作为选项。这也是 Ruby 很少在 Rails（和/或 Web）之外使用的原因之一。</p><p></p><p>[7] 令人惊讶的是，从内存中的 SQLite 中查找比从数据库中查找要慢。但这说明了另一个重要问题：数据库运行在单独的线程中，甚至可能在单独的硬件上。因此负载是分布式的：在 SQLite 和我们的内存示例中，一个 Ruby 线程完成了所有的过滤、获取和提升。对于外部数据库，这是偏移量。根据你的设置，Ruby 线程甚至可能在数据库进行查找时继续工作。在这种情况下，经过优化以过滤和获取数据的 Postgresql 可以比 SQLite-inside-ruby 更快地完成这项工作。在典型的生产设置中，Postgresql 更适合这一点。</p><p></p><p>[8] 请注意，虽然DateTime:parse 很慢，但这个函数是用 C 编写的。之所以慢，并不是因为它是用 Ruby 编写的，而是因为解析如此复杂的文本很慢。对于 Rust 中的功能相当的版本来说，它可能会一样慢。</p><p></p><p>[9] 有更多的理由说明这是一个更好的主意。最明显的一点是，你永远不能把所有的业务逻辑都放在数据库中，即使你想这样做。因此，你将在多个地方拥有业务逻辑，而不需要任何去往何处的结构。所以把它放在一个地方的显而易见的解决方案是……放在一个地方。唯一可以保存所有内容的地方：你的应用程序。</p><p></p><p>作者简介：</p><p></p><p>Bèr Kessels，经验丰富的 Web 开发人员，对技术和开源充满热情。</p><p></p><p>原文链接：</p><p></p><p>https://berk.es/2022/08/09/ruby-slow-database-slow/</p><p></p>",
    "publish_time": "2023-10-05 07:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "安息吧，元宇宙",
    "url": "https://www.infoq.cn/article/2qmOzDAMFH1YH0f78GWG",
    "summary": "<p>Meta的急剧垮台表明，这位雄心勃勃、曾经不可撼动的CEO兼Facebook联合创始人已经麻烦缠身。他的宏图伟业之一、被寄予厚望的元宇宙项目，已经有一只脚踏进了科技行业的垃圾堆。</p><p></p><h2>Meta“蠢蛋秀”</h2><p></p><p>2022年底，这家曾经市值万亿美元的科技巨头以70%的自由落体式暴跌结束了这风云变幻的一年，也使其成为整个标普500指数中表现最差的股票。公司陷入了严重麻烦，从社交网络巨头Facebook到元宇宙虚拟现实世界的激进转型已经成为一场闹剧、一笔沉重的损失。</p><p>&nbsp;</p><p>为了了解原Facebook和元宇宙项目的这段历程，我们不妨先从这家大型科技企业陷入当前困境的主要原因说起。</p><p>&nbsp;</p><p>最大的问题其实并不在于马克·扎克伯格全力押注元宇宙。事实上，无论Meta接下来打算主攻哪款产品，结局都有可能失败。正如作家兼专栏写手Ted GIoia所言，“在Facebook看来，用户永远是错的。”</p><p>&nbsp;</p><p>对于干过企业的人来说，无论规模如何，商业经营的重点都应该是为客户提供服务，这似乎是理所当然的思维。但Facebook和旗下的Instagram、WhatsApp，再到现在的Meta，却永远只有一个目的：为应用和背后的开发团队创造利润。这也是导致扎克伯格元宇宙帝国轰然倒塌的真正原因。</p><p></p><h2>虚假的承诺</h2><p></p><p>扎克伯格当初想要打造元宇宙的雄心壮志，确实吸引到了他身边几乎所有伙伴。他宣称这个虚拟世界将是“一个广阔且身临其境的互联网全新版本”。</p><p>&nbsp;</p><p>元宇宙迅速登上商业世界的顶峰，其他企业也纷纷选择跟进，包括沃尔玛、迪士尼、耐克和古驰等知名企业。扎克伯格还说服投资者、华尔街和媒体共同加入这场狂欢。</p><p>&nbsp;</p><p>到这里，一切看起来都很有搞头。</p><p>&nbsp;</p><p>当时科技专家Ed Zitron曾表示“元宇宙项目已经成功了一半”，并在短时间内震动了整个科技行业。但扎克伯格的宏大叙事最终只是……一句空话。元宇宙项目没有明确的商业愿景，最终也没能为公众解决任何实际问题。</p><p>&nbsp;</p><p>Meta掌门人对于他的下一场辉煌胜利做出了充满诗意的表达，但却缺乏关于元宇宙具体能做什么的确切描述。因为拿不出清晰可行的愿景和能够解决的问题，Meta这场豪赌很快遭受损失。其实大家也能看出，缺少明确的动机、目标受众和市场接纳意愿，这东西根本就不可能真正发展出又一家重量级企业。</p><p></p><h2>巨大的失败</h2><p></p><p>现在，我们来具体对这些问题做一番剖析。</p><p>&nbsp;</p><p>由于产品负责人自己没法说明元宇宙要解决什么问题，自然也就没法让公众理解和认同。用扎克伯格自己的话来说：</p><p>&nbsp;</p><p>“我认为很多人在说起元宇宙时，想到的仅仅是虚拟现实——没错，虚拟现实肯定是元宇宙中重要的组成部分，但元宇宙绝不止于此。它能让我们在所有不同计算平台上访问，包括VR/AR，还有PC、移动设备和游戏主机。说到这里，很多人又觉得元宇宙就是个大游戏。是的，娱乐肯定是其中的重要组成部分，但元宇宙同样绝不止于此。”</p><p>&nbsp;</p><p>好吧，直到撰写这篇文章的时候，我仍然不禁在想，“他到底在说什么？”说了半天，又似乎什么都没说。根据他的描述，元宇宙可以是任何东西，甚至把同样的表达照搬给互联网也没有任何违和。元宇宙到底是游戏、应用，还是一整个虚拟世界？我们不知道，扎克伯格似乎也不知道。</p><p></p><h2>超级混乱</h2><p></p><p>第二个问题跟前一个密切相关。元宇宙的定义比解释它的意义更加令人费解，更不用说它的目标受众到底是谁了。扎克伯格宣称未来将有十亿人会使用元宇宙，但如果没有明确的用例，这个数字是从哪来的？据说这些用户人均会花几百美元来使用元宇宙产品。</p><p>&nbsp;</p><p>第三，既然缺少对元宇宙作用和它所要解决问题的明确认知，那我们真的很难相信全球最大的社交网络的创始人“真知道自己在干什么”。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/88/884df5926359d05dea64f85e889c6b3b.png\" /></p><p></p><p>Meta股价下跌70%，到2022年收盘时已经成为标普500指数中表现最差的股票。</p><p>&nbsp;</p><p>可既然华尔街、科技行业、媒体和技术爱好者们都相信了这个故事，为什么普罗大众就是不感兴趣呢？</p><p>&nbsp;</p><p>因为扎克伯格对我们普通人的认知是错的——这也是整个故事中最重要的分析前提。</p><p></p><h2>我错了，但我其实没错</h2><p></p><p>公众已经厌倦了那帮大公司天天告诉他们该做什么。如果媒体、科技行业和投资者居然相信一个敢在自己都说不明白的产品上投入100亿美元的家伙，那这家伙的崩塌肯定只是时间问题。</p><p>&nbsp;</p><p>根据体验过元宇宙的用户所言，这东西“质量低下”而且“bug太多”，基本跟儿童益智游戏在一个水平。对于一家价值数十亿美元的企业，拿出这样的产品当然不可能让公众满意。号称是互联网的未来形态，但充满卡通感的音乐和连腿都没有虚拟化身能“改变世界”？别开玩笑了。</p><p>&nbsp;</p><p>《商业内幕》撰稿人直呼扎克伯格为“骗子”，称元宇宙是种毫无意义的工具，只是种“分解了扎克伯格对于重要问题的关注，并给坏人提供获利机会的温床”。</p><p>&nbsp;</p><p>令人难以置信的是，一个掌握如此权势、极具影响力的名人怎么会公然撒谎，并为此把几十亿美元挥霍一空，然后好像什么都没有发生。但仔细想想，好像扎克伯格并不是第一个打算通过兜售谎言来赚钱的人。</p><p>&nbsp;</p><p>大家还记得Elizabeth Holmes承诺要用90亿美元彻底改变验血方式吗？事实证明这完全是个骗局。就连扎克伯格自己，也不是第一次这么干了。</p><p></p><h2>扎克伯格的科技帝国</h2><p></p><p>扎克伯格建立起一个科技帝国，无论他要做什么，都能在这个帝国之内牢牢保持统治，甚至到了不可触碰的程度。换言之，Meta是他一手成就的，所以可以完全控制，任何董事会成员都无法阻拦。</p><p>&nbsp;</p><p>尽管迄今为止的很多尝试都遭受失败，例如2013年的Facebook Phone，但Meta的这位CEO还是在一年之后以20亿美元收购了VR厂商Oculus并继续全力下注。</p><p>&nbsp;</p><p>当然，他创造的“互联网未来”的狂妄愿景、包括用虚拟现实加化身构建数字世界的思路，都可以一路追溯到上世纪90年代。游戏《子午线》、《领土在线》和更早的《创世纪》都做出了自己的尝试。</p><p>&nbsp;</p><p>由此看来，建设元宇宙的想法并非毫无可取。毕竟如今的技术似乎正向着虚拟现实环境的广泛普及步步逼近。然而，如果这个未来还需要15到20年才能落地，那么扎克伯格老兄确实有些操之过急了。想带动整个行业？那就得承受相应的风险。</p><p>&nbsp;</p><p>如今的智能手机几乎成为身体的延伸。苹果通过iPhone将各种产品组合成了统一的实用工具，从而突破了市场边界、颠覆了市场形态。电话、MP3播放器还有电子记事本，现在它们都是智能手机的组成部分。</p><p>&nbsp;</p><p>然而，扎克伯格并不是乔布斯，他的元宇宙产品一直也没有清晰的前进方向。</p><p>&nbsp;</p><p>Meta打算宣扬一种革命性的数字社交方式，但对普通群众来说，这可能只是另一种更繁琐的游戏参与方式。在大型游戏行业来看，这无非就是另一种形式的多人在线游戏。从这个角度，也能看出乔布斯和扎克伯格二人对于创新革命性产品的理解根本就不在一个层次。</p><p></p><h2>安息吧，元宇宙</h2><p></p><p>尽管经历了大肆宣传，但由于得不到市场支持，这个短命的项目还是崩溃了。Meta甚至没法说服自己的员工使用这套Horizon Worlds平台。由于之前夸下的海口无法兑现，元宇宙概念变得愈发虚弱无力。则Web3行业，也迅速将注意力转向了更有热度的AI炒作。</p><p>&nbsp;</p><p>大多数当初贸然跟进的企业开始关闭自己的元宇宙项目。沃尔玛在Roblox上推出的元宇宙体验项目短短六个月后就被关停，迪士尼也在今年三月关闭了元宇宙部门。</p><p>&nbsp;</p><p>现在我们很难判断，扎克伯格提出的整个元宇宙概念到底只是为了创造一个大骗局、让他和自己的同行能够在亏损中狠捞一笔，还是他真心觉得自己有机会开启互联网的新时代、实现自我超越。无论如何，引发这一切的核心在于他是扎克伯格，是扎克大王，没人够胆阻拦他的脚步。无论选择是对是错，有权做出判断的只有他本人。此外，Facebook始终专注于控制用户，而非认真倾听他们的意见。</p><p></p><h2>Meta的终局之战</h2><p></p><p>从商业角度来说，我们需要明确一点。Facebook已经是家价值数十亿美元的巨型企业，而且在几年前就已经达到了体量上限。之后他们遭遇到几波重大动荡，目前的产品已经没有拓展的空间。</p><p>&nbsp;</p><p>扎克伯格打算通过单纯关注利润来重塑自己、拯救自己的公司。大家都知道，目前大多数巨头企业都是这么个思路，这也很可能是Meta面前最不坏的选项。</p><p>&nbsp;</p><p>遗憾的是，这样一个身兼所有骗子特征的家伙根本不会受到任何惩罚。即便误导了整个行业，平白烧掉几十亿美元，还拉了那么多人下水，扎克伯格也依然逍遥自在。</p><p>&nbsp;</p><p>而且我们压根没必要对此感到惊讶，毕竟他的帝国就是建立在谎言之上。也许这位草根大王最终会把自己玩死，也许会让从无到有的帝国再从有到无，但……一切都由扎克伯格掌控。</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://beincrypto.com/metaverse-swindler-zuckerberg-deceived-fantasy/\">https://beincrypto.com/metaverse-swindler-zuckerberg-deceived-fantasy/</a>\"</p>",
    "publish_time": "2023-10-05 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Gatling发布全新Java DSL，Java与Kotlin齐飞",
    "url": "https://www.infoq.cn/article/XdR3fldiPGT9ewtxfFJ5",
    "summary": "<p>负载测试工具<a href=\"https://gatling.io/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTQ4MTQsImZpbGVHVUlEIjoiMWQzYU1wMXhaTUkwTGwzZyIsImlhdCI6MTY5NjIxNDUxNCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.jQ5YpRqVdOBYg7YUQPo6W-oZY-x781aSesPtaO9Sk4A\">Gatling</a>\"是为易用性、可维护性和高性能而设计的。它最初提供了Scala DSL来编写测试场景。后来，它<a href=\"https://gatling.io/2021/11/gatling-3-7-java-dsl-kotlin-and-much-more/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTQ4MTQsImZpbGVHVUlEIjoiMWQzYU1wMXhaTUkwTGwzZyIsImlhdCI6MTY5NjIxNDUxNCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.jQ5YpRqVdOBYg7YUQPo6W-oZY-x781aSesPtaO9Sk4A\">发布</a>\"了Java DSL，可以使用Java或Kotlin编写测试场景。</p><p></p><p>Gatling的快速入门文档中有一段专门介绍了<a href=\"https://gatling.io/docs/gatling/tutorials/quickstart/#picking-the-right-language?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTQ4MTQsImZpbGVHVUlEIjoiMWQzYU1wMXhaTUkwTGwzZyIsImlhdCI6MTY5NjIxNDUxNCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.jQ5YpRqVdOBYg7YUQPo6W-oZY-x781aSesPtaO9Sk4A\">如何选择正确的语言</a>\"， 建议已经在使用Scala或Kotlin的开发人员使用这些语言编写测试，但如果还没有在使用这些语言，推荐使用Java，因为它广为人知，需要较少的CPU进行编译，并且更容易在Maven或Gradle中配置。</p><p></p><p>“<a href=\"https://gatling.io/2022/08/java-kotlin-or-scala-which-gatling-flavor-is-right-for-you/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTQ4MTQsImZpbGVHVUlEIjoiMWQzYU1wMXhaTUkwTGwzZyIsImlhdCI6MTY5NjIxNDUxNCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.jQ5YpRqVdOBYg7YUQPo6W-oZY-x781aSesPtaO9Sk4A\">Java, Kotlin or Scala: Which Gatling Flavor is Right for You?</a>\"”这篇文章发表于Java DSL发布一年之后，文中显示，有35%的用户在使用Java DSL。在文章中，Gatling明确指出，尽管Java DSL迅速流行起来，但他们计划继续支持Scala DSL，用户可以自由选择Java、Scala和Kotlin来编写测试。</p><p></p><p>假设有一个使用Scala编写的测试场景，其中有8个用户在10秒内启动，0秒后0个用户，5秒后4个用户，10秒后8个用户。然后每个用户执行五次循环，验证car和carpart端点是否都返回HTTP 200状态码：</p><p></p><p><code lang=\"java\">class BasicSimulationScala extends Simulation {\n    val httpProtocol = http\n        .baseUrl(\"http://localhost:8080\");\n\n    val scn = scenario(\"BasicSimulation\")\n        .repeat(5){  \n             exec(http(\"car\").get(\"/car\")\n            .check(status.is(200)))\n            .pause(1)\n            .exec(http(\"carpart\")\n            .get(\"/carpart\")\n            .check(status.is(200)))\n        }\n\n    setUp(\n        scn.inject(rampUsers(8).during(10))\n    ).protocols(httpProtocol);\n}\n</code></p><p></p><p>这个测试可以在Linux/Unix上使用Gatling脚本<a href=\"https://gatling.io/docs/gatling/tutorials/quickstart/#running-gatling?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTQ4MTQsImZpbGVHVUlEIjoiMWQzYU1wMXhaTUkwTGwzZyIsImlhdCI6MTY5NjIxNDUxNCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.jQ5YpRqVdOBYg7YUQPo6W-oZY-x781aSesPtaO9Sk4A\">运行</a>\"：</p><p></p><p><code lang=\"java\">$GATLING_HOME/bin/gatling.sh</code></p><p></p><p>或者在Windows上：</p><p><code lang=\"text\">&nbsp;%GATLING_HOME%\\bin\\gatling.bat</code></p><p></p><p>另外，也可以使用Maven等构建工具来运行测试，方法是在testSourceDirectory中指定测试场景的目录，并配置<a href=\"https://davidb.github.io/scala-maven-plugin/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTQ4MTQsImZpbGVHVUlEIjoiMWQzYU1wMXhaTUkwTGwzZyIsImlhdCI6MTY5NjIxNDUxNCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.jQ5YpRqVdOBYg7YUQPo6W-oZY-x781aSesPtaO9Sk4A\">Scala Maven插件</a>\"和<a href=\"https://gatling.io/docs/gatling/reference/current/extensions/maven_plugin/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTQ4MTQsImZpbGVHVUlEIjoiMWQzYU1wMXhaTUkwTGwzZyIsImlhdCI6MTY5NjIxNDUxNCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.jQ5YpRqVdOBYg7YUQPo6W-oZY-x781aSesPtaO9Sk4A\">Gatling Maven插件</a>\"：</p><p></p><p><code lang=\"java\">\n    src/test/scala\n    \n        \n            net.alchim31.maven\n            scala-maven-plugin\n            ${scala-maven-plugin.version}\n            \n                \n                    \n                        testCompile\n                    \n                    \n                        \n                            -Xss100M\n                        \n                        \n                            -deprecation\n                            -feature\n                            -unchecked\n                            -language:implicitConversions\n                            -language:postfixOps\n                        \n                    \n                \n            \n        \n        \n            io.gatling\n            gatling-maven-plugin\n            ${gatling-maven-plugin.version}\n        \n    \n</code></p><p></p><p>最后执行测试：</p><p><code lang=\"java\">mvn gatling:test</code></p><p></p><p>同样的场景可以用Java DSL来表达： 用Duration.ofSeconds(10)替代10，用status()替代status，用repeat(5).on(...)替代repeat(5){...}：</p><p></p><p><code lang=\"java\">public class BasicSimulationJava extends Simulation {\n\n    HttpProtocolBuilder httpProtocol = http\n        .baseUrl(\"http://localhost:8080\");\n\n    ScenarioBuilder scn = scenario(\"BasicSimulation\")\n        .repeat(5).on(\n            exec(http(\"car\").get(\"/car\")\n            .check(status().is(200)))\n            .pause(1)\n            .exec(http(\"carpart\")\n            .get(\"/carpart\")\n            .check(status().is(200)))\n        );\n\n    {\n        setUp(\n            scn.injectOpen(rampUsers(8).during(Duration.ofSeconds(10)))\n        ).protocols(httpProtocol);\n    }\n}</code></p><p></p><p>虽然Scala DSL和Java DSL之间的这些变化看起来相对较小，但对用户来说最大的好处是与测试相关的所有自定义逻辑也可以用Java编写。</p><p></p><p>用户可以使用Gatling脚本来运行测试，或者可以使用构建工具。</p><p></p><p>最后一个示例是Kotlin的Java DSL，其中最大的变化是使用status().shouldBe(200)替代Java示例中的status().200) ：</p><p></p><p><code lang=\"java\">class BasicSimulationKotlin : Simulation() {\n\n    val httpProtocol = http\n    .baseUrl(\"http://localhost:8080\");\n\n    val scn = scenario(\"BasicSimulation\")\n        .repeat(5).on(\n            exec(http(\"car\").get(\"/car\")\n        .check(status().shouldBe(200)))\n        .pause(1)\n        .exec(http(\"carpart\")\n        .get(\"/carpart\")\n        .check(status().shouldBe(200)))\n    );\n\n    init {\n        setUp(\n            scn.injectOpen(rampUsers(8).during(Duration.ofSeconds(10)))\n        ).protocols(httpProtocol);\n    }\n}</code></p><p></p><p>用户可以使用Gatling脚本来运行测试。另外，也可以使用像<a href=\"https://kotlinlang.org/docs/maven.html?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTQ4MTQsImZpbGVHVUlEIjoiMWQzYU1wMXhaTUkwTGwzZyIsImlhdCI6MTY5NjIxNDUxNCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.jQ5YpRqVdOBYg7YUQPo6W-oZY-x781aSesPtaO9Sk4A\">Kotlin Maven Plugin</a>\"这样的构建插件，并在testSourceDirectory中指定测试场景文件的位置后：</p><p></p><p><code lang=\"java\">\n    src/test/kotlin\n    \n        \n            org.jetbrains.kotlin\n            kotlin-maven-plugin\n            ${kotlin.version}\n\n            \n                \n                    compile\n                    \n                        compile\n                    \n                \n                \n                    test-compile\n                    \n                        test-compile\n                    \n                \n            \n        \n        \n            io.gatling\n            gatling-maven-plugin\n            ${gatling-maven-plugin.version}\n        \n    \n</code></p><p></p><p>更多信息可以在<a href=\"https://gatling.io/docs/gatling/tutorials/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTQ4MTQsImZpbGVHVUlEIjoiMWQzYU1wMXhaTUkwTGwzZyIsImlhdCI6MTY5NjIxNDUxNCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.jQ5YpRqVdOBYg7YUQPo6W-oZY-x781aSesPtaO9Sk4A\">文档</a>\"中找到，文档为每个功能提供了Scala、 Java和Kotlin示例。</p><p></p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/09/gatling-java-dsl/\">https://www.infoq.com/news/2023/09/gatling-java-dsl/</a>\"</p>",
    "publish_time": "2023-10-05 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "云计算时代的领域驱动设计：构建可扩展的架构",
    "url": "https://www.infoq.cn/article/6Xd8bv6eW7vCBCmPXUB3",
    "summary": "<p>Domain-Driven Cloud（DDC）是一种根据你的业务模型创建组织云架构的方法。DDC使用你的业务模型的限界上下文作为输入，并输出一个灵活的云架构，以支持组织中的所有工作负载，并随着业务变化而演进。DDC通过为团队提供创新的能力，在保护范围内促进团队自治。在运营方面，DDC以一种促进IT和业务利益相关者彼此透明的方式，简化了安全性、治理、集成和成本管理。</p><p>&nbsp;</p><p>基于领域驱动设计（DDD）和高内聚低耦合的架构原则，本文介绍了DDC，包括将你的云架构与业务模型的限界上下文对齐所带来的技术和人员收益。你将了解如何在亚马逊网络服务（AWS）和微软Azure等云平台上实施DDC，并与它们的良构架构框架对齐。通过我们一个真实客户的示例，你将学习在你的组织中实施DDC的5个步骤。&nbsp;</p><p></p><h2>什么是领域驱动云（DDC）？</h2><p></p><p>&nbsp;</p><p>DDC将DDD的原则扩展到传统软件系统之外，创建了一个统一的架构，涵盖了业务领域、软件系统和云基础设施。</p><p>&nbsp;</p><p>我们的客户始终努力对齐“人员、流程和技术”，以便能够协同工作，实现业务目标。然而，在实践中，往往事与愿违，因为业务（Biz）、IT开发（Dev）和IT运营（Ops）都各自为营，从自己的角度为横跨这三个领域的复杂问题在设计解决方案。</p><p>&nbsp;</p><p>最后的结果就是不同团队使用不同方法和本地化语言设计和实施的业务流程重新设计、企业架构和云平台架构。</p><p>&nbsp;</p><p>缺失的是使用共享语言的统一架构方法来集成BizDevOps。这就是DDC的作用所在，它专注于将云架构和运行其上的软件系统与使用DDD确定的业务模型的限界边界上下文保持一致。图1显示了DDC如何扩展DDD的原则，包括云基础设施架构，从而创建一个对齐BizDevOps的统一架构。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/ae/ae4de223be6589e950db4d02ef99b297.png\" /></p><p></p><p>&nbsp;</p><p>在DDC中，最重要的云服务是包含账户的AWS<a href=\"https://docs.aws.amazon.com/organizations/latest/userguide/orgs_introduction.html\">组织单位</a>\"(OU's)和包含订阅的Azure<a href=\"https://learn.microsoft.com/en-us/azure/governance/management-groups/overview\">管理组</a>\"(MG's)。因为你所保护、使用和支付的100%云资源都与账户和订阅相关联，所以它们是自然的成本和安全容器。通过在更高的OU/MG级别启用管理和安全，并将其锚定在业务模型的限界上下文上，你现在可以创建一个涵盖业务、开发和运维的统一架构。在满足特定需求时，你可以为团队提供使用账户和订阅的灵活性。</p><p>&nbsp;</p><p></p><h2>为什么要将云架构与业务模型相一致？</h2><p></p><p>&nbsp;</p><p>将云架构与组织的业务模型保持一致有以下好处：</p><p>随着业务发展而演进 - 企业不是静态的，你的云架构也不是。随着市场的变化和业务的发展，新的上下文可能会出现，而其他上下文则可能会巩固或消失。一些过去注重战略差异化的上下文今天可能带来较少的商业价值。将云管理、安全和成本直接与限界上下文对齐，意味着你的云架构会随着业务的发展而演进。提高团队的自主性 - 尽管某些云管理任务必须集中进行，但 DDC 建议在领域上下文中给予团队自主权，如基础架构的供应和应用程序的部署。这样一来，你的敏捷团队可以更快地前进，并对业务增长的变化做出更敏锐的响应，从而促成“有保障的创新”。这还确保了不同上下文中工作负载之间的依赖关系是明确的，目标是促进与授权团队一致的松散耦合架构。促进高内聚和低耦合 - 将网络与限界上下文对齐，可以明确允许或拒绝所有上下文之间的网络连接。这是非常强大的，尤其对于在云平台上实施低耦合的现代架构而言。在一个上下文中，团队和工作负载理想情况下在安全性、网络集成和支持业务特定部分方面具有高内聚性。你还可以自由地在限界上下文和工作负载级别上做出可用性和弹性决策。增加成本透明度 通过将你的限界上下文与OU和MG对齐，所有云资源使用情况，预算和成本都可以精确地以细粒度进行跟踪。然后，它们会在限界上下文中自动汇总，无需自定义报告和打扰所有工程师来标记所有内容！通过DDC，你可以查看每个限界上下文的每月云账单，并了解确切的云支出，从而使你能够评估这些成本是否与每个上下文的业务价值相符。云预算和警报可以委派给与上下文对齐 的团队，使他们能够监控和优化他们的支出，同时你的组织对整体云成本有清晰的自上而下的视图。与领域对齐的安全性 - 安全策略、控制、身份和访问管理都与限界上下文很好地对齐。一些策略和控制可以在所有上下文中部署，以创建强大的安全基线。从这里，可以安全地将选定的控制委派给团队进行自我管理，同时仍然强制执行企业安全标准。可重复使用的代码模板 - AWS和Azure都提供了从基于代码的蓝图持续预备新的帐户或订阅的方法。在DDC中，我们建议为所有领域上下文定义一个模板，然后使用此模板（加上可配置的输入参数）根据需要提供和配置新的OU和帐户或MG和订阅。这些管理结构是免费的（你只需支付其中使用的实际资源），使你能够逐步构建云架构，朝着明确的未来状态发展，而不会产生额外的云成本。</p><p>&nbsp;</p><p>DDC可能并不是所有情况下的最佳方法。其他选择，比如按照租户/客户（SaaS）或法人实体组织云架构，也是可行的选项。</p><p>&nbsp;</p><p>不幸的是，我们经常看到客户按照他们当前的组织结构来组织他们的云架构，遵循着上世纪60年代的康威定律（Conway's Law）。我们认为这是一个错误，而DDC是一个更好的选择，原因很简单：你的业务模式比你的组织结构更稳定。</p><p>&nbsp;</p><p>好的架构的核心原则之一是我们不应该让更稳定的组件依赖于不稳定的组件（也称为<a href=\"https://devlead.io/DevTips/StableDependenciesPrinciple\">稳定依赖原则</a>\"）。组织机构，尤其是大型机构，经常喜欢重组，这使得他们的组织结构比他们的商业模式更不稳定。基于组织结构构建云架构意味着每次重组时都会直接影响到你的云架构，这可能会影响到云环境中运行的所有工作负载。为什么要这样做呢？基于组织的商业模式构建云架构可以使其随着你的业务战略的发展而自然演化，如图2所示。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/f8/f8225514bb8008a8170aab68be346481.png\" /></p><p></p><p>&nbsp;</p><p>我们认识到，正如Ruth Malan所说的那样：“如果系统的架构与组织的架构不一致，组织的架构将占上风”。我们也承认，达到OU（组织单元）/ MG（管理组）以及其中的所有工作负载与团队边界和责任之间的最佳对齐状态仍有待努力。我们认为像<a href=\"https://www.infoq.com/articles/book-review-team-topologies/\">Team Topologies</a>\"这样的理念可能会在这方面提供帮助。</p><p>&nbsp;</p><p>我们看到当今的组织正在摒弃独立的部门项目和正式沟通结构，转向跨职能团队创建跨越组织边界的产品和服务。这些现代解决方案在云上运行，因此我们认为现在是以共享语言和架构方法统一业务、开发和运维的企业架构的时机。</p><p></p><h2>Well-Architected框架怎么样？</h2><p></p><p>&nbsp;</p><p><a href=\"https://docs.aws.amazon.com/wellarchitected/latest/framework/welcome.html\">亚马逊云服务的Well-Architected框架</a>\"和<a href=\"https://azure.microsoft.com/en-us/solutions/cloud-enablement/well-architected/\">微软Azure的Well-Architected框架</a>\"都提供了一套经过精心策划的设计原则和最佳实践，用于设计和操作云环境中的系统。DDC完全支持这些框架，并且在SingleStone我们与客户一起使用这些框架。虽然这些框架为将工作负载组织成多个帐户或订阅，并使用OU和MG进行管理提供了具体的建议和好处，但它们会让你自行决定最适合你组织的分类方式。</p><p>&nbsp;</p><p>DDC倾向于基于限界上下文构建云架构，同时与AWS的Separated AEO/IEO模型和“执行操作即代码”以及“自动从故障中恢复”的设计原则完全兼容。你也可以采用DDC并应用这些最佳实践。AWS Landing Zone和Azure Landing Zones等工具可以加速设置云架构，并且也符合领域驱动的原则。</p><p></p><h2>实施领域驱动云的五个步骤</h2><p></p><p>&nbsp;</p><p>你认为在BizDevOps中使用共享语言的统一架构能够使你的组织受益吗？虽然本文无法详尽列出所有任务，但以下是你可以遵循的五个基本步骤，其中包含了最近迁移到Azure的一位客户的示例。</p><p></p><h3>步骤1：从限界上下文开始</h3><p></p><p>&nbsp;</p><p>实施DDC的起点是一组描述你业务模型的限界上下文。本文不涵盖确定限界上下文的步骤，但<a href=\"https://www.infoq.com/articles/architecture-modernization-domain-driven-discovery/\">领域驱动发现</a>\"中描述的过程是一种方法。</p><p>&nbsp;</p><p>确定限界上下文后，将它们组织成两个组：</p><p>领域上下文直接与你的业务模型对齐。技术上下文通过共享基础架构和服务来支持所有领域上下文。</p><p>&nbsp;</p><p>为了说明，让我们看一下一位医疗用品公司的客户。他们的领域和技术上下文如图3所示。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/21/2192d7c50c3f98e4407ea8584c0c6377.png\" /></p><p></p><p>你组织的领域背景可能会有所不同。</p><p>&nbsp;</p><p>对于技术上下文，数字将取决于你组织的行业、复杂性、监管和安全要求等因素。一家财富100强的金融服务公司将拥有比一家新媒体初创公司更多的技术上下文。话虽如此，作为起点，DDC推荐为支持所有系统和数据设置六个技术上下文。</p><p>云管理 上下文用于配置和管理云平台，包括OU/MG（组织单位/管理组）、账户/订阅、云预算和云控制。安全 上下文用于身份和访问管理、密钥管理和其他任何工作负载使用的共享安全服务。网络 上下文用于所有集中式网络服务，包括子网、防火墙、流量管理和本地网络连接。合规性 上下文用于支持监管、审计和取证活动的任何合规性相关服务和数据存储。平台服务 上下文用于包括CI/CD、软件包管理、可观察性、日志记录、计算和存储在内的常见开发和运维服务。分析 上下文用于企业数据仓库、治理、报告和仪表板。</p><p>&nbsp;</p><p>你无需一开始就创建所有这些上下文，可以从云管理开始，根据需要逐步构建。</p><p></p><h3>步骤2：打造坚实的基础</h3><p></p><p>&nbsp;</p><p>在定义了你的限界上下文之后，现在是时候为支持你的组织工作负载建立一个安全的云基础了。根据我们的经验，我们发现将云能力按照它们对工作负载的支持方式分为三个层次进行组织是很有帮助的。对于我们的医疗用品客户，图4显示了他们的上下文与应用程序、平台和基础层的云架构对齐。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/b5/b57a1441ee0abcaaa02260e01528a187.png\" /></p><p></p><p>&nbsp;</p><p>使用DDC，你可以将AWS组织单位（OU）或Azure管理组（MG）与限界上下文对齐。所谓对齐，是指将它们命名为你的限界上下文。这些是管理的最高级别，并通过继承的使用使你能够在整个云架构中标准化控件和设置。</p><p>&nbsp;</p><p>DDC使你能够以最佳方式组织你的帐户和订阅分类法，从粗粒度到细粒度，如图5所示。</p><p>DDC建议从一个OU/MG和至少两个限界上下文的帐户/订阅开始。如果你的组织有更高的工作负载隔离要求，DDC也可以支持，如图5所示。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/ac/ac4d3e11c3513bc8be66d9aac237a018.png\" /></p><p></p><p>&nbsp;</p><p>对于我们的客户来说，他们的小型云团队刚开始接触Azure，为每个上下文设置独立的生产环境和非生产环境的订阅是个合理的起点，如图6所示。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/e6/e6ab00795ff5b4d296c2f3a9c1fd02a8.png\" /></p><p>图 7 展示了在 AWS 中的样子。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/65/656a5e6ada4b1920414fd7850abb40f7.png\" /></p><p></p><p>对于我们的客户，可以在各自的生产环境和非生产环境订阅中创建Dev、Test和Stage等进一步的环境。这为他们提供了在订阅或更低级别中，配置环境特定设置的能力，同时保持了环境之间的隔离。他们还决定仅为六个技术环境构建生产环境的订阅，以便开始的时候保持简单。如果你的组织希望为每个工作负载环境创建单独的账户或订阅，也可以实现，并与DDC保持一致。</p><p></p><p>从治理的角度来看，在DDC中，我们建议领域上下文从技术上下文继承安全控制和配置。在技术上下文中创建强大的安全姿态，使得在领域上下文中运行的所有工作负载都可以默认继承此安全性。然后，领域上下文可以根据情况选择性地覆盖某些控制和设置，以平衡团队自治和灵活性与所需的安全防护。</p><p>&nbsp;</p><p>使用DDC，你的组织可以赋予团队自主权，在防护栏杆内实现创新。借助<a href=\"https://teamtopologies.com/key-concepts\">团队拓扑的关键概念</a>\"，在创建云基础设施、部署发布和监控工作负载时，流程对齐的团队可以在领域上下文中自给自足。主要在技术上下文中工作的平台团队可以专注于设计和运行流程对齐团队使用的高可用服务。这些团队共同努力，在集中化和分散化云控制之间找到合适的平衡，以满足组织的安全性和风险要求，如图8所示。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/54/54573b9c0c7b9fde04dd91b699e7a461.png\" /></p><p></p><p>&nbsp;</p><p>正如这个图所示，定义在较高级OU/MG中的政策和控制会向下执行，而成本和合规性会向上报告。对于我们的医疗用品客户来说，这意味着他们的每月Azure账单会自动按照其限界上下文进行细项列示，其中包括订单、分销商和支付方等的云成本总结。</p><p>&nbsp;</p><p>这使得他们的首席技术官可以轻松地与业务伙伴共享云成本，并建立可以随时间监控的现实预算。与成本类似，所有上下文中的政策合规性可以向上报告，并在合规性技术上下文中存储证据，以用于审计或取证目的。像Azure Policy和AWS Audit Manager这样的服务有助于通过将政策和控制集中管理，持续维护云环境的合规性。</p><p></p><h3>步骤 3：将工作负载与限界上下文对齐</h3><p></p><p>&nbsp;</p><p>在打下坚实基础并确定了限界上下文之后，下一步是将工作负载与限界上下文对齐。通常，确定将在云环境中运行的所有工作负载是在云迁移发现过程中完成的，部分借助于变更管理数据库（CMDB），该数据库包含你的组织应用程序的投资组合。</p><p>&nbsp;</p><p>在将工作负载与限界上下文对齐时，我们更倾向于采用一种促进讨论和协作的研讨会方法。根据我们的经验，这使得迁移相关的团队能够理解DCC并产生共鸣。由于团队必须开发和支持这些工作负载，研讨会还能够突出组织结构与限界上下文之间是否能够对齐的地方。在这个研讨会（或后续研讨会）中，还可以确定哪些应用程序应该具有独立可部署性，以及团队的所有权边界如何与限界上下文对应。</p><p>&nbsp;</p><p>对于我们的医疗用品客户，这个研讨会揭示了在共享服务上下文中部署新版本订单管理系统所需的共享CI/CD工具的权限。这引发了一场关于如何跨上下文管理机密信息和权限的讨论，确定了在云迁移期间优先考虑的新的机密信息管理能力。通过创建一个适用于领域上下文中所有未来工作负载的可重用解决方案，云团队创建了一个新的能力——提高了未来迁移的速度。</p><p>&nbsp;</p><p>图9总结了我们的客户如何将工作负载与限界上下文对齐，并将其与Azure管理组对齐。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/24/2406be39a950865448604fb486deb764.png\" /></p><p></p><p>&nbsp;</p><p>在订单的上下文中，我们的客户使用Azure资源组来独立部署包含Azure资源的应用程序或服务，如图10所示。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/92/9260d160e7302f9d22f406cdb5f65520.png\" /></p><p></p><p>&nbsp;</p><p>这个设计为他们最初从数据中心迁移到Azure的应用程序提供了一个起点。在接下来的几年里，他们的目标是将这些应用程序重构为多个独立的微服务。当时机成熟时，他们可以通过为每个服务创建额外的资源组，逐步地按应用程序进行重构。</p><p>&nbsp;</p><p>如果我们的客户使用的是AWS，图10看起来会非常相似，但使用组织单位、账户和AWS技术栈来组织独立部署的应用程序或包含资源的服务。云服务提供商之间的一个区别是，AWS允许嵌套技术栈（技术栈内嵌技术栈），而Azure资源组不支持嵌套。</p><p>&nbsp;</p><p>对于网络，在领域上下文中运行的工作负载要访问技术上下文中的共享服务，它们的网络必须连接或显式启用权限以允许访问。虽然网络技术上下文包含集中的网络服务，但默认情况下，与领域上下文对齐的每个账户或订阅都将拥有自己的私有网络，其中包含由其内部运行的工作负载独立创建、维护和使用的子网。</p><p>&nbsp;</p><p>根据账户或订阅的总数，可能是期望的也可能是太多的独立网络需要管理（每个网络可能有自己的IP范围）。或者，可以在网络上下文中定义核心网络，并与特定的领域或技术上下文共享，从而避免每个上下文都拥有自己的私有网络。云网络的详细信息超出了本文的范围，但DDC可以实现多种网络选项，同时将你的云架构与业务模型保持一致。底线是：你无需牺牲网络安全性来采用DDC。&nbsp;</p><p></p><h3>步骤4：迁移工作负载</h3><p></p><p>&nbsp;</p><p>现在我们已经确定了每个工作负载将在哪里运行，是时候开始将它们移动到正确的账户或订阅中了。虽然这对我们的客户来说是一次新的迁移（绿地），但对于你的组织来说，这可能涉及重新架构现有的云平台（棕地）。将一系列工作负载迁移到AWS或Azure以及架构云平台的步骤超出了本文的范围，但就DDC而言，以下是需要记住的主要事项清单：</p><p>根据你的限界上下文为AWS组织单位（OU）或Azure管理组（MG）命名。</p><p>将上下文组织成领域和技术分组，包括：</p><p>将技术上下文作为云架构的基础和平台层。将领域上下文作为云架构的应用层。在技术上下文中集中常见的控制，以确保强大的安全姿态。在领域上下文中分散选定的控制，以促进团队的自治、速度和敏捷性。在OU或MG内使用继承来向下强制执行策略和控制，同时向上报告成本和合规性。在OU / MG内决定你的账户/订阅分类法，平衡工作负载隔离和管理复杂性。决定你的网络如何映射到域和技术上下文，平衡集中化与分散化。为一致性创建领域上下文模板，并在为新的账户/订阅进行配置时使用这些模板。</p><p>&nbsp;</p><p>对于既有云架构的 DDC 的棕地部署，基本步骤如下：</p><p>创建以你的限界上下文命名的新 OU（组织单位）/ MG（管理组）。在一段时间内，这些将与你现有的 OU / MG 并行存在，并且不应对当前操作产生任何影响。在新的 OU / MG 中根据技术上下文实施策略和控制，并适当使用继承。为所有领域上下文创建一个通用代码模板，该模板从你的技术上下文继承策略和控制。对于上下文之间的任何不同之处，使用参数进行设置。根据你的工作负载映射研讨会的输出，针对每个工作负载执行以下操作之一：</p><p>a. 使用通用模板创建一个新的帐户/订阅，与你期望的帐户分类法保持一致，用于容纳工作负载；或者b. 迁移现有的帐户/订阅，包括其中的所有工作负载和资源，到新的 OU / MG。迁移时，请仔细注意来自原始 OU / MG 的控制措施，确保它们也在目标 OU / MG 中启用。</p><p>你移动工作负载的顺序将由工作负载之间的依赖关系来决定，在开始之前应明确了解。共享服务所依赖的工作负载也是如此。根据要迁移的工作负载数量的不同，这可能需要几周或几个月的时间（但希望不是几年）。在迁移工作负载时要有条不紊地进行工作，验证每个上下文的控制、成本和合规性是否正常运行。完成后，废弃旧的 OU / MG 结构和不再使用的任何帐户/订阅。</p><p></p><h3>步骤 5：检查和调整</h3><p></p><p>&nbsp;</p><p>你的云架构不是静态的工件，随着业务的变化和新技术的出现，设计将继续发展。新的限界上下文会出现，需要对你的云平台进行更改。理想情况下，这项工作的大部分都是通过编码和自动化来完成的，但很可能你仍然需要一些手动步骤，因为限界上下文也在演化。</p><p>你的帐户/订阅分类法也可能随时间而变化，开始时较少，以简化最初的管理，但会随着团队和流程的成熟而逐渐增长。团队的责任边界以及它们如何与限界上下文对齐，也会随时间而成熟。像 GitOps 这样的方法与 DDC 结合使用，可以使你的云基础架构随时间而灵活和可扩展，并始终与你的业务模型保持一致。</p><p></p><h2>结论</h2><p></p><p>&nbsp;</p><p>DDC扩展了DDD原则，将其应用于传统软件系统以外的领域，创建了一个统一的架构，跨越业务领域、软件系统和云基础设施（BizDevOps）。DDC基于软件架构的高内聚低耦合原则，用于设计复杂的分布式系统，比如AWS和Azure环境。在创建组织的云架构时，应用DDD的透明性和共享语言的优势，可以得到一个安全而灵活的平台，随着业务随时间的变化而自然演化。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/domain-driven-cloud/\">https://www.infoq.com/articles/domain-driven-cloud/</a>\"</p>",
    "publish_time": "2023-10-05 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]