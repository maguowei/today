[
  {
    "title": "安全对等问题：确保移动应用跨平台安全性",
    "url": "https://www.infoq.cn/article/1mccNMl6UlaLNMwzO3co",
    "summary": "<p>一段时间以来，人们都“知道”，作为移动平台的Android不如iOS安全，这已经成为常识。似乎除了消费者，每个人都知道。<a href=\"https://www.appdome.com/consumer-security-survey/\">2021年8月对10000名移动消费者进行的一项全球调查</a>\"发现，iOS和Android用户的安全期望基本一致。</p><p>&nbsp;</p><p>然而，尽管消费者有这样的期望，而且从本质上讲，一个移动平台并不一定比另一个平台更安全，但移动应用很少能实现Android和iOS的安全功能对等。事实上，<a href=\"https://www.infoq.com/articles/mobile-devsecops/\">许多移动应用甚至缺少最基本的安全保护措施</a>\"。让我们看看这是为什么。</p><p></p><h2>移动应用安全需要多层次防御</h2><p></p><p>大多数安全专家和第三方标准组织都会同意，移动应用安全需要多层次防御，包括以下核心领域的多种安全特性：</p><p>代码混淆和应用护盾（Application Shielding）：保护移动应用的二进制文件和源代码，防止逆向工程。数据加密：保护应用中存储和使用的数据。安全通信：保护在应用和应用后端之间传递的数据，包括确保用于建立可信连接的数字证书的真实性和有效性。操作系统防护：保护应用免受未经授权的操作系统修改（如rooting和越狱）所影响。</p><p>&nbsp;</p><p>开发人员应该在应用的iOS和Android版本中均衡地实现这些功能的组合，形成一致的安全防御。而且，他们应该在开发周期的早期添加这些功能——这个概念被称为<a href=\"https://www.infoq.com/minibooks/devsecops-emag/\">安全“左移”</a>\"。听起来很容易吧？ 理论上，是的，但在实践中，如果使用“传统”方法，要实现移动应用多层次安全防御实际上是相当困难的。</p><p>&nbsp;</p><p>多年来，移动开发人员一直试图使用传统的工具集来实现应用内移动应用安全，包括第三方开源库、商业移动应用安全SDK或专用编译器。第一个主要的挑战是，移动应用的安全从来无法通过“银弹”实现。由于移动应用在不受保护的环境中运行，并存储和处理大量有价值的信息，有许多方法可以攻击它们。黑客有无穷无尽的、免费提供而又非常强大的工具集可以使用，而且可以全天候地研究和攻击应用而不被发现。</p><p></p><h3>移动安全要求</h3><p></p><p>因此，为了构建一个强大的防御体系，移动开发人员需要实施一个既“广”且“深”的多层次防御。所谓“广”，我指的是不同保护类别的多种安全特性，它们彼此相互补充，如加密和混淆。所谓“深”，我指的是每个安全特性都应该有多种检测或保护方法。例如，一个越狱检测SDK如果只在应用启动时进行检查，就不会很有效，因为攻击者很容易绕过。</p><p>&nbsp;</p><p>或者考虑下反调试，这是一种重要的运行时防御，可以防止攻击者使用调试器来执行动态分析——他们会在一个受控的环境中运行应用，为的是了解或修改应用的行为。有许多类型的调试器——有一些基于LLDB——是针对原生代码的，如C++或Objective C，其他的在Java或Kotlin层进行检查，诸如此类。每个调试器连接和分析应用的工作方式都略有不同。因此，为了使反调试防御奏效，应用需要识别正在使用的多种调试方法，并动态地进行恰当的防御，因为黑客会继续尝试不同的调试工具或方法，直到他们找到一个可以成功的。</p><p></p><h3>防篡改</h3><p></p><p>安全要求清单并不仅限于此。每个应用都需要防篡改功能，如校验和验证、预防二进制补丁，以及应用的重新打包、重新签名、模拟器和仿真器，等等。毫不夸张，仅是针对一个操作系统研究和实现这些功能或保护方法中的一项，就需要至少几个人周的开发时间。而且还要有一个前提，就是移动开发人员已经拥有特定安全领域的专业知识，但情况往往并非如此。复杂度可能会快速增加，到目前为止，我们只讨论了一个保护类别——运行时或动态保护。想象一下，如果提到的每个功能都需要一到两周的开发时间，那么实现全部安全特性得付出多大的时间成本。</p><p></p><h3>防越狱/Rooting</h3><p></p><p>接下来，你还需要操作系统层面的保护，如防越狱/rooting，在移动操作系统遭破坏的情况下保护应用。越狱/rooting使移动应用容易受到攻击，因为它允许对操作系统和文件系统进行完全的管理控制，破坏了整个安全模型。而且，仅仅检测越狱/rooting已经不够了，因为黑客们一直在不断地改进他们的工具。要说最先进的越狱和rooting工具，在iOS上是<a href=\"https://en.wikipedia.org/wiki/IOS_jailbreaking\">Checkra1n</a>\"，在Android上是<a href=\"https://www.xda-developers.com/how-to-install-magisk/\">Magisk</a>\"——还有许多其他的工具。其中，还有一些工具用于隐藏或掩盖活动及管理超级用户权限——通常授予恶意应用。朋友们，如果你使用SDK或第三方库实现了越狱或rooting检测，那么你的保护措施很有可能已经过时或者很容易被绕过，尤其是在没有对应用的源代码进行充分混淆的情况下。&nbsp;</p><p></p><h3>代码混淆</h3><p></p><p>如果你使用SDK或第三方库来实现安全防护，那在未混淆的应用中几乎没什么用——为什么？因为黑客使用<a href=\"https://www.hopperapp.com/\">Hopper</a>\"、<a href=\"https://resources.infosecinstitute.com/topic/basics-of-ida-pro-2/\">IDA-pro</a>\"等开源工具，就可以很容易地反编译或反汇编，找到SDK的源代码，或使用类似<a href=\"https://frida.re/\">Frida</a>\"这样的动态二进制工具箱，注入他们自己的恶意代码，修改应用的行为，或简单地禁用安全SDK。&nbsp;</p><p>&nbsp;</p><p>代码混淆可以防止攻击者了解移动应用的源代码。而且，我们总是建议使用多种混淆方法，包括混淆本地代码或非本地代码和库，以及混淆应用的逻辑结构或控制流。例如，可以使用控制流混淆或重命名函数、类、方法、变量等来实现。不要忘了还要混淆调试信息。</p><p>&nbsp;</p><p>从现实世界的数据中可以看出，大多数移动应用都缺乏足够的混淆，只混淆了应用的一小部分代码，<a href=\"https://arxiv.org/pdf/1801.02742.pdf\">这项对超过100万个Android应用的研究清楚地说明了这一点</a>\"。正如该研究指出的那样，造成这种情况的原因是，对于大多数移动开发人员来说，依赖专用编译器的传统混淆方法实在是太复杂和费时，难以全面实施。相反，许多开发人员只实现了单一的混淆功能，或者只混淆了代码库的一小部分。在这项研究中，研究人员发现，大多数应用只实现了类名混淆，这本身很容易被攻陷。拿书打个比方，类名混淆本身就像是混淆了一本书的“目录”，但书中所有实际的页和内容却并没有混淆。这种表面的混淆相当容易被绕过。&nbsp;</p><p></p><h3>数据保护和加密</h3><p></p><p>接着说数据保护，你还需要借助加密来保护应用和用户数据——在移动应用中，有很多地方存储着数据，包括沙盒、内存以及应用的代码或字符串。要自己实现加密，有很多棘手的问题需要解决，包括密钥衍生（key derivation）、密码套件和加密算法组合、密钥大小及强度。许多应用使用了多种编程语言，每一种都需要不同的SDK，或者会导致你无法控制的不兼容性，又或是需要你无法访问的依赖。而数据类型的差异也有复杂性增加和性能下降的风险。</p><p>&nbsp;</p><p>然后，还有一个典型的问题，即在哪里存储加密密钥。如果密钥存储在应用内部，那它们可能会被反向工程的攻击者发现，然后他们就可以用来解密数据。这就是为什么我们说动态密钥生成是一个非常重要的功能。通过动态密钥生成，加密密钥只在运行时生成，而不会存储在应用或移动设备上。此外，密钥只使用一次，可以防止攻击者发现或截获它们。</p><p>&nbsp;</p><p>那么传输中的数据呢？仅靠TLS是不够的，因为有很多方法可以侵入应用的连接。检查和验证TLS会话和证书很重要，这可以确保所有的证书和CA都是有效且真实的，受到行业标准加密的保护。这可以防止黑客获得TLS会话的控制权。然后还有证书固定，可以防止连接到遭到入侵的服务器，或保护服务器，拒绝遭到入侵的应用连接（例如，如果你的应用被变成了一个恶意机器人）。</p><p></p><h3>欺诈、恶意软件、防盗版&nbsp;</h3><p></p><p>最后，还有反欺诈、反恶意软件和反盗版保护，你可以在上述基线保护的基础上增加防护层，用于防止非常高级或专门的威胁。这些保护措施可能包括可以防止应用覆盖攻击、自动点击器、钩子框架和动态二进制工具、内存注入、键盘记录器、密钥注入或可访问性滥用的功能，所有这些都是移动欺诈或移动恶意软件的常用武器。</p><p>&nbsp;</p><p>不难想象，即使是实现上述功能的一个子集，也需要大量的时间和资源。到目前为止，我只是谈了一个强大的安全防御所需的特性和功能。即使你内部有资源和所需的技能组合，那么拼凑出一个防御体系的行动挑战又是什么呢？让我们探讨一下开发团队可能会遇到的一些实施挑战。</p><p></p><h2>不同平台和框架之间的实现差异</h2><p></p><p>鉴于用于构建移动应用的SDK/库及原生或非原生编程语言之间存在无数的框架差异和不兼容，开发人员将面临的下一个问题是如何分别为Android和iOS实现这些安全功能。虽然软件开发工具包（SDK）提供了一些标准安全功能，但没有SDK能普遍覆盖所有的平台或框架。</p><p>&nbsp;</p><p>当开发人员试图使用SDK或开源库来实现移动应用安全时，所面临的一个主要挑战在于，这些方法都依赖于源代码，需要对应用代码进行修改。而结果是，这些方法中的每一个都明确地与应用所使用的特定编程语言绑定，并且还暴露给了各种编程语言或是这些语言和框架的包“依赖”。</p><p>&nbsp;</p><p>通常，iOS应用使用Objective-C或Swift构建，而Android应用使用Java或Kotlin以及使用C和C++编写原生库。例如，假如你想对存储在Android和iOS应用中的数据进行加密。如果你找到了一些第三方Android加密库亦或是Java或Kotlin的SDK，它们不一定适用于应用中使用的C或C++代码部分（原生库）。</p><p>&nbsp;</p><p>在iOS中也是如此。你浏览StackOverflow时可能会发现，<a href=\"https://stackoverflow.com/questions/68957448/swift-cryptokit-encryption-yields-inconsistent-results\">在Swift中常用的Cryptokit框架</a>\"对Objective C不起作用。</p><p>&nbsp;</p><p>那么，非原生或跨平台应用呢？它们是完全不同的赛道，因为你要处理的是JavaScript等Web技术和React Native、Cordova、Flutter或Xamarin等非原生框架，它们无法直接（或根本不能）使用为原生语言构建的SDK或库。此外，对于非原生应用，你可能无法获得相关的源代码文件，从源头实现加密。</p><p>&nbsp;</p><p>关于这个问题，有一个真实的例子，请看Stack Overflow上的<a href=\"https://stackoverflow.com/questions/52696998/obfuscate-entire-react-native-app-including-javascript-code\">这篇帖子</a>\"。开发人员需要在一个iOS应用中实现代码混淆，其中React Native（一个非原生框架）和Objective C（一种原生编码语言）之间存在多个依赖关系。由于iOS项目中没有可以混淆React Native代码的内置库，开发人员需要使用一个外部包（依赖关系#1）。此外，该外部包还依赖下游的一个库或包来混淆JavaScript代码（依赖关系#2）。现在，如果第三方库的开发人员决定废弃该解决方案，会发生什么？我们的一个客户就面临着这样的问题，这导致他们的应用不符合PCI标准。</p><p>&nbsp;</p><p>那么，你认为需要多少开发人员来实现我刚才描述的哪怕是一小部分功能？又需要多长时间？你有足够的时间在现有的移动应用发布过程中实现所需的安全功能吗？</p><p></p><h2>DevOps是敏捷+自动化，传统安全是单体+手动</h2><p></p><p>移动应用是在一个快节奏、灵活且高度自动化的敏捷模式下开发和发布的。为了使构建和发布更快速、更简单，大多数Android和iOS DevOps团队都围绕CI/CD和其他自动化工具构建了最佳管道。另一方面，安全团队无法访问或查看DevOps系统，而且大多数安全工具并不是针对敏捷方法构建的，因为它们在很大程度上依赖于手动编程或实施，在这种情况下，单个安全功能的实施时间可能会长于发布时间表允许的时间。</p><p>&nbsp;</p><p>为了弥补这些不足，一些组织在向公共应用商店发布应用之前，会使用代码扫描和渗透测试，以深入探查漏洞和其他移动应用问题。当发现漏洞时，企业就会面临一个艰难的决定：是在未进行必要保护的情况下发布应用，还是推迟发布，让开发人员有时间来解决安全问题。当这种情况发生时，推荐的安全保护措施往往会被忽视。</p><p>&nbsp;</p><p>开发人员并不懒惰，而是他们用于实现安全保护的系统和工具根本无法匹配现代敏捷/DevOps开发的快节奏。</p><p></p><h2>实现强大的移动应用安全和平台对等的五个步骤</h2><p></p><p>一般来说，自动化是实现安全对等和强大的移动应用安全的关键所在。以下是在应用发布周期内将移动应用安全打造为应用组成部分的五个步骤。</p><p></p><h3>第1步：明确希望得到什么样的安全成果</h3><p></p><p>开发、运营和安全团队必须就移动安全预期达成一致。对于组织作为起点的安全目标，人们要有一个共同的理解，如<a href=\"https://owasp.org/www-project-mobile-top-10/\">OWASP Mobile Top 10</a>\"、<a href=\"https://www.mas.gov.sg/-/media/MAS/Regulations-and-Financial-Stability/Regulatory-and-Supervisory-Framework/Risk-Management/TRM-Guidelines-18-January-2021.pdf\">TRM移动应用安全指南</a>\"和<a href=\"https://github.com/OWASP/owasp-masvs\">移动应用安全验证标准（MASVS）</a>\"。一旦确定了目标并选择了标准，所有团队成员都要知道这对他们的工作流有何影响。</p><p></p><h3>第2步：移动应用安全的实施必须自动化</h3><p></p><p>安全非常复杂，手动编码很慢，而且容易出错。评估并利用自动化系统，借助人工智能和机器学习（ML）将安全集成到移动应用中。通常情况下，这些都是无代码平台，可以自动将安全构建到移动应用中，它们通常被称为安全构建系统。</p><p></p><h3>第3步：将安全作为开发周期的一部分——安全左移</h3><p></p><p>移动应用安全模型左移是指，移动开发人员需要在构建应用的同时构建安全特性。&nbsp;</p><p>&nbsp;</p><p>一旦选择了自动化安全实施平台，就应该将其整合到团队的持续集成（CI）和持续交付（CD）流程中，这可以加速开发生命周期，所有团队——开发、运营和安全——在整个冲刺期间都应该保持密切合作。 此外，企业可以为每个Android和iOS应用所需的特定安全特性创建可重复使用的移动安全模板，从而更接近实现平台对等。</p><p></p><h3>第4步：确保即时确认和验证</h3><p></p><p>如果没有办法即时验证所需的安全功能是否包含在发布中，那么在发布会议上就会出现争执，可能导致应用发布或更新延期。验证和确认应该自动记录，防止最后一刻的发布混乱。</p><p></p><h3>第5步：保持安全开发成本不变</h3><p></p><p>开发团队需要可预测性和明确的预算。通过采用自动化的安全方法，应用开发团队可以减少人员和开发费用的意外变化，因为它消除了手动将安全编码到移动应用时固有的不确定性。</p><p></p><h2>小结</h2><p></p><p>安全对等问题是一个大问题，但它是一个更大问题的一部分，即移动应用普遍缺乏安全性。通过在安全实现中采用与特性开发相同或更高程度的自动化，开发人员可以确保他们针对每个平台发布的每一个应用都免受黑客、骗子和网络犯罪分子的侵害。</p><p></p><p>作者简介：</p><p>Alan Bavosa是Appdome的安全产品副总裁。长期以来，他一直担任安全产品执行官，曾是Palerra（被Oracle收购）和Arcsight（被HP收购）的产品主管。</p><p>&nbsp;&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/secure-mobile-apps-parity-problem/\">The Parity Problem: Ensuring Mobile Apps Are Secure Across Platforms</a>\"</p>",
    "publish_time": "2022-07-16 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "作业帮 K8s Serverless 大规模应用实践",
    "url": "https://www.infoq.cn/article/TWzvplySyD8CTJ09VKCU",
    "summary": "<p></p><blockquote>为进一步加强技术交流，推进云原生生态共建，6月28日下午，首届云原生实践者大会在线上线下同步举办。来自作业帮、知乎、转转、58、同程等多家科技企业的数十名研发人员，以及中国信通院云大所的专家共同参与了此次技术研讨沙龙。&nbsp;会上，作业帮架构研发高级工程师别路分享了作业帮在K8s Serverless上的探索历程，包括在K8s中通过虚拟节点使用Serverless的技术原理、Serverless能带来哪些收益、作业帮在K8s Serverless上遇到的问题，以及如何在业界的调度方案都不太理想的情况下产出创新的调度方案、如何保持虚拟节点上pod的可观测性等，并在生产实践上给出建议。&nbsp;以下，是别路的分享。</blockquote><p></p><p>&nbsp;</p><p>大家好，我是别路，来自作业帮基础架构部。先简单做个自我介绍，我2017年参加工作，先后在滴滴、旷视从事业务和架构开发工作。2020年加入作业帮，负责K8s集群建设和基础组件研发工作。</p><p>&nbsp;</p><p>很高兴在这里和大家分享，本次分享的主题是“作业帮K8s Serverless大规模应用实践”，内容分为以下4个部分：</p><p>&nbsp;</p><p>第一部分是背景，主要包括作业帮在Serverless上的探索历程第二部分是有关虚拟节点的介绍，包括K8s虚拟节点的技术原理和优势第三部分是我们遇到的一些问题和解决方案最后一部分是总结</p><p>&nbsp;</p><p></p><h2>背景</h2><p></p><p>&nbsp;</p><p>作业帮的服务端技术体系正向着云原生化发展，提升资源利用率是云原生技术栈的核心目标之一。利用Serverless按量计费、快速伸缩、运维自动化等特点，能够带来降低基础设施成本、降低交付时间、降低人力成本等优势。</p><p>&nbsp;</p><p>Serverless化一直是作业帮基础架构探索的核心方向。目前业界的Serverless主要有两种形态，一种是函数计算，一种是K8s 虚拟节点。</p><p>&nbsp;</p><p>基于公司大部分服务已完成容器化的背景，我们选择使用K8s虚拟节点。使用K8s 虚拟节点，对已经运行在K8s上的服务来说，无需改造即可使用，具有无感平滑迁移、用户体验较好的优点。</p><p>&nbsp;</p><p>2020年，我们开始尝试将部分密集计算调度到Serverless 虚拟节点上，利用虚拟节点底层服务器的强隔离能力来规避服务间相互影响。2021年，我们就将定时任务调度到Serverless 虚拟节点，替代节点扩缩容，应对短期运行的任务，提升资源利用率降低成本。2022年，我们开始将部分核心在线业务调度到了Serverless 虚拟节点上。</p><p>&nbsp;</p><p></p><h2>虚拟节点的原理</h2><p></p><p>&nbsp;</p><p>虚拟节点是一种调度能力，支持将标准 Kubernetes集群中的 pod 调度到集群服务器节点之外的资源中。部署在虚拟节点上的pod具备裸金属服务器一致的网络连通性，又具有无需预留资源，按量计费的特性。</p><p>&nbsp;</p><p>业界K8s虚拟节点基本都是基于Virtual Kubelet实现的。Virtual Kubelet是一个开源的K8s Kubelet实现，它通过实现Kubelet的一些接口来伪装成一个Kubelet，而实际上创建 pod 的工作是由云厂商去通过相应的接口来实现。</p><p>&nbsp;</p><p>其中，一些核心接口有注册节点容量，创建、销毁、更新pod，获取pod信息等接口。这些都属于云厂商需要关注的范畴，而我们作为用户通常只需要把它当作一个特殊的节点来使用就可以。当然，理解它的工作原理更容易把握它的边界。</p><p>&nbsp;</p><p>接下来，我们看一下用户视角的虚拟节点。从用户视角来看，虚拟节点和普通节点几乎一致。普通节点上的pod可以和虚拟节点上的pod互相访问，一个Service下还可以同时存在正常节点和虚拟节点上的pod。Pod是否部署到虚拟节点上对大多数业务来说几乎感知不到区别。</p><p>&nbsp;</p><p>虚拟节点有着诸多优点，也存在一些限制，基本都是和host相关。这也很好理解，毕竟实际上并不存在真正的节点。所以，DaemonSet、HostNetwork、HostPath、HostPid 和 NodePort 类型的 Service 和节点绑定的资源通常是不可用的。</p><p>&nbsp;</p><p>介绍完虚拟节点的原理，我们再来看一下虚拟节点可以带来的成本优势。</p><p>&nbsp;</p><p>目前，作业帮的大部分服务都已经完成容器化，在线业务有着典型的高峰期，且高峰期持续时间较短（约4个小时/每天）。高峰期服务器平均负载接近60%，而低峰期负载只有10%左右。此场景就非常适合Serverless的弹性伸缩落地。</p><p>&nbsp;</p><p>我们可以做一个简单的计算。假设全部使用自有服务器每小时的成本为C，平均每天高峰期的时间为4小时，使用Serverless的单位时间成本为1.5C，那么：</p><p>&nbsp;</p><p>全部使用自有服务器的总成本为 C * 24 = 24C保留70%的自有服务器，高峰期增加30%的Serverless来应对，此时的总成本为：C * 24 * 0.7 + 1.5C * 4 * 0.3 = 18.6C</p><p>&nbsp;</p><p>理论上高峰期波峰部分使用Serverless可降低的成本大约为：22.5%。可见，将在线服务高峰期弹性调度到Serverless可以节省大量的资源成本。</p><p>&nbsp;</p><p></p><h2>遇到的问题及解决方案</h2><p></p><p>&nbsp;</p><p>介绍完虚拟节点的原理和成本优势之后，接下来看看我们在使用虚拟节点过程中遇到的一些问题和解决方案。</p><p>&nbsp;</p><p>第一个问题是调度问题，第二个是观察性问题，最后是性能、稳定性和其它问题。</p><p>&nbsp;</p><p>我们先来看一下调度问题。在调度层面，主要需要解决两个问题：一是扩容时创建pod基于何种调度策略调度到虚拟节点；二是缩容时应优先缩虚拟节点上的pod。这两种能力在当前的Kubernetes版本中能力是不足的。</p><p>&nbsp;</p><p>对于调度到虚拟节点，业界常用的有两种方案。</p><p>&nbsp;</p><p>第一种方案，也是调度到虚拟节点，最朴素的做法是通过NodeSelector、节点亲和、污点和容忍的方式。这种方式是最简单的把虚拟节点用起来的方式，但是这样虚拟节点和标准节点是完全分开的，服务只能调度到指定的资源池：一个服务要么全上虚拟节点，要么全不上虚拟节点，而这样无法最大化利用成本优势。</p><p>&nbsp;</p><p>第二种方案，也是很多云厂商提供的方案：用户不用指定selector，当pod因固定节点资源不足调度pending的时候，再尝试调度到虚拟节点上。这种方案也存在问题：在集群资源已满的情况下才调度到虚拟节点，会导致pod部署过于密集，节点负载太高影响业务。</p><p>&nbsp;</p><p>而我们理想方案是希望在集群物理服务器资源达到利用率瓶颈后，扩容到serverless 虚拟节点上。这样就可以即没有负载过高的风险也可以最大化成本优势。</p><p>&nbsp;</p><p>我们的业务场景需要更精细化的资源管理策略，所以我们研发了自己的方案：使用自研调度器将具体服务超过一定数量的pod调度到虚拟节点上，这个数量就是一个关键的“阈值”。该阈值基于在线服务的波峰波谷，进行预测推荐，计算出高峰该服务能在集群物理机上运行的副本数最优解，这样既能满足集群物理机的资源利用率也能满足性能要求。</p><p></p><p>该方案除了支持自动计算调度到虚拟节点的阈值，还支持人工手动设置以便于业务进行更精细的调控，调度到虚拟节点的能力还可以结合hpa、cron-hpa同时使用，以此满足业务更灵活的需求。</p><p>&nbsp;</p><p>解决完扩容问题，再来看一下缩容问题。缩容时，优先缩Serverless 虚拟节点上的pod很好理解，因为常备的资源池是包年包月的单价更低，虚拟节点上的资源是按量计费的单价较高，优先缩虚拟节点上的pod来达到成本最优。</p><p>&nbsp;</p><p>具体的做法是通过自研调度器对虚拟节点上的pod注入自定义的注解，对Kube-controller-manager进行二次开发，将带有虚拟节点自定义注解的pod置于缩容队列的顶部，来完成优先缩容虚拟节点上的pod。</p><p>&nbsp;</p><p>说完调度问题，我们再来看一下观测性问题。我们的观测服务都是自建的，比如（日志检索、监控报警、分布式追踪）。因为是虚拟节点，pod里跑的监控组件、日志采集是由云厂商内置的。我们需要保证业务感知层面上，pod运行在Serverless 虚拟节点和物理服务器上是一致的，所以就有一个转化到我们自有观测服务的过程。</p><p>&nbsp;</p><p>在日志采集方面，通过 CRD 配置日志采集，将日志发送到统一的Kafka。通过我们自研的日志消费服务，消费各云厂商和自有节点上的日志，实现了虚拟节点和正常节点上日志的统一。</p><p>&nbsp;</p><p>在监控方面，云厂商虚拟节点实现的metrics接口和Kubelet完全兼容，可以无缝接入Prometheus，完成了Pod实时CPU/内存/磁盘/网络流量等监控，做到了和普通节点上的pod一致。</p><p>&nbsp;</p><p>在分布式追踪方面，由于无法部署daemonset形式的jeager agent，我们在jeager client端做了改造，通过环境变量识别pod运行的环境，如果是在虚拟节点上则跳过jeager agent，直接将分布式追踪的数据推送到jeager collector。</p><p>&nbsp;</p><p>最后是性能、稳定性和其它问题。</p><p>&nbsp;</p><p>Serverless 虚拟节点底层性能差异：由于底层计算资源规格的不同以及虚拟化层带来的开销，性能可能和裸金属服务器有所差异，这就需要对时延非常敏感的业务，在上虚拟节点之前进行充分的测试和评估。云厂商库存风险：高峰期大量扩容，如果云厂商某个规格的的资源水位低，可能会扩不出来指定规格的pod。对此，我们开启自动升配，假如申请2C2G pod，如果没有库存，会匹配到2C4G、4C4G的机器。以此类推。问题定位排查：因为虚拟节点本质上使用的是云厂商资源池，不在我们的管控范围内，当业务出现异常时虽然可以自动摘流，但无法登陆到机器排查问题，比如像查看系统日志、取回core dump文件等操作就比较困难。在我们的建议下，一些云厂商（阿里云ECI）已经支持将core dump自动上传到各自的对象存储了。</p><p>&nbsp;</p><p>目前该方案已经成熟，高峰期已有近万核规模的核心链路在线业务运行在Kubernetes 虚拟节点上。随着业务的放量，未来运行在Serverless虚拟节点上的服务规模会进一步扩大，将节省更多的资源成本。</p>",
    "publish_time": "2022-07-16 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]