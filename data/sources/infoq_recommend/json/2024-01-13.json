[
  {
    "title": "Expedia 使用 WebSocket 和 Kafka 实现近实时的数据流查询",
    "url": "https://www.infoq.cn/article/9zVV6PjSfqZPaDhM95FA",
    "summary": "<p>Expedia 实现了从他们的平台近实时地查询点击流数据的解决方案，这让他们的产品和工程团队可以在开发新的和增强现有数据驱动的特性时能够进行实时的数据探索。该团队使用了 WebSocket、Apache Kafka 和 PostgreSQL 的组合，可以连续向用户浏览器流式传输查询结果。</p><p></p><p>Expedia 的多个来源会产生大量数据，包括网站上的交互。用户在浏览网站或与网页元素进行交互时收集的点击流数据可以提供宝贵的用户行为见解。Expedia Group 的数据工程师（目前在 Personio）Ryan Lacerna 解释了近实时查询的优势：</p><p></p><p></p><blockquote>为了确保数据质量，我们面临的一个挑战是在数据注入管道后可以立即查看数据。传统的方法，如查询数据湖和数据仓库，需要较长的处理时间，而基于事件驱动的工具可以让用户快速高效地查询和查看流式数据，为数据生产者提供快速反馈，让数据使用者可以了解捕获了哪些数据。</blockquote><p></p><p></p><p>该团队选择使用 WebSocket 实现网页浏览器和服务器之间的双向实时通信。使用 WebSocket 的优势在于可以避免不断刷新服务器数据。此外，WebSocket 基于单个长连接，可以提高性能和最小化资源开销。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/ee/eeaf95b8b6b1011443cccc41b2817823.png\" /></p><p></p><p>近实时查询解决方案的架构（来源：Expedia 工程博客)</p><p></p><p>该解决方案包含了 UI 应用程序、WebSocket Handler 和 Filter Worker，并使用了 Apache Kafka 主题和 PostgreSQL 数据库。UI 提供了一个简单的查询表单，用户可以指定要显示的点击流事件类型，并提供了一个通过 WebSocket 发送查询结果的小部件。UI 应用程序使用 SockJS 库和 [STOMP 协议] 实现 (<a href=\"https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol\">https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol</a>\") 与服务器的交互。</p><p></p><p>在服务器端，WebSocket Handler 负责处理 STOMP 格式的查询，并将流式结果发送回浏览器。Handler 从 Apache Kafka 主题读取经过筛选的点击流事件。Filter Worker 负责基于活动查询将经过筛选的事件流发布到 WebSocket Handler 订阅的 Kafka 主题中。这两个服务在 Kubernetes 运行了多个副本，具备了可伸缩性。</p><p></p><p>服务使用 PostgreSQL 数据库来同步查询的细节，其中包括点击流事件的筛选条件。WebSocket Handler 将查询过滤器持久化到数据库表中，并在用户断开会话或 TTL（生存时间） 到期（在用户会话存在的情况下）时将其删除。该解决方案依赖了 Postgres 的 LISTEN/NOTIFY 功能，确保 Filter Worker 根据数据库的变更保持其内存缓存的最新状态。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/3b/3bf0fb50346e0f121b3c5afb3040e831.png\" /></p><p></p><p>将筛选事件路由给用户（来源：Expedia 工程博客）</p><p></p><p>与源主题相比，Filter Worker 服务显著减少了发布到筛选主题的事件的数量。发布到筛选主题的消息使用 Filter ID 作为键，WebSocket Handler 利用这个 ID 将消息路由给正确的用户。这种方法还支持对 WebSocket 层进行扩展，在工具用户数量增长时处理更大的负载。</p><p></p><p>原文链接：</p><p></p><p><a href=\"https://www.infoq.com/news/2023/12/expedia-websockets-kafka-query/\">https://www.infoq.com/news/2023/12/expedia-websockets-kafka-query/</a>\"</p><p></p><p></p><p></p><p></p>",
    "publish_time": "2024-01-13 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "服务端来自火星，客户端来自金星，RSC开发新思路",
    "url": "https://www.infoq.cn/article/xAqVQjRUuT8bGqU1xvg0",
    "summary": "<p>将Storybook升级到8.0alpha版本，可支持React服务端组件。</p><p>&nbsp;</p><p>在基于React的Web UI开发中，<a href=\"https://nextjs.org/docs/app/building-your-application/rendering/server-components?ref=storybookblog.ghost.io\">React服务端组件（RSC）</a>\"是一种新的编程模式。与传统的React “客户端”组件不同，它们只在服务器上进行渲染。这为性能和安全方面带来了一些好处，但与当下的各种React工具和库相比，其用法有很大的差异。</p><p>&nbsp;</p><p>其中受影响最大的领域之一就是基于组件驱动的开发和测试。诸如Storybook、Testing Library以及用于组件测试的工具Playwright和Cypress，全都是假设用户组件在浏览器（或 JSDom）中进行渲染。但是对于服务器组件来说，情况就不再是这样了。</p><p>&nbsp;</p><p>因此，这就引出了一个问题：该如何独立进行服务器端组件的开发和测试呢？</p><p>&nbsp;</p><p>今天，我很高兴地宣布，Storybook的Next.js框架将提供RSC支持，算是作为上述问题的一个尝试性的解决方案。由于它是一个纯客户端实现，所以能很好的集成和适配整个Storybook插件生态。</p><p>&nbsp;</p><p>本文介绍了它的工作原理和用法，并提供了一个简单的教程。</p><p>&nbsp;</p><p></p><h1>服务端来自火星，客户端来自金星</h1><p></p><p>&nbsp;</p><p>RSC与传统的客户端组件有两个主要区别，如下代码所示：</p><p>&nbsp;</p><p><code lang=\"null\">// ApiCard.tsx\nimport { ComponentProps } from 'react';\nimport { Card } from './Card';\nimport { findById } from './db';\nexport async function DbCard({ id }: {id: number}) {\n  let props;\n  try {\n    const contact = await findById(id);\n    props = { state: 'success', contact };\n  } catch (e) {\n    props = { state: 'error' };\n  }\n  return ;\n}</code></p><p>&nbsp;</p><p>第一个区别是：服务端组件是异步的，而这在客户端上是不支持的。第二个区别是：服务端组件可以直接访问Node代码，在这个示例中，函数findById封装了一个经过验证的数据库连接。</p><p>&nbsp;</p><p>为了实现这两点，RSC在底层做了很多事情。这段代码只能在服务器上运行，并生成一个静态的、类似JSON的结构，然后通过流的方式传输给客户端。</p><p>&nbsp;</p><p>Storybook是一个纯客户端应用。它是一个用于生成纯HTML/CSS/JS的静态构建，没有任何Node的影子！因此，如果要支持RSC，就需要解决两个问题：要么找出如何在客户端上渲染 RSC的方法，要么为服务端渲染重构Storybook。</p><p>&nbsp;</p><p>我们首先专注于客户端方法。这是因为，我们希望最大程度地减少对用户的影响，毕竟这些用户已经在当前的架构下编写了数百万个用例和上百个插件。</p><p>&nbsp;</p><p>那么，它到底是如何实现的呢？</p><p>&nbsp;</p><p></p><h1>开始支持异步</h1><p></p><p>&nbsp;</p><p>如何支持异步组件是在客户端上渲染RSC组件的第一个挑战。幸运的是，在Next.js最新依赖的React版本中已经（<a href=\"https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md?ref=storybookblog.ghost.io#why-cant-client-components-be-async-functions\">非官方地</a>\"）支持了这一功能。我们要特别感谢<a href=\"https://github.com/JamesManningR?ref=storybookblog.ghost.io\">JamesManningR</a>\"和<a href=\"https://github.com/julRuss?ref=storybookblog.ghost.io\">julRuss</a>\"，他们为此提供了一个简单的解决方案！</p><p>&nbsp;</p><p><code lang=\"null\">import { Suspense } from 'react';\nexport const ClientContact = ({ id }) =&gt; (\n  \n);</code></p><p>&nbsp;</p><p>从Storybook 8开始，通过在.storybook/main.js中开启experimentalNextRSC特性，@storybook/nextjs就会自动将你的story封装在Suspense中：</p><p>&nbsp;</p><p><code lang=\"null\">// .storybook/main.js\nexport default {\n  features: {\n    experimentalNextRSC: true,\n  }\n};</code></p><p>&nbsp;</p><p>在@storybook/nextjs 7.x版本中，你也可以手动将RSC story封装到<a href=\"https://storybook.js.org/docs/writing-stories/decorators/?ref=storybookblog.ghost.io\">装饰器</a>\"中。</p><p>&nbsp;</p><p>注意：这个解决方案目前还不能在其他Storybook React框架（例如 react-vite、react-webpack5）中使用，因为它们没有像Next.js那样使用canary版的React。希望下一个React版本能消除这个限制。</p><p>&nbsp;</p><p></p><h1>模拟和加载</h1><p></p><p></p><p>解决异步问题只解决了一半的问题。为了完成组件数据的填充，我们的DbCard组件是通过调用Node代码获取数据。然而，Node代码在浏览器中无法执行，这就导致了问题！</p><p>&nbsp;</p><p>为了解决这个问题，我们建议搭建一个干净的数据访问层。这也是<a href=\"https://nextjs.org/blog/security-nextjs-server-components-actions?ref=storybookblog.ghost.io\">RSC架构师推荐的最佳实践。</a>\"</p><p>&nbsp;</p><p>创建好数据访问层后，你就可以在浏览器中通过模拟来运行它，并精确控制返回的数据，展示不同的用户界面状态（加载中、错误、成功等）。</p><p>&nbsp;</p><p>你可以使用模块模拟或网络模拟来模拟数据访问层，这两种方式Storybook都支持。</p><p>&nbsp;</p><p>模块模拟：有一个叫做<a href=\"https://storybook.js.org/addons/storybook-addon-module-mock?ref=storybookblog.ghost.io\">storybook-addon-module-mock</a>\"的社区插件，它提供了和jest.mock（仅适用于Webpack项目）类似的模拟功能。当然，也可以使用<a href=\"https://webpack.js.org/configuration/resolve/?ref=storybookblog.ghost.io#resolvealias\">webpack/vite</a>\"的别名实现一个简单但功能有限的解决方案。我们计划在Storybook的未来版本中提供更便捷的模块模拟功能。</p><p>&nbsp;</p><p>网络API模拟：为了模拟网络请求，我们推荐使用<a href=\"https://storybook.js.org/addons/msw-storybook-addon?ref=storybookblog.ghost.io\">Mock Service Worker (msw)</a>\"。当然Storybook还支持许多<a href=\"https://storybook.js.org/integrations/tag/mocking?ref=storybookblog.ghost.io\">其他网络</a>\"和<a href=\"https://storybook.js.org/integrations/tag/graphql?ref=storybookblog.ghost.io\">GraphQL</a>\"模拟插件。</p><p>&nbsp;</p><p>回到上面的例子，下面是一个使用了storybook-addon-module-mock的story：</p><p>&nbsp;</p><p><code lang=\"null\">// DbCard.stories.js\nimport { StoryObj, Meta } from '@storybook/react';\nimport { createMock } from 'storybook-addon-module-mock';\nimport { DbCard } from './DbCard';\nimport * as db from './db';\nexport default { component: DbCard };\nexport const Success {\n  args: { id: 1 },\n  parameters: {\n    moduleMock: {\n      mock: () =&gt; {\n        const mock = createMock(db, 'findById');\n        mock.mockReturnValue(Promise.resolve({\n          name: 'Beyonce',\n          img: 'https://blackhistorywall.files.wordpress.com/2010/02/picture-device-independent-bitmap-119.jpg',\n          tel: '+123 456 789',\n          email: 'b@beyonce.com'\n        }))\n        return [mock];\n      },\n    },\n  },\n}</code></p><p>&nbsp;</p><p></p><h1>完整Demo：API+模块模拟</h1><p></p><p></p><p>要了解完整示例，包括使用模块模拟数据库版本和使用MSW2模拟API版本，请查看<a href=\"https://6578430567214463f1df4629-htkembgskw.chromatic.com/?path=%2Fdocs%2Foverview--docs&amp;ref=storybookblog.ghost.io\">完整</a>\"<a href=\"https://6578430567214463f1df4629-htkembgskw.chromatic.com/?path=%2Fdocs%2Foverview--docs&amp;ref=storybookblog.ghost.io\">的</a>\"<a href=\"https://6578430567214463f1df4629-htkembgskw.chromatic.com/?path=%2Fdocs%2Foverview--docs&amp;ref=storybookblog.ghost.io\">Storybook</a>\"<a href=\"https://6578430567214463f1df4629-htkembgskw.chromatic.com/?path=%2Fdocs%2Foverview--docs&amp;ref=storybookblog.ghost.io\"></a>\"<a href=\"https://6578430567214463f1df4629-htkembgskw.chromatic.com/?path=%2Fdocs%2Foverview--docs&amp;ref=storybookblog.ghost.io\">RSC示例</a>\"或<a href=\"https://github.com/shilman/storybook-rsc-demo?ref=storybookblog.ghost.io\">GitHub仓库</a>\"。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/af/af502851e033a3180fbf473bcb377234.png\" /></p><p></p><p>&nbsp;</p><p></p><h1>有什么问题吗？</h1><p></p><p></p><p>在本文中，我们成功地在Storybook中为RSC编写了第一个story，并展示了这一切是在幕后是如何实现的。</p><p>&nbsp;</p><p>虽然所有事情都相当的简单明了，但是这种方法还是会有一些限制：</p><p>&nbsp;</p><p>保真度：纯客户端实现与在应用程序中实际运行的服务端流式RSC相比依然存在显著的差异。便利性：这里的模拟解决方案肯定还有改进的空间。当前的模块模拟解决方案不仅冗长，且与Storybook的<a href=\"https://storybook.js.org/docs/api/doc-block-controls?ref=storybookblog.ghost.io\">参数/控件</a>\"也兼容的不够好。</p><p>&nbsp;</p><p>我们计划在后续的迭代中解决这两个问题，这也是为什么我们将此解决方案标记为实验性的原因。</p><p>&nbsp;</p><p>&nbsp;</p><p></p><h1>现在就在Storybook中进行RSC开发吧</h1><p></p><p>&nbsp;</p><p>要使用Storybook进行RSC开发，请将Storybook升级到 8.0-alpha 版本：</p><p>&nbsp;</p><p><code lang=\"null\">npx storybook@next upgrade --prerelease</code></p><p>&nbsp;</p><p>然后，在项目的.storybook/main.ts文件中将实验性功能开启：</p><p>&nbsp;</p><p><code lang=\"null\">// .storybook/main.js\nexport default {\n  features: {\n    experimentalNextRSC: true,\n    },\n  };\n}</code></p><p>&nbsp;</p><p>更多信息，请参阅@storybook/nextjs的<a href=\"https://github.com/storybookjs/storybook/blob/next/code/frameworks/nextjs/README.md?ref=storybookblog.ghost.io#experimental-react-server-components-rsc\">README文档</a>\"。</p><p>&nbsp;</p><p>本文是详细介绍Storybook 8.0的第一篇文章，在接下来的几个月里我们将发布更多的内容。请关注我们的<a href=\"https://twitter.com/storybookjs?ref=storybookblog.ghost.io\">社交媒体</a>\"或订阅<a href=\"https://storybook.us18.list-manage.com/subscribe?u=06a6fce3ab1327784d4342396&amp;id=18b5cea6e6&amp;ref=storybookblog.ghost.io\">Storybook新闻资讯</a>\"，获取Storybook下个版本的全部信息！</p><p>&nbsp;</p><p>&nbsp;</p><p>原文地址：<a href=\"https://storybook.js.org/blog/storybook-react-server-components/\">https://storybook.js.org/blog/storybook-react-server-components/</a>\"</p><p>&nbsp;</p><p></p><h5>相关阅读：</h5><p></p><p></p><p><a href=\"https://www.infoq.cn/article/SSjTSB0H2NPb02wwOJxz?utm_campaign=geek_search&amp;utm_content=geek_search&amp;utm_medium=geek_search&amp;utm_source=geek_search&amp;utm_term=geek_search\">从 Styleguidist 迁移到&nbsp;Storybook</a>\"</p><p><a href=\"https://www.infoq.cn/article/Web-Sockets-Proxy-Servers?utm_campaign=geek_search&amp;utm_content=geek_search&amp;utm_medium=geek_search&amp;utm_source=geek_search&amp;utm_term=geek_search\">HTML5 Web Sockets 与代理服务器交互</a>\"</p><p><a href=\"https://www.infoq.cn/article/Tv3SyqoivXMWUoj8qSMT\">从新&nbsp;React&nbsp;文档看未来 Web 的开发趋势</a>\"</p><p><a href=\"https://www.infoq.cn/article/6s2QNpu3EvR0LS5mHa3b?utm_campaign=geek_search&amp;utm_content=geek_search&amp;utm_medium=geek_search&amp;utm_source=geek_search&amp;utm_term=geek_search\">如何快速构建 React 组件库</a>\"</p>",
    "publish_time": "2024-01-13 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]