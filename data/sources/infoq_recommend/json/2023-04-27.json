[
  {
    "title": "零拷贝技术升级，V6D让数据传输更高效",
    "url": "https://www.infoq.cn/article/Qx4zJlivwd2B1XAzYxDr",
    "summary": "<p>零拷贝和内存数据管理器<a href=\"https://v6d.io/index.html\">Vineyard（v6d）</a>\"&nbsp;最近发布了<a href=\"http://github.com/v6d-io/v6d/releases/tag/v0.13.2\">0.13.2</a>\"版本，为Python/C++开发和Kubernetes部署带来了改进的功能。它是作为<a href=\"https://www.cncf.io/projects/vineyard/\">CNCF沙箱项目</a>\"来进行维护的，并提供了分布式操作符，可用于在集群节点内或跨集群节点共享不可变数据。V6d特别适用于大型（分片）数据集上（例如大语言和图模型）的深度网络训练。它的开发目前由阿里巴巴的一个工程团队领导。</p><p>&nbsp;</p><p><a href=\"https://en.wikipedia.org/wiki/Zero-copy\">零拷贝</a>\"和<a href=\"https://en.wikipedia.org/wiki/In-memory_database\">内存</a>\"数据分布是许多实时应用程序的核心问题。从图像处理管道到深度学习模型，如LLM和图挖掘算法等，许多数据处理应用程序都需要从许多独立的进程中获取大量数据。在机器学习工程中，随着深度网络变得越来越大，模型参数的分布要求访问共享状态和数据，这一瓶颈变得越来越明显了。作为一个早期项目，V6d旨在为此类用例提供一个高级API。</p><p>&nbsp;</p><p>实时应用程序的架构通常利用内存中的<a href=\"https://en.wikipedia.org/wiki/List_of_in-memory_databases\">键-值存储/缓存</a>\"（例如etcd、Memcached、Redis）来存储和交换频繁访问的数据。根据服务类型，工程团队必须考虑这些工具带来的相关权衡。V6d由两个主要组件组成：<a href=\"https://arrow.apache.org/docs/python/plasma.html\">Apache Arrow Plasma</a>\"派生共享内存数据管理器（在一个节点内）和由<a href=\"https://etcd.io/\">etcd</a>\"支持的元数据服务器（在不同节点之间）。虽然Plasma派生服务允许零拷贝数据传输，但etcd服务处理数据属性的全局分布（可能是分区的）。</p><p>&nbsp;</p><p>V6d将自己置于Python社区中。在某种程度上，可以考虑将Python原生的多进程<a href=\"https://docs.python.org/3/library/multiprocessing.shared_memory.html\">shared_memory</a>\"扩展到多台机器，以实现不可变的blob。V6d提供了两个不同的Python客户端接口<a href=\"https://v6d.io/notes/python-api.html#vineyard.IPCClient\">IPCClient</a>\"和<a href=\"https://v6d.io/notes/python-api.html#vineyard.RPCClient\">RPCClient</a>\"，分别用于操作本地和远程对象。两个客户端API都允许基于对象ID的统一数据插入和检索模式。然而，v6d<a href=\"https://v6d.io/notes/data-accessing.html#ipcclient-vs-rpcclient\">不会</a>\"在集群节点之间自动移动数据，除非被指示这样做，因为这种操作的高网络成本很高。</p><p>&nbsp;</p><p>我们可以提供了一个可以在本地机器上运行的简单示例，让我们先从创建本地v6d实例开始：</p><p>&nbsp;</p><p><code lang=\"null\">python -m vineyard --socket /tmp/vineyard.sock --size 16733650944</code></p><p>&nbsp;</p><p>作为第一步，让我们展示如何利用Python的原生API。为此，我们将使用NumPy创建一个10k分辨率的虚拟RGB图像，并使用shared_memory()接口来快速共享它：</p><p>&nbsp;</p><p><code lang=\"null\">import numpy as np\nfrom multiprocessing import shared_memory\nshape_, dtype_ = (3, 10000, 10000), np.uint8\narray_to_share = np.random.randint(0, high=255, size=shape_, dtype=dtype_)\n#创建共享内存\nshm = shared_memory.SharedMemory(create=True, size=array_to_share.nbytes)\narray_shm = np.ndarray(shape_, dtype=array_to_share.dtype, buffer=shm.buf)\narray_shm[:] = array_to_share[:] # Here we need to copy as we use existing array\n# 在另一个过程中使用共享内存名称、大小和类型信息来检索数据\nexisting_shm = shared_memory.SharedMemory(name=shm.name)\narray_retrieved = np.ndarray(shape=shape_, dtype=dtype_, buffer=existing_shm.buf)\n\n</code></p><p>&nbsp;</p><p>在这里，我们可以使用v6d执行相同的操作：</p><p>&nbsp;</p><p><code lang=\"null\">import vineyard\nclient = vineyard.connect('/tmp/vineyard.sock')\narray_id = client.put(array_to_share)\n# 在另一个进程中检索之前的array_to_share\narray_retrieved = client.get(array_id)</code></p><p>&nbsp;</p><p>如上所示，该API非常易于使用，并将数据类型和数组形状传播到检索到的对象中。由于是通用<a href=\"https://numpy.org/doc/stable/reference/arrays.interface.html\">数组协议</a>\"（又名缓冲协议），NumPy接口还接受对PyTorch、TensorFlow和MxNet张量的零拷贝操作。除此之外，v6d在Pandas/Arrow数据框架上进行了相同的操作。有关该库集成的更多详细信息，请访问<a href=\"https://v6d.io/notes/ml.html\">相关的文档页面</a>\"。 也可以在<a href=\"https://v6d.io/tutorials/distributed-learning.html\">网页中</a>\"找到机器学习培训教程的示例。</p><p>&nbsp;</p><p>对于多节点设置，V6d允许通过<a href=\"https://v6d.io/notes/deploy-kubernetes.html\">Python API</a>\"和<a href=\"https://v6d.io/notes/vineyard-operator.html#install-from-helm-chart\">Helm图表</a>\"在Kubernetes集群上部署vineyard操作。<a href=\"https://v6d.io/notes/architecture.html#architecture-of-vineyard\">官方文档</a>\"中还提供了更详细的架构概述。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/03/zero-copy-v6d/\">https://www.infoq.com/news/2023/03/zero-copy-v6d/</a>\"</p><p></p><p>相关阅读：</p>",
    "publish_time": "2023-04-27 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "从新React文档看未来Web的开发趋势",
    "url": "https://www.infoq.cn/article/Tv3SyqoivXMWUoj8qSMT",
    "summary": "<p>新的React文档终于到来，目前已经通过全新React.dev域与广大开发者见面。</p><p>&nbsp;</p><p>长久以来，官方文档是一直是新手们学习React的好起点。然而，新文档中表现出的一些倾向却在社区中引起了不小的轰动。</p><p>&nbsp;</p><p>首先，新文档建议在首次启动项目时使用Next.js或Remix等React支持的框架，而无框架开发项目的老办法则像麻风病人般被“驱逐”到了页面下方的下拉部分。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ed/ed20cda8de2dc396d452a8b8e0a524bb.png\" /></p><p></p><p>不知道这样的变化将如何影响Web开发的未来。作为大受欢迎的学习资源，官方文档有着非常强烈的引导性，相信开发社区、特别是那些经验不足的开发人员，肯定会严格按照说明操作、最终让框架在新项目中的使用频率大幅增加。</p><p>&nbsp;</p><p></p><h2>新文档是什么时候发布的？</h2><p></p><p>&nbsp;</p><p>新的React文档发布于2023年3月16日。</p><p>&nbsp;</p><p>其实文档内容早在2021年10月就已经作为beta形式亮相了，当时主要侧重于使用Hooks和一些函数组件。经过近两年的调整，如今正式版本终于推出，但社区反响却是褒贬不一。</p><p>&nbsp;</p><p>另外，原始文档已降级为旧版，但仍然开放以供参考。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/bc/bca0f2ccc560eaa24224810e1b063d14.png\" /></p><p></p><p></p><h2>新文档跟原React文档有何区别？</h2><p></p><p>&nbsp;</p><p>跟整个前端开发领域一样，React的开发思路也不可能停滞不前，一直随着时间推移而稳步发展。</p><p>&nbsp;</p><p></p><h3>Hook与useState</h3><p></p><p>&nbsp;</p><p>React组件有两种不同的编写方式，类组件或函数组件。</p><p>&nbsp;</p><p>以往，如果大家需要在组件中存储状态，那唯一的选择就是使用“有状态”类选项。更短、更简单的函数组件没办法满足这类需求。</p><p>&nbsp;</p><p>随着React 16.8当中Hook和useState的出现，这一切发生了变化。它们改变了游戏规则，现在允许将状态存储在函数组件当中。于是乎，函数组件成的风头盖过了更长、更复杂的类组件，成为众多Web开发者的首选。函数组件得势之后，旧的类组件降级为遗留选项，这也推动了“现代React”的流行并使其成为组件编写的标准方式。</p><p>&nbsp;</p><p>原始文档仍然非常关注类组件，这是因为很多应用都需要存储状态信息。其中列出的大部分代码示例都基于类选项，代表着当时最流行的解决方案。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/bb/bb73c7cbfa430baa57fdf235138bf276.png\" /></p><p></p><p>&nbsp;尽管旧文档在讲解React用法和为新用户提供示例方面做得不错，但其中大量旧示例的存在还是跟现实世界中的组件编写方式有所冲突。更令人沮丧的是，刚刚开始学习React的人们甚至不宜立刻阅读官方文档，因为这里介绍的是一种已经过时的React编写方式。</p><p>&nbsp;</p><p>而在阅读较新的beta文档时，开发者们又抱有怀疑态度，“这可是beta版，里面的内容可靠吗？”面对这样一个尴尬的问题，新文档明显是想要拨乱反正、定下新标杆。</p><p></p><p></p><h3>Create React App已无人问津</h3><p></p><p>&nbsp;</p><p>长久以来，Create React App一直是创建React新项目时的首选工具。它提供一种便捷方法，能够快速创建应用程序所需要的一切——开发服务器、linting、热重载开发环境、生产环境的转译和捆绑等等。</p><p>&nbsp;</p><p>最近，Create React App的吸引力开始被Vite抢走，后者凭借着显著的速度优势而越来越受到欢迎。</p><p>&nbsp;</p><p>新文档同样不再使用Create React App，甚至提都不提。但这个版本也没有将Vite作为首选方案，而开始大肆赞扬使用框架构建新应用的种种优势。</p><p>&nbsp;</p><p>Dan Abramov只在文档中建议将Create React App作为推荐框架的启动器。所以看起来Create React App并没有彻底出局，只是不再受到重视、推广和维护。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/08/085807e3c7def646fc0328cb6ae989ca.png\" /></p><p></p><p></p><h3>useEffect的必要性受到质疑</h3><p></p><p>&nbsp;</p><p>另外，社区还提出了另一个质疑，就是新版文档在React组件中对useEffect的使用似乎有点过度。</p><p>&nbsp;</p><p>很明显，useEffect确实在很多不必要的情况下得到了广泛使用，而它的存在其实只会令代码更难理解、执行更慢。</p><p>&nbsp;</p><p>文档在相关章节中提供了使用useEffect的常见情况和综合示例，但这些例子其实可以用其他更高效的方式来编写。</p><p>&nbsp;</p><p></p><h3>框架已成至高真理</h3><p></p><p>&nbsp;</p><p></p><blockquote>框架能够为大部分应用程序和网站提供实际需要的功能，包括路由、数据获取和HTML生成等。</blockquote><p></p><p>&nbsp;</p><p>文档中指出，尽管我们的React项目可能在起步阶段不一定需要框架所提供的一切，但很可能会在未来的某个时候有所需求。如果使用框架，即可在必要时轻松添加这些新功能。</p><p>&nbsp;</p><p>相反，如果大家选择Vite来创建项目，那后续就得自行负责添加额外的库来解决各种功能需求。根据文档的观点，这会降低应用程序的运行速度，同时拉高各组件间和谐匹配的难度。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/8d/8d38465e96bff63eaa4446a51dfe1a51.png\" /></p><p></p><p>&nbsp;文档中推荐的框架有Next.js、Remix、Gatsby和Expo。就个人而言，我当然承认使用框架有其好处，连我本人的网站也是用Next.js创建的。我最初也是使用Create React App开发网站，但在考虑到页面SEO和为谷歌的信息抓取提供元描述和标题等内容之后，框架用实力证明了自己的价值。</p><p>&nbsp;</p><p>React.dev网站本身现在也是用Next和Tailwind编写的，所以官方团队明显也在走这个路子。</p><p>&nbsp;</p><p></p><h2>但有必要把框架当成排他式的优先选项吗？</h2><p></p><p>&nbsp;</p><p>文档以非常鲜明的态度指出了创建新React项目的最佳方式。只要读读“我可以在不用框架的情况下使用React吗？”这部分，就能感受到项目团队强烈建议大家使用框架。</p><p>&nbsp;</p><p></p><blockquote>你当然可以在不匹配框架的情况下使用React。但如果希望使用React构建新的应用程序或网站，我们建议使用框架。但如果想自行创建定制化设置，我们也无权阻止。请便！</blockquote><p></p><p></p><p></p><p></p><h3>SSR (服务器端渲染)</h3><p></p><p>&nbsp;</p><p>既然如此大力推荐使用框架，这似乎意味着SSR（服务器端渲染）也是新应用的开发首选。从我收集到的反馈意见来看，大多数开发者也确实支持这种倾向。</p><p>&nbsp;</p><p>但我要唱唱反调，分享几个不同的观点。</p><p></p><p></p><h4>对初学者更不友好</h4><p></p><p>&nbsp;</p><p>对于刚刚接触React世界的初学者来说，立即接触服务器端渲染很容易令人心生畏惧。</p><p>&nbsp;</p><p>Create React App的出色之处就在于它相对简单而且易于使用，任何人都可以快速用它构建起React应用程序。而强制要求使用框架和服务器端渲染不仅增加了早期学习的复杂性，也很可能成为大家接触React的障碍，让初学者们难以坚持下去。</p><p>&nbsp;</p><p>老实说，就连我自己有时候都整不明白，更别说那些刚打算入行的新人了。在我看来，这东西真的挺劝退人的。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/75/75d40d36f006d75c4ffd3f0bb166a9eb.png\" /></p><p></p><p></p><h4>不必要的复杂性</h4><p></p><p>&nbsp;</p><p>不少网友评论说，“我只想要一个简单的客户端应用程序，不需要服务器端那些没完没了的复杂元素”。其实这话有理，因为在很多情况下，框架提供的那些额外内容和服务器元素其实完全没有任何必要。</p><p>&nbsp;</p><p>有时候，一个简单的客户端应用程序就足够了，没必要非得把一切都交给服务器去做渲染！</p><p>&nbsp;</p><p></p><h3>客户端单页应用</h3><p></p><p>&nbsp;</p><p>咱就问一句，客户端单页应用是不是被丢进垃圾堆了？React团队倒是矢口否认。</p><p>&nbsp;</p><p>Dan Abramov反驳说，虽然他们确实在推动框架作为创建新React应用的默认方式，但服务器端渲染并不是唯一的选项。</p><p>&nbsp;</p><p></p><blockquote>几乎所有这些框架都允许您生成纯客户端应用程序，几乎所有框架都可以不依赖于Node.js服务器。</blockquote><p></p><p>&nbsp;</p><p>但出于文档内所述的各种原因，他们仍然优先推荐框架，但不一定要匹配服务器端渲染。即使使用这些框架，也仍然可以创建纯客户端应用程序。</p><p>&nbsp;</p><p>这就是React团队给出的结论：应该优先使用框架，并在使用框架的前提下选择不用服务器端渲染。</p><p>&nbsp;</p><p></p><h2>新文档昭示出怎样的Web开发图景？</h2><p></p><p>&nbsp;</p><p>官方文档中关于使用框架的建议，必将对未来新React应用的创建倾向产生深远影响。</p><p>&nbsp;</p><p>与其花时间深入研究这些框架，相信会有更多人默认选择使用。这意味着未来的Web应用会越来越臃肿，并把服务器端处理机制全塞进去。</p><p>&nbsp;</p><p>可以看到，虽然使用这些框架也能创建纯客户端应用程序，但这绝对不是什么常规操作，React团队也因此受到了不少批评。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/df/df306687f5f840b92ee6ac85a1c909aa.png\" /></p><p></p><p>&nbsp;网友们非常直言不讳地驳斥了这种观点，所以希望能看到官方做点回应来消除人们的负面评论，最好是能稍微更新一下文档内容来做澄清。</p><p>&nbsp;</p><p>当然，我倒不觉得React这么搞就会失去人气，毕竟它仍然是首选库、将继续在多数开发者的心目中保持领先地位，也包括我自己。</p><p>&nbsp;</p><p>文档中提到的这些框架的流行度也会进一步飙升，毕竟React自己也在使用（他们的React.dev网站用的就是Next.js），并开始得到官方文档的推广。</p><p>&nbsp;</p><p>当然，也会有越来越多的应用程序使用服务器端渲染来创建，并从起步阶段就内置了所有附加功能（路由之类）。</p><p>&nbsp;</p><p></p><h2>总结</h2><p></p><p>&nbsp;</p><p>React官方文档是份很好的学习资料，目前的种种争议都改变不了这个基本事实。人们热切期待新的文档，现在正式版的发布终于满足了开发者群体的愿望。</p><p>&nbsp;</p><p>新文档会帮助到很多人，特别是那些刚刚开始学习React的朋友。当然，经验丰富的开发者也可以将其作为重要的参考资料。</p><p>&nbsp;</p><p>总之，新的文档确实引发了不少争议和讨论，我们也将持续关注事态的进一步发展。</p><p>&nbsp;</p><p></p><h5>相关阅读：</h5><p></p><p><a href=\"https://xie.infoq.cn/article/f2b2c65bf3db1ccfc2f7c4f09\">前端工程化实战：React 的模块化开发、性能优化和组件化实践</a>\"</p><p><a href=\"https://www.infoq.cn/article/CZKMjHaxbf1Z7xcSzisX\">我被 React 劫持了，很痛苦又离不开</a>\"</p><p><a href=\"https://xie.infoq.cn/article/958fbe57ff88cdba990d99739\">手写一个 react，看透 react 运行机制</a>\"</p><p><a href=\"https://xie.infoq.cn/article/3e10ee935ffd1b23b1ecd8842\">看透 react 源码之感受 react 的进化</a>\"</p>",
    "publish_time": "2023-04-27 11:08:09",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]