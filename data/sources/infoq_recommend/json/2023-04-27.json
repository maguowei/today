[
  {
    "title": "零拷贝技术升级，V6D让数据传输更高效",
    "url": "https://www.infoq.cn/article/Qx4zJlivwd2B1XAzYxDr",
    "summary": "<p>零拷贝和内存数据管理器<a href=\"https://v6d.io/index.html\">Vineyard（v6d）</a>\"&nbsp;最近发布了<a href=\"http://github.com/v6d-io/v6d/releases/tag/v0.13.2\">0.13.2</a>\"版本，为Python/C++开发和Kubernetes部署带来了改进的功能。它是作为<a href=\"https://www.cncf.io/projects/vineyard/\">CNCF沙箱项目</a>\"来进行维护的，并提供了分布式操作符，可用于在集群节点内或跨集群节点共享不可变数据。V6d特别适用于大型（分片）数据集上（例如大语言和图模型）的深度网络训练。它的开发目前由阿里巴巴的一个工程团队领导。</p><p>&nbsp;</p><p><a href=\"https://en.wikipedia.org/wiki/Zero-copy\">零拷贝</a>\"和<a href=\"https://en.wikipedia.org/wiki/In-memory_database\">内存</a>\"数据分布是许多实时应用程序的核心问题。从图像处理管道到深度学习模型，如LLM和图挖掘算法等，许多数据处理应用程序都需要从许多独立的进程中获取大量数据。在机器学习工程中，随着深度网络变得越来越大，模型参数的分布要求访问共享状态和数据，这一瓶颈变得越来越明显了。作为一个早期项目，V6d旨在为此类用例提供一个高级API。</p><p>&nbsp;</p><p>实时应用程序的架构通常利用内存中的<a href=\"https://en.wikipedia.org/wiki/List_of_in-memory_databases\">键-值存储/缓存</a>\"（例如etcd、Memcached、Redis）来存储和交换频繁访问的数据。根据服务类型，工程团队必须考虑这些工具带来的相关权衡。V6d由两个主要组件组成：<a href=\"https://arrow.apache.org/docs/python/plasma.html\">Apache Arrow Plasma</a>\"派生共享内存数据管理器（在一个节点内）和由<a href=\"https://etcd.io/\">etcd</a>\"支持的元数据服务器（在不同节点之间）。虽然Plasma派生服务允许零拷贝数据传输，但etcd服务处理数据属性的全局分布（可能是分区的）。</p><p>&nbsp;</p><p>V6d将自己置于Python社区中。在某种程度上，可以考虑将Python原生的多进程<a href=\"https://docs.python.org/3/library/multiprocessing.shared_memory.html\">shared_memory</a>\"扩展到多台机器，以实现不可变的blob。V6d提供了两个不同的Python客户端接口<a href=\"https://v6d.io/notes/python-api.html#vineyard.IPCClient\">IPCClient</a>\"和<a href=\"https://v6d.io/notes/python-api.html#vineyard.RPCClient\">RPCClient</a>\"，分别用于操作本地和远程对象。两个客户端API都允许基于对象ID的统一数据插入和检索模式。然而，v6d<a href=\"https://v6d.io/notes/data-accessing.html#ipcclient-vs-rpcclient\">不会</a>\"在集群节点之间自动移动数据，除非被指示这样做，因为这种操作的高网络成本很高。</p><p>&nbsp;</p><p>我们可以提供了一个可以在本地机器上运行的简单示例，让我们先从创建本地v6d实例开始：</p><p>&nbsp;</p><p><code lang=\"null\">python -m vineyard --socket /tmp/vineyard.sock --size 16733650944</code></p><p>&nbsp;</p><p>作为第一步，让我们展示如何利用Python的原生API。为此，我们将使用NumPy创建一个10k分辨率的虚拟RGB图像，并使用shared_memory()接口来快速共享它：</p><p>&nbsp;</p><p><code lang=\"null\">import numpy as np\nfrom multiprocessing import shared_memory\nshape_, dtype_ = (3, 10000, 10000), np.uint8\narray_to_share = np.random.randint(0, high=255, size=shape_, dtype=dtype_)\n#创建共享内存\nshm = shared_memory.SharedMemory(create=True, size=array_to_share.nbytes)\narray_shm = np.ndarray(shape_, dtype=array_to_share.dtype, buffer=shm.buf)\narray_shm[:] = array_to_share[:] # Here we need to copy as we use existing array\n# 在另一个过程中使用共享内存名称、大小和类型信息来检索数据\nexisting_shm = shared_memory.SharedMemory(name=shm.name)\narray_retrieved = np.ndarray(shape=shape_, dtype=dtype_, buffer=existing_shm.buf)\n\n</code></p><p>&nbsp;</p><p>在这里，我们可以使用v6d执行相同的操作：</p><p>&nbsp;</p><p><code lang=\"null\">import vineyard\nclient = vineyard.connect('/tmp/vineyard.sock')\narray_id = client.put(array_to_share)\n# 在另一个进程中检索之前的array_to_share\narray_retrieved = client.get(array_id)</code></p><p>&nbsp;</p><p>如上所示，该API非常易于使用，并将数据类型和数组形状传播到检索到的对象中。由于是通用<a href=\"https://numpy.org/doc/stable/reference/arrays.interface.html\">数组协议</a>\"（又名缓冲协议），NumPy接口还接受对PyTorch、TensorFlow和MxNet张量的零拷贝操作。除此之外，v6d在Pandas/Arrow数据框架上进行了相同的操作。有关该库集成的更多详细信息，请访问<a href=\"https://v6d.io/notes/ml.html\">相关的文档页面</a>\"。 也可以在<a href=\"https://v6d.io/tutorials/distributed-learning.html\">网页中</a>\"找到机器学习培训教程的示例。</p><p>&nbsp;</p><p>对于多节点设置，V6d允许通过<a href=\"https://v6d.io/notes/deploy-kubernetes.html\">Python API</a>\"和<a href=\"https://v6d.io/notes/vineyard-operator.html#install-from-helm-chart\">Helm图表</a>\"在Kubernetes集群上部署vineyard操作。<a href=\"https://v6d.io/notes/architecture.html#architecture-of-vineyard\">官方文档</a>\"中还提供了更详细的架构概述。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/03/zero-copy-v6d/\">https://www.infoq.com/news/2023/03/zero-copy-v6d/</a>\"</p><p></p><p>相关阅读：</p>",
    "publish_time": "2023-04-27 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "从新React文档看未来Web的开发趋势",
    "url": "https://www.infoq.cn/article/Tv3SyqoivXMWUoj8qSMT",
    "summary": "<p>新的React文档终于到来，目前已经通过全新React.dev域与广大开发者见面。</p><p>&nbsp;</p><p>长久以来，官方文档是一直是新手们学习React的好起点。然而，新文档中表现出的一些倾向却在社区中引起了不小的轰动。</p><p>&nbsp;</p><p>首先，新文档建议在首次启动项目时使用Next.js或Remix等React支持的框架，而无框架开发项目的老办法则像麻风病人般被“驱逐”到了页面下方的下拉部分。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ed/ed20cda8de2dc396d452a8b8e0a524bb.png\" /></p><p></p><p>不知道这样的变化将如何影响Web开发的未来。作为大受欢迎的学习资源，官方文档有着非常强烈的引导性，相信开发社区、特别是那些经验不足的开发人员，肯定会严格按照说明操作、最终让框架在新项目中的使用频率大幅增加。</p><p>&nbsp;</p><p></p><h2>新文档是什么时候发布的？</h2><p></p><p>&nbsp;</p><p>新的React文档发布于2023年3月16日。</p><p>&nbsp;</p><p>其实文档内容早在2021年10月就已经作为beta形式亮相了，当时主要侧重于使用Hooks和一些函数组件。经过近两年的调整，如今正式版本终于推出，但社区反响却是褒贬不一。</p><p>&nbsp;</p><p>另外，原始文档已降级为旧版，但仍然开放以供参考。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/bc/bca0f2ccc560eaa24224810e1b063d14.png\" /></p><p></p><p></p><h2>新文档跟原React文档有何区别？</h2><p></p><p>&nbsp;</p><p>跟整个前端开发领域一样，React的开发思路也不可能停滞不前，一直随着时间推移而稳步发展。</p><p>&nbsp;</p><p></p><h3>Hook与useState</h3><p></p><p>&nbsp;</p><p>React组件有两种不同的编写方式，类组件或函数组件。</p><p>&nbsp;</p><p>以往，如果大家需要在组件中存储状态，那唯一的选择就是使用“有状态”类选项。更短、更简单的函数组件没办法满足这类需求。</p><p>&nbsp;</p><p>随着React 16.8当中Hook和useState的出现，这一切发生了变化。它们改变了游戏规则，现在允许将状态存储在函数组件当中。于是乎，函数组件成的风头盖过了更长、更复杂的类组件，成为众多Web开发者的首选。函数组件得势之后，旧的类组件降级为遗留选项，这也推动了“现代React”的流行并使其成为组件编写的标准方式。</p><p>&nbsp;</p><p>原始文档仍然非常关注类组件，这是因为很多应用都需要存储状态信息。其中列出的大部分代码示例都基于类选项，代表着当时最流行的解决方案。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/bb/bb73c7cbfa430baa57fdf235138bf276.png\" /></p><p></p><p>&nbsp;尽管旧文档在讲解React用法和为新用户提供示例方面做得不错，但其中大量旧示例的存在还是跟现实世界中的组件编写方式有所冲突。更令人沮丧的是，刚刚开始学习React的人们甚至不宜立刻阅读官方文档，因为这里介绍的是一种已经过时的React编写方式。</p><p>&nbsp;</p><p>而在阅读较新的beta文档时，开发者们又抱有怀疑态度，“这可是beta版，里面的内容可靠吗？”面对这样一个尴尬的问题，新文档明显是想要拨乱反正、定下新标杆。</p><p></p><p></p><h3>Create React App已无人问津</h3><p></p><p>&nbsp;</p><p>长久以来，Create React App一直是创建React新项目时的首选工具。它提供一种便捷方法，能够快速创建应用程序所需要的一切——开发服务器、linting、热重载开发环境、生产环境的转译和捆绑等等。</p><p>&nbsp;</p><p>最近，Create React App的吸引力开始被Vite抢走，后者凭借着显著的速度优势而越来越受到欢迎。</p><p>&nbsp;</p><p>新文档同样不再使用Create React App，甚至提都不提。但这个版本也没有将Vite作为首选方案，而开始大肆赞扬使用框架构建新应用的种种优势。</p><p>&nbsp;</p><p>Dan Abramov只在文档中建议将Create React App作为推荐框架的启动器。所以看起来Create React App并没有彻底出局，只是不再受到重视、推广和维护。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/08/085807e3c7def646fc0328cb6ae989ca.png\" /></p><p></p><p></p><h3>useEffect的必要性受到质疑</h3><p></p><p>&nbsp;</p><p>另外，社区还提出了另一个质疑，就是新版文档在React组件中对useEffect的使用似乎有点过度。</p><p>&nbsp;</p><p>很明显，useEffect确实在很多不必要的情况下得到了广泛使用，而它的存在其实只会令代码更难理解、执行更慢。</p><p>&nbsp;</p><p>文档在相关章节中提供了使用useEffect的常见情况和综合示例，但这些例子其实可以用其他更高效的方式来编写。</p><p>&nbsp;</p><p></p><h3>框架已成至高真理</h3><p></p><p>&nbsp;</p><p></p><blockquote>框架能够为大部分应用程序和网站提供实际需要的功能，包括路由、数据获取和HTML生成等。</blockquote><p></p><p>&nbsp;</p><p>文档中指出，尽管我们的React项目可能在起步阶段不一定需要框架所提供的一切，但很可能会在未来的某个时候有所需求。如果使用框架，即可在必要时轻松添加这些新功能。</p><p>&nbsp;</p><p>相反，如果大家选择Vite来创建项目，那后续就得自行负责添加额外的库来解决各种功能需求。根据文档的观点，这会降低应用程序的运行速度，同时拉高各组件间和谐匹配的难度。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/8d/8d38465e96bff63eaa4446a51dfe1a51.png\" /></p><p></p><p>&nbsp;文档中推荐的框架有Next.js、Remix、Gatsby和Expo。就个人而言，我当然承认使用框架有其好处，连我本人的网站也是用Next.js创建的。我最初也是使用Create React App开发网站，但在考虑到页面SEO和为谷歌的信息抓取提供元描述和标题等内容之后，框架用实力证明了自己的价值。</p><p>&nbsp;</p><p>React.dev网站本身现在也是用Next和Tailwind编写的，所以官方团队明显也在走这个路子。</p><p>&nbsp;</p><p></p><h2>但有必要把框架当成排他式的优先选项吗？</h2><p></p><p>&nbsp;</p><p>文档以非常鲜明的态度指出了创建新React项目的最佳方式。只要读读“我可以在不用框架的情况下使用React吗？”这部分，就能感受到项目团队强烈建议大家使用框架。</p><p>&nbsp;</p><p></p><blockquote>你当然可以在不匹配框架的情况下使用React。但如果希望使用React构建新的应用程序或网站，我们建议使用框架。但如果想自行创建定制化设置，我们也无权阻止。请便！</blockquote><p></p><p></p><p></p><p></p><h3>SSR (服务器端渲染)</h3><p></p><p>&nbsp;</p><p>既然如此大力推荐使用框架，这似乎意味着SSR（服务器端渲染）也是新应用的开发首选。从我收集到的反馈意见来看，大多数开发者也确实支持这种倾向。</p><p>&nbsp;</p><p>但我要唱唱反调，分享几个不同的观点。</p><p></p><p></p><h4>对初学者更不友好</h4><p></p><p>&nbsp;</p><p>对于刚刚接触React世界的初学者来说，立即接触服务器端渲染很容易令人心生畏惧。</p><p>&nbsp;</p><p>Create React App的出色之处就在于它相对简单而且易于使用，任何人都可以快速用它构建起React应用程序。而强制要求使用框架和服务器端渲染不仅增加了早期学习的复杂性，也很可能成为大家接触React的障碍，让初学者们难以坚持下去。</p><p>&nbsp;</p><p>老实说，就连我自己有时候都整不明白，更别说那些刚打算入行的新人了。在我看来，这东西真的挺劝退人的。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/75/75d40d36f006d75c4ffd3f0bb166a9eb.png\" /></p><p></p><p></p><h4>不必要的复杂性</h4><p></p><p>&nbsp;</p><p>不少网友评论说，“我只想要一个简单的客户端应用程序，不需要服务器端那些没完没了的复杂元素”。其实这话有理，因为在很多情况下，框架提供的那些额外内容和服务器元素其实完全没有任何必要。</p><p>&nbsp;</p><p>有时候，一个简单的客户端应用程序就足够了，没必要非得把一切都交给服务器去做渲染！</p><p>&nbsp;</p><p></p><h3>客户端单页应用</h3><p></p><p>&nbsp;</p><p>咱就问一句，客户端单页应用是不是被丢进垃圾堆了？React团队倒是矢口否认。</p><p>&nbsp;</p><p>Dan Abramov反驳说，虽然他们确实在推动框架作为创建新React应用的默认方式，但服务器端渲染并不是唯一的选项。</p><p>&nbsp;</p><p></p><blockquote>几乎所有这些框架都允许您生成纯客户端应用程序，几乎所有框架都可以不依赖于Node.js服务器。</blockquote><p></p><p>&nbsp;</p><p>但出于文档内所述的各种原因，他们仍然优先推荐框架，但不一定要匹配服务器端渲染。即使使用这些框架，也仍然可以创建纯客户端应用程序。</p><p>&nbsp;</p><p>这就是React团队给出的结论：应该优先使用框架，并在使用框架的前提下选择不用服务器端渲染。</p><p>&nbsp;</p><p></p><h2>新文档昭示出怎样的Web开发图景？</h2><p></p><p>&nbsp;</p><p>官方文档中关于使用框架的建议，必将对未来新React应用的创建倾向产生深远影响。</p><p>&nbsp;</p><p>与其花时间深入研究这些框架，相信会有更多人默认选择使用。这意味着未来的Web应用会越来越臃肿，并把服务器端处理机制全塞进去。</p><p>&nbsp;</p><p>可以看到，虽然使用这些框架也能创建纯客户端应用程序，但这绝对不是什么常规操作，React团队也因此受到了不少批评。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/df/df306687f5f840b92ee6ac85a1c909aa.png\" /></p><p></p><p>&nbsp;网友们非常直言不讳地驳斥了这种观点，所以希望能看到官方做点回应来消除人们的负面评论，最好是能稍微更新一下文档内容来做澄清。</p><p>&nbsp;</p><p>当然，我倒不觉得React这么搞就会失去人气，毕竟它仍然是首选库、将继续在多数开发者的心目中保持领先地位，也包括我自己。</p><p>&nbsp;</p><p>文档中提到的这些框架的流行度也会进一步飙升，毕竟React自己也在使用（他们的React.dev网站用的就是Next.js），并开始得到官方文档的推广。</p><p>&nbsp;</p><p>当然，也会有越来越多的应用程序使用服务器端渲染来创建，并从起步阶段就内置了所有附加功能（路由之类）。</p><p>&nbsp;</p><p></p><h2>总结</h2><p></p><p>&nbsp;</p><p>React官方文档是份很好的学习资料，目前的种种争议都改变不了这个基本事实。人们热切期待新的文档，现在正式版的发布终于满足了开发者群体的愿望。</p><p>&nbsp;</p><p>新文档会帮助到很多人，特别是那些刚刚开始学习React的朋友。当然，经验丰富的开发者也可以将其作为重要的参考资料。</p><p>&nbsp;</p><p>总之，新的文档确实引发了不少争议和讨论，我们也将持续关注事态的进一步发展。</p><p>&nbsp;</p><p></p><h5>相关阅读：</h5><p></p><p><a href=\"https://xie.infoq.cn/article/f2b2c65bf3db1ccfc2f7c4f09\">前端工程化实战：React 的模块化开发、性能优化和组件化实践</a>\"</p><p><a href=\"https://www.infoq.cn/article/CZKMjHaxbf1Z7xcSzisX\">我被 React 劫持了，很痛苦又离不开</a>\"</p><p><a href=\"https://xie.infoq.cn/article/958fbe57ff88cdba990d99739\">手写一个 react，看透 react 运行机制</a>\"</p><p><a href=\"https://xie.infoq.cn/article/3e10ee935ffd1b23b1ecd8842\">看透 react 源码之感受 react 的进化</a>\"</p>",
    "publish_time": "2023-04-27 11:08:09",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "如何了解云数据库的隐藏费用，计算真实成本",
    "url": "https://www.infoq.cn/article/MTbRAyLuEbyW344cl1TF",
    "summary": "<p>在云计算成为主流之前，计算数据库成本只需要使用一个简单的公式：软件成本+硬件成本=数据库成本。如果你使用的是开源产品，那么软件成本可能会有所降低。虽然云计算已经从根本上改变了使用和部署软件的方式，但很多人仍然在使用这种过时的计算方法来计算数据库成本。</p><p>&nbsp;</p><p>事实上，在计算数据库的总体成本时，还有很多东西需要考虑。除了硬件和软件成本，你还需要考虑数据库的伸缩成本、与现有或未来系统集成的成本，以及计划中（或计划外）的停机时间成本。</p><p>&nbsp;</p><p>在计算云数据库的成本时，需要事先考虑到这些问题。在<a href=\"https://www.cockroachlabs.com/webinars/true-cost-of-a-cloud-database/\">The Cockroach Hour</a>\"的一期Webinar中，我们给出了在计算数据库真实成本时需要考虑的问题。成本主要分为三类：硬成本、运维成本和软成本。</p><p>&nbsp;</p><p>如果你想看完整的报告，可以看看这份<a href=\"https://www.cockroachlabs.com/guides/do-more-with-less-with-distributed-sql/\">50页的报告</a>\"。该报告评估了七家不同的公司，其中的见解可以帮你降低成本，改进正常运行时间，并加快创新的步伐。</p><p>&nbsp;</p><p>在本文中，我们将回顾Webinar中提到的各个成本项，并提供一个模板，你可以用它来计算自己的数据库成本。</p><p>&nbsp;</p><p></p><h2>数据库的硬成本</h2><p></p><p>&nbsp;</p><p>从表面上看，在云计算开始流行之前，等式的这一部分并没有太大变化。数据库的硬成本分为两类：软件许可和硬件。云计算的崛起为我们带来了一些关于硬件和软件成本的新问题。</p><p>&nbsp;</p><p></p><h2>云数据库软件成本</h2><p></p><p>&nbsp;</p><p>市场上有很多种软件许可，可以分为三类：</p><p>&nbsp;</p><p>传统企业：在云计算出现之前，这种模式在企业软件领域已经存在了30多年。你需要提前为企业软件许可支付一大笔费用（通常是数十万美元，再加上支持和维护费用）。购买之后，你还要为额外的功能和升级支付额外的费用。完全开源：完全免费的Apache许可。不过，与自由软件许可相关的成本并非不存在。你需要花钱维护它，支持它，降低它的风险。我们稍后会讨论这些成本。商业开源：这种模式大约是在10到15年前出现的，作为一种可行的解决方案，可以解决完全开源许可中存在的一些问题，比如补偿和支持方面的问题。</p><p>&nbsp;</p><p></p><h2>云数据库硬件成本</h2><p></p><p>&nbsp;</p><p>如今的硬件成本与30年前有所不同，但它们并没有消失，尽管你不再需要在机房里安装嗡嗡作响的巨型机器。不同的地方在于，你可能会与供应商协商价格，或利用规模来降低成本，但这些成本仍然存在。</p><p>&nbsp;</p><p>你还需要管理和运维，所以运维成本不会凭空消失。你需要花时间在云供应商提供的管理接口上，并从运维的角度来理解它们，因此接口的易用性就变得非常重要。</p><p>&nbsp;</p><p></p><h2>数据库的运维成本</h2><p></p><p>&nbsp;</p><p>除了硬件和软件成本之外，还有日常运行数据库所产生的成本。根据你所选择的供应商（及其定价结构）的不同，这方面的成本变化很大，但都存在同一个问题：如果在未来需要执行X个任务该怎么办？</p><p>&nbsp;</p><p>在使用数据库的过程中，你将不得不进行灾难恢复、水平伸缩以及将系统与其他工具集成，等等。我们可能会想“船到桥头自然直”，但在计算数据库的真实成本时，你需要考虑这些不可避免的情况，并在需要处理这些情况时将其纳入到成本计算当中。</p><p>&nbsp;</p><p></p><h2>灾难恢复：数据库故障成本</h2><p></p><p>&nbsp;</p><p>不管硬件之上有多少个抽象层，归根结底，我们都是在跟机械设备打交道，而机械设备总归会发生故障。在为你的应用程序部署数据库时，你还需要考虑临时或灾难性故障所带来的成本。虽然导致应用程序发生故障的原因有很多，但数据库是导致停机的主要原因：版本太旧、写入性能瓶颈、内存问题、事务被锁定、配置错误、硬件故障。你需要为这些不可避免的情况做好准备，因为它们总有一天会发生。</p><p>&nbsp;</p><p>计划中和计划外的停机都可能带来巨大的成本，虽然这种成本可能不容易计算，但仍然需要将其作为数据库成本的一部分来考虑。业务不同，停机时间的影响也不相同，但在计算停机时间对业务的影响成本时，可以考虑以下几个方面：</p><p>&nbsp;</p><p>收入损失：错失进行在线交易或吸引潜在用户的机会；声誉影响：消费者可能会转而购买竞争对手的产品；客户满意度：由于看到了问题的发生而对你的产品或服务失去信任；监管成本：监管机构有时会因数据问题对组织处以罚款；法律责任：在极端情况下，可能会因与数据丢失相关的问题遭到诉讼。</p><p>&nbsp;</p><p>有一些非常简单和直接的技术原因可以说明为什么数据丢失和停机可能会是一个问题。我们经常发现自己在处理较长时间的RPO（恢复点目标）/RTO（恢复时间目标），并承受高昂的技术成本。</p><p>&nbsp;</p><p></p><h2>水平伸缩：分片的成本</h2><p></p><p>&nbsp;</p><p>大多数云数据库的伸缩是通过加大实例的大小来实现的，但这种方法会受到可用最大大小的限制。如果你想要更大的规模或者需要全球规模时该怎么办？</p><p>&nbsp;</p><p>有些数据库，如AWS Aurora，允许扩展到单个实例（RDS）以外，并支持多个实例。但这仅用于读取，并且限制了可处理的事务数量，因为没有扩展写节点的能力。因此，你仍然面临规模的限制。此外，这种单一的写节点配置限制了跨地理区域访问的可用性，因为总是存在写访问的物理延迟。</p><p>&nbsp;</p><p>如果你选择对开源数据库（如PostgreSQL或MySQL）进行伸缩，就需要对数据库进行分片。这种方法会带来巨大的成本。首先，你需要修改应用程序，这会带来风险。你还需要配置一个新的实例，并在某个时刻（通常是在半夜）将流量切换到这个新的实例上。这会带来与硬件相关的额外成本，以及它给团队带来的痛苦……这还是最好的情况，如果在这个过程中出了问题，就会导致计划外的停机。此外，分片数据库的管理成本随着每个新分片的增加而呈指数级增长。</p><p>&nbsp;</p><p></p><h2>集成成本</h2><p></p><p>&nbsp;</p><p>你的数据库并不是孤立存在的，它将被集成到IT平台的其他部分。你不会在OLTP数据库中运行OLAP，数据仓库的出现是有原因的。因此，数据库与其他工具（如数据仓库）之间的集成就变得非常重要。根据数据库的不同，集成成本可能会很高。你需要使用Kafka或某种流式处理吗？你在使用数据湖吗？</p><p>&nbsp;</p><p></p><h2>在购买前评估数据库的隐性成本</h2><p></p><p>&nbsp;</p><p>除了运维成本之外，还有一些难以量化的问题，这些问题构成了云数据库的隐性成本，包括合规成本、竞争风险、供应商锁定的可能性以及吸引人才的能力。评估部署、管理和伸缩传统关系数据库隐性成本最好的方法是使用这个报告：</p><p>&nbsp;</p><p><a href=\"https://www.cockroachlabs.com/guides/do-more-with-less-with-distributed-sql/\">https://www.cockroachlabs.com/guides/do-more-with-less-with-distributed-sql/</a>\"</p><p>&nbsp;</p><p></p><h5>原文链接：</h5><p></p><p><a href=\"https://www.cockroachlabs.com/blog/true-cost-cloud-database/\">https://www.cockroachlabs.com/blog/true-cost-cloud-database/</a>\"</p><p></p><p></p><h5>相关阅读：</h5><p></p><p><a href=\"https://xie.infoq.cn/article/fcd01d0317de95c2bba6cc79c\">在今年的数字生态大会上，云原生数据库前进了一大步</a>\"</p><p><a href=\"https://xie.infoq.cn/article/45f0cd8221552649ab8dae201\">共促云原生数据库生态繁荣</a>\"</p><p><a href=\"https://www.infoq.cn/article/e9OECwQVphjLs0eXmr73\">国内首份《云数据库选型及满意度调查报告》出炉！ | ITPUB 报告（一）</a>\"</p><p><a href=\"https://xie.infoq.cn/article/871862a942f1ee93ed4f89cd1\">TDSQL云时代，我们需要怎样的数据库？</a>\"</p>",
    "publish_time": "2023-04-27 11:08:53",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Ruby on Rails之父闹着要下云，亚马逊ceo：我们将重视“降本增效”",
    "url": "https://www.infoq.cn/article/kdiaQ7QATUtZXj12eYuu",
    "summary": "<p></p><blockquote>亚马逊云科技销售和支持团队目前正将大部分时间用于帮助客户优化 AWS 支出，确保他们能够平衡度过这个不确定性的经济时期。</blockquote><p></p><p></p><p>这是 Amazon.com CEO Andy Jassy 在写给公司股东的年度信件中的原话。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/c8/c8de7b5a1f9297880d6b10a68f84a140.png\" /></p><p></p><p>Jassy 解释道，“与我们的其他业务一样，AWS 也不会单纯针对一年或者一个季度做优化。”相反，整个亚马逊都在“努力建立起全方位的持久客户关系（和业务）；因此我们的 AWS 销售和支持团队正将大部分时间用于帮助客户优化 AWS 支出，确保他们能够平衡度过这个不确定性的经济时期。”</p><p></p><p>“不少 AWS 客户告诉我们，他们从未像本轮成本优化这样认真削减过运营开销，由此节约下的资源将被投入到他们正在规划的全新创造性客户体验当中。他们对这种以客户为中心的策略深表赞赏，这对于客户和 AWS 来说也是通往双赢的好态势。”</p><p></p><p>Jassy 补充道，“尽管种种短期不利因素削弱了我们的业务增长率，但我们对 AWS 体系内的各个基本面仍然相当看好。”而这里提到的基本面，包括吸引新客户和推进主动迁移的“强大”管道。</p><p></p><p>“在这样充满动荡的时期，很多企业会选择退后一步，重新审视自己的战略规划。我们发现，越来越多的企业选择放弃自主管理基础设施，转而迁往 AWS 以享受更好的敏捷性、创新、成本效率和安全优势。”</p><p></p><p>但这些优势当中并不涉及成本节约。SaaS 供应商 37Signals 正是出于成本考量而退出了云计算，37signals 的文章提到【微信文章链接 https://mp.weixin.qq.com/s/GkdYLv1YjAyGnQdjVxyN6w】，该公司曾经使用云计算服务来托管其在线应用程序，但最终决定将其迁回到自己的数据中心。这个决定的原因是，在云计算服务中，他们不得不支付更高的成本，而且他们无法完全控制应用程序和数据。通过自己的数据中心，他们可以更好地控制成本和应用程序的稳定性，并且可以更好地满足客户的需求。</p><p>软件供应商 Ahrefs 甚至估算称自有托管数据中心提供的硬件为其节约下 4 亿美元，他们在文章中指出，【微信文章链接：https://mp.weixin.qq.com/s/KzIjVy11zs4VZSn7it748A】避免使用云计算可以降低成本。云计算的价格通常很高，而且随着使用量的增加，费用也会增加。相比之下，购买和维护自己的服务器可以更加经济实惠。而自主管理服务器可以提供更好的灵活性和控制。对于 Ahrefs 来说，他们的业务需要处理大量数据，而自己的服务器可以更好地适应这种需求。Ahrefs 强调，如果将产品百分百上云，那么 Ahref 将不再有利润，甚至也不再会存在。面对媒体，不少硬件供应商也给出了类似的结论，称确实有不少客户出于成本节约而放弃云计算。</p><p></p><p>尽管目前的经济环境令投资者感到不安，但 Jassy 对未来仍充满信心，因为他发现“全球约 90% 的 IT 支出仍然集中在本地，尚未真正迁移至云端”。这意味着 AWS 仍有巨大的上升空间。他在信中指出，亚马逊旗下还有很多比 AWS 开发更早的业务。所以虽然目前的经济环境确实令投资者们心生不安，但亚马逊仍在一步一个脚印投资于推动未来增长的新业务。AWS 本身就是这项战略的实际成果。亚马逊当初在 2007 年到 2008 年全球金融危机期间的投资，最终成就了傲视同侪的云计算帝国。</p><p></p><p>总之，云计算可以是一个有效的降本增效的工具，但企业需要根据实际情况选择最适合自己的解决方案。对于某些企业，云计算服务可能比自己的数据中心更适合，因为它可以提供更高的弹性和可扩展性，同时可以降低 IT 成本和风险。而对于其他企业，自己的数据中心可能更适合。但无论选择哪种方案企业都需要实施一些策略和实践来最大化云计算的降本增效潜力。</p><p></p><p></p><h5>参考文章：</h5><p></p><p>https://www.theregister.com/2023/04/17/amazon_annual_shareholder_letter_aws/</p><p>https://dev.37signals.com/bringing-our-apps-back-home/</p><p>https://www.aboutamazon.com/news/company-news/amazon-ceo-andy-jassy-2022-letter-to-shareholders</p><p></p><p></p><h5>相关阅读：</h5><p></p><p><a href=\"https://xie.infoq.cn/article/b14696263a58d961487c9368e\">多云之下，京东云的降本增效之道</a>\"</p><p><a href=\"https://xie.infoq.cn/article/91dda3b9a9051795b49a640a1\">降本增效不是“盲目减脂”，利用亚马逊云科技达成云成本正循环</a>\"</p><p><a href=\"https://xie.infoq.cn/article/147d91ead496aa06c0684ca89\">我们在华为云上实现了降本增效</a>\"</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651106711&amp;idx=3&amp;sn=73a9259175cf9662bb104b83dbaa0536&amp;chksm=bdb955c48acedcd2bad808c907522866f6f3612dc9d3c49bf168bfa7372e5561c392e3c3b480&amp;scene=27#wechat_redirect\">数字经济下的“降本增效”之路怎么走？</a>\"</p>",
    "publish_time": "2023-04-27 11:10:49",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "圆桌“论剑”：网关未来将走向何方？｜InfoQ《极客有约》",
    "url": "https://www.infoq.cn/article/ryz7FSgVC3FdSzpFfalm",
    "summary": "<p>云原生网关正流行，大家会碰撞出怎样的火花？未来网关之路又会怎样？本期《极客有约》，NGINX、APISIX、Higress “当家人”共同做客《极客有约》，共话网关未来。</p>\n<p><strong>核心议题：</strong></p>\n<ul>\n<li>网关产品怎么做升级演化</li>\n<li>各项目的云原生网关规划</li>\n<li>现在还能入局网关市场吗</li>\n<li>网关生态未来如何长期健康发展</li>\n</ul>",
    "publish_time": "2023-04-27 13:08:25",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Ruby on Rails之父闹着要下云，亚马逊CEO：我们将重视“降本增效”",
    "url": "https://www.infoq.cn/article/kdiaQ7QATUtZXj12eYuu",
    "summary": "<p></p><blockquote>亚马逊云科技销售和支持团队目前正将大部分时间用于帮助客户优化 AWS 支出，确保他们能够平衡度过这个不确定性的经济时期。</blockquote><p></p><p></p><p>这是 Amazon.com CEO Andy Jassy 在写给公司股东的年度信件中的原话。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/c8/c8de7b5a1f9297880d6b10a68f84a140.png\" /></p><p></p><p>Jassy 解释道，“与我们的其他业务一样，AWS 也不会单纯针对一年或者一个季度做优化。”相反，整个亚马逊都在“努力建立起全方位的持久客户关系（和业务）；因此我们的 AWS 销售和支持团队正将大部分时间用于帮助客户优化 AWS 支出，确保他们能够平衡度过这个不确定性的经济时期。”</p><p></p><p>“不少 AWS 客户告诉我们，他们从未像本轮成本优化这样认真削减过运营开销，由此节约下的资源将被投入到他们正在规划的全新创造性客户体验当中。他们对这种以客户为中心的策略深表赞赏，这对于客户和 AWS 来说也是通往双赢的好态势。”</p><p></p><p>Jassy 补充道，“尽管种种短期不利因素削弱了我们的业务增长率，但我们对 AWS 体系内的各个基本面仍然相当看好。”而这里提到的基本面，包括吸引新客户和推进主动迁移的“强大”管道。</p><p></p><p>“在这样充满动荡的时期，很多企业会选择退后一步，重新审视自己的战略规划。我们发现，越来越多的企业选择放弃自主管理基础设施，转而迁往 AWS 以享受更好的敏捷性、创新、成本效率和安全优势。”</p><p></p><p>但这些优势当中并不涉及成本节约。SaaS 供应商 37Signals 正是出于成本考量而退出了云计算，37signals 的<a href=\"https://mp.weixin.qq.com/s/GkdYLv1YjAyGnQdjVxyN6w\">文章</a>\"提到，该公司曾经使用云计算服务来托管其在线应用程序，但最终决定将其迁回到自己的数据中心。这个决定的原因是，在云计算服务中，他们不得不支付更高的成本，而且他们无法完全控制应用程序和数据。通过自己的数据中心，他们可以更好地控制成本和应用程序的稳定性，并且可以更好地满足客户的需求。</p><p></p><p>软件供应商 Ahrefs 甚至估算称自有托管数据中心提供的硬件为其节约下 4 亿美元，他们在<a href=\"https://mp.weixin.qq.com/s/KzIjVy11zs4VZSn7it748A\">文章</a>\"中指出，避免使用云计算可以降低成本。云计算的价格通常很高，而且随着使用量的增加，费用也会增加。相比之下，购买和维护自己的服务器可以更加经济实惠。而自主管理服务器可以提供更好的灵活性和控制。对于 Ahrefs 来说，他们的业务需要处理大量数据，而自己的服务器可以更好地适应这种需求。Ahrefs 强调，如果将产品百分百上云，那么 Ahref 将不再有利润，甚至也不再会存在。面对媒体，不少硬件供应商也给出了类似的结论，称确实有不少客户出于成本节约而放弃云计算。</p><p></p><p>尽管目前的经济环境令投资者感到不安，但 Jassy 对未来仍充满信心，因为他发现“全球约 90% 的 IT 支出仍然集中在本地，尚未真正迁移至云端”。这意味着 AWS 仍有巨大的上升空间。他在信中指出，亚马逊旗下还有很多比 AWS 开发更早的业务。所以虽然目前的经济环境确实令投资者们心生不安，但亚马逊仍在一步一个脚印投资于推动未来增长的新业务。AWS 本身就是这项战略的实际成果。亚马逊当初在 2007 年到 2008 年全球金融危机期间的投资，最终成就了傲视同侪的云计算帝国。</p><p></p><p>总之，云计算可以是一个有效的降本增效的工具，但企业需要根据实际情况选择最适合自己的解决方案。对于某些企业，云计算服务可能比自己的数据中心更适合，因为它可以提供更高的弹性和可扩展性，同时可以降低 IT 成本和风险。而对于其他企业，自己的数据中心可能更适合。但无论选择哪种方案企业都需要实施一些策略和实践来最大化云计算的降本增效潜力。</p><p></p><p></p><h5>参考文章：</h5><p></p><p><a href=\"https://www.theregister.com/2023/04/17/amazon_annual_shareholder_letter_aws/\">https://www.theregister.com/2023/04/17/amazon_annual_shareholder_letter_aws/</a>\"</p><p><a href=\"https://dev.37signals.com/bringing-our-apps-back-home/\">https://dev.37signals.com/bringing-our-apps-back-home/</a>\"</p><p><a href=\"https://www.aboutamazon.com/news/company-news/amazon-ceo-andy-jassy-2022-letter-to-shareholders\">https://www.aboutamazon.com/news/company-news/amazon-ceo-andy-jassy-2022-letter-to-shareholders</a>\"</p><p></p><p></p><h5>相关阅读：</h5><p></p><p><a href=\"https://xie.infoq.cn/article/b14696263a58d961487c9368e\">多云之下，京东云的降本增效之道</a>\"</p><p><a href=\"https://xie.infoq.cn/article/91dda3b9a9051795b49a640a1\">降本增效不是“盲目减脂”，利用亚马逊云科技达成云成本正循环</a>\"</p><p><a href=\"https://xie.infoq.cn/article/147d91ead496aa06c0684ca89\">我们在华为云上实现了降本增效</a>\"</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651106711&amp;idx=3&amp;sn=73a9259175cf9662bb104b83dbaa0536&amp;chksm=bdb955c48acedcd2bad808c907522866f6f3612dc9d3c49bf168bfa7372e5561c392e3c3b480&amp;scene=27#wechat_redirect\">数字经济下的“降本增效”之路怎么走？</a>\"</p>",
    "publish_time": "2023-04-27 11:10:49",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "代码重构：面向单元测试",
    "url": "https://www.infoq.cn/article/5c83e55dbac27f793a5425f1f",
    "summary": "<p>作者：杜沁园</p><p></p><p></p><blockquote>本文将会以一个 “生产者消费者” 的代码重构示例贯穿始终。并以一个业务上常见的Excel导出系统为例，简单阐述业务上的重构实例。</blockquote><p></p><p></p><p>重构代码时，我们常常纠结于这样的问题：</p><p></p><p>需要进一步抽象吗？会不会导致过度设计？如果需要进一步抽象的话，如何进行抽象呢？有什么通用的步骤或者法则吗？</p><p></p><p>单元测试是我们常用的验证代码正确性的工具，但是如果只用来验证正确性的话，那就是真是 “大炮打蚊子”—大材小用，它还可以帮助我们评判代码的抽象程度与设计水平。本文还会提出一个以“可测试性”为目标，不断迭代重构代码的思路，利用这个思路，面对任何复杂的代码，都能逐步推导出重构思路。为了保证直观，本文会以一个 “生产者消费者” 的代码重构示例贯穿始终。最后还会以业务上常见的Excel导出系统为例简单阐述一个业务上的重构实例。</p><p></p><p>阅读本文需要具有基本的单元测试编写经验（最好是Java），但是本文不会涉及任何具体的单元测试框架和技术，因为它们都是不重要的，学习了本文的思路，可以将它们用在任意的单测工具上。</p><p></p><p></p><h1>一、不可测试的代码</h1><p></p><p></p><p>程序员们重构一段代码的动机是什么？可能众说纷纭：</p><p></p><p>代码不够简洁？不好维护？不符合个人习惯？过度设计，不好理解？</p><p></p><p>这些都是比较主观的因素，在一个老练程序员看来恰到好处的设计，一个新手程序员却可能会觉得过于复杂，不好理解。但是让他们同时坐下来为这段代码添加单元测试时，他们往往能够产生类似的感受，比如：</p><p></p><p>“单测很容易书写，很容易就全覆盖了”，那么这就是可测试的代码；“虽然能写得出来，但是费了老大劲，使用了各种框架和技巧，才覆盖完全”，那么这就是可测试性比较差的代码；“完全不知道如何下手写”，那么这就是不可测试的代码；</p><p></p><p>一般而言，可测试的代码一般都是同时是简洁和可维护的，但是简洁可维护的代码却不一定是可测试的，比如下面的“生产者消费者”代码就是不可测试的：</p><p></p><p><code lang=\"text\">public void producerConsumer() {\n    BlockingQueue blockingQueue = new LinkedBlockingQueue&lt;&gt;();\n    Thread producerThread  = new Thread(() -&gt; {\n        for (int i = 0; i &lt; 10; i++) {\n            blockingQueue.add(i + ThreadLocalRandom.current().nextInt(100));\n        }\n    });\n    Thread consumerThread = new Thread(() -&gt; {\n        try {\n            while (true) {\n                Integer result = blockingQueue.take();\n                System.out.println(result);\n            }\n        } catch (InterruptedException ignore) {\n        }\n    });\n    producerThread.start();\n    consumerThread.start();\n}\n</code></p><p></p><p>上面这段代码做的事情非常简单，启动两个线程：</p><p></p><p>生产者：将 0-9 的每个数字，分别加上 [0,100) 的随机数后通过阻塞队列传递给消费者；消费者：从阻塞队列中获取数字并打印；</p><p></p><p>这段代码看上去还是挺简洁的，但是，算得上一段好代码吗？尝试下给这段代码加上单元测试。仅仅运行一下这个代码肯定是不够的，因为我们无法确认生产消费逻辑是否正确执行。我也只能发出“完全不知道如何下手”的感叹，这不是因为我们的单元测试编写技巧不够，而是因为代码本身存在的问题：</p><p></p><p>1）违背单一职责原则：这一个函数同时做了数据传递，处理数据，启动线程三件事情。单元测试要兼顾这三个功能，就会很难写。</p><p></p><p>2）这个代码本身是不可重复的，不利于单元测试，不可重复体现在：</p><p></p><p>需要测试的逻辑位于异步线程中，对于它什么时候执行？什么时候执行完？都是不可控的；逻辑中含有随机数；消费者直接将数据输出到标准输出中，在不同环境中无法确定这里的行为是什么，有可能是输出到了屏幕上，也可能是被重定向到了文件中；</p><p></p><p>因为第2点的原因，我们就不得不放弃单测了呢？其实只要通过合理的模块职责划分，依旧是可以单元测试。这种划分不仅仅有助于单元测试，也会“顺便”帮助我们抽象一套更加合理的代码。</p><p></p><p></p><h1>二、可测试意味着什么？</h1><p></p><p></p><p>所有不可测试的代码都可以通过合理的重构与抽象，让其核心逻辑变得可测试，这也重构的意义所在。本章就会详细说明这一点。</p><p></p><p>首先我们要了解可测试意味着什么，如果说一段代码是可测试的，那么它一定符合下面的条件：</p><p></p><p>可以在本地设计完备的测试用例，称之为完全覆盖的单元测试；只要完全覆盖的单元测试用例全部正确运行，那么这一段逻辑肯定是没有问题的。</p><p></p><p>第一点常常会令人感到难以置信，但事实比想象的简单，假设有这样一个分段函数：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/37/370799c1f04172805affd76300350f1e.png\" /></p><p></p><p>f(x)看起来有无限的定义域，我们永远无法穷举所有可能的输入。但是再仔细想想，我们并不需要穷举，其实只要下面几个用例可以通过，那么就可以确保这个函数是没有问题的：</p><p></p><p>&lt;-50f(-51) == -100[-50, 50]f(-25) == -50f(25) == 50&gt;50f(51) == 100边界情况f(-50) == -100f(50) == 100</p><p></p><p>日常工作中的代码当然比这个复杂很多，但是没有本质区别，也是按照如下思路进行单元测试覆盖的：</p><p></p><p>每一个分段其实就是代码中的一个条件分支，用例的分支覆盖率达到了100%；像2x这样的逻辑运算，通过几个合适的采样点就可以保证正确性；边界条件的覆盖，就像是分段函数的转折点。</p><p></p><p>但是业务代码依旧比f(x)要复杂很多，因为f(x)还有其他好的性质让它可以被完全测试，这个性质被称作引用透明：函数的返回值只和参数有关，只要参数确定，返回值就是唯一确定的。</p><p></p><p>现实中的代码大多都不会有这么好的性质，反而具有很多“坏的性质”，这些坏的性质也常被称为副作用：</p><p></p><p>代码中含有远程调用，无法确定这次调用是否会成功；含有随机数生成逻辑，导致行为不确定；执行结果和当前日期有关，比如只有工作日的早上，闹钟才会响起。</p><p></p><p>好在我们可以用一些技巧将这些副作用从核心逻辑中抽离出来。</p><p></p><p></p><h2>2.1 高阶函数</h2><p></p><p></p><p>“引用透明” 要求函数的出参由入参唯一确定，之前的例子容易让人产生误解，觉得出参和入参一定要是数据，让我们把视野再打开一点，出入参可以是一个函数，它也可以是引用透明的。</p><p></p><p>普通的函数又可以称作一阶函数，而接收函数作为参数，或者返回一个函数的函数称为高阶函数，高阶函数也可以是引用透明的。</p><p></p><p>对于函数f(x)来说，x是数据还是函数，并没有本质的不同，如果x是函数的话，仅仅意味着f(x)拥有更加广阔的定义域，以至于没有办法像之前一样只用一个一维数轴表示。</p><p></p><p>对于高阶函数f(g) (g是一个函数)来说，只要对于特定的函数g，返回逻辑也是固定，它就是引用透明的了， 而不用在乎参数g或者返回的函数是否有副作用。利用这个特性，我们很容易将一个有副作用的函数转换为一个引用透明的高阶函数。</p><p></p><p>一个典型的拥有副作用的函数如下：</p><p></p><p><code lang=\"text\">public int f() {\n    return ThreadLocalRandom.current().nextInt(100) + 1;\n}\n</code></p><p></p><p>它生成了随机数并且加1，因为这个随机数，导致它不可测试。但是我们将它转换为一个可测试的高阶函数，只要将随机数生成逻辑作为一个参数传入，并且返回一个函数即可：</p><p></p><p><code lang=\"text\">public Supplier g(Supplier integerSupplier) {\n    return () -&gt; integerSupplier.get() + 1;\n}\n</code></p><p></p><p>上面的g就是一个引用透明的函数，只要给g传递一个数字生成器，返回值一定是一个 “用数字生成器生成一个数字并且加1” 的逻辑，并且不存在分支条件和边界情况，只需要一个用例即可覆盖：</p><p></p><p><code lang=\"text\">public void testG() {\n    Supplier result = g(() -&gt; 1);\n    assert result.get() == 2;\n}\n</code></p><p></p><p>实际业务中可以稍微简化一下高阶函数的表达， g的返回的函数既然每次都会被立即执行，那我们就不返回函数了，直接将逻辑写在方法中，这样也是可测试的：</p><p></p><p><code lang=\"text\">public int g2(Supplier integerSupplier) {\n    return integerSupplier.get() + 1;\n}\n</code></p><p></p><p>这里我虽然使用了Lambda表达式简化代码，但是 “函数” 并不仅仅是指Lambda表达式，OOP中的充血模型的对象，接口等等，只要其中含有逻辑，它们的传递和返回都可以看作 “函数”。</p><p></p><p></p><blockquote>因为这个例子比较简单，“可测试” 带来的收益看起来没有那么高，真实业务中的逻辑一般比+1要复杂多了，此时如果能构建有效的测试将是非常有益的。</blockquote><p></p><p></p><p></p><h1>三、面向单测的重构</h1><p></p><p></p><p></p><h2>3.1 第一轮重构</h2><p></p><p></p><p>我们本章回到开头的生产者消费者的例子，用上一章学习到的知识对它进行重构。</p><p></p><p>那段代码无法测试的第一个问题就是职责不清晰，它既做数据传递，又做数据处理。因此我们考虑将生产者消费者数据传递的代码单独抽取出来：</p><p></p><p><code lang=\"text\">public  void  producerConsumerInner(Consumer&gt; producer,\n                                       Consumer&gt; consumer) {\n    BlockingQueue blockingQueue = new LinkedBlockingQueue&lt;&gt;();\n    new Thread(() -&gt; producer.accept(blockingQueue::add)).start();\n    new Thread(() -&gt; consumer.accept(() -&gt; {\n        try {\n            return blockingQueue.take();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    })).start();\n}\n</code></p><p></p><p>这一段代码的职责就很清晰了，我们给这个方法编写单元测试的目标也十分明确，即验证数据能够正确地从生产者传递到消费者。但是很快我们又遇到了之前提到的第二个问题，即异步线程不可控，会导致单测执行的不稳定，用上一章的方法，我们将执行器作为一个入参抽离出去：</p><p></p><p><code lang=\"text\">public  void  producerConsumerInner(Executor executor,\n                                  Consumer&gt; producer,\n                                  Consumer&gt; consumer) {\n    BlockingQueue blockingQueue = new LinkedBlockingQueue&lt;&gt;();\n    executor.execute(() -&gt; producer.accept(blockingQueue::add));\n    executor.execute(() -&gt; consumer.accept(() -&gt; {\n        try {\n            return blockingQueue.take();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }));\n}\n</code></p><p></p><p>这时我们就为它写一个稳定的单元测试了：</p><p></p><p><code lang=\"text\">private void testProducerConsumerInner() {\n    producerConsumerInner(Runnable::run,\n            (Consumer&gt;) producer -&gt; {\n                producer.accept(1);\n                producer.accept(2);\n            },\n            consumer -&gt; {\n                assert consumer.get() == 1;\n                assert consumer.get() == 2;\n            });\n}\n</code></p><p></p><p>只要这个测试能够通过，就能说明生产消费在逻辑上是没有问题的。一个看起来比之前的分段函数复杂很多的逻辑，本质上却只是它定义域上的一个恒等函数（因为只要一个用例就能覆盖全部情况），是不是很惊讶。</p><p></p><p>如果不太喜欢上述的函数式编程风格，可以很容易地将其改造成OOP风格的抽象类，就像上一章提到的，传递对象和传递函数没有本质的区别：</p><p></p><p><code lang=\"text\">public abstract class ProducerConsumer {\n​\n    private final Executor executor;\n​\n    private final BlockingQueue blockingQueue;\n​\n    public ProducerConsumer(Executor executor) {\n        this.executor = executor;\n        this.blockingQueue = new LinkedBlockingQueue&lt;&gt;();\n    }\n    \n    public void start() {\n        executor.execute(this::produce);\n        executor.execute(this::consume);\n    }\n​\n    abstract void produce();\n​\n    abstract void consume();\n​\n    protected void produceInner(T item) {\n        blockingQueue.add(item);\n    }\n​\n    protected T consumeInner() {\n        try {\n            return blockingQueue.take();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}</code></p><p></p><p>​此时单元测试就会像是这个样子：</p><p></p><p><code lang=\"text\">    private void testProducerConsumerAbCls() {\n        new ProducerConsumer(Runnable::run) {\n            @Override\n            void produce() {\n                produceInner(1);\n                produceInner(2);\n            }\n​\n            @Override\n            void consume() {\n                assert consumeInner() == 1;\n                assert consumeInner() == 2;\n            }\n        }.start();\n    }</code></p><p></p><p>看到这些类，熟悉设计模式的读者们一定会想到 “模板方法模式”，但是我们在上面的过程从来没有刻意去用任何设计模式，正确的重构就会让你在无意间 “重新发现” 这些常用的设计模式，一般这种情况下，设计模式的使用都是正确的，因为我们一直在把代码往更加可测试的方向推荐，而这也是衡量设计模式是否使用正确的重要标准，错误的设计模式使用则会让代码更加的割裂和不可测试，后文讨论“过度设计”这个主题时会进一步深入讨论这一部分内容。</p><p></p><p>很显然这种测试无法验证多线程运行的情况，但我故意这么做的，这部分单元测试的主要目的是验证逻辑的正确性，只有先验证逻辑上的正确性，再去测试并发才比较有意义，在逻辑存在问题的情况下就去测试并发，只会让问题隐藏得更深，难以排查。一般开源项目中会有专门的单元测试去测试并发，但是因为其编写代价比较大，运行时间比较长，数量会远少于逻辑测试。</p><p></p><p>经过第一轮重构，主函数变成了这个样子（这里我最终采用了OOP风格）：</p><p></p><p><code lang=\"text\">    public void producerConsumer() {\n        new ProducerConsumer(Executors.newFixedThreadPool(2)) {\n            @Override\n            void produce() {\n                for (int i = 0; i &lt; 10; i++) {\n                    produceInner(i + ThreadLocalRandom.current().nextInt(100));\n                }\n            }\n​\n            @Override\n            void consume() {\n                while (true) {\n                    Integer result = consumeInner();\n                    System.out.println(result);\n                }\n            }\n        }.start();\n    }</code></p><p></p><p>在第一轮重构中，我们仅仅保障了数据传递逻辑是正确的，在第二轮重构中，我们还将进一步扩大可测试的范围。</p><p></p><p></p><h2>3.2 第二轮重构</h2><p></p><p></p><p>代码中影响我们进一步扩大测试范围因素还有两个：</p><p></p><p>随机数生成逻辑打印逻辑</p><p></p><p>只要将这两个逻辑像之前一样抽出来即可：</p><p></p><p><code lang=\"text\">public class NumberProducerConsumer extends ProducerConsumer {\n​\n    private final Supplier numberGenerator;\n​\n    private final Consumer numberConsumer;\n​\n    public NumberProducerConsumer(Executor executor,\n                                  Supplier numberGenerator,\n                                  Consumer numberConsumer) {\n        super(executor);\n        this.numberGenerator = numberGenerator;\n        this.numberConsumer = numberConsumer;\n    }\n​\n    @Override\n    void produce() {\n        for (int i = 0; i &lt; 10; i++) {\n            produceInner(i + numberGenerator.get());\n        }\n    }\n​\n    @Override\n    void consume() {\n        while (true) {\n            Integer result = consumeInner();\n            numberConsumer.accept(result);\n        }\n    }\n}</code></p><p></p><p>这次采用OOP和函数式混编的风格，也可以考虑将numberGenerator和numberConsumer两个方法参数改成抽象方法，这样就是更加纯粹的OOP。</p><p></p><p>它也只需要一个测试用例即可实现完全覆盖：</p><p></p><p><code lang=\"text\">    private void testProducerConsumerInner2() {\n        AtomicInteger expectI = new AtomicInteger();\n        producerConsumerInner2(Runnable::run, () -&gt; 0, i -&gt; {\n            assert i == expectI.getAndIncrement();\n        });\n        assert expectI.get() == 10;\n    }</code></p><p></p><p>此时主函数变成：</p><p></p><p><code lang=\"text\">    public void producerConsumer() {\n        new NumberProducerConsumer(Executors.newFixedThreadPool(2),\n                () -&gt; ThreadLocalRandom.current().nextInt(100),\n                System.out::println).start();\n    }</code></p><p></p><p>经过两轮重构，我们将一个很随意的面条代码重构成了很优雅的结构，除了更加可测试外，代码也更加简洁抽象，可复用，这些都是面向单测重构所带来的附加好处。</p><p></p><p>你可能会注意到，即使经过了两轮重构，我们依旧不会直接对主函数producerConsumer进行测试，而只是无限接近覆盖里面的全部逻辑，因为我认为它不在“测试的边界”内，我更倾向于用集成测试去测试它，集成测试则不在本篇文章讨论的范围内。下一章则重点讨论测试边界的问题。</p><p></p><p></p><h1>四、单元测试的边界</h1><p></p><p></p><p>边界内的代码都是单元测试可以有效覆盖到的代码，而边界外的代码则是没有单元测试保障的。</p><p></p><p>上一章所描述的重构过程本质上就是一个在探索中不断扩大测试边界的过程。但是单元测试的边界是不可能无限扩大的，因为实际的工程中必然有大量的不可测试部分，比如 RPC 调用，发消息，根据当前时间做计算等等，它们必然得在某个地方传入测试边界，而这一部分就是不可测试的。</p><p></p><p>理想的测试边界应该是这样的，系统中所有核心复杂的逻辑全部包含在了边界内部，然后边界外都是不包含逻辑的，非常简单的代码，比如就是一行接口调用。这样任何对于系统的改动都可以在单元测试中就得到快速且充分的验证，集成测试时只需要简单测试下即可，如果出现问题，一定是对外部接口的理解有误，而不是系统内部改错了。</p><p></p><p>清晰的单元测试边界划分有利于构建更加稳定的系统核心代码，因为我们在推进测试边界的过程中会不断地将副作用从核心代码中剥离出去，最终会得到一个完整且可测试的核心，就如同下图的对比一样：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/3c/3c38df74a4ea5f59855355f732c871fd.png\" /></p><p></p><p></p><h1>五、重构的工作流</h1><p></p><p></p><p>好代码从来都不是一蹴而就的，都是先写一个大概，然后逐渐迭代和重构的，从这个角度来说，重构别人的代码和写新代码没有很大的区别。</p><p></p><p>从上面的内容中，我们可以总结出一个简单的重构工作流：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/89/898a2d8189b026668190b1f5a7ce84e2.png\" /></p><p></p><p>按照这个方法，就能够逐步迭代出一套优雅且可测试的代码，即使因为时间问题没有迭代到理想的测试边界，也会拥有一套大部分可测试的代码，后人可以在前人用例的基础上，继续扩大测试边界。</p><p></p><p></p><h1>六、过度设计</h1><p></p><p></p><p>最后再谈一谈过度设计的问题。</p><p></p><p>按照本文的方法是不可能出现过度设计的问题，过度设计一般发生在为了设计而设计，生搬硬套设计模式的场合，但是本文的所有设计都有一个明确的目的--提升代码的“可测试性”，所有的技巧都是在过程中无意使用的，不存在生硬的问题。</p><p></p><p>而且过度设计会导致“可测试性”变差，过度设计的代码常常是把自己的核心逻辑都给抽象掉了，导致单元测试无处可测。如果发现一段代码“写得很简洁，很抽象，但是就是不好写单元测试”，那么大概率是被过度设计了。</p><p></p><p>另外一种过度设计是因为过度依赖框架而无意中导致的，Java往往习惯于将自己的设计耦合进Spring框架中，比如将一段完整的逻辑拆分到几个Spring Bean中，而不是使用普通的Java类，导致根本就无法在不启动容器的情况下进行完整的测试，最后只能写一堆无效的测试提升“覆盖率”。这也是很多人抱怨“单元测试没有用”的原因。</p><p></p><p></p><h1>七、和TDD的区别</h1><p></p><p></p><p>本文到这里都还没有提及到TDD，但是上文中阐述的内容肯定让不少读者想到了这个名词，TDD是 “测试驱动开发” 的简写，它强调在代码编写之前先写用例，包括三个步骤：</p><p></p><p>红灯：写用例，运行，无法通过用例绿灯：用最快最脏的代码让测试通过重构：将代码重构得更加优雅</p><p></p><p>在开发过程中不断地重复这三个步骤。</p><p></p><p>但是会实践中会发现，在繁忙的业务开发中想要先写测试用例是很困难的，可能会有以下原因：</p><p></p><p>代码结构尚未完全确定，出入口尚未明确，即使提前写了单元测试，后面大概率也要修改产品一句话需求，外加对系统不够熟悉，用例很难在开发之前写好</p><p></p><p>因此本文的工作流将顺序做了一些调整，先写代码，然后再不断地重构代码适配单元测试，扩大系统的测试边界。</p><p></p><p>不过从更广义的TDD思想上来说，这篇文章的总体思路和TDD是差不多的，或者标题也可以改叫做 “TDD 实践”。</p><p></p><p></p><h1>八、业务实例 - 导出系统重构</h1><p></p><p></p><p>钉钉审批的导出系统是一个专门负责将审批单批量导出成Excel的系统：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b0/b0342aa6bddaf43209f6573ecd33a515.png\" /></p><p></p><p>大概步骤如下：</p><p></p><p>启动一个线程，在内存中异步生成Excel上传Excel到钉盘/oss发消息给用户</p><p></p><p>钉钉审批导出系统比常规导出系统要更加复杂一些，因为它的表单结构并不是固定的。而用户可以通过设计器灵活配置：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/c8/c8acdfc76a2a2facfa6f608bfb154229.png\" /></p><p></p><p>从上面可以看出单个审批单还具有复杂的内部结构，比如明细，关联表单等等，而且还能相互嵌套，因此逻辑很十分复杂。</p><p></p><p>接手导出系统的时候，已经维护两年了，没有任何测试用例，代码中导出都是类似patchXxx的方法，可见在两年的岁月中，被打了不少补丁。系统虽然总体能用，但是有很多小bug，基本上遇到边界情况就会出现一个bug（边界情况比如明细里只有一个控件，明细里有关联表单，而关联表单里又有明细等等）。代码完全不可测试，完成的逻辑被Spring Bean隔离成一小块一小块，就像下图一样：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/4d/4d07f947d4d4f21e68bd86428265a047.png\" /></p><p></p><p>于是我决定用本文的工作流对代码进行重新梳理。</p><p></p><p></p><h2>8.1 确定测试边界</h2><p></p><p></p><p>首先需要确定哪些部分是单元测试可以覆盖到的，哪些部分是不需要覆盖到的，靠集成测试保证的。</p><p></p><p>经过分析，我认为导出系统的核心功能，就是根据表单配置和表单数据生成excel文件：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/6a/6a71a29aafadf740173d1de90fbea4eb.png\" /></p><p></p><p>这部分也是最核心，逻辑也最复杂的部分，因此我将这一部分作为我的测试边界，而其他部分，比如上传，发工作通知消息等放在边界之外：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/55/556babcedc4028db0ecaf0fe70c816da.png\" /></p><p></p><p>图中 “表单配置” 是一个数据，而 “表单数据” 其实是一个函数，因为导出过程中会不断批量分页地去查询数据。</p><p></p><p></p><h2>8.2 不断迭代，扩大测试边界到理想状态</h2><p></p><p></p><p>迭代的过程如下：</p><p></p><p>异步执行导致不可测试：抽出一个同步的函数；大量使用Spring Bean导致逻辑割裂：将逻辑放到普通的Java类或者静态方法中；表单数据，流程与用户的相关信息查询是远程调用，含有副作用：通过高阶函数将这些副作用抽出去；导入状态落入数据库，也是一个副作用：同样通过高阶函数将其抽象出去；</p><p></p><p>最终导出的测试边界大约是这个样子：</p><p></p><p><code lang=\"text\">public byte[] export(FormConfig config, DataService dataService, ExportStatusStore statusStore) {\n    //... 省略具体逻辑, 其中包括所有可测试的逻辑, 包括表单数据转换，excel 生成\n}</code></p><p></p><p>config：数据，表单配置信息，含有哪些控件，以及控件的配置dataService: 函数，用于批量分页查询表单数据的副作用statusStore: 函数，用于变更和持久化导出的状态的副作用</p><p></p><p><code lang=\"text\">public interface ExportStatusStore {\n​\n    /**\n     * 将状态切换为 RUNNING\n     */\n    void runningStatus();\n​\n    /**\n     * 将状态置为 finish\n     * @param fileId 文件 id\n     */\n    void finishStatus(Long fileId);\n​\n    /**\n     * 将状态置为 error\n     * @param errMsg 错误信息\n     */\n    void errorStatus(String errMsg);\n    \n}</code></p><p></p><p>在本地即可验证生成的Excel文件是否正确（代码经过简化）：</p><p></p><p><code lang=\"text\">    public void testExport() {\n        //  这里的 export 就是刚刚展示的导出测试边界\n        byte[] excelBytes = export(new FormConfig(), new LocalDataService(),\n                new LocalStatusStore());\n        assertExcelContent(excelBytes, Arrays.asList(\n                Arrays.asList(\"序号\", \"表格\", \"表格\", \"表格\", \"创建时间\", \"创建者\"),\n                Arrays.asList(\"序号\", \"物品编号\", \"物品名称\", \"xxx\", \"创建时间\", \"创建者\"),\n                Arrays.asList(\"1\", \"22\", \"火车\", \"而非\", \"2020-10-11 00:00:00\", \"悬衡\")\n        ));\n    }</code></p><p></p><p>其中LocalDataService，LocalStatusStore分别是内存中的数据服务，和状态变更服务实现，用于进行单元测试。assertExcelContent是我用poi写的一个工具方法，用于测试内存中的excel文件是否符合预期。所有边界的用例都可以直接在本地测试和沉淀用例。</p><p></p><p>最终的代码结构大约如下（经过简化）：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ea/ea8e1f7abb477a1c0051c05462faafa5.png\" /></p><p></p><p>虽然到现在为止我的目的都是提升代码的可测试性，但是实际上我一不小心也提升了代码的拓展性，在完全没有相关产品需求的情况下：</p><p></p><p>通过DataService的抽象，系统可以支持多种数据源导出，比如来自搜索，或者来自db的，只要传入不同的DataService实现即可，完全不需要改动和性逻辑；ExportStatusStore的抽象，让系统有能力使用不同的状态存储，虽然目前使用的是db，但是也可以在不改核心逻辑的情况下轻松切换成tair等其他中间件；</p><p></p><p>果然在重构后不久，就接到了类似的需求，比如要支持从不同的数据源导出。我们又新增了一个导出入口，这个导出状态是存储在不同的表中。每次我都暗自窃喜，其实这些我早就从架构上准备好了。</p><p></p><p></p><h1>九、单元测试的局限性</h1><p></p><p></p><p>虽然本文是一篇单元测试布道文章，前文也将单元测试说得“神通广大”，但是也不得不承认单元测试无法解决全部的问题。</p><p></p><p>单元测试仅仅能保证应该的代码逻辑是正确的，但是应用开发中还有很多更加要紧的事情，比如架构设计，中间件选型等等，很多系统bug可能不是因为代码逻辑，而是因为架构设计导致的，此时单元测试就无法解决。因此要彻底保障系统的稳健，还是需要从单元测试，架构治理，技术选项等多个方面入手。</p><p></p><p>另外一点也不得不承认，单元测试是有一定成本的，一套工作流完成的话，可能会有数倍于原代码量的单元测试，因此并不是所有代码都需要这样的重构，在时间有限的情况下，应该优先重构系统中核心的稳定的代码，在权衡好成本与价值的情况下，再开始动手。</p><p></p><p>最后，单元测试也是对人有强依赖的技术，侧重于前期预防，没有任何办法量化一个人单元测试的质量如何，效果如何，这一切都是出于工程自己内心的“工匠精神” 以及对代码的敬畏，相信读到最后的你，也一定有着一颗工匠的心吧。</p>",
    "publish_time": "2023-04-27 11:40:35",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "打通企业数字化转型“最后一公里”，是时候了解应用现代化了",
    "url": "https://www.infoq.cn/article/0BmB0RRsZHy7WrcRm2mu",
    "summary": "<p>2007 年，在 IBM Rational 软件开发高峰论坛 SOA 专场中，“应用现代化”概念首度亮相，其核心理念是解决应用开发过程中的遗留问题。近年来，随着各行业数字化转型进程加快，云计算提供的弹性、可扩展等特性对应用现代化服务市场的增长推动作用日趋明显，应用现代化已经成为产业共识。但从现实情况来看，我国企业的应用现代化进程尚处于起步阶段，企业在这一领域大多面临着认知、实践等方面的挑战。</p><p>&nbsp;</p><p>作为最早在国内提出应用现代化建设思路的厂商，华为云早在2021 年就与中国信息通信研究院联合发布了《企业应用现代化白皮书》。白皮书指出，应用现代化是以软件的敏捷交付为导向，实现贯穿基础设施到应用的认知重塑、架构升级和技术跃迁，同时提炼出了应用现代化的典型特征和建设维度。</p><p>&nbsp;</p><p>4 月 26 日，第六届数字中国建设峰会期间，华为云官宣面向政企的三大关键举措：发布央国企15 大场景化解决方案，公布“<a href=\"https://xie.infoq.cn/article/659c95ef0f9a690f01d55e772\">应用现代化产业联盟</a>\"”最新进展并进行招募，发起“‘百城万企’应用现代化中国行”行动。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/3e/3e2fc1677762e88cb389e2e903a7fcea.png\" /></p><p></p><p>我们不禁好奇，华为云如何看待应用现代化的发展趋势、又是如何布局的？应用现代化发展的助推因素有哪些、又是如何打通企业数字化转型“最后一公里”的？围绕这些问题，InfoQ 与华为云战略与产业发展部总裁黄瑾、华为云 PaaS 服务产品部部长徐峰以及中国软件行业协会常务副秘书长陈宝国进行了深入探讨，以期为行业带来新的理解和启发。</p><p></p><h2>应用现代化：企业数字化转型的必经之路</h2><p></p><p>&nbsp;</p><p>所谓应用现代化，通俗地来讲就是基于一系列的先进技术，让企业的应用成为“六边形全能战士”，在体验、效能、智能、韧性、安全、成本这六大维度上获得最优表现，只要能满足这个标准的应用都可以称为现代化应用。</p><p>&nbsp;</p><p>应用现代化的概念与当下火热的数字化转型浪潮密不可分。陈宝国谈到，企业<a href=\"https://www.infoq.cn/article/F0X46ljkHXGulW9TNEb2\">数字化转型</a>\"的本质是把业务能力变成“应用、数据和算法”，将“业务资产”变成“数字资产”，再让数字资产结合数字技术，提升客户的体验和服务客户的效率，以快速应对各种变化。</p><p>&nbsp;</p><p>但在这一过程中，传统应用所使用的技术架构已经无法支持企业数字化业务的高质量增长。一方面，企业新应用数量爆炸式增长，传统企业应用开发和交付的效率难以跟上节奏，投入成本却在快速膨胀。据 Gartner 调查，2025 年传统应用会占到企业 IT 预算的 40%以上，严重影响企业创新速度；另一方面，企业应用中开源代码占比快速增长，导致软件供应链攻击威胁日趋严重；最后，传统企业应用以单体为主的架构设计在性能、可靠性等指标上很难满足新时代的企业要求。</p><p>&nbsp;</p><p>传统企业应用面临的这些挑战，需要通过应用现代化的升级来加速解决。现代化应用的TTM（Time to Market）可以缩短到数天，能够通过数智驱动帮助企业实现智能化决策和运营。现代化应用还具备全生命周期安全性、高可靠、高韧性，能够带来跨终端的无缝使用体验，并通过弹性实现成本最优。应用现代化能够通过搬迁、改造、重构、新建、替换等途径，将传统应用升级为极致体验、高效智能、安全可靠的现代化应用，实现业务敏捷和高效创新。</p><p>&nbsp;</p><p>基于应用现代化对于企业、产业发展的重要作用，企业应用现代化已经箭在弦上，势在必行。行业普遍认同，应用现代化是企业数字化转型的必经之路。但就实际情况而言，不同行业、不同公司的应用各不相同，其应用现代化的路径也并非唯一，尤其在国内应用现代化还处在发展初期的阶段，企业还面临着很多亟需解决的挑战。</p><p></p><h2>企业应用现代化之路面临的焦点问题</h2><p></p><p>&nbsp;</p><p>如果将企业应用现代化的过程拆分，简单来说有两个焦点问题：第一是要不要做，第二是怎么做。</p><p>&nbsp;</p><p>关于第一个讨论的焦点，企业需要根据其自身的业务挑战、诉求和目标进行决策。徐峰表示：“如果企业存在如下挑战是可以重点考虑开展应用现代化，例如，数字化业务体验不佳，员工和客户不满意；应用交付的时间周期长，无法匹配业务的诉求；应用安全、可靠性、韧性等方面存在挑战，经常出现宕机、泄露、被攻击等情况；空有一堆的数据，但是数据无法流动，AI 和算法无从下手等问题。同时，也要结合自身的能力和预算投资综合考虑如何开展应用现代化。”</p><p>&nbsp;</p><p>关于第二个焦点问题，企业则需要根据自身业务发展诉求进行推进。黄瑾认为，企业在推进应用现代化的过程中首先要有整体规划，应用现代化工作要与公司数字化战略相结合；其次要有组织保障，在公司层面设立数字化规划和建设委员会与项目组，确保应用现代化工作的规划和落地资源；第三要有优秀伙伴的支撑，包括咨询，业务应用，开发实施，云平台等。在具体的实施过程中，企业可以按照现状分析、实施规划、策略制定、项目实施、评估和改进五大步骤来顺利完成应用现代化的目标。&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/9a/9a280fba7712dcf32eef85ad79c09c42.png\" /></p><p></p><p>与此同时，企业在应用现代化的实施过程中，也面临着多个维度的挑战，华为云总结国内企业主要面临的问题有：企业普遍对应用现代化的概念还不太了解；企业对于自身传统应用的缺陷还未展开全面评估和分析，不知如何下手；企业对于层出不穷的新技术感到迷茫，不知该如何选择和引入；企业未从顶层统筹规划应用现代化，导致各个部门分而治之。</p><p>&nbsp;</p><p>针对上述挑战，华为云推荐的关键举措是：企业要自顶向下进行应用现代化的顶层设计，统一企业内的认识，对于现代化的目标达成一致，成立专项工作组或项目来推动应用现代化在企业内的推行。</p><p></p><h2>“极致”企业应用现代化体验是如何构建的？</h2><p></p><p>&nbsp;</p><p>当企业下定决心开始应用现代化之路，接下来要面对的挑战就是：如何构建极致的企业应用现代化体验？针对这一问题，华为云给出了自己的答案。</p><p>&nbsp;</p><p>各行各业的应用各不相同，应用所采用的技术栈和所承载的企业业务也不尽相同。对企业而言，要打造现代化的应用体验，关键是结合业界的现代化应用标准，结合企业自身的业务和能力，评估自身现有应用，制定自身企业的应用现代化的升级改造策略和目标；企业开发者则需要增强学习能力，不断掌握新技术和开发方法，持续将新技术运用到企业应用开发中。总体而言，应用现代化的构建包含制定标准、评估现状、持续学习和实践几大部分。针对这些环节，华为云都给出了对应的解决方案，帮助企业快速实现应用现代化改造。</p><p>&nbsp;</p><p>首先，华为云最早在国内提出应用现代化的建设思路，2021 年华为云联合信通院发布了《企业应用现代化白皮书》，完整阐述了应用现代化的趋势、定义、关键理念和技术等。同时，华为流程&nbsp;IT 部门通过实践经验总结发布了内部的现代化应用标准，围绕业务感知、DFX 以及开发部署三个方面展开，并从按需订阅、智能和体验、可组合&amp;可扩展、高可用&amp;弹性、可观测&amp;可运维、安全合规、敏捷开发和多云部署 8 个方面的标准来评判应用是否达到现代化标准。华为云还对服务的政企客户的应用进行了深入的调研分析，最终提炼了实现传统应用到现代化应用的 6 大关键技术，分别是组装式交付、数智驱动，<a href=\"https://xie.infoq.cn/article/08f31e56a29f926dd3190cbe9\">DevOps</a>\"，服务化架构，安全可信，韧性。</p><p>&nbsp;</p><p>其次，华为云基于自身数字化转型的经验和能力，面向政企客户提供了完整的应用现代化解决方案，除了关键技术产品，还有咨询、优秀实践、专业服务等，帮助企业快速评估现状、制定转型升级方案，加速实现应用现代化。华为全联接大会 2022 期间，华为还发布了应用现代化的六大使能关键技术，使能业界共同推进应用现代化。</p><p>&nbsp;</p><p>更为重要的是，华为云将华为30 多年在 ICT 领域的技术积累和产品解决方案开放，为客户、伙伴和开发者提供稳定可靠、安全可信、可持续发展的云服务。凭借基础设施即服务、技术即服务和经验即服务，华为云应用现代化基于云原生、AI、Serverless 等技术，通过搬迁、改造、重构等途径，帮助企业对传统应用进行升级，打造极致体验、智能高效、安全可靠的新型应用，实现业务敏捷和高效创新，释放企业的数字生产力，成就高质量增长的现代化企业。</p><p>&nbsp;</p><p>通过这些产品、服务和创新技术，华为云最终可以为企业带来应用现代化的一系列可见成果：</p><p>&nbsp;</p><p>大幅提升用户体验和业务支持水平：升级后的现代化应用面对业务流量和突发环境的弹性和响应更快，应用运行的环境有全生命周期的安全保证，用户使用体验更流畅，应用对于企业数字化业务的支撑水平也得到进一步提升，整体提升企业业绩和企业在市场的竞争力；优化传统应用对企业预算的消耗占比，拥抱创新：根据咨询机构采访统计，应用现代化可以节省传统应用25%~30%的维护成本，通过应用现代化的过程，企业也会对众多的应用资产进行精简盘点，主动采取“关停并转”的措施，改善冗余，减少重复建设，优化成本，提升企业的盈利能力；更快速的价值实现，提升企业效能：使用DevOps 等新的研发模式，现代化应用的发布频次提供 2~3 倍，质量检查、安全审计内嵌在应用生产线中，质量和漏洞风险相比传统开发模式会降低 60%以上。</p><p></p><h2>写在最后</h2><p></p><p>&nbsp;</p><p>如今，应用现代化已经成为企业数字化转型过程中的必由之路，也是走向现代化企业的重要抓手和底层实现。应用现代化成为趋势的同时，也面临着多重挑战，这对云厂商们提出了更为具体的要求，作为国内应用现代化服务的先行者，华为云进行了多年的布局，并已落地了广泛实践。</p><p>&nbsp;</p><p>未来，华为云还会给应用现代化带来哪些理论、技术和实践的创新？我们相信，华为云与其他行业伙伴的努力最终将结出硕果，不仅能够加快中国企业的数字化转型步伐，还将为中国软件业在全球市场的崛起提供有力支撑。</p>",
    "publish_time": "2023-04-27 15:11:14",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "十年架构重构，为多端统一，QQ选用了 Electron",
    "url": "https://www.infoq.cn/article/PzQfDeSeXzhIacxzVSc9",
    "summary": "<p>根据百度百科消息，2023年4月23日，新版 Windows QQ 正式开启用户公测，采用全新 QQ NT 架构，并带来了全新交互界面。</p><p>&nbsp;</p><p>去年，随着QQ for macOS 的更新，QQ全新的NT技术架构走进大众视野。腾讯表示，QQ 将使用全新的QQ NT技术，对QQ底层代码进行一次全方位重构。</p><p>&nbsp;</p><p>去年12月，QQ for Linux 3.0正式版上架QQ官网，Linux用户可以直接下载进行尝试。该版本采用了全新的QQ NT技术架构，并可支持 x64 系统以及 arm64 系统，还主要针对系统外观、效率提升、生活娱乐等方面功能进行提升和拓展。QQ for Linux 版本更新很慢，1.0版本在2008年推出，2.0版本则在十多年后的2019年推出。3.0版本的推出相对来说算是很快的了。今年4月7日，腾讯 Windows QQ 全新架构版开启灰度内测，本次需要登录资格，没有报名 Windows QQ 测试计划的无法登录。</p><p>&nbsp;</p><p>目前，基于QQ NT 架构，这是QQ首次对Windows/Mac/Linux三个平台做架构统一，实现了三个平台一套代码、多端运行，三个平台的版本在外观、操作和性能上一致，提高了用户在操作方面的体验。</p><p>&nbsp;</p><p></p><h2>为多端统一，QQ 选择 Electron</h2><p></p><p>&nbsp;</p><p>QQ 的架构设计源于1998年，经过二十四年的发展，其架构也经历了无数次的迭代和重构。有网友表示，如今QQ 的 Windows 版本就是2009年重构基础上“缝缝补补”建立起来的。</p><p>&nbsp;</p><p>一直以来，QQ 最大的问题是无法跨平台。Windows方面，QQ 最早用的是 MFC，后来也用了DirectUI、WPF等，这些能力只能用在Windows平台上。Linux和Mac端必须使用其他技术，比如 Qt。从过往更新历史中也可以看出，三个平台的更新迭代节奏完全不同。</p><p>&nbsp;</p><p>因此，对QQ 开发团队来说，代码的复用并能保持三端用户体验一致就变得很重要。如今，QQ 凭借 NT架构实现了QQ架构的统一。而QQ NT 技术的一个重点就是使用Electron作为新版QQ桌面端UI跨平台解决方案。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/59/59bb294dbb748087fe1d464bdc94fef8.png\" /></p><p></p><p>图片来源：<a href=\"https://www.zhihu.com/question/570447541/answer/2791939780\">https://www.zhihu.com/question/570447541/answer/2791939780</a>\"</p><p>&nbsp;</p><p>Electron是使用JavaScript，HTML和CSS构建跨平台的桌面应用程序框架，基于 Chromium 和 Node.js，兼容Mac、Windows和Linux。</p><p>&nbsp;</p><p>但是，不同系统间还是会有很大的差异，需要相应地做一些额外处理，使得打包出的应用在不同系统下都能正常运转。QQ 开发团队就在Electron基础上做了大量优化。比如，针对Electron“占内存”的问题，QQ根据不同的使用场景，在Electron与N用 Electron 开发多平台客户端的成本相对低很多。相比于大多数都能完全复用的代码，针对性优化成本可以忽略不计。</p><p>&nbsp;</p><p>而且，Electron 基于 Node.js意味着，Node 大生态下的模块，Electron 都可以用。同时，跨平台也让 Electron 可同时开发 Web 应用和桌面应用，无论是 UI还是代码，很多资源都可以共享，大幅减少了开发者的工作量。QQ开发团队都可以享受到这样的便捷。</p><p>&nbsp;</p><p>多端统一的需求不只是QQ有。2017年，<a href=\"https://www.infoq.cn/article/2017/05/github-electron-desktop-client\">GitHub</a>\" 已经使用Electron 重写了macOS 和Windows 的客户端。</p><p>&nbsp;</p><p>负责重写应用的团队<a href=\"https://githubengineering.com/how-four-native-developers-wrote-an-electron-app/\">解释</a>\"道，重新构建 GitHub 桌面客户端的主要原因是为了减少支持多平台开发所耗费的成本。实际上，分别为 Windows 和 macOS 开发原生应用要求使用两种不同的技术栈，也就是说，每个功能特性都需要重复实现、调试和维护。如果需要支持第三个平台，如 Linux，那么还需要投入额外的精力。这跟QQ面临的情况相似。</p><p>&nbsp;</p><p></p><h2>太吃内存，微软抛弃 Electron 7</h2><p></p><p>&nbsp;</p><p>有人选择Electron，还有人在抛弃。</p><p>&nbsp;</p><p>今年4月初，<a href=\"https://www.infoq.cn/article/uHD15zM6RUaMUPWq6rlf\">微软宣</a>\"布以公共预览版的形式，在 Win10 / Win11 系统上推出新版 Microsoft Teams 应用程序。微软协作应用程序和平台总裁 Jeff Teper 表示，新版应用的设计核心是速度和易用性，“我们围绕着速度、性能、灵活性和智能，重新构建了 Teams 应用。运行速度提高了 2 倍，同时使用的内存减少 50%。”</p><p>&nbsp;</p><p>功能增强的一个重要原因是该应用程序从 Electron 过渡到了 Microsoft 的 Edge WebView 2 渲染引擎。要知道，微软从使用到放弃 Electron，前后也没有四年。</p><p>&nbsp;</p><p>“2015 年，我们开始开发 Teams 时选择 Electron 等框架，使跨平台 Web 和桌面客户端的快速交付成为可能。”该公司工程副总裁 Sumi Singh 解释道，“然而，Teams 的功能不断扩展给设备资源带来了压力。”</p><p>&nbsp;</p><p>此前，Teams 被公认为是内存大户。Office 365 MVP Tony Redmond 曾做过一次测试，下图显示了 Windows 任务管理器报告，加载到 Edge Chromium 的浏览器客户端占用了 775 MB，而组成 Teams 桌面客户端的进程需要 887 MB。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/dc/dc147b6f2cda4a27ff44bc6bc6c0bb0a.png\" /></p><p></p><p>&nbsp;</p><p>过去，微软尝试了许多不同的技术来减少桌面客户端对内存的需求。但似乎向前迈出的一大步是2021年时Teams 2.0 从 Electron 转向使用 Edge WebView2。</p><p>&nbsp;</p><p>Edge WebView2 控件允许用户在原生应用程序中嵌入 Web 技术（HTML、CSS 和 JavaScript），Web 代码可以被嵌入到原生应用的不同部分，也可以在单个 WebView2 实例中构建所有本机应用。</p><p>&nbsp;</p><p>根据 Teams 工程师 Rish Tandon 在推特上的分享，Teams 2.0 从 Electron 转向 Edge WebView2，大概花费了 Teams 团队 6 个月的时间，优化后的 Teams 2.0 消耗的内存将只有 Teams 1.0 上相同帐户的一半。</p><p>&nbsp;</p><p>今年的新版本Teams 发布时，微软称邀请了第三方基准测试公司 GigaOm在三台不同的机器（低端、通用和高性能）上测试了新旧 Teams 的性能，新版本性能明显更为优异：</p><p>&nbsp;</p><p>启动应用程序的速度提高 2 倍加入会议的速度提高 2 倍切换聊天/频道的速度提高了 1.7 倍消耗的内存最多减少 50%占用的磁盘空间最多减少 70%</p><p></p><p></p><h2>该如何选择跨平台框架</h2><p></p><p>&nbsp;</p><p>虽然多端统一带来很多便利，但跨平台框架并非万能。“跨平台意味着需要花费很多时间来解决平台差异性问题，同时要面临第三方库不够原生平台丰富健壮的现状。跨平台其实是牺牲部分功能和体验，换取开发速度和一致性的权衡，并不是业务开发的银弹。”腾讯微信客户端工程师方秋枋曾说道。</p><p>&nbsp;</p><p>目前，并没有一个能完善解决这些问题的解决方案。事实上，GitHub 重写应用的团队也曾表示，Web 并非完美的平台，不过原生应用也不是。使用 Electron 重写原生应用只不过是在不同的权衡点之间进行了交换。</p><p>&nbsp;</p><p>方秋枋认为，从框架开发者的角度，跨平台开发的难点就在于处理平台差异性。从框架使用者的角度，难点在于如果框架出问题了，维护成本将会变得非常高。</p><p>&nbsp;</p><p>那么，企业如何选择适合自己的跨平台开发框架？</p><p>&nbsp;</p><p>阿里巴巴淘系技术部资深无线技术专家黄刚（花名：腾渊）曾分享道，从应用的 Life Cycle 来看，研发阶段只是其中一个阶段，是否具有长久的可维护性、可运维性也是需要重点考虑的问题。</p><p>&nbsp;</p><p>腾渊表示，如果在当下的业务形态里，前台展现是高度产品化、比较稳定或者对于性能以及交互的要求极度苛刻的，那么 Cross-Platform First 未必是一个理想的选择。一方面，多平台开发工作在整个研发成本里的占比不高，ROI 未必高；另一方面是 Cross-Platform First 是以牺牲平台特性为代价来达到跨平台的一致性。在达到一致性表现的过程中，工程上的填坑成本可能更高。</p><p>&nbsp;</p><p>反过来讲，如果当前的业务，前台的呈现比较不稳定并且整个前台开发占比较高，那么应用跨平台框架的收益就比较高了。</p><p>&nbsp;</p><p>腾渊认为，从 Hybrid 的方案到 React Native、Weex 再到 Flutter，本质上都是在研发成本、灵活性、性能体验三者间找一个平衡点，只是大家切入的点不太一样，最终导致整个解决方案有了不同。</p><p>&nbsp;</p><p>“假设现在你要做一个新的 App，可能整个开发团队是多前端、少客户端的，那我可能比较建议考虑 Hybrid 的模式；如果对性能要求比较高，可以考虑 Weex 或者 React Native；反过来，如果是客户端同学比较多，那么考虑下 Flutter 未尝不可。”腾渊说道。</p><p>&nbsp;</p><p>&nbsp;</p><p>参考链接：</p><p>&nbsp;</p><p><a href=\"https://www.infoq.cn/article/uHD15zM6RUaMUPWq6rlf\">https://www.infoq.cn/article/uHD15zM6RUaMUPWq6rlf</a>\"</p><p><a href=\"https://www.infoq.cn/article/SlBQ288e063_N2FdxkOe\">https://www.infoq.cn/article/SlBQ288e063_N2FdxkOe</a>\"</p><p><a href=\"https://office365itpros.com/2020/07/22/teams-memory-management/\">https://office365itpros.com/2020/07/22/teams-memory-management/</a>\"</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651024593&amp;idx=4&amp;sn=d0864208f132b5bbfea986fe81c6fa43&amp;chksm=bdbe94828ac91d943162230f6b869473100955472300610d7efdadeaa28fe696ab2f3bc5fa05&amp;scene=27#wechat_redirect\">https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651024593&amp;idx=4&amp;sn=d0864208f132b5bbfea986fe81c6fa43&amp;chksm=bdbe94828ac91d943162230f6b869473100955472300610d7efdadeaa28fe696ab2f3bc5fa05&amp;scene=27#wechat_redirect</a>\"</p>",
    "publish_time": "2023-04-27 15:40:59",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "应用为核心的研发资产和流程管理｜ BizDevOps 公开课",
    "url": "https://www.infoq.cn/article/GRkwCxN5mwIVTbmRAUXj",
    "summary": "<p><strong>内容简介：</strong><br />\nBizDevOps最新权威解读课程，由BizDevOps共促计划专家团成员共同创作，包括《必致（BizDevOps）白皮书》解读共 10 讲，阿里巴巴、招商银行、Thoughtworks等企业真实实践案例分享，以及需求管理、组织设计、组织数字化升级、数据运营和工具等设计专题精讲。</p>\n<p>白皮书下载链接：<a href=\"https://www.infoq.cn/minibook/lsB8GB2BbvLQj2u5mBKo\">https://www.infoq.cn/minibook/lsB8GB2BbvLQj2u5mBKo</a></p>\n<p><strong>你将理解：</strong></p>\n<ol>\n<li>如何应用BizDevOps，为数字化的业务打造数字化的组织</li>\n<li>理解BizDevOps的1个目标，3个能力和5个实践</li>\n<li>BizDevOps与DevOps的根本不同，以及如何实现从DevOps向BizDevOps的蝶变</li>\n<li>你将掌握BizDevOps的1-3-5框架，掌握驾驭数字化变革的力量</li>\n</ol>\n<p><strong>面向受众：</strong><br />\n数字化转型从业者和关注者，包括研发管理者、数字业务和数字化转型负责人、业务分析师等、研发工具负责人</p>\n<p><strong>发布计划：</strong><br />\n3.23日起，每周四下午16:00，准时开播。</p>\n<p><strong>本系列视频内容规划：</strong></p>\n<ol>\n<li>BizDevOps(必致)是什么，如何实施？ 整体框架</li>\n<li>产品导向的团队组织和交付 （实践一） 协作和管理实践</li>\n<li>业务驱动的组织协同机制 （实践二）</li>\n<li>数字业务的动态投资组合管理 （落地和案例）</li>\n<li>应用为核心的研发资产和流程管理（实践三） “工程和技术实践”</li>\n<li>适配业务特征的持续业务交付 （实践四）</li>\n<li>建设和改进持续业务交付能力 （落地和案例）</li>\n<li>全量、全要素和实时数据支持的度量和持续改进（实践五） 度量和持续改进实践</li>\n<li>度量和持续改进体系的设计和应用（落地和案例）</li>\n<li>BizDevOps（必致）：驾驭数字化变革的力量 总结</li>\n</ol>",
    "publish_time": "2023-04-27 16:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "敏捷时代必须终结",
    "url": "https://www.infoq.cn/article/tGmKw5zqR6aRA5bvoNlR",
    "summary": "<p></p><blockquote>30年前，科技行业试图引进精益实践，但以失败而告终。他们没有“持续改进”，而是就此停了下来。敏捷与UX研究、设计和可扩展开发并不相容，而且会一直如此。是时候制定一个新的作业标准了。</blockquote><p></p><p></p><p>本文最初发布于UX Collective。</p><p></p><p>鉴于初创公司重新开始关注“运营效率”，我们需要强调一下，<a href=\"https://uxdesign.cc/operational-efficiency-and-operational-efficacy-defining-designops-metrics-b5a2c8fe40b7\">效率</a>\"是一种工作方式，而不是数人头。</p><p></p><p>毫无疑问，<a href=\"https://archive.org/details/agileprojectmana0000schw\">20多年来</a>\"，敏捷开发一直是科技领域的头号作业原则。然而，它的根本性缺陷也一直对我们虎视眈眈。</p><p></p><p>缺陷1：人不是机器。缺陷2：设计不是库存。缺陷3：产品不能由任意数量的拥有任意技能和经验的人在两周的冲刺中所能完成的工作来定义。</p><p></p><p>让我们回顾一下各个阶段：</p><p></p><p>2001 —— 敏捷1995年 —— Scrum1988年 —— 精益20世纪60年代 —— 丰田生产系统（TPS）</p><p></p><h2>初起</h2><p></p><p></p><p>从20世纪40年代到70年代，<a href=\"https://global.toyota/en/company/vision-and-philosophy/production-system/\">TPS</a>\"经历了几十年的发展，使丰田得以实现并保持其在世界汽车制造商中的主导地位。这个令人印象深刻的早期阶段主要聚焦于消除muda（浪费）、mura（不一致）和muri（负担过重）。</p><p></p><p>关于消除浪费的记录最详尽。在这8种浪费中，危害最大的是库存过剩——包括成品和原材料，以及闲置不用的机器。换句话说，你花钱买的东西没有为你赚钱。本质上，丰田的解决方案是物流方面的，后来被称为“准时生产”。</p><p></p><p></p><blockquote>及时接收材料，以便流水线可以及时处理材料，生产出满足客户需求的成品。“丰田之路”是TPS的一个卓越的合作伙伴。这一理念要求持续改进，包括：克服挑战，实现长期愿景；kaizen（运营创新）；以及我个人最喜欢的现地现物（genchi genbutsu）——意思是“真实的地方，真实的东西”，这个原则是说要“自己去看看”，并据此做出决策。它还鼓励采用自下而上的改进方法，了解每名员工的见解，而不管他们是什么级别。</blockquote><p></p><p></p><p>美国人发挥了它的魔力，把丰田之路变成了他们的Cup Noodles。好吧，也许我这样说并不公平。准时制造在美国本土制造业中得到了很好的应用。1988年，在一篇题为“精益生产系统的胜利”的文章中，它被重新命名为精益——清晰的传承。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/34/34bdb4c5d5ff111d31f7c8dd2dd28239.png\" /></p><p></p><p>精益及其前身非常适合实物产品的制造，特别是当市场已经建立、产品已经成熟时。它依赖于需求和供应链的可预测性。当研发新产品时，制造商则依赖于研发部门的各种流程。无论是基因泰克公司（Genentech）研发合成胰岛素，还是宝洁公司（Proctor &amp; Gamble）研发Swiffer，这都是一个漫长的线性过程。其中包括在产品开发之前进行深入的研究和市场分析。</p><p></p><h2>瀑布成了替罪羊</h2><p></p><p></p><p>在很大程度上，蓬勃发展的软件业遵循了这些流程；在应用于数字产品时，它们被称为<a href=\"https://medium.com/dataseries/will-waterfall-development-ever-die-probably-not-6ab4589e061\">瀑布式</a>\"方法。术语“瀑布”已经成为描述以发布完全实现的产品为终点的线性开发过程的统称。然而，这个又大又昂贵的产品发布可能并没什么用，说实话，人们在这方面的批评是合理的。因此，瀑布被作为证据，用来证明迭代、测试和在更短的时间内对市场做出反应的必要性。</p><p></p><p>20世纪90年代，科技行业的从业者们探索了将精益应用于数字产品的方法。遗憾的是，从一开始，他们就误诊了问题。<a href=\"https://uxdesign.cc/dont-start-with-the-mvp-e2e604e4ebfe\">上市时间</a>\"很重要，但我认为从现金流的角度来看更重要，尤其是对初创公司而言。精益的支持者把婴儿和洗澡水一起倒掉了。请注意，Scrum和敏捷文献很少或根本没有提到研究或战略。在瀑布中，设计这个冗长的阶段被认为是浪费时间。精益框架都是关于构建和发布的。</p><p></p><p>大约是在这个时候，精益开发的支持者和瀑布开发的践行者之间爆发了一场怪兽对机甲的战斗。不管是怪物，还是机器人，它们都没有考虑用户的需求，而是踩着他们毁灭了世界。</p><p></p><p>如下图所示，它们之间的区别在于，敏捷代表一部分，而瀑布代表整体。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e5/e5ecc3d5474c4673377f37af5bfab5ae.png\" /></p><p></p><p>对市场上正在使用的产品进行迭代是软件的专利——更新可以在任何时候推送，而且不需要对流水线和工具做任何改造。每个科技产品都应该分阶段构建，但必须围绕最终目标和完全实现的产品。成功需要战略、<a href=\"https://uxdesign.cc/heres-what-to-do-when-user-research-doesn-t-fit-in-a-sprint-2f8b5db7d48c\">研究</a>\"、设计和现地现物（genchi genbutsu），正如“丰田之路”告诉我们的。敏捷与瀑布之争是一个错误的两分法：公司可以有一个长期的战略，并在执行的同时，增量、迭代地发布产品。</p><p></p><h2>存在长达30年的错误</h2><p></p><p></p><p>当<a href=\"https://uxdesign.cc/where-is-the-beginning-and-the-end-of-the-product-owners-responsibilities-1dc4b67f7dea\">产品负责人</a>\"和工程师试图将精益生产原则应用于软件开发时，他们找到了模仿流水线的方法。及时确定需求，然后跨职能团队冲刺发布可工作的软件。Scrum这个词是一个明智的选择——它源于橄榄球比赛，在这项运动中，一排小伙子在球场上穿梭并来回抛球。软件开发方法具有同等的技巧和策略。</p><p></p><p>所有人都得和Scrum打交道，原因如下：</p><p></p><p>必须限定到冲刺（Sprint）中，以确保软件可以按“迭代”周期投放市场。“冲刺计划”要在“冲刺”开始前进行，因为那时你可以及时获得所关注事项的最新见解。每天举行站会，“即时”开展运营改进。（开发者只能发言，不能讨论，因为那比较浪费时间。）在冲刺结束的时候，会对可工作的软件做一次评审，看看哪些没有完成，哪些需要改进。还有一次回顾，讨论哪些工作进展顺利，哪些工作进展不顺利，以期增加产出。待办事项（Backlog）并不是Scrum实践的核心，它产生于冲刺的副作用以及这个过程中产生的一些零碎的事项。可以看到，Scrum已经相当不合逻辑了，但它还会变得更糟。</p><p></p><p>Scrum的部分创建者和其他精益开发从业者一起制定了*《敏捷软件开发宣言》*。这个具有马克思主义色彩的标题很可能是有意为之：他们声称工人将拥有生产资料。</p><p></p><h2>敏捷（脆弱）宣言</h2><p></p><p></p><p>就宣言而言，这是有史以来<a href=\"http://agilemanifesto.org/\">最可悲的文件</a>\"之一。敏捷宣言给出了4个“价值观”和12项“原则”。它的初衷可能是好的——将开发人员看作是人，而不是机器上的齿轮——但现在，我们已经回到原点。这些原则已经演变成腐蚀组织的东西。现在看来，它们是敏捷团队如何免除责任这个主题的变体。</p><p></p><p>敏捷宣言的重点（和我的翻译）：</p><p></p><p>个人和交互高于过程和工具。（是的，我们想怎么做就怎么做）。欣然面对需求变化，即使在开发后期也一样。（我们也可以随时改变主意）。激发个体的斗志，以他们为核心构建项目，信任他们。（离我们远点，只管有什么拿什么）。可以工作的软件是进度的首要度量标准。（事实是，我们创造的任何东西都很重要）。简洁为本——这是极力减少不必要工作的艺术。（我们会尽量少做）。最好的架构、需求和设计出自自组织团队。（不要告诉我们该做什么）。</p><p></p><p>听我说，我这不是对<a href=\"https://uxdesign.cc/true-collaboration-with-cross-functional-peers-engineering-product-management-design-7be163369bb0\">工程师朋友们</a>\"的攻击。与我共事的大多数开发人员都热衷于把事情做好，但他们感觉受到了限制，只能根据冲刺时间窗口和承诺的交付成果来完成差强人意的工作。尽管如此，一些已经被灌输了敏捷思维的技术领导者仍然心怀崇拜地遵循着上述原则。需求更多的是建议而不是规则，设计需要解释，如果最终结果仍然“有效”，那么任何东西都可以砍掉。</p><p></p><p>对于初创公司来说，敏捷原则和Scrum实践的结合是灾难性的。这些是来自管理层的作业指令；设计师、项目经理和工程师并不是自组织的，这种方式工作不是他们选择的。一切都是以“<a href=\"https://uxdesign.cc/a-minimal-viable-product-needs-to-actually-be-viable-8d121e6f31bd\">MVP</a>\"”和上市时间的名义；这就是一再发生的事情。</p><p></p><p>研究和设计针对客户的问题提供解决方案，但相比之下，<a href=\"https://uxdesign.cc/why-doesnt-the-product-build-look-like-the-design-51810ea5760\">实际构建的产品却总是相形见绌</a>\"。</p><p></p><p>产品经理忙着实现路线图上下一个闪亮的目标……<a href=\"https://uxdesign.cc/the-risks-of-taking-shortcuts-in-product-development-b25484430497\">而且遵循着越少越好的原则</a>\"。</p><p></p><p>工程师就像流水线上的机器一样，总是被期待着生产和交付，为了“完工”而偷工减料。</p><p></p><p>领导层不明白为什么产品如此不稳定且效率低下。</p><p></p><p>敏捷和Scrum非但没有消除浪费，反而只会产生浪费，留下一个烂摊子：倦怠、技术债务、<a href=\"https://uxdesign.cc/design-debt-is-often-a-hidden-killer-of-consistency-heres-how-to-resolve-it-39bf6609f1a7\">设计债务</a>\"、不断增加的待办事项、硬编码的前端逻辑，以及始终存在的完全重构的威胁。</p><p></p><p>我们怎样才能走出这个怪圈呢？</p><p></p><h2>停下脚步</h2><p></p><p></p><p>不用把以客户为中心的解决方案硬塞进一个冲刺里。</p><p></p><p>确定需要构建什么。确定如何构建最好，并且可以获得可扩展性和未来适用性。然后构建它，不管花多长时间。（不必是两年，也不必是两周。只要产品是按照规范构建的，版本就可以分割。）激励卓越，而不是偷工减料。投资于基础工作，如设计系统和清洁技术栈，这样未来的工作可以更有效。投资于用户体验，优先提升功能集的深度而非广度。以正确的方式投资于运营效率，而不是削减员工数量，并期望同样数量的产出。</p><p></p><p>否则，就只能让渡质量了。</p><p></p><p>原文链接：<a href=\"https://uxdesign.cc/the-age-of-agile-must-end-bc89c0f084b7\">https://uxdesign.cc/the-age-of-agile-must-end-bc89c0f084b7</a>\"</p>",
    "publish_time": "2023-04-27 16:23:12",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]