[
  {
    "title": "PHP 8：函数和方法",
    "url": "https://www.infoq.cn/article/5ztCCEZ39EfToyRNaPF3",
    "summary": "<p></p><blockquote>本文属于专题文章<a href=\"https://www.infoq.cn/theme/php8-article-series\">《深入浅出 PHP 8》</a>\"。根据<a href=\"https://w3techs.com/technologies/details/pl-php\">w3tech</a>\"的数据，PHP仍然是Web上使用最广泛的脚本语言之一，77.3%的网站使用PHP进行服务器端编程。PHP 8带来了许多新特性和其他改进，我们将在本系列文章中进行探讨。PHP 8.0添加了对多个函数和方法相关特性的支持，其中一些是对现有特性的改进，而另一些则是全新的特性。PHP 8.1中增强的可调用语法可用于通过可调用对象创建匿名函数。命名函数参数可以与位置参数一起使用，另外还有一个好处，即命名参数没有顺序，可以通过它们的名称来传达含义。纤程（Fiber）是可中断的函数，增加了对多任务的支持。</blockquote><p></p><p></p><h2>重新定义了私有方法上的继承</h2><p></p><p>对象继承是大多数面向对象语言（包括PHP）所使用的编程范式。它可以从任何扩展类中重写公共和受保护的方法，以及在类中定义的类属性和常量。在PHP中，公共方法不能通过更严格的访问来重新实现，例如将 public 方法设为 private 。为了演示这一点，考虑一个扩展了类A的类B，它重新实现了类A中一个公共方法。</p><p></p><p><code lang=\"php\"><!--?php\nclass A{\n  public function sortArray():string{\n   return \"Class A method\";\n  }\n}\n \nclass B extends A{\n  private function sortArray():string{\n   return \"Class B method\";\n  }\n}\n$b=new B();\necho $b--->sortArray();\n</code></p><p></p><p>运行时，脚本会生成如下的一条错误信息：</p><p></p><p><code lang=\"plain\">致命错误：B::sortArray()的访问级别必须是公共的(与类A一样)\n公共方法不能重新实现。\n</code></p><p></p><p>相反，在类中定义的私有方法不是继承的，可以在扩展它的类中重新实现。例如，类B在下面的脚本中扩展了类A，并重新实现了类A中一个私有方法。</p><p></p><p><code lang=\"plain\"><!--?php\nclass A{\n  private function sortArray():string{\n   return \"Class A method\";\n  }\n}\n \nclass B extends A{\n  private function sortArray(int $a):string{\n   return \"Class B method\";\n  }\n}\n</code--></code></p><p></p><p><code lang=\"plain\">在PHP 8.0之前，对扩展类中私有方法的重新声明应用了两个限制：不允许更改 final 和 static 修饰符。如果 private 方法被声明为 final ，则不允许扩展类重新声明该方法。如果私有方法被声明为静态的，那么它将在扩展类中保持静态。而且，如果私有方法没有static 修饰符，则不允许扩展类添加static 修饰符。在PHP 8中，这两个限制都被取消了。以下脚本在PHP 8中能正常运行。</code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><!--?php\nclass A {\n  private final static function sortArray():string{\n   return \"Class A method\";\n  }\n}\n \nclass B extends A {\n  private  function sortArray(int $a):string{\n   return \"Class B method\";\n  }\n}\n</code--></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\">PHP 8中唯一的私有方法限制是强制使用 private final 构造函数，当使用静态工厂方法作为替代时，有时会使用private final来禁用构造函数。</code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\nclass A {\n  private final function __construct(){\n         \n  }\n}\n \nclass B extends A {\n  private final function __construct(){\n    \n  }\n}\n</code--></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">该脚本生成如下的错误信息：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">致命错误：不能重写最终方法A::__construct()\n</code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">可变参数可以替换任意数量的函数参数</code></code></code></h2><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">在PHP 8中，单个可变参数可以替换任意数量的函数参数。考虑下面的脚本，其中类B扩展了类A，并用一个可变参数替换函数 sortArray 的三个参数。</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"> <!--?php\nclass A {\n    public function sortArray(array $arrayToSort, string $sortType, int $arraySize) { \n       if ($sortType == \"asc\") {\n             sort($arrayToSort);\n             foreach ($arrayToSort as $key =--> $val) {\n                echo \"$key = $val \";\n             }  \n       } elseif ($sortType == \"desc\") {\n             rsort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  \n       }  \n   }\n}\nclass B extends A {\n    public function sortArray(...$multiple) {\n        $arrayToSort= $multiple[0];\n        $sortType=$multiple[1];\n    \n    if ($sortType == \"asc\") {\n             sort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  \n        } elseif ($sortType == \"desc\") {\n             rsort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  \n        }  \n   }\n}\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">可以使用多个参数调用类B中的 sortArray 函数。</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">$sortType=\"asc\";\n$arrayToSort=array(\"B\", \"A\", \"f\", \"C\");\n$arraySize=4;\n \n$b=new B();\n$b-&gt;sortArray($arrayToSort,$sortType,$arraySize);\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">输出结果如下所示：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">0 = A 1 = B 2 = C 3 = f \n</code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">简化了可调用语法</code></code></code></h2><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">可调用（callable）是可以被调用的PHP表达式，例如实例方法、静态方法或可调用对象。例如，可调用可用于为方法调用创建简短的表达式。在PHP 8.1中，可以用新的可调用语法：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">AVariableCallableExpression(...)</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">AVariableCallableExpression 表示一个变量可调用表达式。省略号…包含在语法中。</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">为什么要使用新的可调用语法呢？让我们通过一些示例来回顾一下传统的可调用语法是什么样子的：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">$f1 = 'strlen'(...);\n$f2 = [$someobj, 'somemethod'](...);\n$f3 = [SomeClass::class, 'somestaticmethod'](...);\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">这有两个问题：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">语法涉及字符串和数组在创建可调用时，作用域不会被维护。为了演示这一点，请考虑如下用于对数组进行排序的脚本，其中 getSortArrayMethod() 方法返回 sortArray() 方法的可调用项，[$this，'sortArray'] 。</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \n class Sort  {\n    private array $arrayToSort; \n    private string $sortType;\n    public function __construct($arrayToSort,$sortType)\n    {\n        $this--->arrayToSort = $arrayToSort;\n        $this-&gt;sortType = $sortType;\n    }\n    public function getSortArrayMethod() {\n             return [$this, 'sortArray'];\n         \n    }\n    private function sortArray() {\n        if ($this-&gt;sortType == \"Asc\") {\n             sort($this-&gt;arrayToSort);\n             foreach ($this-&gt;arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  \n        } elseif ($this-&gt;sortType == \"Desc\") {\n             rsort($this-&gt;arrayToSort);\n             foreach ($this-&gt;arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  \n        } else {\n              \n             shuffle($this-&gt;arrayToSort);\n             foreach ($this-&gt;arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  \n        }\n    }\n}\n$sortType=\"Asc\";\n$arrayToSort=array(\"B\", \"A\", \"f\", \"C\");\n$sort = new Sort($arrayToSort,$sortType);\n$c = $sort-&gt;getSortArrayMethod();\n$c();\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">该脚本会生成如下的错误信息：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">致命错误：未捕获错误：调用私有方法Sort::sortArray()来自全局作用域\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">使用 Closure::fromCallable([$this, 'sortArray']) 而不是 [$this, 'sortArray'] 可以解决作用域问题，但使用 Closure::fromCallable 方法会使调用变得冗长。新的可调用语法解决了作用域和语法冗长的问题。使用新的可调用语法，函数变为：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">public function getSortArrayMethod() {\n       return $this-&gt;sortArray(...);         \n}\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">数组根据输出进行排序：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">0 = A 1 = B 2 = C 3 = f\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">新语法可以与涉及字符串和数组的传统语法结合使用，以解决作用域问题。创建可调用的作用域将保持不变。</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">public  function getSortArrayMethod() {\n        return [$this, 'sortArray'](...);       \n            \n}\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">新的可调用语法也可以与静态方法一起使用，如下面的脚本所示，该脚本包含一个静态函数。</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n class Sort  {\n    private array $arrayToSort; \n    private string $sortType;\n    public function __construct($arrayToSort,$sortType)\n    {\n        $this--->arrayToSort = $arrayToSort;\n        $this-&gt;sortType = $sortType;\n    }\n    public  function getStaticMethod() {\n       \n       return Sort::aStaticFunction(...); \n        \n    }\n    \n    private  static  function aStaticFunction() {\n    }\n}\n$sortType=\"Asc\";\n$arrayToSort=array(\"B\", \"A\", \"f\", \"C\");\n$sort = new Sort($arrayToSort,$sortType);\n$cStatic=$sort-&gt;getStaticMethod();\n$cStatic();\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">输出结果与之前的相同：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">0 = A 1 = B 2 = C 3 = f\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">以下是调用方法的等效方法：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">return $this-&gt;sortArray(...); \nreturn Closure::fromCallable([$this, 'sortArray']);\nreturn [$this, 'sortArray'](...); \n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">以下是调用静态方法的等效方法：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">return Sort::aStaticFunction(...); \nreturn [Sort::class, 'aStaticFunction'](...); \nreturn Closure::fromCallable([Sort::class, 'aStaticFunction']);\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">即使函数声明了形参，也可以使用新的可调用语法。</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n class Sort  {\n    private array $arrayToSort; \n    private string $sortType;\n    public function __construct($arrayToSort,$sortType)\n    {\n        $this--->arrayToSort = $arrayToSort;\n        $this-&gt;sortType = $sortType;\n    }\n    public  function getSortArrayMethod() {\n       return $this-&gt;sortArray(...); \n    }\n    private function sortArray(int $a,string $b) {\n        if ($this-&gt;sortType == \"Asc\") {\n             sort($this-&gt;arrayToSort);\n             foreach ($this-&gt;arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  \n        } elseif ($this-&gt;sortType == \"Desc\") {\n             rsort($this-&gt;arrayToSort);\n             foreach ($this-&gt;arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  \n        } else {\n              \n             shuffle($this-&gt;arrayToSort);\n             foreach ($this-&gt;arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  \n        }\n    }\n}\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">如果一个方法声明了任意参数，则必须使用它的参数来调用可调用对象。</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">$sortType=\"Asc\";\n$arrayToSort=array(\"B\", \"A\", \"f\", \"C\");\n$sort = new Sort($arrayToSort,$sortType);\n$c = $sort-&gt;getSortArrayMethod();\n$c(1,\"A\");\n</code></code></code></code></p><p></p><h3><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">简化语法可用于任意的PHP Callable表达式</code></code></code></h3><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">简化的可调用语法可以用于任意的PHP可调用表达式。用于对象创建的 new 运算符不支持可调用语法，因为可调用语法 AVariableCallableExpression(...) 没有指定构造函数参数的规定，这可能是必需的。以下是不支持的示例：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">$sort = new Sort(...);\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">生成的错误信息为：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">致命错误：不能为new表达式创建闭包\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">以下的脚本演示了受支持的所有可调用表达式。</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n class Sort  {\n    private array $arrayToSort; \n    private string $sortType;\n    public function __construct($arrayToSort,$sortType)\n    {\n        $this--->arrayToSort = $arrayToSort;\n        $this-&gt;sortType = $sortType;\n    }\n    public  function getSortArrayMethod() {\n       return $this-&gt;sortArray(...); \n    }\n    public  function getStaticMethod() {\n       \n      return Sort::aStaticFunction(...);   \n         \n    }\n    \n    public  static  function aStaticFunction() {\n    }\n     \n    public    function sortArray(int $a,string $b) {\n        if ($this-&gt;sortType == \"Asc\") {\n             sort($this-&gt;arrayToSort);\n             foreach ($this-&gt;arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  \n        } elseif ($this-&gt;sortType == \"Desc\") {\n             rsort($this-&gt;arrayToSort);\n             foreach ($this-&gt;arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  \n        } else {\n              \n             shuffle($this-&gt;arrayToSort);\n             foreach ($this-&gt;arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  \n        }\n    }\n    public function __invoke() {}\n}\n$sortType=\"Asc\";\n$arrayToSort=array(\"B\", \"A\", \"f\", \"C\");\n \n$classStr = 'Sort';\n$staticmethodStr = 'aStaticFunction';\n$c1 = $classStr::$staticmethodStr(...);\n$methodStr = 'sortArray';\n$sort = new Sort($arrayToSort,$sortType);\n$c2 = strlen(...);\n$c3 = $sort(...);  // 可调用对象\n$c4 = $sort-&gt;sortArray(...);\n$c5 = $sort-&gt;$methodStr(...);\n$c6 = Sort::aStaticFunction(...);\n$c7 = $classStr::$staticmethodStr(...);\n// 传统的可调用使用字符串，数组\n$c8 = 'strlen'(...);\n$c9 = [$sort, 'sortArray'](...);\n$c10 = [Sort::class, 'aStaticFunction'](...); \n$c11 = $sort-&gt;getSortArrayMethod();\n$c11(1,\"A\");\n$cStatic=$sort-&gt;getStaticMethod();\n$cStatic();\n</code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">尾逗号和可选/必选的参数顺序</code></code></code></h2><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">PHP 8.0的另一个新特性是支持在函数的参数列表末尾添加一个尾逗号，以提高可读性。任何尾逗号都将被忽略。尾逗号可能并不总是有用的，但如果参数列表很长，或者参数名称很长，则可能会有用，因此可以垂直列出它们。闭包使用列表也支持尾逗号。</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">PHP 8.0不支持在必选参数之前声明可选参数。在必选参数之前声明的可选参数都是隐式的必选参数。</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">下面的脚本演示了必选参数的隐式顺序，以及尾逗号的使用。</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n  function trailing_comma_example(\n    $the_very_first_arg_of_this_function,\n    $the_second_arg_of_this_function,\n    $the_third_arg_of_this_function = 1,\n    $the_fourth_arg_of_this_function, \n    $the_last_arg_of_this_function,\n){ echo $the_third_arg_of_this_function; }\n \n  trailing_comma_example(1,2,null,3,4)\n \n?-->\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">输出如下所示：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">已弃用（不推荐）：在必选参数$the_last_arg_of_this_function之前声明的可选参数\n$the_third_arg_of_tis_function将被隐式地视为必选参数\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">可空参数不会被视为可选参数，可以使用 $param=null 形式或显式可空类型在必选参数之前声明，脚本如下所示：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n  class A {}\n  function fn1(A $a = null, $b) {}  \n  function fn2(?A $a, $b) {}        \n  fn1(new A,1);\n  fn2(null,1);\n?--> \n</code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">命名函数形参和实参</code></code></code></h2><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">PHP 8.0除了已经支持的位置形参和实参之外，还增加了对命名函数形参和实参的支持。命名参数在函数调用中的传递语法如下所示：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">参数名称：参数值\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">命名参数的一些好处如下所示：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">可以为函数参数指定一个有意义的名称，使它们能够自我记录按名称传递时，参数与顺序无关可以任意跳过默认值。在下面的脚本中， array_hashtable 函数声明了命名参数。 该函数传递的实参值可以带参数名，也可以不带参数名。当传递位置实参时，使用函数形参声明顺序。但传递命名实参时，可以使用任意顺序。</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\nfunction array_hashtable($key1,$key2,$key3,$key4,$key5){ \n  echo $key1.' '.$key2.' '.$key3.' '.$key4.' '.$key5;\n  echo \"<br-->\";\n}\n// 使用位置实参:\narray_hashtable(0, 10, 50, 20, 25);\n// 使用命名实参:\narray_hashtable(key2: 0, key5: 25, key1: 10, key4: 50, key3: 20);\n?&gt;\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">输出结果为：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">0 10 50 20 25\n10 0 20 50 25\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">命名实参和位置实参可以在同一函数调用中使用。对相同的示例函数 array_hashtable 一起使用混合参数调用。</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><!--?php\nfunction array_hashtable($key1,$key2,$key3,$key4,$key5){ \n  echo $key1.' '.$key2.' '.$key3.' '.$key4.' '.$key5;\n  echo \"<br-->\";\n}\n// 使用混合参数:\narray_hashtable(0, 10, 50, key5: 25, key4: 20);\n \n?&gt;\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">输出结果为：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">0 10 50 20 25\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">请注意，命名参数只能用于位置参数之后。下面的脚本颠倒了顺序，在命名参数之后使用位置参数：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><!--?php\nfunction array_hashtable($key1,$key2,$key3,$key4,$key5){ \n  echo $key1.' '.$key2.' '.$key3.' '.$key4.' '.$key5;\n  echo \"<br-->\";\n}\n// Using mixed arguments:\narray_hashtable(0, 10, key3: 25, 50, key5: 20);\n \n?&gt;\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">该脚本生成的错误信息为：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">致命错误：不能在命名参数后使用位置参数\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">即使使用命名参数，也不推荐在必选参数之前声明可选参数，脚本如下所示：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><!--?php\nfunction array_hashtable($key1=0,$key2=10,$key3=20,$key4,$key5){ \n  echo $key1.' '.$key2.' '.$key3.' '.$key4.' '.$key5;\n  echo \"<br-->\";\n}\n// 使用混合参数:\narray_hashtable(1,2,key3: 25, key4: 1,key5: 20);\n \n?&gt;\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">输出将包括已弃用（不推荐）信息：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">已弃用（不推荐）：在必选参数$key5之前声明的可选参数$key1被隐式视为必选参数\n已弃用（不推荐）：在必选参数$key5之前声明的可选参数$key2被隐式视为必选参数\n已弃用（不推荐）：在必选参数$key5之前声明的可选参数$key3被隐式视为必选参数\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">当在必选命名形参之后使用可选命名形参时，命名实参可用于跳过函数调用中的一个或多个可选形参，脚本如下所示：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><!--?php\nfunction array_hashtable($key1,$key2,$key3=20,$key4=50,$key5=10){ \necho $key1.' '.$key2.' '.$key3.' '.$key4.' '.$key5;\necho \"<br-->\";\n}\n// 使用混合参数:\narray_hashtable(key1:1, key2:2,key4: 25);\n \n?&gt;\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">输出结果为：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">1 2 20 25 10\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">你可以只使用可选参数的子集来调用函数，而不用考虑它们的顺序。</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\nfunction array_hashtable($key1=0,$key2=10,$key3=20,$key4=50,$key5=10){ \n  echo $key1.' '.$key2.' '.$key3.' '.$key4.' '.$key5;\n  echo \"<br-->\";\n}\n// 使用混合参数:\narray_hashtable(1,2,key4: 25);\n \n?&gt;\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">输出结果如下所示：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">1 2 20 25 10\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">即使使用可选参数的子集调用函数，也不能在命名参数之后使用位置参数，脚本如下所示：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\nfunction array_hashtable($key1=0,$key2=10,$key3=20,$key4=50,$key5=10){ \necho $key1.' '.$key2.' '.$key3.' '.$key4.' '.$key5;\necho \"<br-->\";\n}\n// Using mixed arguments:\narray_hashtable(1,2,key4: 25,5);\n \n?&gt;\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">生成的错误信息以下所示：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">致命错误：不能在命名参数后使用位置参数\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">PHP 8.1改进了命名实参特性，在解包实参后支持命名实参，脚本如下所示：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\nfunction array_hashtable($key1,$key2,$key3=30,$key4=40,$key5=50){ \n  echo $key1.' '.$key2.' '.$key3.' '.$key4.' '.$key5;\n  echo \"<br-->\";\n}\necho array_hashtable(...[10, 20], key5: 40);  \necho array_hashtable(...['key2' =&gt; 2, 'key1' =&gt; 2], key4: 50);  \n \n?&gt;\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">输出如下所示：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">10 20 30 40 40\n2 2 30 50 50\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">但是，命名的参数不能覆盖前面的参数，脚本如下所示：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\nfunction array_hashtable($key1,$key2,$key3=30,$key4=40,$key5=50){ \n  echo $key1.' '.$key2.' '.$key3.' '.$key4.' '.$key5;\n  echo \"<br-->\";\n}\necho array_hashtable(...[10, 20], key2: 40);   \n?&gt;\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">输出如下所示：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">致命错误：未捕获错误：命名参数$key2覆盖上一个参数。\n</code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">非静态方法不能被静态调用</code></code></code></h2><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">在PHP 8.0之前，如果在静态上下文中调用非静态方法，或者静态调用，则只会收到一条已弃用（不推荐）的信息。使用8.0，你现在会收到一条错误信息。此外， $this 在静态上下文中是未定义的。为了演示这一点，请考虑如下的脚本，其中使用静态语法 A::aNonStaticMethod() 调用了非静态方法 aNonStaticMethod() 。</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\nclass A\n{\n    function aNonStaticMethod()\n    {\n    }\n}\n \nA::aNonStaticMethod();\n</code--></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">如果你运行这个脚本，将会得到如下的错误信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">未捕获错误：非静态方法A::aNonStaticMethod()不能被静态调用\n</code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">纤程</code></code></code></code></h2><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">PHP 8.1添加了对纤程（Fiber）多任务的支持。纤程是一个可中断的函数，它具有自己的堆栈。纤程可以从调用堆栈中的任何位置挂起，然后再恢复。新的Fiber类是一个final类，它支持以下的公共方法：</code></code></code></code></p><p></p><p></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">纤程只能启动一次，但可以挂起并恢复多次。下面的脚本通过使用纤程在数组上执行不同类型的排序来演示多任务处理。纤程在每次排序后都会挂起，然后再恢复执行不同类型的排序。</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \n \n$fiber = new Fiber(function (array $arr): void {\n   sort($arr);\n   foreach ($arr as $key =--> $val) {\n                echo \"$key = $val \";\n             }  \n  echo \"<br />\";\n  Fiber::suspend();\n  rsort($arr);\n   foreach ($arr as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  \n   echo \"<br />\";\n  Fiber::suspend();\n  shuffle($arr);\n   foreach ($arr as $key =&gt; $val) {\n                echo \"$key = $val \";\n             } \n});\n \n  $arrayToSort=array(\"B\", \"A\", \"f\", \"C\");\n$value = $fiber-&gt;start($arrayToSort); \n   \n $fiber-&gt;resume();\n$fiber-&gt;resume(); \n?&gt;\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">输出如下所示：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">0 = A 1 = B 2 = C 3 = f\n0 = f 1 = C 2 = B 3 = A\n0 = C 1 = f 2 = A 3 = B\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">如果纤程在第一次挂起后没有再恢复，则只进行一种类型的排序，这可以通过注释掉对 resume() 的两次调用来实现。</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">//$fiber-&gt;resume();\n\n//$fiber-&gt;resume(); \n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">输出的是第一次排序的结果：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">0 = A 1 = B 2 = C 3 = f\n</code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">Stringable接口和 __toString()</code></code></code></h2><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">PHP 8.0引入了一个名为 Stringable 的新接口，它只提供一个方法 __toString() 。 __toString() 方法如果在类中提供，将隐式实现 Stringable 接口。考虑提供 __toString() 方法的类A。</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A    {\n\n     public function __toString(): string {\n       return \" \";\n    }\n}\n\necho (new A() instanceof Stringable);\n</code--></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">该脚本从 Stringable 的类型检查中返回1。</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">然而，反之则不然。如果类实现了 Stringable 接口，则必须显式提供 __toString() 方法，因为该方法不会自动添加，比如：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><!--?php\n\nclass A implements Stringable  {\npublic function __toString(): string { }\n   \n}\n</code--></code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">新的标准库函数</code></code></code></code></code></h2><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">PHP 8引入了许多属于其标准库的新函数。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">str_contains 函数返回一个 bool 值，用于指示作为第一个参数的字符串是否包含作为第二个参数的字符串。以下脚本将返回 false ：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n\nif (str_contains('haystack', 'needle')) {\n    echo true;\n} else {\n    echo false;\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">下面的脚本返回1，或true：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\nif (str_contains('haystack', 'hay')) {\n    echo true;\n}else {\n    echo \"false\";\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">str_starts_with 函数返回一个bool 值 ，指示作为第一个参数的字符串是否以作为第二个参数的字符串开头。以下脚本将返回 false 。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nif (str_contains('haystack', 'hay')) {\n    echo true;\n}else {\n    echo \"false\";\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">下面的脚本将返回1，或true。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nif (str_starts_with('haystack', 'needle')) {\n    echo true;\n} else {\n    echo false;\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">str_ends_with 函数返回一个bool 值 ，指示作为第一个参数的字符串是否以作为第二个参数的字符串结尾。以下脚本将返回 false 。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><!--?php\n\nif (str_starts_with('haystack', 'needle')) {\n    echo true;\n} else {\n    echo false;\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">下面的脚本将返回1，或true。</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n\nif (str_starts_with('haystack', 'hay')) {\n    echo true;\n} else {\n    echo false;\n}\n</code--></code></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">fdiv 函数将两个数字相除并返回一个 float 值，脚本如下所示：</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><!--?php\n\nvar_dump(fdiv(1.5, 1.3));   \nvar_dump(fdiv(10, 2));  \nvar_dump(fdiv(5.0, 0.0));    \nvar_dump(fdiv(-2.0, 0.0));   \nvar_dump(fdiv(0.0, 0.0));  \n \nvar_dump(fdiv(5.0, 1.0));   \nvar_dump(fdiv(10.0, 2));  \n</code--></code></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">输出为：</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">float(1.1538461538461537)\nfloat(5) \nfloat(INF) \nfloat(-INF)\nfloat(NAN)\nfloat(5)\nfloat(5)\n</code></code></code></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">fdatasync 函数在Windows上的别名为 fsync ，用于将数据同步到文件上的流中。为了演示它的用法，在包含要运行的PHP脚本的脚本目录中创建一个空文件 test.txt 。运行脚本：</code></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n\n$file = 'test.txt';\n\n$stream = fopen($file, 'w');\nfwrite($stream, 'first line of data');\nfwrite($stream, \"\\r\\n\");\nfwrite($stream, 'second line of  data');\nfwrite($stream, 'third line of  data');\n\nfdatasync($stream);\nfclose($stream);\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">随后，打开 test.txt 文件会发现包含如下的文本：</code></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">first line of data\nsecond line of data\nthird line of data\n</code></code></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">array_is_list 函数返回布尔值，用于指示给定的数组是否为列表。数组必须从0开始，键必须是连续的整数，并且顺序正确。下面的脚本演示了 array_is_list 函数：</code></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\necho array_is_list([]);  \necho array_is_list(['1', 2, 3]);  \necho array_is_list([0 =--> 'a', 'b']);  \n\necho array_is_list([1 =&gt; 'a', 'b']); // false\necho array_is_list([1 =&gt; 'a', 0 =&gt; 'b']); // false\necho array_is_list([0 =&gt; 'a', 'b' =&gt; 'b']); // false\necho array_is_list([0 =&gt; 'a', 2 =&gt; 'b']); // false\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">输出为：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">1\n1\n1\n</code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">魔术方法必须要有正确的签名</code></code></code></code></h2><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">魔术方法是PHP中用于覆盖默认操作的特殊方法。它们包括如下的方法，其中构造函数 __construct() 可能是大家最熟悉的：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">__construct(),\n__destruct(), \n__call(),\n__callStatic(),\n__get(), \n__set(),\n__isset(),\n__unset(), \n__sleep(),\n__wakeup(),\n__serialize(),\n__unserialize(),\n__toString(),\n__invoke(),\n__set_state(),\n__clone(),\n__debugInfo()\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">从PHP 8.0开始，魔术方法定义的签名必须要是正确的，这意味着如果在方法参数或返回类型中使用类型声明，则它们必须与<a href=\"https://www.php.net/manual/en/language.oop5.magic.php\">文档中</a>\"的声明相同。新的 __toString() 方法的返回类型必须要声明为 string 。下面的演示将返回类型声明为 int ：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A   {\n\n    public function __toString(): int { \n    }\n}\n</code--></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">将生成如下的错误信息：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">致命错误：A::__toString():返回类型在声明时必须是字符串\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">但是，未通过定义声明返回类型的函数（如构造函数）不能声明返回类型，即使是 void 返回类型也不行。示例如下脚本所示：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A   {\n    public function __construct():void\n    {\n         \n    }\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">该脚本将返回如下的错误信息：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">致命错误：方法A::__construct()不能声明返回类型\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">所有魔术方法，除了少数例外（例如 __construct() ）外，都必须声明为具有公共可见性。为了演示这一点，声明了一个带有 private 可见性的 __callStatic 。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"> <!--?php\n\nclass A   {\n\n    private static function __callStatic(string $name, array $arguments) {}\n\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">输出的警告信息为：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">警告：魔术方法A::__callStatic()必须要具有公共可见性\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">尽管可以省略混合返回类型，但方法签名也必须相同。例如，在下面的脚本中，类A声明了 __callStatic 而没有指定其返回类型，而类B将其第一个参数定义为int ：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">\n<!--?php\n\nclass A   {\n\n    public static function __callStatic(string $name, array $arguments) {}\n\n\n\nclass B   {\n\n    public static function __callStatic(int $name, array $arguments) {}\n\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">输出的错误信息如下所示：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">致命错误：B::__callStatic()：参数 #1 ($name) 在声明时必须为字符串类型\n</code></code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">返回类型与内部类的兼容性</code></code></code></code></code></h2><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">在PHP 8.1中，大多数内部方法，即内部类中的方法，都已经“试探性地”开始声明返回类型。试探性地暗示，虽然在8.1中只会引发不推荐（Deprecation）通知，但在9.0版中，则会输出错误条件信息。因此，任何扩展类都必须声明与内部类相兼容的返回类型，否则将会引发已弃用（不推荐）通知。为了演示这一点，扩展内部类 Directory 并重新声明没有返回类型的函数 read() ：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A extends Directory {\n    public function read() { }\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">该脚本将生成已弃用（不推荐）通知：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">已弃用（不推荐）：A::read()的返回类型应与Directory::read(): string|false兼容，或者应使用#[\\ReturnTypeWillChange]属性来临时抑制通知\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">但是，以下脚本是可以的：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A extends Directory {\n    public function read():string  { return \"\"; }\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">添加 #[\\ReturnTypeWillChange] 属性能抑制已弃用（不推荐）通知：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\nclass A extends Directory {\n    #[\\ReturnTypeWillChange]\n    public function read()    {   }\n}\n</code--></code></code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">\\SensitiveParameter属性</code></code></code></code></code></h2><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">虽然包含有关方法参数的详细信息的异常堆栈跟踪对调试非常有用，但你可能不希望输出某些敏感参数的参数值，例如与密码和凭据关联的参数值。PHP 8.2引入了一个名为 \\SensitiveParameter 的新属性，这样，如果使用 \\SensitivyParameter 属性注解方法的参数，则该参数的值不会在异常堆栈跟踪中输出。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">为了演示这一点，考虑下面的脚本，其中函数 f1 具有与 \\SensitiveParameter 属性关联的参数 $password 。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \nfunction f1(\n    $param1 = 1,\n    #[\\SensitiveParameter] $password = “s@5f_u7”,\n    $param3 = null\n) {\n    throw new \\Exception('Error');\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">为了演示 \\SensitiveParameter 特性，该函数只是抛出一个异常。调用函数：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">f1(param3: 'a');\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">请注意，异常堆栈跟踪不包含 $password 参数的值，而是列出了 Object(SensitiveParameterValue) 。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">Stack trace: #0 : f1(1, Object(SensitiveParameterValue), 'a') #1 {main}\n</code></code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">内置函数弃用/增强</code></code></code></code></code></h2><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">内置函数 utf8_encode() 和 utf8_decode() 经常被误解，因为它们的名称意味着对任何字符串进行编码/解码。实际上，这些函数仅用于编码/解码ISO8859-1，即“Latin-1”字符串。此外，它们生成的错误信息对于调试来说描述性不够。PHP 8.2已经弃用了这些函数。下面的脚本使用了它们：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \n$string_to_encode = \"\\x7A\\x6A\\xdB\";\n$utf8_string = utf8_encode($string_to_encode);\necho bin2hex($utf8_string), \"\\n\";\n$utf8_string = \"\\x6A\\x6B\\xD3\\xCB\";\n$decoded_string = utf8_decode($utf8_string);\necho bin2hex($decoded_string), \"\\n\";\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">对于PHP 8.2，会输出已弃用（不推荐）通知：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">已弃用（不推荐）：函数utf8_encode()已弃用\n已弃用（不推荐）：函数utf8_decode()已弃用\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">在PHP 8.2中，函数 iterator_count 和 iterator_to_array 接受所有可迭代的对象。 iterator_to_array() 函数将迭代器的元素复制到数组中。 iterator_count() 函数对数组的元素进行计数。这些函数接受一个 $iterator 作为第一个参数。在PHP 8.2中，$iterator 参数的类型已从 Traversable 扩展为 Traversable|array ，以便接受任意的可迭代值。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">下面的脚本演示了它们在 arrays 和 Traversables 中的使用。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \n$a=array('1'=-->'one', 'two', 'three', 'four');\n$iterator = new ArrayIterator($a);\nvar_dump(iterator_to_array($iterator, true));\nvar_dump(iterator_to_array($a, true));\n\nvar_dump(iterator_count($iterator));\nvar_dump(iterator_count($a));\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">输出如下所示：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">array(4) { [1]=&gt; string(3) \"one\" [2]=&gt; string(3) \"two\" [3]=&gt; string(5) \"three\" [4]=&gt; string(4) \"four\" } \narray(4) { [1]=&gt; string(3) \"one\" [2]=&gt; string(3) \"two\" [3]=&gt; string(5) \"three\" [4]=&gt; string(4) \"four\" } \nint(4) \nint(4)\n</code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">总结</code></code></code></code></h2><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">在这篇PHP 8系列文章中，我们讨论了与函数和方法相关的新特性，其中最突出的是命名函数的形参/实参、简化的可调用语法和被称为纤程（Fiber）的可中断函数。</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">在本系列的下一篇文章中，我们将介绍PHP类型系统的新特性。</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">原文链接：</code></code></code></code></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.com/articles/php8-functions-methods/\">https://www.infoq.com/articles/php8-functions-methods/</a>\"</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">相关阅读：</code></code></code></code></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.cn/article/XkzLrAYhV1CWPDzu72N2\">PHP 8：注解、match 表达式及其他改进</a>\"</code></code></code></code></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.cn/article/XkIrT3XLmZFW9XdoJS1F\">PHP 8：类和枚举</a>\"</code></code></code></code></p>",
    "publish_time": "2023-01-21 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]