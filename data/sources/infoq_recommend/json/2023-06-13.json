[
  {
    "title": "架构成长之路 | 图解分布式共识算法Paxos教会协议",
    "url": "https://www.infoq.cn/article/2de2edc609c74954bc2bf8c53",
    "summary": "<p>作者：谢鑫</p><p></p><p></p><blockquote>分布式共识算法是保证分布式一致性的基础，本文主要以简化类比的方式阐述了Paxos算法中的单法令教会会议（The Single-decree SYNOD）的算法。</blockquote><p></p><p></p><p></p><h1>一、分布式共识算法</h1><p></p><p></p><p>分布式共识算法是保证分布式一致性的基础。我们在进行微服务开发的时候，都会尽量让自己的服务无状态（stateless），遇到部分需要存储的数据时，通常会将其往中间件转移 。比如持久化数据的存储往关系数据库转移，缓存的存取往Redis转移，文件的读写往OSS/HDFS转移，消息的收发往MQ转移。但是这些中间件又如何保证数据的一致性呢？如果用的是一个单机版中间件，则能够较容易地保证本地的一致性，但是这样会丧失可用性和扩展性。所以，很多中间件内部通常会使用分布式共识算法来保证分布式环境下的一致性，同时又能兼顾高可用和横向扩展。</p><p></p><p>分布式共识（consensus）和分布式一致性（consistency）它们的关系是怎样的呢？很多情况下我们会将两者混为一谈，但它们之间还是有细微的区别。一致性的解释有很多，这里选择用一种比较简单的解释：存储的数据之间不自相矛盾。一致性描述的是数据应该达到的结果，不自相矛盾包含了很多信息，数据能够持久化存储，副本之间的数据相同，满足业务上的各种规则等等；而共识则是一个过程，即大家关于某件事情（比如选举、分布式锁、全局ID、数据复制 等等）达成一致的过程。</p><p></p><p>常用的分布式共识算法有Paxos、Raft等等，还有一种更激进的说法：\"世界上只有一种分布式共识算法，那就是Paxos\"。所以本专题以Paxos为引，逐步引出关于分布式共识、分布式一致性的更多内容。在进入Paxos讲解之前，首先需要了解一下关于分布式共识算法的两个基本特性：</p><p></p><p>安全性（safety）：所有的参与者对同一件事达成共识。例如对于选举，不会出现A、B认A为主，而C、D认D为主；活性（liveness）：所有的参与者最终会对某一件事达成共识。也用选举来举例，不管谁当选，最终都会有人当选，而不是陷入死循环或死锁中。</p><p></p><p></p><h1>二、Paxos的历史</h1><p></p><p></p><p>Paxos算法是Leslie Lamport于20世纪90年代在《The Part-Time Parliament》提出的，论文以一个虚构的Paxos小岛上选举的故事来描述整个算法，充满着各种隐喻，比较晦涩难懂。Lamport之后在2001年，通过在《Paxos Made Simple》中使用计算机领域的概念描述了一遍算法，但是依然很难理解。直到Google的Chubby横跨出世，作为它底层的分布式共识算法，Paxos也逐渐被大家熟知和认可。Lamport凭借他在分布式领域的贡献，最终于2013年获得图灵奖。</p><p></p><p>Paxos中包含两个协议，一个是单法令的教会协议（single-decree SYNOD），一个是多法令的议会协议（multi-decrees parliament），议会协议是教会协议的衍生版，本文主要讲解单法令教会协议。</p><p></p><p></p><h1>三、背景设定</h1><p></p><p></p><p>Long long ago，在遥远的爱琴海上，有一座与世隔绝的小岛，叫做Paxos……算了，还是用简单一点的例子吧。（以下故事，纯属虚构，如有雷同，就这么着）</p><p></p><p>我们团队一共有5个人，分别是我（小X）以及小A、小B、小C和小D。我们团队有个传统，就是每天中午之前，都会讨论一个困难的哲学问题——今天中午去哪儿吃？备选项也不多，去一食堂的餐馆吃拉面，或者说去二食堂的餐馆吃蛋炒饭。与其说吃什么，倒不如说我们就是想选个地方一起聊聊“八卦”，增进增进\"感情\"。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/c3/c39f59564ee77da5891c4ddcc4744036.png\" /></p><p></p><p>为此，每天中午吃饭之前，我们都会通过表决（ballot）的形式来进行投票（vote）。咱们的同学都比较忙，表决的时候有可能不在工位上，所以我们会锲而不舍的发起多轮表决，并且每轮表决只会简单的问在工位上的同学，吃面吗？或者是问吃米饭吗？其他人只需要回答\"我去\"（投票），或者不回答（不投票）。程序员都好懒哦，毕竟判断题比选择题简单，选择题比填空题简单，能回答一个字绝不再多说一个字。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/cd/cdbe30c1b0786cde9ae3824cfe995a34.png\" /></p><p></p><p></p><p></p><h1>四、要解决的问题</h1><p></p><p></p><p>寻找出一种算法，在团队间关于\"今天中午去哪儿吃？\"（Decrees），达成友好的共识。吃什么其实不那么重要，毕竟我们是要去增进\"感情\"的。所以一定要大家达成一致，不能两个人去吃面，三个人去吃米饭，这种\"分裂\"团队的事情，咱干不出来。</p><p></p><p>基于上面一点的目的，大家在表决的时候，也没有个人口味的倾向（能填饱肚子就行）。所以发起表决的人说吃啥，没有特殊情况，大家都会很捧场的说“我去”</p><p></p><p></p><h1>五、怎么解决</h1><p></p><p></p><p>Lamport从数学上证明了，如果用一种算法，它能满足了以下三点条件，就能很好地解决这个问题：</p><p></p><p>1）每一轮表决都有一个唯一的编号，且表决之前能通过编号进行大小比较。不要求表决是严格按照编号的顺序发起的；</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/7b/7b2c333f99e3edce10d6ac19c6ecf585.png\" /></p><p></p><p>2）任何两轮表决的参与人（在工位上的人）之间，至少有一个人是同一个人。例如第N轮表决有小A和小D参加，参与第M轮表决变成了我和小B、小C参加。这两轮表决找不出一个共同的人，这就违背了第2点条件；</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/7a/7a935271fb7b5abdee26fc1b9b926fe3.png\" /></p><p></p><p>3）对于任何一轮表决，如果参与表决的人在之前投过票。那么这一轮表决询问的餐馆，就必须是之前投过票的人里，最大的那轮表决询问的餐馆。</p><p></p><p>有点拗口，举个栗子。小B准备发起第三轮表决，参与表决的人有小A和小D。小A在第一轮发起过表决，问大家要不要吃面；小D在第二轮投过票，那一轮问的是要不要吃米饭。那么，按照第3点条件，小B发起的第三轮投票，只能问大家要不要吃米饭。（小A给第一轮的面投票了，发起的表决默认给自己投票了；小B和小D给第二轮的米饭投票了，所以参与第三轮表决的人，投过的票里最大那一轮是就是第二轮的米饭。）</p><p></p><p>这里又引出另外一个问题，如果参与这轮表决的人都没投过票（比如第一轮），那么随便问一家就好了。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ab/ab0b52fadecc907d456fddab40998a14.png\" /></p><p></p><p>只要我们不断地发起表决，每一轮表决都满足以上三点条件。那么直到某一轮表决，所有参与人都说了“我去”（不一定所有人都参与了这一轮表决，可能有的人不在工位上；参与的人也不一定都会说“我去”，可能有的人正在开会），我们能就今天中午去哪儿吃达成共识（具体的证明步骤放到本文最后）。</p><p></p><p>满足这三点条件的算法，只保证了安全性，但并不一定保证活性。所以有可能我们今天中午啥都吃不了。（Lamport提出了一种既满足安全性，又基本满足活性的实现方式，详情可参见附录中的\"完整教会协议\"）</p><p></p><p></p><h1>六、初步协议（The Preliminary Protocol）</h1><p></p><p></p><p>算法的三点条件只是“指导原则”，要细化到可落地、可执行的方式，还有很长一段路要走。不要慌，我们一点一点地“打穿”它。</p><p></p><p>为了满足算法的第一点条件，即“每一轮表决，都有一个唯一的编号。且表决之前能通过编号进行大小比较”。每个人记录都需要记下自己发起过的表决编号，这样在下次发起表决的时候，能保证编号在本人的范围内是唯一的（且可比较）；那么如何保证这个编号在所有人范围内都是唯一且可比较的呢？在表决的编号中加入每个人的唯一标识（名字、工号、身份证号等等），这个标识也是可以进行排序的，这样每个人都得到一个独立的表决号空间。举个栗子：(13，小A) &lt; (13, 小X) &lt; (15，小A)。</p><p></p><p>为了满足算法的第二点条件，即\"任何两轮表决的参与人（在工位上的人）之间，至少有一个人是同一个人\"。只需要参与每一轮表决的人数，大于总人数的一半即可；如果参与人数小于等于总人数的一半，那就不能发起这轮表决，或者说这轮表决无效。这个可以通过一个简单的反证证明，假设有两轮投票B和C，包含的人数都大于总人数 P 的一半，但是它们的参与者里面没有相同的一个人（即交集为空）。那么B的参与者的人数范围Pb &gt; P/2，C的参与者的人数范围Pc &gt; P/2，所以 Pb + Pc &gt; P；又因为假设中的B和C的参与者没有交集，所以P - Pc &gt;= Pb，即 Pb + Pc &lt;= P，这和前面的推导出的结论矛盾了，所以假设不成立。</p><p></p><p>为了满足算法的第三点条件，即\"对于任何一轮表决，如果参与表决的人在之前投过票，那么这一轮表决决定的餐馆，就必须是之前投过票的人里，最大的那轮表决询问的餐馆\"。就这一点，我们需要精心的设计整个表决的过程，以满足条件。</p><p></p><p></p><h2>6.1&nbsp;完整步骤</h2><p></p><p></p><p>1）小A先生成一个唯一的表决编号，假设是十。然后给每个在工位上的人说: \"我准备开始第十轮表决了\"（NextBallot）。（在这里用小A只是一个例子，任何人在任何时候都可以发起表决，甚至是并发地发起表决）；</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/a1/a1f79484ec7ca4f0f0cf940e3e50d9fe.png\" /></p><p></p><p>2）小B听到之后，可以回答小A: \"我参与第十轮表决，并且我在之前的第八轮表决中投了吃面\"（LastVote）。其他人亦是如此回答。在这里有一点很重要，就是回答了小A的人，都需要做出一个承诺（promise）：我不再回答上次投票的表决和这轮表决之前的其它询问。对于小B来说，就是当有人说\"我准备开始第九轮表决了\"的时候（不要觉得奇怪，算法只要求表决编号唯一且可比较，并没有要求是有序的），他不做任何回应，这样才能保证对A做出的回答是有效的。不然小B刚给小A说在第八轮投了吃面，转头就给第九轮投了米饭；</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/8d/8d03dc161bbf71d6a49cf675e8146f7e.png\" /></p><p></p><p>3）当小A从大多数人那里得到回答之后，他就可以将这些人圈定为参与本轮表决的人。并且从这些人的回答中，得到本次表决需要询问的餐馆，这样就能满足算法的第3点条件。在这里假设得到要问的是吃面。然后小A就可以正式开始表决了，他依次去问这些人：\"要不要去吃面\"（BeginBallot）；</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/8a/8a02e076abcde485f9ace731df1fb7ab.jpeg\" /></p><p></p><p>4）参与这轮表决的人，在听到小A问要不要去吃面后，根据自身情况决定要不要回答\"我去\"（Voted）。因为从第2步到现在，可能有其他人发起了第十一轮表决。大家的承诺可不保证不去回应更大轮次的表决，如果有人回应了更大的轮次并做出承诺，那么他在这里就不能说\"我去\"了；</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/3f/3f5b984df4e22e8971b1d1886279bdca.jpeg\" /></p><p></p><p>5）如果参与第十轮的所有人，都对小 A 说了\"我去\"，那么他就可以得出结论——今天中午去吃面。并且将这个消息（Success）奔走相告给团队里的每个人（不只是参与这轮投票的人）；</p><p></p><p>整个步骤有点像一个\"三阶段提交\"的过程，并且满足了算法的3点条件。再辅以数学上的证明，从而保证了算法的安全性。</p><p></p><p></p><h2>6.2&nbsp;可能出现的异常情况</h2><p></p><p></p><p>上一节完整的叙述了初步协议的正常步骤，那么这些步骤如果出现了异常，会对算法产生什么样的影响呢？</p><p></p><p>第1步中可能出现的异常情况：</p><p></p><p>在生成表决号时如果出现了问题，这轮表决就无法发起；如果在给其他人说\"准备开始表决\"的时候，只有小部分人在工位，或者大部分人都没听到。那么第3步的条件就无法达成，也不会有正事的表决。而听到且回应了的一小部分人，他们只是做出不投某些票承诺，并没有给这轮表决投票。</p><p></p><p>第2步中可能出现的异常情况：</p><p></p><p>接受人已经对别的表决做出承诺了（严格来说这不算异常情况）。这个就不予以回应，也不做出新承诺。当多个人并发尝试发起表决时，可能遇到这个情况。这个时候谁都没有法开展表决，就看谁能通过新的更大的表决号，先争取到大多数人的参与；接受人做出了承诺，但是他的回应没被发起人听到。如果只是小部分人，不影响第3步表决的正式开始；如果是大部分人，则打断第3步执行，不会正式开始表决。</p><p></p><p>第3步中可能出现的异常情况：</p><p></p><p>一直收不到大多数人的\"我参加……\"，那就一直不开始正式表决；提出的\"去不去xxx吃饭问题\"，没有被参与人听到。只要有一个参与人未听到这个问题，或为对这个问题做出回应，那么表决就没有结束。没有结束的表决，不会影响算法的安全性。</p><p></p><p>第4步中可能出现的异常情况：</p><p></p><p>\"我去！\"没被发起人听到。同3.b 。</p><p></p><p>第5步中可以出现的异常情况：</p><p></p><p>最后的结论，没有传达到所有人。那这些人会认为还没有达成共识，而继续发起表决。通过附录\"数学证明\"中的引理，可以保证后续的表决，会得到相同的结论。</p><p></p><p></p><h3>异常宕机</h3><p></p><p></p><p>如果某些人暂时离开，之后又回工位了，这对算法的安全性不造成影响（可恢复性宕机）。但是如果有人离开又回来之后，发现忘记了之前记录的承诺和投票，记录的小本本也不见了（不可恢复性宕机），这种情况下，这个算法就无法满足安全性。设想以下场景：</p><p></p><p>小A发起了第一表决，问大家要不要去吃面。小B和小C积极响应并且投了票。然后小B去阳台找小D和小X，回来之后小B把第一轮的事情给忘了。这个时候，小D想起还不知道中午吃啥，于是发起了第二轮表决，给小B和小X说他准备开始第二轮表决了，小B和小X回应小D说他们都没投过票，于是小D随机选了米饭正式表决。小B和小X也都说了“我去”。这个时候算法的安全性就被破坏了，小A和小C得到结论是去吃面，小B、小D和小X得到的结论是去吃米饭。</p><p></p><p></p><h3>网络分区</h3><p></p><p></p><p>如果出现了网络分区的情况（这是不可避免的），对应到例子里就是团队的5个人被临时分散到不同地方去开会了。这时会有两种情况：</p><p></p><p>1）每个分区都只包含少数人（不超过2人），那么算法的第2步和第4步都会卡住，从而影响算法的活性，但并不影响安全性；</p><p></p><p>2）（最多）有一个分区包含了大多数人（不少于3人），这个分区中的人能继续通过算法得出结论，而其他分区的人，只能等到网络恢复之后，通过新的表决来同步这个结论。</p><p></p><p></p><h1>七、写在最后</h1><p></p><p></p><p>Paxos算法的教会协议是一个单法令的协议，也就是说它只能就一件事情达成一致的决定。那么它有什么样的用途呢？如果将这个事情换成一个具体命令，就能联想到它的各种用法。比如将法令换成“谁来做Leader？”就可以用于选举；将法令换成“谁能持有这个资源的锁？”，就能用于分布式加锁。但是受限于“单法令”，有很多用法都只能完成一部分，而更为实用的多法令议会协议，是从教会协议衍生出来的，并且高度依赖教会协议中的算法。</p><p></p><p></p><h1>八、附录</h1><p></p><p></p><p></p><h2>8.1&nbsp;基础协议（The Basic Protocol）</h2><p></p><p></p><p>在初步协议中，每一个人都需要在小本本里，记下三个东西：</p><p></p><p>自己发起的所有表决的编号，以便再发起表决时，能生成一个新的唯一编号；自己的每一次投票，即在哪些轮的表决说了\"我去\"，还要记下这些表决问的是哪个餐馆；自己在初始协议的第2步回应之后，做出的承诺，白纸黑字记下来比较可靠。</p><p></p><p>需要记的东西着实有点多，多来几轮表决，多来几天，大本本都搞不定。所以机智的我（记住，这是一个虚构的故事）又登场了，我简化了初始协议，这样每个人只需要记录以下三个东西：</p><p></p><p>只用记下上一次发起的表决的编号；投过的票里，只用记下最大编号的那一轮表决的编号，和它问的餐馆；类似初始协议第2步的承诺，只用记下表决编号最大的承诺。比如我先回应了第十轮表决，做出来承诺；然后又回应了第十一轮表决，也做出了承诺。这个时候我可以把第十轮的承诺擦掉，记下第十一轮的承诺就行。</p><p></p><p>注意这里的区别：初始协议是需要几下每一个编号、每一次投票、每一个承诺，因为初始协议是运行并发地发起表决的；但是基础协议只需要记住一个编号、一次投票和一个承诺。所以……基础协议不允许并发地表决，一旦发现了过时的表决或者响应，都不予理睬；一旦发现了更新的表决或者响应，抛弃掉老表决的记录，转而响应更新的表决。简化后的基础协议具体步骤如下：</p><p></p><p>小A根据他记录的上一次发起的表决编号（记录的第一项内容），计算出一个新的表决编号b ，然后给每个在工位上的人说：\"我准备开始第b轮表决了\"。小B听到了小A的问题之后，发现这轮表决编号比他做过的承诺的表决编号（记录的第三项内容，比如说是九）还大，那么就回应小A说\"我参与第十轮表决，并且我在之前的第八轮（记录的第二项内容）表决中投了吃面\"，然后小B将记录的第三项从\"我给第九轮表决做出了承诺\"改成\"我给第十轮表决做出了承诺\"；反之如果小B记的承诺编号比十大，那就不回应小A。小A收到了大多数人的针对第十轮表决的回应之后，就可以正式开始表决，圈定参与人和选择询问的餐馆同初始协议的第三步一致。小A依次去问这些人，要不要去吃面。小A问到小B时，小B检查自己的小本本，如果发现第二项记录的承诺还是十，那就给小A说\"我去\"；否则就不回答小A。当参与表决的每一个人，针对第十轮的表决都说了\"我去\"，那么他就可以得出结论——今天中午去吃面，并且将这个结论奔走相告给团队里的每个人（不只是参与这轮投票的人）。团队里的每个人，一旦听到了小A宣布的结论，也都知道了今天中午去吃面。</p><p></p><p></p><h3>完整教会协议（The Complete Synod Protocol）</h3><p></p><p></p><p>基础协议同初步协议一样，保证了一致性，但是并不保证一定能达成决定。所以为了能尽早达成一致的决定（看来大家还是不喜欢挨饿的），完整协议在保持基础协议6个步骤的同时，除了要求每个人都能积极执行或响应第2~6步，更重要的是完整协议规定了大家在什么时候发起表决（第一步）。</p><p></p><p>为什么何时发起表决很重要？因为存在以下情况，会导致大家一直都没法达成决定：</p><p></p><p>一直没有人来发起表决，当然也没法达成决定。太多人持续发起新表决，也可能没法达成决定。基础协议只能串行处理表决，每次发起了更新的表决，都会将可能正在进行中的表决中断。</p><p></p><p>这就要求我们必须要发起新的表决，但是又不能太频繁的发起新的表决（就是这么矛盾）。为了解决这个问题，完整协议增加了一个选生活委员的前置步骤。</p><p></p><p>如何选出这个生活委员呢？最简单的一个办法就是选还在工位上的工号最小的那个，可行的步骤如下：</p><p></p><p>每个还在工位的人，每隔5分钟就告诉其他人自己的工号是多少。小A跟小B、小C说自己的工号是123456，小B跟小A、小C说自己的工号是654321，小C跟小A、小B说自己的工号是 55555；然后每个人每过10分钟就检查一下，看下之前10分钟有没有听到别人的工号比自己小的。如果有，那就证明自己当选生活委员无望；如果没有人工号比自己的小，那就恭喜自己当选了，可以发起新一轮的表决了；在这个10分钟的检查期内：如果小X又回到工位，然后跟小A、小B、小C说自己的工号是11111，那么小A就知道自己无望当选了；但是如果这时小A离开了工位，那么小B和小C什么也不会做，等到下一个10分钟再看；</p><p></p><p>小A当选了生活委员之后，需要做些什么呢？</p><p></p><p>1）首先是先发起新一轮的表决；</p><p></p><p>2）其次，如果在执行第三步或第五步的时候，过了很久（可能是有人离开工位了；也有可能是一个工号更小的人回了工位，认为自己当选了生活委员，发起了更新的表决）都没有收到大家的响应，那么就需要重新发起新的一轮表决（前提是他还当选着）；</p><p></p><p>3）此外，为了避免新发起的表决，一开始过时了（小A发起了第十轮表决，但在此之前，小B已经给第十一轮表决承诺了），所以小A需要从其他人那儿了解到他们做出的承诺，并以此来调整自己之后发起表决的编号。有两种方式：</p><p></p><p>在初步和基础协议的第二和第四步中，遇到这种情况，小B不会给小A任何回应。但是到了完整版协议中，小B会告诉小A：\"我不参加第十轮投票了，因为我已经给了第十一轮承诺\"，或者是：\"我不能确定要不要去吃面，因为我已经给了第十一轮承诺\"。这样小A就知道自己的第十轮表决是过时的，转而去发起第十二轮表决。每个人隔段时间都告诉其他人，自己发起过的最大一轮表决编号是多少。比如小C每过5分钟就告诉小A和小B，自己之前发起过第十一轮表决。等到小A当选生活委员的时候，就会跳过第十轮表决，发起第十二轮表决。</p><p></p><p>完整协议的很多步骤，都强依赖时间（即每个一段时间做XX事情），但它并不要求这个时间完全精确，只要在可接受的范围内即可。</p><p></p><p></p><h2>8.2&nbsp;证明过程</h2><p></p><p></p><p>(这一部分有点烧脑，对证明过程不感兴趣的话可以略过)</p><p></p><p>前面提到了，我们只要满足算法的三点条件，就能达成一致的决定。这并不是随便说说的，下面给出了完整的数学证明：</p><p></p><p>如果我们的所有表决，都满足算法的三点条件的情前提下。假设参与的小A、小B和小C都在第十轮表决，问大家去不去吃米饭，说了\"我去\"（按照算法，此时已达成了去吃米饭的一致决定）。</p><p></p><p>这里的证明用下反证法：假设第十轮之后的表决中（也满足算法的三点条件），还有表决在问大家要不要去吃面。基于这个假设成立的结论，我们一步一步地推导下去：</p><p></p><p>首先从第十轮之后，问去不去吃面的表决中，取最早的一轮表决C。因为我们的假设，所以C一定存在；C的轮次肯定大于第10轮。很显然成立，因为我们就是这么假设的；第十轮里投票的人，和C轮里参与的人，至少有一个相同的人。这也很显然也成立，因为所有的表决，都必须满足算法的第2点条件；参与C轮表决的人中，之前投过票的最大表决M，那么M的轮次 &gt;= 十。参与C轮表决的人可以分为两组：第一组是参与过第十轮投票的人，因为算法的第2点条件，这组里面一定有人，所以这一组的M1 &gt;= 十（如果他们后面又投票，M1就大于十）；第二组是没参加过第十轮投票的人，这一组可能没人，有可能只在第十轮前投过票，也有可能只在第十轮之后投过票，更有可能部分人第十轮前投票，部分人第十轮之后投票，所以这一组的M2可以是小于C轮次的任意值。然后两组再取其大，M = Max(M1, M2) &gt;= 十；M也是算法的3点条件的，这是我们的前提；所以，M问的餐馆和C问的餐馆是一样的，也就是去吃面。因为M和C轮表决都满足算法的第3点条件；M问的餐馆和第十轮问的餐馆不一样。根据上面一步推导，M轮问的是吃面，第十轮问的是米饭；M的轮次必定大于十。这个比第4步推导更进了一步，消除了等于这种情况。因为第7步，我们得出M和第十轮问的餐馆不一样，又因为算法的第一点条件（每轮投票都有唯一的编号），可以推导M的轮次不等于十；因为第7、8步的推导，和初始假设成立的结论，得出M是一个在第十轮之后，问大家要不要去吃面的表决；M的轮次一定是小于C的轮次的，因为根据第4步，M的定义就是\"参与C轮表决的人中，之前投过票的最大表决\"；矛盾出现了。C的定义在第1步中的定义是\"第十轮之后，问去不去吃面的表决中，最早的一轮表决\"，而M根据第9步的推导，它是\"第十轮之后，问大家要不要去吃面的表决\"，又因为第10步我们得出\"M的轮次一定是小于C的轮次的\"，这三点是冲突的。</p><p></p><p>所以通过反证法和这11步推导得出的矛盾，我们的初始假设不成立。\"假设第十轮之后的表决中（也满足上面的三点条件），还有表决在问大家要不要去吃面\" 这个假设不成立。换句话说，通过我们的证明，得出了一个引理（Lemma）：</p><p></p><p>所有表决都满足算法的3点条件的情况下，在表决投票得出一致的餐馆后，后续的表决中不会再问出要不要去其它餐馆的问题了。</p><p></p><p>通过这个引理，我们还能够得出其他两个定理（Theorem）：</p><p></p><p>定理一：所有表决都满足算法的三点条件的情况下，任何两轮成功的表决（所有参与表决的人都投了票），它们问的餐馆是一样的；</p><p></p><p>定理二：在已有表决都满足算法的三点条件的情况下，在后续新开展的表决中，一定存在满足算法的3点条件且成功的表决。算法虽然不保证一定能达成决定，但通过这点至少能证明满足三点条件之后，不会死锁。</p><p></p><p>定理二的证明过程如下，假设满足定理的表决为B，那么：</p><p></p><p>可以通过很多已有算法（雪花算法）来选择一个比已有轮次都更大，且唯一的B的轮次。这样B就满足了算法的第1点条件；只要每一轮表决（已有的和B），都选择所有人中的大多数（参与人数大于总人数的一半，例子中即3人），那么B的参与者也能够满足算法的第二点条件；如果参与B的人之前都没投过票，那么B可以随便决定那个餐馆；如果参与B的人之前投过票，那么B问的餐馆就是这些人之前投票的最大一轮表决问的餐馆。这样B就满足了算法的第三点；又因为背景中的设定，每个人没有口味偏好，一般情况下参与了表决，就会投票。所以经历足够多轮的表决之后（每一轮都按照以上三点，定出一个满足算法的B），总能有一轮表决参与的人都投了票，从而让这轮是一轮成功的表决。</p>",
    "publish_time": "2023-06-13 09:50:56",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "可观测的崭新进化：加速CI/CD管道的秘密武器",
    "url": "https://www.infoq.cn/article/lPSPNxwMD2US2WEHamr4",
    "summary": "<p>持续集成（CI）管道已经成为软件开发团队非常重要、甚至是无处不在的一部分，这是因为它们为团队带来的价值，即能够在不同层面上持续测试代码并自动化许多复杂的部署过程。如果你想获得最大的价值，仅仅有一个CI管道还不够。</p><p></p><p>如何跟踪CI管道和流程的有效性最好？如何确保管道实际交付的软件达到了应有的质量水平，而不是默认它会成功？如何更好地利用管道来排除软件问题，并使不同的应用程序更有效地运行？</p><p></p><p>只要我们实现有效的监控和可观察性，CI管道就可以提供所有这些问题的答案。要做到这一点，首先需要解决以下问题：</p><p>在涉及CI管道时，需要了解可观察性的哪些方面？如何在管道中配置这种监控？为了更好地理解CI管道和软件应用程序，应该监控哪些指标？如何更好地可视化这些指标？</p><p></p><p>在本文中，我们将探讨其中的许多问题，让你可以借助可观察性来更好地利用CI管道。虽然在本文中，我们将介绍团队应该努力培养的几项重要特质，但你也要认识到，每个团队和软件应用程序都是不同的，这一点很重要。你可能需要根据团队的具体需求进行调整。同样，本文探讨的大多数技术解决方案都涉及到像InfluxDB和Grafana这样的工具，并展示了如何通过它们配置各种仪表板。你的团队可能使用了不同的工具，但在很大程度上，这些原则还是适用的。你可能需要针对特定的工具集，研究下如何更好地实现相同的结果。</p><p></p><p></p><h2>可观察性技术面面观</h2><p></p><p></p><p>CI管道中有几个关键的可观察性组件，包括监控、日志记录和跟踪。</p><p></p><p>监控是指对管道操作的持续跟踪，包括各个阶段的性能、构建和部署的状态以及管道的总体健康状况。这可以借助各种工具来实现，比如Prometheus和Grafana。它们可以提供管道的实时可见性，并提醒开发人员可能出现的任何问题。</p><p></p><p>日志记录是指收集和存储来自管道的日志数据，包括与构建、部署和管道性能有关的信息。这些数据可以用于故障排除和根因分析，并且可以存储在集中式的日志管理系统（如ELK或Splunk）中，便于访问和分析。</p><p></p><p>跟踪是指跟踪通过管道的请求或事务流的能力，从开发到生产。这可以通过跟踪工具来完成，例如Jaeger或Zipkin。它们可以提供关于管道各个阶段的详细信息，包括每个阶段所花费的时间、使用的资源以及可能发生的任何错误。</p><p></p><p>总的来说，CI管道的可观察性对于保持管道的可靠性和有效性至关重要，而且让开发人员可以快速识别和解决可能出现的任何问题。这可以通过组合使用监控、日志记录和跟踪工具来实现。这些工具可以提供管道的实时可见性，并帮助进行故障排除和根因分析。</p><p></p><p>除此之外，你还可以使用应用程序性能管理（APM）解决方案这样的可观察性工具，如New Relic或Datadog。APM提供了整个应用程序和基础设施的端到端可见性，可以帮助开发人员识别管道中的瓶颈、性能问题和错误。</p><p></p><p>值得注意的是，可观察性应该集成到整个管道中，从开发到生产，保证任何问题都能被快速有效地识别和解决。</p><p></p><h2>CI管道的监控如何配置最好？</h2><p></p><p></p><p>关于这一部分，最困难的部分也许是如何选择恰当的工具。可供选择的工具有很多，每种工具都有各自的优缺点，本文就不展开介绍了。我建议你多花些时间和精力，研究一下市场上存在的不同工具，看看哪些工具与你现有的技术栈、预算和技能集最匹配，然后尝试不同的选项，看看哪些适合你。</p><p></p><p>像Prometheus、Grafana和ELK技术栈（Elasticsearch、Logstash、Kibana）这样的工具是CI管道监控中比较流行的选项。不过，我们在决策的时候不能只看哪些工具提供了最好的监控可视化以及哪些工具提供了最好的报告或预警功能，还要看哪些工具能更好地收集数据，这也许更重要。</p><p></p><p>以下是配置数据收集和管道流程的关键步骤，你可以从这些方面比较各种工具：</p><p>从多个数据源收集数据：这包括构建过程、测试过程和部署过程，可以提供管道性能的完整视图。将数据集中存储：利用数据仓库或集中式日志记录系统，方便日志访问和分析。使用API自动收集数据：使用API从管道和其他数据源（如代码存储库和问题跟踪系统）收集数据。这样就可以轻松地与其他工具和系统集成，实现比较简单的自动化，在不需要人工干预的情况下提取数据。使用日志记录和监控框架：可以使用Logstash和Prometheus等框架来收集和分析数据。它们为数据收集、存储和分析提供了内置支持。使用数据可视化工具：在将数据收集到集中式存储后，就该研究可视化数据的方法了（将在下文讨论）。使用数据可视化工具，如Grafana或Tableau，可以获得相对更容易理解的格式，简化趋势识别，并基于特定的数据需求和模式进行过滤。设置预警：设置预警机制，以便在管道出现问题时发送通知，包括团队聊天工具、Slack频道、电子邮件、短信，在PagerDuty等事件管理工具中创建事件，甚至将事件记录到JIRA等问题管理工具中。跟踪数据保留策略：我们正在讨论的是收集所有这些数据，但如果最终只是不断地存储所有数据，并不能带来什么帮助。虽然拥有大量的数据有用，但成本很高，而且可能会降低系统的性能，并成为一种阻碍。跟踪数据保留策略，并确保数据保存足够长的时间以供分析及满足合规性要求。持续监控和优化：不用说，数据收集了，也可视化了，现在要做的是持续监控管道，并在必要时做出调整，包括调整数据收集配置、添加新的数据点以及优化管道、提升性能。</p><p></p><h2>如何通过管道推送数据？</h2><p></p><p></p><p>有许多方法可以将数据从CI管道推送到数据源，具体的方法取决于数据源和你正在使用的CI工具。下面是一些使用代码将数据从管道推送到数据源的示例。</p><p></p><h3>借助REST API</h3><p></p><p></p><p>许多数据源都提供REST API，允许我们使用HTTP请求将数据推送到数据源。例如，可以使用Python的requests库向REST API端点发送POST请求，将数据推送到数据源。</p><p></p><p>示例：</p><p><code lang=\"text\">import requests \ndata = {'key1': 'value1', 'key2': 'value2'} \nresponse = requests.post('https://example.com/data', json=data)</code></p><p></p><p></p><h3>借助SDK</h3><p></p><p></p><p>有些数据源会提供SDK或客户端库，可用于将数据推送到数据源。例如，可以使用AWS SDK For Python（boto3）将数据推送到Amazon S3桶。</p><p></p><p>示例：</p><p><code lang=\"text\">import boto3 \ns3 = boto3.client('s3') \ns3.put_object(Bucket='my-bucket', Key='data.json', Body=data)</code></p><p></p><p></p><h3>借助命令行工具</h3><p></p><p></p><p>有些数据源提供可以将数据推送到数据源的命令行工具。例如，可以使用curl命令将数据推送到REST API端点。</p><p></p><p>示例：</p><p><code lang=\"text\">curl -X POST -H \"Content-Type: application/json\" -d '{\"key1\": \"value1\", \"key2\": \"value2\"}' https://example.com/data</code></p><p></p><p></p><h3>借助数据管道工具</h3><p></p><p></p><p>有些数据源提供数据管道工具，可用于将数据推送到数据源。例如，可以使用Apache NiFi将数据推送到数据湖。</p><p></p><p>这些示例非常基础，但应该也可以让你有一个基本的了解。在此基础上，团队可以着手从CI管道中将数据提取到目标数据源。</p><p></p><p>下面是一个完整的示例代码，使用Typescript在CI管道中设置数据存储，并将相关结果推送到数据存储中。在这个例子中，考虑到其可配置性和低成本，我们使用了</p><p><code lang=\"text\">import { config as dotenv } from 'dotenv';\nimport * as influxDB from 'influx';\n\nlet dbName: string;\nlet connection: influxDB.InfluxDB;\n\nexport async function streamMeasurement(\n  measurement: string,\n  points: influxDB.IPoint[]\n): Promise {\n  if (connection == null) {\n    dotenv({ path: '.influxconfig' });\n\n\n    dbName = process.env.INFLUXDB_METRICS_DBNAME;\n    if (dbName == null) {\n      return;\n    }\n\n    await createConnection();\n    await createDatabase();\n  }\n\n  await connection.writeMeasurement(measurement, points);\n}\n\nexport async function executeQuery(\n  influxQl: string\n): Promise&gt; {\n  await createConnection();\n  return connection.query(influxQl);\n}\n\nasync function createConnection(): Promise {\n  dbName = process.env.INFLUXDB_METRICS_DBNAME;\n  const host = process.env.INFLUXDB_METRICS_HOST;\n  const port = process.env.INFLUXDB_METRICS_PORT;\n\n  connection = new influxDB.InfluxDB(`http://${host}:${port}/${dbName}`);\n}\n\nasync function createDatabase(): Promise {\n  dbName = process.env.INFLUXDB_METRICS_DBNAME;\n  const dbNames = await connection.getDatabaseNames();\n\n  if (dbNames.includes(dbName)) {\n    return;\n  }\n\n  await connection.createDatabase(dbName);\n  await connection.createRetentionPolicy(dbName, {\n    duration: '700d',\n    database: dbName,\n    replication: 1,\n    isDefault: true,\n  });\n}\n</code></p><p></p><p></p><h2>通过CI管道可以度量哪些指标？</h2><p></p><p></p><p>通过CI管道，我们可以捕获许多不同类型的指标。为了获得最可靠、最有价值的结果，你可能希望在CI管道的不同阶段度量不同的东西。</p><p></p><p>指标清单也可能非常详尽，但要注意，不要想着什么都度量，那会导致分析瘫痪。团队访问了大量的信息，但却无法理解关注哪些指标才有助于他们理解、处理或纠正某些问题，经常会出现未能有效完成工作的情况。</p><p></p><p>注意，下面列出的具体指标只与CI过程相关。度量应用程序性能之类的东西也很重要，也应该做，只不过不应该作为CI过程的一部分。</p><p></p><p>以下是需要跟踪的最重要的指标：</p><p>构建时间：该指标度量完成构建所需的时间，即从构建流程开始到完成测试所耗费的时间。我们可以用它来识别缓慢的构建时间，并以此为基础优化构建管道，提升构建速度。测试通过率：该指标度量在构建过程中测试通过的百分比。我们可以用它来识别不可靠的测试，并提高代码的整体质量。安全扫描结果：任何管道都应该有某种形式的静态分析，检查代码中任何已知的漏洞或不受支持的包。虽然这个问题似乎微不足道，因为任何具有重大漏洞的pull请求都可能会失败，但仍然需要跟踪不同的安全风险，并确保识别出的风险确实是风险。部署频率：该指标度量将代码部署到生产环境的频率。我们可以用它识别管道的瓶颈并优化部署过程。失败率：该指标度量构建或部署失败的百分比。我们可以用它识别管道中存在的问题，并优化流程，减少故障。平均恢复时间（MTTR）：该指标度量应用程序从故障中恢复所需的时间。我们可以用它识别管道中存在的问题并优化流程，加快恢复速度。资源利用率：这类指标度量底层系统资源（如CPU、内存、磁盘或网络带宽）的使用情况。我们可以用它识别管道的瓶颈，并优化流程以便更好地利用资源。代码质量指标：这类指标度量代码的质量，例如Bug数量、代码复杂性、可维护性和测试覆盖率。我们可以用它识别管道中存在的问题，提高代码的整体质量。用户参与度指标：该指标衡量用户如何与系统交互，例如活动用户数、响应时间或错误率。我们可以用它识别管道中存在的问题，并优化流程，提升用户参与度。</p><p></p><p>务必要记住，并不是所有的指标对所有的管道都同样重要，这要视管道和组织的特定需求而定。选择与管道和组织目标最相关的指标，这很重要。</p><p></p><p></p><h2>数据可视化工具</h2><p></p><p></p><p>在详细讨论数据可视化的方法之前，我想简单地介绍一些一般来说最适合CI可观察性的可视化工具。并不是只有这些工具，但由于它们在处理大量数据时用起来比较简单，比较容易与各种旨在跟踪CI管道的工具集成，而且还具备可重配置能力，所以它们是使用最广泛的工具。</p><p></p><p></p><h3>GrafanaGrafana</h3><p></p><p></p><p>是一个开源的仪表板和可视化工具，可用于显示来自各种数据源（包括Prometheus、InfluxDB、Graphite、Elasticsearch等）的指标。我们可以用它创建自定义仪表板和预警，它内置了各种可用于显示管道指标的面板和插件。</p><p></p><p></p><h3>KibanaKibana</h3><p></p><p></p><p>是一个开源的数据可视化和探索工具，是Elastic Stack的一部分。它可以用来显示来自Elasticsearch的指标，也可以用来创建自定义可视化和仪表板。你还可以用它搜索及探索数据，并设置预警。</p><p></p><p></p><h3>DatadogDatadog</h3><p></p><p></p><p>是一个基于云的监控和分析平台，可用于显示来自各种数据源的指标，包括代理、集成和API。你可以用它创建自定义仪表板，设置预警，以及显示管道指标。</p><p></p><p></p><h3>New RelicNew Relic</h3><p></p><p></p><p>是一个基于云的性能监控和分析平台，可用于显示来自各种数据源的指标，包括代理、集成和API。你可以用它创建自定义仪表板，设置预警，以及显示管道指标。</p><p></p><p></p><h3>PrometheusPrometheus</h3><p></p><p></p><p>是一个开源的监控和预警系统，可用于从各种数据源收集以及存储指标。它还提供了一个内置的可视化和探索工具，名为Prometheus Web UI，可用于显示管道指标。</p><p></p><p>其中许多工具都有的一个好处是，它们可以使用HTML或JSON结构来传递信息，这意味着你可以轻松地分发或扩展仪表板，让它在不同的领域中发挥作用，而不需要什么都从头开始构建。</p><p></p><p>下面是一些JSON脚本的示例，完全用代码配置Grafana仪表板。（注意，<a href=\"https://github.com/CraigRisiAG/grafana-dashboarding/blob/main/performance.json\">实际的文件</a>\"相当大，为了让代码看起来简单些，这里只显示了一小部分）。</p><p></p><p><code lang=\"javascript\"> \"description\": \"A dashboard for visualizing results from the k6.io load testing tool, using the InfluxDB exporter.Based on https://grafana.com/dashboards/4411\",\n  \"editable\": true,\n  \"gnetId\": 10660,\n  \"graphTooltip\": 0,\n  \"id\": 18,\n  \"iteration\": 1607358257072,\n  \"links\": [],\n  \"panels\": [\n    {\n      \"cacheTimeout\": null,\n      \"colorBackground\": true,\n      \"colorValue\": false,\n      \"colors\": [\n        \"rgba(86, 166, 75, 0.5)\",\n        \"rgba(242, 204, 12, 0.5)\",\n        \"rgba(224, 47, 68, 0.5)\"\n      ],\n      \"datasource\": \"k6\",\n      \"decimals\": 2,\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"custom\": {}\n        },\n      },\n      \"format\": \"ms\",\n      \"gauge\": {\n        \"maxValue\": 100,\n        \"minValue\": 0,\n        \"show\": false\n      },\n      \"gridPos\": {\n        \"h\": 3, \"w\": 4, \"x\": 0, \"y\": 0\n      },\n      \"height\": \"50px\",\n      \"id\": 16,\n      \"interval\": null,\n      \"links\": [],\n      \"mappingType\": 1,\n      \"mappingTypes\": [\n        {\n          \"name\": \"value to text\",\n          \"value\": 1\n        },\n        {\n          \"name\": \"range to text\",\n          \"value\": 2\n        }\n      ],\n      \"maxDataPoints\": 100,\n      \"nullPointMode\": \"connected\",\n      \"nullText\": null,\n      \"postfixFontSize\": \"50%\",\n      \"prefixFontSize\": \"50%\",\n      \"rangeMaps\": [\n        {\n          \"from\": \"null\",\n          \"text\": \"N/A\",\n          \"to\": \"null\"\n        }\n      ],\n….\n      ],\n      \"thresholds\": \"1000,2000\",\n      \"title\": \"Response Minimum\",\n      \"type\": \"singlestat\",\n      \"valueFontSize\": \"80%\",\n      \"valueMaps\": [\n        {\n          \"op\": \"=\",\n          \"text\": \"N/A\",\n          \"value\": \"null\"\n        }\n      ],\n      \"valueName\": \"min\"\n    },</code></p><p></p><p>如何可视化这些指标？这个主题也涉及许多不同的选项，因为有许多显示各种指标的方法。有些工具提供了许多内置的指标和仪表板，简化了我们的工作。尽管如此，考虑到不同软件需求的多样性，对于组织来说，最好是针对自己的具体情况组合仪表板。</p><p></p><p>以下是一些重要的建议：</p><p>保持简单：使用简单、易于理解的可视化，如柱状图、折线图和饼图，而不是复杂或不好解释的可视化。合理搭配颜色：合理搭配颜色突出数据及重要的趋势或模式。使用标签和注释：使用标签和注释来帮助解释数据，使用户更容易理解数据所代表的内容。使用实时数据：使用实时数据来显示最新信息，让用户可以查看数据如何随时间而变化。保持设计一致性：保持设计一致性，方便用户理解数据，并确保可视化易于阅读和解释。使其易于访问：确保所有用户都可以访问可视化，包括那些有视觉障碍或色觉缺陷的用户。</p><p></p><p>最重要的是要记住，设法跟踪关键指标和预警。许多团队会将一些好看的仪表板组合在一起，让其看起来很有用，提供了大量信息，但可观察性的目的是为了维护和监控管道的有效性，而不是为了好看。</p><p></p><p>举例来说，在一个好看的时间轴图中可视化每个管道作业的数据很简单，但是如果你的管道每天在不同的构建和环境中运行多次，那么信息将很快变得让人不堪重负，难以有效地可视化。相反，你可以将管道通过率和运行时间作为一个指标来展示，然后使用图形来可视化有问题的管道，从而更好地了解那里发生了什么。</p><p>&nbsp;</p><p>可视化还有助于快速识别醒目的内容，但不一定会为你提供排查某个情况所需的所有信息。这时，上文提到的日志就变得很重要了，它能够在你需要时提供更具体的数据。</p><p>&nbsp;</p><p>下面是一些仪表板示例，可以帮你很好地可视化CI管道。这些仪表板都是在Grafnan中创建的，不过这类可视化也可以在其他工具中展示。可以看出，我们要根据自己的需求配置仪表板的外观，而不仅仅依赖于作用有限的通用仪表板模板。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/64/643b21a599a32f67a421161e811ac32c.jpeg\" /></p><p></p><p>&nbsp;</p><p>如果你想分析趋势，那么上面的仪表板构思可能非常有用。有一些图形表盘带颜色，但重点是分析仅仅在趋势分析时才经常见到的低谷和异常值。这一点很重要，因为如果你的指标基于简单的通过率或平均性能，那么总体值可能看着还不错，但你可能会错过不频繁，但从长远来看又可能非常重要的峰值。尤其是规模很大的时候。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b5/b533cf658e3493a4382b2617bd4cddbe.jpeg\" /></p><p></p><p>&nbsp;</p><p>这个仪表板示例提供了视觉效果和信息的良好组合。并不是所有的东西都要显示在图上，有时只需以文本或数字格式提供所有你真正需要知道的信息，并且让你可以通过颜色分级来了解需要注意的内容。如果需要特定的图表或趋势，也可以使用它们。让你看到所需的数字，而不被数据压垮，这是一种可以确保事情健康发展的简单方法。当数字令人担忧时，你还可以设置预警触发策略。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/1e/1e1357d74d51a708e709afac2ed9e8d1.jpeg\" /></p><p></p><p>&nbsp;</p><p>下面这个仪表板构思融合了各种可视化技术，包括易于阅读的数字和彩色编码，可以突出这些数字相对于预定基准的健康状况，同时，它还使用了一些图形可视化来更清晰地展示问题。它很好地混合了不同的技术，提供了有趣的信息。不过，可能有人会认为，右下角的管道持续时间图可能显示的信息太多，应该只显示有问题的管道，而不是尝试显示所有内容。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ab/abcd334e92dfe47375030816089df337.jpeg\" /></p><p></p><p>&nbsp;</p><p>这个仪表板做的事情可能太多了。这里的信息跟踪了运行管道作业的服务器的性能，虽然非常详细且进行了可视化，但要了解具体问题可能在哪里却很困难。对于调试性能问题，这样的信息或许有用，但由于数据太多，所以很难将其与正在发生的事情联系起来，因而团队很可能无法集中精力寻找问题。</p><p>&nbsp;</p><p>所有这些信息都应该为你在管道中尝试和实现可观察性提供一个入手点。可供选择的方法有很多，重要的是，作为一个团队和公司，你要设法确定最适合自己的信息和策略，以及一个在前进的过程中完善和改进一切的目标。如果你愿意改进和完善，那么最终不仅可以获得合适的CI管道监控，而且还可以获得提高其利用率所需的信息。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/ci-cd-observability/\">https://www.infoq.com/articles/ci-cd-observability/</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/minibook/Q4eHZELtNaUvfZJV7lrK\">中国企业研发高效能白皮书-CI/CD篇</a>\"</p><p><a href=\"https://www.infoq.cn/article/14QYNmR7oJ3S07jLBXQt\">CI/CD 流水线创建方法：Monad、Arrow 还是 Dart ？</a>\"</p>",
    "publish_time": "2023-06-13 09:57:24",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]