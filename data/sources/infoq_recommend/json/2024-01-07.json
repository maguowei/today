[
  {
    "title": "Java架构师：ASM已经过时，建议使用类文件API简化开发",
    "url": "https://www.infoq.cn/article/QSeBA9fQ21JrVPx0y6pa",
    "summary": "<p>JEP 457，<a href=\"https://openjdk.org/jeps/457\">类文件API(Class-File API，预览)</a>\"，最近已经集成到了JDK 22中。该JEP建议提供一个API来解析、生成和转换Java类文件。它最初将作为JDK中Java字节码操作和分析框架<a href=\"https://asm.ow2.io/\">ASM</a>\"的内部替代品，并计划将其作为公共API开放。甲骨文的Java语言架构师<a href=\"https://www.linkedin.com/in/briangoetz\">Brian Goetz</a>\"将ASM描述为“带有大量遗留包袱的旧代码库”，并提供了关于该草案将如何发展并最终取代ASM的<a href=\"https://mail.openjdk.org/pipermail/discuss/2022-June/006131.html\">背景信息</a>\"。</p><p>&nbsp;</p><p>类文件API的核心是几项关键原则。首先，它将类文件实体（比如字段、方法、属性和字节码指令）均视为不可变对象。这种不可变的表述确保在类文件转换时可以可靠地进行共享。该API采用树形结构来反映类文件的层次结构，从而支持用户驱动的导航以进行高效地解析。它还强调了解析过程的延迟性，即只会处理满足用户需求所需的类文件。</p><p>&nbsp;</p><p>类文件API位于java.lang.classfile包及其子包中，包含三个主要的抽象，即元素、构建器和转换。元素是类文件组件的不可变描述。构建器对应于每种复合元素，可以使用特定的构建方法来方便地构造类文件。转换表示在构建过程中修改元素的函数。</p><p>该API还引入了使用模式解析类文件的新方法，与ASM基于访问者（visitor）的方式有所不同。这支持更直接和更简洁的表达式，利用了Java的模式匹配功能。例如，开发人员可以遍历CodeModel中的指令，并匹配感兴趣的元素，以完成像依赖图构造这样的任务。</p><p>&nbsp;</p><p>考虑如下的样例：</p><p><code lang=\"null\">CodeModel code = ...;\nSet deps = new HashSet&lt;&gt;();\nfor (CodeElement e : code) {\n    switch (e) {\n        case FieldInstruction f  -&gt; deps.add(f.owner());\n        case InvokeInstruction i -&gt; deps.add(i.owner());\n        // ... and so on for instanceof, cast, etc ...\n    }\n}</code></p><p>这个代码片段展示了使用模式匹配来解析Code属性以收集类依赖关系图的依赖，迭代指令并匹配特定的类型。</p><p>&nbsp;</p><p>使用构建器生成类文件是另一项关键特性。该API颠覆了使用构造函数或工厂创建构建器的传统习惯，相反，客户端提供一个接受构建器的lambda。这种方法提供了更具体和透明的代码生成，并且可以重放操作序列。它还为管理块范围、局部变量索引计算和标签管理提供了更高级的便利性。</p><p>&nbsp;</p><p>下面的代码展示了如何使用构建器生成方法，演示了该API具体且透明的代码生成方式。</p><p><code lang=\"java\">ClassBuilder classBuilder = ...;\nclassBuilder.withMethod(\"fooBar\", MethodTypeDesc.of(CD_void, CD_boolean, CD_int), flags,\n    methodBuilder -&gt; methodBuilder.withCode(codeBuilder -&gt; {\n        Label label1 = codeBuilder.newLabel();\n        Label label2 = codeBuilder.newLabel();\n        codeBuilder.iload(1)\n            .ifeq(label1)\n            .aload(0)\n            .iload(2)\n            .invokevirtual(ClassDesc.of(\"Foo\"), \"foo\", MethodTypeDesc.of(CD_void, CD_int))\n            .goto_(label2)\n            .labelBinding(label1)\n            .aload(0)\n            .iload(2)\n            .invokevirtual(ClassDesc.of(\"Foo\"), \"bar\", MethodTypeDesc.of(CD_void, CD_int))\n            .labelBinding(label2)\n            .return_();\n    });</code></p><p>类文件的转换功能同样值得注意。解析和生成方法保持了一致，这样转换可以无缝进行。例如，开发人员可以处理一个类，以便于删除特定的方法，或者通过应用各种转换来改变方法体。</p><p>&nbsp;</p><p>下面的代码片段展示了API的转换类文件的功能，演示了在转换过程中如何有选择地修改或替换类元素。</p><p><code lang=\"java\">ClassFile cf = ClassFile.of();\nClassModel classModel = cf.parse(bytes);\nbyte[] newBytes = cf.transform(classModel, (classBuilder, ce) -&gt; {\n    if (ce instanceof MethodModel mm) {\n        classBuilder.transformMethod(mm, (methodBuilder, me)-&gt; {\n            if (me instanceof CodeModel cm) {\n                methodBuilder.transformCode(cm, (codeBuilder, e) -&gt; {\n                    switch (e) {\n                        case InvokeInstruction i\n                                when i.owner().asInternalName().equals(\"Foo\") -&gt;\n                            codeBuilder.invokeInstruction(i.opcode(), ClassDesc.of(\"Bar\"), \n                                                          i.name().stringValue(),\n                                                          i.typeSymbol(), i.isInterface());\n                        default -&gt; codeBuilder.with(e);\n                    }\n                });\n            }\n            else\n                methodBuilder.with(me);\n        });\n    }\n    else\n        classBuilder.with(ce);\n});</code></p><p>JEP 457具有变革性的一个方面是如何解决Java生态系统中类文件格式的快速发展所带来的挑战。通过提供与JDK一起演进的标准API，它能够确保使用该API的框架和工具会自动支持来自最新JDK的类文件。这种能力对于新语言和VM特性非常重要，它们在类文件中可能会有相应地表述。</p><p>&nbsp;</p><p>总之，JEP 457的类文件API是一种具有前瞻性的解决方案，符合Java开发的现代化需求。它的设计原则、抽象和转换功能使其成为Java开发人员的强大工具，增强了Java生态系统中类文件管理的效率和可靠性。</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/12/jep-457-new-class-file-api/\">&nbsp;JEP 457: Streamlining Java Development with the Class-File API</a>\"</p>",
    "publish_time": "2024-01-07 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]