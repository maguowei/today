[
  {
    "title": "于晓波：数字经济下 HR 的转型 ｜DTDS 8 月",
    "url": "https://www.infoq.cn/article/AyQYLHHsgEqT09lP5HOX",
    "summary": "<p>在工业和信息化部人才交流中心和中国移动通信联合会教育与考试中心的大力支持与指导下，由极客时间企业版、培训杂志共同举办，甫瀚咨询联合举办的 DTDS 全球数字人才发展线上峰会于 8 月 9 日拉开帷幕。</p>\n<p>经过多年在企业数字人才发展领域的耕耘，极客时间于 2022 年发布了数字人才粮仓模型，深入定义了五层数字人才，收获了来自各行各业的企业客户的认可。我们也看到许多企业都在加大对数字人才的培养，并且希望向行业标杆学习，完善自己的数字人才培养体系，融入数字人才标准和生态。</p>\n<p>为此，DTDS 峰会汇聚了来自政府和产业的权威，以及金融、汽车、制造、ICT、零售、互联网、风控审计企业的数字化先锋人物，旨在建立数字人才培养“朋友圈”，让大家从多维视角了解企业数字化转型，人才发展，和组织变革的先进经验。</p>",
    "publish_time": "2022-10-11 00:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "云端机器人的“智慧大脑”是如何获取知识，提升认知，完成“进化”的？| InfoQ《极客有约》",
    "url": "https://www.infoq.cn/article/vPaILEuvZaaeMxe2O4pl",
    "summary": "<p>云端智能机器人和普通机器人有何差别？未来智能机器人技术有哪些值得关注的？本期《极客有约》直播，带你了解云端智能机器人如何获取知识，完成进化的。</p>",
    "publish_time": "2022-10-11 11:07:26",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Spring Boot Migrator简介",
    "url": "https://www.infoq.cn/article/M8Tcely7QZhZYx4od2t1",
    "summary": "<p><a href=\"https://github.com/spring-projects-experimental/spring-boot-migrator\">Spring Boot Migrator</a>\"（SBM）是一个实验性的Spring项目，最初发布于2022年3月。SBM允许开发人员将现有的、非<a href=\"https://spring.io/projects/spring-boot\">Spring Boot应用（基于JAX-RS、EJB和JMS等技术）转换成Spring Boot</a>\"应用，也可以将较旧的Spring Boot应用升级为最新版本。</p><p></p><p>SBM是基于<a href=\"https://docs.openrewrite.org/\">OpenRewrite</a>\"实现的，这是一个用于源码和配置重构的通用工具。OpenRewrite使用<a href=\"https://docs.openrewrite.org/reference/recipes\">Recipes</a>\"修改现有的Kubernetes、Gradle、Maven、Java等文件。例如，借助recipes能够将现有的应用升级为较新的Java版本。SBM使用OpenRewrite实现Spring Boot的迁移。</p><p></p><p><a href=\"https://github.com/spring-projects-experimental/spring-boot-migrator/releases\">下载</a>\"最新版本的SBM之后，可以使用命令行界面（CLI）启动：</p><p><code lang=\"java\">java -jar spring-boot-migrator.jar</code></p><p>几秒钟之后，用户可以看到一个专门的SBM提示：migrator:&gt;。</p><p></p><p>list命令能够展示当前可用的30个recipes。比如，其中的recipes能够升级Spring Boot到新版本、将XML bean配置变更为Java配置以及迁移各种Java EE/Jakarta到Spring Boot。</p><p></p><p>scan [directory]命令能够分析一个应用并展示适用的recipes。如下展示了一个样例，SBM分析了一个比较旧的<a href=\"https://en.wikipedia.org/wiki/Jakarta_RESTful_Web_Services\">JAX-RS</a>\"应用，该应用没有提供对Spring Boot的支持，结果如下所示：</p><p><code lang=\"java\">scanning 'JAXRS'\nChecked preconditions for '.../JAXRS'\n[ok] Found pom.xml.\n[ok] 'sbm.gitSupportEnabled' is 'true', changes will be committed to branch [master] after each recipe.\n[ok] Required Java version (17) was found.\n[ok] Found required source dir 'src/main/java'.\nMaven       100% ││ 2/2 (0:00:09 / 0:00:00)\nApplicable recipes:\n    = 'automated recipe'\n  = 'partially automated recipe'\n    = 'manual recipe'\n  - initialize-spring-boot-migration []\n    -&gt; Initialize an application as Spring Boot application.\n  - migrate-jax-rs []\n    -&gt; Any class has import starting with javax.ws.rs\n  - cn-spring-cloud-config-server []\n    -&gt; Externalize properties to Spring Cloud Config Server</code></p><p>基于应用的源码，SBM将会展示与条件相匹配的recipes。如果没有匹配的recipes话，可用recipes的列表将保持为空。此时，我们可以使用其中列出的某个recipes，比如，将现有的代码转换成Spring Boot应用：</p><p><code lang=\"java\">migrator:&gt; apply initialize-spring-boot-migration</code></p><p>上述命令将会产生一个新的Git提交，描述为SBM: applied recipe 'initialize-spring-boot-migration'。</p><p>我们分析一下该提交会发现在pom.xml中有如下变化：打包方式从WAR改变成了JAR、增加了spring-boot-starter、spring-boot-starter-test依赖和spring-boot-maven-plugin、dependencyManagement区域包含了pom类型的spring-boot-dependencies。pom.xml文件的缩进方式可能会与最初有所差异。</p><p></p><p>源码也会有所变更，现在包含了SpringBootApp.java和SpringBootAppTest.java类：</p><p><code lang=\"java\">@SpringBootApplication\npublic class SpringBootApp {\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootApp.class, args);\n    }\n}</code></p><p></p><p><code lang=\"java\">@SpringBootTest\nclass SpringBootAppTest {\n    @Test\n    void contextLoads() {\n    }\n}</code></p><p>现在，应用已经转换成了Spring Boot应用。下一步就是通过如下的命令将JAX-RS源码转换成Spring Boot：</p><p><code lang=\"java\">migrator:&gt; apply migrate-jax-rs</code></p><p>该命令会产生一个新的Git提交，其描述为:SBM: applied recipe 'migrate-jax-rs'. 分析该提交可以看出，JAX-RS的导入被删除，取而代之的是导入了Spring、类文件上的JAX-RS&nbsp;@Path注解被Spring Boot的@RestController和@RequestMapping取代。各个方法现在都有Spring Boot的@RequestMapping、@RequestParam、@PathVariable注解，以替换JAX-RS的注解，如@Get、@Post、@Path、@Produces、@QueryParam和@PathParam。最后，这些方法的返回值不再是Response类型，而是ResponseEntity类型。</p><p></p><p>遗憾的是，迁移后运行该Spring Boot应用失败了，这是因为pom.xml文件中定义的<a href=\"https://maven.apache.org/plugins/maven-compiler-plugin/\">maven-compiler-plugin</a>\"使用了旧版本的Java。手动修改pom.xml文件以使用当前安装的Java版本可以解决这个问题，也可以通过OpenRewrite的<a href=\"https://docs.openrewrite.org/reference/recipes/maven/changepluginconfiguration\">Change Maven插件配置</a>\"来自动完成这个步骤。</p><p></p><p>分析产生的代码和配置，我们可能会发现一些Spring Boot不再需要的依赖。可以手动删除这些过时的依赖，也可以通过SBM或OpenRewrite自动完成这一步骤。</p><p></p><p>SBM目前支持仅Maven，因为OpenRewrite对Gradle的支持还没有<a href=\"https://github.com/spring-projects-experimental/spring-boot-migrator/issues/216\">完成</a>\"。关于SBM的更多信息可以参阅其<a href=\"https://spring-projects-experimental.github.io/spring-boot-migrator/user-documentation.html\">用户文档</a>\"和<a href=\"https://spring-projects-experimental.github.io/spring-boot-migrator/developer-documentation.html\">开发者文档</a>\"。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2022/09/spring-boot-migrator/\">Introducing Spring Boot Migrator</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/TJrVEvEhmrxAIVzMj10R\">Spring Boot 2.7.0 发布，支持 GraphQL、Podman 和 Cache2k</a>\"</p>",
    "publish_time": "2022-10-11 11:36:49",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "马斯克吐槽无用的“阑尾”终于被割掉，特斯拉移除超声波传感器，All In 纯视觉自动驾驶",
    "url": "https://www.infoq.cn/article/ieqsEOaplV4GQOMdl03j",
    "summary": "<p></p><p></p><p></p><blockquote>马斯克“干掉”最后的雷达。</blockquote><p></p><p></p><p></p><h2>Tesla Vision 替代超声波传感器</h2><p></p><p></p><p>10 月 4 日，特斯拉宣布，将从 Model 3 和 Model Y 车型中移除超声波传感器（USS）。</p><p></p><p>自 2022 年 10 月上旬开始，为北美、欧洲、中东和中国台湾制造的所有 Model 3 与 Model Y 车型均不再配备超声波传感器，而将完全依靠 Tesla Vision 以实现 Autopilot、增强 Autopilot、FSD 以及主动安全等功能。</p><p></p><p>未来几个月，特斯拉将在全球范围内推广这一波去超声波传感器运动，随后 Model S 和 Model X 也将于 2023 年加入行列。</p><p></p><p>特斯拉表示，此举也标志着 Tesla Vision 在发展道路上迈出了新的一步。</p><p></p><p>自 2021 年，特斯拉开始转向 Tesla Vision，先期在 Model 3 与 Model Y 车型上移除雷达，随后又在今年推广至 Model S 与 Model X。如今，在全球大部分地区，这些车型都将采用 Tesla Vision 纯摄像头自动驾驶系统。</p><p></p><p>自推出以来，特斯拉不断在功能对等性与安全性等方面开展渐进式改进。与配备雷达的车型相比，配备 Tesla Vision 的 Model 3 与 Model Y 在美国和欧洲的主动安全等级保持不变或有所提升，而且在行人自动紧急制动（AEB）干预方面表现更好。</p><p></p><p>自取消雷达以来，特斯拉对其软件进行了重大改进，以启用其高级驾驶辅助功能 (ADAS)。这包括其基于视觉的占用网络（occupancy network，目前已在 FSD Beta 中应用），Full Self-Driving Beta 依赖于该网络。根据特斯拉的公告，占用网络将取代 USS 生成的输入。借助当前软件，这种方法能够为 Autopilot 提供高清空间定位、更远距离的可见性以及识别 / 区分对象的能力。与其他特斯拉功能一样，占用网络模型也将随时间推移而不断快速改善。</p><p></p><p>在这段过渡期内，未配备 USS 的 Tesla Vision 车型可能出现部分功能暂时受限 / 不可用的情形，包括：</p><p></p><p>泊车辅助：当车辆以低于 5 英里 / 小时行驶时，提示车身周边的物体。自动泊车：自动驶入纵向或侧向车位。召唤：通过 Tesla 应用手动向前 / 向后移动车辆。智能召唤：通过 Tesla 应用将车辆导航至车主所在 / 所指定的位置。</p><p></p><p>特斯拉表示，在过渡期间，未安装超声波传感器的 Tesla Vision 并不会影响到 2022 年 10 月及之后交付的 Model 3/Model Y 车型的安全等级。过渡期间的影响不涉及碰撞安全等级，配备 Tesla Vision 的车辆与配备 Vision+ 雷达 +USS 的车辆拥有相同的碰撞安全等级。</p><p></p><p>在不久的将来，当这些功能达到与当前车型相当的功能，上述选项将通过一系列 OTA 软件更新得以恢复。所有其他可用的 Autopilot、增强 Autopilot 及 FSD 功能将在车辆交付时正常起效，具体取决于用户的订单配置。</p><p></p><p>而针对已售出的车型，特斯拉并不打算移除其配备的超声波传感器功能。</p><p></p><p></p><h2>“&nbsp;雷达杀手”马斯克</h2><p></p><p></p><p>作为高级传感器，激光雷达对于自动驾驶来说非常重要，激光雷达是安全自动驾驶是必不可少的设备之一。现在很多自动驾驶车企以及造车新势力等都在自家车型上应用了激光雷达，例如，小鹏 P5、蔚来 ET7、理想 L9、威马 M7、智己 L7 等搭载激光雷达的车型已在国内上市。</p><p></p><p>但作为全球最具影响力的自动驾驶探索者之一，马斯克和他的特斯拉对激光雷达却一向没有好感。马斯克一直是坚定的纯视觉自动驾驶倡导者。</p><p></p><p>为了节省成本，特斯拉坚决拒绝使用激光雷达进行精准测距。2014 年，被称为“激光雷达”的激光传感器成本为 75,000 美元。虽然之后随着激光雷达和摄像头混合技术的进步，成本有所降低，但使用激光雷达还是会让特斯拉挣不到钱。所以特斯拉选择依靠计算机视觉方案实现自动驾驶。</p><p></p><p>马斯克经常嘲讽激光雷达和多传感器融合路线。2019 年，马斯克“False and foolish = HD maps and LiDAR”（傻子才采用高清地图加激光雷达）的言论一出，当即引起了很大的争论。</p><p></p><p>马斯克认为，“（激光雷达）就像是人身上长了一堆阑尾，阑尾本身的存在基本是无意义的，如果长了一堆的话，那就太可笑了。任何依赖激光雷达的公司都可能无疾而终。”&nbsp; “当雷达和视觉系统发生判断冲突时，你会相信哪一个？视觉系统的精度更高，所以倒不如配合必要的传感器进一步发掘视觉系统的潜力”；“激光雷达毫无意义，对于自动驾驶汽车来说没有必要”；“激光雷达昂贵、丑陋、没有必要”...</p><p></p><p>去年 7 月，特斯拉公司 AI 高级总监 Andrej Karpathy &nbsp;曾在 CVPR2021 年自动驾驶研讨会上表示，激光雷达加高清地图这套基础设施的持续更新会带来极高的成本，所以特斯拉采取的方案则主要基于视觉元素。车辆可以依靠环绕车身的 8 个摄像头即时捕捉并理解周边发生的一切。这样当第一次来到某个十字路口，就需要弄清楚车道在哪里、每条车道间如何连接、交通灯在哪里、什么灯控制什么车道等，一切都由车辆亲自观察和处理，不需要高清地图作为支持。</p><p></p><p>特斯拉认为，其深度学习系统比雷达要强上一百倍，激光雷达技术并不是自动驾驶技术的最终选择。</p><p>Karpathy 表示，特斯拉过去几年构建的视觉系统已经非常出色，因此不再需要其他各类传感器。摄像头已经能够满足视觉感知方面的大部分需求，因此特斯拉能够更有信心地逐渐去掉那些已无必要的旧有传感器装置。</p><p></p><p>Karpathy 认为，视觉加传感器的组合在自动驾驶效果上已经远远超越了雷达方案。自动驾驶中的元素并不是越多越好，需要保留真正有贡献的元素、去掉经常产生噪声的元素，这样才能构建起稳定可靠的解决方案。”</p><p></p><p>此前特斯拉的传感器方案为 8 摄像头，1 毫米波雷达，12 超声波雷达。在特斯拉汽车的前后保险杠上安装有 12 个超声波传感器，短程声波传感器主要用于停车和检测近距离物体。</p><p></p><p>2021 年 5 月，特斯拉宣布去掉了毫米波雷达。一年多后，特斯拉再度减配，移除超声波雷达，以后将是8个摄像头走天下了。Guidehouse Insights 分析师 Sam Abuelsamid 认为，“去掉超声波传感器，会为他们节省几美元。因为超声波传感器都很便宜。”</p><p></p><p>业内关于激光雷达与视觉算法的技术之争由来已久，激光雷达数据精度更高，但其成本高昂，视觉方案成本优势高，但感知精度不够。此前有自动驾驶专家曾向 InfoQ 谈到自己的观点，“自动驾驶离不开激光雷达，图像技术足够成熟至少还要十年。”</p><p></p><p>参考链接：</p><p></p><p>https://www.tesla.com/support/transitioning-tesla-vision</p><p></p><p>https://www.notateslaapp.com/news/1003/tesla-is-removing-ultrasonic-sensors-from-all-of-its-vehicles</p>",
    "publish_time": "2022-10-11 14:56:25",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "进入工业大生产阶段，能让AI真正产业落地的关窍是什么？",
    "url": "https://www.infoq.cn/article/csAtICUTZ3ejLpRM7S2G",
    "summary": "<p></p><p></p><blockquote>AI深入产业落地，关键在于人才。</blockquote><p></p><p></p><p></p><h3>大模型等基础共性AI技术降低应用门槛&nbsp;, AI人才推动产业智能化升级</h3><p></p><p></p><p>9月25日，在由深度学习技术及应用国家工程研究中心与百度联合发起的AICA首席AI架构师培养计划第五期、第六期双期毕业典礼上，来自五期班的57位学员与六期班的75位学员通过答辩获得毕业证书。</p><p></p><p>现场，百度集团副总裁、深度学习及应用国家工程研究中心副主任吴甜在致辞中表示，人工智能与产业的融合越来越深入，通过深度学习平台持续建设和发展，大模型等基础共性 AI 技术让应用门槛不断降低，可以预见 AI 应用更有前景的未来。</p><p></p><p>吴甜讲到，预训练大模型技术是人工智能发展的重要方向，通过自监督学习、弱监督学习，大模型从海量数据中学习知识和规律。依托于大模型，在场景应用中通过少量数据的精调就得到很好的效果，成本降低且效果提升，从而 AI 技术可以更大规模的应用，推动实现工业大生产。人工智能和产业共同发展的底层规律在 AICA 项目中得到印证，飞桨将与来自各行各业的学员们一起持续推动 AI 深入产业，推动智能化升级。</p><p></p><p>数据显示，截止2022年5月，飞桨已凝聚477万开发者，创建56万模型，服务18万企事业单位，同时产学研用紧密协同培养超过200万AI人才。</p><p></p><p></p><h3>培养深入产业的AI架构师</h3><p></p><p></p><p>随着AI进入工业大生产阶段，全新AI应用正在加速与纵深垂直行业场景深度融合。AICA首席AI架构师培养计划目标培养集业务理解、技术理解和工程实践为一体的复合型AI人才，通过培养产业人才的方式来打通产业智能化升级的关窍。</p><p></p><p>据悉，百度AICA六期班首次采取了百人班制，课程内容设置以对深度学习落地技术的全景解读和框架梳理为起点。对于具体实际的AI产业落地问题，百度架构师们一对一帮助学员梳理项目困难与难点，帮助学员构建AI项目架构与思考路径。AICA希望助力学员将AI与各自企业实际业务相结合，为业务问题带去可实践的方案，最终为企业创造智能化价值。</p><p></p><p>参与培训计划的学员中来自500强企业、专精特新龙头企业的比例较往期提高一倍，并首次出现了来自海外企业的AI方向学员；在AI业务方向上，五、六期班学员所关注的AI与业务融合场景更加广泛和深入，涉及能源油气、智能制造、智慧医疗、智慧城市、智能交通等多个领域，场景也更贴近民生。</p><p>&nbsp;</p><p>例如在交通领域，铁路客运从人脸识别进一步升级到步态识别，开创新的研究方向和应用可能；医疗领域，学员利用AI技术实现基于音频分类的呼吸暂停事件检测及分析系统；能源领域，场景已广泛拓展覆盖煤矿视频分析、风电场无人巡检和风机叶片缺陷检测、电力业务模型压缩和异构转换、智慧加油站解决方案、光伏组件故障识别诊断等；AI+科学计算的前沿领域探索上，学员利用AI技术进行台风风场重构和风暴潮预测研究。</p><p>&nbsp;</p><p>目前，六期班来自国家能源、中石油、中海油、中国一汽、中国铁道科学研究院、光大科技、山东瑞邦等行业龙头、专精特新在内的企业学员已经成功将AI技术应用到公司的项目中，并为以后AI场景融合的大规模落地打下基础。</p><p></p><p></p><h3>代表案例解析</h3><p></p><p>据悉，自2019年推出至今，AICA已累计向业界输送了322名AI架构师，培养了懂AI、懂业务，并将AI付诸于业务实践的高端复合型AI人才。</p><p></p><p>以下为第六期优秀学员中，AI方向的代表案例解析。</p><p></p><h4> 基于铁路客运进出站的步态身份识别研究</h4><p></p><p></p><p>来自中铁程科技有限责任公司的李贝贝，此前是一名架构师，在工作了几年后，他看到了AI火热的趋势和蕴藏的能量，并且产生了浓厚的兴趣，于是，他决定转型成为一名AI架构师。</p><p></p><p>转型之后，李贝贝发现，与普通架构师相比，AI架构师需要掌握的技能知识点更多，例如对基础数学的能力和经验要求更高，此外还需要掌握AI知识。为了锻炼和提升自己，李贝贝报名了百度AICA计划。</p><p></p><p>今年5月加入AICA六期班时，李贝贝选择的项目方向是基于铁路客运进出站的步态身份识别研究。与人脸识别相比，步态识别不仅具有人脸识别的“无接触”特点，还具有可远距离观察、易于捕捉等特点，结合疫情的安全防护需要，辅助实现旅客无需摘口罩即可出站，简化旅客出站的同时，降低新冠传播或感染风险。</p><p></p><p>在研究过程中，李贝贝通过AICA的学习，参考并不断吸收百度飞桨的相关经验。例如飞桨企业版EasyDL零门槛AI开发平台和BML全功能AI开发平台，能够让开发者更便捷、高效地完成AI应用开发；PaddleLite端侧推理引擎能实现多种算法之间的串联部署等。“我们面向的主要是铁路场景，但其中也有很多细分场景，百度飞桨给予我很多思考和支持。”</p><p></p><p>李贝贝表示，AICA的学习经历让他对AI整体体系和理念有了非常直观的认识，未来也将持续在铁路领域进行AI应用的探索。</p><p></p><h4>软通动力数字人探索：未来你的面试官可能是虚拟人！</h4><p></p><p></p><p>易呈是软通动力正在进行中的虚拟数字人项目的一员，他所在的AI专项组主导两个项目，虚拟数字人和简历解析与智能匹配。易呈主要负责AI算法模型研究，包括AI产品和架构设计。</p><p></p><p>软通动力一直深耕数字化转型，并持续追踪和探索行业前沿技术与产品，元宇宙就是其中之一。目前，软通已推出自己的数字孪生和元宇宙产品平台，而近年来大火的数字人便是重要的一个研究方向。</p><p></p><p>软通动力计划从数字人这条线切入，初期实现在软通内部使用，而后对外推出企业级应用。项目主要面向两个细分方向，一是虚拟主播，在公司内部的展厅、电梯等做新闻播报；二是结合组内简历解析的优势打造虚拟数字人面试官。一般面试官进行一轮面试通常需要花费几十分钟时间，而软通每年有大量的面试，数字人面试官可以作为初面环节的面试官，通过在线的方式与候选人做初步的沟通，了解候选人的意向，并通过AI算法进行自动化的评价，以待用人方做出进一步判断，提升候选人面试体验。</p><p></p><p>今年，软通动力数字人项目的Demo出炉，在对其进行更高层次的研发过程中，易呈团队遇到了一系列挑战。在这时，易呈想到了此前在铁路领域工作时接触到的飞桨，恰巧软通动力也已经与百度飞桨建立了生态伙伴合作关系，于是易呈便撰写了课题，申请前往AICA进行交流学习，希望借助飞桨进一步提升软通动力虚拟数字人的表现。</p><p></p><p>通过在AICA的交流学习，易呈团队面临的诸多技术难题有了重大突破。例如，虚拟面试官对实时性要求较高，易呈团队与飞桨PaddleGAN团队一起探索人脸表情和唇形实时渲染方案，即用离线方式、工程化的思路打造近似实时的体验，通过生成很多短视频，根据用户的输入指令把离线视频通过流的形式推给用户，实现与用户的实时问答。</p><p></p><p>回顾该经历，易呈表示，AICA对有经验的技术人员带来的提升不仅仅局限在技术上，更多地是开拓眼界和思维方式，还有在AICA结识了众多老师、助教老师，以及一帮同学好友。</p><p></p><p>另一个重要的价值在于，AICA能够带领一些“门外”的人进来，从认识到实操。“我发现，很多学员之前不是AI领域的，AICA能够是把这些人从‘门外’拉进来，真正去摸一摸AI到底是什么东西，让产业的企业引起对AI的重视。对普通人来说，人工智能就像是雾里看花一般，但对实际应用开发者来说，它与做软件或硬件开发类似，都会经历一个‘1+1=2’的过程，，只是很多人根本就不知道怎样找到1+1的路径，AICA就是把这些人引到这条路上来”。</p>",
    "publish_time": "2022-10-11 15:56:27",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "新一波 JavaScript Web 框架",
    "url": "https://www.infoq.cn/article/2SyNfw6RkyTV4gkRavIQ",
    "summary": "<p></p><blockquote>这篇文章让读者们了解为什么新的 JavaScript Web 框架扩散如此迅速，并且对大规模的问题和创新的最新发展进行了深入的探讨。</blockquote><p></p><p>&nbsp;</p><p>太过保守很难在 Javascript 生态系统中保持与时俱进。对于那些刚进入这个行业的人来说，要在新的库、框架、概念和有力的意见中关注正在发生的事情，很有挑战性。这是个很好的提醒，默认情况下，使用“无聊”的技术，你所熟悉的技术，并且成为晚期采用者，通常是个不错的选择。</p><p>&nbsp;</p><p>闲话少叙，本文将带读者了解 Javascript 中生态系统中的最新进展，通过研究过去在构建大规模 Web 应用时的痛点来了解当前的情况。</p><p>&nbsp;</p><p>不要把注意力集中在快速增长的解决方案上，而是从潜在问题入手。每一种架构都会有不同的答案，并且会有不同的权衡。到本文结束时，我们会列出流行框架的高级模型，如 React、Svelte、Vue、Solid、Astro、Marko、Fresh、Next、Remix、Qwik，以及适合当今环境的“元框架” 。</p><p>&nbsp;</p><p>鉴往知来。让我们回首来时路，再看看未来的趋势。这次，我们将专注于大型项目中的问题，这些问题激发了其他方法和思维方式。</p><p>&nbsp;</p><p></p><h2>网页简史</h2><p></p><p>&nbsp;</p><p>Web 最初由静态文档链接在一起组成。那时候，人们可以提前准备一份文件，并把它放在电脑上。而现在最酷的就是，人人都可以访问它，无需亲临其境。</p><p>&nbsp;</p><p>不知从何时起，我们觉得，让这些文件变成动态，会非常酷。于是我们有了像 <a href=\"https://en.wikipedia.org/wiki/Common_Gateway_Interface\">CGI</a>\" 这样的技术，使我们能够根据请求提供不同的内容。然后，我们有了像 <a href=\"https://www.perl.org/\">Perl</a>\" 这样的表达式语言来编写这些脚本。它对最初针对 Web 开发的 <a href=\"https://en.wikipedia.org/wiki/PHP\">PHP</a>\" 产生了影响。PHP 的创新之处在于将 HTML 直接连接到后端代码。这使得以编程方式创建嵌入动态值的文件变得容易了。</p><p>&nbsp;</p><p>Web 最重要的突破之一来自于此：</p><p>&nbsp;</p><p><code lang=\"null\">\n\nThis document has been prepared ahead of time.\nRegards.\n\n</code></p><p>&nbsp;</p><p>具有易于嵌入的动态值：</p><p>&nbsp;</p><p><code lang=\"null\">\n\nY2K? <!--?php echo time(); ?-->\n\n</code></p><p>&nbsp;</p><p></p><h3>框架时代拉开大幕</h3><p></p><p>&nbsp;</p><p>这些动态页面很受欢迎。我们可以很轻松地对发送给用户的内容进行定制，包括启用会话的 cookies。在与数据库交互的语言生态系统中，已经有了基于服务器的模板框架。通过这些框架，我们可以轻松地从静态页面开始，然后扩展到动态页面。</p><p>&nbsp;</p><p>Web 的发展一日千里，我们想要更多的互动体验。为了这个目的，我们使用了 <a href=\"https://en.wikipedia.org/wiki/Adobe_Flash\">Flash</a>\" 这样的浏览器插件。在其他方面，我们会在后端提供的 HTML 上“撒上” Javascript 片段。</p><p>&nbsp;</p><p>像 jQuery 和 Prototype 这样的工具出现了，它们隐藏了 Web API 的复杂度，消除了浏览器之间的差异。</p><p>&nbsp;</p><p>光阴荏苒，科技公司的规模在不断扩大，并且由于项目和开发团队的增长，在模板中加入更多的业务逻辑是非常普遍的。</p><p>&nbsp;</p><p>编写的服务器代码，将处理后的数据传输到服务器模板语言中。模板常常会演变成业务逻辑的“混合体”来访问全局变量。由于像 SQL 注入这样的攻击已经司空见惯，因此安全问题也越来越突出。</p><p>&nbsp;</p><p>最终，论文《<a href=\"https://designftw.mit.edu/lectures/apis/ajax_adaptive_path.pdf\">Ajax：Web 应用的新方法</a>\"》（Ajax: A New Approach to Web Applications）为我们带来了 Ajax 技术。现在你用 Ajax 技术可以做的新事情就是用异步方式更新页面，而不再是以同步的方式来更新页面。这种模式被第一批大型客户端应用程序所推广，如谷歌地图和谷歌文档。后来，我们开始看到 Web 分发对桌面风格的软件的影响力。与在商店里购买光盘的软件相比，这是一个重大的进步。</p><p>&nbsp;</p><p></p><h3>JavaScript 壮大</h3><p></p><p>&nbsp;</p><p>当 node 出现的时候，它所带来的新特性，就是用与前端相同的语言来编写你的后端。所有这些都是开发人员所熟悉的异步优先模式。这曾经令人无法抗拒，当然现在也是。随着越来越多的企业上线，竞争优势在于能否快速交付和迭代。</p><p>&nbsp;</p><p>Node 的生态系统强调重复使用小型的单用途包，你可以利用现成的去完成任务。</p><p>&nbsp;</p><p></p><h3>前端与后端分离</h3><p></p><p>&nbsp;</p><p>我们更渴求能够与桌面、移动设备相媲美的 Web。现在，我们已经有了一系列可重用的“小部件”库和工具，如 jQuery UI、Dojo、Mootools、ExtJs 和 YUI 等。</p><p>&nbsp;</p><p>我们对这些小玩意儿的关注程度与日俱增，并且在前端的工作也越来越多。这往往导致了前端和后端的模板重复。像 Backbone 和 Knockout 以及许多其他的框架出现了。它们通过 MVC、MVVM 等架构为前端增加了关注点的分离，并且，架构可以兼容我们收集到的所有小部件和 JQuery 插件。添加结构有助于扩展所有这些前端代码。并且可以加速从后端传送模板。</p><p>&nbsp;</p><p>我们仍然编写微调的 DOM 操作来更新页面并保持组件的同步。这个问题非同小可，而且与数据同步相关的错误也很常见。</p><p>&nbsp;</p><p>在谷歌的支持下，Angular 登场了。它通过增强 HTML 的动态性，促进了生产力的提高。它配备了双向数据绑定，以及一个受电子表格启发的反应性系统。这些声明式的双向绑定消除了许多必须更新的模板。这是好事，可以让我们的工作效率更高。</p><p>&nbsp;</p><p>随着规模的扩大，跟踪变化越来越困难，常常会造成性能下降。更新的周期会发生，并占据主线程（今天像 Svelte 这样的库可以在降低其缺陷的情况下保<a href=\"https://imfeld.dev/writing/how_svelte_makes_two_way_binding_safe\">持双向绑定</a>\"）。除了移动设备的兴起之外，这些提高生产力的框架也加速了前端和后端的分离。这为探索强调这种解耦的不同架构铺平了道路。</p><p>&nbsp;</p><p>这是 JAMstack 理念的一个主要部分，强调提前预生成 HTML，并从 CDN 提供服务。在当时，这是对提供静态文档服务的一种倒退。但现在，我们有了基于 git 的工作流，有了强大的 CDN 基础设施，有了可以与独立 API 互动的解耦前端，就无需依靠远在天边的中央服务器。与运营服务器相比，将静态资产放置到 CDN 上要便宜很多。</p><p>&nbsp;</p><p>今天，像 Gatsby、Next 和很多的其他工具都利用了这些想法。</p><p>&nbsp;</p><p></p><h2>React 崛起</h2><p></p><p>&nbsp;</p><p>快步流星地进入大科技时代。我们正试图追风逐电，一改故辙。对于那些进入这个行业的人来说，Javascript 很大，而构建一个由独立后端支持的解耦 SPA 已经成为现实。</p><p>&nbsp;</p><p>在 Facebook，React 的诞生面临着几个挑战。</p><p>&nbsp;</p><p>数据频繁变化时的一致性：保持许多小部件之间的同步，仍然是一项重大的挑战。由于数据流缺乏可预测性，这在规模上是个问题。组织上的扩展：优先考虑进入市场的时间和速度。对于新开发人员来说，能否快速上手，并且富有成效，这一点至关重要。</p><p>&nbsp;</p><p><a href=\"https://www.infoq.cn/article/YZMFbo42uyHdps9WiQif\">React </a>\"诞生了，你能做得很酷的新事情就是声明性地编写前端代码。</p><p>&nbsp;</p><p>前端关注点的分离是著名的反思，以前的 <a href=\"https://www.youtube.com/watch?v=nYkdrAPrdcw&amp;feature=share&amp;si=ELPmzJkDCLju2KnD5oyZMQ&amp;t=438\">MVC 框架无法扩展</a>\"。人们并不喜欢从模板向 Javascript 驱动的 JSX 过渡。但是我们大多数人都接受了。</p><p>&nbsp;</p><p>组件模型允许解耦独立的前端团队，他们可以更容易地在独立组件上并行工作。作为一个架构，它允许组件的分层。从共享的原语到构成页面根目录的“有机体”。单向的数据流使数据流更易于理解、跟踪和调试。这就提高了之前难以企及的可预见性。虚拟 DOM 就是我们可以编写函数，返回用户界面的说明，让 React 去解决这些难点。这样可以避免在数据频繁变化时出现的一致性问题，并且使得模板的组成更加人性化。</p><p>&nbsp;</p><p></p><h2>规模化的 React 已达到 CPU 和网络的极限</h2><p></p><p>&nbsp;</p><p>React 非常流行，已经成为了业界的标准，即使是那些不想要其特性的网站来说也是如此。在规模的远端，我们开始看到一些限制。</p><p>&nbsp;</p><p></p><h3>CPU 遭遇很大阻力</h3><p></p><p>&nbsp;</p><p>DOM 是 <a href=\"https://www.infoq.cn/article/3zjScEsgksmFNdgIR7sM\">React 模型</a>\"的一个问题。浏览器并不是为了在连续的渲染周期中不断创建和销毁 DOM 节点而构建的。就像任何可以通过引入一个新的间接级别来解决的问题一样，React 把它抽象到了虚拟 DOM 后面。</p><p>&nbsp;</p><p>人们只有在 100 毫秒以内感知到反馈，才会感到流畅。而在做像滚动页面这样的事情时则要低得多。在与单线程环境相结合的情况下，这种优化已经成为高度交互式应用的新瓶颈。当虚拟 DOM 和真实 DOM 之间发生协调时，大型交互式应用程序会对用户的输入失去响应。像“长任务”这样的术语开始出现了。</p><p>&nbsp;</p><p>这导致了 React 在 2017 年被重新编写，为并发模式奠定了基础。</p><p>&nbsp;</p><p></p><h3>运行时成本增加</h3><p></p><p>&nbsp;</p><p>与此同时，更快的移动意味着传输更多的代码。浏览器在运行大量 Javascript 时，启动速度慢就成为一个问题。我们开始注意到所有隐含的运行时成本，不仅是 HTML 和虚拟 DOM，还有我们编写 CSS 的方式。</p><p>&nbsp;</p><p>组件模型简化了我们在 CSS 方面的经验。我们可以将样式与组件放在一起，这提高了可删除性。对于那些以前不敢删除 CSS 代码的人来说，这是一个非常好的属性。我们一直在处理的级联和所有的特殊性问题都被 JavaScript 库中的 CSS 抽象化了。</p><p>&nbsp;</p><p>这些第一波的库往往伴有隐含的运行时成本。我们需要等到组件被渲染后，再将这些样式注入到页面中，这就造成了 JavaScript 包中的样式问题。从规模上来说，糟糕的性能往往是千夫所指，而我们也注意到了这些成本。这导致 JavaScript 库中出现了新的 CSS，它通过使用智能预编译器来提取样式表，这些库专注于没有运行时的开销。</p><p>&nbsp;</p><p></p><h3>效率低下的网络和渲染受阻的组件</h3><p></p><p>&nbsp;</p><p>当浏览器渲染 HTML 时，像 CSS 或脚本这样的渲染障碍资源会阻止 HTML 的其他部分显示出来。在一个组件的层次结构中，父组件往往会成为子组件的渲染障碍。</p><p>&nbsp;</p><p>在实践中，许多组件依赖于数据库的数据和 CDN 的代码（通过代码分割）。这经常会造成瀑布式的网络请求阻塞。在渲染之后，组件会获取数据，解锁异步子组件。接着，它们将会获取它们所需的数据，并重复这一过程。经常可以看到“下拉列表的地狱”或累积布局偏移，这些变化是在加载 UI 时出现在屏幕上的。</p><p>&nbsp;</p><p>React 后来发布了 Suspense，以使页面的加载阶段更加顺畅。但是，默认情况下，这并不能防止持续的网络瀑布问题。Suspense 支持“在获取数据时渲染”的模式。</p><p>&nbsp;</p><p></p><h2>Facebook 如何解决这些问题</h2><p></p><p>&nbsp;</p><p>我们将继续绕行，了解 React 的一些权衡如何在规模上得到缓解。这将有助于构建新框架中的模式。</p><p>&nbsp;</p><p>优化运行时成本</p><p>&nbsp;</p><p>在 React 中，<a href=\"https://svelte.dev/blog/virtual-dom-is-pure-overhead\">虚拟 DOM 的运行时成本是无法避免的</a>\"。并发模式是一个解决问题的方法，它可以让你在高度互动的体验中保持对事情做出响应。</p><p>&nbsp;</p><p>在 JavaScript 中的 CSS 领域，使用了一个名为 Stylex 的内部库。当成千上万的组件被渲染时，这可以维持人性化的开发人员体验，而无需运行时的成本。</p><p>&nbsp;</p><p>优化网络</p><p>&nbsp;</p><p>Facebook 用 Relay 来避免顺序性的网络瀑布问题。对于一个给定的入口点，静态分析可以精确地确定要加载的代码和数据。这就意味着代码和数据都可以在一个优化的 graphQL 查询中并行加载。</p><p>&nbsp;</p><p>这比初始加载和 SPA 转换的顺序网络瀑布要快得多。</p><p>&nbsp;</p><p>优化 Javascript 包</p><p>&nbsp;</p><p>其中一个基本问题就是传递 JavaScript，这些 JavaScript 与具体的用户无关。</p><p>&nbsp;</p><p>如果有 A/B 测试，特性标记的经历，以及针对特定类型和群组的用户的代码时，那就很困难了。还有语言和地区设置。当代码有许多分支时，静态依赖关系图不能看到在实践中为特定用户群一起使用的模块。</p><p>&nbsp;</p><p>Facebook 使用了一个由人工智能驱动的动态包系统。这利用其紧密的客户-服务器集成，在运行时根据请求计算出最佳的依赖图。这与一个根据优先级分阶段加载包的框架相结合。</p><p>&nbsp;</p><p></p><h3>生态系统的其他部分呢？</h3><p></p><p>&nbsp;</p><p>Facebook 拥有复杂的基础设施和多年来构建的内部库。如果你是一家大型科技公司，你可以投入大量的资金和资源来优化这些大规模的权衡。</p><p>&nbsp;</p><p>这为前端产品开发人员创造了一个成功的深渊，可以让他们在完成任务的同时保持性能。</p><p>&nbsp;</p><p>我们中的大多数人都不会像 Facebook 那样的规模上构建一套应用。然而，对于许多大型企业来说，性能是个话题。我们可以从这些模式中学习，例如：尽可能多地获取数据，并行化网络，以及使用内联需求等等。</p><p>&nbsp;</p><p>大型科技公司经常在内部推出自己的应用框架。在不同的用户资源库中，遗留了大量的解决方案。这导致了许多 Javascript 生态系统疲劳和框架倦怠。</p><p>&nbsp;</p><p></p><h2>JavaScript 的世界：群龙无首</h2><p></p><p>&nbsp;</p><p>还跟我们在一起？我们正处于 SPA 的时代。这就是目前从事这一行的人所面临的现状。</p><p>&nbsp;</p><p>React 是无可争议的冠军，然而，我们看到了大规模的取舍。</p><p>&nbsp;</p><p>React 提供了一个层。它将其他必要的层留给了生态系统，在路由、状态管理、数据获取等各个重要方面造成了混乱，每个层都有自己的概念和 API。</p><p>&nbsp;</p><p>不可变与可变，带有类的 OOP 与函数式的 OOP，争论和库都如火如荼。</p><p>&nbsp;</p><p>如今，很多开发人员都被不确定的事情所困扰，他们不知道应该怎么去做，也不知道该怎么去构建。</p><p>&nbsp;</p><p></p><h2>起来，起来，React 替代品！</h2><p></p><p>&nbsp;</p><p>组件是有黏性的。但运行时成本、Javascript 驱动的 JSX 以及复杂性都有待讨论。很多不是来自大型科技公司的草根替代方案，已经获得了广泛的认同。让我们对这些方案做一个总论：</p><p>&nbsp;</p><p></p><h3>Vue</h3><p></p><p>&nbsp;</p><p>当人们在评估迁移到 Angular 2 或 React 时，Vue 填补了入门门槛低的空白。你不必为复杂的 webpack 配置而担心。你可以从 CDN 上下载并开始使用对许多开发人员来说很直观的模板来构建组件。</p><p>&nbsp;</p><p>核心团队可以使用路由和样式等核心组件，减少决策疲劳。它还通过对模板进行静态分析，缓解了 React 调和算法的某些方面，以实现优化，加快运行时。这被称为编译器通知的虚拟 DOM。</p><p>&nbsp;</p><p></p><h3>Svelte</h3><p></p><p>&nbsp;</p><p>Svelte 开创了预编译方法的先河，消除了我们在运行时看到的复杂性和开销。</p><p>&nbsp;</p><p>我们的想法是要有一个可以自行编译的框架，并简化输出最小的普通 JavaScript。所有这些都是基于声明式组件和熟悉的可变 Javascript 风格来保持现代的创作体验。Svelte 完全避免了使用虚拟 DOM，因此不会受到编写 Javascript 的不可变风格的约束，这种风格可以用来做更新状态之类的事情。对于许多人来说，这是一个更简单、更理智地在 Web 上构建东西的模型。</p><p>&nbsp;</p><p></p><h3>Solid</h3><p></p><p>&nbsp;</p><p>Solid 有一个直接的和可预测的反应性模型，其灵感来自 Knockout。像 React 一样，它也避免了使用模板来简化函数的可组合性。</p><p>&nbsp;</p><p>而 React 采取的是不断重新渲染世界的方法。Solid 只渲染一次，并在不增加虚拟 DOM 开支的情况下，使用精简的反应性系统进行细粒度的更新。Solid 看起来就像我们许多 React 开发人员想要使用钩子的新代码那样。它的 API 也许更人性化，并且在许多方面非常顺利，例如钩子的依赖数组，其重点是细粒度的反应性和可组合的原语。</p><p>&nbsp;</p><p></p><h3>交流互鉴</h3><p></p><p>&nbsp;</p><p>对于每个框架，还有许多可说的。每个人都会在自己的基本模式和喜好上作出不同的权衡。</p><p>&nbsp;</p><p>在现实中，进化往往是由人类的意志决定的。尝试不同的解决方案来解决当前的痛点，每个框架都从彼此中学习。其中一个重要的主题就是精简和简化。把事情从运行时移到编译时是这些主题之一，它激发了 “React forget”，这是一个有望能够消除记忆化需求的特性。它们的共同点是解决了文件的交互部分。正如我们所看到的，这是一个具有挑战性的方面，要以一种容易扩展的方式来解决。</p><p>&nbsp;</p><p>同时，我们看到了纯客户端渲染的权衡。当加载一个页面时，那个空白的白屏需要更长的时间。在移动设备和网络上，这真是一场灾难。对于很多网站来说，网页打开速度更快，且性能不降低，成为一个主要的竞争优势。</p><p>&nbsp;</p><p>我们迈出了这一步，正在探索通过首先在服务器上渲染内容来加快渲染速度的方法（后来才发现这是一种权衡）。这个最初的倒退引发了许多“元”框架和 HTML 优先前端框架的新浪潮。</p><p>&nbsp;</p><p></p><h2>新一波的 JavaScript Web 框架</h2><p></p><p>&nbsp;</p><p></p><blockquote>我们不会停止探索。我们所有探索的终点就是我们开始的地方。也是第一次知道这个地方。</blockquote><p></p><p>&nbsp;</p><p>受 PHP 的启发，Next 开始简化创建静态页面推送到 CDN 的过程。它还解决了在 React 应用程序中使用 SSR 的棘手问题。</p><p>&nbsp;</p><p>它还提供了一些关于使用基于文件的路由来构建应用程序的意见，这很受欢迎。还有其他一些不错的特点。从那时起，又有一波“元”框架被创建。对于 Vue，我们在 Nuxt 中有一个类似的框架。Svelte 的 Sveltekit，以及即将推出的 SolidStart。</p><p>&nbsp;</p><p>这些都是服务器优先，旨在整合 Web 框架的所有部分和人体工程学。这并不仅仅是人们长久以来所关心的互动元素。</p><p>&nbsp;</p><p>对话的出发点是改进用户的经验和开发人员的经验，而非一种交换。</p><p>&nbsp;</p><p></p><h3>MPA 的反击</h3><p></p><p>&nbsp;</p><p>多页面架构从服务器上提供 HTML，其中导航是全页面刷新。快速启动对于很多站点来说都是至关重要的，尤其是那些没有登录的站点。它直接关系到诸如搜索排名和跳出率之类的事情。对于许多互动性低的网站和应用程序来说，使用像 React 这样的客户端渲染库，就过于夸张了。</p><p>&nbsp;</p><p>对许多人来说，这意味着翻转脚本。做到 HTML 优先而不是 Javascript 优先，MPA 优于 SPA，并默认为零 Javascript。</p><p>&nbsp;</p><p>像 Marko、Astro、Fresh、Rocket 和 Enhance 等框架都采用了这种方法。与一些元框架相比，路由器停留在服务器上，而不是让客户端的路由器在第一次加载后接管。在 Javascript 生态系统中，这是对 Node 之后不久的基于服务器的模板制作的一种倒退。</p><p>&nbsp;</p><p>这一轮的 MPA 与前几代不同。“Sprinkles”是在一个基于组件的模型中编写的，通常使用 island 模式。在前端和后端代码中使用相同的语言。往往在同一个文件中共存。这就消除了在添加一些交互性时前端和后端构造不同的重复模板代码的问题。</p><p>&nbsp;</p><p></p><h3>渐进增强的回归</h3><p></p><p>&nbsp;</p><p>Remix 在 React 生态系统中带来了渐进增强的回归。</p><p>&nbsp;</p><p>从技术角度来看，Remix 是 React Router 的编译器，和其他新兴的元框架一样，是一个边缘兼容运行时。它通过嵌套布局和数据获取 API，解决了 Facebook 通过 Relay 大规模解决的相同挑战。</p><p>&nbsp;</p><p>这允许早期的代码和数据的并行获取。这是用 Suspense 实现“边渲染边获取”模式的一个良好前提条件。对渐进增强的强调意味着它的 API 基于 Web 标准，数据变异的故事基于 HTML 表单。</p><p>&nbsp;</p><p>而不是通过连接事件处理程序来进行必要的获取请求。你渲染表单，将数据提交给在服务器上处理它们的动作函数（通常在同一个文件中）。受到 PHP 的启发。</p><p>&nbsp;</p><p>与 Next 类似，应用程序可以缩小规模，像传统的服务器渲染的 MPA 那样在没有 Javascript 的情况下工作，或者按每页的规模扩展到交互式 React 应用程序。</p><p>&nbsp;</p><p>Remix 还提供了许多 API 和模式，用于处理诸如乐观的 UI 更新、静态条件的处理以及优雅的退化之类的事情，这些都是你希望一个专注于终端用户体验的深思熟虑的框架所提供的。</p><p>&nbsp;</p><p></p><h3>混合的未来</h3><p></p><p>&nbsp;</p><p>不要与 Quic 协议相混淆。Qwik 这个框架是关于尽量减少不必要的 Javascript。虽然它的 API 看起来像 React，但它的方法与其他元框架不同，因为它专注于水化过程。</p><p>&nbsp;</p><p>就像你可以暂停一台虚拟机并将其移动到不同的物理机上。Qwik 把这个想法带到了服务器和浏览器之间发生的工作。它的“可恢复”水化的想法意味着你可以在服务器上启动一些东西，然后在客户端上恢复，而不需要任何重新工作。这与部分水化形成对比，后者在水化工作发生时进行移动，而 Qwik 则试图在一开始就避免这样做。</p><p>&nbsp;</p><p>这是一套有趣的想法，它利用了服务器和客户端紧密结合的力量，允许这种动态捆绑和服务。</p><p>&nbsp;</p><p>这些概念开始模糊了 MPA 和 SPA 之间的界限，一个应用程序可以从 MPA 开始，动态地过渡到 SPA。有时（用更流行的话来说）被称为 “过渡性应用程序”。</p><p>&nbsp;</p><p></p><h2>边缘的生活</h2><p></p><p>&nbsp;</p><p>同时，后端基础设施和托管也在不断改进。CDN 的边缘使我们的 SPA 的静态资产服务变得简单而快速。现在将运行时和数据转移到边缘也变得可行了。这是在浏览器之外创建一个新的运行时层，但仍然尽可能地接近用户。这使得将目前在浏览器中完成的许多事情移回服务器变得更加容易。同时在一定程度上减轻了这样做所带来的网络延迟的取舍。</p><p>&nbsp;</p><p>像 React 服务器组件这样的想法正在探索将服务器组件的输出从这一层流向浏览器的概念。像 Deno 和 Bun 这样的新的 Javascript 运行时正在出现，以简化和精简 Javascript 生态系统，并为这个边缘运行时的新世界而构建，为速度和快速启动时间而优化。</p><p>&nbsp;</p><p>这也导致了应用框架采用标准的网络 API 来在这一层运行。随着无服务器功能和流媒体架构被探索出来。</p><p>&nbsp;</p><p>流（Streaming）是这里的一个大主题。它允许提前刷新 HTML，因此浏览器可以在接收到它时逐步进行渲染。在后端同时获取任何数据时，开始处理任何阻碍渲染的资源，如 CSS 和 JS。这有助于并行化许多其他顺序往返行程。</p><p>&nbsp;</p><p></p><h2>概括</h2><p></p><p>&nbsp;</p><p>本文讲了那么多，但实际上只是触及皮毛而已。对于本文中提到的最佳框架、架构或模式，以及我们没有提到的无数其它框架、架构和模式，并没有一个通用的答案。它始终是对特定指标的权衡。而要知道如何权衡，取决于你正在构建的东西、你的用户是谁、他们的使用模式，以及围绕关键用户体验的任何其他要求（如性能预算）的设定。</p><p>&nbsp;</p><p>对于我们中的大多数人来说，真相在某个中间的地方。新一波框架和创新的伟大之处在于，它们提供了根据需要扩大和缩小规模的杠杆。对于那些进入这个行业的人和那些经验丰富的人来说，投资于基本面总是一个不错的选择。</p><p>&nbsp;</p><p>框架的演变慢慢地将原生 Web 推向了更远的地方，消除了以前对框架的需求，并减轻了之前的取舍，使我们能够越来越多地采用其原生特性。</p><p>&nbsp;</p><p>原文链接：</p><p>&nbsp;</p><p><a href=\"https://frontendmastery.com/posts/the-new-wave-of-javascript-web-frameworks/\">https://frontendmastery.com/posts/the-new-wave-of-javascript-web-frameworks/</a>\"</p>",
    "publish_time": "2022-10-11 16:31:27",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Go运行时：4年之后",
    "url": "https://www.infoq.cn/article/UcGg4BHuORGwQ1df5VGg",
    "summary": "<p>自2018年以来，<a href=\"https://www.infoq.cn/article/MwasczNiyzIY7VCNlwo1\">Go</a>\" GC，以及更广泛的Go运行时，一直在稳步改进。近日，<a href=\"https://www.infoq.cn/article/BrxvMywuC2YV79wvgWCN\">Go</a>\"社区总结了4年来Go运行时的一些重要变化。</p><p></p><p>这些重要变化主要是：</p><p>sync.Pool是一种GC感知的重用内存的工具，具有较低的延迟影响，并且能够比之前更有效地回收内存。（Go 1.13）Go运行时能够更主动地将不需要的内存返回给操作系统，减少了内存消耗和出现内存不足的可能性。这将减少最高20%的空闲内存消耗。（Go 1.13和1.14）在许多情况下，Go运行时能够更容易地抢占goroutine，最高可减少90%的stop-the-world延迟。（Go 1.14）Go运行时能够比以前更有效地管理计时器，特别是在拥有多核CPU的机器上。（Go 1.14）在大多数情况下，现在使用defer语句的函数调用的开销与常规函数调用一样少。点击这里观看Gophercon 2020的相关演讲。（Go 1.14）内存分配器的慢路径对CPU核心的伸缩性更好，将吞吐量提升了最多10%，并将尾部延迟降低了最多30%，特别是在高度并行的程序中。（Go 1.14和1.15）Go内存统计数据现在可以通过更细粒度、更灵活、更高效的API（runtime/metrics包）来访问。这将获取运行时统计信息的延迟减少了两个数量级（从毫秒到微秒）。（Go 1.16）Go调度器在寻找新任务时花费的CPU时间减少了30%。（Go 1.17）Go代码现在在amd64、arm64和ppc64上遵循基于寄存器的调用约定，将CPU效率提升了最多15%。（Go 1.17和1.18）Go GC的内部审计和调度已经进行了重新设计，解决了长期存在的各种与效率和健壮性相关的问题。对于goroutine占内存使用很大一部分的应用程序来说，这显著降低了应用程序的尾部延迟（最高达66%）。（Go 1.18）Go GC现在在应用程序空闲时会限制自己的CPU使用。这将空闲应用程序的GC周期的CPU使用降低了75%，从而减少可能导致作业调度器混淆的CPU峰值。（Go 1.19）</p><p></p><p>这些变化对用户来说大多是看不见的——他们只需要升级Go，就可以看到他们所熟悉和喜爱的Go代码运行得更好了。</p><p></p><p></p><h2>一个新的“旋钮”</h2><p></p><p></p><p>Go 1.19带来了一个期待已久的特性，使用这个特性需要做一些额外的工作，但它具备很大的潜力：Go运行时的软内存限制。</p><p></p><p>多年来，Go GC只有一个调优参数——GOGC。GOGC允许用户在CPU开销和内存开销之间做出权衡。多年来，这个“旋钮”为Go社区提供了很好的服务，被用在各种各样的场景中。</p><p></p><p>Go运行时团队一直不愿意在Go运行时中添加新的旋钮，他们的理由很充分——每个新的旋钮代表了配置空间中的一个新的维度，我们需要对其进行测试和维护，而且可能要永远持续下去。旋钮的激增也给Go开发人员增加了理解和使用它们的负担，随着旋钮的增多，情况会变得愈加困难。因此，Go运行时总是倾向于用最小配置实现合理的行为。</p><p></p><p>那么为什么要添加内存限制旋钮呢？</p><p></p><p>内存不像CPU时间那么具有可互换性。对于CPU时间，如果稍等片刻，将来总会得到更多的CPU时间。但对于内存，你所拥有的总是有限的。</p><p></p><p>内存限制解决了两个问题。</p><p></p><p>首先，当应用程序的内存使用峰值不可预测时，仅靠GOGC几乎无法防止内存被耗尽。如果只使用GOGC，Go运行时根本不知道它有多少可用的内存。通过设置内存限制，运行时能够意识到什么时候需要更努力地工作以减少内存开销，从而使运行时能够健壮地应对瞬时的、可恢复的负载峰值。</p><p></p><p>第二是为了避免不使用内存限制时出现的内存不足。我们必须根据内存峰值调优GOGC，而为了保持较低的内存开销会导致更高的GC CPU开销，即使应用程序没有处于内存使用峰值且有足够的可用内存。这在容器化的环境中尤其重要。在容器化的环境中，程序被部署在具有独立预留内存的容器中。设置内存限制可以为峰值负载提供保护，并可以针对CPU开销更主动地调优GOGC。</p><p></p><p>内存限制的设计旨在易用性和健壮性。例如，它是对应用程序中Go部分的整个内存占用的限制，而不仅仅是Go的堆，因此用户不需要额外计算Go运行时的开销。运行时还会根据内存限制调整其内存清除策略，以便在内存出现压力时更主动地将内存返回给操作系统。</p><p></p><p>虽然内存限制是一个强大的工具，但在使用时仍然要谨慎。其中一个需要注意的地方是，它会让你的程序陷入GC抖动状态——在这种状态下，程序运行GC的时间过多，导致没有足够的时间来处理其他任务。例如，如果内存限制设置得比程序实际需要的内存少，Go程序可能会崩溃。以前不太可能出现GC抖动，除非显式对GOGC进行了大量调优。我们选择让内存耗尽而不是陷入抖动状态，因此作为一种缓解措施，运行时将GC限制为总CPU时间的50%，即使这样会超过内存限制。</p><p></p><p>所有这些都需要慎重考虑，因此，作为这项工作的一部分，我们发布了一个新的GC指南，其中包含了交互式可视化的图表，以帮助你们理解GC成本以及如何操作它们。</p><p></p><p>更多可以查看GC指南：<a href=\"https://go.dev/doc/gc-guide?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjU0Nzc4NDEsImZpbGVHVUlEIjoiNVRnYk1qZFdIRjByYWx3USIsImlhdCI6MTY2NTQ3NzU0MSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo1MDA3OTEyfQ.XJNqs-kezT_9bttILHS29vTPPwcOi4sf6kHvboBVETo\">https://go.dev/doc/gc-guide</a>\"</p><p></p><p>原文链接：<a href=\"https://go.dev/blog/go119runtime?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjU0Nzc4NDEsImZpbGVHVUlEIjoiNVRnYk1qZFdIRjByYWx3USIsImlhdCI6MTY2NTQ3NzU0MSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo1MDA3OTEyfQ.XJNqs-kezT_9bttILHS29vTPPwcOi4sf6kHvboBVETo\">https://go.dev/blog/go119runtime</a>\"</p>",
    "publish_time": "2022-10-11 17:35:01",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "关于RabbitMQ，多么希望当初有人告诉我们这些",
    "url": "https://www.infoq.cn/article/XVbtYzyD7PWsV26S2luc",
    "summary": "<p>我的手表嗡嗡作响，在黎明前的昏沉中，我不知道这是闹钟响了还是来电话了。现在是凌晨4点45分。我回过神来，才意识到这是一个陌生号码来电——这可不是什么好兆头。我接通电话，是我的一个同事——他负责我们的支持团队，为我们的客户处理所有的生产问题。“Ryan，抱歉吵醒你，现在还很早。我们最大的客户报告说，他们发出的请求需要两个多小时才能返回结果。我们认为是我们的信息系统出问题了，但我们不确定接下来该怎么做。我们需要你的帮助。请加入我们的电话会议。”过了一会儿，我的手表又响了，这次是闹钟。今天早上的早起可不是为了锻炼。</p><p></p><p>我们已经在生产环境中运行<a href=\"https://www.infoq.cn/article/2010/09/RabbitMQ2.0-release\">RabbitMQ</a>\"将近三年了，99.5%的时间都没有问题。在此期间，我们扩展到了200多个运行在数十个虚拟机上的并发消费者客户端，并处理来自我们.NET应用程序的数亿条消息。我们的主要业务场景是通过HTTP调用Web服务，获取JSON数据或下载PDF文档。我会推荐使用RabbitMQ，因为我们就用了。在大多数情况下，它都很棒，在我们的系统中表现良好。但这里有一个很大的问题，我们在做架构决策时并不知道。</p><p></p><p>我们使用<a href=\"https://www.infoq.cn/article/W7ayyUv5Wx1K5csq36CX\">RabbitMQ</a>\"来轮询调度作业的执行结果。一般的操作顺序是这样的：用户通过Web应用程序提交请求，后端在处理请求时向RabbitMQ中添加消息，消费者客户端获取消息并通过HTTP调用另一个Web服务，将请求提交给实际处理业务逻辑的服务。然后，轮询逻辑开始接管，队列中的后续消息用于轮询处理结果。如果作业还没有执行结果，消费者将消息放回队列，等待下一次轮询尝试（等待时间可由客户配置）。等待的延迟逻辑使用了存活时间（Time-To-Live，TTL）和死信队列。</p><p></p><p>我们的非生产集群使用两个或三个节点，生产集群使用三个节点。每个集群都有一个负载均衡器，应用程序的流量严格流经负载均衡器。在运行时，发布者和消费者使用相同的负载均衡器。</p><p></p><p></p><h1>你应该知道的</h1><p></p><p></p><p>在使用RabbitMQ三年后，如果再要写与RabbitMQ交互相关的代码，我一定会这样告诉我自己。</p><p></p><p></p><h1>一开始就请专家帮忙</h1><p></p><p></p><p>你可以大概花2000到3000美元从RabbitMQ咨询公司找来专家，利用这个机会审查和验证你的假设和计划、提出问题、获取建议并进行尽职调查，这样就可以减少可能在未来出现的问题。从长远来看，现在做出正确的决策，最有可能在未来帮你节约成本。或者你也可以像我们一样，在遇到麻烦时找专家帮忙。</p><p></p><p></p><h1>我们使用了EasyNetQ或NServiceBus</h1><p></p><p></p><p>我们的应用程序使用了RabbitMQ.Client库，一些抽象库（如EasyNetQ和NServiceBus）也使用了它。这些抽象库比我更了解RabbitMQ的底层交互。RabbitMQ的驱动程序相对底层，所以你需要了解RabbitMQ的底层细节。如果这是你第一次使用RabbitMQ，我保证你不会对它有任何溢美之词。</p><p></p><p>如果你想知道“为什么不使用包装器库”，我可以告诉你，最初的开发人员在实现接近尾声时离开了公司，他已经使用了RabbitMQ.Client ，而这个项目最后落到了我的手上。我没有足够的时间重构（我也没想到要把它换成包装器库）。</p><p></p><p></p><h1>网络分区是个大问题</h1><p></p><p></p><p>RabbitMQ一般被部署成集群，集群由一个或多个节点组成，节点是运行RabbitMQ实例的服务器或容器。集群中所有的节点都必须运行完全相同版本的RabbitMQ。</p><p></p><p>RabbitMQ提供了一种叫作聚簇（Clustering）的机制，这样你就可以将多个RabbitMQ实例链接起来，成为一个逻辑Broker。你可以将请求发送给集群中的任意一个节点，节点会合作发布消息或将消息发送给消费者。</p><p></p><p>节点之间通过交换关于消息、队列等的信息不断相互通信。如果通信中断，即使只是几毫秒，RabbitMQ也会进入分区状态，然后它们会根据配置文件中配置的内容决定如何处理通信中断。默认的处理策略是ignore，也就是直接进入分区状态，并在这种“脑裂”模式下继续运行，从而使集群陷入完全的混乱。这对我们来说简直就是地狱（对我来说更是如此）。退出分区状态的唯一方法是重启分区一侧的节点，然后重新连接另一侧，并丢弃从集群发生分区时积累的数据。</p><p></p><p>我经历过两种方式的网络分区：通过Windows更新和防火墙规则同时更新集群中所有的节点。</p><p></p><p>对于这个话题，我可以无休止地咆哮，所以我不得不让自己消停一下。正确的配置应该是将partition_handling策略设置为pause_minority。当集群发生分区时，分区的一侧应该将自己关闭，避免发生脑裂。被关闭的一方继续监控集群，等待恢复通信，并在恢复时重新加入。现在你所要做的就是确保你的代码能够正确地处理断开的连接，这样你就有了一个相当健壮的队列解决方案。</p><p></p><p>根据CAP定理，ignore策略意味着牺牲一致性换取可用性，而pause_minority意味着牺牲可用性换取一致性。如果你问我的话，我认为后者是值得的。</p><p></p><p></p><h1>你打算如何升级RabbitMQ</h1><p></p><p></p><p>你的RabbitMQ版本总归会有过时的那一天。到时候你会怎么做？继续使用不受支持的版本？创建一个新的集群？你计划怎样将流量从遗留集群迁移到新集群？之前已经提到，集群中的所有节点都应该是相同的版本。如果你的计划是进行就地升级，你就会知道这将是多么棘手。</p><p></p><p>我留给你的只有问题，没有答案。因为每一个决策都高度依赖具体的组织和运营策略。换句话说，每个人可能都有不同的方法来解决这些问题。</p><p></p><p></p><h1>如果RabbitMQ的消息全部丢失，你该怎么办</h1><p></p><p></p><p>如果RabbitMQ中所有（或者三分之一）的消息丢失了，你会有多惨？RabbitMQ是你用来保存记录的系统吗？你有让应用程序回到正常状态的恢复策略吗？如果你把本地服务器迁移到云端，如何让你的RabbitMQ消息再次流动起来？</p><p></p><p></p><h1>让发布者和消费者使用不同的连接地址</h1><p></p><p></p><p>在未来的某个时刻（可能是在升级期间），你希望能够灵活地向不同的集群或负载均衡器发布消息或读取消息。这是一种零风险高回报的模式，你可以尽早在应用程序中使用这种模式，未来的你会因此感谢现在的你。</p><p></p><p></p><h1>不断增长的日志文件将占用几十GB的磁盘空间</h1><p></p><p></p><p>随着时间的推移，RabbitMQ的日志文件会增长到占用几十GB的磁盘空间。我们可以使用rabbitmqctl rotate_logs来滚动这些文件，不过也要努力使这个过程自动化，避免因“磁盘空间不足”导致停机。</p><p></p><p></p><h1>结论</h1><p></p><p></p><p>RabbitMQ是我们基础设施的一个稳固的组件，选择它可能是一个正确的决定。但你也应该认真对待我在本文中提出的那些问题，至少应该与你的同事和利益相关者沟通，看看应该试着解决哪些痛点。</p><p></p><p>原文链接：<a href=\"https://ryanrodemoyer.github.io/what-i-wish-someone-would-have-told-me-about-using-rabbitmq-before-it-was-too-late/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjU0ODE4NzMsImZpbGVHVUlEIjoiSnU4QXdaRW5VNjg2MFBJNCIsImlhdCI6MTY2NTQ4MTU3MywiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo1MDA3OTEyfQ.MNhDc4atbhxT1QWSApgk1qeGF2Zwpb6-E1ZKDZpp5jU\">https://ryanrodemoyer.github.io/what-i-wish-someone-would-have-told-me-about-using-rabbitmq-before-it-was-too-late/</a>\"</p><p></p>",
    "publish_time": "2022-10-11 17:55:24",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]