[
  {
    "title": "架构师（2022 年 9 月）",
    "url": "https://www.infoq.cn/article/7sboJ7aY5E0WFBDbpHGj",
    "summary": "<h2>卷首语：成为架构师，你必须具备这五点能力</h2>\n<p>作者 | Alan Tai<br />\n译者 | 冬雨<br />\n策划 | 闫园园</p>\n<p>对于软件架构师这个角色来说，对每一件事情都有经验至关重要。它让你知道什么时候该充当公司的桥梁，当放大或缩小架构图时该关注什么。当在不同的上下文中应用特定的架构设计时，您还将观察模式。在十多家公司工作过之后，我最终进入了<a href=\"https://www.zuehlke.com/en\">Zuhlke</a>咨询公司，在那里我不再需要换工作来获得不同的经验了。我的项目几乎涵盖了无数种行业，包括金融科技、保险科技、物流、制造业、奢侈品时尚、初创企业，这份列表还在不断增长。</p>\n<h3>领域知识</h3>\n<p>对某些业务领域的深入了解对于软件架构师的成功是至关重要的，因为您不仅要知道它是什么，还要知道它将是什么，或者可能是什么，以及为什么。客户经常找到软件架构师，要求向他们展示行业领导者正在做什么以及如何做。领域知识还可以帮助软件架构师说一种商业通用的语言，这反过来帮助他们成为连接管理和开发团队桥梁。</p>\n<h3>人际交往能力</h3>\n<p>软件架构师也是一个伟大的沟通者。许多优秀的高级软件工程师发现很难晋升为软件架构师，因为他们没有展示自己的技能，如倾听、口头和书面沟通、推进、冲突管理、演示、谈判和说服。</p>\n<p>这份工作所需技能的具体类型取决于你工作的特定公司环境。</p>\n<p>在我的公司，我有机会在安全的环境中练习这些技能，比如我们称之为“<a href=\"https://www.zuehlke.com/en/welcome-to-zuhlke-hong-kong\">祖尔克日</a>”和“<a href=\"https://www.zuehlke.com/en/insights/zuhlkes-curiosity-capital-learning-development-during-a-pandemic\">祖尔克营</a>”的环境。我的雇主也在这些方面为我提供了正式的<a href=\"https://www.zuehlke.com/en/our-projects/getting-better-together-at-zuhlke-you-never-stop-developing\">培训</a>。最后，公司的建设性反馈文化支撑着许多人成长了起来。</p>\n<h3>专业技术能力</h3>\n<p>单独任何一张大学文凭都无法证明你是一个软件架构师。你需要学习软件工程的所有领域，包括软件设计、编码、质量保证、DevOps、性能分析、软件安全、项目管理、软件支持等等。这些技能对于创建满足软件架构“能力”的解决方案至关重要。当与开发团队中的专家交流时，软件架构师能够更好地理解相关信息，因为他们已经具备了这些领域的实践经验。</p>\n<p>作为一名开发团队成员，我可以胜任各个领域的日常工作，包括后端、前端和 DevOps。这让我能够以第一人称视角看到幕后发生了什么，并让我能够与团队保持较近的距离。</p>\n<h3>业务和开发过程</h3>\n<p>业务过程描述了一个组织的业务操作，并定义了业务需求，而这些业务需求通常没有清晰地表述为软件项目需求。软件架构师应该知道，或者至少应该知道向谁询问业务流程的相关信息。</p>\n<p>一个向行业组织交付解决方案的软件架构师，需要干上几年时间才能成为领域专家，这种情况并不少见。</p>\n<p>理解技术过程、软件开发生命周期和最佳实践的重要性与了解业务过程一样重要。这是因为软件架构师通常在确保业务和开发过程之间的一致性方面扮演着关键的角色，如此，才能做到迭代交付，才能有现实的项目计划。</p>\n<h3>领导力</h3>\n<p>现在，您应该非常好奇软件架构师如何掌握所有这些知识和技能了吧。好吧，我告诉你，他们并没有掌握！一个人是不可能掌握所有这些的。伟大的产品需要一个有能力的专家团队来开发。成功的软件架构师通常是有效的领导者，他们的团队中拥有伟大的成员，并使成员们成长得更加伟大，而不仅仅是个体。</p>\n<p>软件架构师通常被视为团队的代表。他们在领导、管理业务和技术方面投入了大量的精力。虽然人们常常认为领导者只在站在前面指挥，但有时在一个项目中需要<a href=\"https://learn.coactive.com/your-leadership-approach\">五种领导风格</a>。<a href=\"https://www.zuehlke.com/en\">我们公司</a>提供的领导力培训就是这么教的。</p>\n<p>你准备好成为一名软件架构师来寻求职业生涯的进一步发展了吗？现在是行动的最佳时机！</p>\n<p><strong>作者简介：</strong></p>\n<p><a href=\"https://www.linkedin.com/in/ayltai/\">Alan Tai</a>是 Zuhlke 的首席软件架构师，<a href=\"https://www.zuehlke.com/en\">Zuhlke</a>是一家优质的全球咨询公司，为我们的业务伙伴提供高质量的解决方案。</p>\n<h2>目录</h2>\n<p><strong>热点 | Hot</strong></p>\n<p>是什么让 Redis“气急败坏”回击：13 年来，总有人想替 Redis 换套新架构</p>\n<p>Oracle 大规模裁员进行时：营收暴跌 28%，数据库地位被侵蚀</p>\n<p><strong>理论派｜Theory</strong></p>\n<p>过去的十五年，我们怎样做 IM？</p>\n<p>在云时代，我们该如何看待新的开源许可证？</p>\n<p><strong>推荐文章 | Article</strong></p>\n<p>新浪微博从 Kafka 到 Pulsar 的演变</p>\n<p>理想汽车：从 Hadoop 到云原生的演进与思考</p>\n<p>大规模分布式架构中，怎样设计和选择 API 限流技术？</p>\n<p><strong>观点 | Opinion</strong></p>\n<p>为什么说 DevOps 治理是实现快速开发的关键</p>",
    "publish_time": "2022-09-08 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Debezium和Quarkus：通过CDC模式来避免双重写入",
    "url": "https://www.infoq.cn/article/V4kqPgrQlqqPgWQuMmDP",
    "summary": "<p>在本系列文章的<a href=\"https://www.infoq.cn/article/WfA0p1XoZCJ6INdyJLyv\">第2部分</a>\"，我们学习了Kafka Streams与Quarkus的集成。我们开发了一个简单的应用程序向一个Kafka主题生成事件，并使用Kafka Streams实时消费和处理这些事件。</p><p></p><p>在那个示例中，我们模拟了一家电影流媒体公司。我们将电影信息保存在一个Kafka主题中，当用户停止观看电影，我们将这个事件和已播放的时间保存到另一个主题中。我们对这些事件进行实时的后续处理，计算出一部电影播放超过10分钟的次数。</p><p></p><p>应用程序的架构如下图所示。</p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/change-data-capture-debezium/en/resources/1schema-1660305488714.jpg\" /></p><p>所有的信息都保存在Kafka主题中，但这在现实的项目中是不太可能发生的。</p><p></p><p>在现实当中，电影信息可能保存在传统的数据库中，并用一些分布式缓存来加快查询速度，或者使用搜索引擎建立索引。为简单起见，我们假设电影信息保存在数据库中。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/change-data-capture-debezium/en/resources/1schema-2-1660305488714.jpeg\" /></p><p>这就提出了一个问题——我们如何在两个不同的系统中维护相同的数据，数据库作为主要保存数据的位置，Kafka主题中的数据将使用Kafka Streams来处理。</p><p></p><p>本文将教你如何正确地以不同形式保存相同的数据。</p><p></p><h2>双重写入</h2><p></p><p>要解决这个问题，我们首先想到的可能是双重写入。这是一种最为简单的方法，应用程序负责维护所有位置的数据。例如，当有新的电影信息需要插入时，会执行一个数据库插入，并发送一个事件到Kafka主题。</p><p></p><p>代码可能像下面这样。</p><p><code lang=\"java\">@Channel(\"movies\")\nEmitter&gt; movieEmitter;\n \nprivate static ObjectMapper objectMapper = new ObjectMapper();\n \npublic Movie dualWriteInsert(Movie movie) throws JsonProcessingException {\n    // Inserts to DB\n    movie.persist();\n \n    // Send an event to movies topic\n    final String payloadJson = objectMapper.writeValueAsString(movie);\n    long id = movie.id;\n \n    movieEmitter.send(Record.of(id, payloadJson));\n</code></p><p></p><p>这看起来没什么问题，很容易实现，也很有效，如果没有遇到什么奇怪的问题的话。下面让我们来看看这种方式会遇到怎样的问题。</p><p></p><p>如果数据被持久化在数据库中，但发送到Kafka主题时失败了，你可以把这两个操作包装在一个事务块中。这可以解决事务问题，因为在出错时可以回滚。但你在性能方面付出了巨大的代价，事务范围越大，阻塞数据库的时间就越长。如果两个并发用户想同时更新一个电影信息，会发生什么情况？可能会发生这样的情况——第一个请求更新了数据库，并将事件发送给Kafka，然后第二个请求再次更新数据库和Kafka。在这种情况下，数据库和Kafka主题中的数据是对齐的。但是如果第一个请求只将数据持久化到数据库，第二个请求持久化并发送事件到Kafka，然后第一个请求再将事件发送到Kafka主题，那么此时数据库和Kafka主题中的数据就发生了分歧，产生了不同的值，导致数据之间不一致。当然，你可以使用同步方法，但这将意味着巨大的性能损失。出现第二个问题是因为混合使用了不同的系统，数据库事务的保证范围只限于数据库本身，无法在不同的系统之间起作用。</p><p></p><h2>两阶段提交</h2><p></p><p>这个问题的一个可能的解决方案是使用两阶段提交协议。虽然这可能是一个很好的解决方案，但也存在两个问题。</p><p></p><p>首先，并不是所有的系统都支持分布式事务和两阶段提交。这个协议的问题在于各方之间的通信需要进行额外的协调。这是一个可能的解决方案，但它不是一个通用的解决方案。在我们的示例中，Kafka不支持分布式事务，所以让我们来看看另一个解决方案。</p><p></p><h2>变更数据捕获</h2><p></p><p>变更数据捕获（Change Data CaptureCDC）是一种模式，用于跟踪已更改的数据（例如，添加的新记录、更新的注册表等）并触发事件，让应用程序能够对变更作出反应。</p><p></p><p>有几种实现CDC的方法，例如，在使用行级别的时间戳、版本号或状态指示器，这样就可以定时从一个特定的点检查数据（例如，SELECT * WHERE status=not_read）。但这种方法有一个缺点，你需要经常访问数据库，但这些访问与业务无关，而且需要处理数据被删除的情况。</p><p></p><p>另一种方法是使用数据库触发器，即任何一个数据变更都会触发一个事件，并将事件保存在特定的事件表中。你可以捕获任何一个事件，但仍然需要定时轮询数据库。</p><p></p><p>大多数数据库都有事务日志，它记录了数据库的所有变更。日志扫描器会扫描这个日志，并以非侵入式的方式捕获变更。这种方法的好处如下所示。</p><p></p><p>对数据库的影响最小。变更对应用程序来说是透明的，不需要插入特殊的列。事务完整性。不需要修改数据库Schema。日志扫描是最好的方法，而<a href=\"https://debezium.io/\">Debezium</a>\"是最流行的开源日志扫描器项目。</p><p></p><h4>Debezium</h4><p></p><p>Debezium是一个通过扫描日志实现变更数据捕获的开源项目。启动数据库并配置Debezium，用它消费数据库事务日志中的数据。对于提交给数据库的每一次插入、删除或更新，Debezium都将触发一个事件，应用程序可以向它注册并作出相应的反应。</p><p></p><p>那么为什么说Debezium、CDC和Kafka可以帮助我们解决双重写入的问题呢？Kafka主题由一个或多个分区组成，每个分区按照事件到达的顺序对事件进行排序（事件总是被追加到分区的末尾）。因此，如果我们想要维护并发操作的顺序问题（避免在系统之间有错位的数据），Kafka主题可以帮我们解决这个问题。</p><p></p><p>当然，还有另外一个问题，即在并发操作的情况下，如何按照正确的顺序从数据库中读取数据。CDC和日志扫描器可以确保事务提交后数据的顺序是正确的，并且是非侵入性的，而Debezium可以在这方面发挥作用。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/change-data-capture-debezium/en/resources/1debezium-1-1660305488714.jpeg\" /></p><p>你可以用两种不同的方式来操作Debezium，这两种方式都是有效的，使用哪一种取决于具体情况。这两种方式分别是Debezium服务器或Debezium引擎（嵌入式）。</p><p></p><h4>Debezium服务器</h4><p></p><p>Debezium服务器将Debezium作为Kafka Connect实例运行。Kafka Connect是一个独立的进程，由消费者和生产者启动，用于从Kafka读取数据。Kafka Connect定义了不同数据系统的连接器，然后将大型数据集移入或移出Kafka。由于连接器使用了Kafka API，所以它们是可伸缩的，具有容错能力和较低的延迟。</p><p></p><p>在下面的例子中，假设你想将数据从一个Kafka主题导出到一个索引引擎，比如ElasticSearch。你有两个选择。</p><p></p><p>使用Kafka API创建一个应用程序（就像我们在本系列的<a href=\"https://www.infoq.com/articles/data-with-quarkus-kafka/\">第1部分</a>\"中看到的那样）从Kafka主题读取事件，然后使用ElasticSearch客户端将数据填充到索引中。</p><p></p><p>使用ElasticSearch Kafka Connect，它已经实现了所有这些逻辑，你只需要配置和启动即可。</p><p></p><p>Debezium做的是同样的事情，它从数据库读取事务日志，并将其发送到Kafka主题。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/change-data-capture-debezium/en/resources/1debezium-architecture-2-1660305488714.jpeg\" /></p><p>Debezium最大的优点之一是它可以连接到多种数据库，如MySQL、MongoDB、PostgreSQL、Oracle DB、SQL Server、DB 2、Cassandra和Vitesse。</p><p></p><h4>Debezium引擎</h4><p></p><p>通常情况下我们会使用Debezium服务器，因为它不会干扰应用程序。它是一个用于接收数据变更并填充Kafka主题的服务。</p><p></p><p>但并不是所有的应用程序都需要Kafka Connect提供的容错能力或可伸缩性。此外，有时候应用程序必须自己捕获数据变更事件，并执行一些自定义逻辑，而不只将变更发送到消息传递系统中。</p><p></p><p>对这些情况，debezium-api模块定义了一个API来将Debezium引擎嵌入到应用程序中。</p><p></p><p>到目前为止，我们知道了应该要尽量避免双重写入。我们的解决方案是使用CDC直接从事务日志中获取数据，并将其推送到Kafka主题，这样其他系统就可以以“事务性”的方式和顺序消费这些数据。</p><p></p><h2>发件箱模式</h2><p></p><p>看到这里，你可能会想：“好吧，我可以通过CDC对数据变更作出反应，但内部实体被暴露给了外部系统。”虽然这是真的，但请允许我向你介绍<a href=\"https://microservices.io/patterns/data/transactional-outbox.html\">发件箱模式</a>\"来避免这个问题。</p><p></p><p>发件箱模式提供了一个发件箱表，你可以在其中记录所有实体的操作（可能使用非规范化数据）。然后CDC系统（在我们的例子中使用的是Debezium）对发件箱表（而不是实体表）中的变更做出反应，这样就实现了数据模型与其他系统的隔离。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/change-data-capture-debezium/en/resources/1outbox-table-1660305488714.jpeg\" /></p><p>需要注意的是，实体变更和发件箱必须在同一个事务中。</p><p></p><p>让我们把所有这些碎片放在一个Quarkus项目中，并解决我们在一开始提出的问题——如何在数据库中插入与电影相关的信息，并将其填充到外部系统（Kafka主题）中。</p><p></p><h2>我们的Debezium示例</h2><p></p><p>我们不再为每一种场景手动编写代码，而是使用Debezium引擎并将它与Quarkus集成来解决这个问题。</p><p></p><h4>创建项目</h4><p></p><p>到Quarkus<a href=\"https://code.quarkus.io/\">起始页</a>\"，选择RestEasy Reactive和RestEasy Reactive Jackson插件（用于编码/解码数据），实现JAX-RS端点，使用Panache和MySQL驱动程序将电影信息插入到MySQL数据库，使用SmallRye Reactive Messaging与Kafka发生交互。另外，取消选中Started Code选项，如下图所示。</p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/change-data-capture-debezium/en/resources/1configure-1660305488714.jpeg\" /></p><p>你可以跳过这个手动步骤，并打开<a href=\"https://code.quarkus.io/?a=movie-plays-producer-debezium&amp;j=17&amp;nc=true&amp;e=resteasy-reactive&amp;e=resteasy-reactive-jackson&amp;e=smallrye-reactive-messaging-kafka&amp;e=jdbc-mysql&amp;e=hibernate-orm-rest-data-panache&amp;extension-search=panache\">Quarkus Generator</a>\"链接，这里所有的依赖项都被选中。然后按下“Generate your application”按钮，下载搭建好的应用程序zip文件包。</p><p></p><p>解压缩文件并在你最喜欢的IDE中打开项目。</p><p></p><h4>开发</h4><p></p><p>在开始编码之前，我们需要添加两个新的依赖项：一个用于使用Debezium引擎，另一个用于添加Debezium Quarkus Outbox插件。</p><p></p><h4>Debezium引擎</h4><p></p><p>打开pom.xml文件并添加以下依赖项。</p><p></p><p>在dependencyManagement部分：</p><p><code lang=\"java\">\n   io.debezium\n   debezium-bom\n   1.9.4.Final\n   pom\n   import\n\n</code></p><p></p><p>在dependencies部分：</p><p><code lang=\"java\">\n  io.debezium\n  debezium-ddl-parser\n\n\n  io.debezium\n  debezium-embedded\n\n<!-- We connect to a MySQL database, so we need debezium MySQL connector -->\n\n  io.debezium\n  debezium-connector-mysql\n\n</code></p><p></p><p>这是为了使用嵌入在应用程序中的Debezium引擎。如果我们使用Debezium服务器，就不需要这些依赖项，因为它是一个独立的服务。</p><p></p><h4>Debezium Quarkus Outbox插件</h4><p></p><p>Quarkus通过<a href=\"https://debezium.io/documentation/reference/stable/integrations/outbox.html\">Debezium Quarkus Outbox</a>\"插件实现发件箱模式。</p><p></p><p>打开pom.xml文件并添加以下依赖项。</p><p></p><p>在dependencyManagement部分：</p><p><code lang=\"java\">\n   ${quarkus.platform.group-id}\n   quarkus-debezium-bom\n   ${quarkus.platform.version}\n   pom\n   import\n \n</code></p><p></p><p>请注意BOM的版本与Quarkus版本要对齐，在这里是2.10.1.Final。</p><p></p><p>在dependencies部分：</p><p><code lang=\"java\">\n  io.debezium\n  debezium-quarkus-outbox\n\n</code></p><p></p><h4>实现</h4><p></p><p>你可以选择不使用发件箱模式或自己实现它，如果是这样，那么这些依赖项就都不需要。但为简单起见，我们在这里使用它。</p><p></p><p>有了这些依赖项，我们就可以创建带有JPA注解并扩展了PanacheEntity类的的Movie实体。</p><p><code lang=\"java\">import javax.persistence.Entity;\n \nimport io.quarkus.hibernate.orm.panache.PanacheEntity;\n \n@Entity\npublic class Movie extends PanacheEntity {\n  \n   // No worries Quarkus will change them\n   // to private and auto-generate getters/setters at compilation time\n   public String name;\n   public String director;\n   public String genre;\n \n}\n</code></p><p></p><p>下一步是创建一个HTTP端点，使用JAX-RS注解将电影信息插入到数据库中。</p><p><code lang=\"java\">import javax.inject.Inject;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\n \nimport org.jboss.logging.Logger;\n \n@Path(\"/movie\")\npublic class MovieResource {\n \n   // Service to insert the movie data into Movie and Outbox tables\n   @Inject\n   MovieService movieService;\n \n   // Injects the logger\n   @Inject\n   Logger logger;\n \n   // Http Post method to insert a movie\n   @POST\n   public Movie insert(Movie movie) {\n       logger.info(\"New Movie inserted \" + movie.name);\n       System.out.println(\":)\");\n      \n       return movieService.insertMovie(movie);\n   }\n}\n</code></p><p></p><p>因为我们使用的是Debezium Quarkus Outbox插件，所以需要创建一个用于表示发件箱表中存储的内容的实体。实体必须实现ExportedEvent接口，并实现接口方法来识别发件箱表中放置的事件类型。</p><p><code lang=\"java\">import java.time.Instant;\n \nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\n \nimport io.debezium.outbox.quarkus.ExportedEvent;\n \npublic class MovieEvent implements ExportedEvent {\n \n   private static ObjectMapper mapper = new ObjectMapper();\n \n   // Set the type enclosed inside the event\n   private static final String TYPE = \"Movie\";\n   // Set the event type\n   private static final String EVENT_TYPE = \"MovieCreated\";\n \n   private final long gameId;\n   private final JsonNode jsonNode;\n   private final Instant timestamp;\n \n   // Saves Game info in the class\n   public MovieEvent(Movie movie) {\n       this.gameId = movie.id;\n       this.timestamp = Instant.now();\n       // Saves game content in a string column in JSON format\n       this.jsonNode = convertToJson(movie);\n   }\n \n   @Override\n   public String getAggregateId() {\n       return String.valueOf(this.gameId);\n   }\n \n   @Override\n   public String getAggregateType() {\n       return TYPE;\n   }\n \n   @Override\n   public JsonNode getPayload() {\n       return jsonNode;\n   }\n \n   @Override\n   public Instant getTimestamp() {\n       return timestamp;\n   }\n \n   @Override\n   public String getType() {\n       return EVENT_TYPE;\n   }\n  \n   private JsonNode convertToJson(Movie movie) {\n       ObjectNode asJson = mapper.createObjectNode()\n               .put(\"id\", movie.id)\n               .put(\"name\", movie.name)\n               .put(\"director\", movie.director)\n               .put(\"genre\", movie.genre);\n      \n       return asJson;\n   }\n \n}\n</code></p><p></p><p>在将Debezium逻辑添加到代码之前，我们还需要实现MovieService类，加入插入数据的逻辑。这个逻辑应该将电影信息持久化到Movie表中，并将MovieEvent实体持久化到由OutboxEvent插件管理的表中。</p><p></p><p>这个插件提供了一个特定的CDI事件来持久化实现了ExportedEvent接口的事件。我们唯一要做的事情是触发一个事件，数据将自动被持久化。</p><p><code lang=\"java\">import javax.enterprise.context.ApplicationScoped;\nimport javax.enterprise.event.Event;\nimport javax.inject.Inject;\nimport javax.transaction.Transactional;\n \nimport io.debezium.outbox.quarkus.ExportedEvent;\n \n@ApplicationScoped\npublic class MovieService {\n  \n   // CDI event interface triggering Outbox entities\n   @Inject\n   Event&gt; event;\n \n   // Transaction method\n   @Transactional\n   public Movie insertMovie(Movie movie) {\n \n       // Persists data\n       movie.persist();\n      \n       // Persists outbox content\n       event.fire(new MovieEvent(movie));\n      \n       return movie;\n   }\n}\n</code></p><p></p><p>最后一步是配置Debezium引擎，并将其嵌入到应用程序中。</p><p></p><p>要配置引擎，你需要设置数据库信息（主机名、端口、凭证）以及Debezium要监控的数据库和表。</p><p></p><p><code lang=\"java\">import java.io.File;\nimport java.io.IOException;\n \nimport javax.enterprise.inject.Produces;\n \nimport org.eclipse.microprofile.config.inject.ConfigProperty;\n \nimport io.debezium.config.Configuration;\n \npublic class DebeziumConfiguration {\n  \n   // Debezium needs Database URL and credentials to login and\n   // monitor transaction logs\n   @ConfigProperty(name = \"quarkus.datasource.jdbc.url\")\n   String url;\n \n   @ConfigProperty(name = \"quarkus.datasource.password\")\n   String password;\n \n   @ConfigProperty(name = \"quarkus.datasource.username\")\n   String username;\n\n   @Produces\n   public Configuration configureDebezium() throws IOException {\n \n       // Custom class to get database name or hostname of Database server\n       MySqlJdbcParser jdbcParser = MySqlJdbcParser.parse(url);\n      \n       File fileOffset = File.createTempFile(\"offset\", \".dat\");\n       File fileDbHistory = File.createTempFile(\"dbhistory\", \".dat\");\n \n       return io.debezium.config.Configuration.create()\n           .with(\"name\", \"movies-mysql-connector\")\n           // configures MySQL connector\n           .with(\"connector.class\", \"io.debezium.connector.mysql.MySqlConnector\")\n           .with(\"offset.storage\", \"org.apache.kafka.connect.storage.FileOffsetBackingStore\")\n           .with(\"offset.storage.file.filename\", fileOffset.getAbsolutePath())\n           .with(\"offset.flush.interval.ms\", \"60000\")\n           // Configures database location\n           .with(\"database.hostname\", jdbcParser.getHost())\n           .with(\"database.port\", jdbcParser.getPort())\n           .with(\"database.user\", \"root\")\n           .with(\"database.allowPublicKeyRetrieval\", \"true\")\n           .with(\"database.password\", password)\n           .with(\"database.dbname\", jdbcParser.getDatabase())\n           .with(\"database.include.list\", jdbcParser.getDatabase())\n           // Debezium only sends events for the modifications of OutboxEvent table and not all tables\n           .with(\"table.include.list\", jdbcParser.getDatabase() + \".OutboxEvent\")\n           .with(\"include.schema.changes\", \"false\")\n           .with(\"database.server.id\", \"10181\")\n           .with(\"database.server.name\", \"movies-mysql-db-server\")\n           .with(\"database.history\", \"io.debezium.relational.history.FileDatabaseHistory\")\n           .with(\"database.history.file.filename\", fileDbHistory.getAbsolutePath())\n       .build();\n   }\n \n}\n</code></p><p></p><p>DebeziumListener CDI类会在应用程序启动时启动Debezium。</p><p></p><p>Debezium引擎并不是在单独的线程中运行，所以我们需要提供一个并行运行的线程，而不是阻塞应用程序的线程。在Quarkus中，我们可以使用ManagedExecutor提供执行程序线程来运行Debezium。</p><p></p><p>然后，我们需要使用DebeziumEngine类来实例化Debezium引擎，并设置在上一步中创建的配置属性。最重要的一个步骤是注册一个在Debezium每次生成事件时触发的方法。notifying方法会对这个自定义方法进行注册，在我们的示例中，这个方法叫作handleChangeEvent。</p><p></p><p>这个方法用于接收事件，我们可以实现任何我们想要的逻辑——将事件发送到Kafka主题或者其他服务——任何你可以在Java中实现的东西。</p><p><code lang=\"java\">import java.io.IOException;\n \nimport javax.enterprise.context.ApplicationScoped;\nimport javax.enterprise.event.Observes;\n \nimport org.apache.kafka.connect.data.Struct;\nimport org.apache.kafka.connect.source.SourceRecord;\nimport org.eclipse.microprofile.context.ManagedExecutor;\nimport org.eclipse.microprofile.reactive.messaging.Channel;\nimport org.eclipse.microprofile.reactive.messaging.Emitter;\n \nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n \nimport io.debezium.config.Configuration;\nimport io.debezium.embedded.Connect;\nimport io.debezium.engine.DebeziumEngine;\nimport io.debezium.engine.RecordChangeEvent;\nimport io.debezium.engine.format.ChangeEventFormat;\nimport io.quarkus.runtime.ShutdownEvent;\nimport io.quarkus.runtime.StartupEvent;\nimport io.smallrye.reactive.messaging.kafka.Record;\n \nimport static io.debezium.data.Envelope.FieldName.*;\nimport static io.debezium.data.Envelope.Operation;\n\n@ApplicationScoped\npublic class DebeziumListener {\n  \n   private static ObjectMapper objectMapper = new ObjectMapper();\n \n   // Start the Debezium engine in a different thread\n   ManagedExecutor executor;\n \n   // Debezium configuration object\n   Configuration configuration;\n \n   private DebeziumEngine&gt; engine;\n \n   public DebeziumListener(ManagedExecutor executor, Configuration configuration) {\n       this.executor = executor;\n       this.configuration = configuration;\n   }\n \n   // Interface to send events to movies Kafka topic\n   @Channel(\"movies\")\n   Emitter&gt; movieEmitter;\n \n   void onStart(@Observes StartupEvent event) {\n \n       // Configures Debezium engine\n       this.engine = DebeziumEngine.create(ChangeEventFormat.of(Connect.class))\n           .using(this.configuration.asProperties())\n           // For each event triggered by Debezium, the handleChangeEvnt method is called\n           .notifying(this::handleChangeEvent)\n           .build();\n \n       // Starts Debezium in different thread\n       this.executor.execute(this.engine);\n   }\n\n   void handleChangeEvent(RecordChangeEvent sourceRecordRecordChangeEvent) {\n \n       // For each triggered event, we get the information\n       SourceRecord sourceRecord = sourceRecordRecordChangeEvent.record();\n       Struct sourceRecordChangeValue= (Struct) sourceRecord.value();\n \n       if (sourceRecordChangeValue != null) {\n           Operation operation = Operation.forCode((String) sourceRecordChangeValue.get(OPERATION));\n \n           // Only insert operations are processed\n           if(operation == Operation.CREATE) {\n \n               // Get insertation info\n               Struct struct = (Struct) sourceRecordChangeValue.get(AFTER);\n               String type = struct.getString(\"type\");\n               String payload = struct.getString(\"payload\");\n \n               if (\"GameCreated\".equals(type)) {\n                   try {\n                       final JsonNode payloadJson = objectMapper.readValue(payload, JsonNode.class);\n                       long id = payloadJson.get(\"id\").asLong();\n \n                       // Populate content to Kafka topic\n                       movieEmitter.send(Record.of(id, payloadJson));\n                   } catch (JsonProcessingException e) {\n                       throw new IllegalArgumentException(e);\n                   }\n               }\n           }\n       }\n   }\n\n   void onStop(@Observes ShutdownEvent event) throws IOException {\n       if (this.engine != null) {\n           this.engine.close();\n       }\n   }\n \n}\n</code></p><p></p><h4>运行</h4><p></p><p>这个示例是自包含的，因此你不需要启动任何东西，因为Quarkus会为你启动它。</p><p></p><p>Panache和Kafka Connector已经与Quarkus <a href=\"https://quarkus.io/guides/dev-services\">DevServices</a>\"集成，因此我们不需要启动Kafka集群或MySQL数据库，也不需要将它们配置为Quarkus Dev模式。电脑上需要有一个可运行的容器运行时，比如Podman或任何其他兼容OCI的工具。</p><p></p><p>为了便于跟踪，在运行应用程序之前，我们向应用程序中添加两个配置属性。在application.properties文件中添加下面的两行。</p><p></p><p><code lang=\"java\">quarkus.hibernate-orm.log.sql=true\nquarkus.debezium-outbox.remove-after-insert=false\n</code></p><p></p><p>第一行记录执行的SQL语句。这有助于在插入数据时对两张表（Movies和OutboxEvent）进行验证。</p><p></p><p>第二行避免Debezium在使用发件箱表后删除数据。</p><p></p><p>在终端窗口中启动服务：</p><p><code lang=\"java\">./mvnw clean quarkus:dev\n\n…\n2022-07-07 11:36:22,942 INFO  [io.deb.con.mys.MySqlStreamingChangeEventSource] (debezium-mysqlconnector-movies-mysql-db-server-change-event-source-coordinator) Waiting for keepalive thread to start\n2022-07-07 11:36:22,948 INFO  [io.deb.con.mys.MySqlStreamingChangeEventSource] (debezium-mysqlconnector-movies-mysql-db-server-change-event-source-coordinator) Keepalive thread is running\n2022-07-07 11:37:43,889 INFO  [org.acm.MovieResource] (executor-thread-1) New Movie inserted string\n</code></p><p></p><p>几秒钟后，Kafka集群、MySQL实例和应用程序就启动起来了。</p><p></p><p>通过检查运行的容器来验证实例：</p><p><code lang=\"java\">docker ps\n\nCONTAINER ID   IMAGE                          COMMAND                  CREATED          STATUS          PORTS                                    \n         \nfa316bfae219   vectorized/redpanda:v21.11.3   \"sh -c 'while [ ! -f…\"   49 seconds ago   Up 45 seconds   8081-8082/tcp, 9644/tcp, 0.0.0.0:55002-&gt;9092/tcp\n\n4c220f7ee066   mysql:8.0                      \"docker-entrypoint.s…\"   50 seconds ago   Up 46 seconds   33060/tcp, 0.0.0.0:60652-&gt;3306/tcp\n\ne41cae02ff02   testcontainers/ryuk:0.3.3      \"/app\"                   53 seconds ago   Up 50 seconds   0.0.0.0:60650-&gt;8080/tcp\n</code></p><p></p><p>Kafka集群运行在端口55002上，和MySQL（ID为4c220f7ee066）运行在端口60652上。</p><p></p><p>注意：不同情况下端口和ID可能不同。</p><p></p><p>在另一个终端窗口中运行curl命令，插入一个新的Movie记录。</p><p><code lang=\"shell\">curl -X 'POST' \\\n  'http://localhost:8080/movie' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n  \"name\": \"Minions: The Rise of Gru\",\n  \"director\": \"Kyle Balda\",\n  \"genre\": \"Animation\"\n}'\n</code></p><p></p><p>检查Quarkus终端窗口，可以看到数据库运行的SQL语句。</p><p><code lang=\"java\">:)\nHibernate:\n    select\n        next_val as id_val\n    from\n        hibernate_sequence for update\n\n\n\nHibernate:\n    update\n        hibernate_sequence\n    set\n        next_val= ?\n    where\n        next_val=?\n\n// Insert into Movie \n\nHibernate:\n    insert\n    into\n        Movie\n        (director, genre, name, id)\n    values\n        (?, ?, ?, ?)\n\n// Automatically OutboxEvent table receives an insert\n\nHibernate:\n    insert\n    into\n        OutboxEvent\n        (aggregatetype, aggregateid, type, timestamp, payload, tracingspancontext, id)\n    values\n        (?, ?, ?, ?, ?, ?, ?)\n</code></p><p></p><p>为了验证Debezium可以检测到变更并将其推送到Movies Kafka主题，我们将运行<a href=\"https://github.com/edenhill/kcat\">kcat</a>\"工具来查询Kafka主题。</p><p></p><p><code lang=\"plain\">kcat -b localhost:55002 -C -t movies\n\n{\"id\":1,\"name\":\"Minions: The Rise of Gru\",\"director\":\"Kyle Balda\",\"genre\":\"Animation\"}\n% Reached end of topic movies [0] at offset 1\n</code></p><p></p><h2>结论</h2><p></p><p>我们实现了一种解决方案，通过使用Debezium读取事务日志并为每一个变更触发一个事件，解决了数据库和外部系统之间的双重写入问题。</p><p></p><p>在本例中，我们使用了Debezium引擎，并实现了在触发事件时执行的逻辑。</p><p></p><p>嵌入式方式可能在某些场景中有用，但在其他场景中（特别是在需要高可伸缩性和容错能力的项目中)，Debezium服务器可能更适合。如果使用Debezium服务器（作为一个Kafka Connect进程)，你的代码就不需要做出修改（没有依赖项），因为Debezium是一个独立的进程，它会自己连接到数据库事务日志，检测变更，并将它们发送到Kafka主题。由于事件是有序的，所以任何系统都可以消费主题中的变更事件。</p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/change-data-capture-debezium/en/resources/2debezium-architecture-2-1660305488714.jpeg\" /></p><p>尽管在使用Debezium时，发件箱模式并不是必需的（到最后，Debezium可以监听任何一张表中的变更），但隔离数据是一个很好的实践，发件箱模式可以帮助你做到这一点。</p><p></p><p>集成（微）服务架构最初看起来可能很容易，但当你开始集成数据时，事情就变复杂了，而Debezium项目可以帮助你完成这项任务。</p><p></p><p>源代码可以在<a href=\"https://github.com/lordofthejars/movie-plays-kafka\">GitHub</a>\"上找到。</p><p></p><p>作者简介：</p><p>Alex Soto是Red Hat的开发者体验总监。他对Java和软件自动化充满热情，并相信开源软件模型。Soto是《Testing Java Microservices》（Manning）和《Quarkus Cookbook》（O'Reilly）的合著者，也是几个开源项目的贡献者。自2017年以来，他获得Java Champion的称号，也是Salle URL University的国际演讲者和教师。你可以在Twitter上关注他（Alex Soto），了解Kubernetes和Java世界正在发生的事情。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/change-data-capture-debezium/\">https://www.infoq.com/articles/change-data-capture-debezium/</a>\"</p><p></p><p>相关阅读：</p><p>本系列第一部分：<a href=\"https://www.infoq.cn/article/cFpvXRLmZzJBGbzAeFu5\">使用 Apache Kafka 实现 Quarkus 的反应式消息</a>\"</p><p>本系列第二部分：<a href=\"https://www.infoq.cn/article/WfA0p1XoZCJ6INdyJLyv\">Kafka Streams 与 Quarkus：实时处理事件</a>\"</p>",
    "publish_time": "2022-09-08 09:17:45",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]