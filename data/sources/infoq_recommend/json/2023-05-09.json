[
  {
    "title": "中国开源未来发展峰会“问道 AI 分论坛”即将开幕！",
    "url": "https://www.infoq.cn/article/02ac19e3401d4bf0e28048802",
    "summary": "<p>过去几个月，AI几乎已经成为全民热议的话题。各式开源大模型、训练框架层出不穷；AI技术也加速应用在各个领域和行业，例如服务运营优化、解决供应链问题等等；数据库、云计算、大前端等多类技术领域产品纷纷探索集成AI技术；在资本市场，AI技术的投资与投资收益都呈现上升趋势；全球范围内的AI交流活动在明显增加……</p><p>&nbsp;</p><p>聚焦至AI技术本身，我们可以看到，当下新兴的AI工具几乎全部以开源的模式出现。许多业内专家更是认为，开源是未来的AI领域技术工具产品存活于市场的必要条件。</p><p>&nbsp;</p><p>然而，在备受追捧的现状背后，也隐藏着众多风险与挑战，比如数据安全和隐私保护的问题，我们该如何适合AI浪潮的发展，一个好的AI技术产品该如何迭代与运营……</p><p>&nbsp;</p><p>为了能够与广大开发者一起更好地拥抱AI技术的发展，5月13日，由天工开物开源基金会、开源中国社区联合发起的，面向广大开发者的中国开源未来发展峰会“问道AI分论坛”将在重庆富力假日酒店举办，论坛将邀请国内多位一线AI领域大咖，从底层技术、产品设计、开源社区运营等角度详解“AI +开源”的发展现状与未来方向。</p><p><img src=\"https://static001.geekbang.org/infoq/50/50824edbaa0cbee08525958723a7dc8d.png\" /></p><p>在“问道AI分论坛”之外，本次峰会也将聚焦开源技术前沿与生态革新，将联合产学研用各领域开源专家，共同探讨中国开源未来如何更好地发展；更有开源项目路演策划，邀请10余位开源领域大牛，结合基金会的理念、项目考核标准和项目情况，对开源项目进行考核；完成天工开物首次帮扶开源项目发展。</p><p><img src=\"https://static001.geekbang.org/infoq/86/864520e1bf1d678a669d36851c2ba392.png\" /></p><p>值得一提的是，本次峰会是天工开物开源基金会首次主办活动，正式近距离为行业、为开发者全方位展现开源事业的魅力所在。天工开物开源基金会是致力于推动中国开源事业发展的非营利机构，于2022年12月31日在重庆揭牌，由重庆市政府批复设立，由清华大学，华中科技大学，重庆大学，中冶赛迪，中国信科，中科院等知名高校和企业联合发起。</p><p>&nbsp;</p><p>届时现场活动将与线上直播同时进行，覆盖新华社、人民日报、澎湃新闻等国家一级类新闻媒体，今日头条等热门客户端在内的100+个新闻门户网站。重点覆盖国内知名科技类新闻网站，博客、微博、头条号、百家号、知乎机构号全方位发稿，科技圈全方位触达，与百万开发者共同见证未来。</p><p>&nbsp;</p><p>中国开源，未来已来！</p><p>5月13日，重庆富力假日酒店（重庆市沙坪坝区大学城南路26号）期待您的莅临！</p>",
    "publish_time": "2023-05-09 10:03:33",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "代码注释的艺术，优秀代码真的不需要注释吗？",
    "url": "https://www.infoq.cn/article/33d315fdbf35662c011b68fb8",
    "summary": "<p>作者：聂晓龙</p><p></p><p></p><blockquote>注释并不会妨碍你写出优雅简洁的代码，它只是程序固有的一部分而已。</blockquote><p></p><p></p><p></p><h1>一、前言</h1><p></p><p></p><p>回家路上，有辆车强行插到前面的空位，司机大哥暴躁地拍着方向盘吐槽道“加塞最可恶了”，我问“还有更可恶的吗”，司机大哥淡定说道“不让自己加塞的”。我们程序员界也有这两件相似的事：最讨厌别人不写注释，更讨厌让自己写注释。</p><p></p><p>一段糟糕的代码，往往大家最低的预期是把注释写清楚，最合理的做法通常应该对代码做优化。如果我们将代码真正做到了优秀，我们是否还需要注释？</p><p></p><p></p><h1>二、注释的意义</h1><p></p><p></p><p><code lang=\"text\">; **************************************************************************\n; * RAMinit Release 2.0 *\n; * Copyright (c) 1989-1994 by Yellow Rose Software Co. *\n; * Written by Mr. Leijun *\n; * Press HotKey to remove all TSR program after this program *\n; **************************************************************************\n; Removed Softwares by RI:\n; SPDOS v6.0F, WPS v3.0F\n; Game Busters III, IV\n; NETX ( Novell 3.11 )\n; PC-CACHE\n; Norton Cache\n; Microsoft SmartDrv\n; SideKick 1.56A\n; MOUSE Driver\n; Crazy (Monochrome simulate CGA program)\n; RAMBIOS v2.0\n; 386MAX Version 6.01</code></p><p></p><p>注释是对代码的解释和说明，本质目的是为了增强程序的可读性与可解释性。注释会随着源代码，在进入预处理器或编译器处理后会被移除。这是雷布斯1994年写的一段MASM汇编代码，注释与代码整体结构都非常清晰。如果说代码是为了让机器读懂我们的指令，那注释完全就是为了让我们了解我们自己到底发出了哪些指令。</p><p></p><p></p><h1>三、争议与分歧</h1><p></p><p></p><p>注释的起源非常早，我们甚至已经查阅不到注释的由来，但现在任何一种语言，甚至几乎任何一种文本格式都支持各式各样的注释形式。</p><p></p><p>但如何使用注释，其实一直是一个备受争论的话题。当我们接手一段‘祖传代码’时，没有注释的感觉简直让人抓狂，我们总是希望别人能提供更多的注释。但软件界也有一段神话传说，叫做『我的代码像诗一样优雅』。有注释的代码都存在着一些瑕疵，认为足够完美的代码是不需要注释的。</p><p></p><p></p><h1>四、坏代码的救命稻草</h1><p></p><p></p><p></p><blockquote>The proper use of comments is to compensate for our failure to express ourself in code.— Robert C. Martin 《Clean Code》译：注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败</blockquote><p></p><p></p><p>Clean Code的作者Robert C. Martin可以说是注释的极力否定者了，他认为注释是一种失败，当我们无法找到不用注释就能表达自我的方法时，才会使用注释，任何一次注释的使用，我们都应该意识到是自己表达能力上的失败。</p><p></p><p>PH&amp;V的系统架构师和负责人Peter Vogel，同样也是一名坚定的注释否定者，他发表了一篇文章 why commenting code is still bad 来表述为代码添加注释在某种程度上可能是必要的，但确实没有价值。</p><p></p><p>事实上，我们也确实遇到过非常多无价值的注释，以及完全应由代码来承担解释工作的“职能错位”的注释。</p><p></p><p></p><h2>4.1 零注释</h2><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/80/80dc4e87972771f39117df3792c1c922.png\" /></p><p></p><p>糟糕的代码加上完全不存在的注释，我喜欢称呼它们为『我和上帝之间的秘密』，当然过两个月后也可以称之为『上帝一个人的秘密』。</p><p></p><p>压垮程序员的最后一根稻草，往往都是零注释。可以没有文档，也可以没有设计，但如果没有注释，我们每一次阅读都是灾难性的。当我们抱怨它一行注释都没有时，其实我们是在抱怨我们很难理解代码想要表达的含义，注释是直接原因，但根本原因是代码。</p><p></p><p>零注释往往和坏代码一起生活，“没有注释”的吐槽，其实本质上直击的是那堆歪七扭八的英文字母，它们到底想表达什么！</p><p></p><p></p><h2>4.2 无用注释</h2><p></p><p></p><p><code lang=\"text\">/**  * returns the last day of the month  * @return the last day of the month  */\npublic Date getLastDayOfMonth(Date date) {\n    Calendar calendar = new GregorianCalendar();\n    calendar.setTime(date);\n    calendar.set(Calendar.DAY_OF_MONTH, calendar.getActualMaximum(Calendar.DAY_OF_MONTH));\n    return calendar.getTime();\n}</code></p><p></p><p>这是典型的废话注释，读代码时代码本身就能很好的表达具体的含义，我们完全不需要看注释，并且注释也不会给我们提供更多有效的信息。无用注释或许是零注释的另一个极端，我们担心自己写的代码被人所吐槽，于是尽可能去补全注释，当你为getLastDayOfMonth()补一段get last day of month的注释时，恭喜你，你得到了双倍的代码。</p><p></p><p></p><h2>4.3 代码优于注释</h2><p></p><p></p><p></p><blockquote>\"Comments Do Not Make Up for Bad Code\"— Robert C.Martin 《Clean Code》译：注释不能美化糟糕的代码</blockquote><p></p><p></p><p>当需要为一段代码加上注释时，说明代码已经不能很好的表达意图，于是大家开始为这段代码添加注释。Robert C.Martin在Clean Code中提出一个观点：注释不能美化糟糕的代码。能用代码表达的直接用代码表达，不能用代码表达的，你再想想，如何能用代码表达。</p><p></p><p>复杂的代码最直接的表现就是不够直观、难以理解，加上注释后往往会清晰很多，但你是愿意看这段代码？</p><p></p><p><code lang=\"text\">// 判断是否活跃用户\nif((customer.getLastLoginTime().after(dateUtils.minusDays(new Date(),15)) &amp;&amp; customer.getCommentsLast30Days() &gt; 5) \n    || orderService.countRecentDaysByCustomer(customer,30) &gt; 1)</code></p><p></p><p>还是这段代码？</p><p></p><p><code lang=\"text\">if(customer.isActive())</code></p><p></p><p>糟糕代码的存在，通常是我们写注释的常见动机之一。这种试图粉饰可读性差的代码的注释称之为『拐杖式注释』，即使大名鼎鼎的JDK，也存在这样的拐杖式注释。</p><p></p><p><code lang=\"text\">public synchronized void setFormatter(Formatter newFormatter) {\n    checkPermission();\n    // Check for a null pointer\n    newFormatter.getClass();\n    formatter = newFormatter;\n}</code></p><p></p><p>这是取自JDK java.util.logging.Handler类的setFormatter方法，作者为了不让空指针异常下传，提前做一次空指针检查。没有这段注释我们完全不知道游离的这句newFormatter.getClass()到底要做什么，这段注释也充分表达了作者自己也知道这句代码难以理解，所以他加上了注释进行说明。但我们完全可以用Objects.requireNonNull()来进行替代。同样的代码作用，但可读性可理解性大不一样，JDK里的这段代码，确实让人遗憾。</p><p></p><p></p><h2>4.4 注释否定论</h2><p></p><p></p><p></p><blockquote>\"If our programming languages were expressive enough, or if we had the talent to subtly wield those languages to express our intent, we would not need comments very much—perhaps not at all.\"— Robert C.Martin 《Clean Code》译：若编程语言足够有表达力，或者我们长于用这些语言来表达意图，就不那么需要注释--也许根本不需要</blockquote><p></p><p></p><p>通过代码进行阐述，是注释否定论的核心思想。当你花功夫来想如何写注释，让这段代码更好的表达含义时，我们更应该重构它，通过代码来解释我们的意图。每一次注释的编写，都是对我们代码表达能力上的差评，提升我们的归纳、表达、解释能力，更优于通过注释来解决问题。当代码足够优秀时，注释则是非必须的。并且需求在不断调整，代码一定会随之变动，但注释可能慢慢被人遗忘，当代码与注释不匹配时，将是更大的灾难。</p><p></p><p></p><h1>五、软件设计的乌托邦</h1><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/73/73b8e508cd6ccaa1ad4b3ed55efbe4f8.png\" /></p><p></p><p></p><h2>5.1 优秀的代码</h2><p></p><p></p><p>曾经我的确对优秀的代码不断钻研，对代码本身所蕴含的能量无比坚信。如同当科学代替鬼神论走上历史舞台时，即使存在有科学解释不了，我们依然坚信只是科学还需要发展。当代码别人无法理解时，我会认为是我表述不够精准，抽象不够合理，然后去重构去完善。</p><p></p><p>有一次给老板review代码，当时老板提出，“你的代码缺少注释”，我说不需要注释，代码就能自解释。于是老板现场读了一段代码，“query-customer-list 查询客户”、“transfer-customer-to-sales 分发客户到销售”、“check-sales-capacity 检查销售库容”，每一个类每一个函数，一个单词一个单词往外蹦时，你会发现好像确实都能读懂，于是老板回了一个“好吧”。</p><p></p><p></p><h2>5.2 美丽的乌托邦</h2><p></p><p></p><p></p><blockquote>\"'good code is self-documenting' is a delicious myth\"— John Ousterhout《A Philosophy of Software Design》译：‘好的代码自解释’是一个美丽的谎言</blockquote><p></p><p></p><p>在软件设计中，总有一些软件工程师所坚信的诗和远方，有的是大洋彼岸的美好国度，有的或许是虚无缥缈的理想乌托邦。John Ousterhout教授在A Philosophy of Software Design中提到一个观念，‘好的代码自解释’是一个美丽的谎言。</p><p></p><p>我们可以通过选择更好的变量名，更准确的类与方法，更合理的继承与派生来减少注释，但尽管如此，我们还是有非常多的信息无法直接通过代码来表达。这里的信息，或许不单单只是业务逻辑与技术设计，可能还包括了我们的观感，我们的体验，我们的接纳程度以及第一印象带来的首因效应。</p><p></p><p></p><h1>六、好代码的最佳僚机</h1><p></p><p></p><p></p><blockquote>You might think the purpose of commenting is to 'explain what the code does', but that is just a small part of it.The purpose of commenting is to help the reader know as much as the writer did.— Dustin Boswell《The Art of Readable Code》译：你可能以为注释的目的是“解释代码做了什么”，但这只是其中很小一部分，注释的目的是尽量帮助读者了解得和作者一样多</blockquote><p></p><p></p><p>如同John Ousterhout教授一样，The Art of Readable Code的作者Dustin Boswell，也是一个坚定的注释支持者。与Robert C.Martin类似，Dustin Boswell同样认为我们不应该为那些从代码本身就能快速推断的事实写注释，并且他也反对拐杖式注释，注释不能美化代码。</p><p></p><p>但Dustin Boswell认为注释的目的不仅解释了代码在做什么，甚至这只是一小部分，注释最重要的目的是帮助读者了解得和作者一样多。编写注释时，我们需要站在读者的角度，去想想他们知道什么，这是注释的核心。这里有非常多的空间是代码很难阐述或无法阐述的，配上注释的代码并非就是糟糕的代码，相反有些时候，注释还是好代码最棒的僚机。</p><p></p><p></p><h2>6.1 更精准的表述</h2><p></p><p></p><p></p><blockquote>There are only two hard things in Computer Science: cache invalidation and naming things.— Phil Karlton译：计算机科学中只有两个难题：缓存失效和命名</blockquote><p></p><p></p><p>Martin Fowler在他的 TwoHardThings 文章中引用了Phil Karlton的一段话，命名一直都是一件非常难的事情，因为我们需要将所有含义浓缩到几个单词中表达。很早之前学Java，接触到很长的类名是ClassPathXmlApplicationContext。可能有人认为只要能将含义准确地表达出来，名字长一些无所谓。那如果我们需要有一段处理有关“一带一路”的内容，那我们的代码可能是这样的：</p><p></p><p><code lang=\"text\">public class TheSilkRoadEconomicBeltAndThe21stCenturyMaritimeSilkRoad {\n \n}</code></p><p></p><p>他非常准确的表达了含义，但很明显这不是我们期望的代码。但如果我们辅以简单的注释，代码会非常清晰，说明了简称，也说明了全意，表述更精准。</p><p></p><p><code lang=\"text\">/**\n * 一带一路\n * 丝绸之路经济带和21世纪海上丝绸之路\n */\npublic class OneBeltOneRoad {\n \n}</code></p><p></p><p></p><h2>6.2 代码层次切割</h2><p></p><p></p><p>函数抽取是我们经常使用且成本最低的重构方法之一，但并非银弹。函数并非抽得越细越好，如同分布式系统中，并非无限的堆机器让每台机器处理的数据越少，整体就会越快。过深的嵌套封装，会加大我们的代码阅读成本，有时我们只需要有一定的层次与结构帮助我们理解就够了，盲目的抽取封装是无意义的。</p><p></p><p><code lang=\"text\">/**\n * 客户列表查询\n */\npublic List queryCustomerList(){\n    // 查询参数准备\n    UserInfo userInfo = context.getLoginContext().getUserInfo();\n    if(userInfo == null || StringUtils.isBlank(userInfo.getUserId())){\n        return Collections.emptyList();\n    }\n    LoginDTO loginDTO = userInfoConvertor.convertUserInfo2LoginDTO(userInfo);\n    // 查询客户信息\n    List customerSearchList = customerRemoteQueryService.query(loginDTO);\n    Iterable it = customerSearchList.iterator();\n    // 排除不合规客户\n    while(it.hasNext()){\n        CustomerSearchVO customerSearchVO = it.next(); \n        if(isInBlackList(customerSearchVO) || isLowQuality(customerSearchVO)){\n            it.remove();\n        }\n    }\n    // 补充客户其他属性信息\n    batchFillCustomerPositionInfo(customerSearchList);\n    batchFillCustomerAddressInfo(customerSearchList);\n}</code></p><p></p><p>其实细看每一处代码，都很容易让人理解。但如果是一版没有注释的代码，可能我们会有点头疼。缺少结构缺少分层，是让我们大脑第一感观觉得它很复杂，需要一次性消化多个内容。通过注释将代码层次进行切割，是一次抽象层次的划分。同时也不建议大家不断去抽象私有方法，这样代码会变得非常割裂，并且上下文的背景逻辑、参数的传递等等，都会带来额外的麻烦。</p><p></p><p></p><h2>6.3 母语的力量</h2><p></p><p></p><p>其实上述例子，我们更易阅读，还有一个重要的原因，那就是母语的力量。我们天然所经历的环境与我们每天所接触到的事物，让我们对中文与英文有完全不一样的感受。我们代码的编写本质上是一个将我们沟通中的“中文问题”，翻译成“英文代码”来实现的过程。而阅读代码的人在做的，是一件将“英文代码”翻译成“中文表述”的事情。而这之中经过的环节越多，意思变味越严重。</p><p></p><p><code lang=\"text\">TaskDispatch taskDispatch = TaskDispatchBuilder.newBuilder().withExceptionIgnore().build();\ntaskDispatch\n        // 外贸信息\n        .join(new FillForeignTradeInfoTask(targetCustomer, sourceInfo))\n        // 国民经济行业、电商平台、注册资本\n        .join(new FillCustOutterInfoTask(targetCustomer, sourceInfo))\n        // 客户信息\n        .join(new FillCustomerOriginAndCategoryTask(targetCustomer, sourceInfo))\n        // 客户扩展信息\n        .join(new FillCustExtInfoTask(targetCustomer, sourceInfo))\n        // 收藏屏蔽信息\n        .join(new FillCollectStatusInfoTask(targetCustomer, sourceInfo, loginDTO()))\n        // 详情页跳转需要的标签信息\n        .join(new FillTagInstanceTask(targetCustomer, sourceInfo, loginDTO()))\n        // 客户信息完整度分数\n        .join(new FillCustomerScoreTask(targetCustomer, sourceInfo))\n        // 潜客分层完整度\n        .join(new FillCustomerSegmentationTask(targetCustomer, sourceInfo))\n        // 填充操作信息\n        .join(new FillOperationStatusTask(targetCustomer, sourceInfo, loginDTO))\n        // 认证状态\n        .join(new FillAvStatusTask(targetCustomer, loginDTO))\n        // 客户地址和组织\n        .join(new FillCompanyAddressTask(targetCustomer, loginDTO))\n        // 违规信息\n        .join(new FillPunishInfoTask(targetCustomer, sourceInfo))\n        // 填充客户黑名单信息\n        .join(new FillCustomerBlackStatusTask(targetCustomer, sourceInfo))\n        // 填充客户意愿度\n        .join(new FillCustIntentionLevelTask(targetCustomer, sourceInfo));\n        // 执行\n        .execute();</code></p><p></p><p>这是一段补齐客户全数据信息的代码，虽然每一个英文我们都看得懂，但我们永远只会第一眼去看注释，就因为它是中文。并且也因为有这些注释，这里非常复杂的业务逻辑，我们同样可以非常清晰的了解到它做了哪些，分哪几步，如果要优化应该如何处理。这里也建议大家写中文注释，注释是一种说明，越直观越好，中文的亲和力是英文无法比拟的。当然，这条建议并不适合美国程序员。</p><p></p><p></p><h1>七、注释的真正归属</h1><p></p><p></p><p></p><h2>7.1 复杂的业务逻辑</h2><p></p><p></p><p><code lang=\"text\">// Fail if we're already creating this bean instance:\n// We're assumably within a circular reference.\nif (isPrototypeCurrentlyInCreation(beanName)) {\n    throw new BeanCurrentlyInCreationException(beanName);\n}\n// Check if bean definition exists in this factory.\nBeanFactory parentBeanFactory = getParentBeanFactory();\nif (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {\n    // Not found -&gt; check parent.\n    String nameToLookup = originalBeanName(name);\n    if (args != null) {\n        // Delegation to parent with explicit args.\n        return parentBeanFactory.getBean(nameToLookup, args);\n    }\n    else {\n        // No args -&gt; delegate to standard getBean method.\n        return parentBeanFactory.getBean(nameToLookup, requiredType);\n    }\n}</code></p><p></p><p>这是Spring中的一段获取bean的代码，spring作为容器管理，获取bean的逻辑也非常复杂。对于复杂的业务场景，配上必要的注释说明，可以更好的理解相应的业务场景与实现逻辑。</p><p></p><p>截取自：org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</p><p></p><p></p><h2>7.2 晦涩的算法公式</h2><p></p><p></p><p><code lang=\"text\">/**\n * Returns the value obtained by reversing the order of the bits in the\n * two's complement binary representation of the specified {@code long}\n * value.\n */\npublic static long reverse(long i) {\n    // HD, Figure 7-1\n    i = (i &amp; 0x5555555555555555L) &lt;&lt; 1 | (i &gt;&gt;&gt; 1) &amp; 0x5555555555555555L;\n    i = (i &amp; 0x3333333333333333L) &lt;&lt; 2 | (i &gt;&gt;&gt; 2) &amp; 0x3333333333333333L;\n    i = (i &amp; 0x0f0f0f0f0f0f0f0fL) &lt;&lt; 4 | (i &gt;&gt;&gt; 4) &amp; 0x0f0f0f0f0f0f0f0fL;\n    i = (i &amp; 0x00ff00ff00ff00ffL) &lt;&lt; 8 | (i &gt;&gt;&gt; 8) &amp; 0x00ff00ff00ff00ffL;\n    i = (i &lt;&lt; 48) | ((i &amp; 0xffff0000L) &lt;&lt; 16) |\n        ((i &gt;&gt;&gt; 16) &amp; 0xffff0000L) | (i &gt;&gt;&gt; 48);\n    return i;\n}</code></p><p></p><p>这是JDK中Long类中的一个方法，为reverse方法添加了足够多的注释。对于几乎没有改动且使用频繁的底层代码，性能的优先级会高于可读性。在保证高效的同时，注释帮助我们弥补了可读性的短板。</p><p></p><p>截取自：java.lang.Long#reverse</p><p></p><p></p><h2>7.3 不明所以的常量</h2><p></p><p></p><p><code lang=\"text\">/**\n * The bin count threshold for using a tree rather than list for a\n * bin.  Bins are converted to trees when adding an element to a\n * bin with at least this many nodes. The value must be greater\n * than 2 and should be at least 8 to mesh with assumptions in\n * tree removal about conversion back to plain bins upon\n * shrinkage.\n */\nstatic final int TREEIFY_THRESHOLD = 8;</code></p><p></p><p>这是JDK中HashMap的一个常量因子，记录由链表转向红黑树的链表长度阈值，超过该长度则链表转为红黑树。这里记录了一个8，不仅记录了该常量的用途，也记录了为什么我们定义这个值。我们经常会发现代码中存在一个常量等于3、等于4，有时我们不知道这些3和4是干什么的，有时我们不知道为什么是3和4。</p><p></p><p>截取自：java.util.HashMap#TREEIFY_THRESHOLD</p><p></p><p></p><h2>7.4 意料之外的行为</h2><p></p><p></p><p><code lang=\"text\">for (int i = 0; i &lt; 3; i++) {\n    // if task running, invoke only check result ready or not\n    Result result = bigDataQueryService.queryBySQL(sql, token);\n    if (SUCCESS.equals(result.getStatus())) {\n        return result.getValue();\n    }\n    Thread.sleep(5000);\n}</code></p><p></p><p>代码及注释所示为每5秒check一下是否有结果返回，远程服务将触发与获取放在了一个接口。没有注释我们可能认为这段代码有问题，代码表现的含义更像是每5秒调用一次，而非每5秒check一次。为意料之外的行为添加注释，可以减少对代码的误解读，并向读者说明必要的背景及逻辑信息。</p><p></p><p></p><h2>7.5 接口对外API</h2><p></p><p></p><p><code lang=\"text\">/**\n * </code></p><p><code lang=\"text\">Checks if a CharSequence is empty (\"\"), null or whitespace only.</code></p><code lang=\"text\">\n * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n * StringUtils.isBlank(null)      = true\n * StringUtils.isBlank(\"\")        = true\n * StringUtils.isBlank(\" \")       = true\n * StringUtils.isBlank(\"bob\")     = false\n * StringUtils.isBlank(\"  bob  \") = false\n *\n * @param cs  the CharSequence to check, may be null\n * @return {@code true} if the CharSequence is null, empty or whitespace only\n */\npublic static boolean isBlank(final CharSequence cs) {\n    final int strLen = length(cs);\n    if (strLen == 0) {\n        return true;\n    }\n    for (int i = 0; i &lt; strLen; i++) {\n        if (!Character.isWhitespace(cs.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}</code><p></p><p></p><p>我们经常使用的StringUtils工具类中的isBlank方法，写了非常详细的注释，不仅包括方法的逻辑、入参的含义，甚至还包括具体示例。我们平常定义的二方库中的HSF、HTTP接口定义，同样需要有清晰详尽的注释，这里的注释甚至经常会多过你的代码。</p><p></p><p>截取自：org.apache.commons.lang3.StringUtils#isBlank</p><p></p><p></p><h2>7.6 法律文件信息</h2><p></p><p></p><p><code lang=\"text\">/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */</code></p><p></p><p>与法律相关的注释，在开源软件库中较经常遇到。涉及到一些版权及著作声明时，我们需要在源文件顶部放置法律相关注释。当然，我们不需要将所有法律信息写到注释中，如例子中的跳链，引用一份标准的外部文档，会是一个更好的选择。</p><p></p><p></p><h1>八、写在最后</h1><p></p><p></p><p>注释并不会妨碍你写出优雅简洁的代码，它只是程序固有的一部分而已。我们不用过分在意我们的代码是否可以脱离注释，也不需要强调因为我们的代码符合什么原则，满足什么约定，所以代码是优秀的注释是冗余的。代码是一门艺术，并不会因为满足三规九条它就一定完美，因为艺术是不可衡量的。</p><p></p><p></p><h2>参阅书籍</h2><p></p><p></p><p>[01] 《A Philosophy of Software Design》</p><p>[02] 《Clean Code》</p><p>[03] 《The Art of Readable Code》</p>",
    "publish_time": "2023-05-09 10:45:46",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "数据如何驱动业务，看网易游戏、微信和白贝壳集团专家分享 | QCon",
    "url": "https://www.infoq.cn/article/C4izVuAcTsM2iLmZYjE5",
    "summary": "<p>数据是企业的战略资产，不管是数据 Infra 还是数据应用，在做技术选型的时候，都需要重点关注这些技术如何让数据产生更大价值。本专题关注数据价值的挖掘、数据架构体系优化与治理。打通数据流转通道，更好地服务业务方，做到极致的用户体验。</p><p>&nbsp;</p><p>在5月25-26日，<a href=\"https://qcon.infoq.cn/2023/guangzhou/schedule\">QCon全球软件开发大会（广州站）</a>\"即将落地，我们策划了【数据驱动业务】专题，邀请了网易技术研究员、网易严选数据中心负责人陈炬担任专题出品人，为我们对议题分享质量进行把控。与此同时，我们也邀请了三位专家来分享他们的技术实践，下面是详细介绍：</p><p>&nbsp;</p><p><a href=\"https://qcon.infoq.cn/2023/guangzhou/presentation/5262\">黄育钊</a>\"，网易游戏用户体验中心数据挖掘团队负责人，将分享他们如何通过数据驱动的方式不断改进游戏体验，从而提高用户满意度和体验，实现商业成功。他将详细介绍如何将数据驱动思维融入游戏开发的全过程，并通过实际案例展示他们的落地成果；</p><p>&nbsp;</p><p><a href=\"https://qcon.infoq.cn/2023/guangzhou/presentation/5208\">林伟壕</a>\"，微信高级安全工程师，将着眼于大型互联网企业数据分类分级实践，由浅入深的介绍数据分类分级的必要性、流程、思路以及落地方案。他将分享如何进行有效的数据治理，并介绍他们在设计和开发高通用、高扩展、高性能、高准确率的系统时所采取的方法。通过林伟壕的演讲，您将了解大型互联网公司在数据分类分级的实践经验，并了解数据分类分级成果应用落地，最大化扫描价值；</p><p>&nbsp;</p><p><a href=\"https://qcon.infoq.cn/2023/guangzhou/presentation/5271\">顾赟</a>\"，白贝壳集团数字化中心高级商业智能总监，将分享 Babycare 是如何基于用户洞察的产品创新和营销创新来获得爆发式增长的。他将介绍他们如何推动了公司级 VOC（用户之声）的收集和整改机制的数字化落地，并基于语义分析模型生成产品力和服务力指标。参加顾赟的演讲后，您将了解如何从用户思维出发设计数据产品，确保产品的落地应用；</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/12/1255c1008c698923b2351dbe40535452.png\" /></p><p></p><p>这些专家将带领我们深入了解如何通过数据驱动业务来实现更好的用户体验和商业成功。</p><p>&nbsp;</p><p>活动推荐：</p><p>&nbsp;</p><p>在5月25-26日，QCon全球软件开发大会（广州）站即将落地，在此峰会上，共有十二个专题，近五十余场分享。其中包括稳定性即生命线、编程语言实战、DevOps vs 平台工程、AGI 与 AIGC 落地、下一代软件架构、数据驱动业务、出海的思考、云成本优化、现代数据架构、AIGC浪潮下的效能智能化、新型数据库、大前端技术探索。欢迎与你一起交流，更多详细信息可扫描下方海报二维码了解。</p><p><img src=\"https://static001.infoq.cn/resource/image/cf/29/cfcd3fcbdac33fa9d712124034c31a29.jpg\" /></p><p></p>",
    "publish_time": "2023-05-09 11:28:20",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "微软发布Visual Studio Extensibility SDK Preview 3",
    "url": "https://www.infoq.cn/article/9sLcjI1YY9TAvmKjtUmo",
    "summary": "<p>微软发布了<a href=\"https://learn.microsoft.com/en-us/visualstudio/extensibility/?view=vs-2022&amp;accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODM2MDMyMDIsImZpbGVHVUlEIjoiTzRyQXlxVGtMcWNYUHh3eiIsImlhdCI6MTY4MzYwMjkwMiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NTA5NTIwOX0.KVTkhWZ71TuNbXaUSnJ3g8BJEXg_sTxOthGVAGo3KwA\">VisualStudio.Extensibility SDK</a>\" Preview 3，为开发Visual Studio扩展的开发者带来了与提升生产力、定制和调试能力相关的新特性。VisualStudio.Extensibility是一个新的用于开发Visual Studio扩展的框架。</p><p></p><p>在Preview 3中，开发者可以利用调试器可视化器（Debugger Visualizers）来简化调试体验，用自定义对话框（Custom Dialogs）来创建定制的用户界面，用查询项目系统（Query the Project System）来访问项目系统并与之发生交互，用编辑器边缘扩展（Editor Margin Extensions）来向代码编辑器添加自定义组件，用扩展配置（Extension Configuration）选项让用户对其扩展拥有更灵活的控制。这些新特性为开发者提供了更有效和直观的方法来开发Visual Studio扩展，提升了整体的开发者体验和生产力。官方的GitHub代码库中提供了创建自定义对话框的<a href=\"https://github.com/microsoft/VSExtensibility/tree/main/New_Extensibility_Model/Samples/DialogSample?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODM2MDMyMDIsImZpbGVHVUlEIjoiTzRyQXlxVGtMcWNYUHh3eiIsImlhdCI6MTY4MzYwMjkwMiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NTA5NTIwOX0.KVTkhWZ71TuNbXaUSnJ3g8BJEXg_sTxOthGVAGo3KwA\">示例</a>\"。</p><p></p><p>VisualStudio.Extensibility Preview 3提供了使用<a href=\"https://github.com/microsoft/VSExtensibility/blob/main/docs/new-extensibility-model/inside-the-sdk/remote-ui.md?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODM2MDMyMDIsImZpbGVHVUlEIjoiTzRyQXlxVGtMcWNYUHh3eiIsImlhdCI6MTY4MzYwMjkwMiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NTA5NTIwOX0.KVTkhWZ71TuNbXaUSnJ3g8BJEXg_sTxOthGVAGo3KwA\">远程UI</a>\"特性创建自定义调试器可视化器的能力，开发者可以用它创建复杂数据类型的自定义视图。此外，Preview 3引入了更多可定制的对话功能，开发者可以实现更惊艳的用户交互。</p><p></p><p>这些特性是用VisualStudio.Extensibility实现的，为开发者提供了更大的灵活性，让他们能够创建符合其意图和改善用户体验的自定义对话框。<a href=\"https://learn.microsoft.com/dotnet/desktop/wpf/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODM2MDMyMDIsImZpbGVHVUlEIjoiTzRyQXlxVGtMcWNYUHh3eiIsImlhdCI6MTY4MzYwMjkwMiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NTA5NTIwOX0.KVTkhWZ71TuNbXaUSnJ3g8BJEXg_sTxOthGVAGo3KwA\">WPF的使用</a>\"为创建交互式和视觉丰富的对话可视化提供了基础，远程UI特性则保证了对话可视化的可靠性和性能。</p><p></p><p>除了调试器可视化器和自定义对话框之外，VisualStudio.Extensibility Preview 3还提供了检索项目和解决方案的能力。开发者可以用它获得与特定条件相匹配的项目和解决方案的信息，为用户提供与当前代码相关的体验。该功能的<a href=\"http://github.com/microsoft/VSExtensibility/tree/main/New_Extensibility_Model/Samples/VSProjectQueryAPISample?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODM2MDMyMDIsImZpbGVHVUlEIjoiTzRyQXlxVGtMcWNYUHh3eiIsImlhdCI6MTY4MzYwMjkwMiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NTA5NTIwOX0.KVTkhWZ71TuNbXaUSnJ3g8BJEXg_sTxOthGVAGo3KwA\">示例</a>\"可在官方GitHub项目代码库中获得。</p><p></p><p>为了进一步增强开发者体验，VisualStudio.Extensibility Preview 3还提供了编辑器边缘扩展。该功能允许开发者在编辑器边缘创建“端和中心”体验，利用远程UI来提高工作效率。开发者可以使用编辑器边缘扩展来实现简单的功能，如字数统计或文档编码，或创建自定义导航条和标题来改进工作流程。开发者可以利用这个特性来增加工作内容的可见性，并为用户提供更强大的功能，从而改善整体的开发者体验。</p><p></p><p>最后，VisualStudio.Extensibility Preview 3的扩展配置比以往任何时候都更加容易！扩展中定义的许多组件都需要进行配置，指定它们如何或何时出现在IDE中。在这个版本中，微软听取了社区和用户的反馈，并彻底修改了扩展配置，提升了可用性和可发现性。现在，开发者可以使用强类型的类和属性来配置扩展，并在IntelliSense的帮助下轻松发现预定义的选项。开发者可以通过配置属性将命令放在他们完全可控的新创建的菜单和工具栏中。</p><p></p><p>微软官网提供了大量代码示例，并解释了所有的新特性和实现。其中的一个示例是使用简单的ModifierKey来设置某个命令的快捷键：</p><p><code lang=\"java\">public override CommandConfiguration CommandConfiguration =&gt; new(\"%MyCommand.DisplayName%\")\n{\n    Shortcuts = new CommandShortcutConfiguration[]\n    {\n        new(ModifierKey.ControlShift, Key.G),\n    },\n};</code></p><p></p><p>除了官网的<a href=\"https://devblogs.microsoft.com/visualstudio/visualstudio-extensibility-preview-3/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODM2MDMyMDIsImZpbGVHVUlEIjoiTzRyQXlxVGtMcWNYUHh3eiIsImlhdCI6MTY4MzYwMjkwMiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NTA5NTIwOX0.KVTkhWZ71TuNbXaUSnJ3g8BJEXg_sTxOthGVAGo3KwA\">博文</a>\"，作为开发过程的一部分，VisualStudio.Extensibility开发团队还呼吁开发者对新版本进行测试，并通过问题跟踪器<a href=\"https://github.com/microsoft/VSExtensibility/issues?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODM2MDMyMDIsImZpbGVHVUlEIjoiTzRyQXlxVGtMcWNYUHh3eiIsImlhdCI6MTY4MzYwMjkwMiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NTA5NTIwOX0.KVTkhWZ71TuNbXaUSnJ3g8BJEXg_sTxOthGVAGo3KwA\">提供反馈</a>\"。用户也被邀请<a href=\"https://www.surveymonkey.com/r/VisualStudioExtensibilityUserStudies?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODM2MDMyMDIsImZpbGVHVUlEIjoiTzRyQXlxVGtMcWNYUHh3eiIsImlhdCI6MTY4MzYwMjkwMiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NTA5NTIwOX0.KVTkhWZ71TuNbXaUSnJ3g8BJEXg_sTxOthGVAGo3KwA\">参加未来的用户研究</a>\"，一起助力塑造这个软件开发工具包的未来。开发者可以访问官方的<a href=\"https://github.com/microsoft/VSExtensibility/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODM2MDMyMDIsImZpbGVHVUlEIjoiTzRyQXlxVGtMcWNYUHh3eiIsImlhdCI6MTY4MzYwMjkwMiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NTA5NTIwOX0.KVTkhWZ71TuNbXaUSnJ3g8BJEXg_sTxOthGVAGo3KwA\">GitHub项目库</a>\"了解更多关于这个项目的信息。</p><p></p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/04/vs-extensibility-sdk-preview-3/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODM2MDMyMDIsImZpbGVHVUlEIjoiTzRyQXlxVGtMcWNYUHh3eiIsImlhdCI6MTY4MzYwMjkwMiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NTA5NTIwOX0.KVTkhWZ71TuNbXaUSnJ3g8BJEXg_sTxOthGVAGo3KwA\">https://www.infoq.com/news/2023/04/vs-extensibility-sdk-preview-3/</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/sj95UdY5Vqp9Hcxd5XlZ\">构建重启后依然可用的 Windows 服务</a>\"</p>",
    "publish_time": "2023-05-09 11:36:04",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]