[
  {
    "title": "优化容器工作负载：Kubernetes装箱的效益和挑战",
    "url": "https://www.infoq.cn/article/xW8oBGXBqDkhDMgOALDC",
    "summary": "<p>Kubernetes已经成为容器编排事实上的标准，因此企业不断寻求优化其集群资源利用的方法。其中一种技术是装箱（bin packing）：在集群中有效地分配资源，以最小化运行工作负载所需的节点数量。装箱使得企业能够通过减少支持应用程序所需的节点数量来降低成本。</p><p>&nbsp;</p><p>在Kubernetes中，装箱的概念涉及在节点内部战略性地放置容器或“箱子（bin）”，以最大化资源利用率和减少资源浪费。如果实施得当，可以实现对硬件资源更有效的利用，并降低基础设施成本。在云环境中，这尤为重要，因为基础设施支出占据IT开支的相当大部分。</p><p>&nbsp;</p><p>在本文中，我们将探讨在Kubernetes中进行装箱的复杂性，讨论与这种方法相关的挑战和权衡，并提供在企业中实现装箱的示例和最佳实践。</p><p>&nbsp;</p><p></p><h2>Kubernetes装箱挑战</h2><p></p><p>&nbsp;</p><p>尽管Kubernetes中的装箱在资源利用和成本节约方面提供了显著的好处，但也带来了一些需要解决的问题。</p><p>&nbsp;</p><p></p><h3>密度与工作负载隔离和分发</h3><p></p><p>&nbsp;</p><p>实现装箱的一个主要问题是在最大化资源密度和保持工作负载隔离性之间找到平衡，同时要确保工作负载分布在系统和可用区（AZ）中，以御硬件故障。将容器高密度地打包到节点上可以提高资源利用率，但也可能增加对共享资源（如CPU和内存）争用的风险。</p><p>&nbsp;</p><p>这可能导致性能下降，并可能影响整个集群的稳定性。此外，过度的装箱可能与分配的概念相矛盾，降低系统抵御硬件故障的能力。因此，我们有必要明智地并只在用例有意义的情况下应用装箱策略。</p><p>&nbsp;</p><p>为了更深入地理解这种权衡的含义，有必要考虑密度的增加对集群容错性所造成的影响。当容器被高密度地打包到较少的节点上时，单个节点的故障可能对应用程序的整体健康和可用性产生更大的影响。这带来了一个问题：在节省成本的同时，如何确保你的工作负载对潜在故障的弹性？</p><p>&nbsp;</p><p></p><h3>在节点上过度集中应用程序的风险</h3><p></p><p>&nbsp;</p><p>在节点中过度装箱应用程序的风险与保持分布式部署的“最佳实践”是两个对立面。把所有的鸡蛋放在一个篮子里，这是典型的风险管理错误。这是一种操作风险，如果某些节点宕机，整个部署的更大部分也将随之离线。因此，一方面，出于弹性的考虑，你希望尽可能偏向分布式。另一方面，你希望控制成本，而装箱是一个很好地解决方案。在这种平衡中找到最佳的点才是关键。</p><p>&nbsp;</p><p>当多个容器争用单个节点有限的资源（如内存或CPU）时，这些问题变得更加明显，从而导致资源匮乏和应用程序性能下降。此外，以非逐渐方式或突发方式扩展系统还可能导致不必要的故障，进一步加剧这些挑战。为了应对这些不一致性，可以尝试设置策略限制，确保向应用程序提供可靠的资源。</p><p>&nbsp;</p><p>在高密度装箱到节点时需要考虑的另一个问题是对维护和更新的潜在影响。随着在单个节点上运行更多的容器，对维护任务或软件更新的影响可能会被放大，导致更长时间的停机或降低应用程序性能。在进行装箱时，如何管理更新和维护而不对工作负载性能产生负面影响，是需要认真考虑的问题。</p><p>&nbsp;</p><p></p><h3>解决挑战的调度策略</h3><p></p><p>&nbsp;</p><p>Kubernetes提供了几种调度策略来帮助解决与装箱相关的问题：</p><p>&nbsp;</p><p><a href=\"https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\">资源请求和限制</a>\" 允许你配置Kubernetes调度程序在进行调度决策时考虑每个节点上的可用资源，这使你能够将容器放置在具有适当资源量的节点上。<a href=\"https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity\">Pod亲和性和反亲和性规则</a>\" 允许你根据其他Pod的存在来指定Pod应该或不应该放置在哪些节点上，这有助于确保工作负载在整个集群中均匀分布，或者根据特定要求在某些节点上进行分组。例如，处理基本客户数据的数据关键系统需要尽可能偏向分布式，以增强可靠性和性能。这种方法可以降低单点故障风险，带来更好的整体系统弹性。<a href=\"https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/\">Pod拓扑传播约束</a>\" 使你能够考虑区域等因素，控制Pod在节点之间的分布方式。通过使用这些约束，你可以确保工作负载均匀分布，最大限度地减少单个节点过载的风险，并提高整体集群弹性。</p><p>&nbsp;</p><p>通过仔细考虑和实施这些调度策略，你可以有效地解决在Kubernetes中进行装箱所面临的挑战，同时保持最佳的资源利用率和性能。</p><p>&nbsp;</p><p></p><h2>Kubernetes装箱示例</h2><p></p><p>&nbsp;</p><p>关于在Kubernetes中如何有效地为不同类型的工作负载（从无状态的Web应用程序到数据库实例等）实施装箱，我们将在下面探讨其中一些示例。</p><p>&nbsp;</p><p></p><h3>无状态应用程序</h3><p></p><p>&nbsp;</p><p>Kubernetes可以将多个无状态应用程序实例打包到单个节点中，同时确保每个实例都具有足够的资源。通过使用资源请求和限制，你可以引导Kubernetes调度程序为每个实例分配适当数量的CPU和内存。只要这些实例有足够的资源，它们就会启动并运行，并确保无状态应用程序（如Web应用程序或面向客户的应用程序）具有高可用性。</p><p>&nbsp;</p><p></p><h3>数据库实例</h3><p></p><p>&nbsp;</p><p>在处理数据库时，Kubernetes可以有效地将不同有状态应用程序的单个实例打包到节点中，以最大化吞吐量和最小化延迟。通过利用Pod亲和性规则，你可以确保数据库实例放置在拥有必要的卷并与其他组件（如缓存服务器或应用程序服务器）接近的节点上。这有助于优化资源使用，同时保持数据库操作的高性能和低延迟。</p><p>&nbsp;</p><p></p><h3>批处理和机器学习工作负载</h3><p></p><p>&nbsp;</p><p>装箱也能给批处理和机器学习工作负载带来好处。Kubernetes可以使用Pod拓扑传播约束确保这些工作负载均匀分布在节点上，防止资源争用，保持性能处于最佳状态。</p><p>&nbsp;</p><p></p><h3>大型多节点集群</h3><p></p><p>&nbsp;</p><p>如果需要将服务分布到大量节点（例如2000个节点）中，资源优化仍然是一个重要的考虑因素。虽然将这些服务分散开对于容错能力来说是必不可少的，但仍然需要考虑对剩余的服务进行装箱，以提高节点的利用率。</p><p>&nbsp;</p><p>如果使用了特定的节点资源，Kubernetes可以通过拓扑传播配置（例如<a href=\"https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/\">PodTopologySpreadArgs</a>\"）来管理它们。集群管理员和云供应商应该要确保节点得到相应的配置，以平衡分散的服务和装箱的服务。</p><p>&nbsp;</p><p>通过理解和应用这些示例，你可以利用装箱来优化资源利用率，提高集群的整体效率。</p><p>&nbsp;</p><p></p><h2>Kubernetes装箱的成本效益</h2><p></p><p>&nbsp;</p><p>通过在集群内有效地分配资源并最小化支持工作负载所需的节点数量，装箱有助于降低基础设施成本。这是通过将多个容器合并到较少的节点上实现的，减少了对额外硬件或云资源的需求。因此，企业可以在硬件、能源和维护方面节省开支。</p><p>&nbsp;</p><p>在云环境中，基础设施成本占IT开支的很大一部分，因此通过装箱实现的成本节省可能非常显著。云提供商通常根据使用的节点数量和大小向客户收费，通过装箱优化资源利用率直接可以转化为减少云基础设施费用。</p><p>&nbsp;</p><p></p><h2>Kubernetes装箱最佳实践</h2><p></p><p>&nbsp;</p><p>要充分利用Kubernetes装箱所带来的好处，需要遵循一些最佳实践，确保在防止出现性能问题的同时实现最佳资源利用。以下是三个重要的最佳实践。</p><p>&nbsp;</p><p></p><h3>谨慎的规划和测试</h3><p></p><p>&nbsp;</p><p>在Kubernetes环境中实施装箱之前，需要仔细规划和测试容器在节点中的放置。这可能涉及分析工作负载的资源需求，确定适当的密度水平，并在不同场景下测试集群的性能和稳定性。此外，设置内存的硬限制至关重要，因为内存是不可压缩的资源，应谨慎分配，以避免影响其他的应用程序。还要考虑潜在的内存泄漏问题，确保一个节点的内存泄漏不会在整个系统中造成混乱。</p><p>&nbsp;</p><p>花一些时间进行规划和测试有助于避免与装箱相关的潜在问题，如资源争用和性能下降。</p><p>&nbsp;</p><p></p><h3>正确设置节点和容器大小</h3><p></p><p>&nbsp;</p><p>正确设置节点和容器大小是优化Kubernetes环境中资源利用的关键。为实现这一目标，首先需要评估应用程序的资源需求，如CPU、内存和存储。这些信息有助于确定最适合的节点大小和容器资源限制，以最大限度地减少浪费和提高效率。为工作负载设置适当的节点和容器大小至关重要，因为如果你的容器太大并占用了节点相当比例的资源，那么你将无法将其他容器放置到节点上。例如，如果你运行一个非常大的容器，占用了每个节点75%的资源，那么将导致25%的浪费，无论你设置了多少装箱规则。在优化Kubernetes环境时，容器分配的资源和机器提供的资源是需要考虑的关键因素。</p><p>&nbsp;</p><p></p><h3>随时监控和调整</h3><p></p><p>&nbsp;</p><p>在Kubernetes集群中保持最佳资源利用需要进行持续的监控和调整。随着工作负载和需求的演变，可能需要重新评估装箱策略，以确保其有效性。</p><p>&nbsp;</p><p>进行定期监控可以帮助你及早识别问题，如资源争用或未被充分利用的节点，让你能够在问题升级之前做出调整。</p><p>&nbsp;</p><p></p><h3>利用Kubernetes特性进行装箱</h3><p></p><p>&nbsp;</p><p>资源配额 允许你限制命名空间可以消耗的资源量，确保不存在单个工作负载垄断集群的可用资源。资源请求和限制 可以让你引导Kubernetes调度程序将容器放置在具有适当资源量的节点上，这有助于确保工作负载被高效分配，并最小化资源争用。</p><p>&nbsp;</p><p>另外需要考虑的一点是基础设施对环境的影响。通过装箱来优化资源利用，你可以潜在地减少企业的碳排放。运行较少的节点意味着消耗更少的能源并产生更少的热量，这有助于降低温室气体排放和降低对环境的影响。这带来了一个重要的问题：企业如何在追求成本效益和性能的同时，平衡其社会责任，以减少碳排放？</p><p>&nbsp;</p><p></p><h2>结论</h2><p></p><p>&nbsp;</p><p>在Kubernetes中进行装箱在优化资源利用和降低基础设施成本方面发挥着至关重要的作用，但同样重要的是如何在优化Kubernetes资源时正确找到效率和性能之间的平衡。</p><p>&nbsp;</p><p>通过在集群中战略性地分配资源，企业可以将运行工作负载所需的节点数量降到最低，实现更低的支出和更高效的基础设施管理。</p><p>&nbsp;</p><p>然而，正如讨论过的那样，企业需要面对与装箱相关的一些性能挑战和权衡以及在Kubernetes环境中有效使用装箱的最佳实践。通过理解和利用这些技术，企业可以最大限度地利用集群中的资源，节省基础设施成本，并提高总体效率。</p><p>&nbsp;</p><p>&nbsp;</p><p>原文链接：</p><p>https://www.infoq.com/articles/kubernetes-bin-packing/</p><p></p><p></p><h5>相关阅读：</h5><p></p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ%3D%3D&amp;chksm=e8d7e428dfa06d3ed76212b029784a7db555f1c09321a535ded950b30a7258bf3d84e30de519&amp;idx=1&amp;mid=2247490538&amp;scene=27&amp;sn=d9aab0a30357e4b1689e578144cf3957&amp;utm_campaign=geek_search&amp;utm_content=geek_search&amp;utm_medium=geek_search&amp;utm_source=geek_search&amp;utm_term=geek_search#wechat_redirect\">50+ 顶级开源&nbsp;Kubernetes&nbsp;工具列表</a>\"</p><p><a href=\"https://www.infoq.cn/article/kubernetes-effect?utm_campaign=geek_search&amp;utm_content=geek_search&amp;utm_medium=geek_search&amp;utm_source=geek_search&amp;utm_term=geek_search\">Kubernetes&nbsp;效应</a>\"</p><p><a href=\"https://www.infoq.cn/article/8XZ4ZV59Yx9NHyqbaIlI?utm_campaign=geek_search&amp;utm_content=geek_search&amp;utm_medium=geek_search&amp;utm_source=geek_search&amp;utm_term=geek_search\">你该如何为&nbsp;Kubernetes&nbsp;定制特性</a>\"</p><p><a href=\"https://www.infoq.cn/article/u6D2XoVVVz1fpxxzBKzT?utm_campaign=geek_search&amp;utm_content=geek_search&amp;utm_medium=geek_search&amp;utm_source=geek_search&amp;utm_term=geek_search\">用了就会更好吗？小心&nbsp;Kubernetes&nbsp;陷阱</a>\"</p>",
    "publish_time": "2023-12-21 00:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Java新闻汇总：JDK 22、Spring CVE、Liberica JDK、JDKMon 21、Jupyter for Java和Gradle 8.5",
    "url": "https://www.infoq.cn/article/kHGCPfPcKtU7XBaxATRU",
    "summary": "<p></p><h4>OpenJDK</h4><p></p><p></p><p>在审查结束后，JEP 463，<a href=\"https://openjdk.org/jeps/463\">隐式声明类和实例主方法（Implicitly Declared Classes and Instance Main Methods，第二轮预览）</a>\"，已经在JDK 22中从Targeted状态<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-November/008469.html\">提升</a>\"到了Proposed to Target状态。它以前被称为未命名类和实例主方法（Unnamed Classes and Instance Main Methods，预览）、灵活主方法和匿名主类（Flexible Main Methods and Anonymous Main Classes，预览）和隐式类和增强的主方法（Implicit Classes and Enhanced Main Methods，预览），该JEP包含了对前一轮<a href=\"https://openjdk.java.net/jeps/12\">预览</a>\"反馈的增强，即JEP 445，<a href=\"https://openjdk.org/jeps/445\">未命名类和实例主方法（预览）</a>\"。这个JEP建议“演进Java语言，这样学生们就可以编写他们的第一个程序，而不需要理解为大型程序所设计的语言特性”。该JEP延续了甲骨文的Java语言架构师<a href=\"https://www.linkedin.com/in/briangoetz/\">Brian Goetz</a>\"在2022年9月发表的博客文章<a href=\"https://openjdk.org/projects/amber/design-notes/on-ramp\">Paving the on-ramp</a>\"。甲骨文的技术顾问<a href=\"https://www.linkedin.com/in/gavin-bierman-a0173075/\">Gavin Bierman</a>\"已经<a href=\"https://mail.openjdk.org/pipermail/amber-dev/2023-May/008065.html\">发布了</a>\"规范文档的<a href=\"https://cr.openjdk.org/~gbierman/jep445/jep445-20230502/specs/unnamed-classes-instance-main-methods-jls.html\">初稿</a>\"，供Java社区审查。关于JEP 445的更多细节可以在InfoQ的<a href=\"https://www.infoq.com/news/2023/05/beginner-friendly-java/\">新闻报道</a>\"中找到。</p><p>&nbsp;</p><p>在审查结束后，JEP 462，<a href=\"https://openjdk.org/jeps/462\">结构化并发（Structured Concurrency，第二次预览）</a>\"，已经从Proposed to Target状态<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-December/008493.html\">提升</a>\"到了Targeted状态。这个JEP提议在JDK 22中重新审查API，不做任何变更，以便于从上一轮预览中获取更多的反馈，即JDK 21交付的JEP 453，<a href=\"https://openjdk.org/jeps/453\">结构化并发（预览）</a>\"。这个特性通过引入结构化并发性来简化并发编程，“将在不同线程中运行的相关任务组视为单个工作单元，从而简化错误处理和取消，提高可靠性并增强可观测性。”</p><p>&nbsp;</p><p>在审查结束后，JEP 461,&nbsp;<a href=\"https://openjdk.org/jeps/461\">流收集器（Stream Gatherers，预览）</a>\"，已经在JDK 22中从Proposed to Target状态<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-November/008473.html\">提升</a>\"到了Targeted状态。该JEP建议增强流API以支持自定义的中间操作。“这将允许流管道以现有内置中间操作难以实现的方式转换数据。”关于此JEP的更多细节可以参考甲骨文Java平台组软件架构师<a href=\"https://www.linkedin.com/in/viktorklang/\">Viktor Klang</a>\"编写的原始<a href=\"https://cr.openjdk.org/~vklang/Gatherers.html\">设计文档</a>\"。</p><p>&nbsp;</p><p>在审查结束后，JEP 458，<a href=\"https://openjdk.org/jeps/458\">启动多文件源码程序（Launch Multi-File Source-Code Programs）</a>\"，已经在JDK 22的Proposed to Target状态<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-December/008494.html\">提升</a>\"到了Targeted状态。该JEP建议增强Java Launcher，以执行通过一个或多个Java源代码文件提供的应用程序。这可以通过推迟一个完整项目的搭建来实现从小型应用程序到大型应用程序的渐进过渡。</p><p>&nbsp;</p><p>在审查结束后，JEP 457，<a href=\"https://openjdk.org/jeps/457\">类文件API（Class-File API，预览）</a>\"，已经在JDK 22的Proposed to Target状态<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-November/008471.html\">提升</a>\"到了&nbsp;Targeted状态。该JEP建议提供一个API来解析、生成和转换Java类文件。它最初作为JDK中<a href=\"https://asm.ow2.io/\">ASM</a>\"的替代品，ASM是一个Java字节码操作和分析框架，并计划将其作为公开API对外开放。甲骨文的Java语言架构师<a href=\"https://www.linkedin.com/in/briangoetz\">Brian Goetz</a>\"将ASM描述为“带有大量遗留包袱的旧代码库”，并提供了关于该草案如何发展并最终取代ASM的<a href=\"https://mail.openjdk.org/pipermail/discuss/2022-June/006131.html\">背景信息</a>\"。</p><p>&nbsp;</p><p>在审查结束后，JEP 423，<a href=\"https://openjdk.org/jeps/423\">G1的区域锚定（Region Pinning for G1）</a>\"，已经在JDK 22的Proposed to Target<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-November/008470.html\">提升</a>\"到了&nbsp;Targeted状态。该JEP建议通过实现<a href=\"https://docs.oracle.com/en/java/javase/17/gctuning/garbage-first-g1-garbage-collector1.html#GUID-ED3AB6D3-FD9B-4447-9EDF-983ED2F7A573\">G1垃圾收集器</a>\"的区域锚定来减少GC延迟。这将扩展G1，以便在major和minor收集操作期间可以锚定任意区域，以便于实现<a href=\"https://shipilev.net/jvm/anatomy-quarks/9-jni-critical-gclocker/\">JNI关键区域</a>\"时避免禁用垃圾收集进程。</p><p>&nbsp;</p><p>JEP 464，<a href=\"https://openjdk.org/jeps/464\">作用域值（Scoped Values，第二次预览）</a>\"，已经从它的JEP Draft 8318898状态<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-November/008472.html\">提升</a>\"至Candidate状态，然后快速在JDK 22<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-November/008480.html\">提升</a>\"到了Proposed to Target状态。它以前被称为范围局部变量（Extent-Local Variables，孵化），这个JEP建议在JDK 22中重新预览API，不做任何更改，以便于从上一轮预览中获得额外的经验和反馈，即JDK 21交付的JEP 446,&nbsp;<a href=\"https://openjdk.org/jeps/446\">作用域值（预览）</a>\"和JDK 20交付的<a href=\"https://openjdk.org/jeps/429\">作用域值（孵化）</a>\"。该特性允许在线程内部和线程之间共享不可变数据。这种方式优于thread-local变量，特别是在使用大量虚拟线程的时候。该审查预计会在2023年12月7日结束。</p><p></p><h4>JDK 22</h4><p></p><p></p><p>JDK 22的早期访问构建版本的<a href=\"https://github.com/openjdk/jdk/releases/tag/jdk-22%2B26\">Build 26</a>\"发布，其中包括对Build 25的<a href=\"https://github.com/openjdk/jdk/compare/jdk-22%2B25...jdk-22%2B26\">更新</a>\"，其中包括对各种<a href=\"https://bugs.openjdk.org/issues/?jql=project%20%3D%20JDK%20AND%20fixversion%20%3D%2022%20and%20%22resolved%20in%20build%22%20%3D%20b26%20order%20by%20component%2C%20subcomponent\">问题</a>\"的修复。关于这个版本的更多细节可以在<a href=\"https://jdk.java.net/22/release-notes\">发行说明</a>\"中找到。</p><p>&nbsp;</p><p>对于<a href=\"https://openjdk.org/projects/jdk/22/\">JDK 22</a>\"，鼓励开发人员通过<a href=\"https://bugreport.java.com/bugreport/\">Java缺陷数据库</a>\"报告缺陷。</p><p></p><h4>Jakarta EE</h4><p></p><p></p><p><a href=\"https://jakarta.ee/specifications/data/\">Jakarta Data</a>\"&nbsp;1.0.0的第二个里程碑版本提供了如下特性：制品名称的重命名，例如，从jakarta-data-api改为jakarta.data-api，以便于同所有Jakarta EE规范保持一致；延迟静态元模型的实现，以进一步解决与反射和注解处理器相关的问题；对版权文档的优化，以便将值与占位符绑定。关于此版本的更多细节可以在<a href=\"https://github.com/jakartaee/data/releases/tag/1.0.0-M2\">发布说明</a>\"中找到。</p><p>&nbsp;</p><p><a href=\"https://www.jnosql.org/\">Eclipse JNoSQL</a>\"（<a href=\"https://jakarta.ee/specifications/nosql/\">Jakarta NoSQL</a>\"规范的兼容实现）的1.0.3版本发布，带来重要的数据库升级，比如，MongoDB驱动4.11.1、Hazelcast 5.3.6、Apache Solr 9.4.0、Couchbase Library 3.4.11和ArangoDB Library7.2.0。更新方法还实现了增强功能，以改进整个项目的功能。关于此版本的更多细节可以在<a href=\"https://github.com/eclipse/jnosql/releases/tag/1.0.3\">发布说明</a>\"中找到。</p><p></p><h4>BellSoft</h4><p></p><p></p><p>BellSoft<a href=\"https://bell-sw.com/blog/bellsoft-releases-liberica-jdk-lts-17-and-21-with-coordinated-restore-at-checkpoint-crac-for-fast-startup/\">发布</a>\"了<a href=\"https://bell-sw.com/libericajdk/\">Liberica JDK</a>\"的17和21版本，这是他们OpenJDK的下游发行版，具有检查点协调恢复(Coordinated Restore at Checkpoint，CRaC)功能，使开发人员能够构建运行中的应用程序快照，减少Java应用的启动和预热时间。这些新版本将适用于x86_64和AArch64 CPU架构以及Linux操作系统。</p><p></p><h4>Spring Framework</h4><p></p><p></p><p>VMware<a href=\"https://spring.io/blog/2023/11/27/cve-2023-34053-cve-2023-34055-spring-framework-and-spring-boot\">披露</a>\"了两个安全漏洞：CVE-2023-34053，<a href=\"https://spring.io/security/cve-2023-34053\">Spring框架服务器Web观测DoS漏洞（Spring Framework Server Web Observations DoS Vulnerability）</a>\"以及CVE-2023-34055，<a href=\"https://spring.io/security/cve-2023-34055\">Spring Boot服务器Web观测DoS漏洞（Spring Boot Server Web Observations DoS Vulnerability</a>\"，它们会影响<a href=\"https://spring.io/projects/spring-framework\">Spring Framework</a>\"6.0.0至6.0.13版本和<a href=\"https://spring.io/projects/spring-boot\">Spring Boot</a>\"3.1.0至3.1.5版本、3.0.0至3.0.12版本以及2.7.0至2.7.17版本。这两个漏洞都允许攻击者提供特制的HTTP请求，这些请求可能会在以下情况下导致拒绝服务：</p><p>应用程序使用了<a href=\"https://docs.spring.io/spring-framework/reference/web/webmvc.html\">Spring MVC</a>\"或<a href=\"https://docs.spring.io/spring-framework/reference/web/webflux.html\">Spring WebFlux</a>\"。io.micrometer:micrometer-core制品位于类路径中。在应用程序中配置了Micrometer&nbsp;ObservationRegistry接口的实现来记录观测结果。</p><p></p><p>因此，鼓励开发人员升级到Spring Framework 6.0.14以及Spring Boot 2.7.18、3.0.13和3.1.6。</p><p>&nbsp;</p><p><a href=\"https://spring.io/projects/spring-shell\">Spring Shell</a>\"的3.2.0-rc1、3.1.6、3.0.10和2.1.15版本<a href=\"https://spring.io/blog/2023/11/28/spring-shell-2-1-15-3-0-10-3-1-6-and-3-2-0-rc1-are-now-available\">发布</a>\"，分别进行了缺陷修复和对Spring Boot 3.2.0、3.1.6、3.0.13和2.7.18依赖升级。3.0和2.1版本系列已被宣布与它们对应的Spring Boot版本一起结束生命周期。3.2.0-RC1和3.1.6版本中的新特性包括：支持zsh补全和模态视图；对<a href=\"https://docs.spring.io/spring-shell/reference/tui/index.html\">Terminal UI</a>\"的小改动。关于此版本的更多细节可以在<a href=\"https://github.com/spring-projects/spring-shell/releases/tag/v3.2.0-RC1\">3.2.0-RC1版本</a>\"、<a href=\"https://github.com/spring-projects/spring-shell/releases/tag/v3.1.6\">3.1.6版本</a>\"、<a href=\"https://github.com/spring-projects/spring-shell/releases/tag/v3.0.10\">3.0.10版本</a>\"和<a href=\"https://github.com/spring-projects/spring-shell/releases/tag/v2.1.15\">2.1.15版本</a>\"的发行说明中找到。</p><p></p><h4>Quarkus</h4><p></p><p></p><p>Red Hat<a href=\"https://quarkus.io/blog/quarkus-3-6-0-released/\">发布</a>\"了<a href=\"https://quarkus.io/\">Quarkus</a>\"的3.6.0版本，其中有一些显著的变化，比如，支持OIDC bearer令牌的自定义授权模式；改进了服务器发送事件(SSE)，允许REST客户端返回整个SSE事件并对这些事件进行过滤；支持与Jakarta Annotations&nbsp;@RolesAllowed注解类似的@SecureField注解中的表达式。关于这个版本的更多细节可以在<a href=\"https://github.com/quarkusio/quarkus/releases/tag/3.6.0\">变更日志</a>\"中找到。</p><p>&nbsp;</p><p>Red Hat还<a href=\"https://quarkus.io/blog/java-17/\">宣布</a>\"JDK 17将是即将发布的Quarkus 3.7要求的最低版本，它计划于2024年1月底发布。InfoQ将会跟进更详细的新闻报道。</p><p></p><h4>Open Liberty</h4><p></p><p></p><p>IBM<a href=\"https://openliberty.io/blog/2023/11/28/23.0.0.12-beta.html\">发布</a>\"了<a href=\"https://openliberty.io/\">Open Liberty</a>\"的23.0.0.12-beta版，该版本支持<a href=\"https://jakarta.ee/specifications/data/\">Jakarta Data</a>\"&nbsp;1.0.0-M1，其中包括：用于基本存储库方法的新&nbsp;BasicRepository接口；在CrudRepository接口中添加insert()和update()方法；新的@Insert、@Update、@Delete和@Save注解。这个版本还提供了一个可配置的静默超时阶段，即当Liberty运行时的关闭时间超过默认的30秒时。这能够支持需要更多时间来完成处理请求的服务。</p><p></p><h4>Helidon</h4><p></p><p></p><p><a href=\"https://helidon.io/\">Helidon</a>\"&nbsp;4.0.1，即<a href=\"https://github.com/helidon-io/helidon/releases/tag/4.0.1\">第一个维护版本</a>\"，提供了值得关注的变更，比如，支持Helidon Web服务器组件的<a href=\"https://www.haproxy.com/blog/use-the-proxy-protocol-to-preserve-a-clients-ip-address\">代理协议</a>\"；&nbsp;WebServer接口的性能改进；在&nbsp;CrossOriginConfig.Builder类中定义的enabled()方法现在返回Optional而不是boolean以解决CORS问题。关于此版本的更多细节可以在<a href=\"https://github.com/helidon-io/helidon/blob/4.0.1/CHANGELOG.md\">变更日志</a>\"中找到。</p><p>&nbsp;</p><p>同样，Helidon 3.2.4的<a href=\"https://github.com/helidon-io/helidon/releases/tag/3.2.4\">发布</a>\"提供了依赖项升级和一些值得注意的变化，例如，用于延迟OCI Vault配置的新类的集合；将opentracing相关的类和接口迁移到Helidon Tracing API；正确处理请求URL的IPv6地址的解析。关于这个版本的更多细节可以在<a href=\"https://github.com/helidon-io/helidon/blob/3.2.4/CHANGELOG.md\">变更日志</a>\"中找到。</p><p></p><h4>Hibernate</h4><p></p><p></p><p><a href=\"https://hibernate.org/reactive/\">Hibernate Reactive</a>\"&nbsp;2.2.0.Final版本<a href=\"https://in.relation.to/2023/11/28/hibernate-reactive-2_2_Final/\">发布</a>\"，它兼容Hibernate ORM 6.4.0.Final and Vert.x SQL driver 4.5.0。Red Hat还提供了2.2.1.Final和2.0.7.Final版本，它们分别与<a href=\"https://hibernate.org/orm/\">Hibernate ORM</a>\"的6.3.2.Final and 6.2.13.Final版本兼容。关于此版本的更多细节可以在<a href=\"https://github.com/hibernate/hibernate-reactive/releases/tag/2.2.0\">发布说明</a>\"中找到。</p><p>&nbsp;</p><p>Hibernate Search 7.1.0的<a href=\"https://in.relation.to/2023/11/30/hibernate-search-7-1-0-Alpha1/\">第一个alpha版本</a>\"提供了一个孵化特性，即允许在<a href=\"https://lucene.apache.org/\">Apache Lucene</a>\"后端进行矢量搜索，并提供了搜索二进制或文本数据的工具。此外，在Spring boot 3.2中读取嵌套JAR时，Hibernate Search将不再启动失败。关于此版本的更多细节可以在<a href=\"https://hibernate.atlassian.net/browse/HSEARCH-5024?jql=project%3D10061%20AND%20fixVersion%3D32219\">发布说明</a>\"中找到。</p><p></p><h4>Grails基金会</h4><p></p><p></p><p>Grails 5.3.4发布，提供了依赖升级和一些值得注意的变化，比如，为所有主分支启用GitHub&nbsp;<a href=\"https://codeql.github.com/\">CodeQL</a>\"；添加了一个SnakeYAML物料清单（BOM）来覆盖SpringBoot BOM；对Javadoc的清理，包括在Javadoc中转义特殊字符、重构代码、定义显式类型和删除不必要的变量使用。关于此版本的更多细节可以在<a href=\"https://github.com/grails/grails-core/releases/tag/v5.3.4\">发布说明</a>\"中找到。</p><p></p><h4>Apache软件基金会</h4><p></p><p></p><p><a href=\"https://groovy-lang.org/\">Apache Groovy</a>\"&nbsp;5.0.0的<a href=\"https://www.mail-archive.com/announce@apache.org/msg08717.html\">第三个alpha版本</a>\"提供了缺陷修复、依赖升级和功能改进，例如，支持JDK 22；实现了在groovyc命令行中进行库编译器时缺失的特性；还有一个针对数组类型的新indexOf(element)扩展方法。关于此版本的更多细节可以在<a href=\"https://issues.apache.org/jira/secure/ReleaseNote.jspa?projectId=12318123&amp;version=12353636\">发布说明</a>\"中找到。</p><p>&nbsp;</p><p>同样，Apache Groovy 4.0.16的<a href=\"https://www.mail-archive.com/announce@apache.org/msg08716.html\">发布</a>\"也提供了缺陷修复、依赖升级和功能改进，例如，对JDK 22的支持；在DefaultGroovyStaticMethods类中定义一个新的allThreads()方法，以补充Java Thread类中定义的现有currentThread()方法。关于此版本的更多细节可以在<a href=\"https://issues.apache.org/jira/secure/ReleaseNote.jspa?projectId=12318123&amp;version=12353637\">发布说明</a>\"中找到。</p><p>&nbsp;</p><p>为了与Quarkus保持一致，Camel Quarkus 3.6.0版本<a href=\"https://camel.apache.org/blog/2023/11/camel-quarkus-release-3.6.0/\">发布</a>\"，解决了以下问题：在执行QuartzQuarkusSchedulerAutowiredWithSchedulerBeanTest类的时候，出现间歇性的AssertionFailedError；在使用容器的测试中，清除硬编码对主机的使用。关于此版本的更多细节可以在<a href=\"https://camel.apache.org/releases/q-3.6.0/\">发布说明</a>\"中找到。</p><p>&nbsp;</p><p><a href=\"https://maven.apache.org/\">Apache Maven</a>\"&nbsp;3.9.6版本提供了依赖项升级和排除插件验证的功能。关于此版本的更多细节可以在<a href=\"https://github.com/apache/maven/releases/tag/maven-3.9.6\">发布说明</a>\"中找到。</p><p></p><h4>JDKMon</h4><p></p><p></p><p>监视和更新已安装jdk的工具<a href=\"https://github.com/HanSolo/JDKMon\">JDKMon</a>\"发布了<a href=\"https://github.com/HanSolo/JDKMon/releases/tag/21.0.0\">21.0.0</a>\"版本。这个工具由Azul的首席工程师<a href=\"https://de.linkedin.com/in/gerritgrunwald\">Gerrit Grunwald</a>\"创建，这个新版本通过将所有依赖项移动到最新的LTS版本，完全支持JDK 21。</p><p></p><h4>PrimeFaces</h4><p></p><p></p><p>PrimeFaces的12.0.7、11.0.13、10.0.20和8.0.25版本发布，特性包括：升级<a href=\"https://github.com/stleary/JSON-java/blob/master/README.md\">JSON in Java</a>\"到20231013，以解决<a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-5072\">CVE-2023-5072</a>\"漏洞，该漏洞允许攻击者利用JSON解析器中的缺陷，例如，中等大小的字符串输入可能导致无限量的内存使用并导致拒绝服务。关于这些版本的更多细节可以在<a href=\"https://github.com/primefaces/primefaces/issues?q=is%3Aissue+label%3A12.0.7+is%3Aclosed\">12.0.7版本</a>\"、<a href=\"https://github.com/primefaces/primefaces/issues?q=is%3Aissue+label%3A11.0.13+is%3Aclosed\">11.0.13版本</a>\"、<a href=\"https://github.com/primefaces/primefaces/issues?q=is%3Aissue+is%3Aclosed+label%3A10.0.20\">10.0.20版本</a>\"和<a href=\"https://github.com/primefaces/primefaces/issues?q=is%3Aissue+is%3Aclosed+label%3A8.0.25\">8.0.25版本</a>\"的发布说明中找到。</p><p></p><h4>Jupyter for Java</h4><p></p><p></p><p><a href=\"https://github.com/jupyter-java\">Jupyter for Java</a>\"，这是一个新的GitHub组织，旨在帮助开发人员发现在Jupyter notebooks中使用Java的各种方法。该项目由Red Hat的杰出工程师<a href=\"https://www.linkedin.com/in/maxrydahlandersen/\">Max Rydahl Andersen</a>\"创建，目前包含五个提供资源和样例的仓库。</p><p></p><h4>Gradle</h4><p></p><p></p><p><a href=\"https://gradle.org/\">Gradle</a>\"&nbsp;8.5.0<a href=\"https://github.com/gradle/gradle/releases/tag/v8.5.0\">发布</a>\"，提供了以下新特性：完全支持在JDK 21上编译、测试和运行；<a href=\"https://docs.gradle.org/8.5-rc-1/userguide/kotlin_dsl.html\">Kotlin DSL</a>\"的改进，包括在预编译Kotlin脚本插件中<a href=\"https://docs.gradle.org/8.5-rc-1/release-notes.html#faster-first-use\">更快的首次使用</a>\"以及<a href=\"https://docs.gradle.org/8.5-rc-1/release-notes.html#catalog-precompiled\">对版本目录的支持</a>\"；改进了错误和告警的报告。关于此版本的更多细节可以在<a href=\"https://docs.gradle.org/8.5/release-notes.html\">发布说明</a>\"中找到。</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/12/java-news-roundup-nov27-2023/\">Java News Roundup: JDK 22, Spring CVEs, Liberica JDK, JDKMon 21, Jupyter for Java, Gradle 8.5</a>\"</p>",
    "publish_time": "2023-12-21 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "软硬结合，共赴服务器操作系统的云智未来",
    "url": "https://www.infoq.cn/article/7fJZyhHOECjwFE33z6TJ",
    "summary": "<p>随着&nbsp;CentOS&nbsp;停服、信创产业蓬勃发展、生成式&nbsp;AI&nbsp;浪潮来袭等大事件接连发生，国产服务器操作系统正在迎来前所未有的崛起机遇。据信通院近期调查显示，国内大量服务器操作系统用户已经开始了国产替换的考量或计划，有意愿且已开始试点或制定计划的用户高达&nbsp;72%，意向用户占&nbsp;12%。与此同时，在多样性算力和智能计算快速发展的背景下，服务器操作系统产业正在步入&nbsp;2.0&nbsp;时代，新一代国产服务器操作系统开始全面围绕如何充分释放计算能力的核心问题，面向以云计算、智能计算为主的技术方向进化，这一变化进一步加快了主流用户向国产操作系统迁移的进度。</p><p>&nbsp;</p><p>在国产服务器操作系统百花齐放的局面中，龙蜥操作系统社区是发展水平较高、品牌市场基础较好的榜样之一。2023&nbsp;年&nbsp;12&nbsp;月&nbsp;17-18&nbsp;日，首届龙蜥操作系统大会在北京召开，以《云智融合&nbsp;共筑未来》为主题，宣告龙蜥社区到达了一个新的发展节点。大会筹备期间，InfoQ&nbsp;采访了龙蜥社区副理事长单位，英特尔公司软件与先进技术事业部研发总监杨继国，就英特尔公司与龙蜥战略合作、社区共建以及云智融合对服务器操作系统的影响等主题进行了深入探讨。</p><p>&nbsp;</p><p></p><h2>生态共建，英特尔与龙蜥社区携手同行</h2><p></p><p>&nbsp;</p><p>英特尔公司是在&nbsp;2020&nbsp;年首批加入龙蜥社区的&nbsp;14&nbsp;家理事单位之一，英特尔也同时加入了龙蜥社区的技术委员会、运营委员会，与其他伙伴共同推动社区的生态发展。在龙蜥社区，各项社区活动总体是以各个社区兴趣小组为基础展开的，英特尔也创建了名为&nbsp;Intel&nbsp;SIG&nbsp;的兴趣小组，并参与和促进了总共&nbsp;14&nbsp;个相关兴趣小组的发展。这些小组共同努力，使得龙蜥操作系统对各大主流芯片架构、平台技术的支持达到了业内领先水平，例如英特尔第四代、第五代至强可扩展处理器的&nbsp;AMX&nbsp;加速引擎、QAT&nbsp;网络加速、TDX&nbsp;安全虚拟机技术等创新特性就第一时间在龙蜥系统中得到了支持。此外，英特尔还向社区贡献了很多英特尔与龙蜥共同运用的技术最佳实践，并举办了多场线上、线下&nbsp;Meetup、Workshop，与社区共同撰写技术白皮书等，通过多种形式推动社区生态发展。</p><p>&nbsp;</p><p>在英特尔看来，龙蜥社区是国内领先的系统软件和开源生态社区，对国产软件生态有着很大的影响力和促进作用。英特尔与龙蜥社区的合作对双方的技术创新和生态拓展都有良好的推动力，一方面英特尔能够帮助社区在先进芯片技术支持方面维持领先地位，另一方面龙蜥社区也能帮助英特尔将很多最新的平台技术、软件特性高效传递给用户。例如，Intel&nbsp;SIG&nbsp;帮助龙蜥操作系统的很多发行版对英特尔至强平台提供了完善支持，还通过最佳实践教学用户将至强平台的新特性充分利用起来；阿里云等社区合作伙伴也在英特尔的帮助下，在自身产品中运用了英特尔平台的创新特性，等等。</p><p>&nbsp;</p><p>英特尔公司在龙蜥社区中的经历只是龙蜥开放生态的一个缩影。整体而言，龙蜥是多元化的开源技术生态社区，有来自各个行业的生态伙伴共同参与，丰富的多样性使这些生态伙伴能够将不同行业的经验和需求都带入社区广泛交流应对。由此以来，当社区协商龙蜥的技术发展路线、开发不同的发行版等工作时，就能充分考虑到不同垂直行业的需求、利用各类创新技术成果，使得龙蜥的技术发展紧跟行业大趋势，进而在关键节点上推动各行各业的数字化升级。</p><p>&nbsp;</p><p></p><h2>国产服务器操作系统崛起，云智融合成为行业方向</h2><p></p><p>&nbsp;</p><p>今天，服务器操作系统技术正在从传统的服务器硬件管理、支撑应用运行逐渐向覆盖云、边、端多场景，支持多样化算力的方向升级迭代，服务器操作系统的边界不断拓展，针对不同场景的深度定制化与对异构算力的优化成为技术突破重点。在这样的背景下，国产开源服务器操作系统近年来发展飞快，以龙蜥为代表的新一代国产操作系统从发展伊始就面向全新的行业趋势来开发设计，从而很快得到了行业的认可与应用。仅以龙蜥操作系统为例，目前其装机量超过&nbsp;600&nbsp;万，服务各个行业用户超过&nbsp;80&nbsp;万，在政务、金融、电信、互联网等领域有着较好的用户基础，竞争力持续提升。此外，龙蜥开启捐献到了开放原子开源基金会的流程，为开源产业的发展做出了贡献和表率。</p><p>&nbsp;</p><p>随着云计算和人工智能技术的飞跃式进步，行业也需要服务器操作系统进行对应的升级。2023&nbsp;年是生成式&nbsp;AI全面爆发的元年，硬件产业做了很多创新来为大模型等&nbsp;AI&nbsp;应用提供更加充沛的算力支持。英特尔就在第四代至强处理器上引入了&nbsp;AMX&nbsp;加速引擎、动态负载均衡加速器&nbsp;DLB、数据流加速器&nbsp;DIC&nbsp;和&nbsp;TDX&nbsp;安全虚拟技术，帮助云厂商以更低的&nbsp;TCO、更加安全可信赖的环境为用户提供更高算力的生成式&nbsp;AI&nbsp;服务。对此，英特尔与龙蜥社区共同规划合作，在&nbsp;2023&nbsp;年的主要版本更新中率先支持了第四代至强处理器的诸多特性，有力支持了云厂商的生成式&nbsp;AI&nbsp;服务升级。</p><p>&nbsp;</p><p>纵观全局，云计算与人工智能的发展是互相促进，相辅相成的。云计算能够为&nbsp;AI&nbsp;提供大规模、多样化的并行&nbsp;AI&nbsp;算力支持，大模型可以充分利用云端海量数据进行训练和推理，且云计算全球化部署的特性使得&nbsp;AI&nbsp;产品可以轻松为全球用户提供服务。反过来说，AI&nbsp;也能够为云计算提供更加智能的技术和运维支持，提升服务质量，实现智能服务调度和优化、智能算力预测等智算功能，帮助云厂商提升服务效率，降低&nbsp;TCO。云计算与人工智能结合，还让更多缺乏足够资源的中小企业可以轻松运用大模型等前沿技术进行业务创新，改善用户体验。</p><p>&nbsp;</p><p>服务器操作系统作为云计算基础设施的重要组成部分，在云智融合、携同发展的技术大势中肩负着重要任务。新一代服务器操作系统需要提供更好的解决方案，完美地融合各类开源工具链，帮助&nbsp;AI&nbsp;开发者和用户能够更轻松地构造、部署、管理和使用基于云计算的&nbsp;AI&nbsp;服务。另一大挑战来自安全性，AI&nbsp;服务的基础模型、算法和数据都需要更加完善的安全防护，预防窃取、篡改和滥用，这就要求操作系统建立更加安全、高效的响应机制。操作系统需要依托开源社区和专业安全机构，第一时间获取软件漏洞信息，同时通过迅捷的安全修复机制尽快修复漏洞，并及时响应已发生的安全攻击事件。最后，云智时代软硬件技术的频繁升级还会带来很多兼容性挑战，服务器硬件组件的持续升级需要软件层面优化适配，服务器操作系统的升级又可能对云智环境中的已有组件产生影响，极端情况下甚至可能需要组件重构代码以继续运行。这些兼容性问题需要操作系统和云服务厂商提前合理规划，实现平稳升级过渡，避免兼容性问题导致服务中断等事件。</p><p>&nbsp;</p><p>针对上述问题，龙蜥社区的开放和共建体系发挥出了很大优势。由于龙蜥社区非常注重技术创新进步，社区成员都很活跃，社区建立了能够吸纳创新技术、建立自身技术优势的机制。例如，英特尔的硬件团队在芯片设计阶段就会与软件团队紧密沟通，收集社区用户的反馈来调整设计，同时软件团队会提前开始新特性的优化适配工作。以上文提到的&nbsp;AMX&nbsp;加速引擎为例，龙蜥社区就很早引入了&nbsp;AMX&nbsp;指令来加速&nbsp;AI&nbsp;深度学习效率，获得两倍甚至更高的性能提升。又如英特尔&nbsp;TDX&nbsp;安全虚拟技术也在一两年前就开始在龙蜥社区引入，很早就完成了代码集成、测试等工作，提前集成到了龙蜥操作系统中。TDX&nbsp;技术使得云计算环境中，用户向云端上传的数据可以得到处理器硬件级的端到端加密保护，即便云厂商自身也无法解密获取，这样的设计极大提升了用户信心，为云端生成式&nbsp;AI&nbsp;等服务的普及打通了重要瓶颈。</p><p>&nbsp;</p><p>云智融合成为行业主要技术方向的当下，龙蜥社区的开放架构与创新机制使得更多厂商能够像英特尔一样，与社区内的其他产业伙伴共同加快创新技术的研发与应用过程。龙蜥社区的繁荣生态环境，也为国产服务器操作系统的崛起起到了引领作用，助力更多企业向国产操作系统迁移，并充分利用云计算与生成式&nbsp;AI&nbsp;等前沿技术的能力创造价值。</p><p>&nbsp;</p><p></p><h2>公平中立、开放活跃，龙蜥为开源社区治理作出表率</h2><p></p><p>&nbsp;</p><p>作为开源服务器操作系统社区，龙蜥在开源生态建设和治理方面的经验和成果也是可圈可点的。龙蜥社区有着典型的开源治理模式，所有社区角色和管理操作都是透明公开的，社区理事会的全部成员都有公平的机会表达观点，每一项社区角色都有理事会成员共同参与，社区对所有成员也是中立无偏向的。</p><p>&nbsp;</p><p>龙蜥社区从创立之初就积极鼓励创新、充满技术活力，并为来自各行业的技术人才提供了展示才华的机会，向他们提供了丰富的资源和工具，形成了活跃的开源人才生态圈。仅在&nbsp;2023&nbsp;年，社区开发者中就有超过&nbsp;15000&nbsp;人有代码贡献记录。活跃的开发者氛围为创新打下了坚实基础，龙蜥的每一个发行版都有众多创新特性，反过来也让社区竞争力持续提升。</p><p>&nbsp;</p><p>最后，龙蜥社区的理事成员涵盖了云厂商、芯片厂商、整机厂商、操作系统厂商、电信运营商、互联网服务商、独立软件开发商、系统解决方案提供商等诸多领域，社区成员来自各个行业与细分市场，有力保障了社区的多样与开放性。</p><p>&nbsp;</p><p>在社区的基础治理和协同研发方面，英特尔公司正在龙蜥社区内逐渐转向技术引领者的角色，参加了&nbsp;50&nbsp;余个&nbsp;SIG&nbsp;中的&nbsp;20&nbsp;多个，孵化了很多具有技术领先性和影响力的项目，是社区内影响力最大的厂商之一。2022-23&nbsp;年，英特尔公司在社区提交的代码约&nbsp;30&nbsp;万行，参与维护了四个代码仓库，也在龙蜥社区大会上获得了多个奖项。和英特尔公司一样，其他社区成员也在积极发挥自身优势，努力为社区贡献有价值的代码和项目，对社区事务发表观点，参加社区活动，推动龙蜥社区的技术进步。</p><p>&nbsp;</p><p>目前，龙蜥社区凭借活跃、丰富的开源生态，在国际开源社区中也取得了充足的话语权。社区围绕芯片、内核、编译器、安全、虚拟化及云原生等操作系统核心领域持续进行技术创新，进而推动建立国际范围的技术标准。随着龙蜥社区开源商业模式的不断成熟，越来越多的厂商依托龙蜥社区，&nbsp;不断推出国产服务器操作系统社区发行版及商业版，满足国产替代多样化需求。在此基础上，开源的参与方企业形成开源&nbsp;+&nbsp;服务的多种&nbsp;商业模式，加速开源项目的商业化落地，商业上的成功支撑龙蜥社区不断壮大，从而产生更多技术创新，龙蜥社区与商业模式也由此形成了良性循环。</p><p>&nbsp;</p><p>未来，英特尔等社区伙伴将进一步加强对龙蜥社区的技术发展与生态建设的投入，进一步在新技术使能、垂直软件栈集成、用户场景优化、社区最佳实践发布等方面持续发力，支持社区软硬件和应用生态繁荣局面。龙蜥社区正在紧抓国产替代与生成式&nbsp;AI&nbsp;浪潮等历史机遇，为中国开源社区基础建设和国产服务器操作系统生态发展作出表率，从而推动全产业数字化进程，帮助更多企业把握智算时代创新脉搏。</p>",
    "publish_time": "2023-12-21 11:04:04",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "搭起AI和DB之间“桥梁”！阿里云开源新技术：将AI算法“一键部署”进数据库",
    "url": "https://www.infoq.cn/article/htR9SxSgVDy9KhUUY4RX",
    "summary": "<p>12月20日，数据库国际顶会VLDB2024公布新一批论文，阿里云旨在实现将AI算法在数据库“一键部署”的PilotScope中间件相关论文成功入围。同日，阿里云宣布将PilotScope全部技术免费开源。</p><p>&nbsp;</p><p>开源地址：<a href=\"https://github.com/alibaba/pilotscope\">https://github.com/alibaba/pilotscope</a>\"</p><p></p><h2>在AI和DB之间“搭桥”</h2><p></p><p>&nbsp;</p><p>AI 和数据库的结合在业内已经探索了很长一段时间，其中AI for DB 是利用 AI 技术替换数据库里的某些功能，使其性能得到提升。</p><p>&nbsp;</p><p>这个方案需要依赖深度学习或者说大模型。但难点在于，AI开发和数据库开发基本是两拨人，数据库特别复杂，AI开发人员很难梳理清楚其中的结构，得到嵌入效果的同时还要保证数据库的稳定性。同时，AI方法非常多样，数据库底层架构也不尽相同，这导致嵌入的模式、交互需求、具体底层实现方式都各不相同，如果做定制化就会带来很大的时间成本，不利于大规模应用。</p><p>&nbsp;</p><p>“AI做了很多，DB做了很多，但中间的桥梁没有人干，这个桥是不通的。我们现在做的事情就是要把这个桥搭建起来。”PilotScope项目负责人朱鎔说道。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/96/965e270024da0ee69ed41bd0d20a5fd6.png\" /></p><p></p><p>根据朱鎔的介绍，PilotScope 屏蔽不同数据库异构的细节，提供了抽象的、可对AI调用的一整套接口。PilotScope把数据库交互需求及嵌入过程，抽象成了一个个的接口，将最难的底层细节开发部分屏蔽掉，用户可以直接使用，AI工程师不用关注数据库的细节。</p><p>&nbsp;</p><p>理论上，用户只要支持这个接口，同一个AI方法可以支持各种数据库，包括阿里云、微软、AWS以及PostgreSQL等数据库，开发者可以用一个方法、写一次代码就支持所有类型数据库在上面的运行。接口还可以不断扩展，支持不同AI方法的需求，同时通过开源的方式来增加支持AI算法的多样性。</p><p>&nbsp;</p><p>另外，PilotScope对AI算法的嵌入做了最小的扰动和侵入，不对系统的稳定性造成影响。用户不开启PilotScope时可以直接忽略它的存在，而使用PilotScope并把某些AI算法进行了相应运行后，PilotScope的检测机制会处理和限定模型的异常输出，对于不正常的结果会直接打断，让数据用原来的模块运行。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/6e/6ec0d41a67e0b098d14ebfd13804e0cd.png\" /></p><p></p><p>&nbsp;据了解，当前PilotScope针对参数调优、索引推荐、基数估计、查询优化等数据库主流任务，预置了10多种AI算法，并完成PostgreSQL和Spark等两大主流开源数据库的适配打样。根据团队的实验数据，使用PilotScope将AI算法嵌入数据库，较传统“硬植入”方法，查询优化等任务提速1-2倍不等，并且PilotScope本身对部署产生的额外代价基本可忽略。</p><p></p><h2>十多人，用了两年做研发</h2><p></p><p>&nbsp;</p><p>PilotScope项目是一个深度交叉的领域：要有懂算法的研发人员明确算法具体需求，也要有懂系统的研发将需求真正抽象成系统化设计；除了要有懂AI的人，还要有懂数据库的人，了解数据库架构、嵌入模式、与数据库的交互等；在系统设计的人员抽象出系统模式后，还需要开发人员用实际的代码把构思实现出来；AI for DB是学界想做的算法探索研究，业界想做一些实际落地，两者的综合平衡对满足开源社区是比较重要的。</p><p>&nbsp;</p><p>从上可以看出，这样的研发难度是不小的。朱鎔表示，从有做PilotScope的想法开始到今天正式搞出来，十几个人的团队差不多用了两年时间才基本完成。</p><p>&nbsp;</p><p>做PilotScope的想法来源于阿里云团队在做AI for DB中遇到了测试、部署、落地等各种痛点问题。2021年夏季之前，团队是点对点地解决，然后发现通用性差、成本高，很难持续下去。之后，团队开始构思这样的一个中间件，在与业务部门沟通、研究了学界最新进展后，才将最终需求确认下来，包括要支持哪些主流方法、支持到什么程度等。</p><p>&nbsp;</p><p>整个2022年，团队一直在解决“两端解耦、让桥顺畅”的难题，到了9月份左右才开始做真正的系统研发。考虑到两个数据库的适配，团队要做很多细小的修改、打磨、迭代，陆陆续续到今年八九月份才算基本成熟。</p><p>&nbsp;</p><p>据悉，PilotScope目前已在阿里云内部展开试点应用。朱鎔表示，未来将做一些产业化部署，希望通过这个工具，把AI for DB的算法真正大规模的地应用到数据库系统里，提升数据库系统的效率和效果。</p>",
    "publish_time": "2023-12-21 11:16:35",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]