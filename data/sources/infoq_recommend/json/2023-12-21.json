[
  {
    "title": "优化容器工作负载：Kubernetes装箱的效益和挑战",
    "url": "https://www.infoq.cn/article/xW8oBGXBqDkhDMgOALDC",
    "summary": "<p>Kubernetes已经成为容器编排事实上的标准，因此企业不断寻求优化其集群资源利用的方法。其中一种技术是装箱（bin packing）：在集群中有效地分配资源，以最小化运行工作负载所需的节点数量。装箱使得企业能够通过减少支持应用程序所需的节点数量来降低成本。</p><p>&nbsp;</p><p>在Kubernetes中，装箱的概念涉及在节点内部战略性地放置容器或“箱子（bin）”，以最大化资源利用率和减少资源浪费。如果实施得当，可以实现对硬件资源更有效的利用，并降低基础设施成本。在云环境中，这尤为重要，因为基础设施支出占据IT开支的相当大部分。</p><p>&nbsp;</p><p>在本文中，我们将探讨在Kubernetes中进行装箱的复杂性，讨论与这种方法相关的挑战和权衡，并提供在企业中实现装箱的示例和最佳实践。</p><p>&nbsp;</p><p></p><h2>Kubernetes装箱挑战</h2><p></p><p>&nbsp;</p><p>尽管Kubernetes中的装箱在资源利用和成本节约方面提供了显著的好处，但也带来了一些需要解决的问题。</p><p>&nbsp;</p><p></p><h3>密度与工作负载隔离和分发</h3><p></p><p>&nbsp;</p><p>实现装箱的一个主要问题是在最大化资源密度和保持工作负载隔离性之间找到平衡，同时要确保工作负载分布在系统和可用区（AZ）中，以御硬件故障。将容器高密度地打包到节点上可以提高资源利用率，但也可能增加对共享资源（如CPU和内存）争用的风险。</p><p>&nbsp;</p><p>这可能导致性能下降，并可能影响整个集群的稳定性。此外，过度的装箱可能与分配的概念相矛盾，降低系统抵御硬件故障的能力。因此，我们有必要明智地并只在用例有意义的情况下应用装箱策略。</p><p>&nbsp;</p><p>为了更深入地理解这种权衡的含义，有必要考虑密度的增加对集群容错性所造成的影响。当容器被高密度地打包到较少的节点上时，单个节点的故障可能对应用程序的整体健康和可用性产生更大的影响。这带来了一个问题：在节省成本的同时，如何确保你的工作负载对潜在故障的弹性？</p><p>&nbsp;</p><p></p><h3>在节点上过度集中应用程序的风险</h3><p></p><p>&nbsp;</p><p>在节点中过度装箱应用程序的风险与保持分布式部署的“最佳实践”是两个对立面。把所有的鸡蛋放在一个篮子里，这是典型的风险管理错误。这是一种操作风险，如果某些节点宕机，整个部署的更大部分也将随之离线。因此，一方面，出于弹性的考虑，你希望尽可能偏向分布式。另一方面，你希望控制成本，而装箱是一个很好地解决方案。在这种平衡中找到最佳的点才是关键。</p><p>&nbsp;</p><p>当多个容器争用单个节点有限的资源（如内存或CPU）时，这些问题变得更加明显，从而导致资源匮乏和应用程序性能下降。此外，以非逐渐方式或突发方式扩展系统还可能导致不必要的故障，进一步加剧这些挑战。为了应对这些不一致性，可以尝试设置策略限制，确保向应用程序提供可靠的资源。</p><p>&nbsp;</p><p>在高密度装箱到节点时需要考虑的另一个问题是对维护和更新的潜在影响。随着在单个节点上运行更多的容器，对维护任务或软件更新的影响可能会被放大，导致更长时间的停机或降低应用程序性能。在进行装箱时，如何管理更新和维护而不对工作负载性能产生负面影响，是需要认真考虑的问题。</p><p>&nbsp;</p><p></p><h3>解决挑战的调度策略</h3><p></p><p>&nbsp;</p><p>Kubernetes提供了几种调度策略来帮助解决与装箱相关的问题：</p><p>&nbsp;</p><p><a href=\"https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\">资源请求和限制</a>\" 允许你配置Kubernetes调度程序在进行调度决策时考虑每个节点上的可用资源，这使你能够将容器放置在具有适当资源量的节点上。<a href=\"https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity\">Pod亲和性和反亲和性规则</a>\" 允许你根据其他Pod的存在来指定Pod应该或不应该放置在哪些节点上，这有助于确保工作负载在整个集群中均匀分布，或者根据特定要求在某些节点上进行分组。例如，处理基本客户数据的数据关键系统需要尽可能偏向分布式，以增强可靠性和性能。这种方法可以降低单点故障风险，带来更好的整体系统弹性。<a href=\"https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/\">Pod拓扑传播约束</a>\" 使你能够考虑区域等因素，控制Pod在节点之间的分布方式。通过使用这些约束，你可以确保工作负载均匀分布，最大限度地减少单个节点过载的风险，并提高整体集群弹性。</p><p>&nbsp;</p><p>通过仔细考虑和实施这些调度策略，你可以有效地解决在Kubernetes中进行装箱所面临的挑战，同时保持最佳的资源利用率和性能。</p><p>&nbsp;</p><p></p><h2>Kubernetes装箱示例</h2><p></p><p>&nbsp;</p><p>关于在Kubernetes中如何有效地为不同类型的工作负载（从无状态的Web应用程序到数据库实例等）实施装箱，我们将在下面探讨其中一些示例。</p><p>&nbsp;</p><p></p><h3>无状态应用程序</h3><p></p><p>&nbsp;</p><p>Kubernetes可以将多个无状态应用程序实例打包到单个节点中，同时确保每个实例都具有足够的资源。通过使用资源请求和限制，你可以引导Kubernetes调度程序为每个实例分配适当数量的CPU和内存。只要这些实例有足够的资源，它们就会启动并运行，并确保无状态应用程序（如Web应用程序或面向客户的应用程序）具有高可用性。</p><p>&nbsp;</p><p></p><h3>数据库实例</h3><p></p><p>&nbsp;</p><p>在处理数据库时，Kubernetes可以有效地将不同有状态应用程序的单个实例打包到节点中，以最大化吞吐量和最小化延迟。通过利用Pod亲和性规则，你可以确保数据库实例放置在拥有必要的卷并与其他组件（如缓存服务器或应用程序服务器）接近的节点上。这有助于优化资源使用，同时保持数据库操作的高性能和低延迟。</p><p>&nbsp;</p><p></p><h3>批处理和机器学习工作负载</h3><p></p><p>&nbsp;</p><p>装箱也能给批处理和机器学习工作负载带来好处。Kubernetes可以使用Pod拓扑传播约束确保这些工作负载均匀分布在节点上，防止资源争用，保持性能处于最佳状态。</p><p>&nbsp;</p><p></p><h3>大型多节点集群</h3><p></p><p>&nbsp;</p><p>如果需要将服务分布到大量节点（例如2000个节点）中，资源优化仍然是一个重要的考虑因素。虽然将这些服务分散开对于容错能力来说是必不可少的，但仍然需要考虑对剩余的服务进行装箱，以提高节点的利用率。</p><p>&nbsp;</p><p>如果使用了特定的节点资源，Kubernetes可以通过拓扑传播配置（例如<a href=\"https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/\">PodTopologySpreadArgs</a>\"）来管理它们。集群管理员和云供应商应该要确保节点得到相应的配置，以平衡分散的服务和装箱的服务。</p><p>&nbsp;</p><p>通过理解和应用这些示例，你可以利用装箱来优化资源利用率，提高集群的整体效率。</p><p>&nbsp;</p><p></p><h2>Kubernetes装箱的成本效益</h2><p></p><p>&nbsp;</p><p>通过在集群内有效地分配资源并最小化支持工作负载所需的节点数量，装箱有助于降低基础设施成本。这是通过将多个容器合并到较少的节点上实现的，减少了对额外硬件或云资源的需求。因此，企业可以在硬件、能源和维护方面节省开支。</p><p>&nbsp;</p><p>在云环境中，基础设施成本占IT开支的很大一部分，因此通过装箱实现的成本节省可能非常显著。云提供商通常根据使用的节点数量和大小向客户收费，通过装箱优化资源利用率直接可以转化为减少云基础设施费用。</p><p>&nbsp;</p><p></p><h2>Kubernetes装箱最佳实践</h2><p></p><p>&nbsp;</p><p>要充分利用Kubernetes装箱所带来的好处，需要遵循一些最佳实践，确保在防止出现性能问题的同时实现最佳资源利用。以下是三个重要的最佳实践。</p><p>&nbsp;</p><p></p><h3>谨慎的规划和测试</h3><p></p><p>&nbsp;</p><p>在Kubernetes环境中实施装箱之前，需要仔细规划和测试容器在节点中的放置。这可能涉及分析工作负载的资源需求，确定适当的密度水平，并在不同场景下测试集群的性能和稳定性。此外，设置内存的硬限制至关重要，因为内存是不可压缩的资源，应谨慎分配，以避免影响其他的应用程序。还要考虑潜在的内存泄漏问题，确保一个节点的内存泄漏不会在整个系统中造成混乱。</p><p>&nbsp;</p><p>花一些时间进行规划和测试有助于避免与装箱相关的潜在问题，如资源争用和性能下降。</p><p>&nbsp;</p><p></p><h3>正确设置节点和容器大小</h3><p></p><p>&nbsp;</p><p>正确设置节点和容器大小是优化Kubernetes环境中资源利用的关键。为实现这一目标，首先需要评估应用程序的资源需求，如CPU、内存和存储。这些信息有助于确定最适合的节点大小和容器资源限制，以最大限度地减少浪费和提高效率。为工作负载设置适当的节点和容器大小至关重要，因为如果你的容器太大并占用了节点相当比例的资源，那么你将无法将其他容器放置到节点上。例如，如果你运行一个非常大的容器，占用了每个节点75%的资源，那么将导致25%的浪费，无论你设置了多少装箱规则。在优化Kubernetes环境时，容器分配的资源和机器提供的资源是需要考虑的关键因素。</p><p>&nbsp;</p><p></p><h3>随时监控和调整</h3><p></p><p>&nbsp;</p><p>在Kubernetes集群中保持最佳资源利用需要进行持续的监控和调整。随着工作负载和需求的演变，可能需要重新评估装箱策略，以确保其有效性。</p><p>&nbsp;</p><p>进行定期监控可以帮助你及早识别问题，如资源争用或未被充分利用的节点，让你能够在问题升级之前做出调整。</p><p>&nbsp;</p><p></p><h3>利用Kubernetes特性进行装箱</h3><p></p><p>&nbsp;</p><p>资源配额 允许你限制命名空间可以消耗的资源量，确保不存在单个工作负载垄断集群的可用资源。资源请求和限制 可以让你引导Kubernetes调度程序将容器放置在具有适当资源量的节点上，这有助于确保工作负载被高效分配，并最小化资源争用。</p><p>&nbsp;</p><p>另外需要考虑的一点是基础设施对环境的影响。通过装箱来优化资源利用，你可以潜在地减少企业的碳排放。运行较少的节点意味着消耗更少的能源并产生更少的热量，这有助于降低温室气体排放和降低对环境的影响。这带来了一个重要的问题：企业如何在追求成本效益和性能的同时，平衡其社会责任，以减少碳排放？</p><p>&nbsp;</p><p></p><h2>结论</h2><p></p><p>&nbsp;</p><p>在Kubernetes中进行装箱在优化资源利用和降低基础设施成本方面发挥着至关重要的作用，但同样重要的是如何在优化Kubernetes资源时正确找到效率和性能之间的平衡。</p><p>&nbsp;</p><p>通过在集群中战略性地分配资源，企业可以将运行工作负载所需的节点数量降到最低，实现更低的支出和更高效的基础设施管理。</p><p>&nbsp;</p><p>然而，正如讨论过的那样，企业需要面对与装箱相关的一些性能挑战和权衡以及在Kubernetes环境中有效使用装箱的最佳实践。通过理解和利用这些技术，企业可以最大限度地利用集群中的资源，节省基础设施成本，并提高总体效率。</p><p>&nbsp;</p><p>&nbsp;</p><p>原文链接：</p><p>https://www.infoq.com/articles/kubernetes-bin-packing/</p><p></p><p></p><h5>相关阅读：</h5><p></p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ%3D%3D&amp;chksm=e8d7e428dfa06d3ed76212b029784a7db555f1c09321a535ded950b30a7258bf3d84e30de519&amp;idx=1&amp;mid=2247490538&amp;scene=27&amp;sn=d9aab0a30357e4b1689e578144cf3957&amp;utm_campaign=geek_search&amp;utm_content=geek_search&amp;utm_medium=geek_search&amp;utm_source=geek_search&amp;utm_term=geek_search#wechat_redirect\">50+ 顶级开源&nbsp;Kubernetes&nbsp;工具列表</a>\"</p><p><a href=\"https://www.infoq.cn/article/kubernetes-effect?utm_campaign=geek_search&amp;utm_content=geek_search&amp;utm_medium=geek_search&amp;utm_source=geek_search&amp;utm_term=geek_search\">Kubernetes&nbsp;效应</a>\"</p><p><a href=\"https://www.infoq.cn/article/8XZ4ZV59Yx9NHyqbaIlI?utm_campaign=geek_search&amp;utm_content=geek_search&amp;utm_medium=geek_search&amp;utm_source=geek_search&amp;utm_term=geek_search\">你该如何为&nbsp;Kubernetes&nbsp;定制特性</a>\"</p><p><a href=\"https://www.infoq.cn/article/u6D2XoVVVz1fpxxzBKzT?utm_campaign=geek_search&amp;utm_content=geek_search&amp;utm_medium=geek_search&amp;utm_source=geek_search&amp;utm_term=geek_search\">用了就会更好吗？小心&nbsp;Kubernetes&nbsp;陷阱</a>\"</p>",
    "publish_time": "2023-12-21 00:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Java新闻汇总：JDK 22、Spring CVE、Liberica JDK、JDKMon 21、Jupyter for Java和Gradle 8.5",
    "url": "https://www.infoq.cn/article/kHGCPfPcKtU7XBaxATRU",
    "summary": "<p></p><h4>OpenJDK</h4><p></p><p></p><p>在审查结束后，JEP 463，<a href=\"https://openjdk.org/jeps/463\">隐式声明类和实例主方法（Implicitly Declared Classes and Instance Main Methods，第二轮预览）</a>\"，已经在JDK 22中从Targeted状态<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-November/008469.html\">提升</a>\"到了Proposed to Target状态。它以前被称为未命名类和实例主方法（Unnamed Classes and Instance Main Methods，预览）、灵活主方法和匿名主类（Flexible Main Methods and Anonymous Main Classes，预览）和隐式类和增强的主方法（Implicit Classes and Enhanced Main Methods，预览），该JEP包含了对前一轮<a href=\"https://openjdk.java.net/jeps/12\">预览</a>\"反馈的增强，即JEP 445，<a href=\"https://openjdk.org/jeps/445\">未命名类和实例主方法（预览）</a>\"。这个JEP建议“演进Java语言，这样学生们就可以编写他们的第一个程序，而不需要理解为大型程序所设计的语言特性”。该JEP延续了甲骨文的Java语言架构师<a href=\"https://www.linkedin.com/in/briangoetz/\">Brian Goetz</a>\"在2022年9月发表的博客文章<a href=\"https://openjdk.org/projects/amber/design-notes/on-ramp\">Paving the on-ramp</a>\"。甲骨文的技术顾问<a href=\"https://www.linkedin.com/in/gavin-bierman-a0173075/\">Gavin Bierman</a>\"已经<a href=\"https://mail.openjdk.org/pipermail/amber-dev/2023-May/008065.html\">发布了</a>\"规范文档的<a href=\"https://cr.openjdk.org/~gbierman/jep445/jep445-20230502/specs/unnamed-classes-instance-main-methods-jls.html\">初稿</a>\"，供Java社区审查。关于JEP 445的更多细节可以在InfoQ的<a href=\"https://www.infoq.com/news/2023/05/beginner-friendly-java/\">新闻报道</a>\"中找到。</p><p>&nbsp;</p><p>在审查结束后，JEP 462，<a href=\"https://openjdk.org/jeps/462\">结构化并发（Structured Concurrency，第二次预览）</a>\"，已经从Proposed to Target状态<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-December/008493.html\">提升</a>\"到了Targeted状态。这个JEP提议在JDK 22中重新审查API，不做任何变更，以便于从上一轮预览中获取更多的反馈，即JDK 21交付的JEP 453，<a href=\"https://openjdk.org/jeps/453\">结构化并发（预览）</a>\"。这个特性通过引入结构化并发性来简化并发编程，“将在不同线程中运行的相关任务组视为单个工作单元，从而简化错误处理和取消，提高可靠性并增强可观测性。”</p><p>&nbsp;</p><p>在审查结束后，JEP 461,&nbsp;<a href=\"https://openjdk.org/jeps/461\">流收集器（Stream Gatherers，预览）</a>\"，已经在JDK 22中从Proposed to Target状态<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-November/008473.html\">提升</a>\"到了Targeted状态。该JEP建议增强流API以支持自定义的中间操作。“这将允许流管道以现有内置中间操作难以实现的方式转换数据。”关于此JEP的更多细节可以参考甲骨文Java平台组软件架构师<a href=\"https://www.linkedin.com/in/viktorklang/\">Viktor Klang</a>\"编写的原始<a href=\"https://cr.openjdk.org/~vklang/Gatherers.html\">设计文档</a>\"。</p><p>&nbsp;</p><p>在审查结束后，JEP 458，<a href=\"https://openjdk.org/jeps/458\">启动多文件源码程序（Launch Multi-File Source-Code Programs）</a>\"，已经在JDK 22的Proposed to Target状态<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-December/008494.html\">提升</a>\"到了Targeted状态。该JEP建议增强Java Launcher，以执行通过一个或多个Java源代码文件提供的应用程序。这可以通过推迟一个完整项目的搭建来实现从小型应用程序到大型应用程序的渐进过渡。</p><p>&nbsp;</p><p>在审查结束后，JEP 457，<a href=\"https://openjdk.org/jeps/457\">类文件API（Class-File API，预览）</a>\"，已经在JDK 22的Proposed to Target状态<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-November/008471.html\">提升</a>\"到了&nbsp;Targeted状态。该JEP建议提供一个API来解析、生成和转换Java类文件。它最初作为JDK中<a href=\"https://asm.ow2.io/\">ASM</a>\"的替代品，ASM是一个Java字节码操作和分析框架，并计划将其作为公开API对外开放。甲骨文的Java语言架构师<a href=\"https://www.linkedin.com/in/briangoetz\">Brian Goetz</a>\"将ASM描述为“带有大量遗留包袱的旧代码库”，并提供了关于该草案如何发展并最终取代ASM的<a href=\"https://mail.openjdk.org/pipermail/discuss/2022-June/006131.html\">背景信息</a>\"。</p><p>&nbsp;</p><p>在审查结束后，JEP 423，<a href=\"https://openjdk.org/jeps/423\">G1的区域锚定（Region Pinning for G1）</a>\"，已经在JDK 22的Proposed to Target<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-November/008470.html\">提升</a>\"到了&nbsp;Targeted状态。该JEP建议通过实现<a href=\"https://docs.oracle.com/en/java/javase/17/gctuning/garbage-first-g1-garbage-collector1.html#GUID-ED3AB6D3-FD9B-4447-9EDF-983ED2F7A573\">G1垃圾收集器</a>\"的区域锚定来减少GC延迟。这将扩展G1，以便在major和minor收集操作期间可以锚定任意区域，以便于实现<a href=\"https://shipilev.net/jvm/anatomy-quarks/9-jni-critical-gclocker/\">JNI关键区域</a>\"时避免禁用垃圾收集进程。</p><p>&nbsp;</p><p>JEP 464，<a href=\"https://openjdk.org/jeps/464\">作用域值（Scoped Values，第二次预览）</a>\"，已经从它的JEP Draft 8318898状态<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-November/008472.html\">提升</a>\"至Candidate状态，然后快速在JDK 22<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-November/008480.html\">提升</a>\"到了Proposed to Target状态。它以前被称为范围局部变量（Extent-Local Variables，孵化），这个JEP建议在JDK 22中重新预览API，不做任何更改，以便于从上一轮预览中获得额外的经验和反馈，即JDK 21交付的JEP 446,&nbsp;<a href=\"https://openjdk.org/jeps/446\">作用域值（预览）</a>\"和JDK 20交付的<a href=\"https://openjdk.org/jeps/429\">作用域值（孵化）</a>\"。该特性允许在线程内部和线程之间共享不可变数据。这种方式优于thread-local变量，特别是在使用大量虚拟线程的时候。该审查预计会在2023年12月7日结束。</p><p></p><h4>JDK 22</h4><p></p><p></p><p>JDK 22的早期访问构建版本的<a href=\"https://github.com/openjdk/jdk/releases/tag/jdk-22%2B26\">Build 26</a>\"发布，其中包括对Build 25的<a href=\"https://github.com/openjdk/jdk/compare/jdk-22%2B25...jdk-22%2B26\">更新</a>\"，其中包括对各种<a href=\"https://bugs.openjdk.org/issues/?jql=project%20%3D%20JDK%20AND%20fixversion%20%3D%2022%20and%20%22resolved%20in%20build%22%20%3D%20b26%20order%20by%20component%2C%20subcomponent\">问题</a>\"的修复。关于这个版本的更多细节可以在<a href=\"https://jdk.java.net/22/release-notes\">发行说明</a>\"中找到。</p><p>&nbsp;</p><p>对于<a href=\"https://openjdk.org/projects/jdk/22/\">JDK 22</a>\"，鼓励开发人员通过<a href=\"https://bugreport.java.com/bugreport/\">Java缺陷数据库</a>\"报告缺陷。</p><p></p><h4>Jakarta EE</h4><p></p><p></p><p><a href=\"https://jakarta.ee/specifications/data/\">Jakarta Data</a>\"&nbsp;1.0.0的第二个里程碑版本提供了如下特性：制品名称的重命名，例如，从jakarta-data-api改为jakarta.data-api，以便于同所有Jakarta EE规范保持一致；延迟静态元模型的实现，以进一步解决与反射和注解处理器相关的问题；对版权文档的优化，以便将值与占位符绑定。关于此版本的更多细节可以在<a href=\"https://github.com/jakartaee/data/releases/tag/1.0.0-M2\">发布说明</a>\"中找到。</p><p>&nbsp;</p><p><a href=\"https://www.jnosql.org/\">Eclipse JNoSQL</a>\"（<a href=\"https://jakarta.ee/specifications/nosql/\">Jakarta NoSQL</a>\"规范的兼容实现）的1.0.3版本发布，带来重要的数据库升级，比如，MongoDB驱动4.11.1、Hazelcast 5.3.6、Apache Solr 9.4.0、Couchbase Library 3.4.11和ArangoDB Library7.2.0。更新方法还实现了增强功能，以改进整个项目的功能。关于此版本的更多细节可以在<a href=\"https://github.com/eclipse/jnosql/releases/tag/1.0.3\">发布说明</a>\"中找到。</p><p></p><h4>BellSoft</h4><p></p><p></p><p>BellSoft<a href=\"https://bell-sw.com/blog/bellsoft-releases-liberica-jdk-lts-17-and-21-with-coordinated-restore-at-checkpoint-crac-for-fast-startup/\">发布</a>\"了<a href=\"https://bell-sw.com/libericajdk/\">Liberica JDK</a>\"的17和21版本，这是他们OpenJDK的下游发行版，具有检查点协调恢复(Coordinated Restore at Checkpoint，CRaC)功能，使开发人员能够构建运行中的应用程序快照，减少Java应用的启动和预热时间。这些新版本将适用于x86_64和AArch64 CPU架构以及Linux操作系统。</p><p></p><h4>Spring Framework</h4><p></p><p></p><p>VMware<a href=\"https://spring.io/blog/2023/11/27/cve-2023-34053-cve-2023-34055-spring-framework-and-spring-boot\">披露</a>\"了两个安全漏洞：CVE-2023-34053，<a href=\"https://spring.io/security/cve-2023-34053\">Spring框架服务器Web观测DoS漏洞（Spring Framework Server Web Observations DoS Vulnerability）</a>\"以及CVE-2023-34055，<a href=\"https://spring.io/security/cve-2023-34055\">Spring Boot服务器Web观测DoS漏洞（Spring Boot Server Web Observations DoS Vulnerability</a>\"，它们会影响<a href=\"https://spring.io/projects/spring-framework\">Spring Framework</a>\"6.0.0至6.0.13版本和<a href=\"https://spring.io/projects/spring-boot\">Spring Boot</a>\"3.1.0至3.1.5版本、3.0.0至3.0.12版本以及2.7.0至2.7.17版本。这两个漏洞都允许攻击者提供特制的HTTP请求，这些请求可能会在以下情况下导致拒绝服务：</p><p>应用程序使用了<a href=\"https://docs.spring.io/spring-framework/reference/web/webmvc.html\">Spring MVC</a>\"或<a href=\"https://docs.spring.io/spring-framework/reference/web/webflux.html\">Spring WebFlux</a>\"。io.micrometer:micrometer-core制品位于类路径中。在应用程序中配置了Micrometer&nbsp;ObservationRegistry接口的实现来记录观测结果。</p><p></p><p>因此，鼓励开发人员升级到Spring Framework 6.0.14以及Spring Boot 2.7.18、3.0.13和3.1.6。</p><p>&nbsp;</p><p><a href=\"https://spring.io/projects/spring-shell\">Spring Shell</a>\"的3.2.0-rc1、3.1.6、3.0.10和2.1.15版本<a href=\"https://spring.io/blog/2023/11/28/spring-shell-2-1-15-3-0-10-3-1-6-and-3-2-0-rc1-are-now-available\">发布</a>\"，分别进行了缺陷修复和对Spring Boot 3.2.0、3.1.6、3.0.13和2.7.18依赖升级。3.0和2.1版本系列已被宣布与它们对应的Spring Boot版本一起结束生命周期。3.2.0-RC1和3.1.6版本中的新特性包括：支持zsh补全和模态视图；对<a href=\"https://docs.spring.io/spring-shell/reference/tui/index.html\">Terminal UI</a>\"的小改动。关于此版本的更多细节可以在<a href=\"https://github.com/spring-projects/spring-shell/releases/tag/v3.2.0-RC1\">3.2.0-RC1版本</a>\"、<a href=\"https://github.com/spring-projects/spring-shell/releases/tag/v3.1.6\">3.1.6版本</a>\"、<a href=\"https://github.com/spring-projects/spring-shell/releases/tag/v3.0.10\">3.0.10版本</a>\"和<a href=\"https://github.com/spring-projects/spring-shell/releases/tag/v2.1.15\">2.1.15版本</a>\"的发行说明中找到。</p><p></p><h4>Quarkus</h4><p></p><p></p><p>Red Hat<a href=\"https://quarkus.io/blog/quarkus-3-6-0-released/\">发布</a>\"了<a href=\"https://quarkus.io/\">Quarkus</a>\"的3.6.0版本，其中有一些显著的变化，比如，支持OIDC bearer令牌的自定义授权模式；改进了服务器发送事件(SSE)，允许REST客户端返回整个SSE事件并对这些事件进行过滤；支持与Jakarta Annotations&nbsp;@RolesAllowed注解类似的@SecureField注解中的表达式。关于这个版本的更多细节可以在<a href=\"https://github.com/quarkusio/quarkus/releases/tag/3.6.0\">变更日志</a>\"中找到。</p><p>&nbsp;</p><p>Red Hat还<a href=\"https://quarkus.io/blog/java-17/\">宣布</a>\"JDK 17将是即将发布的Quarkus 3.7要求的最低版本，它计划于2024年1月底发布。InfoQ将会跟进更详细的新闻报道。</p><p></p><h4>Open Liberty</h4><p></p><p></p><p>IBM<a href=\"https://openliberty.io/blog/2023/11/28/23.0.0.12-beta.html\">发布</a>\"了<a href=\"https://openliberty.io/\">Open Liberty</a>\"的23.0.0.12-beta版，该版本支持<a href=\"https://jakarta.ee/specifications/data/\">Jakarta Data</a>\"&nbsp;1.0.0-M1，其中包括：用于基本存储库方法的新&nbsp;BasicRepository接口；在CrudRepository接口中添加insert()和update()方法；新的@Insert、@Update、@Delete和@Save注解。这个版本还提供了一个可配置的静默超时阶段，即当Liberty运行时的关闭时间超过默认的30秒时。这能够支持需要更多时间来完成处理请求的服务。</p><p></p><h4>Helidon</h4><p></p><p></p><p><a href=\"https://helidon.io/\">Helidon</a>\"&nbsp;4.0.1，即<a href=\"https://github.com/helidon-io/helidon/releases/tag/4.0.1\">第一个维护版本</a>\"，提供了值得关注的变更，比如，支持Helidon Web服务器组件的<a href=\"https://www.haproxy.com/blog/use-the-proxy-protocol-to-preserve-a-clients-ip-address\">代理协议</a>\"；&nbsp;WebServer接口的性能改进；在&nbsp;CrossOriginConfig.Builder类中定义的enabled()方法现在返回Optional而不是boolean以解决CORS问题。关于此版本的更多细节可以在<a href=\"https://github.com/helidon-io/helidon/blob/4.0.1/CHANGELOG.md\">变更日志</a>\"中找到。</p><p>&nbsp;</p><p>同样，Helidon 3.2.4的<a href=\"https://github.com/helidon-io/helidon/releases/tag/3.2.4\">发布</a>\"提供了依赖项升级和一些值得注意的变化，例如，用于延迟OCI Vault配置的新类的集合；将opentracing相关的类和接口迁移到Helidon Tracing API；正确处理请求URL的IPv6地址的解析。关于这个版本的更多细节可以在<a href=\"https://github.com/helidon-io/helidon/blob/3.2.4/CHANGELOG.md\">变更日志</a>\"中找到。</p><p></p><h4>Hibernate</h4><p></p><p></p><p><a href=\"https://hibernate.org/reactive/\">Hibernate Reactive</a>\"&nbsp;2.2.0.Final版本<a href=\"https://in.relation.to/2023/11/28/hibernate-reactive-2_2_Final/\">发布</a>\"，它兼容Hibernate ORM 6.4.0.Final and Vert.x SQL driver 4.5.0。Red Hat还提供了2.2.1.Final和2.0.7.Final版本，它们分别与<a href=\"https://hibernate.org/orm/\">Hibernate ORM</a>\"的6.3.2.Final and 6.2.13.Final版本兼容。关于此版本的更多细节可以在<a href=\"https://github.com/hibernate/hibernate-reactive/releases/tag/2.2.0\">发布说明</a>\"中找到。</p><p>&nbsp;</p><p>Hibernate Search 7.1.0的<a href=\"https://in.relation.to/2023/11/30/hibernate-search-7-1-0-Alpha1/\">第一个alpha版本</a>\"提供了一个孵化特性，即允许在<a href=\"https://lucene.apache.org/\">Apache Lucene</a>\"后端进行矢量搜索，并提供了搜索二进制或文本数据的工具。此外，在Spring boot 3.2中读取嵌套JAR时，Hibernate Search将不再启动失败。关于此版本的更多细节可以在<a href=\"https://hibernate.atlassian.net/browse/HSEARCH-5024?jql=project%3D10061%20AND%20fixVersion%3D32219\">发布说明</a>\"中找到。</p><p></p><h4>Grails基金会</h4><p></p><p></p><p>Grails 5.3.4发布，提供了依赖升级和一些值得注意的变化，比如，为所有主分支启用GitHub&nbsp;<a href=\"https://codeql.github.com/\">CodeQL</a>\"；添加了一个SnakeYAML物料清单（BOM）来覆盖SpringBoot BOM；对Javadoc的清理，包括在Javadoc中转义特殊字符、重构代码、定义显式类型和删除不必要的变量使用。关于此版本的更多细节可以在<a href=\"https://github.com/grails/grails-core/releases/tag/v5.3.4\">发布说明</a>\"中找到。</p><p></p><h4>Apache软件基金会</h4><p></p><p></p><p><a href=\"https://groovy-lang.org/\">Apache Groovy</a>\"&nbsp;5.0.0的<a href=\"https://www.mail-archive.com/announce@apache.org/msg08717.html\">第三个alpha版本</a>\"提供了缺陷修复、依赖升级和功能改进，例如，支持JDK 22；实现了在groovyc命令行中进行库编译器时缺失的特性；还有一个针对数组类型的新indexOf(element)扩展方法。关于此版本的更多细节可以在<a href=\"https://issues.apache.org/jira/secure/ReleaseNote.jspa?projectId=12318123&amp;version=12353636\">发布说明</a>\"中找到。</p><p>&nbsp;</p><p>同样，Apache Groovy 4.0.16的<a href=\"https://www.mail-archive.com/announce@apache.org/msg08716.html\">发布</a>\"也提供了缺陷修复、依赖升级和功能改进，例如，对JDK 22的支持；在DefaultGroovyStaticMethods类中定义一个新的allThreads()方法，以补充Java Thread类中定义的现有currentThread()方法。关于此版本的更多细节可以在<a href=\"https://issues.apache.org/jira/secure/ReleaseNote.jspa?projectId=12318123&amp;version=12353637\">发布说明</a>\"中找到。</p><p>&nbsp;</p><p>为了与Quarkus保持一致，Camel Quarkus 3.6.0版本<a href=\"https://camel.apache.org/blog/2023/11/camel-quarkus-release-3.6.0/\">发布</a>\"，解决了以下问题：在执行QuartzQuarkusSchedulerAutowiredWithSchedulerBeanTest类的时候，出现间歇性的AssertionFailedError；在使用容器的测试中，清除硬编码对主机的使用。关于此版本的更多细节可以在<a href=\"https://camel.apache.org/releases/q-3.6.0/\">发布说明</a>\"中找到。</p><p>&nbsp;</p><p><a href=\"https://maven.apache.org/\">Apache Maven</a>\"&nbsp;3.9.6版本提供了依赖项升级和排除插件验证的功能。关于此版本的更多细节可以在<a href=\"https://github.com/apache/maven/releases/tag/maven-3.9.6\">发布说明</a>\"中找到。</p><p></p><h4>JDKMon</h4><p></p><p></p><p>监视和更新已安装jdk的工具<a href=\"https://github.com/HanSolo/JDKMon\">JDKMon</a>\"发布了<a href=\"https://github.com/HanSolo/JDKMon/releases/tag/21.0.0\">21.0.0</a>\"版本。这个工具由Azul的首席工程师<a href=\"https://de.linkedin.com/in/gerritgrunwald\">Gerrit Grunwald</a>\"创建，这个新版本通过将所有依赖项移动到最新的LTS版本，完全支持JDK 21。</p><p></p><h4>PrimeFaces</h4><p></p><p></p><p>PrimeFaces的12.0.7、11.0.13、10.0.20和8.0.25版本发布，特性包括：升级<a href=\"https://github.com/stleary/JSON-java/blob/master/README.md\">JSON in Java</a>\"到20231013，以解决<a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-5072\">CVE-2023-5072</a>\"漏洞，该漏洞允许攻击者利用JSON解析器中的缺陷，例如，中等大小的字符串输入可能导致无限量的内存使用并导致拒绝服务。关于这些版本的更多细节可以在<a href=\"https://github.com/primefaces/primefaces/issues?q=is%3Aissue+label%3A12.0.7+is%3Aclosed\">12.0.7版本</a>\"、<a href=\"https://github.com/primefaces/primefaces/issues?q=is%3Aissue+label%3A11.0.13+is%3Aclosed\">11.0.13版本</a>\"、<a href=\"https://github.com/primefaces/primefaces/issues?q=is%3Aissue+is%3Aclosed+label%3A10.0.20\">10.0.20版本</a>\"和<a href=\"https://github.com/primefaces/primefaces/issues?q=is%3Aissue+is%3Aclosed+label%3A8.0.25\">8.0.25版本</a>\"的发布说明中找到。</p><p></p><h4>Jupyter for Java</h4><p></p><p></p><p><a href=\"https://github.com/jupyter-java\">Jupyter for Java</a>\"，这是一个新的GitHub组织，旨在帮助开发人员发现在Jupyter notebooks中使用Java的各种方法。该项目由Red Hat的杰出工程师<a href=\"https://www.linkedin.com/in/maxrydahlandersen/\">Max Rydahl Andersen</a>\"创建，目前包含五个提供资源和样例的仓库。</p><p></p><h4>Gradle</h4><p></p><p></p><p><a href=\"https://gradle.org/\">Gradle</a>\"&nbsp;8.5.0<a href=\"https://github.com/gradle/gradle/releases/tag/v8.5.0\">发布</a>\"，提供了以下新特性：完全支持在JDK 21上编译、测试和运行；<a href=\"https://docs.gradle.org/8.5-rc-1/userguide/kotlin_dsl.html\">Kotlin DSL</a>\"的改进，包括在预编译Kotlin脚本插件中<a href=\"https://docs.gradle.org/8.5-rc-1/release-notes.html#faster-first-use\">更快的首次使用</a>\"以及<a href=\"https://docs.gradle.org/8.5-rc-1/release-notes.html#catalog-precompiled\">对版本目录的支持</a>\"；改进了错误和告警的报告。关于此版本的更多细节可以在<a href=\"https://docs.gradle.org/8.5/release-notes.html\">发布说明</a>\"中找到。</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/12/java-news-roundup-nov27-2023/\">Java News Roundup: JDK 22, Spring CVEs, Liberica JDK, JDKMon 21, Jupyter for Java, Gradle 8.5</a>\"</p>",
    "publish_time": "2023-12-21 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]