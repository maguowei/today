[
  {
    "title": "领英通过实施消息客户端 SDK，将开发效率提高了10倍",
    "url": "https://www.infoq.cn/article/31oV8dKq8heHUsRQPGfB",
    "summary": "<p>领英在近期发布的文章《<a href=\"https://engineering.linkedin.com/blog/2023/unifying-messaging-experiences-across-linkedin\">如何通过消息客户端 SDK 大幅提升开发效率</a>\"》中称，通过使用 SDK 抽象数千行代码至共享库，他们得以削减跨多平台应用的代码维护成本。在一个用例场景下，新 SDK 在构建全新领英体验时可以节省四十余名开发者数周的劳动。</p><p>&nbsp;</p><p>领英的高级员工工程师 <a href=\"https://www.linkedin.com/in/micurs/\">Michele Ursino</a>\" 和领英的工程负责人 <a href=\"https://www.linkedin.com/in/joe-xue-66782012/\">Joe Xue</a>\" 对 SDK 是如何提高生产力的解释如下：</p><p>&nbsp;</p><p></p><blockquote>我们的 Messenger SDK 通过将数千行代码抽象为共享库，减少了跨多个应用程序的代码维护成本，极大地提升了开发人员的工作效率。在部分情况下，我们实现了跨十倍的代码数量减少，从三千多行减至几百行。其结果是，开发人员现在可以在几周内创建新的信息体验，而非原先的几月或几季度。</blockquote><p></p><p>&nbsp;</p><p>Ursino 和 Xue 称，通过创建一个跨领英消息体验的共用前端平台，他们已经证明了这种可被他人复制、用于自己核心功能的模式：</p><p>&nbsp;</p><p></p><blockquote>同领英一样，拥有多个大型应用的组织应重新考虑应用构建的方式。与其将应用当作独立个体，组织可以在可重复使用的平台库之上，建立轻薄的应用层，按需暴露各类技术支柱的高级能力乃至用户界面。</blockquote><p></p><p>&nbsp;</p><p>领英<a href=\"https://engineering.linkedin.com/blog/2020/bootstrapping-our-new-messaging-platform\">在2020年年中完成了其消息体验的重构</a>\"。不过，据 Ursino 和 Xue 说明，“在运行领英产品的设备上实现完整消息可靠性和功能性是一项复杂的任务，不仅工作量繁重且对细节要求颇高。”为确保最大限度的一致性和可靠性，领英对其消息传递平台进行了扩展，涵盖了客户侧设备和前端 API 中的消息数据管理。领英的消息传递团队将所有消息传递功能打包为一个全功能的数据层 SDK，用于解决客户端应用中消息传递数据的管理复杂性问题。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/78/7802e504274cb018bc45afd42713e818.png\" /></p><p></p><p>来源：<a href=\"https://engineering.linkedin.com/blog/2023/unifying-messaging-experiences-across-linkedin\">https://engineering.linkedin.com/blog/2023/unifying-messaging-experiences-across-linkedin</a>\"</p><p>&nbsp;</p><p>领英将新的 SDK 分为两类库：用于应用程序 API 中消息整合的 API 库（“messenger-api”），以及用于表示设备本地信箱的客户库（messenger-data）。</p><p>&nbsp;</p><p>其中，API 库有三项功能：桥接客户与后端消息传递平台基础设施间&nbsp;<a href=\"https://graphql.org/\">GraphQL</a>\" 请求、允许主机 API 自定义消息传递 API 的行为，以及允许其他系统使用 GraphQL 对消息传递数据进行装饰。该 API 库实现了对外部系统消息传递数据的错误检查，并暴露了一个 GraphQL 模式，其中包含每个平台中客户 SDK 库用于获取信息的查询。这种架构方式允许主机 API 代码对每个 API 请求生命周期中，后端消息平台传至前端的消息数据进行自定义转换。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/44/44c3a10e70b6a649223d6950d32b8e95.png\" /></p><p></p><p>来源：<a href=\"https://engineering.linkedin.com/blog/2023/unifying-messaging-experiences-across-linkedin\">https://engineering.linkedin.com/blog/2023/unifying-messaging-experiences-across-linkedin</a>\"</p><p>&nbsp;</p><p>客户库为消息传递实现了一个以<a href=\"https://en.wikipedia.org/wiki/Event-driven_architecture\">事件为驱动</a>\"的数据层（EDDL），为客户设备中的信箱数据提供了实时的表示，且与后端中实际的信箱数据进行同步。该 API 库意在保障最大化消息传递可靠性，允许应用程序开发者轻松访问信箱数据。此外，其所采用的反应式方法也支持了设备中对话和消息的快速渲染和屏幕刷新，即时地将任何数据变化通知主机应用程序代码，从而允许必要的用户界面刷新。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b9/b9094091931d15f740411f8229c375ed.png\" /></p><p></p><p>来源：<a href=\"https://engineering.linkedin.com/blog/2023/unifying-messaging-experiences-across-linkedin\">https://engineering.linkedin.com/blog/2023/unifying-messaging-experiences-across-linkedin</a>\"</p><p>&nbsp;</p><p>领英已经将其旗舰应用程序的消息传递功能迁移至 Messenger SDK，为全客户平台提供一致且可靠的消息传递体验。该 SDK 带来了跨平台的功能平等性以及现代化的代码库，提高了稳定性和可靠性，也提升了开发人员的生产力。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/03/linkedin-messenger-sdk/\">LinkedIn Improves Development Productivity by 10x Implementing a Messaging Client-Side SDK</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/87fXytBSTUiUDmTkHfcO\">领导力匠艺：像开发人员打造代码那样打造你的领导力</a>\"</p><p><a href=\"https://www.infoq.cn/article/7Ps0qyHfQhp59g7YrEvZ\">当你的技术栈不能满足每个人需求时，下一步是什么呢？</a>\"</p><p><a href=\"https://www.infoq.cn/article/FAxivpNAGHAIyYMupEJG\">提高软件质量：如何处理数据发现更多 Bug</a>\"</p><p></p>",
    "publish_time": "2023-04-25 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": ".NET无侵入自动化探针原理和主流实现",
    "url": "https://www.infoq.cn/article/fY1dWBrmj8V2BeP8eOGf",
    "summary": "<p></p><h2>前言</h2><p></p><p></p><p>最近，我在微信公众号和博客园分享了一篇关于 .NET 微服务系统迁移至.NET 6.0 的故事 的文章，引起了许多读者的关注。其中，许多人对基于 OpenTelemetry .NET 的观测指标和无侵入自动化探针颇感兴趣。事实上，我已计划抽出时间，与大家分享这方面的内容。</p><p></p><p>巧合的是，在二月末，我收到了来自 OpenTelemetry 中国社区的蒋志伟大佬的邀请，希望我能就 .NET 实现无侵入自动化探针的方法进行分享。因为关于 Java 等其他语言的自动化探针实现原理已有大量文章，但.NET 领域却鲜有介绍，而社区对此也很感兴趣。</p><p></p><p>然而，因为 .NET 无侵入自动化探针的实现原理相当复杂，理解和完全掌握原理有很大差别。为确保文章质量和严谨性，撰写过程耗时较长，因此现在才能与大家见面。</p><p></p><p></p><h2>APM 探针</h2><p></p><p></p><p>当我们提到 .NET 的 APM 时，许多人首先会想到 SkyWalking 。这是因为 SkyAPM-dotnet 是第一个支持.NET 应用程序的开源非商业 APM 探针实现，目前很多 .NET 项目都采用了它。在此，我们要特别感谢刘浩杨等社区领袖的辛勤付出。</p><p></p><p>除了 SkyWalking 之外， Datadog APM 也是一款功能强大的商业应用性能监测工具，旨在帮助开发人员跟踪、优化并排查应用程序中的性能问题。Datadog APM 适用于多种编程语言和框架，包括 .NET 。通过使用 Datadog 丰富的功能和可视化仪表板，我们能够轻松地识别并改进性能瓶颈。</p><p></p><p>另一个比较知名的选择是 OpenTelemetry-dotnet-contrib ，这是 CNCF-OpenTelemetry 的 .NET 应用程序 APM 探针实现。虽然它的推出时间比 SkyAPM 和 Datadog APM 稍晚，但由于其开放的标准和开源的实现，许多 .NET 项目也选择使用它。</p><p></p><p>关于 APM 探针的实现原理，我们主要分为两类来介绍：平台相关指标和组件相关指标。接下来，我们将讨论如何采集这两类指标。</p><p></p><p></p><h3>平台相关指标采集</h3><p></p><p></p><p>那么 APM 探针都是如何采集 .NET 平台相关指标呢？其实采集这些指标在 .NET 上是非常简单的，因为.NET 提供了相关的 API 接口，我们可以直接获得这些指标，这里指的平台指标是如 CPU 占用率、线程数量、GC 次数等指标。</p><p></p><p>比如在 SkyAPM-dotne t 项目中，我们可以查看 SkyApm.Core 项目中的 Common 文件夹，文件夹中就有诸如里面有 CPU 指标、GC 指标等平台相关指标采集实现帮助类。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/25/2533bd4b8a4beb24015b93f7be35b5a8.png\" /></p><p>同样，在 OpenTelemetry-dotnet-contrib 项目中，我们可以在 Process 和 Runtime 文件夹中，查看进程和运行时等平台相关指标采集的实现。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/c3/c339111e7d609272c13c661b9e939e64.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/fd/fd832f0804a47cd7179b567760d2bf80.png\" /></p><p></p><p>这些都是简单的 API 调用，有兴趣的同学可以自行查看代码，本文就不再赘述这些内容。</p><p></p><p></p><h3>组件相关指标采集</h3><p></p><p></p><p>除了平台相关指标采集，还有组件相关的指标，这里所指的组件相关指标拿 ASP.NET Core 应用程序举例，我们接口秒并发是多少、一个请求执行了多久，在这个请求执行的时候访问了哪些中间件 ( Redis 、MySql 、Http 调用、RPC 等等)，访问中间件时传递的参数 (Redis 命令、Sql 语句、请求响应体等等) 是什么，访问中间件花费了多少时间。</p><p></p><p>在 SkyAPM-dotnet 项目中，我们可以直接在src目录找到这些组件相关指标采集的实现代码。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e0/e0f871cf738a4c1209d944daaa9dc7a7.png\" /></p><p></p><p>同样在 OpenTelemetry-dotnet-contrib 项目中，我们也可以在src目录找到这些组件相关指标采集代码。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/39/390e9df04f7e30804e9283941e49d0ff.png\" /></p><p></p><p>如果看过这两个 APM 探针实现的朋友应该都知道，组件指标采集是非常依赖DiagnosticSource技术。.NET 官方社区一直推荐的的方式是组件开发者自己在组件的关键路径进行埋点，使用DiagnosticSource的方式将事件传播出去，然后其它监测软件工具可以订阅DiagnosticListener来获取组件运行状态。</p><p></p><p>就拿 ASP.NET Core 来举例，组件源码中有<a href=\"https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Hosting/src/Internal/HostingApplicationDiagnostics.cs\">HostingApplicationDiagnostics.cs</a>\"这样一个类，这个类中定义了 Hosting 在请求处理过程中的几个事件。</p><p></p><p><code lang=\"text\">internal const string ActivityName = \"Microsoft.AspNetCore.Hosting.HttpRequestIn\";\nprivate const string ActivityStartKey = ActivityName + \".Start\";\nprivate const string ActivityStopKey = ActivityName + \".Stop\";</code></p><p></p><p>当 Hosting 开始处理请求时，会检测当前是否有监听者监听这些事件，如果有的话就会写入事件，事件也会携带当前的一些上下文信息，代码如下所示：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e0/e05b086b764f390b9c9e15ca3a202a25.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/4f/4fe0bc2a1613cd885662d5218647baa1.png\" /></p><p></p><p>以 SkyAPM-dotnet 举例，有对应的HostingTracingDiagnosticProcessor.cs监听事件，然后获取上下文信息记录 APM 埋点信息，代码如下所示：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/4f/4f127a34233f51eefe7def7240ce5e7b.png\" /></p><p></p><p>这种方式的优点有：</p><p></p><p>高效和高性能：DiagnosticSource 是 .NET 平台自带的框架，使用它硬编码可以享受到编译器和 JIT 相关优化可以避免一些性能开销。组件开发者可以控制事件传递的频率和内容，以达到最佳的性能和资源利用率。</p><p></p><p>灵活：通过使用 DiagnosticSource，组件开发者可以灵活地定义自己的事件模型，并按需发布事件。这意味着可以轻松地定制自己的监测需求，而不必担心过多的日志数据产生过大的开销。</p><p></p><p>可扩展性：使用DiagnosticSource可以让组件的监测需求随着时间的推移而演变，而不必担心日志系统的限制。开发者可以根据自己的需要添加新的事件类型，以适应不断变化的监测需求。</p><p></p><p>易用性：DiagnosticSource的 API 简单易用，订阅事件数据也很容易。这使得使用它进行组件监测变得非常容易，并且可以快速地集成到现有的监测系统中。</p><p></p><p>可移植性：DiagnosticSource可以在多个平台上运行，包括 Windows、Linux 和 macOS 等。这意味着可以使用相同的事件模型来监测不同的应用程序和服务，从而简化了监测系统的设计和管理。</p><p></p><p>不过这种方式的缺点也很明显，就是 必须由组件开发者显式的添加事件代码，探针的开发者也因此束手束脚，这就导致一些没有进行手动埋点的三方组件都无法添加事件监听，所以现阶段 SkyAPM-dotnet 支持的第三方组件还不是很丰富。</p><p></p><p>那么其实只要解决 如何为没有进行手动埋点的组件库加入埋点 就能解决 SkyAPM-dotnet 支持第三方组件多样性的问题。</p><p></p><p></p><h2>.NET 方法注入</h2><p></p><p></p><p>从上一节我们可以知道，目前制约 APM 支持组件不够丰富的原因之一就是很多组件库都没有进行可观测性的适配，没有在关键路径进行埋点。</p><p></p><p>那么要解决这个问题其实很简单，我们只需要修改组件库关键路径代码给加上一些埋点就可以了，那应该如何给这些第三方库的代码加点料呢？聊到这个问题我们需要知道一个 .NET 程序是怎么从源代码变得可以运行的。</p><p></p><p>通常情况下，一个 .NET 程序从源码到运行会经过两次编译（忽略 ReadyToRun 、NativeAOT 、分层编译等情况）。如下图所示：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/6d/6d0184b4e6eddc51c4db549f31310f5e.png\" /></p><p></p><p>第一次是使用编译器将 C#/F#/VB/Python/PHP 源码使用 Roslyn 等对应语言编译器编译成 CIL（Common Intermediate Language，公共中间语言）。第二次使用 RuyJit 编译器将 CIL 编译为对应平台的机器码，以 C# 语言举了个例子，如下图所示：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e1/e15ab70b5a4de52805515feb85eac64f.png\" /></p><p>方法注入也一般是发生在这两次编译前后，一个是在 Roslyn 静态编译期间进行方法注入，期间目标 .NET 程序并没有运行，所以这种 .NET 程序未运行的方法注入我们叫它 编译时静态注入。而在 RuyJit 期间 .NET 程序已经在运行，这时进行方法注入我们叫它 运行时动态注入。下表中列出了比较常见方法注入方式：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/fc/fcdae00fcf221ae86b8f5e2334744ed6.png\" /></p><p></p><p>综合各种优缺点现阶段 APM 使用最多的是 CLR Profile API 的方式进行方法注入，比如 Azure AppInsights、DataDog、Elastic 等.NET 探针都是使用这种方式。</p><p></p><p></p><h2>基于 CLR Profile API 实现 APM 探针原理</h2><p></p><p></p><p></p><h3>CLR Profile API 简介</h3><p></p><p></p><p>在下面的章节中和大家聊一聊基于 CLR Profile API 是如何实现方法注入，以及 CLR Profile API 是如何使用的。</p><p></p><p>聊到 CLR 探查器，我们首先就得知道 CLR 是什么，CLR（Common Language Runtime，公共语言运行时），可以理解为是托管运行 .NET 程序的平台，它提供了基础类库、线程、JIT 、GC 等语言运行的环境（如下图所示），它功能和 Java 的 JVM 有相似之处，但定位有所不同。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/0e/0e1c57f73e03f8a2b9c6dfb49621cdab.png\" /></p><p></p><p>.NET 程序、CLR 和操作系统的关系如下图所示：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/95/957a2d18cd0f221fcbdb7c8748990ca3.png\" /></p><p></p><p>那么 CLR 探查器是什么东西呢？根据 官方文档 的描述，CLR 探查器和相关 API 的支持从 .NET Framework 1.0 就开始提供，它是一个工具，可以使用它来监视另一个 .NET 应用程序的执行情况，它也是一个 ( .dll ) 动态链接库，CLR 在启动运行时加载探查器，CLR 会将一些事件发送给探查器，另外探查器也可以通过 Profile API 向 CLR 发送命令和获取运行时信息。下方是探查器和 CLR 工作的简单交互图：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/6e/6e957b266dc2fe9597602c13f55e3ec0.png\" /></p><p></p><p>ICorProfilerCallback提供的事件非常多，常用的主要是下方提到这几类：</p><p></p><p>CLR 启动和关闭事件应用程序域创建和关闭事件程序集加载和卸载事件模块加载和卸载事件COM vtable 创建和析构事件实时 (JIT) 编译和代码间距调整事件类加载和卸载事件线程创建和析构事件函数入口和退出事件异常托管和非托管代码执行之间的转换不同运行时上下文之间的转换有关运行时挂起的信息有关运行时内存堆和垃圾回收活动的信息 ICorProfilerInfo 提供了很多查询和命令的接口，主要是下方提到的这几类：方法信息接口类型信息接口模块信息接口线程信息接口CLR 版本信息接口Callback 事件设置接口函数 Hook 接口还有 JIT 相关的接口 通过 CLR Profile API 提供的这些事件和信息查询和命令接口，我们就可以使用它来实现一个无需改动原有代码的 .NET 探针。</p><p></p><p></p><h3>自动化探针执行过程</h3><p></p><p></p><p>APM 使用 .NET Profiler API 对应用程序进行代码插桩方法注入，以监控方法调用和性能指标从而实现自动化探针。下面详细介绍这一过程：</p><p></p><p>Profiler 注册：在启动应用程序时，.NET Tracer 作为一个分析器（profiler）向 CLR（Common Language Runtime）注册。这样可以让它在整个应用程序生命周期内监听和操纵执行流程。JIT 编译拦截：当方法被即时编译（JIT）时，Profiler API 发送事件通知。.NET Tracer 捕获这些事件，如 JITCompilationStarted，从而有机会在方法被编译之前修改其 IL（Intermediate Language）代码。代码修改插桩：通过操纵 IL 代码，.NET Tracer 在关键方法的入口和退出点插入跟踪逻辑。这种操作对原始应用程序是透明的，不需要修改源代码。跟踪逻辑通常包括记录方法调用数据、计时、捕获异常等。上下文传播：为了连接跨服务或异步调用的请求链，.NET Tracer 会将 Trace ID 和 Span ID 在分布式系统中进行传递。这使得在复杂的微服务架构中追踪请求变得更加容易。数据收集：插桩后的代码在运行期间会产生跟踪数据，包括方法调用时间、执行路径、异常信息等。这些数据会被封装成跟踪和跨度（spans），并且通过 APM Agent 发送到 APM 平台进行后续分析和可视化。</p><p></p><p>通过使用 .NET Profiler API 对应用程序进行方法注入插桩，APM 可以实现对 .NET 程序的详细性能监控，帮助开发者和运维人员发现并解决潜在问题。</p><p></p><p>第一步，向 CLR 注册分析器的步骤是很简单的，CLR 要求分析器需要实现 COM 组件接口标准，微软的 COM（Component Object Model）接口是一种跨编程语言的二进制接口，用于实现在操作系统中不同软件组件之间的通信和互操作。通过 COM 接口，组件可以在运行时动态地创建对象、调用方法和访问属性，实现模块化和封装。COM 接口使得开发人员能够以独立、可复用的方式构建软件应用，同时还有助于降低维护成本和提高开发效率。COM 一般需要实现以下接口：</p><p></p><p>接口（Interfaces）：COM 组件使用接口提供一套预定义的函数，这样其他组件就可以调用这些函数。每个接口都有一个唯一的接口标识（IID）。对象（Objects）：COM 对象是实现了一个或多个接口的具体实例。客户端代码通过对象暴露的接口与其进行交互。引用计数（Reference Counting）：COM 使用引用计数管理对象的生命周期。当一个客户端获取到对象的接口指针时，对象的引用计数加一；当客户端不再需要该接口时，引用计数减一。当引用计数减至零时，COM 对象会被销毁。查询接口（QueryInterface）：客户端可以通过 QueryInterface 函数获取 COM 对象所实现的特定接口。这个函数接收一个请求的接口 IID，并返回包含该接口指针的 HRESULT。类工厂（Class Factories）：为了创建对象实例，COM 使用类工厂。类工厂是实现了 IClassFactory 接口的对象，允许客户端创建新的对象实例。</p><p></p><p>比如 OpenTelemetry 中的class_factory.cpp就是声明了 COM 组件，其中包括了查询接口、引用计数以及创建实例对象等功能。</p><p></p><p>-230411084706645.png)</p><p></p><p>然后我们只需要设置三个环境变量，如下所示：</p><p></p><p>COR_ENABLE_PROFILING：将其设置为1，表示启用 CLR 分析器。COR_PROFILER: 设置分析器的 COM 组件 ID，使 CLR 能正确的加载分析器。COR_PROFILER_PATH_32/64: 设置分析器的路径，32 位或者是 64 位应用程序。</p><p></p><p>通过以上设置，CLR 就可以在启动时通过 COM 组件来调用分析器实现的函数，此时也代表着分析器加载完成。在 OpenTelemetry 和 data-dog 等 APM 中都有这样的设置。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/16/16f9560d632247432e7ee8766ee4ac74.png\" /></p><p>-230411085517744.png)</p><p></p><p>那后面的 JIT 编译拦截以及其它功能如何实现呢？我们举一个现实存在的例子，如果我们需要跟踪每一次 Reids 操作的时间和执行命令的内容，那么我们在应该修改StackExchange.Redis ExecuteAsyncImpl方法，从message中读取执行命令的内容并记录整个方法耗时。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e0/e04114de8a1d6db28fd77f6770404d72.png\" /></p><p></p><p>那么 APM 如何实现对Redis ExecuteAsyncImpl进行注入的？可以打开 dd-trace-dotnet 仓库也可以打开 opentelemetry-dotnet-instrumentation 仓库，这两者的方法注入实现原理都是一样的，只是代码实现上有一些细微的差别。这里我们还是以 dd-trace-dotnet 仓库代码为例。</p><p></p><p>打开tracer/src/Datadog.Trace/ClrProfiler/AutoInstrumentation目录，里面所有的源码都是通过方法注入的方式来实现 APM 埋点，有非常多的组件埋点的实现，比如 MQ 、Redis 、 CosmosDb 、Couchbase 等等。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/c9/c96e64f436dd3462a280f35f53467bbe.png\" /></p><p>打开 Redis 的文件夹，可以很容易找到 Redis 进行方法注入的源码，这相当于是一个 AOP 切面实现方法：</p><p><code lang=\"text\">[InstrumentMethod(\n        AssemblyName = \"StackExchange.Redis\",\n        TypeName = \"StackExchange.Redis.ConnectionMultiplexer\",\n        MethodName = \"ExecuteAsyncImpl\",\n        ReturnTypeName = \"System.Threading.Tasks.Task`1\",\n        ParameterTypeNames = new[] { \"StackExchange.Redis.Message\", \"StackExchange.Redis.ResultProcessor`1[!!0]\", ClrNames.Object, \"StackExchange.Redis.ServerEndPoint\" },\n        MinimumVersion = \"1.0.0\",\n        MaximumVersion = \"2.*.*\",\n        IntegrationName = StackExchangeRedisHelper.IntegrationName)]\n    [InstrumentMethod(\n        AssemblyName = \"StackExchange.Redis.StrongName\",\n        TypeName = \"StackExchange.Redis.ConnectionMultiplexer\",\n        MethodName = \"ExecuteAsyncImpl\",\n        ReturnTypeName = \"System.Threading.Tasks.Task`1\",\n        ParameterTypeNames = new[] { \"StackExchange.Redis.Message\", \"StackExchange.Redis.ResultProcessor`1[!!0]\", ClrNames.Object, \"StackExchange.Redis.ServerEndPoint\" },\n        MinimumVersion = \"1.0.0\",\n        MaximumVersion = \"2.*.*\",\n        IntegrationName = StackExchangeRedisHelper.IntegrationName)]\n    [Browsable(false)]\n    [EditorBrowsable(EditorBrowsableState.Never)]\n    public class ConnectionMultiplexerExecuteAsyncImplIntegration\n    {\n        /// </code></p><code lang=\"text\">\n        /// OnMethodBegin callback\n        /// </code><code lang=\"text\">\n        /// Type of the target\n        /// Type of the message\n        /// Type of the result processor\n        /// Type of the server end point\n        /// Instance value, aka `this` of the instrumented method.\n        /// Message instance\n        /// Result processor instance\n        /// State instance\n        /// Server endpoint instance\n        /// Calltarget state value\n        internal static CallTargetState OnMethodBegin(TTarget instance, TMessage message, TProcessor resultProcessor, object state, TServerEndPoint serverEndPoint)\n            where TTarget : IConnectionMultiplexer\n            where TMessage : IMessageData\n        {\n            string rawCommand = message.CommandAndKey ?? \"COMMAND\";\n            StackExchangeRedisHelper.HostAndPort hostAndPort = StackExchangeRedisHelper.GetHostAndPort(instance.Configuration);\n\n            Scope scope = RedisHelper.CreateScope(Tracer.Instance, StackExchangeRedisHelper.IntegrationId, StackExchangeRedisHelper.IntegrationName, hostAndPort.Host, hostAndPort.Port, rawCommand);\n            if (scope is not null)\n            {\n                return new CallTargetState(scope);\n            }\n\n            return CallTargetState.GetDefault();\n        }\n\n        /// \n        /// OnAsyncMethodEnd callback\n        /// \n        /// Type of the target\n        /// Type of the response, in an async scenario will be T of Task of T\n        /// Instance value, aka `this` of the instrumented method.\n        /// Response instance\n        /// Exception instance in case the original code threw an exception.\n        /// Calltarget state value\n        /// A response value, in an async scenario will be T of Task of T\n        internal static TResponse OnAsyncMethodEnd(TTarget instance, TResponse response, Exception exception, in CallTargetState state)\n        {\n            state.Scope.DisposeWithException(exception);\n            return response;\n        }\n    }</code><p></p><p></p><p>这段代码是一个用于监控和跟踪 StackExchange.Redis 库的 APM（应用性能监控）工具集成。它针对 StackExchange.Redis.ConnectionMultiplexer 类的 ExecuteAsyncImpl 方法进行了注入以收集执行过程中的信息。</p><p></p><p>使用了两个 InstrumentMethod 属性，分别指定 StackExchange.Redis 和 StackExchange.Redis.StrongName 两个程序集。属性包括程序集名称、类型名、方法名、返回类型名等信息以及版本范围和集成名称。ConnectionMultiplexerExecuteAsyncImplIntegration 类定义了 OnMethodBegin 和 OnAsyncMethodEnd 方法。这些方法在目标方法开始和结束时被调用。OnMethodBegin 方法创建一个新的 Tracing Scope，其中包含了与执行的 Redis 命令相关的信息（如 hostname, port, command 等）。OnAsyncMethodEnd 方法在命令执行结束后处理 Scope，在此过程中捕获可能的异常，并返回结果。而这个 CallTargetState state 中其实包含了上下文信息，有 Span Id 和 Trace Id ，就可以将其收集发送到 APM 后端进行处理。</p><p></p><p>但是，仅仅只有声明了一个 AOP 切面类不够，我们还需将这个 AOP 切面类应用到 Redis SDK 原有的方法中，这又是如何做到的呢？那么我们就需要了解一下 CLR Profiler API 实现方法注入的原理了。</p><p></p><p></p><h3>方法注入底层实现原理</h3><p></p><p></p><p>在不考虑 AOT 编译和分层编译特性，一个 .NET 方法一开始的目标地址都会指向 JIT 编译器，当方法开始执行时，先调用 JIT 编译器将 CIL 代码转换为本机代码，然后缓存起来，运行本机代码，后面再次访问这个方法时，都会走缓存以后得本机代码，流程如下所示：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/f2/f2d7f11f40f0fa268a20152cd489648d.png\" /></p><p></p><h4>拦截 JIT 编译</h4><p></p><p></p><p>由于方法一般情况下只会被编译一次，一种方法注入的方案就是在 JIT 编译前替换掉对应方法的 MethodBody ，这个在 CLR Profile API 中提供的一个关键的回调。</p><p></p><p>JITCompilationStarted: 通知探查器，即时编译器已经开始编译方法。 我们只需要订阅这个事件，就可以在方法编译开始时将对应的 MethodBody 修改成我们想要的样子，在里面进行 AOP 埋点即可。在 JITCompilationStarted 事件中重写方法 IL 的流程大致如下：</p><p>捕获JITCompilationStarted事件：当一个方法被即时编译（JIT）时，CLR（Common Language Runtime）会触发JITCompilationStarted事件。通过使用 Profiler API ，分析器可以订阅这个事件并得到一个回调。确定要修改的方法：在收到JITCompilationStarted事件回调时，分析器需要检查目标方法元数据，例如方法名称、参数类型和返回值类型等，来确定是否需要对该方法进行修改。获取方法的原始 IL 代码：如果确定要对目标方法进行修改，分析器需要首先获取该方法的原始 IL 代码。这可以通过使用 Profiler API 提供的GetILFunctionBody方法来实现。分析和修改 IL 代码：接下来，分析器需要解析原始 IL 代码，找到适当的位置以插入新的跟踪逻辑。这通常包括方法的入口点（开始执行时）和退出点（返回或抛出异常）。分析器会生成一段新的 IL 代码，用于记录性能指标、捕获异常等。替换方法的 IL 代码：将新生成的 IL 代码插入到原始 IL 代码中，并使用SetILFunctionBody方法替换目标方法的 IL 代码。这样，在方法被 JIT 编译成本地代码时，新的跟踪逻辑也会被包含进去。继续 JIT 编译：完成 IL 代码重写后，分析器需要通知 CLR 继续 JIT 编译过程。编译后的本地代码将包含插入的跟踪逻辑，并在应用程序运行期间执行。</p><p></p><p>我们来看看源码是如何实现的，打开 dd-trace-dotnet 开源仓库，回退到较早的发布版本，有一个 integrations.json 文件，在 dd-trace-dotnet 编译时会自动生成这个文件，当然也可以手动维护，在这个文件里配置了需要 AOP 切面的程序集名称、类和方法，在分析器启动时，就会加载 json 配置，告诉分析器应该注入那些方法。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/79/79ba3a0a298029e34a4a2db63e719b81.png\" /></p><p></p><p>接下来，我们找到cor_profiler.cpp文件并打开，这是实现 CLR 事件回调的代码，转到关于JITCompilationStarted事件的通知的处理的源码。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/36/3607e687eafc0c64807c18fa73251db4.png\" /></p><p></p><p>由于代码较长，简单的说一下这个函数它做了什么，函数主要用于在 .NET JIT（Just-In-Time）编译过程中执行一系列操作，例如插入启动钩子、修改 IL（中间语言）代码以及替换方法等，以下是它的功能：</p><p></p><p>函数检查 is_attached_ 和 is_safe_to_block 变量，如果不满足条件，则直接返回。使用互斥锁保护模块信息，防止在使用过程中卸载模块。通过给定的 function_id 获取模块 ID 和函数 token。根据模块 ID 查找模块元数据。检查是否已在CallTarget模式下注入加载器。如果符合条件且加载器尚未注入，则在AppDomain中的第一个 JIT 编译方法中插入启动钩子。在最低程度上，必须添加AssemblyResolve事件，以便从磁盘找到Datadog.Trace.ClrProfiler.Managed.dll 及其依赖项，因为它不再被提供为 NuGet 包。在桌面版 IIS 环境下，调用 AddIISPreStartInitFlags() 方法来设置预启动初始化标志。如果未启用CallTarget模式，将对 integrations.json 配置的方法进行插入和替换，并处理插入和替换调用。返回 S_OK 表示成功完成操作。其中有两个关键函数，可以对 .NET 方法进行插入和替换，分别是ProcessInsertionCalls和ProcessReplacementCalls。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/5a/5ad69bad8e1d0434d3d5ad3813f15084.png\" /></p><p></p><p>其中ProcessInsertionCalls用于那些只需要在方法前部插入埋点的场景，假设我们有以下原始 C# 类：</p><p><code lang=\"text\">public class TargetClass\n{\n    public void TargetMethod()\n    {\n        Console.WriteLine(\"This is the original method.\");\n    }\n}</code></p><p></p><p>现在，我们希望在TargetMethod的开头插入一个新的方法调用。让我们创建一个示例方法，并在WrapperClass中定义它： 修改后，插入InsertedMethod调用的TargetMethod将如下所示：</p><p></p><p><code lang=\"text\">public class TargetClass\n{\n    public void TargetMethod()\n    {\n        WrapperClass.InsertedMethod(); // 这是新插入的方法调用\n        Console.WriteLine(\"This is the original method.\");\n    }\n}\n\npublic class WrapperClass\n{\n    public static void InsertedMethod()\n    {\n        Console.WriteLine(\"This is the inserted method.\");\n    }\n}</code></p><p></p><p>请注意，上述示例是为了解释目的而手动修改的，实际上这种修改是通过操作 IL 代码来完成的。在CorProfiler::ProcessInsertionCalls方法中，这些更改是在 IL 指令级别上进行的，不会直接影响源代码。修改方法的 IL 代码.NET 官方提供了一个帮助类 ILRewriter ，ILRewriter 是一个用于操作 C# 程序中方法的中间语言（Intermediate Language，IL）代码的工具类。它会将方法的 IL 代码以链表的形式组织，让我们可以方便的修改 IL 代码，它通常用于以下场景：</p><p></p><p>代码注入：在方法体中插入、删除或修改 IL 指令。代码优化：优化 IL 代码以提高性能。执行 AOP（面向切面编程）：通过动态操纵字节码实现横切关注点（如日志记录、性能度量等）。</p><p></p><p>ILRewriter 类提供了一系列方法用于读取、修改和写回 IL 指令序列。例如，在上述CorProfiler::ProcessInsertionCalls方法中，我们使用 ILRewriter 对象导入 IL 代码，执行所需的更改（如插入新方法调用），然后将修改后的 IL 代码导出并应用到目标方法上。这样可以实现对程序行为的运行时修改，而无需直接更改源代码。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/61/611b28bff9b49f51f00d7d698b39d56b.png\" /></p><p></p><p>另一个ProcessReplacementCalls方法就是将原有的方法调用实现一个 Proxy ，适用于那些需要捕获异常获取方法返回值的场景，这块代码比较复杂，假设我们有以下 C# 代码，其中我们想要替换OriginalMethod()的调用：</p><p></p><p><code lang=\"text\">public class TargetClass\n{\n    public int OriginalMethod(int a, int b)\n    {\n        return a * b;\n    }\n}\n\npublic class CallerClass\n{\n    public void CallerMethod()\n    {\n        TargetClass target = new TargetClass();\n        int result = target.OriginalMethod(3, 4);\n        Console.WriteLine(result);\n    }\n}</code></p><p></p><p>在应用方法调用替换后，CallerMethod()将调用自定义的替换方法WrapperMethod()而不是OriginalMethod()。例如，我们可以使用以下替换方法：</p><p></p><p><code lang=\"text\">public class WrapperClass\n{\n    public static int WrapperMethod(TargetClass instance, int opCode, int mdToken, long moduleVersionId, int a, int b)\n    {\n        Console.WriteLine(\"Method call replaced.\");\n        return instance.OriginalMethod(a, b);\n    }\n}</code></p><p></p><p>经过 IL 修改后，CallerMethod()看起来大致如下：</p><p></p><p><code lang=\"text\">public void CallerMethod()\n{\n    TargetClass target = new TargetClass();\n    int opCode = /* Original CALL or CALLVIRT OpCode */;\n    int mdToken = /* Metadata token for OriginalMethod */;\n    long moduleVersionId = /* Module version ID pointer */;\n\n    // Call the wrapper method instead of the original method\n    int result = WrapperClass.WrapperMethod(target, opCode, mdToken, moduleVersionId, 3, 4);\n\n    Console.WriteLine(result);\n}</code></p><p></p><p>现在CallerMethod()将调用WrapperMethod()，在这个例子中，我们记录了一条替换消息，然后继续调用OriginalMethod()。正如所述，通过捕获JITCompilationStarted事件并对中间语言（IL）进行改写，我们修改方法行为的基本原理。在 .NET Framework 4.5 之前的版本中，这种方式广泛应用于方法改写和植入埋点，从而实现 APM 的自动化探针。然而，此方法也存在以下一些不足之处：</p><p></p><p>不支持动态更新：JITCompilationStarted 在方法被 JIT 编译之前触发，这意味着它只能在初次编译过程中修改 IL。更大的性能影响：由于JITCompilationStarted是一个全局事件，它会在每个需要 JIT 编译的方法被调用时触发。因此，如果在此事件中进行 IL 修改，可能会对整个应用程序产生更大的性能影响。无法控制执行时机：在JITCompilationStarted中重写 IL 时，您不能精确控制何时对某个方法应用更改。某些情况下，运行时可能选择跳过 JIT 编译过程，例如对于 NGEN（Native Image Generator，俗称 AOT 编译）生成的本地映像，此时无法捕获到JITCompilationStarted事件。在多线程环境下，可能会出现竞争条件，导致一些方法执行的是未更新的代码。</p><p></p><p>但是我们也无法再其它时间进行重写，因为 JIT 一般情况下只会编译一次，JIT 已经完成编译以后修改方法 IL 不会再次 JIT ，修改也不会生效。在 .NET Framework 4.5 诞生之前，我们并未拥有更为优美的途径来实现 APM 自动化探测。然而，随着 .NET Framework 4.5 的降临，一条全新的路径终于展现在我们面前。</p><p></p><p></p><h4>重新 JIT 编译</h4><p></p><p></p><p>上文中提到了捕获JITCompilationStarted事件时进行方法重写的种种缺点，于是在.NET 4.5 中，新增了一个名为RequestReJIT的方法，它允许运行时动态地重新编译方法。RequestReJIT主要用于性能分析和诊断工具，在程序运行过程中，可以为指定的方法替换新的即时编译（JIT）代码，以便优化性能或修复 bug。</p><p></p><p>RequestReJIT提供了一种强大的机制，使开发人员能够在不重启应用程序的情况下热更新代码逻辑。这在分析、监视及优化应用程序性能方面非常有用。它可以在程序运行时动态地替换指定方法的 JIT 代码，而无需关心方法是否已经被编译过。RequestReJIT减轻了多线程环境下的竞争风险，并且可以处理 NGEN 映像中的方法。通过提供这个强大的机制，RequestReJIT使得性能分析和诊断工具能够更有效地优化应用程序性能及修复 bug。</p><p></p><p>使用RequestReJIT重写方法 IL 的流程如下：</p><p></p><p>Profiler 初始化：当.NET 应用程序启动时，分析器（profiler）会利用 Profiler API 向 CLR（Common Language Runtime）注册。这允许分析器在整个应用程序生命周期内监听和操纵代码执行流程。确定要修改的方法：分析器需要识别哪些方法需要进行修改。这通常是通过分析方法元数据（如方法名称、参数类型和返回值类型等）来判断的。为目标方法替换 IL 代码：首先，分析器获取目标方法的原始 IL 代码，并在适当位置插入新的跟踪逻辑。接着，使用 SetILFunctionBody 方法将修改后的 IL 代码设置为目标方法的新 IL 代码。请求重新 JIT 编译：使用RequestReJIT方法通知 CLR 重新编译目标方法。此时，CLR 会触发ReJITCompilationStarted事件。捕获ReJITCompilationStarted事件：分析器订阅ReJITCompilationStarted事件，在事件回调中获取到修改后的 IL 代码，订阅结束事件，分析器可以获取本次重新编译是否成功。生成新的本地代码：CLR 会根据修改后的 IL 代码重新进行 JIT 编译，生成新的本地代码。这样，新的 JIT 代码便包含了插入的跟踪逻辑。执行新的本地代码：之后，当目标方法被调用时，将执行新生成的本地代码。这意味着插入的跟踪逻辑会在应用程序运行期间起作用，从而收集性能数据和诊断信息。</p><p></p><p>有了RequestJIT方法，我们可以在任何时间修改方法 IL 然后进行重新编译，无需拦截 JIT 执行事件，在新版的 dd-trace 触发方法注入放到了托管代码中，托管的 C# 代码直接调用非托管的分析器 C++ 代码进行方法注入，所以不需要单独在 json 文件中配置。</p><p></p><p>取而代之的是InstrumentationDefinitions.g.cs文件，在编译时会扫描所有标记了InstrumentMethod特性的方法，然后自动生成这个类。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/63/6352cdfc77c7af0996477a494bdded90.png\" /></p><p></p><p>当分析器启动时，会调用Instrumentation.cs类中Initialize()方法，在这个方法内部就会和分析器通讯，将需要进行方法注入的方法传递给分析器。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/05/053b3a63072f37f248a1e4dd79d376d7.png\" /></p><p></p><p>因为需要和分析器进行通讯，所以需要在分析器中导出可供 C# 代码调用的函数，源码中是interop.cpp导出了 C# 和 C++ 代码互操作的几个函数，同样在 C# 中也要使用P/Invoke技术来定义一个调用类。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ea/eaa48e6a526838534fa2b27a29016560.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/f7/f73b44d12b6b3433c7f28c149144cde8.png\" /></p><p>分析器接受到需要注入的方法信息以后，会将其加入到方法注入的队列中，然后会重写对应方法至下方这种形式：</p><p><code lang=\"text\">/// &lt;摘要&gt;\n/// 用calltarget实现重写目标方法体。（这个函数是由ReJIT处理程序触发的）生成的代码结构：\n///\n/// - 为 TReturn（如果非 void 方法）、CallTargetState、CallTargetReturn/CallTargetReturn 和 Exception 添加局部变量\n/// - 初始化局部变量\n\ntry\n{\n  try\n  {\n    try\n    {\n      - 使用对象实例（对于静态方法则为 null）和原始方法参数调用 BeginMethod\n      - 将结果存储到 CallTargetState 局部变量中\n    }\n    catch 当异常不是 Datadog.Trace.ClrProfiler.CallTarget.CallTargetBubbleUpException 时\n    {\n      - 调用 LogException(Exception)\n    }\n\n    - 执行原始方法指令\n      * 所有RET指令都替换为 LEAVE_S。对于非void方法，堆栈上的值首先存储在 TReturn 局部变量中。\n  }\n  catch (Exception)\n  {\n    - 将异常存储到 Exception 局部变量中\n    - 抛出异常\n  }\n}\nfinally\n{\n  try\n  {\n    - 使用对象实例（对于静态方法则为null），TReturn局部变量（如果非 void 方法），CallTargetState局部变量和 Exception 局部变量调用 EndMethod\n    - 将结果存储到 CallTargetReturn/CallTargetReturn 局部变量中\n    - 如果是非void方法，将 CallTargetReturn.GetReturnValue() 存储到 TReturn 局部变量中\n  }\n  catch 当异常不是 Datadog.Trace.ClrProfiler.CallTarget.CallTargetBubbleUpException 时\n  {\n    - 调用 LogException(Exception)\n  }\n}\n\n- 如果非 void 方法，则加载 TReturn 局部变量\n- RET</code></p><p>/// &lt;摘要&gt;/// 用 calltarget 实现重写目标方法体。（这个函数是由 ReJIT 处理程序触发的）生成的代码结构：////// - 为 TReturn（如果非 void 方法）、CallTargetState、CallTargetReturn/CallTargetReturn 和 Exception 添加局部变量/// - 初始化局部变量</p><p></p><p>try{try{try{- 使用对象实例（对于静态方法则为 null）和原始方法参数调用 BeginMethod- 将结果存储到 CallTargetState 局部变量中}catch 当异常不是 Datadog.Trace.ClrProfiler.CallTarget.CallTargetBubbleUpException 时{- 调用 LogException(Exception)}</p><p></p><p><code lang=\"text\">- 执行原始方法指令\n  * 所有 RET 指令都替换为 LEAVE_S。对于非 void 方法，堆栈上的值首先存储在 TReturn 局部变量中。\n</code></p><p></p><p>最后请求RequestReJIT来重新编译进行 JIT 编译，完成了整个方法的注入。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/90/906ef3a05eb5e5846001f98feb787e15.png\" /></p><p></p><p></p><h2>总结</h2><p></p><p></p><p>以上就是目前 .NET 上 APM 主流的无侵入自动化探针的实现原理的简单科普，总体实现是很复杂的，里面还有诸多细节在本文中并未提到。然而，通过了解这些基本概念和技术原理，希望能为您提供一个较为清晰的认识，让您更好地理解 APM 无侵入式探针是如何在 .NET 平台工作的。</p><p></p><p>如果大家对此话题有兴趣，并希望建立更深入、全面的了解，那么后续可以更新下一篇文章，在接下来的内容中，我们可以实现一个简单版本的 .NET 无侵入探针，并将深入探讨相关实现细节以及如何在实际场景中应用这些方法。</p><p></p><p></p><h2>参考文献</h2><p></p><p></p><p>.NET 探查器文档</p><p></p><p>深入 Java 自动化探针技术的原理和实践</p><p></p><p></p><h1>作者介绍</h1><p></p><p></p><p>李时 (InCerry)，微软最有价值专家，现就职于同程旅行</p><p></p><p>• 欢迎关注 OpenTelemetry 中国官方社区 Github https://github.com/open-telemetry/docs-cn• 加入技术中国官方技术交流群，联系社区发起人微信 nizhanali</p>",
    "publish_time": "2023-04-25 11:00:08",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "面向中小金融机构数字化升级需求，蚂蚁集团 SOFAStack、mPaaS和OceanBase 易用性提升",
    "url": "https://www.infoq.cn/article/e1Hpl35MabWuXxXta35e",
    "summary": "<p>4月25日，2023中国国际金融展(以下简称“金融展”)在北京开幕。展会以“荟萃金融科技成果，展现数字金融力量”为主题，突出科技创新为金融带来变革。<a href=\"http://www.gov.cn/xinwen/2021-03/13/content_5592681.htm\">国家“十四五”规划</a>\"指出：加快推动数字产业化，推进产业数字化转型，实施“上云用数赋智”行动，推动数据赋能全产业链协同转型。明确提出了通过科技创新，加快产业数字化转型的要求。</p><p></p><p>在展会现场，约有上百家参展商展示了行业最新科技成果。其中，<a href=\"https://s.geekbang.org/search/c=0/k=%E8%9A%82%E8%9A%81%E9%9B%86%E5%9B%A2/t=\">蚂蚁集团</a>\"展区展示了十几余项创新科技成果，其中绝大部分技术成果在不断突破技术边界，同时也朝着降低客户使用门槛、开源开放上做突破，让科技产品更易用、更通用，从而帮助金融行业乃至千行百业数字化转型。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/4a/4a67eedd2607e1dc5a21a753b5df3ed4.png\" /></p><p></p><p>&nbsp;</p><p>在蚂蚁集团展区，“数字化三件套”——云原生PaaS平台<a href=\"https://xie.infoq.cn/article/25c5f9a4b46a6f21a90418998\">SOFAStack</a>\"、一站式移动开发平台<a href=\"https://www.infoq.cn/u/mpaas/publish\">mPaaS</a>\"以及原生分布式数据库<a href=\"https://www.infoq.cn/profile/2AF53D640758DA/publish\">OceanBase</a>\"尤其让人关注。这次“数字化三件套”的亮相与以往不同的是，产品升级方向都在往通用、易用方向演变。三件套使得“上云”成本更低、部署方便，运维智能，可动态平衡投入与产出。</p><p></p><p>据悉，SOFAStack是一款云原生的PaaS平台，在过去帮助支付宝以及金融机构的技术架构向云原生分布式升级，实现“丝滑上云”。因其成长在严苛的金融级应用环境下，SOFAStack具备高可用、一致性、可扩展等特性。目前，SOFAStack已经服务于工商银行、四川农信等超百家金融机构，也开始布局从服务金融行业走向更广阔的千行百业。</p><p></p><p>蚂蚁的移动开发平台mPaaS能够为多端的开发、测试、运营等提供云到端的一站式解决方案。目前已经广泛应用于金融、政务、零售、互联网等各行各业，服务客户包括广发银行、新华保险、上海地铁、广东移动等数百家机构及企业。以广东移动为例，广东移动基于mPaaS打造了新的移动端技术中台，可实现一套代码在APP、小程序、H5多端发布使用，开发效率提升近一倍，同时还支持“千人千面”的营销组件能力，满足不同用户的个性化需求。</p><p></p><p>OceanBase4.0版本是一款实现单机分布式一体化架构的数据库产品，最大的特点是既可以像单机数据库一样使用，又拥有分布式数据库无限水平扩展的能力。这意味着，中小金融机构可以通过OceanBase，根据自身业务发展阶段，以更经济的成本用上更好的服务。目前，OceanBase已助力400+客户实现关键业务系统升级，成为通用行业升级首选，其中金融客户与非金融客户各占50%，中小客户占比70%。</p><p></p><p>蚂蚁集团数字科技事业部产品总监马振雄表示：“就像烹调一道菜，OceanBase解决了数据食材的存储管理等问题，SOFAStack是锅勺等炒菜工具，mPaaS则是负责盛在什么样的盘子里端给食客享用。这三件产品都经过了严苛的金融级应用场景的打磨，最终助力企业端出一盘服务客户的‘好菜’。”</p><p></p><p>此外，本次金融展上，蚂蚁集团隐私计算技术产品也入选了五大“金融科技创新成果”。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/77/77058a109fd3128251351b171a65953a.png\" /></p><p></p><p>&nbsp;</p><p>据了解，这一成果可以为金融行业提供安全、高效、定制化的解决方案，助力金融数据安全可信流转。如今，“隐语技术栈”在医疗、电商等领域也有成熟落地应用。据悉，<a href=\"https://s.geekbang.org/search/c=0/k=%E9%9A%90%E8%AF%AD/t=\">隐语</a>\"开发了业内首个把 SQL 做到多方安全计算（MPC）技术上的数据分析系统，在产品易用性上已经有了明显的突破。</p>",
    "publish_time": "2023-04-25 15:02:30",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "如何写出CPU友好的代码，百倍提升性能？",
    "url": "https://www.infoq.cn/article/cab0f9dc43f718cb9c2b1adff",
    "summary": "<p>作者：王再军</p><p></p><p></p><blockquote>不管是什么样的数据，投其所好，才能够优化代码性能。本文将用一个实际用例为大家分享如何通过用心组织的代码来提升性能。</blockquote><p></p><p></p><p></p><h1>一、出现性能差别的代码</h1><p></p><p></p><p>CPU友好的代码与我们平时的那些CRUD操作可能没什么关系。但是用心组织的代码其实也能让性能提升百倍。我们不应该停留在CRUD的漩涡中。今天我给大家带来一个很神奇的现象，文章不长，原理通用，还请大家耐心看完。</p><p></p><p>我们可以先看下面的矩阵计算。大家也可以自己思考一下，如果是你来实现一个矩阵的乘法，你会怎么来做。</p><p></p><p>下图是我给出的A、B、C 三个解题的思路。大家觉得在JVM里面，下面的代码性能会有区别么？如果有的话，哪一个会快一点？如果没有的话，又为什么？</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/a1/a1e4b566255e1850cf59321d7e9b98d3.png\" /></p><p></p><p>下图是benchmark运行的结果（具体的运行代码和结果查看文末附件），是否和你想的一样呢。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/3b/3bbbecf133cb0f28f9d823a5a218db67.png\" /></p><p></p><p>x轴是计算数组的大小，y轴是所消耗的时间。</p><p></p><p>最上两条线是B代码块的结果，中间是A代码块的结果，最下面是C代码块的结果。</p><p></p><p>从运行时间角度看结果是：TC &lt; TA &lt; TB。从性能角度看结果是：PC &gt; PA &gt; PB。</p><p></p><p>大家猜对结果了么，是不是很你想的一样呢？如果不是的话，那就慢慢往下面看。</p><p></p><p></p><h1>二、为什么会有性能差别？</h1><p></p><p></p><p>要想知道这个问题的答案，我们需要知道两个知识点。</p><p></p><p>首先，我们需要知道Java二维数组的存储结构是什么样子的。其次，我们需要知道CPU在计算的时候它L1、L2、L3的缓存机制。</p><p></p><p></p><h2>2.1 知识点</h2><p></p><p></p><p></p><h3>2.1.1 知识点一：Java二维数组的存储结构</h3><p></p><p></p><p>下图便是Java二维数组的一个存储方式示意图，意思是 int[][] array_A = new int[4][3]。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e1/e109d7baaf18b10bf2739dce39fb4cb8.png\" /></p><p></p><p>在一个数组里面存的都是“指针”，指向真实存放数据的地址块。</p><p></p><p>每一行的数据是连续的地址，但是行与行之间的地址就不一定连续了。这一点很重要，后面会用到。</p><p></p><p></p><h3>2.1.2 知识点二：CPU的缓存机制</h3><p></p><p></p><p>CPU架构是会演进的，高低端的参数也不一定相同。但我们毕竟不是CPU的制造者，不必每一个CPU都去细扣，我们只需要理解他的原理，在适当的时候做一些抽象方便理解就可以。</p><p></p><p>下图是我当前Mac的CPU参数，大家需要注意2个东西，L2缓存、L3缓存。这2个参数就是影响我们今天讨论的性能的主要因素。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/4d/4d647bc4659e8226bbe8201cf15099c6.png\" /></p><p></p><p>下面是各个缓存的CPU的访问时间：</p><p></p><p>L1 、L2、L3、主存的大小是逐渐增大，速度是逐渐减小的。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/4d/4dde8226feefcb4adecc7722ab317a02.png\" /></p><p></p><p>下面是现代CPU的一个架构示意图：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/86/86ce4d09d33024a83a496a7f0e8f6dc2.png\" /></p><p></p><p>其中：</p><p>Regs，是寄存器。d-cache，是数据缓存。i-cache，是指令缓存。本次我们并不讨论这个缓存快的影响。</p><p></p><p>CPU的缓存里面还有很多的细节，知道上面的信息就已经足够我们理解今天的问题了。</p><p></p><p></p><h2>2.2&nbsp;性能损失的原因 —&nbsp;缓存命中率</h2><p></p><p></p><p>有了上面的各级别的缓存参考之后，我们可以想象一下，如果把上面的图像换成是我们的二维数组呢。是不是就是下面这样（可能没有那么严谨，但是不妨碍我们理解）。</p><p></p><p>在RAM（主存）的数据是这样的：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/34/349e9ca45531e2bd3354a24f1b0c1653.png\" /></p><p></p><p>L3缓存就是这样的（红色框选中部分）：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/54/547b5c03d40fcd965120dc3baf1d4a46.png\" /></p><p></p><p>L2缓存就是这样的（红色框选中部分）：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/dc/dcb064fa85bf920fd8944b0274539ffe.png\" /></p><p></p><p>有了这个这些层级的缓存之后，CPU在计算的时候就可以不用来回的到速度极慢的RAM（主存）中去找数组的数据了。</p><p></p><p></p><h3>2.2.1 友好的遍历方式</h3><p></p><p></p><p>假设上面的数据的变量名称是A，成员使用a来表述。</p><p></p><p>我们取数据按照从左到右，再从上到下的顺序来进行遍历。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/0d/0d3a6b716e50faaf27b98fd9aefad6a6.png\" /></p><p></p><p>对于L2缓存来说：</p><p></p><p>第一次获取数据a11（“1”）的时候其实是没有数据的，所以会耗时去把a11，a12，a13（“1，2，3”）都取回来缓存起来。</p><p></p><p>当第二次取a12、a13的时候候就直接从L2缓存取了。这样cache命中率就是 66.7%。</p><p></p><p>对于L3的情况类似。这样的遍历方式对于CPU来说是一个很友好且高效的。&nbsp;</p><p></p><p>C代码块就是这种横向优先的访问方式。&nbsp;A代码块里面对arrays_A的方式是横向优先遍历的，但是在处理arrays_B的时候就是纵向遍历的（也就是下面即将提到的方式）。&nbsp;B代码块所有的访问都是纵向的（不友好的遍历方式）。因为发挥不出CPU缓存的效果，所以性能最差。</p><p></p><p></p><h3>2.2.2 不友好的遍历方式</h3><p></p><p></p><p>从上到下，再从左到右。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/6b/6b398ebb4fb1d0e5a958bfbbbadd2e41.png\" /></p><p></p><p>为什么这是一个不好的遍历方式呢？</p><p></p><p>这个得结合上一节Java的二维数组的存储结构一起看。再来回顾一下：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e1/e109d7baaf18b10bf2739dce39fb4cb8.png\" /></p><p></p><p>从上面的存储的结构图来看，其实a11，a12，a13 与 a21，a22，a23行与行之间并不是连续的。所以对于L1、L2、L3缓存来说很有可能是不能一起被缓存的（这里用了可能，具体得看L1、L2、L3的容量和数组的大小）。虽然是可能，但是通常都不会一起出现。</p><p></p><p>有了这个知识之后，我们再来看，先从上到下，再从左到右的顺序的缓存命中率。</p><p></p><p>第一次，获取a11，但是缓存里面没有，找到a11之后就把a11，a12，a13缓存下来了。第二次，获取a21，但是缓存里面没有，找到a21之后就把a21，a22，a23缓存下来了，假设有CPU有两行的缓存空间。第三次，获取a31，但是缓存里面没有，找到a31之后把a31，a32，a33缓存下来，并且把a11，a12，a13替换掉（缓存的空间有限，虽然具体的替换策略有很多种，并且还和数据本身的Hash有关系，这里就假设把第一次的结果覆盖了）。后面的逻辑重复之前的步骤。最后得到的缓存命中率就是0%。</p><p></p><p>结合文章开头的缓存速率表格，我们就不难发现，如果我们每次都不命中缓存的话，那么延迟带来的耗时将会相差一个数量级。</p><p></p><p></p><h1>三、总结</h1><p></p><p></p><p>再来回顾一下我们之前的问题。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/a1/a1e4b566255e1850cf59321d7e9b98d3.png\" /></p><p></p><p>C代码块是横向优先的访问方式。&nbsp;A代码块里面对arrays_A的方式是横向顺序访问的，但是在处理arrays_B的时候就是纵向遍历的。&nbsp;B代码块所有的访问都是纵向的（不友好的遍历方式）。因为发挥不出CPU缓存的效果，所以性能最差。</p><p></p><p>Java的二维数组在内存里面是行连续的，但是行与行之间不一定连续。CPU在缓存大小有限的情况下，不可能把所有的数据都缓存下来。再加上每一层级访问速度的硬件限制，就导致了上面的性能结果。</p><p></p><p>相信大家也和我一样，知道原理之后，也不是那么迷惑了。</p><p></p><p>在实际的业务环境中，我们不一定能遇到这种纯计算的场景。但是我们还是应该尽量顺序访问数据，不管是什么样的数据。投其所好，才能够优化代码性能。</p><p></p><p>其次，我们在访问数据的时候，还是需要了解各种语言背后实际的存储结构和CPU的缓存原理，本次是讲述的是Java，但是这个思想其他语言其实也是受用的。</p><p></p><p></p><h1>四、附件</h1><p></p><p></p><p></p><h2>4.1 运行的环境</h2><p></p><p></p><p>系统参数：</p><p><code lang=\"null\">JMH version: 1.36\nVM version: JDK 11.0.13, Java HotSpot(TM) 64-Bit Server VM, 11.0.13+10-LTS-370\n\n型号名称：MacBook Pro\n型号标识符：MacBookPro15,2\n处理器名称：四核Intel Core i5\n处理器速度：2.4 GHz\n处理器数目：1\n核总数：4\nL2缓存（每个核）：256 KB\nL3缓存：6 MB\n超线程技术：已启用\n内存：16 GB\n系统固件版本：1715.60.5.0.0 (iBridge: 19.16.10647.0.0,0)</code></p><p></p><p></p><h2>4.2 整个benchmark的java代码</h2><p></p><p></p><p>ArrayTestBenchmark</p><p><code lang=\"null\">import org.openjdk.jmh.annotations.*;\n\n/**\n * 矩阵 C = AB 的计算\n *\n * @author wzj\n * @date 2023/02/09\n */\n@BenchmarkMode(Mode.AverageTime)\n@State(value = Scope.Benchmark)\n// 预热3次\n@Warmup(iterations = 3, time = 1)\n// 循环 10 次\n@Measurement(iterations = 10, time = 1)\npublic class ArrayTestBenchmark {\n\n    private final int N = 1000;\n\n    private final int[][] arrays_A = new int[N][N];\n    private final int[][] arrays_B = new int[N][N];\n\n    @Setup\n    public void setUp() {\n        for (int i = 0; i &lt; N; i++) {\n            for (int j = 0; j &lt; N; j++) {\n                arrays_A[i][j] = i + j;\n                arrays_B[i][j] = i + j;\n            }\n        }\n    }\n\n\n    @Benchmark\n    public void ijk() {\n        final int[][] arrays_C = new int[N][N];\n        for (int i = 0; i &lt; N; i++) {\n            for (int j = 0; j &lt; N; j++) {\n                int sum = 0;\n                for (int k = 0; k &lt; N; k++) {\n                    sum += arrays_A[i][k] * arrays_B[k][j];\n                }\n                arrays_C[i][j] += sum;\n            }\n        }\n        assert arrays_C.length &gt; 0;\n    }\n\n    @Benchmark\n    public void jik() {\n        final int[][] arrays_C = new int[N][N];\n        for (int j = 0; j &lt; N; j++) {\n            for (int i = 0; i &lt; N; i++) {\n                int sum = 0;\n                for (int k = 0; k &lt; N; k++) {\n                    sum += arrays_A[i][k] * arrays_B[k][j];\n                }\n                arrays_C[i][j] += sum;\n            }\n        }\n        assert arrays_C.length &gt; 0;\n    }\n\n    @Benchmark\n    public void jki() {\n        final int[][] arrays_C = new int[N][N];\n        for (int j = 0; j &lt; N; j++) {\n            for (int k = 0; k &lt; N; k++) {\n                int r_B = arrays_B[k][j];\n                for (int i = 0; i &lt; N; i++) {\n                    arrays_C[i][j] += arrays_A[i][k] * r_B;\n                }\n            }\n        }\n        assert arrays_C.length &gt; 0;\n    }\n\n    @Benchmark\n    public void kji() {\n        final int[][] arrays_C = new int[N][N];\n        for (int k = 0; k &lt; N; k++) {\n            for (int j = 0; j &lt; N; j++) {\n                int r_B = arrays_B[k][j];\n                for (int i = 0; i &lt; N; i++) {\n                    arrays_C[i][j] += arrays_A[i][k] * r_B;\n                }\n            }\n        }\n        assert arrays_C.length &gt; 0;\n    }\n\n    @Benchmark\n    public void kij() {\n        final int[][] arrays_C = new int[N][N];\n        for (int k = 0; k &lt; N; k++) {\n            for (int i = 0; i &lt; N; i++) {\n                int r_A = arrays_A[k][i];\n                for (int j = 0; j &lt; N; j++) {\n                    arrays_C[i][j] += r_A * arrays_B[k][j];\n                }\n            }\n        }\n        assert arrays_C.length &gt; 0;\n    }\n\n    @Benchmark\n    public void ikj() {\n        final int[][] arrays_C = new int[N][N];\n        for (int i = 0; i &lt; N; i++) {\n            for (int k = 0; k &lt; N; k++) {\n                int r_A = arrays_A[k][i];\n                for (int j = 0; j &lt; N; j++) {\n                    arrays_C[i][j] += r_A * arrays_B[k][j];\n                }\n            }\n        }\n        assert arrays_C.length &gt; 0;\n    }\n}</code></p><p></p><p></p><h2>4.3 多次运行benchmark的结果</h2><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/cd/cde997a2a4e3a236a3637a6e1cd19790.png\" /></p><p></p><p></p><h2>引用</h2><p></p><p></p><p>[01] 《深入理解计算机操作系统》</p><p>[02]&nbsp;《深入理解Java虚拟机》</p>",
    "publish_time": "2023-04-25 15:04:11",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "《产业数字人才研究与发展报告（2023）》",
    "url": "https://www.infoq.cn/article/BuzmHqlMOcCBQldV2CCw",
    "summary": "<p>随着新一轮科技革命和产业变革的深入发展，数字经济正在成为重塑全球经济结构、改变全球竞争格局的关键力量，全球主要经济体均希望通过数字化转型建立更具包容性、竞争力和创新性的新型经济结构。《全球数字经济白皮书 2022》显示，2021 年全球 47 个主要经济体数字经济增加值占 GDP 比重为 45%，毫无疑问，数字经济与实体经济的深度融合，将是未来经济发展的重要动力。而数字人才作为数字经济的核心要素，对推动数字经济高质量发展的作用至关重要。随着各产业数字化转型进入更深的阶段，大量数字化、智能化的岗位相继涌现，相关行业对数字人才的需求与日俱增，人才短缺已经成为制约数字经济发展的重要因素。中国信息通信研究院发布的《中国数字经济发展报告（2022）》显示，2021 年我国数字经济规模达 45.5 万亿元，占 GDP 比重达 39.8%。人瑞人才和德勤中国通过估算发现，当前数字人才总体缺口在 2500 万至 3000 万左右，且缺口仍在持续扩大。<br />\n我们深知，任何形式的组织变革与科技的运用其成败的根本依然在于人。人是发现问题的主观能动者，是保障组织任务和目标落地的决定因素。我们调研了众多的数字化转型企业，转型收效甚微或失败的比比皆是，究其原因主要有：1. 对数字化转型理解不深，盲目表面地转；2. 只侧重技术的运用，片面地转；3. 看到问题解决问题，缺乏系统性地转；4. 转型过程中，人才和组织机制保障跟不上。<br />\n在此背景下，人瑞人才与德勤中国携手合作，共同撰写《产业数字人才研究与发展报告（2023）》，希望通过此次研究，观察中国产业数字化进程现状，发掘企业数字化转型中的关键问题，分析数字人才现状与发展趋势，并给出具有针对性的数字人才发展问题解决方案。本报告研究对象涉及政府、企业、求职者及高校多级主体，采用公开政策研究、头部招聘平台数据采集与分析、第三方报告案头研究、企业深度访谈、调查问卷等方法获取企业数字化转型需求、问题及数字人才信息。这其中包括由公司决策者、业务主管、员工和 HR 填答的近 2500 份调查问卷，与 11 个不同行业高管交流得到的近 100 份访谈资料，以及公开的招聘数据信息，报告力求从客观的角度分析、发现各类企业数字化转型中遇到的问题，总结归纳好的经验方法，并针对困扰绝大部分企业的“数字人才不足与培养”问题提出一些针对性的解决方案，以供企业参考，期望能助力更多的企业成功实现数字化转型。<br />\n本报告第一部分概述中国企业数字化发展的背景与趋势。该部分在明确数字经济内涵的基础上概述了数字人才缺口的总体特征，并细化分析企业组织结构和人才管理体系的现状、挑战，以及应对策略。报告第二、三部分则根据德勤中国在数字化产业和产业数字化的行业经验进一步细化研究，分 11 个不同行业描述企业在人才方面遇到的机遇与挑战。该部分在展示细分行业人才供需情况的基础上，通过胜任力模型给出目标人才具备的能力特征，描绘人才微观画像以指明人才培养方向。报告第四部分将视角转向企业发展，人瑞人才从企业数字转型战略出发，分析数字化时代的产品研发策略和项目管理，并聚焦数字化时代的组织模式与人力资源管理策略，提出“以任务为中心”的组织形态、“基于人才领先”的人力资源战略、“企业内外相结合”的人才供应链体系，以及多元化的用工模式，为数字化转型过程中人才管理与培养问题提供了全面的解决方案，对长期困扰企业的“要不要转型、怎么转型、转型过程中需要注意什么，以及如何更有效地实现转型”等问题给出了归纳性意见及参考思路，对处于数字化转型进程中的企业予以启发。<br />\n数字化转型并非简简单单地将数字化技术叠加运用在企业管理中，一个企业要实现数字化转型，需要对企业组织架构、业务模式、人才结构、管理体系、企业文化等方方面面做系统性的转化。人瑞人才过去十几年服务中国各个行业著名企业，沉淀了大量专业服务经验并对行业的业务拥有深入理解与研究，德勤中国在各个行业的市场动态、业务发展趋势、企业管理模式等方面拥有深刻洞察与丰富的咨询服务经验，双方合作共同完成的《产业数字人才研究与发展报告（2023）》是国内首次对 11 个重点产业的数字人才发展的全面梳理与分析，对各行业企业的数字化转型和人才管理具有重要的参考价值。在此我们也希望借本书抛砖引玉，引发更多针对数字人才发展的讨论，并共同推进中国数字经济深入发展。</p>",
    "publish_time": "2023-04-25 15:39:01",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "连接OpenAI两大智能产品Whisper & DALL·E，实现智能语音转文本/文本转图像",
    "url": "https://www.infoq.cn/article/63065790c6fa30aad7cb39d88",
    "summary": "<p>自集简云上线ChatGPT应用以来，已成功帮助数千家企业将人工智能接入自身办公系统。</p><p>集简云公司内部各系统中也全面接入了ChatGPT能力，大大提升了客服系统的服务质量，对于员工的工作效率也形成了极大的助力。</p><p>本周，集简云再度上线OpenAI两大智能产品，不仅丰富了人工智能领域的应用集成，也为广大用户提供更便捷和智能化的信息获取和视觉创作方式。</p><p>OpenAI Whisper&nbsp;：语音高效智能转换文本OpenAI DALL·E&nbsp;：基于文本描述创作高质量图像</p><p><img src=\"https://static001.geekbang.org/infoq/da/da96b58f51cc4e1290181a7d622b3ba5.png\" /></p><p><a href=\"https://link.zhihu.com/?target=https%3A//apps.jijyun.cn/plugcenter\">集简云让连接更简单​apps.jijyun.cn/plugcenter</a>\"</p><p>下面，我们将分别介绍这两个新功能的应用场景和使用方式。</p><p></p><h3>OpenAI Whisper 功能介绍</h3><p></p><p>OpenAI Whisper是由OpenAI团队开发的一款智能语音转文本工具，只需要提供一段录音或者音频文件，就可以快速将语音转换为文本内容。如果你是一名记者，或者是需要大量听取录音的从业者，OpenAI Whisper将是你不可或缺的好帮手。</p><p></p><h3>OpenAI Whisper 效果展示</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/a2/a2adc99748c79b1e53f4c4bc0a206635.png\" /></p><p>▲自动识别录音转换文本，并使用ChatGPT自动生成录音总结</p><p></p><h3>OpenAI Whisper 应用场景</h3><p></p><p>OpenAI Whisper语音转换文本功能能帮助用户实现更高效、准确地进行文字记录，编辑等功能，在商业和个人领域都具有广泛的应用前景：</p><p>语音助手：将用户的语音命令或输入的语音内容转换成文本，进行进一步的处理和回答。视频及电话会议：将会议纪要语音转换为文本，使得会议记录更加准确，也方便后续的阅读和分析。客服服务：将客户语音的问题或请求转换成文本，减少人工处理时间，提高客户服务效率。医疗记录：对医生或护士在患者诊疗时的语音记录进行转换成文本，方便医生和护士们快速获取和整理患者的医疗信息和历史记录。语音翻译：Whisper可以将一个语言的语音转换为相应的文字，再通过机器翻译算法将其翻译成目标语言的文本，使人们能够跨越语言和文化的障碍进行交流。讲座记录：对大型讲座或演讲的语音内容进行实时记录，使得听众可以更加专注于演讲内容，而不必担心遗漏笔记。</p><p></p><h3>OpenAI Whisper 流程示例</h3><p></p><p>明道云 + OpenAI Whisper + ChatGPT：通过将SDR外呼线索语音文字记录同步到明道云表格系统，并通过ChatGPT3.5对沟通记录进行总结与同步。</p><p><img src=\"https://static001.geekbang.org/infoq/52/52658a85bdf4e5d4113ee287efb9249a.png\" /></p><p></p><p></p><p>实现效果：当有新的大于10s的语音记录文件生成时，可自动将文字与录音总结同步到表单中。</p><p><img src=\"https://static001.geekbang.org/infoq/54/54fba7843c6f70a1534e61549d39d4c6.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/46/46608563ad65fa715fbf9d269394cd3e.png\" /></p><p></p><p>流程介绍：</p><p>1 当明道云应用外呼记录表单有新的记录产生时，通过数据筛选应用将10S以上的语音记录作为筛选条件（此筛选条件规避掉沟通时间过短，或者电话被挂断的无效沟通</p><p>2 当语音记录被筛选通过后，即可通过OpenAI Whisper来将语音文件转化为文本，并将该文本作为文字沟通记录，同步到明道云表单中</p><p>3 将转化为文本的沟通记录，作为指令问题的一部分内容，让OpenAI（ChatGPT）作为智能助手，根据该内容进行归纳和总结，并将总结内容返回到明道云进行记录。</p><p></p><h3>OpenAI DALL·E 功能介绍</h3><p></p><p>OpenAI DALL·E 是一款由OpenAI 公司研发推出的人工智能图像生成应用，能够基于文本描述来创建图像，利用大规模的预训练神经网络和生成对抗网络技术，生成具有高度现实感的图像。</p><p>与传统图像生成器不同的是，DALL·E 不仅可以生成与现实世界中物体相似的图像，也可以创造出抽象的视觉概念，例如一个火柴人在海上冲浪。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d6/d69e0c83dfb01146e2fe0f7c189ff535.png\" /></p><p></p><p>集简云上线OpenAI DALL·E ，无需开发就能快速将OpenAI DALL·E 集成其他应用软件，进行图片创作、图片编辑和以图生图。</p><p></p><h3>OpenAI DALL·E 效果展示</h3><p></p><p><img src=\"https://static001.geekbang.org/infoq/39/3920d22859cddd7410b846201a4dbe68.png\" /></p><p>▲DALL・E 示例</p><p>给出一句话「牛油果形状的椅子」，就可以获得绿油油、形态各异的牛油果椅子图像。</p><p><img src=\"https://static001.geekbang.org/infoq/9f/9f923f78008bd5708b31f9b4ae670913.png\" /></p><p>小鹿在森林深处被萤火虫环绕</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/5e/5e48642166a628f154738b661e288ed0.png\" /></p><p>头带蝴蝶结的赛博朋克小狗</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b8/b8e38e3e62fa5006811940dfd5ea14dd.png\" /></p><p>漫画风窝在沙发上的猫</p><p></p><p></p><h3>OpenAI DALL·E 功能特点</h3><p></p><p>创意丰富：DALL·E 的输出图像非常丰富多样，它可以根据用户的文本描述创作出细节丰富的图像，包括动物、物品、场景等。从而帮助设计师快速生成各种图像，并提供多样化的选择，增强创造力和灵感。快速定制：如果有复杂的场景或物品需要设计，DALL·E 可以帮助用户快速定制，增强效率和准确性。节约时间成本：DALL·E 的创作速度很快，能够大大节省人工绘制图像的时间和成本。对于那些需要大量生成图像的工作，DALL·E 极大地提高了效率，同时还可以帮助降低人力成本。应用广泛：DALL·E 的应用非常广泛，比如设计、广告、出版、媒体、医学、教育等领域。它可以为这些领域提供更丰富的设计选择，增强创意和创造力。</p><p>OpenAI DALL·E 应用场景</p><p>在设计领域中，它可以帮助设计师创建与产品相关的图像，包括海报、广告和包装设计，从而提高设计效率。在广告领域中，广告公司可以使用它设计出更具吸引力和创意性的广告和宣传材料。在医疗领域中，它可以用来生成医学图像，用于辅助疾病诊断和治疗计划制定。比如生成3D模型来辅助医生进行手术模拟。在游戏领域中，它可以用于游戏设计中的角色、道具、场景等元素的构建，或用于创建更互动、沉浸式的虚拟游戏体验。</p><p></p><h3>如何开通</h3><p></p><p>OpenAI Whisper 、 OpenAI DALL·E 需要在集简云插件中心开通应用，并消耗集简云账户余额。</p><p>开通路径：集简云平台 -&nbsp;<a href=\"https://link.zhihu.com/?target=https%3A//apps.jijyun.cn/plugcenter\">插件中心</a>\"&nbsp;- OpenAI Whisper / OpenAI DALL·E - 去开通 - 开通 ，即可开通对应资源包。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b1/b155f02a5383ed1e06b9e88f9ce7d584.png\" /></p><p></p><p></p><p></p><p>集简云: 让连接更简单</p><p></p><p>我们相信：业务流程自动化与智能化是企业新的增长引擎</p><p>官网地址：<a href=\"https://link.zhihu.com/?target=https%3A//www.jijyun.cn/%3Futm_source%3Dzhihu%26utm_medium%3Dwenzhang%26utm_campaign%3Dwhisper\">「集简云官网」软件集成可以如此简单</a>\"</p><p><a href=\"https://link.zhihu.com/?target=https%3A//open.jijyun.cn/app/list%3Futm_source%3Dzhihu%26utm_medium%3Dwenzhang%26utm_campaign%3Dwhisper\">集简云-开发者平台​open.jijyun.cn/app/list?utm_source=zhihu&amp;utm_medium=wenzhang&amp;utm_campaign=whisper</a>\"</p>",
    "publish_time": "2023-04-25 10:25:16",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "平安银行、方正证券、风平智能分享场景金融背后的技术实践，速来报名占座",
    "url": "https://www.infoq.cn/article/juuT1kQ9mh7ePRWMduvm",
    "summary": "<p>所谓“无场景、不金融”。如今，金融行业数字化正围绕平台化、场景化、智能化持续推进。</p><p></p><p>平台化方面，创新移动支付、投资理财、现金管理等综合金融服务，对内聚合产品与服务，对外链接合作伙伴与客户；场景化方面，广泛连接各类金融生态场景，打造覆盖“衣、食、住、行、医、教、购、娱”的生活生态圈；智能化方面，引入指纹、手势、刷脸、声纹等生物识别技术，形成新的交互体验。</p><p></p><p>甚至，<a href=\"https://www.infoq.cn/theme/165\">数字人</a>\"与<a href=\"https://www.infoq.cn/theme/187\">AIGC</a>\"等前沿技术，也在其中拥有无限可能。</p><p></p><p>在这样的背景下，<a href=\"https://xie.infoq.cn/article/7a75e592f6659d9599f9e47b9\">银行</a>\"、保险、证券等金融机构如何迭代和升级自身的商业模式，及其背后的技术架构？4月26日19:30，《超级连麦.数智大脑》栏目邀请了来自中国信通院泰尔终端实验室、平安银行、方正证券、风平智能的专家，分享各自领域和行业的洞察及实践经验。</p><p></p><h3>直播时间</h3><p></p><p>4&nbsp;月&nbsp;26&nbsp;日（周三）&nbsp;19:30-22:00</p><p></p><h3>联合出品</h3><p></p><p>InfoQ&nbsp;x&nbsp;中国信通院&nbsp;“铸基计划”x&nbsp;极客时间企业版</p><p></p><h3>直播主题</h3><p></p><p>金融服务场景化背后的业务创新与技术升级</p><p></p><h3>直播亮点</h3><p></p><p>信通院泰尔终端实验室专家专题解读金融数字化现状、挑战及趋势；平安银行如何进行开放银行模式的探索和实践；方正证券如何基于技术架构升级实现数字化运营；数字人与AIGC等前沿技术在保险场景如何落地；金融业如何从技术、组织、人才多维度，实现体系化变革</p><p></p><h3>直播议程</h3><p></p><p></p><h4>19:30-19:45&nbsp;&nbsp;中国信通院金融数字化转型探索</h4><p></p><p>王景尧博士，中国信通院<a href=\"https://www.infoq.cn/article/Ui3JSdRN2cSbqkPDjoJH\">泰尔终端实验室</a>\"数字生态发展部主任</p><p>分享大纲：</p><p>1.物联网金融数字化平台</p><p>2.绿色金融数字化平台</p><p>3.个人业务数字化平台</p><p>4.基础IT能力的数字化创新</p><p></p><h4>19:45-20:15&nbsp;&nbsp;开放银行模式探索：平安星云开放联盟实践分享</h4><p></p><p>陆皓，平安银行交易银行部总裁助理，平安银行开放银行负责人</p><p>分享大纲：</p><p>1.平安银行在金融数字化方面的业务探索</p><p>2.平安银行星云开放联盟实践分享</p><p>3.平安银行开放银行的生态创新</p><p></p><h4>20:15-20:45&nbsp;&nbsp;数字人AIGC的保险行业应用构想与实践</h4><p></p><p>林洪祥，风平智能CEO&nbsp;&nbsp;</p><p>分享大纲：</p><p>1.数字人与AIGC</p><p>2.AIGC的保险营销新范式</p><p>3.AI数字人的智能服务实践</p><p></p><h4>20:45-21:15&nbsp;方正证券的数字化运营实践和技术架构升级</h4><p></p><p>高玉娴，InfoQ极客传媒数字化主编&nbsp;x&nbsp;石锐，方正证券信息技术部交易研发负责人</p><p>对话大纲：</p><p>1.方正证券在证券服务场景创新方面的探索</p><p>2.方正证券的技术架构升级路径和经验</p><p></p><h4>21:15-22:00&nbsp;连麦对话——金融数字化背后的组织变革与人才培养</h4><p></p><p>霍太稳，极客邦科技创始人兼&nbsp;CEO</p><p>王景尧博士，中国信通院泰尔终端实验室数字生态发展部主任</p><p>陆皓，平安银行开放银行负责人</p><p>林洪祥，风平智能CEO</p><p>石锐，方正证券信息技术部交易研发负责人</p><p></p><h2>直播报名</h2><p></p><p>扫描二维码立即报名预约直播，还可以留下你关心的问题，讲师将在直播中为你解答：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/cb/cbc5281df45947544512328a5ff8abb2.png\" /></p><p></p><p></p><h4>关于《超级连麦.&nbsp;数智大脑》</h4><p></p><p><a href=\"https://www.infoq.cn/video/mdQQzrZrq9WSgEV4sxjr\">《超级连麦.&nbsp;数智大脑》</a>\"是&nbsp;InfoQ&nbsp;重磅推出的一档连麦直播栏目，由数字化领域的思想领袖、技术大咖及企业先行者等多方连线，聚焦企业数字化实践、数字人才培养、数字化技术管理等话题，剖析和拆解典型数字化场景及其痛点，意在帮助各行业企业扫清转型障碍、探寻变革路径。</p><p></p><p>每期直播将邀请&nbsp;2-3&nbsp;位嘉宾围绕同一话题，从不同维度展开深度讨论。我们希望能够深入行业最核心的话题，通过充分的现场碰撞和探讨，对关键问题进行深刻的剖析，既有理论也有实践，既有战略也有战术，为观众呈现更为全方位、多视角，更有代入感、更具启发性的数字化转型参考。</p><p></p><p>欢迎添加小助手进群，我们将为您推送更多数字化内容和活动信息。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/17/1753d78b2a1eba7f6d1ad7a1021ac3c3.jpeg\" /></p><p></p>",
    "publish_time": "2023-04-25 10:28:23",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "神州数码：抢抓云原生发展机遇，共建共治共享 OpenNJet 应用引擎开源生态",
    "url": "https://www.infoq.cn/article/iola1LzWGoAzhplBtLx1",
    "summary": "<p>4 月 25 日下午，“数云原力大会暨 2023 TECH 第五届数字中国技术年会”在北京盛大召开。在开幕式上，神州数码通明湖云和信创研究院重磅发布下一代云原生应用引擎 OpenNJet，并宣布捐赠给开放原子开源基金会孵化，内容包括代码、知识产权、商标等。</p><p></p><p>目前，OpenNJet 已经通过 TOC 评审，并已在 AtomGit 和 Gitee 平台建立了代码仓库。神州数码希望在开放原子开源基金会的开源框架下，持续发展和壮大 OpenNJet，以汇聚更广泛的用户和生态合作伙伴，拓展开源生态版图。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/c1/2a/c1c668296e6c257a124a44bd960d892a.png\" /></p><p>图：下一代云原生应用引擎 OpenNJet 重磅发布</p><p></p><p><a href=\"https://xie.infoq.cn/article/c40cd865c2dabd12714587ca7\">神州数码</a>\"技术总监、通明湖云和信创研究院院长李刚表示，将 OpenNJet 捐赠给开放原子开源基金会是神州数码“数云融合”愿景驱动云原生技术创新、生态发展的重要成果，也是神州数码聚焦云原生技术和产品投入和研发，打造云原生产品竞争力的重要成果。</p><p></p><p>开放原子开源基金会秘书长冯冠霖在致辞中指出，“<a href=\"https://xie.infoq.cn/article/3f9e8920fda2e7a0b6fec9c4d\">神州数码</a>\"捐赠的 OpenNJet 项目是开放原子开源基金会首个云原生应用引擎的捐赠，该项目目前已经通过 TOC 的评审，在开源这个生态中，又多了一份力量。”</p><p></p><p></p><h2>OpenNJet 抢抓云原生技术发展机遇</h2><p></p><p></p><p>近年来，云原生架构已经成为IT架构的新范式，市场占有率不断提升。据 IDC 预测，2024 年新增的生产级云原生应用在新增应用中的比例会从 2020 年的 10% 增加到 60%。云原生架构下，应用引擎的作用不断提升，全面承担云原生数据平面的功能，是所有云应用的入口。然而，云原生架构下的应用引擎，其标准、功能、定义不断演化，创新产品交替涌现、共存竞争，正处于技术变革期。</p><p></p><p>冯冠霖表示，“神州数码将OpenNJet应用引擎捐赠给开放原子开源基金会进行孵化，是抢抓云原生技术发展机遇的重要举措，对于夯实云原生技术发展根基，提升云原生技术创新、成果落地具有非常重要的意义。”</p><p><img src=\"https://static001.infoq.cn/resource/image/ed/65/edd7855b4a1411dd27b7688f46417d65.png\" /></p><p>图：开放原子开源基金会秘书长冯冠霖致辞</p><p></p><p></p><h2>OpenNJet 应用引擎的技术架构迭代创新</h2><p></p><p></p><p>OpenNJet 应用引擎是面向互联网和云原生应用提供的运行时组态服务程序。具备环境感知、安全控制、加速优化等能力，可利用动态加载机制实现不同的产品形态，如API网关、消息代理、入口/出口控制器、边车、负载均衡和 WAF 等。</p><p></p><p>OpenNJet 是以 NGINX1.23.1 开源版本为基础，派生并独立演进的云原生应用引擎，进行内核重构、安全加固、功能增强开发，并随着 NGINX 版本迭代，吸收上游 NGINX 的更新，还提供了服务网格中东西向通信、透明流量劫持、熔断、遥测与故障注入、链路追踪、蓝绿发布等新功能特性。</p><p></p><p>OpenNJet 的目标在于适应国内特定的技术规范及标准，如国密算法套件支持，兼容 Kubernetes 容器编排和 Istio 服务治理框架，并构建安全可控的云原生数据面，支撑我国云原生产业生态发展。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/7f/75/7fc4889565a3485552b133342a3d4975.png\" /></p><p>图：OpenNJet技术架构迭代创新</p><p></p><p>李刚强调，“OpenNJet 充分吸收了开源生态的优秀扩展模块 ，在功能规划上包含了 5 大类 18 类组件，特别是随着安全威胁的快速增加，规划了安全组件。除安全功能外，‘企业特性’也是 OpenNJet 关注的重点领域，如内置的高可用性，自动化的集群发现及配置同步等。”</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/a7/02/a72e8de575c6b83550907d36c3b4d602.png\" /></p><p>图：OpenNJet功能组件</p><p></p><p>OpenNJet 整体包括三大部分，底层的 Framework 用于管理进程，解析配置，提供日志，事件处理等核心能力；Copilot 用于实现各式控制能力，对接不同的周边系统；workers 提供各种业务功能，如代理、Web 引擎、WAF 等。</p><p></p><p></p><h2>共建共治共享 OpenNJet 应用引擎开源生态</h2><p></p><p></p><p>OpenNJet 应用引擎的技术迭代、创新发展、生态繁荣同样离不开全球开源创新能力的建立和完善。因此在开放原子开源基金会架构下，通过代码贡献构建开源社区，集聚开发者和企业用户力量，共创开源生态，将能助力 OpenNJet 应用引擎的技术创新和生态建设走向成熟，繁荣发展。</p><p></p><p>冯冠霖强调，“下一步，开放原子开源基金会将遵循共建、共治、共享的开源理念，组织专门力量，加快推动 OpenNJet 开源生态建设和繁荣。”</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/a4/2b/a45a1ccc5081145133771364cfab7f2b.png\" /></p><p>图：共建共治共享OpenNJet繁荣生态邀请仪式</p><p></p><p>开幕式上，<a href=\"https://xie.infoq.cn/article/ecdb673dfaccbe512f080521c\">神州数码</a>\"联合开放原子开源基金会、北京航空航天大学、北京通明湖信息技术应用创新中心、曙光网络、龙芯中科、浩鲸科技、行云创新、通明智云等产学研用机构和单位一同发起邀请，共建共治共享 OpenNJet 应用引擎开源生态。</p><p></p><p></p><h2>各界嘉宾发表寄语</h2><p></p><p></p><p>北京航空航天大学大数据科学与脑机智能高精尖创新中心副主任沃天宇：开源是群智众创的行业实践，开源的沃土需要每一位贡献者的播种，期待在 OpenNJet 遇到全球最顶尖的云原生开发者！ &nbsp;</p><p></p><p>清华大学研究员、北京通明湖信息技术应用创新中心主任曹军威：在云原生开源的发展历程中，有一批又一批的先行者不断探索和实践，我们将不断深化开源领域产教融合，先从云原生应用引擎开始，夯实开源人才底座、奠定开源发展基础、提升软件源头创新和供给能力。</p><p></p><p>曙光网络科技有限公司副总裁张玉龙：数字化的目的之一在于更好的促进竞争与进步，开源更是，立足产业、聚焦领域，只有尊重开源、拥抱开源，坚定技术创新，加强人才交流，中国基础软件才有机会走向全球。</p><p></p><p>龙芯中科技术股份有限公司解决方案中心总经理秦宝瑞：我们期待更多像OpenNJet这样能够自主创新、加强产业合作的原力引擎，一起携手凝聚更多共同体助力云原生生态自主发展、生态开源共享繁荣发展。&nbsp;&nbsp;</p><p></p><p>浩鲸云计算科技股份有限公司北京大区总经理李强：企业可以在开源项目中充分发挥产业优势，扩大软件生态建设，秉持共建共享共治的开源理念，云原生生态，我们都是赶路人。</p><p></p><p>深圳行云创新科技有限公司联合创始人孔佳明：开源不仅是一种软件开发方式，更使得所有参与者共享科技成果，才会产生连绵不绝的创造力，云原生应用引擎需要聚集各方力量，多元协同，成果共享。</p><p></p><p>通明智云（北京）科技有限公司首席运营官吴静涛：云原生，诞生于开源，很高兴能够以开源共建的身份，加入到开源项目建设中来，开源将重构未来的技术创新，对于云原生来说，应用引擎意味着更高的可靠性、可信开源、可持续发展，数云融合的未来，少不了 OpenNJet 领航！</p>",
    "publish_time": "2023-04-25 19:09:22",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]