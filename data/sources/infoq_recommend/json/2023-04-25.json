[
  {
    "title": "领英通过实施消息客户端 SDK，将开发效率提高了10倍",
    "url": "https://www.infoq.cn/article/31oV8dKq8heHUsRQPGfB",
    "summary": "<p>领英在近期发布的文章《<a href=\"https://engineering.linkedin.com/blog/2023/unifying-messaging-experiences-across-linkedin\">如何通过消息客户端 SDK 大幅提升开发效率</a>\"》中称，通过使用 SDK 抽象数千行代码至共享库，他们得以削减跨多平台应用的代码维护成本。在一个用例场景下，新 SDK 在构建全新领英体验时可以节省四十余名开发者数周的劳动。</p><p>&nbsp;</p><p>领英的高级员工工程师 <a href=\"https://www.linkedin.com/in/micurs/\">Michele Ursino</a>\" 和领英的工程负责人 <a href=\"https://www.linkedin.com/in/joe-xue-66782012/\">Joe Xue</a>\" 对 SDK 是如何提高生产力的解释如下：</p><p>&nbsp;</p><p></p><blockquote>我们的 Messenger SDK 通过将数千行代码抽象为共享库，减少了跨多个应用程序的代码维护成本，极大地提升了开发人员的工作效率。在部分情况下，我们实现了跨十倍的代码数量减少，从三千多行减至几百行。其结果是，开发人员现在可以在几周内创建新的信息体验，而非原先的几月或几季度。</blockquote><p></p><p>&nbsp;</p><p>Ursino 和 Xue 称，通过创建一个跨领英消息体验的共用前端平台，他们已经证明了这种可被他人复制、用于自己核心功能的模式：</p><p>&nbsp;</p><p></p><blockquote>同领英一样，拥有多个大型应用的组织应重新考虑应用构建的方式。与其将应用当作独立个体，组织可以在可重复使用的平台库之上，建立轻薄的应用层，按需暴露各类技术支柱的高级能力乃至用户界面。</blockquote><p></p><p>&nbsp;</p><p>领英<a href=\"https://engineering.linkedin.com/blog/2020/bootstrapping-our-new-messaging-platform\">在2020年年中完成了其消息体验的重构</a>\"。不过，据 Ursino 和 Xue 说明，“在运行领英产品的设备上实现完整消息可靠性和功能性是一项复杂的任务，不仅工作量繁重且对细节要求颇高。”为确保最大限度的一致性和可靠性，领英对其消息传递平台进行了扩展，涵盖了客户侧设备和前端 API 中的消息数据管理。领英的消息传递团队将所有消息传递功能打包为一个全功能的数据层 SDK，用于解决客户端应用中消息传递数据的管理复杂性问题。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/78/7802e504274cb018bc45afd42713e818.png\" /></p><p></p><p>来源：<a href=\"https://engineering.linkedin.com/blog/2023/unifying-messaging-experiences-across-linkedin\">https://engineering.linkedin.com/blog/2023/unifying-messaging-experiences-across-linkedin</a>\"</p><p>&nbsp;</p><p>领英将新的 SDK 分为两类库：用于应用程序 API 中消息整合的 API 库（“messenger-api”），以及用于表示设备本地信箱的客户库（messenger-data）。</p><p>&nbsp;</p><p>其中，API 库有三项功能：桥接客户与后端消息传递平台基础设施间&nbsp;<a href=\"https://graphql.org/\">GraphQL</a>\" 请求、允许主机 API 自定义消息传递 API 的行为，以及允许其他系统使用 GraphQL 对消息传递数据进行装饰。该 API 库实现了对外部系统消息传递数据的错误检查，并暴露了一个 GraphQL 模式，其中包含每个平台中客户 SDK 库用于获取信息的查询。这种架构方式允许主机 API 代码对每个 API 请求生命周期中，后端消息平台传至前端的消息数据进行自定义转换。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/44/44c3a10e70b6a649223d6950d32b8e95.png\" /></p><p></p><p>来源：<a href=\"https://engineering.linkedin.com/blog/2023/unifying-messaging-experiences-across-linkedin\">https://engineering.linkedin.com/blog/2023/unifying-messaging-experiences-across-linkedin</a>\"</p><p>&nbsp;</p><p>客户库为消息传递实现了一个以<a href=\"https://en.wikipedia.org/wiki/Event-driven_architecture\">事件为驱动</a>\"的数据层（EDDL），为客户设备中的信箱数据提供了实时的表示，且与后端中实际的信箱数据进行同步。该 API 库意在保障最大化消息传递可靠性，允许应用程序开发者轻松访问信箱数据。此外，其所采用的反应式方法也支持了设备中对话和消息的快速渲染和屏幕刷新，即时地将任何数据变化通知主机应用程序代码，从而允许必要的用户界面刷新。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b9/b9094091931d15f740411f8229c375ed.png\" /></p><p></p><p>来源：<a href=\"https://engineering.linkedin.com/blog/2023/unifying-messaging-experiences-across-linkedin\">https://engineering.linkedin.com/blog/2023/unifying-messaging-experiences-across-linkedin</a>\"</p><p>&nbsp;</p><p>领英已经将其旗舰应用程序的消息传递功能迁移至 Messenger SDK，为全客户平台提供一致且可靠的消息传递体验。该 SDK 带来了跨平台的功能平等性以及现代化的代码库，提高了稳定性和可靠性，也提升了开发人员的生产力。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/03/linkedin-messenger-sdk/\">LinkedIn Improves Development Productivity by 10x Implementing a Messaging Client-Side SDK</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/87fXytBSTUiUDmTkHfcO\">领导力匠艺：像开发人员打造代码那样打造你的领导力</a>\"</p><p><a href=\"https://www.infoq.cn/article/7Ps0qyHfQhp59g7YrEvZ\">当你的技术栈不能满足每个人需求时，下一步是什么呢？</a>\"</p><p><a href=\"https://www.infoq.cn/article/FAxivpNAGHAIyYMupEJG\">提高软件质量：如何处理数据发现更多 Bug</a>\"</p><p></p>",
    "publish_time": "2023-04-25 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": ".NET无侵入自动化探针原理和主流实现",
    "url": "https://www.infoq.cn/article/fY1dWBrmj8V2BeP8eOGf",
    "summary": "<p></p><h2>前言</h2><p></p><p></p><p>最近，我在微信公众号和博客园分享了一篇关于 .NET 微服务系统迁移至.NET 6.0 的故事 的文章，引起了许多读者的关注。其中，许多人对基于 OpenTelemetry .NET 的观测指标和无侵入自动化探针颇感兴趣。事实上，我已计划抽出时间，与大家分享这方面的内容。</p><p></p><p>巧合的是，在二月末，我收到了来自 OpenTelemetry 中国社区的蒋志伟大佬的邀请，希望我能就 .NET 实现无侵入自动化探针的方法进行分享。因为关于 Java 等其他语言的自动化探针实现原理已有大量文章，但.NET 领域却鲜有介绍，而社区对此也很感兴趣。</p><p></p><p>然而，因为 .NET 无侵入自动化探针的实现原理相当复杂，理解和完全掌握原理有很大差别。为确保文章质量和严谨性，撰写过程耗时较长，因此现在才能与大家见面。</p><p></p><p></p><h2>APM 探针</h2><p></p><p></p><p>当我们提到 .NET 的 APM 时，许多人首先会想到 SkyWalking 。这是因为 SkyAPM-dotnet 是第一个支持.NET 应用程序的开源非商业 APM 探针实现，目前很多 .NET 项目都采用了它。在此，我们要特别感谢刘浩杨等社区领袖的辛勤付出。</p><p></p><p>除了 SkyWalking 之外， Datadog APM 也是一款功能强大的商业应用性能监测工具，旨在帮助开发人员跟踪、优化并排查应用程序中的性能问题。Datadog APM 适用于多种编程语言和框架，包括 .NET 。通过使用 Datadog 丰富的功能和可视化仪表板，我们能够轻松地识别并改进性能瓶颈。</p><p></p><p>另一个比较知名的选择是 OpenTelemetry-dotnet-contrib ，这是 CNCF-OpenTelemetry 的 .NET 应用程序 APM 探针实现。虽然它的推出时间比 SkyAPM 和 Datadog APM 稍晚，但由于其开放的标准和开源的实现，许多 .NET 项目也选择使用它。</p><p></p><p>关于 APM 探针的实现原理，我们主要分为两类来介绍：平台相关指标和组件相关指标。接下来，我们将讨论如何采集这两类指标。</p><p></p><p></p><h3>平台相关指标采集</h3><p></p><p></p><p>那么 APM 探针都是如何采集 .NET 平台相关指标呢？其实采集这些指标在 .NET 上是非常简单的，因为.NET 提供了相关的 API 接口，我们可以直接获得这些指标，这里指的平台指标是如 CPU 占用率、线程数量、GC 次数等指标。</p><p></p><p>比如在 SkyAPM-dotne t 项目中，我们可以查看 SkyApm.Core 项目中的 Common 文件夹，文件夹中就有诸如里面有 CPU 指标、GC 指标等平台相关指标采集实现帮助类。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/25/2533bd4b8a4beb24015b93f7be35b5a8.png\" /></p><p>同样，在 OpenTelemetry-dotnet-contrib 项目中，我们可以在 Process 和 Runtime 文件夹中，查看进程和运行时等平台相关指标采集的实现。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/c3/c339111e7d609272c13c661b9e939e64.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/fd/fd832f0804a47cd7179b567760d2bf80.png\" /></p><p></p><p>这些都是简单的 API 调用，有兴趣的同学可以自行查看代码，本文就不再赘述这些内容。</p><p></p><p></p><h3>组件相关指标采集</h3><p></p><p></p><p>除了平台相关指标采集，还有组件相关的指标，这里所指的组件相关指标拿 ASP.NET Core 应用程序举例，我们接口秒并发是多少、一个请求执行了多久，在这个请求执行的时候访问了哪些中间件 ( Redis 、MySql 、Http 调用、RPC 等等)，访问中间件时传递的参数 (Redis 命令、Sql 语句、请求响应体等等) 是什么，访问中间件花费了多少时间。</p><p></p><p>在 SkyAPM-dotnet 项目中，我们可以直接在src目录找到这些组件相关指标采集的实现代码。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e0/e0f871cf738a4c1209d944daaa9dc7a7.png\" /></p><p></p><p>同样在 OpenTelemetry-dotnet-contrib 项目中，我们也可以在src目录找到这些组件相关指标采集代码。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/39/390e9df04f7e30804e9283941e49d0ff.png\" /></p><p></p><p>如果看过这两个 APM 探针实现的朋友应该都知道，组件指标采集是非常依赖DiagnosticSource技术。.NET 官方社区一直推荐的的方式是组件开发者自己在组件的关键路径进行埋点，使用DiagnosticSource的方式将事件传播出去，然后其它监测软件工具可以订阅DiagnosticListener来获取组件运行状态。</p><p></p><p>就拿 ASP.NET Core 来举例，组件源码中有<a href=\"https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Hosting/src/Internal/HostingApplicationDiagnostics.cs\">HostingApplicationDiagnostics.cs</a>\"这样一个类，这个类中定义了 Hosting 在请求处理过程中的几个事件。</p><p></p><p><code lang=\"text\">internal const string ActivityName = \"Microsoft.AspNetCore.Hosting.HttpRequestIn\";\nprivate const string ActivityStartKey = ActivityName + \".Start\";\nprivate const string ActivityStopKey = ActivityName + \".Stop\";</code></p><p></p><p>当 Hosting 开始处理请求时，会检测当前是否有监听者监听这些事件，如果有的话就会写入事件，事件也会携带当前的一些上下文信息，代码如下所示：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e0/e05b086b764f390b9c9e15ca3a202a25.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/4f/4fe0bc2a1613cd885662d5218647baa1.png\" /></p><p></p><p>以 SkyAPM-dotnet 举例，有对应的HostingTracingDiagnosticProcessor.cs监听事件，然后获取上下文信息记录 APM 埋点信息，代码如下所示：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/4f/4f127a34233f51eefe7def7240ce5e7b.png\" /></p><p></p><p>这种方式的优点有：</p><p></p><p>高效和高性能：DiagnosticSource 是 .NET 平台自带的框架，使用它硬编码可以享受到编译器和 JIT 相关优化可以避免一些性能开销。组件开发者可以控制事件传递的频率和内容，以达到最佳的性能和资源利用率。</p><p></p><p>灵活：通过使用 DiagnosticSource，组件开发者可以灵活地定义自己的事件模型，并按需发布事件。这意味着可以轻松地定制自己的监测需求，而不必担心过多的日志数据产生过大的开销。</p><p></p><p>可扩展性：使用DiagnosticSource可以让组件的监测需求随着时间的推移而演变，而不必担心日志系统的限制。开发者可以根据自己的需要添加新的事件类型，以适应不断变化的监测需求。</p><p></p><p>易用性：DiagnosticSource的 API 简单易用，订阅事件数据也很容易。这使得使用它进行组件监测变得非常容易，并且可以快速地集成到现有的监测系统中。</p><p></p><p>可移植性：DiagnosticSource可以在多个平台上运行，包括 Windows、Linux 和 macOS 等。这意味着可以使用相同的事件模型来监测不同的应用程序和服务，从而简化了监测系统的设计和管理。</p><p></p><p>不过这种方式的缺点也很明显，就是 必须由组件开发者显式的添加事件代码，探针的开发者也因此束手束脚，这就导致一些没有进行手动埋点的三方组件都无法添加事件监听，所以现阶段 SkyAPM-dotnet 支持的第三方组件还不是很丰富。</p><p></p><p>那么其实只要解决 如何为没有进行手动埋点的组件库加入埋点 就能解决 SkyAPM-dotnet 支持第三方组件多样性的问题。</p><p></p><p></p><h2>.NET 方法注入</h2><p></p><p></p><p>从上一节我们可以知道，目前制约 APM 支持组件不够丰富的原因之一就是很多组件库都没有进行可观测性的适配，没有在关键路径进行埋点。</p><p></p><p>那么要解决这个问题其实很简单，我们只需要修改组件库关键路径代码给加上一些埋点就可以了，那应该如何给这些第三方库的代码加点料呢？聊到这个问题我们需要知道一个 .NET 程序是怎么从源代码变得可以运行的。</p><p></p><p>通常情况下，一个 .NET 程序从源码到运行会经过两次编译（忽略 ReadyToRun 、NativeAOT 、分层编译等情况）。如下图所示：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/6d/6d0184b4e6eddc51c4db549f31310f5e.png\" /></p><p></p><p>第一次是使用编译器将 C#/F#/VB/Python/PHP 源码使用 Roslyn 等对应语言编译器编译成 CIL（Common Intermediate Language，公共中间语言）。第二次使用 RuyJit 编译器将 CIL 编译为对应平台的机器码，以 C# 语言举了个例子，如下图所示：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e1/e15ab70b5a4de52805515feb85eac64f.png\" /></p><p>方法注入也一般是发生在这两次编译前后，一个是在 Roslyn 静态编译期间进行方法注入，期间目标 .NET 程序并没有运行，所以这种 .NET 程序未运行的方法注入我们叫它 编译时静态注入。而在 RuyJit 期间 .NET 程序已经在运行，这时进行方法注入我们叫它 运行时动态注入。下表中列出了比较常见方法注入方式：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/fc/fcdae00fcf221ae86b8f5e2334744ed6.png\" /></p><p></p><p>综合各种优缺点现阶段 APM 使用最多的是 CLR Profile API 的方式进行方法注入，比如 Azure AppInsights、DataDog、Elastic 等.NET 探针都是使用这种方式。</p><p></p><p></p><h2>基于 CLR Profile API 实现 APM 探针原理</h2><p></p><p></p><p></p><h3>CLR Profile API 简介</h3><p></p><p></p><p>在下面的章节中和大家聊一聊基于 CLR Profile API 是如何实现方法注入，以及 CLR Profile API 是如何使用的。</p><p></p><p>聊到 CLR 探查器，我们首先就得知道 CLR 是什么，CLR（Common Language Runtime，公共语言运行时），可以理解为是托管运行 .NET 程序的平台，它提供了基础类库、线程、JIT 、GC 等语言运行的环境（如下图所示），它功能和 Java 的 JVM 有相似之处，但定位有所不同。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/0e/0e1c57f73e03f8a2b9c6dfb49621cdab.png\" /></p><p></p><p>.NET 程序、CLR 和操作系统的关系如下图所示：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/95/957a2d18cd0f221fcbdb7c8748990ca3.png\" /></p><p></p><p>那么 CLR 探查器是什么东西呢？根据 官方文档 的描述，CLR 探查器和相关 API 的支持从 .NET Framework 1.0 就开始提供，它是一个工具，可以使用它来监视另一个 .NET 应用程序的执行情况，它也是一个 ( .dll ) 动态链接库，CLR 在启动运行时加载探查器，CLR 会将一些事件发送给探查器，另外探查器也可以通过 Profile API 向 CLR 发送命令和获取运行时信息。下方是探查器和 CLR 工作的简单交互图：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/6e/6e957b266dc2fe9597602c13f55e3ec0.png\" /></p><p></p><p>ICorProfilerCallback提供的事件非常多，常用的主要是下方提到这几类：</p><p></p><p>CLR 启动和关闭事件应用程序域创建和关闭事件程序集加载和卸载事件模块加载和卸载事件COM vtable 创建和析构事件实时 (JIT) 编译和代码间距调整事件类加载和卸载事件线程创建和析构事件函数入口和退出事件异常托管和非托管代码执行之间的转换不同运行时上下文之间的转换有关运行时挂起的信息有关运行时内存堆和垃圾回收活动的信息 ICorProfilerInfo 提供了很多查询和命令的接口，主要是下方提到的这几类：方法信息接口类型信息接口模块信息接口线程信息接口CLR 版本信息接口Callback 事件设置接口函数 Hook 接口还有 JIT 相关的接口 通过 CLR Profile API 提供的这些事件和信息查询和命令接口，我们就可以使用它来实现一个无需改动原有代码的 .NET 探针。</p><p></p><p></p><h3>自动化探针执行过程</h3><p></p><p></p><p>APM 使用 .NET Profiler API 对应用程序进行代码插桩方法注入，以监控方法调用和性能指标从而实现自动化探针。下面详细介绍这一过程：</p><p></p><p>Profiler 注册：在启动应用程序时，.NET Tracer 作为一个分析器（profiler）向 CLR（Common Language Runtime）注册。这样可以让它在整个应用程序生命周期内监听和操纵执行流程。JIT 编译拦截：当方法被即时编译（JIT）时，Profiler API 发送事件通知。.NET Tracer 捕获这些事件，如 JITCompilationStarted，从而有机会在方法被编译之前修改其 IL（Intermediate Language）代码。代码修改插桩：通过操纵 IL 代码，.NET Tracer 在关键方法的入口和退出点插入跟踪逻辑。这种操作对原始应用程序是透明的，不需要修改源代码。跟踪逻辑通常包括记录方法调用数据、计时、捕获异常等。上下文传播：为了连接跨服务或异步调用的请求链，.NET Tracer 会将 Trace ID 和 Span ID 在分布式系统中进行传递。这使得在复杂的微服务架构中追踪请求变得更加容易。数据收集：插桩后的代码在运行期间会产生跟踪数据，包括方法调用时间、执行路径、异常信息等。这些数据会被封装成跟踪和跨度（spans），并且通过 APM Agent 发送到 APM 平台进行后续分析和可视化。</p><p></p><p>通过使用 .NET Profiler API 对应用程序进行方法注入插桩，APM 可以实现对 .NET 程序的详细性能监控，帮助开发者和运维人员发现并解决潜在问题。</p><p></p><p>第一步，向 CLR 注册分析器的步骤是很简单的，CLR 要求分析器需要实现 COM 组件接口标准，微软的 COM（Component Object Model）接口是一种跨编程语言的二进制接口，用于实现在操作系统中不同软件组件之间的通信和互操作。通过 COM 接口，组件可以在运行时动态地创建对象、调用方法和访问属性，实现模块化和封装。COM 接口使得开发人员能够以独立、可复用的方式构建软件应用，同时还有助于降低维护成本和提高开发效率。COM 一般需要实现以下接口：</p><p></p><p>接口（Interfaces）：COM 组件使用接口提供一套预定义的函数，这样其他组件就可以调用这些函数。每个接口都有一个唯一的接口标识（IID）。对象（Objects）：COM 对象是实现了一个或多个接口的具体实例。客户端代码通过对象暴露的接口与其进行交互。引用计数（Reference Counting）：COM 使用引用计数管理对象的生命周期。当一个客户端获取到对象的接口指针时，对象的引用计数加一；当客户端不再需要该接口时，引用计数减一。当引用计数减至零时，COM 对象会被销毁。查询接口（QueryInterface）：客户端可以通过 QueryInterface 函数获取 COM 对象所实现的特定接口。这个函数接收一个请求的接口 IID，并返回包含该接口指针的 HRESULT。类工厂（Class Factories）：为了创建对象实例，COM 使用类工厂。类工厂是实现了 IClassFactory 接口的对象，允许客户端创建新的对象实例。</p><p></p><p>比如 OpenTelemetry 中的class_factory.cpp就是声明了 COM 组件，其中包括了查询接口、引用计数以及创建实例对象等功能。</p><p></p><p>-230411084706645.png)</p><p></p><p>然后我们只需要设置三个环境变量，如下所示：</p><p></p><p>COR_ENABLE_PROFILING：将其设置为1，表示启用 CLR 分析器。COR_PROFILER: 设置分析器的 COM 组件 ID，使 CLR 能正确的加载分析器。COR_PROFILER_PATH_32/64: 设置分析器的路径，32 位或者是 64 位应用程序。</p><p></p><p>通过以上设置，CLR 就可以在启动时通过 COM 组件来调用分析器实现的函数，此时也代表着分析器加载完成。在 OpenTelemetry 和 data-dog 等 APM 中都有这样的设置。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/16/16f9560d632247432e7ee8766ee4ac74.png\" /></p><p>-230411085517744.png)</p><p></p><p>那后面的 JIT 编译拦截以及其它功能如何实现呢？我们举一个现实存在的例子，如果我们需要跟踪每一次 Reids 操作的时间和执行命令的内容，那么我们在应该修改StackExchange.Redis ExecuteAsyncImpl方法，从message中读取执行命令的内容并记录整个方法耗时。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e0/e04114de8a1d6db28fd77f6770404d72.png\" /></p><p></p><p>那么 APM 如何实现对Redis ExecuteAsyncImpl进行注入的？可以打开 dd-trace-dotnet 仓库也可以打开 opentelemetry-dotnet-instrumentation 仓库，这两者的方法注入实现原理都是一样的，只是代码实现上有一些细微的差别。这里我们还是以 dd-trace-dotnet 仓库代码为例。</p><p></p><p>打开tracer/src/Datadog.Trace/ClrProfiler/AutoInstrumentation目录，里面所有的源码都是通过方法注入的方式来实现 APM 埋点，有非常多的组件埋点的实现，比如 MQ 、Redis 、 CosmosDb 、Couchbase 等等。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/c9/c96e64f436dd3462a280f35f53467bbe.png\" /></p><p>打开 Redis 的文件夹，可以很容易找到 Redis 进行方法注入的源码，这相当于是一个 AOP 切面实现方法：</p><p><code lang=\"text\">[InstrumentMethod(\n        AssemblyName = \"StackExchange.Redis\",\n        TypeName = \"StackExchange.Redis.ConnectionMultiplexer\",\n        MethodName = \"ExecuteAsyncImpl\",\n        ReturnTypeName = \"System.Threading.Tasks.Task`1\",\n        ParameterTypeNames = new[] { \"StackExchange.Redis.Message\", \"StackExchange.Redis.ResultProcessor`1[!!0]\", ClrNames.Object, \"StackExchange.Redis.ServerEndPoint\" },\n        MinimumVersion = \"1.0.0\",\n        MaximumVersion = \"2.*.*\",\n        IntegrationName = StackExchangeRedisHelper.IntegrationName)]\n    [InstrumentMethod(\n        AssemblyName = \"StackExchange.Redis.StrongName\",\n        TypeName = \"StackExchange.Redis.ConnectionMultiplexer\",\n        MethodName = \"ExecuteAsyncImpl\",\n        ReturnTypeName = \"System.Threading.Tasks.Task`1\",\n        ParameterTypeNames = new[] { \"StackExchange.Redis.Message\", \"StackExchange.Redis.ResultProcessor`1[!!0]\", ClrNames.Object, \"StackExchange.Redis.ServerEndPoint\" },\n        MinimumVersion = \"1.0.0\",\n        MaximumVersion = \"2.*.*\",\n        IntegrationName = StackExchangeRedisHelper.IntegrationName)]\n    [Browsable(false)]\n    [EditorBrowsable(EditorBrowsableState.Never)]\n    public class ConnectionMultiplexerExecuteAsyncImplIntegration\n    {\n        /// </code></p><code lang=\"text\">\n        /// OnMethodBegin callback\n        /// </code><code lang=\"text\">\n        /// Type of the target\n        /// Type of the message\n        /// Type of the result processor\n        /// Type of the server end point\n        /// Instance value, aka `this` of the instrumented method.\n        /// Message instance\n        /// Result processor instance\n        /// State instance\n        /// Server endpoint instance\n        /// Calltarget state value\n        internal static CallTargetState OnMethodBegin(TTarget instance, TMessage message, TProcessor resultProcessor, object state, TServerEndPoint serverEndPoint)\n            where TTarget : IConnectionMultiplexer\n            where TMessage : IMessageData\n        {\n            string rawCommand = message.CommandAndKey ?? \"COMMAND\";\n            StackExchangeRedisHelper.HostAndPort hostAndPort = StackExchangeRedisHelper.GetHostAndPort(instance.Configuration);\n\n            Scope scope = RedisHelper.CreateScope(Tracer.Instance, StackExchangeRedisHelper.IntegrationId, StackExchangeRedisHelper.IntegrationName, hostAndPort.Host, hostAndPort.Port, rawCommand);\n            if (scope is not null)\n            {\n                return new CallTargetState(scope);\n            }\n\n            return CallTargetState.GetDefault();\n        }\n\n        /// \n        /// OnAsyncMethodEnd callback\n        /// \n        /// Type of the target\n        /// Type of the response, in an async scenario will be T of Task of T\n        /// Instance value, aka `this` of the instrumented method.\n        /// Response instance\n        /// Exception instance in case the original code threw an exception.\n        /// Calltarget state value\n        /// A response value, in an async scenario will be T of Task of T\n        internal static TResponse OnAsyncMethodEnd(TTarget instance, TResponse response, Exception exception, in CallTargetState state)\n        {\n            state.Scope.DisposeWithException(exception);\n            return response;\n        }\n    }</code><p></p><p></p><p>这段代码是一个用于监控和跟踪 StackExchange.Redis 库的 APM（应用性能监控）工具集成。它针对 StackExchange.Redis.ConnectionMultiplexer 类的 ExecuteAsyncImpl 方法进行了注入以收集执行过程中的信息。</p><p></p><p>使用了两个 InstrumentMethod 属性，分别指定 StackExchange.Redis 和 StackExchange.Redis.StrongName 两个程序集。属性包括程序集名称、类型名、方法名、返回类型名等信息以及版本范围和集成名称。ConnectionMultiplexerExecuteAsyncImplIntegration 类定义了 OnMethodBegin 和 OnAsyncMethodEnd 方法。这些方法在目标方法开始和结束时被调用。OnMethodBegin 方法创建一个新的 Tracing Scope，其中包含了与执行的 Redis 命令相关的信息（如 hostname, port, command 等）。OnAsyncMethodEnd 方法在命令执行结束后处理 Scope，在此过程中捕获可能的异常，并返回结果。而这个 CallTargetState state 中其实包含了上下文信息，有 Span Id 和 Trace Id ，就可以将其收集发送到 APM 后端进行处理。</p><p></p><p>但是，仅仅只有声明了一个 AOP 切面类不够，我们还需将这个 AOP 切面类应用到 Redis SDK 原有的方法中，这又是如何做到的呢？那么我们就需要了解一下 CLR Profiler API 实现方法注入的原理了。</p><p></p><p></p><h3>方法注入底层实现原理</h3><p></p><p></p><p>在不考虑 AOT 编译和分层编译特性，一个 .NET 方法一开始的目标地址都会指向 JIT 编译器，当方法开始执行时，先调用 JIT 编译器将 CIL 代码转换为本机代码，然后缓存起来，运行本机代码，后面再次访问这个方法时，都会走缓存以后得本机代码，流程如下所示：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/f2/f2d7f11f40f0fa268a20152cd489648d.png\" /></p><p></p><h4>拦截 JIT 编译</h4><p></p><p></p><p>由于方法一般情况下只会被编译一次，一种方法注入的方案就是在 JIT 编译前替换掉对应方法的 MethodBody ，这个在 CLR Profile API 中提供的一个关键的回调。</p><p></p><p>JITCompilationStarted: 通知探查器，即时编译器已经开始编译方法。 我们只需要订阅这个事件，就可以在方法编译开始时将对应的 MethodBody 修改成我们想要的样子，在里面进行 AOP 埋点即可。在 JITCompilationStarted 事件中重写方法 IL 的流程大致如下：</p><p>捕获JITCompilationStarted事件：当一个方法被即时编译（JIT）时，CLR（Common Language Runtime）会触发JITCompilationStarted事件。通过使用 Profiler API ，分析器可以订阅这个事件并得到一个回调。确定要修改的方法：在收到JITCompilationStarted事件回调时，分析器需要检查目标方法元数据，例如方法名称、参数类型和返回值类型等，来确定是否需要对该方法进行修改。获取方法的原始 IL 代码：如果确定要对目标方法进行修改，分析器需要首先获取该方法的原始 IL 代码。这可以通过使用 Profiler API 提供的GetILFunctionBody方法来实现。分析和修改 IL 代码：接下来，分析器需要解析原始 IL 代码，找到适当的位置以插入新的跟踪逻辑。这通常包括方法的入口点（开始执行时）和退出点（返回或抛出异常）。分析器会生成一段新的 IL 代码，用于记录性能指标、捕获异常等。替换方法的 IL 代码：将新生成的 IL 代码插入到原始 IL 代码中，并使用SetILFunctionBody方法替换目标方法的 IL 代码。这样，在方法被 JIT 编译成本地代码时，新的跟踪逻辑也会被包含进去。继续 JIT 编译：完成 IL 代码重写后，分析器需要通知 CLR 继续 JIT 编译过程。编译后的本地代码将包含插入的跟踪逻辑，并在应用程序运行期间执行。</p><p></p><p>我们来看看源码是如何实现的，打开 dd-trace-dotnet 开源仓库，回退到较早的发布版本，有一个 integrations.json 文件，在 dd-trace-dotnet 编译时会自动生成这个文件，当然也可以手动维护，在这个文件里配置了需要 AOP 切面的程序集名称、类和方法，在分析器启动时，就会加载 json 配置，告诉分析器应该注入那些方法。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/79/79ba3a0a298029e34a4a2db63e719b81.png\" /></p><p></p><p>接下来，我们找到cor_profiler.cpp文件并打开，这是实现 CLR 事件回调的代码，转到关于JITCompilationStarted事件的通知的处理的源码。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/36/3607e687eafc0c64807c18fa73251db4.png\" /></p><p></p><p>由于代码较长，简单的说一下这个函数它做了什么，函数主要用于在 .NET JIT（Just-In-Time）编译过程中执行一系列操作，例如插入启动钩子、修改 IL（中间语言）代码以及替换方法等，以下是它的功能：</p><p></p><p>函数检查 is_attached_ 和 is_safe_to_block 变量，如果不满足条件，则直接返回。使用互斥锁保护模块信息，防止在使用过程中卸载模块。通过给定的 function_id 获取模块 ID 和函数 token。根据模块 ID 查找模块元数据。检查是否已在CallTarget模式下注入加载器。如果符合条件且加载器尚未注入，则在AppDomain中的第一个 JIT 编译方法中插入启动钩子。在最低程度上，必须添加AssemblyResolve事件，以便从磁盘找到Datadog.Trace.ClrProfiler.Managed.dll 及其依赖项，因为它不再被提供为 NuGet 包。在桌面版 IIS 环境下，调用 AddIISPreStartInitFlags() 方法来设置预启动初始化标志。如果未启用CallTarget模式，将对 integrations.json 配置的方法进行插入和替换，并处理插入和替换调用。返回 S_OK 表示成功完成操作。其中有两个关键函数，可以对 .NET 方法进行插入和替换，分别是ProcessInsertionCalls和ProcessReplacementCalls。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/5a/5ad69bad8e1d0434d3d5ad3813f15084.png\" /></p><p></p><p>其中ProcessInsertionCalls用于那些只需要在方法前部插入埋点的场景，假设我们有以下原始 C# 类：</p><p><code lang=\"text\">public class TargetClass\n{\n    public void TargetMethod()\n    {\n        Console.WriteLine(\"This is the original method.\");\n    }\n}</code></p><p></p><p>现在，我们希望在TargetMethod的开头插入一个新的方法调用。让我们创建一个示例方法，并在WrapperClass中定义它： 修改后，插入InsertedMethod调用的TargetMethod将如下所示：</p><p></p><p><code lang=\"text\">public class TargetClass\n{\n    public void TargetMethod()\n    {\n        WrapperClass.InsertedMethod(); // 这是新插入的方法调用\n        Console.WriteLine(\"This is the original method.\");\n    }\n}\n\npublic class WrapperClass\n{\n    public static void InsertedMethod()\n    {\n        Console.WriteLine(\"This is the inserted method.\");\n    }\n}</code></p><p></p><p>请注意，上述示例是为了解释目的而手动修改的，实际上这种修改是通过操作 IL 代码来完成的。在CorProfiler::ProcessInsertionCalls方法中，这些更改是在 IL 指令级别上进行的，不会直接影响源代码。修改方法的 IL 代码.NET 官方提供了一个帮助类 ILRewriter ，ILRewriter 是一个用于操作 C# 程序中方法的中间语言（Intermediate Language，IL）代码的工具类。它会将方法的 IL 代码以链表的形式组织，让我们可以方便的修改 IL 代码，它通常用于以下场景：</p><p></p><p>代码注入：在方法体中插入、删除或修改 IL 指令。代码优化：优化 IL 代码以提高性能。执行 AOP（面向切面编程）：通过动态操纵字节码实现横切关注点（如日志记录、性能度量等）。</p><p></p><p>ILRewriter 类提供了一系列方法用于读取、修改和写回 IL 指令序列。例如，在上述CorProfiler::ProcessInsertionCalls方法中，我们使用 ILRewriter 对象导入 IL 代码，执行所需的更改（如插入新方法调用），然后将修改后的 IL 代码导出并应用到目标方法上。这样可以实现对程序行为的运行时修改，而无需直接更改源代码。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/61/611b28bff9b49f51f00d7d698b39d56b.png\" /></p><p></p><p>另一个ProcessReplacementCalls方法就是将原有的方法调用实现一个 Proxy ，适用于那些需要捕获异常获取方法返回值的场景，这块代码比较复杂，假设我们有以下 C# 代码，其中我们想要替换OriginalMethod()的调用：</p><p></p><p><code lang=\"text\">public class TargetClass\n{\n    public int OriginalMethod(int a, int b)\n    {\n        return a * b;\n    }\n}\n\npublic class CallerClass\n{\n    public void CallerMethod()\n    {\n        TargetClass target = new TargetClass();\n        int result = target.OriginalMethod(3, 4);\n        Console.WriteLine(result);\n    }\n}</code></p><p></p><p>在应用方法调用替换后，CallerMethod()将调用自定义的替换方法WrapperMethod()而不是OriginalMethod()。例如，我们可以使用以下替换方法：</p><p></p><p><code lang=\"text\">public class WrapperClass\n{\n    public static int WrapperMethod(TargetClass instance, int opCode, int mdToken, long moduleVersionId, int a, int b)\n    {\n        Console.WriteLine(\"Method call replaced.\");\n        return instance.OriginalMethod(a, b);\n    }\n}</code></p><p></p><p>经过 IL 修改后，CallerMethod()看起来大致如下：</p><p></p><p><code lang=\"text\">public void CallerMethod()\n{\n    TargetClass target = new TargetClass();\n    int opCode = /* Original CALL or CALLVIRT OpCode */;\n    int mdToken = /* Metadata token for OriginalMethod */;\n    long moduleVersionId = /* Module version ID pointer */;\n\n    // Call the wrapper method instead of the original method\n    int result = WrapperClass.WrapperMethod(target, opCode, mdToken, moduleVersionId, 3, 4);\n\n    Console.WriteLine(result);\n}</code></p><p></p><p>现在CallerMethod()将调用WrapperMethod()，在这个例子中，我们记录了一条替换消息，然后继续调用OriginalMethod()。正如所述，通过捕获JITCompilationStarted事件并对中间语言（IL）进行改写，我们修改方法行为的基本原理。在 .NET Framework 4.5 之前的版本中，这种方式广泛应用于方法改写和植入埋点，从而实现 APM 的自动化探针。然而，此方法也存在以下一些不足之处：</p><p></p><p>不支持动态更新：JITCompilationStarted 在方法被 JIT 编译之前触发，这意味着它只能在初次编译过程中修改 IL。更大的性能影响：由于JITCompilationStarted是一个全局事件，它会在每个需要 JIT 编译的方法被调用时触发。因此，如果在此事件中进行 IL 修改，可能会对整个应用程序产生更大的性能影响。无法控制执行时机：在JITCompilationStarted中重写 IL 时，您不能精确控制何时对某个方法应用更改。某些情况下，运行时可能选择跳过 JIT 编译过程，例如对于 NGEN（Native Image Generator，俗称 AOT 编译）生成的本地映像，此时无法捕获到JITCompilationStarted事件。在多线程环境下，可能会出现竞争条件，导致一些方法执行的是未更新的代码。</p><p></p><p>但是我们也无法再其它时间进行重写，因为 JIT 一般情况下只会编译一次，JIT 已经完成编译以后修改方法 IL 不会再次 JIT ，修改也不会生效。在 .NET Framework 4.5 诞生之前，我们并未拥有更为优美的途径来实现 APM 自动化探测。然而，随着 .NET Framework 4.5 的降临，一条全新的路径终于展现在我们面前。</p><p></p><p></p><h4>重新 JIT 编译</h4><p></p><p></p><p>上文中提到了捕获JITCompilationStarted事件时进行方法重写的种种缺点，于是在.NET 4.5 中，新增了一个名为RequestReJIT的方法，它允许运行时动态地重新编译方法。RequestReJIT主要用于性能分析和诊断工具，在程序运行过程中，可以为指定的方法替换新的即时编译（JIT）代码，以便优化性能或修复 bug。</p><p></p><p>RequestReJIT提供了一种强大的机制，使开发人员能够在不重启应用程序的情况下热更新代码逻辑。这在分析、监视及优化应用程序性能方面非常有用。它可以在程序运行时动态地替换指定方法的 JIT 代码，而无需关心方法是否已经被编译过。RequestReJIT减轻了多线程环境下的竞争风险，并且可以处理 NGEN 映像中的方法。通过提供这个强大的机制，RequestReJIT使得性能分析和诊断工具能够更有效地优化应用程序性能及修复 bug。</p><p></p><p>使用RequestReJIT重写方法 IL 的流程如下：</p><p></p><p>Profiler 初始化：当.NET 应用程序启动时，分析器（profiler）会利用 Profiler API 向 CLR（Common Language Runtime）注册。这允许分析器在整个应用程序生命周期内监听和操纵代码执行流程。确定要修改的方法：分析器需要识别哪些方法需要进行修改。这通常是通过分析方法元数据（如方法名称、参数类型和返回值类型等）来判断的。为目标方法替换 IL 代码：首先，分析器获取目标方法的原始 IL 代码，并在适当位置插入新的跟踪逻辑。接着，使用 SetILFunctionBody 方法将修改后的 IL 代码设置为目标方法的新 IL 代码。请求重新 JIT 编译：使用RequestReJIT方法通知 CLR 重新编译目标方法。此时，CLR 会触发ReJITCompilationStarted事件。捕获ReJITCompilationStarted事件：分析器订阅ReJITCompilationStarted事件，在事件回调中获取到修改后的 IL 代码，订阅结束事件，分析器可以获取本次重新编译是否成功。生成新的本地代码：CLR 会根据修改后的 IL 代码重新进行 JIT 编译，生成新的本地代码。这样，新的 JIT 代码便包含了插入的跟踪逻辑。执行新的本地代码：之后，当目标方法被调用时，将执行新生成的本地代码。这意味着插入的跟踪逻辑会在应用程序运行期间起作用，从而收集性能数据和诊断信息。</p><p></p><p>有了RequestJIT方法，我们可以在任何时间修改方法 IL 然后进行重新编译，无需拦截 JIT 执行事件，在新版的 dd-trace 触发方法注入放到了托管代码中，托管的 C# 代码直接调用非托管的分析器 C++ 代码进行方法注入，所以不需要单独在 json 文件中配置。</p><p></p><p>取而代之的是InstrumentationDefinitions.g.cs文件，在编译时会扫描所有标记了InstrumentMethod特性的方法，然后自动生成这个类。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/63/6352cdfc77c7af0996477a494bdded90.png\" /></p><p></p><p>当分析器启动时，会调用Instrumentation.cs类中Initialize()方法，在这个方法内部就会和分析器通讯，将需要进行方法注入的方法传递给分析器。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/05/053b3a63072f37f248a1e4dd79d376d7.png\" /></p><p></p><p>因为需要和分析器进行通讯，所以需要在分析器中导出可供 C# 代码调用的函数，源码中是interop.cpp导出了 C# 和 C++ 代码互操作的几个函数，同样在 C# 中也要使用P/Invoke技术来定义一个调用类。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ea/eaa48e6a526838534fa2b27a29016560.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/f7/f73b44d12b6b3433c7f28c149144cde8.png\" /></p><p>分析器接受到需要注入的方法信息以后，会将其加入到方法注入的队列中，然后会重写对应方法至下方这种形式：</p><p><code lang=\"text\">/// &lt;摘要&gt;\n/// 用calltarget实现重写目标方法体。（这个函数是由ReJIT处理程序触发的）生成的代码结构：\n///\n/// - 为 TReturn（如果非 void 方法）、CallTargetState、CallTargetReturn/CallTargetReturn 和 Exception 添加局部变量\n/// - 初始化局部变量\n\ntry\n{\n  try\n  {\n    try\n    {\n      - 使用对象实例（对于静态方法则为 null）和原始方法参数调用 BeginMethod\n      - 将结果存储到 CallTargetState 局部变量中\n    }\n    catch 当异常不是 Datadog.Trace.ClrProfiler.CallTarget.CallTargetBubbleUpException 时\n    {\n      - 调用 LogException(Exception)\n    }\n\n    - 执行原始方法指令\n      * 所有RET指令都替换为 LEAVE_S。对于非void方法，堆栈上的值首先存储在 TReturn 局部变量中。\n  }\n  catch (Exception)\n  {\n    - 将异常存储到 Exception 局部变量中\n    - 抛出异常\n  }\n}\nfinally\n{\n  try\n  {\n    - 使用对象实例（对于静态方法则为null），TReturn局部变量（如果非 void 方法），CallTargetState局部变量和 Exception 局部变量调用 EndMethod\n    - 将结果存储到 CallTargetReturn/CallTargetReturn 局部变量中\n    - 如果是非void方法，将 CallTargetReturn.GetReturnValue() 存储到 TReturn 局部变量中\n  }\n  catch 当异常不是 Datadog.Trace.ClrProfiler.CallTarget.CallTargetBubbleUpException 时\n  {\n    - 调用 LogException(Exception)\n  }\n}\n\n- 如果非 void 方法，则加载 TReturn 局部变量\n- RET</code></p><p>/// &lt;摘要&gt;/// 用 calltarget 实现重写目标方法体。（这个函数是由 ReJIT 处理程序触发的）生成的代码结构：////// - 为 TReturn（如果非 void 方法）、CallTargetState、CallTargetReturn/CallTargetReturn 和 Exception 添加局部变量/// - 初始化局部变量</p><p></p><p>try{try{try{- 使用对象实例（对于静态方法则为 null）和原始方法参数调用 BeginMethod- 将结果存储到 CallTargetState 局部变量中}catch 当异常不是 Datadog.Trace.ClrProfiler.CallTarget.CallTargetBubbleUpException 时{- 调用 LogException(Exception)}</p><p></p><p><code lang=\"text\">- 执行原始方法指令\n  * 所有 RET 指令都替换为 LEAVE_S。对于非 void 方法，堆栈上的值首先存储在 TReturn 局部变量中。\n</code></p><p></p><p>最后请求RequestReJIT来重新编译进行 JIT 编译，完成了整个方法的注入。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/90/906ef3a05eb5e5846001f98feb787e15.png\" /></p><p></p><p></p><h2>总结</h2><p></p><p></p><p>以上就是目前 .NET 上 APM 主流的无侵入自动化探针的实现原理的简单科普，总体实现是很复杂的，里面还有诸多细节在本文中并未提到。然而，通过了解这些基本概念和技术原理，希望能为您提供一个较为清晰的认识，让您更好地理解 APM 无侵入式探针是如何在 .NET 平台工作的。</p><p></p><p>如果大家对此话题有兴趣，并希望建立更深入、全面的了解，那么后续可以更新下一篇文章，在接下来的内容中，我们可以实现一个简单版本的 .NET 无侵入探针，并将深入探讨相关实现细节以及如何在实际场景中应用这些方法。</p><p></p><p></p><h2>参考文献</h2><p></p><p></p><p>.NET 探查器文档</p><p></p><p>深入 Java 自动化探针技术的原理和实践</p><p></p><p></p><h1>作者介绍</h1><p></p><p></p><p>李时 (InCerry)，微软最有价值专家，现就职于同程旅行</p><p></p><p>• 欢迎关注 OpenTelemetry 中国官方社区 Github https://github.com/open-telemetry/docs-cn• 加入技术中国官方技术交流群，联系社区发起人微信 nizhanali</p>",
    "publish_time": "2023-04-25 11:00:08",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]