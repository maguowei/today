[
  {
    "title": "Java近期新闻：单查询加载、GraalVM、GlassFish、JReleaser、Quarkus、Micronaut",
    "url": "https://www.infoq.cn/article/wti8XjbwvZdWSr79kOc6",
    "summary": "<p></p><h4>OpenJDK</h4><p></p><p><a href=\"https://jcp.org/en/home/index\">Java社区进程</a>\"（JCP）执行委员会<a href=\"https://jcp.org/en/jsr/results?id=6356\">投票</a>\"通过了JSR 396（<a href=\"https://openjdk.org/projects/jdk/21/spec/\">Java SE 21平台</a>\"），向着计划在2023年9月19日发布的GA版本继续迈进。</p><p>JEP 442（<a href=\"https://openjdk.org/jeps/442\">外部函数和内存API第3个预览版</a>\"）将在即将发布的JDK 21中交付，JEP草案8310626（<a href=\"https://openjdk.org/jeps/8310626\">外部函数和内存API</a>\"）预计将在JDK 22中<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-August/008061.html\">交付</a>\"，那是<a href=\"https://openjdk.org/projects/panama/\">Panama项目</a>\"的主要特性之一。该项目将JVM与定义明确的“外部”（非Java） API连接起来，其中包括许多C程序员常用的接口。</p><p><a href=\"https://www.linkedin.com/in/minborg/\">Per-Åke Minborg</a>\"是Oracle的一名技术顾问。他在<a href=\"http://minborgsjavapot.blogspot.com/2023/08/java-22-panama-ffm-provides-massive.html\">这篇博文</a>\"中讨论了外部函数和内存API的性能优势。Minborg提供了一个关于字符串转换的基准测试：在JDK 21和JDK 22中使用该API vs. 使用旧的Java本机接口（JNI）调用。</p><p></p><h4>JDK 21</h4><p></p><p><a href=\"https://github.com/openjdk/jdk/releases/tag/jdk-21%2B35\">Build 35</a>\"仍然是JDK 21<a href=\"https://jdk.java.net/20/\">早期访问构建</a>\"的当前构建。要了解关于这个版本的更多细节，请查看<a href=\"https://jdk.java.net/21/release-notes\">发布说明</a>\"。</p><p></p><h4>JDK 22</h4><p></p><p>JDK 22<a href=\"https://jdk.java.net/22/\">早期访问构建</a>\"<a href=\"https://github.com/openjdk/jdk/releases/tag/jdk-22%2B13\">Build 13</a>\"在上周发布，其中包括Build 12的<a href=\"https://github.com/openjdk/jdk/compare/jdk-22%2B12...jdk-22%2B13\">更新</a>\"，主要是修复了各种<a href=\"https://bugs.openjdk.org/issues/?jql=project%20%3D%20JDK%20AND%20fixversion%20%3D%2022%20and%20%22resolved%20in%20build%22%20%3D%20b13%20order%20by%20component%2C%20subcomponent\">问题</a>\"。要了解关于这个版本的更多细节，请查看<a href=\"https://jdk.java.net/22/release-notes\">发布说明</a>\"。</p><p>对于<a href=\"https://openjdk.org/projects/jdk/22/\">JDK 22</a>\"和<a href=\"https://openjdk.java.net/projects/jdk/21/\">JDK 21</a>\"，我们鼓励开发人员通过<a href=\"https://bugreport.java.com/bugreport/\">Java Bug数据库</a>\"报告Bug。</p><p></p><h4>GraalVM</h4><p></p><p>在迈向1.0版本的道路上，Oracle实验室发布了<a href=\"https://github.com/graalvm/native-build-tools/blob/master/README.md\">Native Build Tools</a>\"的<a href=\"https://github.com/graalvm/native-build-tools/releases/tag/0.9.25\">0.9.25版本</a>\"。这是一个GraalVM项目，其中包含与GraalVM原生镜像进行互操作的插件。这个最新版本将依赖项升级到了<a href=\"https://github.com/oracle/graalvm-reachability-metadata/blob/master/README.md\">GraalVM Reachability Metadata Repository</a>\" 0.3.4。要了解关于这个版本的更多细节，请查看<a href=\"https://github.com/graalvm/native-build-tools/compare/0.9.24...0.9.25\">变更日志</a>\"。</p><p></p><h4>Spring Framework</h4><p></p><p>为了解决N+1问题，Spring Data团队<a href=\"https://spring.io/blog/2023/08/31/this-is-the-beginning-of-the-end-of-the-n-1-problem-introducing-single-query\">引入</a>\"了单查询加载（Single Query Loading）。这是一种通过单个SELECT语句加载任意聚合的技术。随着<a href=\"https://spring.io/projects/spring-data-jdbc\">Spring Data JDBC</a>\" 3.2.0-M2的发布，该团队宣称，这项新技术是“解决N+1问题的开始”。类RelationalMappingContext中新增了一个方法setSingleQueryLoadingEnabled(true)，用于启用单查询加载。目前，该特性只适用于简单聚合（只包含一个聚合根和其他实体的单个集合）。但其团队承诺，<a href=\"https://github.com/spring-projects/spring-data-relational/issues/1445\">未来的版本</a>\"将改进这一限制。</p><p></p><h4>Quarkus</h4><p></p><p>Red Hat<a href=\"https://quarkus.io/blog/quarkus-3-3-1-released/\">发布</a>\"了<a href=\"https://quarkus.io/\">Quarkus</a>\"的3.3.1版本，带来了依赖项升级和一些值得注意的变化，其中包括：修复了MicrometerRecorder类中潜在的NullPointerException；在VertxPoolMetrics类中新增计数器rejected ，用来记录被拒绝的请求数；修复了VertxHttpExporter 类解析/v1/traces 端点有误的问题。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/quarkusio/quarkus/releases/tag/3.3.1\">变更日志</a>\"。</p><p>类似的，Quarkus 3.2.5.Final<a href=\"https://quarkus.io/blog/quarkus-3-2-5-final-released/\">也带来了一些值得注意的变化</a>\"，其中包括：修复了当CsrfRequestResponseReactiveFilter类检查媒体类型时，<a href=\"https://quarkus.io/extensions/io.quarkus/quarkus-csrf-reactive\">跨站点请求伪造</a>\"扩展中潜在的NullPointerException；禁用ReactiveMongodbPanacheResourceTest类中的testMoreRepositoryFunctionalities()方法；修复了一个在多个线程中调用bean的写锁定方法时发生死锁的问题，其中该方法调用了同一bean中的另一个写锁定方法。要了解关于这个版本的更多细节，请查看<a href=\"https://github.com/quarkusio/quarkus/releases/tag/3.2.5.Final\">变更日志</a>\"。</p><p>最后，Quarkus 2.16.10.Final<a href=\"https://quarkus.io/blog/quarkus-2-16-10-final-released/\">发布</a>\"，将依赖项<a href=\"https://github.com/xerial/snappy-java/blob/master/README.md\">Snappy Java</a>\"从版本1.1.8.4升级到版本1.1.10.1。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/quarkusio/quarkus/releases/tag/2.16.10.Final\">变更日志</a>\"。</p><p></p><h4>Micronaut</h4><p></p><p>Micronaut基金会<a href=\"https://micronaut.io/2023/09/01/micronaut-framework-4-1-0-released/\">发布</a>\"了<a href=\"https://micronaut.io/\">Micronaut Framework</a>\" 4.1.0版本，带来了<a href=\"https://github.com/micronaut-projects/micronaut-core//releases/tag/v4.1.3\">Micronaut Core 4.1.3</a>\"和一些新特性，其中包括：<a href=\"https://docs.micronaut.io/latest/guide/#beanMappers\">Bean映射器</a>\"自动创建一种类型与另一种类型的映射；新增一个Introspection Builder，如果一个类型只能通过构造器模式来构造，则可以利用@Introspected注解的builder成员来生成一个动态构造器；针对使用<a href=\"https://docs.micronaut.io/latest/guide/#ksp\">Kotlin符号处理</a>\"（KSP）构建Micronaut应用程序做了改进。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/micronaut-projects/micronaut-platform/releases/tag/v4.1.0\">发布说明</a>\"。</p><p>Microaut Frameworkd 4.0.6（<a href=\"https://micronaut.io/2023/08/31/micronaut-framework-4-0-6-released/\">第6个维护版本</a>\"）升级了以下模块：<a href=\"https://micronaut-projects.github.io/micronaut-spring/latest/guide/\">M</a>\"<a href=\"https://micronaut-projects.github.io/micronaut-spring/latest/guide/\">icro</a>\"<a href=\"https://micronaut-projects.github.io/micronaut-spring/latest/guide/\">n</a>\"<a href=\"https://micronaut-projects.github.io/micronaut-spring/latest/guide/\">aut for Spring</a>\"、<a href=\"https://micronaut-projects.github.io/micronaut-jaxrs/latest/guide/\">M</a>\"<a href=\"https://micronaut-projects.github.io/micronaut-jaxrs/latest/guide/\">icro</a>\"<a href=\"https://micronaut-projects.github.io/micronaut-jaxrs/latest/guide/\">n</a>\"<a href=\"https://micronaut-projects.github.io/micronaut-jaxrs/latest/guide/\">aut JAX-RS</a>\"、<a href=\"https://micronaut-projects.github.io/micronaut-servlet/latest/guide/\">M</a>\"<a href=\"https://micronaut-projects.github.io/micronaut-servlet/latest/guide/\">icro</a>\"<a href=\"https://micronaut-projects.github.io/micronaut-servlet/latest/guide/\">n</a>\"<a href=\"https://micronaut-projects.github.io/micronaut-servlet/latest/guide/\">aut Servlet</a>\"、<a href=\"https://micronaut-projects.github.io/micronaut-validation/latest/guide/\">M</a>\"<a href=\"https://micronaut-projects.github.io/micronaut-validation/latest/guide/\">icro</a>\"<a href=\"https://micronaut-projects.github.io/micronaut-validation/latest/guide/\">n</a>\"<a href=\"https://micronaut-projects.github.io/micronaut-validation/latest/guide/\">aut Validation</a>\"、<a href=\"https://micronaut-projects.github.io/micronaut-redis/latest/guide/\">M</a>\"<a href=\"https://micronaut-projects.github.io/micronaut-redis/latest/guide/\">icro</a>\"<a href=\"https://micronaut-projects.github.io/micronaut-redis/latest/guide/\">n</a>\"<a href=\"https://micronaut-projects.github.io/micronaut-redis/latest/guide/\">aut Redis</a>\"、<a href=\"https://micronaut-projects.github.io/micronaut-tracing/latest/guide/\">M</a>\"<a href=\"https://micronaut-projects.github.io/micronaut-tracing/latest/guide/\">icro</a>\"<a href=\"https://micronaut-projects.github.io/micronaut-tracing/latest/guide/\">n</a>\"<a href=\"https://micronaut-projects.github.io/micronaut-tracing/latest/guide/\">aut Tracing</a>\"、<a href=\"https://micronaut-projects.github.io/micronaut-aws/latest/guide/\">M</a>\"<a href=\"https://micronaut-projects.github.io/micronaut-aws/latest/guide/\">icro</a>\"<a href=\"https://micronaut-projects.github.io/micronaut-aws/latest/guide/\">n</a>\"<a href=\"https://micronaut-projects.github.io/micronaut-aws/latest/guide/\">aut AWS</a>\"和<a href=\"https://micronaut-projects.github.io/micronaut-kafka/latest/guide/\">M</a>\"<a href=\"https://micronaut-projects.github.io/micronaut-kafka/latest/guide/\">icro</a>\"<a href=\"https://micronaut-projects.github.io/micronaut-kafka/latest/guide/\">n</a>\"<a href=\"https://micronaut-projects.github.io/micronaut-kafka/latest/guide/\">aut Kafka</a>\"。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/micronaut-projects/micronaut-platform/releases/tag/v4.0.6\">发布说明</a>\"。</p><p></p><h4>WildFly</h4><p></p><p><a href=\"https://www.wildfly.org/\">WildFly</a>\" 29.0.1<a href=\"https://www.wildfly.org/news/2023/08/23/WildFly2901-Released/\">发布</a>\"，带来了组件升级（从Quickstarts 29.x迁移到BOMs and WildFly Server 29.0.1.Final）和一些值得注意的Bug修复，其中包括：新依赖项org.jboss.jts to jdk.jconsole 导致WildFly 29.0.0不能在Eclipse Temurin 17.0.8上启动的问题；将依赖项升级到<a href=\"https://github.com/square/okio/blob/master/README.md\">Square Okio</a>\" 3.4.0，以解决<a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-3635\">CVE-2023-3635</a>\"漏洞（可能导致Okio客户端在通过GzipSource类处理精心制作的GZIP归档文件时发生拒绝服务）；升级到WildFly 29.0.0后与MicroProfile RestClient和Jakarta CDI规范有关的问题。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/wildfly/wildfly/releases/tag/29.0.1.Final\">发布说明</a>\"。</p><p></p><h4>Hibernate</h4><p></p><p><a href=\"https://hibernate.org/orm/\">Hibernate ORM</a>\"的6.3.0和6.2.8版本<a href=\"https://in.relation.to/2023/08/31/orm-630/\">发布</a>\"，带来了一些值得注意的变化，其中包括：初步支持Jakarta EE 11的<a href=\"https://jakarta.ee/specifications/persistence/3.2/\">Jakarta Persistence 3.2</a>\"规范，包括明确了HQL/JPQL查询中的<a href=\"https://hibernate.atlassian.net/browse/HHH-17076\">数值字面量类型</a>\"；新的<a href=\"https://docs.jboss.org/hibernate/orm/6.3/introduction/html_single/Hibernate_Introduction.html\">Hibernate 6入门指南</a>\"；<a href=\"https://docs.jboss.org/hibernate/orm/6.3/introduction/html_single/Hibernate_Query_Language.html\">Hibernate查询语言新语法和新特性指南</a>\"；作为JPA静态元模型生成器的一部分，能够为命名查询生成DAO风格的方法；生成器可以处理任意方法，而且创建出的查找器方法与使用新注解@Find的查询方法类似。</p><p><a href=\"https://hibernate.org/reactive/\">Hibernate Reactive</a>\" 2.0.5.Final<a href=\"https://in.relation.to/2023/09/01/hibernate-reactive-2_0_5_Final/\">发布</a>\"，兼容Hibernate ORM 6.2.8.Final和Vert.SQL driver 4.4.5。值得注意的变化包括：MutinyGenerator类中定义的generate()方法返回类型从Uni更改为Uni<!--?-->；增加了针对@TimeZoneStorage注解的测试；新增ParametersProcessorTest类来修复OracleParameters、PostgresParameters 和SQLServerParameters类处理参数时的转义问题。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/hibernate/hibernate-reactive/releases/tag/2.0.5\">发布说明</a>\"。<p></p><p></p><h4>Eclipse基金会</h4><p></p><p>Eclipse <a href=\"https://glassfish.org/\">GlassFish</a>\" 7.0.8是<a href=\"https://twitter.com/OmniFishEE/status/1696188972630737402\">第8个维护版本</a>\"。该版本初步支持JDK 21，并优化了CDI扩展，减少了非必要的ProcessAnnotatedType接口处理程序调用。它还带来了一些值得注意的Bug修复，包括：RWLockDataStructureTest类中的一个JDK 11兼容性问题；多jar文件兼容性问题；管理员用户将密码改为空时的Admin Console行为。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/eclipse-ee4j/glassfish/releases/tag/7.0.8\">发布说明</a>\"。</p><p>Eclipse <a href=\"https://vertx.io/\">Vert.x</a>\" 4.4.5<a href=\"https://vertx.io/blog/eclipse-vert-x-4-4-5/\">发布</a>\"，带来了依赖项升级和一些值得注意的变化，其中包括：改进ForwardedParser类，支持未用方括号括起来的IPV6地址；在实现WebSocketBase接口时，将帧聚合器与帧处理程序解耦；修复了HTTP/2在超时时抛出HttpClosedException而不是TimeoutException的问题。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/vert-x3/wiki/wiki/4.4.5-Release-Notes\">发布说明</a>\"和<a href=\"https://github.com/vert-x3/wiki/wiki/4.4.5-Deprecations-and-breaking-changes\">弃用及破坏性变更清单</a>\"。</p><p>Eclipse <a href=\"https://github.com/eclipse/jkube/blob/master/README.md\">JKube</a>\" 1.14.0<a href=\"https://blog.marcnuri.com/eclipse-jkube-1-14\">发布</a>\"（一个用于Kubernetes和OpenShift的Java工具和插件实用程序），带来了Bug修复、改进，并支持Gradle 8、Helidon、Spring Boot <a href=\"https://docs.spring.io/spring-boot/docs/2.3.0.RELEASE/maven-plugin/reference/html/#repackage-layers\">Layered Jar</a>\"和向OCI注册中心推送<a href=\"https://helm.sh/\">Helm</a>\" chart。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/eclipse/jkube/releases/tag/v1.14.0\">发布说明</a>\"。</p><p></p><h4>JReleaser</h4><p></p><p><a href=\"https://jreleaser.org/\">JR</a>\"<a href=\"https://jreleaser.org/\">elease</a>\"<a href=\"https://jreleaser.org/\">r</a>\" 1.8.0版本<a href=\"https://andresalmiray.com/jreleaser-1-8-0-has-been-released/\">发布</a>\"（一个简化项目发布的Java实用程序），提供了文档改进、依赖项升级和一些值得注意的变化，其中包括：为缺失的announcer创建默认模板；升级到最新的SDKMan端点；改进GitHub 422错误响应的错误处理。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/jreleaser/jreleaser/releases/tag/v1.8.0\">发布说明</a>\"。</p><p>值得注意的是，SLSA（<a href=\"https://slsa.dev/\">Supply Chain Levels for Software Artifacts</a>\"）已经<a href=\"https://slsa.dev/blog/2023/08/bring-your-own-builder-github\">宣布</a>\"与JReleaser、Maven和Gradle的贡献者合作<a href=\"https://slsa.dev/blog/2023/04/slsa-v1-final\">发布</a>\"SLSA 1.0。这验证了GitHub Actions BYOB（<a href=\"https://github.com/slsa-framework/slsa-github-generator/tree/main#build-your-own-builder\">Build Your Own Builder</a>\"）框架的设计，并证明了它的灵活性。</p><p></p><h4>OpenXava</h4><p></p><p><a href=\"https://openxava.org/\">OpenXava</a>\" 7.1.5<a href=\"https://openxava.org/blog/openxava-7.1.5-released\">发布</a>\"，带来了一些显著的变化，其中包括：新增CompositeFilter类，用于在 Tab.setFilter()中同时使用两个IFilter，也可作为 @Tab注解的IFilter；新增环境变量XAVA_CALENDAR_VIEWEVENT_ACTION，用于定义日历单击事件的动作；修复在 @Editor(\"ValidValuesRadioButton\")中使用枚举时会在日志中产生IndexOutOfBoundsException异常的问题。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/openxava/openxava/releases/tag/7.1.5\">发布说明</a>\"。</p><p>&nbsp;</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/09/java-news-roundup-aug28-2023/\">https://www.infoq.com/news/2023/09/java-news-roundup-aug28-2023/</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/3EO246XRyUiAlTfku9mv\">Java 近期新闻：JDK 21 RC1、Apache Camel 4.0、Payara Platform、Apache Tomcat、Micronaut</a>\"</p><p><a href=\"https://www.infoq.cn/article/ClW8eLeOxRUqqpHWOJCC\">Java ZGC 垃圾收集器全面增强</a>\"</p><p></p></p>",
    "publish_time": "2023-09-12 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Ruby on Rails的创始人将TypeScript从Turbo框架中移除，引起社区不满",
    "url": "https://www.infoq.cn/article/N8QIk2frWWIJbHCMrA0W",
    "summary": "<p>Ruby on Rails 的创建者 David Heinemeier Hansson（DHH） 从即将发布的 Turbo 框架第 8 版中删除了 TypeScript，并声称从未是它的粉丝。许多 Turbo 用户抗议说决定太仓促，不欢迎这种变化。</p><p>&nbsp;</p><p>在移除 TypeScript 的 GitHub <a href=\"https://github.com/hotwired/turbo/pull/971\">pull request</a>\" 上有一条评论认为，这个举措“对于库的用户和贡献者都是一种倒退”。截止目前，这条评论已经有357个赞，仅8个踩，显示了广泛的支持。</p><p>&nbsp;</p><p><a href=\"https://turbo.hotwired.dev/\">Turbo</a>\" 是一个用于传递 HTML 页面的框架，旨在“显著减少自定义 JavaScript 的数量”，并由 Hannson 的公司 37signals 赞助，其产品包括 Basecamp 项目管理平台和 Hey 消息系统。Turbo 是 Hotwire 的引擎，Hotwire 是“HTML over the wire”的缩写，因为它更喜欢发送 HTML 本身而不是 JSON 数据和 JavaScript 代码。</p><p>&nbsp;</p><p>尽管 Turbo 并不属于那批最受欢迎的框架，但 Ruby on Rails 很有名，像 GitHub 和 Shopify 这样的主要网站都在使用它。</p><p>&nbsp;</p><p>Hansson <a href=\"https://world.hey.com/dhh/turbo-8-is-dropping-typescript-70165c01\">发文</a>\"称 TypeScript “通过添加微不足道的类型技巧，让我的开发体验变得更加糟糕，而且频繁引发很多困扰。本应简单的事情反而变得很困难。”</p><p>围绕着 Turbo 开源项目的社区大多感到困惑和失望，不仅是因为变更本身，还因为变更的方式。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/c3/c305bb08962171e1598bd37ec9bf28a2.png\" /></p><p></p><p>\"回到 JS 意味着许多 Hotwire 生态系统的包都会受到影响。当前的所有开放 PR 都已完全过时。从我的角度来看，其中一些是非常好的候选项。IDE 不再提供与以前一样的自动补全功能，\" <a href=\"https://github.com/hotwired/turbo/pull/971#issuecomment-1708302536\">一位用户表示</a>\"。</p><p>&nbsp;</p><p>另一位用户<a href=\"https://github.com/hotwired/turbo/pull/971#pullrequestreview-1613489798\">抱怨</a>\"说：“匆忙进行这个重要的更改，忽视了所有（我是说所有）的 PR 评论...这会开一个坏头。Ruby on Rails 也会像这样来开发吗？取决于一个人的心血来潮？”</p><p>&nbsp;</p><p>Hansson <a href=\"https://github.com/hotwired/turbo/pull/971#issuecomment-1708430006\">回应</a>\"道：“非常感谢那些更喜欢 TypeScript 的贡献者。这只是争论之一，其中的论点不太可能改变任何人的根本立场，所以我不会尝试这样做。”</p><p>&nbsp;</p><p>他补充说：“现在，我们在 37signals 写的所有客户端代码都是纯 JavaScript，内部库也是如此。这次变更意味着保持一致。”</p><p>&nbsp;</p><p>微软的 Anders Hejlsberg 出于他的信念发明了 TypeScript，即如果使用强类型语言编写复杂应用程序，它们将更加健壮且易于维护。TypeScript 在编程社区的普及，表明了许多人持相同观点，而且一些来自 TypeScript 的概念，包括类型注解，也正在逐渐融入 ECMAScript，即 JavaScript 官方标准。无论开发者的选择如何，TypeScript 都会编译成 JavaScript，最终在浏览器或 Node.js 等环境中执行。</p><p>&nbsp;</p><p></p><h5>原文链接：</h5><p></p><p><a href=\"https://devclass.com/2023/09/07/ruby-on-rails-creator-removes-typescript-from-turbo-framework-upsets-community/?td=rt-3a\">https://devclass.com/2023/09/07/ruby-on-rails-creator-removes-typescript-from-turbo-framework-upsets-community/?td=rt-3a</a>\"</p><p></p><p></p><h5>相关阅读：</h5><p></p><p></p><p><a href=\"https://www.infoq.cn/article/3le2VX8uRPBOllXeoTKz\">重磅！OpenAI 开放 GPT-3.5 Turbo 微调，网友：将 prompt 减少 90% 才实惠&nbsp;</a>\"</p><p><a href=\"https://xie.infoq.cn/article/6ff79700fb3bfa972c1beebf3\">TypeScript 与 JavaScript：你应该知道的区别</a>\"</p><p><a href=\"https://www.infoq.cn/article/dDXbcLHT7teNYSPL3sm7\">“TypeScript 不值得！”前端框架 Svelte 作者宣布重构代码，反向迁移到 JavaScript 引争议</a>\"</p><p><a href=\"https://xie.infoq.cn/article/b7f556a866805cf5c71be7af8\">Typescript- 类型检测和变量的定义</a>\"</p>",
    "publish_time": "2023-09-12 09:46:56",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Slack蜂窝架构迁移：背后的技术策略与挑战",
    "url": "https://www.infoq.cn/article/JFv6Qoc3Nfe2Z1KblgA2",
    "summary": "<p>近年来，蜂窝架构（Cell-Based Architecture）作为一种增加冗余和有效限制站点故障影响范围的方式，在大型的在线服务中越来越流行。为了实现这些目标，在过去的一年半里，我们将Slack最关键的面向用户的服务从单体架构迁移到了基于蜂窝的架构。在本系列文章中，我们将解释我们为什么要进行大规模迁移、介绍蜂窝拓扑设计以及我们在此过程中所做出的工程技术权衡，并讨论我们成功对许多相连接的服务进行深度改造所采用的策略。</p><p>&nbsp;</p><p></p><h1>背景说明：事故</h1><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/32/325a2c99f5ee2777c35de46b84761a47.png\" /></p><p></p><p>2021年6月30日事故中的TCP重传图表</p><p>&nbsp;</p><p>在Slack，我们会在每一次发生明显的服务中断后进行一次事故评审。以下是我们内部事故评审报告的一些摘录，总结了其中的一起事故和我们的发现：</p><p>&nbsp;</p><p></p><blockquote>太平洋时间20121年6月30日上午11点45分，我们的云供应商在美国东海岸的一个可用区域发生网络中断，Slack的大部分服务都托管在那里。连接一个可用区域和其他几个包含Slack服务器的可用区域的网络链路发生了间歇性故障，导致Slack服务器之间的连接变慢，进而出现服务降级。&nbsp;太平洋时间2021年6月30日下午12点33分，我们的云供应商自动从服务中删除了网络链接，恢复了对Slack客户的全部服务。经过他们的一系列自动检查之后，网络链接再次进入服务状态。&nbsp;太平洋时间20121年6月30日下午5点22分，网络链路又发生了同样的间歇性故障。下午5点31分，云供应商永久地从服务中删除了网络链接，恢复了对我们全部的服务。</blockquote><p></p><p>&nbsp;</p><p>乍一看，这似乎没什么大不了。我们的服务所使用的一块物理硬件发生了故障，因此出现了一些错误，直到发生故障的硬件被移除。然而，在进行事故评审时，我们不禁问自己：让我们的用户体验到这样的中断是合理的吗？</p><p>&nbsp;</p><p>Slack运营着一个全球性的、多区域的边缘网络，但我们的大多数核心计算基础设施都位于单个地区（us-east-1）的多个可用区域内。可用区域（AZ）是指单个区域内的隔离的数据中心，它们除了可以提供物理隔离之外，也会限制我们所依赖的云服务组件（虚拟化、存储、网络等）的故障影响范围，这样就不会在多个AZ中同时发生故障。在云端托管服务的构建者（如Slack）可以通过这样的一种方式来构建服务——在一个区域内整个服务的可用性高于任何一个AZ的可用性。那么问题来了：为什么这个策略在6月30日没有奏效？为什么一个AZ发生故障会让用户体验到中断？</p><p>&nbsp;</p><p>事实证明，在分布式系统中检测故障是一个难题。来自用户的一个针对Slack API的请求（例如，在一个频道中加载消息）可能会扇出数百个发给后端服务的RPC，每个RPC都必须完成调用才能向用户返回正确的响应。我们的服务前端不断尝试检测和排除发生故障的后端，但在能够排除发生故障的服务器之前必须先将故障记录下来！让事情变得难上加难的是，我们的一些关键数据存储（包括我们的主数据存储Vitess）提供了高度一致的语义，这对应用程序开发人员来说非常有用，但也要求任何写入都要有可用的后端。如果一个分片主节点对应用程序前端不可用，那么到该分片的写入将会失败，直到主分片返回错误或一个次分片被提升为主分片。</p><p>&nbsp;</p><p>我们可以将上述的中断归类为灰色故障。在发生灰色故障时，系统可用性对于不同的组件来说是不一样的。在我们的事故中，受影响AZ内的系统看到其AZ内的后端完全可用，但AZ外的后端不可用。反过来，未受影响AZ内的系统看到受影响的AZ是不可用的。即使是同一个受影响的AZ内的客户端能够看到的后端可用性也是不一样的，这取决于它们的网络流量是否碰巧流经发生故障的设备。这就好比要求分布式系统在为我们的客户处理消息和提供小动物动图的同时处理好一切故障，这是一个相当复杂的任务。</p><p>&nbsp;</p><p>我们对这个难题的解决方案并不是试图去自动修复灰色故障，而是通过利用人类的判断力来让计算机的工作变得更容易。工程师们很清楚，在发生宕机时，主要的问题在于一个AZ不可达——我们汇总的目标AZ的每一张图表都与上面的重传图很相似。如果我们有一个可以告诉所有系统“这个AZ已坏，请避开它”的按钮，我们肯定会把它盘得发亮！因此，我们开始着手构建这样的按钮，可以将流量从AZ中抽走。</p><p>&nbsp;</p><p></p><h1>我们的解决方案：AZ就是会被引流的蜂窝单元</h1><p></p><p>&nbsp;</p><p>与其他许多基础设施一样，AZ引流按钮在概念上很简单，但在实践中却很复杂。我们的设计目标是：</p><p>&nbsp;</p><p>尽可能在5分钟内减少AZ内的流量。Slack的99.99%可用性SLA只允许我们每年不到1小时的总体不可用，因此，为了有效地保持这种可用性，我们需要能够快速奏效的工具。引流不能导致对用户可见的错误。引流是一种通用的缓解措施：只要故障包含在单个AZ内，即使尚未清楚导致故障的根本原因是什么，也可以有效地使用引流来缓解故障。这是一种实验性的方法，在发生故障期间，运维人员可以尝试对AZ进行引流，看看故障是否能够恢复，如果不能，则进行放流。如果引流会导致额外的错误，那么这种方法就没有用了。引流和放流必须是增量的。在放流时，运维人员将流量的1%分配给AZ，看看它是否已经恢复。引流机制不能依赖于被引流的AZ内的资源。例如，只是通过向每台服务器发送SSH命令并强制其关闭健康检查机制来激活引流是不行的。这是为了确保即使AZ完全离线也可以进行引流。</p><p>&nbsp;</p><p>一种符合这些需求的简单实现是向每个RPC客户端发送一个信号，当客户端接收到这个信号时，它们会让流向特定AZ的一定百分比的流量失败。这个方案隐含了很多复杂性。Slack没有共享代码库，甚至没有共享运行时，处理用户请求的服务使用多种语言编写，如Hack、Go、Java和C++，这就需要为每一种语言单独实现客户端。除此之外，我们还支持许多内部服务发现接口，包括Envoy xDS API、Consul API，甚至DNS。况且，DNS没有为AZ或部分引流等机制提供抽象，客户端只希望能够解析DNS地址并接收IP列表。最后，我们在很大程度上依赖了开源系统，如Vitess，要修改代码，就需要在内部维护分支，并做一些额外的工作，将变更合并到上游，这并不是一份令人愉悦的差事。</p><p>&nbsp;</p><p>我们采用的主要策略叫作“筒仓（Siloing）”。如果服务只从其所在的AZ内接收流量，并且只向该AZ内的服务器发送流量，那么这个服务就可以被称为一个筒仓。从整体上看，这种架构的效果是：每个服务似乎都有N个虚拟服务，每个AZ中有一个。重要的是，我们可以通过对某个AZ内的用户请求进行重定向来有效地将AZ内所有筒仓服务的流量抽走。如果没有来自用户的新请求到达筒仓所在的AZ，那么这个AZ的内部服务自然会停止，因为它们没有新的工作要做。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/96/96b91fa8de07ddea5d77b5e442564d83.png\" /></p><p></p><p>我们最初的架构，后端分布在各个AZ中，因此错误会出现在所有AZ的前端</p><p>&nbsp;</p><p>最终，我们得到了一个蜂窝架构。所有服务都存在于所有AZ中，但每个服务只与其AZ内的服务通信。一个AZ内的系统故障被包含在该AZ内，我们可以动态路由流量以避开这些故障，只需在前端重定向即可。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/86/86ec2b2988618e82625195d13b5d599f.png\" /></p><p></p><p>筒仓架构，一个AZ中的故障被包含在该AZ中，流量可能被抽走</p><p>&nbsp;</p><p>有了筒仓架构，我们就可以将精力集中在一个地方来实现流量转换：将来自用户的查询路由到us-east-1区域的核心服务。在过去的几年里，我们进行了大量投入，从HAProxy迁移到了Envoy/xDS生态系统，因此我们所有的边缘负载均衡器现在都在运行Envoy，并从我们内部的xDS控制平面Rotor接收配置。因此，我们能够通过简单地使用两个开箱即用的Envoy功能来进行AZ引流：加权集群和基于RTDS的动态权重分配。在对一个AZ进行引流时，我们只需通过Rotor向边缘Envoy负载均衡器发送一个信号，指示它们在us-east-1重新分配每个AZ的目标集群权重。如果us-east-1某个AZ的权重变为零，Envoy将继续处理请求，但会将所有新请求分配给另一个AZ，也就完成了对这个AZ的引流。我们来看看这是如何满足我们的目标的：</p><p>&nbsp;</p><p>通过控制平面的传播为秒级，Envoy负载均衡器将立即应用新的权重。引流不会丢失请求，负载均衡层不会放弃任何一个查询。权重提供粒度为1%的增量式引流。边缘负载均衡器完全位于不同的区域，控制平面有区域副本，可以抵御任意的单AZ故障。</p><p>&nbsp;</p><p>下图是我们逐步将流量从一个AZ引到另外两个AZ时每个AZ的带宽情况。注意图中的“膝盖”部分，它反映了Envoy/xDS实现为我们提供的快速、大粒度的传播保证。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/bd/bd7b81effa8e644b6a259149d7815a99.png\" /></p><p></p><p>单AZ的每秒查询走势</p><p>&nbsp;&nbsp;</p><p>原文链接：</p><p></p><p><a href=\"https://slack.engineering/slacks-migration-to-a-cellular-architecture/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTM1NDUwNDgsImZpbGVHVUlEIjoiZXpGV0loMmZYNkZWNDZVOCIsImlhdCI6MTY5MzU0NDc0OCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.E_FTADwFvxpEVro_6zuU3qcVnPYv5Uk-2h8-T6hWslk\">https://slack.engineering/slacks-migration-to-a-cellular-architecture/</a>\"</p><p></p><p></p><h5>相关阅读：</h5><p></p><p></p><p><a href=\"https://www.infoq.cn/article/LAYRE8jxE2z42QuU5pNX\">自定义跟踪架构：Slack&nbsp;高效解决通知问题</a>\"</p><p><a href=\"https://www.infoq.cn/article/9lp0pYfij3bUxmHDXkxl\">Slack实时消息处理架构，更新、更快、更稳定</a>\"</p><p><a href=\"https://www.infoq.cn/article/hhh8OGLNbsz121H43Df4\">Slack工程师如何解决最常见的移动开发痛点</a>\"</p><p><a href=\"https://www.infoq.cn/article/Pwkm3Ro1IqSzM3wLXvMS\">Zoom和Slack的第二曲线</a>\"</p>",
    "publish_time": "2023-09-12 09:49:15",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "隐私与安全同行：探索阿里云可信云架构与机密计算",
    "url": "https://www.infoq.cn/article/A1rDsG3luPU1eaRLcmO7",
    "summary": "<p>《英特尔®️ 至强®️ 实战课》新一期内容即将上线，大招来袭！本期以“大模型时代的云服务安全利器”为主题，邀请 InfoQ 极客传媒主编赵钰莹、英特尔首席工程师宋川、阿里云机密计算安全专家于国瑞、阿里云高级安全专家刘煜堃四位业内大咖，从基本原理、技术框架、场景案例等方面，详细阐述英特尔®️ 至强®️ 处理器机密计算在人工智能数据安全和隐私保护方面的应用及实践。通过本期课程，您将了解到当前云服务安全领域的前沿趋势和解决方案，并获得更专业的实战经验！</p>",
    "publish_time": "2023-09-12 11:11:50",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "《英特尔®️至强®️实战课》机密计算赋能数据为中心的云安全",
    "url": "https://www.infoq.cn/article/P2rM88BBFvQMxSLxxhUO",
    "summary": "<p>《英特尔®️ 至强®️ 实战课》新一期内容即将上线，大招来袭！本期以“大模型时代的云服务安全利器”为主题，邀请 InfoQ 极客传媒主编赵钰莹、英特尔首席工程师宋川、阿里云机密计算安全专家于国瑞、阿里云高级安全专家刘煜堃四位业内大咖，从基本原理、技术框架、场景案例等方面，详细阐述英特尔®️ 至强®️ 处理器机密计算在人工智能数据安全和隐私保护方面的应用及实践。通过本期课程，您将了解到当前云服务安全领域的前沿趋势和解决方案，并获得更专业的实战经验！</p>",
    "publish_time": "2023-09-12 11:13:43",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]