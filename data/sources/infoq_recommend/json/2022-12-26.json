[
  {
    "title": "Spring for Apache Kafka 3.0和Spring for RabbitMQ 3.0发布",
    "url": "https://www.infoq.cn/article/3QVmvCpHzu3Ba76DAmMQ",
    "summary": "<p>VMWare<a href=\"https://spring.io/blog/2022/11/21/new-major-releases-of-spring-for-apache-kafka-and-spring-for-rabbitmq\">发布</a>\"Spring for Apache Kafka 3.0和Spring for RabbitMQ 3.0，需要Java 17和Spring Framework 6.0。这些项目现在支持创建<a href=\"https://www.graalvm.org/latest/reference-manual/native-image/\">原生GraalVM</a>\"应用程序，并使用<a href=\"https://micrometer.io/\">Micrometer</a>\"指标门面来观察计时器和实现跟踪。现在，两个项目都在pom.xml文件中提供了<a href=\"https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#bill-of-materials-bom-poms\">BOM</a>\"，方便进行依赖项管理。</p><p></p><p>Micrometer用于增强JVM代码，没有供应商锁定，可以观察计时器和跟踪<a href=\"https://docs.spring.io/spring-kafka/reference/html/#observation\">KafkaTemplate</a>\"、 <a href=\"https://docs.spring.io/spring-amqp/docs/3.0.0/reference/html/#micrometer-observation\">RabbitTemplate</a>\"及监听器容器。Micrometer类似于<a href=\"https://www.slf4j.org/\">SLF4J</a>\"（一种日志门面），只是它是用在指标方面。</p><p></p><p>现在，<a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aot\">Spring AOT</a>\"原生提示可用来为使用Spring for Apache Kafka或Spring for RabbitMQ构建的Spring应用程序创建<a href=\"https://docs.spring.io/spring-kafka/reference/html/#native-images\">原生镜像</a>\"，示例可在GitHub上的<a href=\"https://github.com/spring-projects/spring-aot-smoke-tests/tree/main/integration\">spring-aot-smoke-tests</a>\"项目中找到。spring-kafka-test模块中的<a href=\"https://docs.spring.io/spring-kafka/api/org/springframework/kafka/test/EmbeddedKafkaBroker.html\">EmbeddedKafkaBroker</a>\"类在原生镜像中不受支持。</p><p></p><p>Spring for Apache Kafka 3.0要求<a href=\"https://mvnrepository.com/artifact/org.apache.kafka/kafka-clients\">Kafka客户端</a>\"是3.3.1版本，如果要使用事务，要求最低Kafka broker（即Kafka服务器）是2.5版本。</p><p></p><p>现在可以跨多个测试类使用一个单独的全局EmbeddedKafkaBroker，只需要像下面这样替换服务器地址：</p><p></p><p><code lang=\"java\">public final class EmbeddedKafkaContainer {\n    private static EmbeddedKafkaBroker embeddedKafkaBroker = \n        new EmbeddedKafkaBroker(1, false)\n            .brokerListProperty(\"spring.kafka.bootstrap-servers\");\n    private static boolean started;\n\n    public static EmbeddedKafkaBroker getEmbeddedKafkaBroker() {\n        if (!started) {\n            try {\n                embeddedKafkaBroker.afterPropertiesSet();\n            }\n            catch (Exception exception) {\n                throw new KafkaException(\"Error starting \n                    EmbeddedKafkaBroker\", exception);\n            }\n            started = true;\n        }\n        return embeddedKafkaBroker;\n    }\n\n    private EmbeddedKafkaContainer() {\n        super();\n    }\n}\n</code></p><p></p><p>在配置了EmbeddedKafkaBroker之后，它就可以被用在每一个测试类中：</p><p></p><p><code lang=\"java\">static {\n    EmbeddedKafkaHolder.getEmbeddedKafkaBroker()\n        .addTopics(\"students\", \"teacher\");\n}\n\nprivate static final EmbeddedKafkaBroker broker =\n    EmbeddedKafkaContainer.getEmbeddedKafkaBroker();\n</code></p><p></p><p>对于前面的示例，broker在完成测试后将会继续运行，这可能会导致潜在的问题。例如，在使用Gradle守护进程时，EmbeddedKafkaBroker的destroy()方法应该在所有测试执行完毕之后被调用。</p><p></p><p><a href=\"https://docs.spring.io/spring-kafka/docs/current-SNAPSHOT/api/org/springframework/kafka/test/junit/GlobalEmbeddedKafkaTestExecutionListener.html\">GlobalEmbeddedKafkaTestExecutionListener</a>\"为测试计划启动一个全局的EmbeddedKafkaBroker，并在测试计划被执行时停止它。监听器在默认情况下是禁用的，可以在1.8或更新版本的JUnit Platform上通过spring.kafka.global.embedded.enabled属性来启用。</p><p></p><p>用于非阻塞重试的<a href=\"https://docs.spring.io/spring-kafka/api/org/springframework/kafka/annotation/RetryableTopic.html\">@RetryableTopic</a>\"注解不再是实验性的。在这个版本中，这个注解得到了进一步的改进，现在可以作为自定义注解的元注解。现在可以在同一个应用程序上下文的同一个主题上配置多个@RetryableTopic监听器。容器现在可以发布<a href=\"https://docs.spring.io/spring-kafka/api/org/springframework/kafka/event/ConsumerRetryAuthEvent.html\">ConsumerRetryAuthEvent</a>\"和<a href=\"https://docs.spring.io/spring-kafka/api/org/springframework/kafka/event/ConsumerRetryAuthSuccessfulEvent.html\">ConsumerRetryAuthSuccessfulEvent</a>\"事件。</p><p></p><p><a href=\"https://docs.spring.io/spring-kafka/api/org/springframework/kafka/core/KafkaTemplate.html\">KafkaTemplate</a>\"和<a href=\"https://docs.spring.io/spring-kafka/api/org/springframework/kafka/requestreply/ReplyingKafkaTemplate.html\">ReplyingKafkaTemplate</a>\"类中定义的各种send方法现在将返回一个<a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/CompletableFuture.html\">CompletableFuture</a>\"，而不是已弃用的<a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/concurrent/ListenableFuture.html\">ListenableFuture</a>\"。</p><p></p><p>Spring for RabbitMQ现在支持单个活跃消费者的<a href=\"https://docs.spring.io/spring-amqp/docs/3.0.0/reference/html/#super-streams\">超级流</a>\"。超级流是通过参数x-super-stream: true将几个流队列绑定到一个exchange来创建的。例如，我们可以使用<a href=\"https://docs.spring.io/spring-amqp/api/org/springframework/rabbit/stream/config/SuperStream.html\">SuperStream</a>\"类型的bean来创建test.exchange和两个队列或分区：</p><p></p><p><code lang=\"java\">@Bean\nSuperStream superStream() {\n  return new SuperStream(\"test.exchange\", 2);\n}\n</code></p><p></p><p>使用<a href=\"https://docs.spring.io/spring-amqp/api/org/springframework/amqp/rabbit/annotation/RabbitListener.html\">@RabbitListener</a>\"注解的监听器方法现在可以消费<a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/index.html\">Collection</a>\"或<a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/List.html\">List</a>\"类型的<a href=\"https://docs.spring.io/spring-amqp/docs/3.0.0/reference/html/#receiving-batch\">消息批次</a>\"。</p><p></p><p><a href=\"https://docs.spring.io/spring-amqp/api/org/springframework/amqp/rabbit/AsyncRabbitTemplate.html\">AsyncRabbitTemplate</a>\"、<a href=\"https://docs.spring.io/spring-amqp/api/org/springframework/rabbit/stream/producer/RabbitStreamTemplate.html\">RabbitStreamTemplate</a>\"和<a href=\"https://docs.spring.io/spring-amqp/docs/current/api/org/springframework/rabbit/stream/producer/RabbitStreamOperations.html\">RabbitStreamOperations</a>\"的send方法现在返回<a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/CompletableFuture.html\">CompletableFuture</a>\"，而不是已弃用的<a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/concurrent/ListenableFuture.html\">ListenableFuture</a>\"。</p><p></p><p>Spring for RabbitMQ不再支持<a href=\"https://www.oracle.com/java/technologies/jpl1-remote-method-invocation.html\">远程方法调用</a>\"（RMI）。</p><p></p><p>更多信息可以在<a href=\"https://docs.spring.io/spring-kafka/docs/3.0.0/reference/html/#whats-new-part\">Kafka</a>\"和<a href=\"https://docs.spring.io/spring-amqp/docs/3.0.0/reference/html/#whats-new\">RabbitMQ</a>\"的What's New页面中找到。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2022/12/spring-apache-kafka-rabbitmq-3/\">https://www.infoq.com/news/2022/12/spring-apache-kafka-rabbitmq-3/</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/iCQ44j3XyAEl2FgHSPQy\">Spring Boot 3和Spring Framework 6使用Java 17和Jakarta EE 9，并支持基于GraalVM的原生Java</a>\"</p><p><a href=\"https://www.infoq.cn/article/F3I9jfBsZ4cyE2aD7K8U\">Spring Modulith使用模块和事件组织Spring Boot 3应用</a>\"</p><p><a href=\"https://www.infoq.cn/article/vl9UfPTm6oOPAUgYpN5c\">InfoQ 2022 年趋势报告：Java 篇</a>\"</p>",
    "publish_time": "2022-12-26 09:31:56",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]