[
  {
    "title": "Spring Modulith 1.0已生产就绪且获IDE支持",
    "url": "https://www.infoq.cn/article/ae3VpuezDx73cRHwHswd",
    "summary": "<p>Spring Modulith 1.0从<a href=\"https://www.infoq.com/news/2022/11/spring-modulith-launch\">实验状态</a>\"提升为完全支持的Spring项目。它通过模块和事件来构建Spring Boot 3应用程序。Spring Tool Suite和Visual Studio Code等IDE现在已经提供了这个模块结构。事件发布注册中心（EPR）可以更快地完成事件保存。集成测试场景则简化了测试事件。</p><p>&nbsp;</p><p>Spring Modulith模块之所以会存在是因为Java包不分层。在下面的示例中，Java的默认可见性向其他包隐藏了example.inventory.SomethingInventoryInternal类。但是，example.order.internal包必须是public的，因为example.order 要访问它。这就使得它对所有其他包都可见。</p><p></p><p><code lang=\"java\">└─  src/main/java\n   ├─  example\n   |  └─  Application.java\n   ├─  example.inventory\n   |  ├─  InventoryManagement.java\n   |  └─  SomethingInventoryInternal.java\n   ├─  example.order\n   |  └─  OrderManagement.java\n   └─  example.order.internal\n      └─  SomethingOrderInternal.java</code></p><p></p><p>Spring Modulith模块既不使用Java平台模块系统（JPMS），也不生成代码。相反，主包的每个直接子包在默认情况下都只是一个模块。在上面的例子中就是inventory和order。模块API由包中所有的公共类型组成。最关键的是，Spring Modulith认为子包是模块内部的。这就解决了上面所说的example.order.internal公共包的问题。</p><p>&nbsp;</p><p>当模块访问其他模块的内部包时，Java仍然可以编译。但是Spring Modulith测试ApplicationModules.of(Application.class).verify()将会失败。Spring Modulith使用ArchUnit来检测这种违规行为。</p><p>&nbsp;</p><p>Spring Modulith鼓励使用Spring Framework应用程序事件实现模块之间的通信。Spring Modulith用EPR增强了这些事件，保证了事件的传递。因此，即使接收事件的模块崩溃或整个应用程序崩溃，当模块或应用程序再次运行时，注册中心仍然会传递事件。</p><p>&nbsp;</p><p>EPR使用JPA、JDBC和MongoDB来存储事件。在这个版本中，MongoDB获得了自动配置的事务。使用Spring Modulith的应用程序可以同时使用模块和事件，也可以单独使用某个特性。</p><p>&nbsp;</p><p>到目前为止，异步事务事件监听器需要三个注解：</p><p><code lang=\"java\">@Component\nclass InventoryManagement {\n\n\n  @Async\n  @Transactional(propagation = Propagation.REQUIRES_NEW)\n  @TransactionalEventListener\n  void on(OrderCompleted event) { /*…*/ }\n}</code></p><p>&nbsp;</p><p>1.0版本新增注解@ApplicationModuleListener简化了上述代码：</p><p><code lang=\"java\">@Component\nclass InventoryManagement {\n\n\n  @ApplicationModuleListener\n  void on(OrderCompleted event) { /*…*/ }\n}</code></p><p>测试异步事务性代码颇具挑战性。这就轮到新工具<a href=\"https://docs.spring.io/spring-modulith/docs/1.0.0/reference/html/#testing.scenarios\">Integration Test Scenarios</a>\"登场了。我们可以将它们注入到Java测试中，并定义好事件驱动测试的起点和预期结果。此外，在这些场景中，我们还可以自定义执行细节并定义额外的事件测试。</p><p>&nbsp;</p><p><a href=\"http://jmolecules.org/\">jMolecules</a>\"为架构定义注解，如领域驱动设计的@ValueObject或@Repository，六角架构（Hexagonal Architecture）的@Port和@Adapter。Spring Modulith 1.0检测jMolecules注解，生成应用程序文档，并根据注解的作用（如“Port”或“Adapter”）对类进行分组。</p><p>&nbsp;</p><p>在<a href=\"https://www.vmware.com/explore/video-library/video-landing.html?sessionid=1677888184456001k1vv&amp;videoId=6335272652112\">2023年8月的Spring One大会</a>\"上，VMware宣布即将推出Spring Modulith 1.1。这个新版本依赖Spring Boot 3.2，而后者要到2023年11月23日才能发布。1.1版本将支持用于事件持久化的其他数据库，如Neo4J，为的是更好地与Spring Data保持一致。它还可以自动将事件发送到外部目的地。当其他应用程序对其中一些事件感兴趣时，这会很有帮助。1.1版本将支持使用Kafka、AMQP、甚至可能是Redis作为事件的外部目的地。</p><p>&nbsp;</p><p><a href=\"https://www.linkedin.com/in/odrotbohm\">Oliver Drotbohm</a>\"是VMware Staff 2的工程师，也是Spring Modulith背后的推动者。他向InfoQ介绍了Spring Modulith。</p><p>&nbsp;</p><p>InfoQ：Spring Modulith推出已经有10个月。到目前为止，反响如何？</p><p></p><p></p><blockquote>Oliver Drotbohm：&nbsp;会议和在线社区的反馈都非常积极。让人们有点犹豫的一个主要方面是，在几天前发布之前，这个项目还一直被认为是实验性的。我们期待着社区消除顾虑并采用它。</blockquote><p></p><p>&nbsp;</p><p>InfoQ：在你们看来，Spring Modulith怎么才算成功？该如何度量？</p><p></p><p></p><blockquote>Drotbohm：当然，与所有的Spring项目一样，我们也在监控Maven Central的下载量，因为这些数值可能增长或下降。尽管如此，对于单个项目，这个数值的增长趋势通常是一个不错的使用增长率指标。我们也有start.spring.io的数据。考虑到Spring Modulith主要是面向新应用程序的，希望我们能看到好的结果。除此之外，我们也关注GitHub上星星的数量。</blockquote><p></p><p>&nbsp;</p><p>InfoQ：Spring Tool Suite和VS Code已经可以读取模块结构。对于IntelliJ和Eclipse支持，你们有什么计划吗？</p><p></p><p></p><blockquote>Drotbohm：Eclipse通过STS插件提供支持。至于IDEA，我们会和开发团队保持联系，他们正在研究。</blockquote><p></p><p>&nbsp;</p><p>InfoQ：目前，Spring Modulith有两个核心的抽象概念——模块和事件。您觉得在未来的版本中还会增加其他的抽象概念吗？</p><p></p><p></p><blockquote>Drotbohm：实际上，这两个抽象概念分别服务于尼尔·福特和马克·理查兹在《<a href=\"https://www.oreilly.com/library/view/software-architecture-the/9781492086888/\">分布式系统架构</a>\"》一书中所描述的软件架构的两个基本活动：“把事情拆分”（即定义应用程序的功能分解）和“将它们重新组合在一起”（定义一个编程模型，使分解出的单个部分最终能够相互交互）。应用程序模块的概念有助于实现代码库的功能结构，其中也包含了方法，确保应该分开的东西实际上是分开的。我们推荐的基于事件的应用程序集成编程模型，使这些模块可以用最终一致的方式进行交互。&nbsp;目前，我们的重点是这两部分该如何演进，并搞清楚社区会如何使用它们，以及我们该如何响应并完善它们。计划在1.1 M1中引入的事件外部化机制就体现了这一点。</blockquote><p></p><p>&nbsp;</p><p>InfoQ：据您估计，使用模块的Spring Modulith应用程序占比有多少，使用事件的占比又有多少？</p><p></p><p></p><blockquote>Drotbohm：这个我们得看下单个Spring Modulith构件的下载量。实验阶段的统计数据显示，模块（包括模块集成测试支持）与事件的比例是90/10。</blockquote><p></p><p></p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/08/spring-modulith-1-0/\">https://www.infoq.com/news/2023/08/spring-modulith-1-0/</a>\"</p>",
    "publish_time": "2023-10-17 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "百川智能启动2024校招，A1轮获阿里腾讯小米等3亿美元投资",
    "url": "https://www.infoq.cn/article/uxPrRHWE4XEz4d7XZiL3",
    "summary": "<p>近日，<a href=\"https://www.infoq.cn/article/ivM3DbowD6o9Ro4jIeGq?utm_campaign=geek_search_source&amp;utm_content=geek_search_source&amp;utm_medium=geek_search_source&amp;utm_source=geek_search_source&amp;utm_term=geek_search_source\">百川智能</a>\"正式启动2024届校园招聘并发起“星耀计划”。本次校招将面向海内外学生，同时覆盖北上广深等多个城市多所高校，目前百川智能是2024届校园招聘规模最大的大模型初创企业。</p><p>&nbsp;</p><p>“星耀计划”是百川智能面向全球精英科技人才的专项校园招聘计划。岗位涵盖了自然语言处理、计算机视觉、强化学习、基础架构等多个人工智能关键技术方向，旨在寻找有技术理想，热爱AI领域的精英人才。2023年11月- 2024年10月毕业的海内外应届生，均可通过百川智能校招官网进行申请<a href=\"https://campus.baichuan-inc.com/\">官网地址</a>\"，截止日期为12月31日。百川智能将为通过该计划的学生提供系统化培养和支持，助力同学们在技术领域的快速成长和飞跃。</p><p>&nbsp;</p><p>百川智能成立于2023年4月10日，由前搜狗公司CEO王小川创立。其核心团队由来自搜狗、Google、腾讯、百度、华为、微软、字节等知名科技公司的AI顶尖人才组成。目前，百川智能的团队规模170余人，其中硕士及硕士以上学历员工占比近70%，研发人员占比超80%。</p><p>&nbsp;</p><p>此前，百川智能已完成A1轮战略融资，融资金额3亿美元，阿里、腾讯、小米等科技巨头及多家顶级投资机构均参投了本轮融资。加上天使轮的5000万美元，百川智能的融资金额已达3.5亿美元。成立不到半年时间便跻身科技独角兽行列，创下国内大模型初创企业晋升独角兽速度之最。</p><p>&nbsp;</p><p>在顶尖科技人才和雄厚资金的支持下，百川智能保持了惊人的大模型研发速度。成立仅半年，百川智能便接连发布Baichuan-7B/13B，Baichuan2-7B/13B四款开源可免费商用大模型及Baichuan-53B、Baichuan2-53B两款闭源大模型，平均每28天就会发布一款新的大模型。</p><p>&nbsp;</p><p>百川智能不仅保持着行业领先的大模型研发速度，还将大模型的性能也做到了顶尖水准。Baichuan-7B/13B两款开源大模型在多个权威评测榜单均名列前茅，累积下载量超过六百万次。Baichuan2-13B在MMLU、CMMLU、MedQA、USMLE等几大权威评估基准中，以绝对优势全方位领先LLaMA2，引领开源社区走向中文开源<a href=\"https://www.infoq.cn/article/Qa3ExDDg5W4OiblRxpGx?utm_campaign=geek_search_source&amp;utm_content=geek_search_source&amp;utm_medium=geek_search_source&amp;utm_source=geek_search_source&amp;utm_term=geek_search_source\">大模型时代</a>\"。</p><p>&nbsp;</p><p>值得一提的是，8月31日百川智能率先通过国家《生成式人工智能服务管理暂行办法》备案，是首批八家公司中唯一一家今年成立的大模型初创公司，并于9月25日开放Baichuan2-53B&nbsp;API接口，正式进军To B领域，开启商业化进程。</p><p>&nbsp;</p><p>经过半年时间的发展，百川智能已经展示出了行业领先的技术竞争力和人才吸引力，在新一轮的融资过程中或将再受巨头和众多资本追捧。</p><p>&nbsp;</p><p>&nbsp;</p>",
    "publish_time": "2023-10-17 09:40:30",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Java IO 与 NIO：高效的输入输出操作探究",
    "url": "https://www.infoq.cn/article/82eece134e72735de70d9a0a1",
    "summary": "<p></p><h3>引言</h3><p></p><p>输入输出（IO）是任何编程语言中的核心概念，而在Java中，IO操作更是应用程序成功运行的基石。随着计算机系统变得越来越复杂，对IO的要求也日益增加。在本文中，我们将探讨Java IO和非阻塞IO（NIO）的重要性以及如何在Java中实现高效的输入输出操作。</p><p></p><h3>传统IO（阻塞IO）</h3><p></p><p>传统IO是大多数开发人员熟悉的IO模型，其中主要涉及InputStream和OutputStream。通过传统IO，您可以轻松地进行文件读写和网络通信。让我们看一下传统IO的一个示例：</p><p></p><p><code lang=\"text\">import java.io.*;\npublic class TraditionalIOExample {\n    public static void main(String[] args) {\n        try {\n            // 打开文件\n            InputStream input = new FileInputStream(\"example.txt\");\n            OutputStream output = new FileOutputStream(\"output.txt\");\n\n            // 读取和写入数据\n            int data;\n            while ((data = input.read()) != -1) {\n                output.write(data);\n            }\n\n            // 关闭文件\n            input.close();\n            output.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></p><p></p><p>传统IO简单易用，但在某些情况下，它可能会阻塞程序的执行，特别是在处理大量并发请求时。</p><p></p><h3>Java NIO简介</h3><p></p><p>Java NIO（New I/O）引入了新的IO模型，主要由通道（Channels）和缓冲区（Buffers）组成。NIO提供了非阻塞和多路复用的特性，使其成为处理大量并发连接的理想选择。让我们了解一下NIO的核心概念。</p><p></p><h3>NIO通道与缓冲区</h3><p></p><p>NIO中，通道是数据传输的管道，而缓冲区则是数据的容器。通过通道和缓冲区，您可以实现高效的文件和网络操作。下面是一个简单的NIO示例：</p><p></p><p><code lang=\"text\">import java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.io.RandomAccessFile;\npublic class NIOExample {\n    public static void main(String[] args) {\n        try {\n            RandomAccessFile file = new RandomAccessFile(\"example.txt\", \"r\");\n            FileChannel channel = file.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n\n            while (channel.read(buffer) != -1) {\n                buffer.flip();  // 切换为读模式\n                while (buffer.hasRemaining()) {\n                    System.out.print((char) buffer.get());\n                }\n                buffer.clear();  // 清空缓冲区，切换为写模式\n            }\n\n            channel.close();\n            file.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></p><p></p><p>NIO的通道和缓冲区模型允许您更灵活地管理数据，以及处理大规模数据传输。</p><p></p><h3>选择IO类型的考虑</h3><p></p><p>在选择传统IO或NIO时，需要考虑性能需求、复杂性和应用场景。传统IO简单易用，适用于大多数情况。而NIO更适用于需要处理大量并发连接的高性能应用，如网络服务器和数据传输。</p><p></p><h3>NIO的非阻塞特性</h3><p></p><p>NIO的非阻塞特性主要通过选择器（Selector）和通道的非阻塞模式实现。这允许程序同时管理多个通道，而不必等待每个通道的数据可用。以下是一个NIO非阻塞IO的示例：</p><p></p><p><code lang=\"text\">import java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\npublic class NIOSelectorExample {\n    public static void main(String[] args) {\n        try {\n            Selector selector = Selector.open();\n            ServerSocketChannel serverSocket = ServerSocketChannel.open();\n            serverSocket.configureBlocking(false);\n            serverSocket.register(selector, SelectionKey.OP_ACCEPT);\n\n            while (true) {\n                int readyChannels = selector.select();\n                if (readyChannels == 0) continue;\n\n                Set selectedKeys = selector.selectedKeys();\n                Iterator keyIterator = selectedKeys.iterator();\n                while (keyIterator.hasNext()) {\n                    SelectionKey key = keyIterator.next();\n                    if (key.isAcceptable()) {\n                        // 处理连接\n                    } else if (key.isReadable()) {\n                        // 处理读取\n                    }\n                    keyIterator.remove();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></p><p></p><p>NIO的非阻塞特性允许程序同时处理多个通道，从而提高了应用程序的响应性。</p><p></p><h3>IO和NIO的性能对比</h3><p></p><p>性能对比是选择IO类型的关键因素之一。传统IO在处理少量并发请求时可能表现良好，但在高并发情况下可能出现性能瓶颈。NIO通过非阻塞和多路复用等特性提供更好的性能。性能测试和案例研究可以帮助开发人员了解哪种IO类型适合他们的应用。</p><p></p><p>IO（传统IO）和NIO（非阻塞IO）在性能方面存在显著差异，尤其在处理大量并发连接时。以下是一个具体的代码和实例，用于比较IO和NIO的性能。</p><p></p><p>性能测试目标： 我们将模拟一个简单的HTTP服务器，它将响应客户端请求并返回一个固定的响应（\"Hello, World!\"）。我们将使用IO和NIO两种不同的方式实现此服务器，然后进行性能测试。</p><p></p><p>IO实现：</p><p></p><p><code lang=\"text\">import java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class IoHttpServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                handleRequest(clientSocket);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void handleRequest(Socket clientSocket) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(clientSocket.getOutputStream()));\n        String request = in.readLine();\n        out.write(\"HTTP/1.1 200 OK\\r\\n\\r\\nHello, World!\\r\\n\");\n        out.flush();\n        clientSocket.close();\n    }\n}\n</code></p><p></p><p>NIO实现：</p><p></p><p><code lang=\"text\">import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NioHttpServer {\n    public static void main(String[] args) {\n        try {\n            ServerSocketChannel serverChannel = ServerSocketChannel.open();\n            serverChannel.socket().bind(new InetSocketAddress(8080));\n            serverChannel.configureBlocking(false);\n\n            Selector selector = Selector.open();\n            serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n            while (true) {\n                selector.select();\n                Set selectedKeys = selector.selectedKeys();\n                Iterator keyIterator = selectedKeys.iterator();\n\n                while (keyIterator.hasNext()) {\n                    SelectionKey key = keyIterator.next();\n                    keyIterator.remove();\n\n                    if (key.isAcceptable()) {\n                        ServerSocketChannel server = (ServerSocketChannel) key.channel();\n                        SocketChannel clientChannel = server.accept();\n                        clientChannel.configureBlocking(false);\n                        clientChannel.register(selector, SelectionKey.OP_READ);\n                    } else if (key.isReadable()) {\n                        SocketChannel clientChannel = (SocketChannel) key.channel();\n                        ByteBuffer buffer = ByteBuffer.allocate(1024);\n                        clientChannel.read(buffer);\n                        buffer.flip();\n                        byte[] bytes = new byte[buffer.remaining()];\n                        buffer.get(bytes);\n                        String request = new String(bytes);\n\n                        String response = \"HTTP/1.1 200 OK\\r\\n\\r\\nHello, World!\\r\\n\";\n                        ByteBuffer responseBuffer = ByteBuffer.wrap(response.getBytes());\n                        clientChannel.write(responseBuffer);\n                        clientChannel.close();\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></p><p></p><p>性能测试： 我们将使用Apache Benchmark工具（ab）来测试这两个HTTP服务器的性能，模拟1000个并发请求，每个请求重复1000次。</p><p></p><p><code lang=\"text\">ab -n 100000 -c 1000 http://localhost:8080/\n</code></p><p></p><p>性能测试结果： 在这个简单的性能测试中，NIO的实现通常会比传统IO的实现更具竞争力。由于NIO的非阻塞特性，它能够更好地处理大量并发请求，减少线程阻塞和上下文切换。</p><p></p><p>需要注意的是，性能测试结果受多个因素影响，包括硬件、操作系统和代码优化。因此，实际性能可能会因环境而异。然而，通常情况下，NIO在高并发场景下表现更出色。</p><p></p><p>总之，通过上述性能测试，我们可以看到NIO相对于传统IO在处理大量并发请求时的性能表现更为出色。因此，在需要高性能和可伸缩性的应用中，NIO通常是更好的选择。</p><p></p><h3>实际应用场景</h3><p></p><p>最后，我们将探讨一些实际应用场景，包括文件复制、HTTP服务器和套接字通信。这些场景演示了如何有效地应用IO和NIO来满足特定需求。</p><p></p><p>当涉及到Java中的IO和NIO的实际应用时，我们可以探讨一些常见的使用场景和示例代码。以下是几个实际应用的示例：</p><p></p><h4>1. 文件复制</h4><p></p><p>文件复制是一个常见的IO任务，它可以使用传统IO和NIO来实现。以下是一个使用传统IO的文件复制示例：</p><p></p><p><code lang=\"text\">import java.io.*;\n\npublic class FileCopyUsingIO {\n    public static void main(String[] args) {\n        try (InputStream inputStream = new FileInputStream(\"input.txt\");\n             OutputStream outputStream = new FileOutputStream(\"output.txt\")) {\n\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                outputStream.write(buffer, 0, bytesRead);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></p><p></p><p>这段代码使用InputStream和OutputStream进行文件复制。</p><p></p><p>以下是一个使用NIO的文件复制示例：</p><p></p><p><code lang=\"text\">import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.file.StandardCopyOption;\nimport java.nio.file.FileSystems;\n\npublic class FileCopyUsingNIO {\n    public static void main(String[] args) {\n        try {\n            Path source = FileSystems.getDefault().getPath(\"input.txt\");\n            Path target = FileSystems.getDefault().getPath(\"output.txt\");\n            FileChannel sourceChannel = FileChannel.open(source, StandardOpenOption.READ);\n            FileChannel targetChannel = FileChannel.open(target, StandardOpenOption.CREATE, StandardOpenOption.WRITE);\n\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            int bytesRead;\n            while ((bytesRead = sourceChannel.read(buffer)) != -1) {\n                buffer.flip();\n                while (buffer.hasRemaining()) {\n                    targetChannel.write(buffer);\n                }\n                buffer.clear();\n            }\n\n            sourceChannel.close();\n            targetChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></p><p></p><p>这段代码使用NIO中的FileChannel和ByteBuffer来实现文件复制。</p><p></p><h4>2. HTTP服务器</h4><p></p><p>创建一个简单的HTTP服务器也是一个常见的应用场景，可以使用NIO来处理多个并发连接。以下是一个使用NIO的简单HTTP服务器示例：</p><p></p><p><code lang=\"text\">import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\n\npublic class SimpleHttpServer {\n    public static void main(String[] args) {\n        try {\n            ServerSocketChannel serverChannel = ServerSocketChannel.open();\n            serverChannel.socket().bind(new InetSocketAddress(8080));\n\n            while (true) {\n                SocketChannel clientChannel = serverChannel.accept();\n\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                clientChannel.read(buffer);\n                buffer.flip();\n                // 处理HTTP请求\n                // ...\n\n                clientChannel.write(buffer);\n                clientChannel.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></p><p></p><p>这段代码创建一个简单的HTTP服务器，使用NIO中的ServerSocketChannel和SocketChannel处理客户端请求。</p><p></p><h4>3. 套接字通信</h4><p></p><p>套接字通信是在网络编程中常见的应用，可以使用NIO来实现非阻塞的套接字通信。以下是一个使用NIO的简单套接字通信示例：</p><p></p><p><code lang=\"text\">import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\nimport java.net.InetSocketAddress;\n\npublic class SocketCommunication {\n    public static void main(String[] args) {\n        try {\n            SocketChannel clientChannel = SocketChannel.open(new InetSocketAddress(\"localhost\", 8080));\n\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            String message = \"Hello, Server!\";\n            buffer.put(message.getBytes());\n            buffer.flip();\n            clientChannel.write(buffer);\n\n            buffer.clear();\n            clientChannel.read(buffer);\n            buffer.flip();\n            // 处理从服务器接收的数据\n            // ...\n\n            clientChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></p><p></p><p>这段代码创建一个客户端套接字通信，使用NIO的SocketChannel来与服务器进行非阻塞通信。</p><p></p><p>这些示例代表了Java中IO和NIO的实际应用场景，从文件复制到HTTP服务器和套接字通信。这些示例演示了如何使用Java的IO和NIO来处理各种输入输出任务。</p><p></p><h3>总结</h3><p></p><p>通过本文，我们深入探讨了Java中的IO和NIO，以及它们的应用。了解如何选择合适的IO类型和使用适当的工具，可以帮助开发人员实现高效的输入输出操作，提高应用程序的性能和可伸缩性。鼓励读者在实际开发中深入研究和应用IO和NIO，以满足不同应用的需求。</p><p></p><p></p><blockquote>更多内容请参考 <a href=\"https://www.infoq.cn/article/www.flydean.com\">www.flydean.com</a>\"最通俗的解读，最深刻的干货，最简洁的教程，众多你不知道的小技巧等你来发现！欢迎关注我的公众号:「程序那些事」,懂技术，更懂你！</blockquote><p></p>",
    "publish_time": "2023-10-17 09:31:01",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "这件事，已被大学生持续关注了 5 年……",
    "url": "https://www.infoq.cn/article/b7xuUQKHJvIFoVma98Zx",
    "summary": "<p>5 年，足以让一棵嫩芽茁壮成长——比如，一个学生完成从本科新生到研究生的转变；</p><p>5 年，也足以让一个新兴技术从初露头角发展为全球焦点——比如，金融科技打破传统金融服务边界，成为了数字化时代的重要部分……</p><p></p><p>那么，对于一年一度的“深圳国际金融科技大赛 - 西丽湖金融科技大学生挑战赛”来说，5 年又意味着什么呢？——意味着从初出茅庐的“新生赛事”成为了具有稳定基础和广泛影响的“赛事盛宴”！</p><p></p><p>自 2019 年第一届大赛落地，该品牌赛事至去年已成功举办 4 届，共吸引了 3500 余名来自海内外知名高校的学生参赛！每届大赛的举办都会在行业内引起一波浪潮！</p><p></p><p>今年，已经是大赛举办的第 5 年</p><p>在大家的热烈期盼下</p><p>大赛正式于 10 月 16 日 00:00 开赛！</p><p></p><p></p><p>🚀是的，你没听错！</p><p>2023 深圳国际金融科技大赛（ FinTechathon ）</p><p>—— 西丽湖金融科技大学生挑战赛全面启动！</p><p>正在面向国内外高校在读生火热招募中📣</p><p>突破界限，释放想象力</p><p>金融科技的未来，由你点燃！</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/35/355ea0cc1ea80a3fdbeb13d788a1d456.jpeg\" /></p><p></p><p></p><p>这个大赛凭啥能“连续 5 年牵扯学生心”？！</p><p>一场专为学生团队打造的世界级金融科技竞赛</p><p></p><p><a href=\"https://www.infoq.cn/news/9AYU96ZSPoCZ6kyClK94\">2023 深圳国际金融科技大赛——西丽湖金融科技大学生挑战赛</a>\"（下文称“大赛”），是一场面向金融科技前沿技术领域的学生团队竞赛活动，是深圳市金融科技节的重要一环。</p><p></p><p>该赛事前身是“ FinTechathon 微众银行金融科技高校技术大赛”，在去年成功完成了品牌升级。经过 4 年的发展，大赛组委会从最初的办赛热忱中逐渐沉淀下来，对大赛的本质和价值进行深入的思考和探索，更加理性地审视了大赛的发展方向和目标，思考了如何更好地为参赛者服务。目前大赛已形成了一套完善的赛制和评选标准，赛事的整体筹备和落地已兼备成熟性，大赛的公平性和公正性有了更多保证，越来越多的优秀作品和人才脱颖而出。</p><p></p><p>从去年起，该赛事便由政、学、企三方联合共建，含金量十足！而本届大赛也依旧是在深圳市地方金融监督管理局、深圳市福田区人民政府、深圳市南山区人民政府战略指导下，由深圳大学、微众银行、深圳香蜜湖国际金融科技研究院等多方联合举办！</p><p></p><p></p><p>哦豁，今年的大赛搞了许多“新花活”？！</p><p>本届大赛的变与不变</p><p></p><p>本届大赛组委会将基于往届办赛经验，继续进一步提升赛事体验和评选质量。本届大赛保留了往届一样的区块链、人工智能、产品经理三个竞技赛道，三个赛道还是将分别通过初赛遴选出 10 支队伍进入决赛，每个赛道进入决赛的队伍将争夺一等奖 (1 队）、二等奖（1 队）及三等奖（1 队）！和去年一样，获奖队伍除了获得奖杯、纸质获奖证书、具有唯一标识的数字化获奖凭证“区块链数字证书”外，还将瓜分大赛组委会准备的 69W+ 的赛事奖金：</p><p>一等奖：100,000 元二等奖：80,000 元三等奖：50,000 元</p><p></p><p>（悄悄地和大家透露下：进入决赛的团队还将获得去微众银行实习的面试机会哦~）</p><p></p><p>本届大赛组委会依旧只接受“团队战”，需要 2-5 人 组队参赛，参与组队的成员不限学历、不限专业、不限年级，无论在国内还是国外，只要是高校在读生（含本科生、硕士 / 博士研究生）就可以参赛！</p><p>但，和去年不一样的是，因产品经理赛道所需参赛作品形式与另外两个赛道有所差异，故该赛道在今年增加了“复赛”，初赛将海选出 30 支队伍进入复赛进行线上答辩，复赛将选出 10 支队伍进入决赛。三个赛道的赛题也发生了变化，但较往年难度相当，具体内容可以前往大赛官网查看<a href=\"https://www.infoq.cn/article/%EF%BC%88https://www.infoq.cn/zones/fintechathon/campus2023/%EF%BC%89\">（https://www.infoq.cn/zones/fintechathon/campus2023/）</a>\"。</p><p></p><p>此外，本届大赛在初赛作品提交之前的“技术公开课”形式也发生了变化，10 月 25 日 -11 月 10 日，今年的大赛组委会除了做线上直播外，还将走到线下高校去与大家面对面交流，届时三个赛道的专家评委和金融科技行业的专家将分别围绕赛题内容展开技术干货分享。届时同学们可以密切关注大赛官方社群内发布的进校行程，关注“InfoQ 视频号”、“InfoQ 官网”直播间的大赛技术公开课的直播预告！</p><p></p><p>“就算拿不到奖”也要参加今年的大赛？!</p><p>数十位行业大佬亲自指导你的作品</p><p></p><p>本届大赛主办方将最大限度地发挥政、学、企三方的优势，坚守全面提高学生的创新能力、实践能力和就业竞争力的办赛初心。为此，大赛组委会特别邀请了国家统计局原副局长许宪春；加拿大皇家科学院院士、加拿大工程院院士、微众银行首席人工智能官杨强；清华大学五道口金融学院教授、华夏银行原行长、中国人民银行研究局原局长张健华；中国工商银行首席技术官吕仲涛；上海新金融研究院副院长、浙商银行原行长刘晓春；全国政协委员、南方科技大学副校长金李；中国银行业协会首席信息官高峰等人担当学术顾问，为大赛提供智力支持，帮助参赛团队更好地理解和应用金融科技知识。</p><p></p><p>除此之外，大赛组委会还邀请了来自中科院、清华大学、中山大学、西安电子科技大学、深圳大学、武汉大学、中央财经大学、广东财经大学、浙江财经大学、哈尔滨工业大学、微众银行等学企单位的数十位科研专家担任大赛评委，为参赛团队提供专业的指导建议，督促参赛团队把创新成果转化为实际应用，为金融科技行业提供更多有价值的技术解决方案，争取开创领域技术创新先河。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b9/b9b06b4328d88a65eeb23cb8d5736111.jpeg\" /></p><p></p><p>如此重磅的评委嘉宾阵容，意味着行业大佬对于参赛的你来说，再也不仅仅是视频里讲课的专家，而是直接帮助你订正作品内容、帮你解决技术难点的专属导师! 这些大佬的经验或许可以帮你在技术创新的道路上少走许多路，一定不能错过这样的好机会！</p><p></p><p>所以，你还在想什么？</p><p>赶紧扫描下方二维码进行报名吧！</p><p><img src=\"https://static001.geekbang.org/infoq/d0/d0dbb40226846cd13a49f1cd42ba5369.png\" /></p><p></p><p>2023 深圳国际金融科技大赛（ FinTechathon ）</p><p>—— 西丽湖金融科技大学生挑战赛</p><p>全新就绪，等你来引爆金融科技的无限想象！</p><p>同学们可通过以下方式</p><p>了解更多大赛信息哦~</p><p></p><p>① 添加小助手随时随地了解比赛进程</p><p><img src=\"https://static001.geekbang.org/infoq/77/778476730106a49946b46a92c1bea68d.jpeg\" /></p><p></p><p>② 登陆大赛官方网站了解更多大赛信息</p><p><a href=\"https://www.infoq.cn/zones/fintechathon/campus2023/\">https://www.infoq.cn/zones/fintechathon/campus2023/</a>\"</p><p></p><p>③ 通过大赛指定邮箱与主办方联系</p><p>fintechathon@geekbang.com</p>",
    "publish_time": "2023-10-17 11:03:12",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "苏州银行网络金融部高级产品经理金一松确认出席 FCon，分享数字人民币（e-CNY）赋能支付业态发展",
    "url": "https://www.infoq.cn/article/aZeXzXbevHvMwikAtKZd",
    "summary": "<p><a href=\"https://fcon.infoq.cn/2023/shanghai/?utm_source=infoqweb&amp;utm_medium=atricle\">FCon 全球金融科技大会</a>\"，将于 11 月在上海召开。苏州银行网络金融部高级产品经理金一松将发表题为《<a href=\"https://fcon.infoq.cn/2023/shanghai/presentation/5574?utm_source=infoqweb&amp;utm_medium=article\">数字人民币（e-CNY）赋能支付业态发展</a>\"》主题分享，介绍数字人民币，以及数字人民币如何与场景应用相结合。</p><p></p><p><a href=\"https://fcon.infoq.cn/2023/shanghai/presentation/5574?utm_source=infoqweb&amp;utm_medium=article\">金一松</a>\"，中国银行业协会金融科技师高级人才库成员，数字人民币研究院专家智库成员，中级经济师，DAMA 数据治理工程师，具备丰富的数字人民币产品研发和场景建设经验，主导并推动苏州银行全渠道、全场景、全维度数字人民币基础建设和场景应用，《苏州银行数字人民币智能风控》案例荣获 2023 数字金融创新大赛数字风控金奖。他在本次会议的演讲内容如下：</p><p></p><p>演讲：数字人民币（e-CNY）赋能支付业态发展</p><p></p><p>数字人民币（e-CNY）是人民银行发行的数字形式的法定货币，由指定运营机构参与运营，以广义账户体系为基础，支持银行账户松耦合功能，与实物人民币等价，具有价值特征和法偿性。其全新的货币形态和独有的支付方式，必将为全社会的商品流通和经济发展带来全新的机会和巨大的动力。</p><p></p><p>演讲提纲：</p><p></p><p>数字人民币概览母子钱包体系软硬钱包形态随用随充体验无网无电支付智能合约应用未来应用展望</p><p></p><p>你将获得：</p><p></p><p>○ 全面深入了解数字人民币</p><p>○ 如何将数字人民币与场景应用相结合</p><p>○ 探索和挖掘数字人民币更多可能性</p><p></p><p>除上述演讲外，FCon 上海还将围绕&nbsp;<a href=\"https://fcon.infoq.cn/2023/shanghai/track/1580?utm_source=infoqweb&amp;utm_medium=atricle\">DevOps&nbsp;在金融企业落地实践</a>\"、<a href=\"https://fcon.infoq.cn/2023/shanghai/track/1591?utm_source=infoqweb&amp;utm_medium=atricle\">金融行业大模型应用</a>\"、<a href=\"https://fcon.infoq.cn/2023/shanghai/track/1576?utm_source=infoqweb&amp;utm_medium=atricle\">创新的金融科技应用</a>\"、<a href=\"https://fcon.infoq.cn/2023/shanghai/track/1577?utm_source=infoqweb&amp;utm_medium=atricle\">金融实时数据平台建设之路</a>\"、<a href=\"https://fcon.infoq.cn/2023/shanghai/track/1588?utm_source=infoqweb&amp;utm_medium=atricle\">金融安全风险管控</a>\"、<a href=\"https://fcon.infoq.cn/2023/shanghai/track/1589?utm_source=infoqweb&amp;utm_medium=atricle\">数据要素流通与数据合规</a>\"等进行交流。</p><p></p><p>FCon 上海 2023，相约 11 月！现在购票，享 7 折优惠 ，立省 ￥2040！咨询购票请联系：17310043226（微信同手机号）。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/a8/a8ec7f7fb25c7949931b2b8a5deffddd.png\" /></p><p></p>",
    "publish_time": "2023-10-17 11:30:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "文心大模型4.0发布！李彦宏：相比GPT-4毫不逊色",
    "url": "https://www.infoq.cn/article/2vE0o4dBI6N4idPFTUlt",
    "summary": "<p>“大模型带来的智能涌现，这是我们开发AI原生应用的基础。”10月17日，李彦宏在百度世界2023上表示。当天，李彦宏以《手把手教你做AI原生应用》为主题发表演讲，发布文心大模型4.0版本，并带来新搜索、新地图等十余款AI原生应用。</p><p><img src=\"https://static001.geekbang.org/infoq/f5/f54e97d5835a6e76f2564c7ee051f29b.png\" /></p><p></p><p>大会上，李彦宏宣布文心大模型4.0正式发布，开启邀请测试。他表示，这是迄今为止最强大的文心大模型，实现了基础模型的全面升级，在理解、生成、逻辑和记忆能力上都有着显著提升，综合能力“与GPT-4相比毫不逊色”。李彦宏介绍，文心4.0也同步开始邀测，现场观众扫描嘉宾证二维码，登录文心一言官网或下载最新版文心一言APP，就可以体验到文心一言的专业版；此外，企业客户也可以通过百度智能云千帆大模型平台来申请测试文心4.0&nbsp;API。</p><p></p><p>他现场展示了基于文心一言重构的百度搜索、如流、地图、网盘、文库等十余款AI原生应用，希望能拓展大家的想象力，“激发大家一起来做出更惊艳的AI原生应用来”。</p><p></p><h2>最强文心大模型4.0发布&nbsp;综合能力比GPT-4毫不逊色</h2><p></p><p></p><p>在李彦宏看来，AI原生应用的诞生，得益于大模型的理解、生成、逻辑和记忆四大核心能力，百度的AI原生应用也是基于文心一言来开发的，“这些能力是过去的时代所不具备的，因而才能打开无限的创新空间”。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/aa/aaf20d6150f36ee1a7c7ddf530b95477.png\" /></p><p></p><p>基于文心大模型4.0，李彦宏依次演示了四大能力的特点与应用场景。在理解能力上，他通过询问公积金异地贷款政策的案例，展示了文心一言对前后乱序、模糊意图、潜台词等复杂提示词的理解力，例如“在北京工作”等同于“在北京缴纳公积金”等等，“今天，你说的每一句话，它大概率都能听懂”。</p><p>&nbsp;</p><p>在生成能力上，李彦宏展示了文心一言如何在短短几分钟内，根据一张素材图片，迅速生成了一组广告海报、五条广告文案以及一条营销视频。据介绍，基于这一系列能力，百度已经推出了AIGC营销创意平台擎舵，让“一个人就成为一支AI营销队伍”。</p><p>&nbsp;</p><p>同时，他还通过解数学题、总结知识点等场景，展示了大模型的逻辑能力；通过数千字的小说撰写和角色、情节设置，体现了大模型的记忆能力；以及数字人医生帮助患者解读药品说明书，来展现四大能力的综合应用。</p><p>&nbsp;</p><p>“前面的演示，体现出文心大模型在理解、生成、逻辑、记忆这四大能力上的进步，这些能力是一切AI原生应用赖以生存的基础。”李彦宏表示。</p><p></p><h2>十余款AI原生应用重磅发布</h2><p></p><p></p><p>丰富的AI原生应用才是大模型的价值所在。大会上，李彦宏宣布“我们的搜索、如流、地图、网盘、文库等，都将以一个全新的面目与大家见面，”并表示，分享上述这些应用的目的，是为了拓展想象力、激发更多人做出更惊艳的AI原生应用。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d0/d0149e6b4817c25ef7cb5923e194f4b1.png\" /></p><p></p><p>李彦宏介绍，百度新搜索具有极致满足、推荐激发和多轮交互三个特点，当用户搜索问题时，新搜索将“不再是给你一堆链接”，而是通过对内容的理解，生成文字、图片、动态图表的多模态答案，让用户一步获取答案。在针对复杂需求时，“多轮交互”特点也可以通过提示、调整等方式，满足用户更个性化的搜索需求。</p><p>&nbsp;</p><p>同时，李彦宏还展示了用AI原生思维打造的国内第一个生成式商业智能产品：百度GBI。据介绍，相对传统BI软件的高门槛和数据分析难等问题，百度GBI可以通过自然语言交互，执行数据查询与分析任务，还支持专业知识注入，满足更复杂、专业的分析需求。</p><p>&nbsp;</p><p>通过对海量文档、图片和视频的理解和再生成，百度网盘和文库拥有了创作能力：网盘不仅能精准定位到视频某一帧，还能在几秒钟内总结完长达1小时的视频内容，并从中提炼出金句和要点；文库更是基于10亿优质资料，能实现写稿和做PPT等工作，成为名副其实的“生产力工具”。</p><p>&nbsp;</p><p>百度地图和智能办公平台如流，也通过理解、记忆等能力，变成更贴心的出行向导和超级助理：在地图上，用户只需说出需求，地图就能调动几千个服务接口，帮助用户推荐餐厅、对比多地点信息、给出出行建议；如流则可以针对群聊信息多的办公痛点，“一秒划重点”，差旅助手不仅能订机票酒店，甚至还能通过接入CRM等公司系统，总结出拜访客户的背景资料和谈话参考。</p><p>&nbsp;</p><p>正如李彦宏此前所说，AI原生应用不是对移动互联网App和PC软件的简单重复，而是要能“解决过去解决不了或解决不好的问题”。&nbsp;</p><p></p><h2>插件、API助力生态繁荣&nbsp;&nbsp;推动经济增长</h2><p></p><p></p><p>“大模型将开启一个繁荣的AI原生应用生态，”李彦宏强调，插件是一种特殊的AI原生应用，门槛最低，也最容易上手，能让开发者、创业者快速加入到生态中。他举例说，大模型接入权威法律数据的“智能法律助手”，能为用户提供法律咨询的相关建议，而简历助手插件则能帮用户一键生成简历模板。</p><p>&nbsp;</p><p>据介绍，个人及企业的数据、能力或应用，都能快速变成AI插件，增强大模型的能力，让大模型更实用易用。李彦宏表示，一个月前，百度上线了灵境插件平台，目前已经有2.7万开发者申请入驻，覆盖法律、职场、学习等多个领域。</p><p>&nbsp;</p><p>在开发AI原生应用时，大模型的基础能力至关重要。李彦宏介绍说，API是AI原生应用调用基础大模型的主要方式，企业和开发者可以在百度的千帆大模型平台上调取包括文心一言在内的大模型API，目前，千帆大模型平台已经成为中国最大的大模型开发平台，有42个主流大模型入驻，覆盖各行各业近500个场景。即日起，企业客户也可以在千帆大模型平台上申请测试文心4.0的API。</p><p></p><p>“中国有丰富的应用场景，中国用户又天然愿意拥抱新技术，有了先进的基础大模型，我们就能构建起一个繁荣的AI生态，共同创造新一轮经济增长。”李彦宏表示。</p><p>&nbsp;</p><p>此外，李彦宏表示，未来的AI原生应用一定是多模态的，在信息世界之外，一定会重构物理世界。自动驾驶就是视觉大模型重构物理世界的一个典型应用。大模型会让百度的自动驾驶能力超越经验系统，更聪明地处理复杂场景，实现更广泛的时空覆盖。目前，百度自动驾驶出行服务平台萝卜快跑累计提供服务超400万次，已经成为全球最大的自动驾驶出行服务商。</p><p>&nbsp;</p><p>“大量AI原生应用将不断涌现，数字技术与实体经济将深度融合……大模型正成为新型工业化的重要推动力。”李彦宏说。正如百度世界2023的主题是“生成未来”，在演讲结尾，李彦宏宣布，我们即将进入一个AI原生的时代，进入一个人机通过Prompt来交互的时代。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/3b/3b3c871ce83566032fbf428201592da5.png\" /></p><p></p>",
    "publish_time": "2023-10-17 11:46:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]