[
  {
    "title": "开源Java性能分析器比较：VisualVM、JMC和async-profiler",
    "url": "https://www.infoq.cn/article/yO6pjms5izsxK5YrZ036",
    "summary": "<p>在本文中，我将介绍性能分析的基本概念和不同类型的开源Java分析器，让你可以根据自己的需要选择最适合的分析器，并了解这些工具大致的工作原理。</p><p>&nbsp;</p><p>在<a href=\"https://qconlondon.com/\">2023年伦敦QCon</a>\"演讲“<a href=\"https://qconlondon.com/presentation/mar2023/your-java-application-slow-check-out-these-open-source-profilers\">你的Java应用程序很慢吗？试试这些开源分析器</a>\"”中，我深入探讨过这个话题，也介绍了不同的性能查看器。本文是基于那次演讲整理而成。</p><p>&nbsp;</p><p>分析器的目的是获取有关程序执行的信息，让开发人员可以看到一个方法在给定的时间段内执行了多长时间。</p><p>&nbsp;</p><p>但它们是如何做到这一点的呢？有两种方法：程序插桩和抽样。</p><p>&nbsp;</p><p></p><h2>插桩分析器</h2><p></p><p>&nbsp;</p><p>获取性能分析概要的一种方法是，对于开发人员感兴趣的每个方法，记录其进入和退出时间。</p><p>&nbsp;</p><p>当想要知道程序的特定部分花费了多长时间时，许多开发人员都会使用这种检测方法。</p><p>&nbsp;</p><p>在这种方法中，下面的方法：</p><p>&nbsp;</p><p><code lang=\"java\">void methodA() {\n      // … // 做工作\n}</code></p><p>&nbsp;</p><p>会被修改成：</p><p>&nbsp;</p><p><code lang=\"java\">void methodA() {\n      long start = System.currentTimeMillis();\n      // … // 做工作\n      long duration = System.currentTimeMillis() - start;\n      System.out.println(“methodA took “ + duration + “ms”);\n}</code></p><p>&nbsp;</p><p>这种修改可以用于基本的时间测量。尽管如此，在嵌套测量方法时，它提供的信息很少，因为了解方法之间的关系也很有趣，例如methodB()由methodA()在几秒钟内执行。因此，我们需要记录每次进入和退出相关方法的日志。这些日志会关联到时间戳和当前线程。</p><p>&nbsp;</p><p>插桩分析器的思想是将这种代码修改的过程自动化：它将logEntry()和logExit()方法的调用插入到方法的字节码中。这些方法是分析器运行时库的一部分。通常，这种插入是在运行时完成的，即在类加载时通过插桩代理完成。然后，分析器将methodA()修改为：</p><p>&nbsp;</p><p><code lang=\"java\">void methodA() {\n      logEntry(“methodA”);\n      // … // 做工作\n      logExit(“methodA”);\n}</code></p><p>&nbsp;</p><p>插桩分析器的优点是它们对所有JVM都有效，因为它们可以用纯Java实现。但它们有一个缺点，即插入的方法调用会导致显著的性能损失并严重影响结果。因此，在最近几十年里，纯插桩分析器的流行度已然消退。如今，现代分析器大多都是抽样分析器。</p><p>&nbsp;</p><p></p><h2>抽样分析器</h2><p></p><p>&nbsp;</p><p>另一种分析器是抽样分析器，它们会在被分析程序执行时进行抽样。这类分析器会定期向JVM请求当前运行程序的堆栈，通常是每10毫秒到20毫秒一次。然后，分析器会使用这些信息来估算性能。这种方法的主要缺点是：运行时间比较短的方法可能不会在性能分析概要中出现。</p><p>&nbsp;</p><p>抽样分析器的主要优点是：它们不会修改程序，开销比较小，不会对结果产生明显的影响。</p><p>&nbsp;</p><p>现代抽样分析器通常每10到20毫秒一次循环运行以下代码：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/92/92f2c093c7b5327c3761ba34892d14c8.jpeg\" /></p><p></p><p>&nbsp;</p><p>抽样分析器每次迭代都会获取当前的（Java）线程列表。然后，它会随机选择一个线程子集进行抽样。通常，这个子集的大小在5到8之间，因为每次迭代对太多线程进行抽样会增加运行分析器的性能影响。在分析具有大量线程的应用程序时，请注意这一点。</p><p>&nbsp;</p><p>然后，分析器向每个选定的线程发送一个信号，这将导致它们停下来调用信号处理程序。此信号处理程序会获取并存储其线程的堆栈跟踪。在每次迭代结束时，分析器会收集所有堆栈跟踪信息并进行后处理。</p><p>&nbsp;</p><p>实现抽样分析器还有其他的方法，但我这里介绍的是使用最广泛且精度最佳的技术。</p><p>&nbsp;</p><p></p><h2>不同的开源分析器</h2><p></p><p>&nbsp;</p><p>目前，最著名的开源分析器有3个：VisualVM、async-profiler和JDK Flight Recorder（JFR）。这些分析器都处于积极开发过程中，可用于各种应用程序。它们都是抽样分析器。VisualVM是唯一支持插桩分析的分析器。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/3a/3ae539ce25ce339df6b94123cd76a30b.jpeg\" /></p><p></p><p>&nbsp;</p><p>&nbsp;</p><p>我们可以区分下“外部”和“内置”分析器：外部分析器不是直接实现到JVM中，而是使用API来收集特定线程的堆栈跟踪信息。对于只使用API的分析器，同一个版本可以用于不同的JVM版本和供应商（如OpenJDK和OpenJ9）。</p><p>&nbsp;</p><p>最著名的外部分析器有两个：VisualVM和async-profiler；它们的主要区别在于它们使用的API。VisualVM使用官方的<a href=\"https://docs.oracle.com/en/java/javase/17/docs/api/java.management/javax/management/JMX.html\">Java管理扩展</a>\"（JMX）来获取线程的堆栈跟踪信息。另一方面，async-profiler使用非官方的AsyncGetCallTrace API。两者各有优缺点，但通常，JMX及相关API被认为更安全，而AsyncGetCallTrace更精确。</p><p>&nbsp;</p><p>OpenJDK和GraalVM仅有一个内置分析器Java Flight Recorder（JFR）；它的工作原理与async-profiler大致相同，同样精确，但更稳定。</p><p>&nbsp;</p><p>接下来，我将介绍这几个分析器及其历史。</p><p>&nbsp;</p><p></p><h3>VisualVM</h3><p></p><p>&nbsp;</p><p>该工具是Netbeans分析器的独立版本。从2006年的Oracle JDK 6到JDK 8，每个JDK都包含Java VisualVM工具。<a href=\"https://dzone.com/articles/visual-vm-free-and-open-source\">该工具于2008年开源</a>\"。后来，这个分析器更名为VisualVM，Oracle JDK 9不再包含它。根据<a href=\"https://www.jetbrains.com/lp/devecosystem-2022/java/\">JetBrains最近的一项调查</a>\"，VisualVM是最常用的开源分析器。需要的话，可以从<a href=\"https://visualvm.github.io/download.html\">这里</a>\"下载。</p><p>&nbsp;</p><p>它的用法很简单；只需要在GUI中为你想要分析的程序选择运行它的JVM并启动性能分析：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/49/49978885ce877ed68a795e36f0b8c082.jpeg\" /></p><p></p><p>&nbsp;</p><p>然后，你可以在一个简单的树形可视化中直接查看性能分析概要信息。也可以从命令行启动和停止抽样分析器：</p><p>&nbsp;</p><p><code lang=\"java\">visualvm --start-cpu-sampler \nvisualvm --stop-sampler </code></p><p>&nbsp;</p><p>VisualVM提供了易于使用的简单UI，但需要注意，它使用了不太精确的JVM API。</p><p>&nbsp;</p><p></p><h3>Async-Profiler</h3><p></p><p>&nbsp;</p><p>Async-profiler是最常用的分析器之一，这不仅仅是因为它被嵌入到了许多其他工具中，如IntelliJ Ultimate Profiler和AppIication Performance Monitors。你可以从<a href=\"https://github.com/jvm-profiling-tools/async-profiler\">项目的GitHub页面</a>\"下载async-profiler。它包含特定于平台的二进制文件，不支持Windows。因此，我创建了<a href=\"https://github.com/parttimenerd/ap-loader\">app-loader项目</a>\"，将所有async-profiler二进制文件封装到一个多平台二进制文件中，使得嵌入并使用这个分析器变得更容易。</p><p>&nbsp;</p><p>你可以通过许多嵌入了async-profiler的工具使用它，或直接将其作为本机Java代理来使用。假设你下载了特定于平台的libasyncProfiler.so，则只需在调用Java二进制文件时添加以下选项，即可分析Java应用程序的性能：</p><p>&nbsp;</p><p><code lang=\"java\">java \n-agentpath:libasyncProfiler.so=start,event=cpu,file=flame.html,flamegraph …</code></p><p>&nbsp;</p><p>这个调用告诉async-profiler生成一个火焰图。这是一种非常流行的可视化方式。</p><p>&nbsp;</p><p>你也可以用它创建JFR文件：</p><p>&nbsp;</p><p><code lang=\"java\">java \n-agentpath:libasyncProfiler.so=start,event=cpu,file=profile.jfr,jfr …</code></p><p>&nbsp;</p><p>这个调用让你可以在众多查看器中查看性能分析概要文件。</p><p>&nbsp;</p><p>以下是async-profiler的发展简史，感兴趣的可以了解一下。</p><p>&nbsp;</p><p>2002年11月，Sun（后来被Oracle收购）根据<a href=\"https://docs.oracle.com/en/java/javase/17/docs/specs/jvmti.html#ChangeHistory\">JVM（TM）工具接口规范</a>\"将AsyncGetStackTrace API添加到JDK中。新API使得从外部分析器获得精确的堆栈跟踪信息成为可能。Sun引入这个API是为了给他们的Sun Development Studio添加一个完整的Java分析器。然而，两个月后，他们删除了该API，原因未公开。但是，这个API仍然以AsyncGetCallTrace的形式保留在JDK中，直到今天一直存在，只是没有导出，所以比较难用。</p><p>&nbsp;</p><p>几年后，人们偶然发现，这个API是一个不错的实现分析器的方法。2007年，Jeremy Manson在博文“<a href=\"http://jeremymanson.blogspot.com/2007/05/profiling-with-jvmtijvmpi-sigprof-and.html\">使用JVMTI/JVMPI、SIGPROF和AsyncGetCallTrace进行性能分析</a>\"”中，首次提到将AsyncGetCallTrace作为实现Java分析器的基础。从那时起，许多开源和闭源分析器就开始使用它。<a href=\"https://www.yourkit.com/docs/java/help/async_sampling_cpu.jsp\">YourKit</a>\"、<a href=\"https://www.ej-technologies.com/products/jprofiler/overview.html\">JProfiler</a>\"和<a href=\"https://github.com/jvm-profiling-tools/honest-profiler\">honest-profiler</a>\"是其中几个比较有名的例子。Async-profiler的开发始于2016年；它目前是使用AsyncGetCallTrace的最主要的开源分析器。</p><p>&nbsp;</p><p>Async-profiler的问题在于，它是基于一个非官方的内部API。这个API没有经过官方OpenJDK测试套件的充分测试，随时都可能失效。尽管该API的广泛应用使得它已近乎标准化，但这仍然是一个风险。为了减轻这些风险，我目前正在编制一份JDK增强提案，在OpenJDK中增加一个官方的AsyncGetCallTrace版本；<a href=\"https://openjdk.org/jeps/435\">见JEP候选435</a>\"。</p><p>&nbsp;</p><p>Async-profiler的优势在于它的许多特性（如堆采样）、可嵌入性、对其他JVM（如OpenJ9）的支持，以及它小巧的代码库，这使得它的适应性非常好。要了解关于async-profiler的更多信息，可以查看<a href=\"https://github.com/jvm-profiling-tools/async-profiler\">async-profiler自述文件</a>\"、<a href=\"https://github.com/async-profiler/async-profiler/wiki\">async-profiler维基</a>\"以及Krzysztof Ślusarski提供的<a href=\"https://krzysztofslusarski.github.io/2022/12/12/async-manual.html\">async-profiler实用手册</a>\"。</p><p>&nbsp;</p><p></p><h3>JDK Flight Recorder（JFR）</h3><p></p><p>&nbsp;</p><p>JRockit最初开发运行时分析器是为了内部使用，但它也越来越受应用程序开发人员的欢迎。后来，在Oracle收购了其开发公司之后，这些特性被集成到了Oracle JDK中。最终，Oracle将该工具与JDK11一起开源，从那时起，它就成了OpenJDK JVM的内置分析工具，不再支持OpenJ9等其他JVM了。</p><p>&nbsp;</p><p>它的工作原理与async-profiler类似，主要区别是它直接使用内部的JVM API。该分析器的使用很简单，可以通过在Java二进制文件的调用中添加以下选项：</p><p>&nbsp;</p><p><code lang=\"java\">$ java \\\n  -XX:+UnlockDiagnosticVMOptions \\\n  -XX:+DebugNonSafepoints \\  # improves precision\n  -XX:+FlightRecorder \\\n  -XX:StartFlightRecording=filename=file.jfr \\\n  arguments</code></p><p>&nbsp;</p><p>或者使用JDK命令行工具jcmd 启动和禁用它：</p><p>&nbsp;</p><p><code lang=\"java\">$ jcmd PID JFR.start\n$ jcmd PID JFR.dump filename=file.jfr\n$ jcmd PID JFR.stop</code></p><p>&nbsp;</p><p>JFR捕获许多性能分析事件，从堆栈跟踪信息抽样到垃圾收集和类加载统计信息。<a href=\"https://sapmachine.io/jfrevents/\">JFR事件</a>\"网站上提供了所有事件的列表。我们甚至还可以<a href=\"https://www.morling.dev/blog/rest-api-monitoring-with-custom-jdk-flight-recorder-events/\">添加自定义事件</a>\"。</p><p>&nbsp;</p><p>要了解更多关于这个工具的信息，可以阅读<a href=\"https://bell-sw.com/announcements/2021/01/29/JDK-Flight-Recorder-The-Programmatic-Way/\">JDK Flight Recorder、The Programmatic Way</a>\"（来自BellSoft）等博客的文章。</p><p>&nbsp;</p><p>与async-profiler相比，JFR的主要优势是它存在于所有平台的OpenJDK中，甚至在Windows上。此外，JFR更稳定一些，记录的事件和信息也更多。JFR有一个名为JDK任务控制的GUI，它让你可以分析JVM性能并查看生成的JFR性能分析概要。</p><p>&nbsp;</p><p></p><h3>正确性与稳定性</h3><p></p><p>&nbsp;</p><p>在使用我所介绍的分析器时，务请记住以下内容：它们本身也是软件，与大型项目OpenJDK（或OpenJ9）交织在一起，因此，它们也会遇到与它们所分析应用程序相同的典型问题：</p><p>测试可以更丰富，特别是底层API，可以更好地测试一下；目前只有一个测试。（我正在努力）测试可以做得更好：现有的测试甚至没有充分测试API是否适用于小样本。它只检查了最上面的帧，但忽略了返回的跟踪信息太短这个问题。我发现了这个问题并修复了测试用例。缺乏自动化回归测试：缺乏测试还意味着，对当前项目中看似不相关部分的更改可能会对分析产生不利的影响，而又没有人注意到。</p><p>&nbsp;</p><p>因此，对于分析器生成的性能分析概要，你要持保留态度。以下博文和演讲谈及了分析器的准确性问题：</p><p><a href=\"https://www.youtube.com/watch?v=7IkHIqPeFjY&amp;list=PLLLT4NxU7U1QYiqanOw48h0VUjlUvqCCv&amp;index=3\">分析器都是撒谎的霍比特人</a>\"<a href=\"http://psy-lob-saw.blogspot.com/2018/07/how-inlined-code-confusing-profiles.html\">内联代码如何导致性能分析概要的混乱</a>\"<a href=\"https://jpbempel.github.io/2022/06/22/debug-non-safepoints.html\">为什么JVM现代分析器仍然有安全点偏见？</a>\"<a href=\"https://mostlynerdless.de/blog/2023/03/14/validating-java-profiling-apis/\">Java性能分析API验证</a>\"</p><p>&nbsp;</p><p>此外，在极少数情况下，对应用程序进行性能分析还可能导致JVM崩溃。像<a href=\"https://github.com/openjdk/jdk/pulls?q=is%3Apr+author%3Ajbachorik\">Jaroslav Bachorik</a>\"和<a href=\"https://github.com/openjdk/jdk/pulls?q=is%3Apr+author%3Aparttimenerd\">我</a>\"这样的OpenJDK开发人员正设法尽可能地修复底层分析API中存在的所有稳定性问题。在实践中，使用上面提到的任何一种分析器都是安全的，很少会引发崩溃。如果遇到问题，请联系分析程序开发人员或在相应的存储库中开一个GitHub问题。</p><p>&nbsp;</p><p></p><h2>小结</h2><p></p><p></p><p>现代基于抽样的Java分析器使得使用开源工具调查性能问题成为可能。你可以选择：</p><p>一个稍微有点不精确但易于使用并且提供了简单UI的工具（VisualVM）一个内置的工具，提供包括GC信息在内的更多信息（JFR）一个提供很多选项的工具，可以显示C/C++代码的信息（async-profiler）</p><p>&nbsp;</p><p>都试用一下，以便了解在下一次遇到性能问题时使用哪种工具。</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/open-source-java-profilers/\">https://www.infoq.com/articles/open-source-java-profilers/</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/u9i2rWrCAQ4NsX7tyU8U\">JEP 443：未命名模式和变量致力于提升 Java 代码的可读性</a>\"</p><p><a href=\"https://www.infoq.cn/article/wxcjbFtvT7Twva0eeXTj\">JEP 444：JDK 21 中出现虚拟线程，开创并发新纪元</a>\"</p><p><a href=\"https://www.infoq.cn/article/R8sh9XHuojBsX9DpGYvJ\">快速实现不打折扣的云原生 Java 应用</a>\"</p>",
    "publish_time": "2023-06-28 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]