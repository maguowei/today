[
  {
    "title": "构建协作性技术系统：Wardley Maps、领域驱动设计和团队拓扑",
    "url": "https://www.infoq.cn/article/b5bDhfgto7END1GxcmB4",
    "summary": "<p>在一个变化迅速、不确定性日益增加的世界中，组织必须不断做出适应和演进，以此来保持竞争力，并在市场上脱颖而出。设计适应性听起来容易做起来难。如何设计和构建能够在不断变化的环境中演进和蓬勃发展的系统？我的建议是采用一种整体性的方法，能够结合与业务战略、软件架构和团队组织相关的观点。</p><p></p><p>本文从高层次的角度介绍了如何结合Wardley Mapping、领域驱动设计（DDD）和团队拓扑来设计和构建针对快速变化流而优化的自适应协作性技术系统。</p><p></p><p>本文重点介绍了一个在线教学遗留系统的演进示例，通过创建一个Wardley Map来可视化其业务环境，并演示了如何将Wardley Map与DDD相连接来发现其核心领域并将单体大泥球分解为模块化的组件（有界上下文）。此外，本文还提到了如何以先前创建的Wardley Map为基础来确定适合团队拓扑的边界。</p><p></p><p></p><h1>一种优化组织的系统性方法</h1><p></p><p></p><p>大多数试图改变或优化系统的方法通常都是针对局部进行的改进，它们倾向于专注对系统各个部分进行局部优化。</p><p></p><p>Russell Ackoff博士（系统性思维先驱之一）认为，对系统各个部分进行局部优化不会改善整体性能。他指出：“一个系统不仅仅是其各部分之和，而是它们相互作用的产物。部件之间的配合方式决定了一个系统的性能——而不是它们单独运行时的性能。”此外，在构建系统时，我们需要考虑有效性（构建出正确的事物）和效率（以正确的方式构建出事物）。</p><p></p><p></p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/adaptive-socio-technical-systems-flow/en/resources/40figure-1-1688720198596.jpg\" /></p><p></p><p>图1——构建系统所面临的普遍性挑战</p><p></p><p>构建可以解决有效性相关问题（例如，解决方案与用户需求的一致性）的东西。为用户创造有意义的价值对组织取得成功来说至关重要。这涉及理解问题并分享对问题共同的见解。在构建事物时关注效率，特别是工程实践的效率。效率是关于利用率的，不仅要能够产生价值，而且要能够很好地交付价值。这关系到我们能够多快地交付变更，能够多快、多容易地让变更生效并适应新情况。构建正确的事物与正确地构建事物缺一不可。但正如Russell Ackoff博士所指出的那样，“把错误的事情做对了并不会比把正确的事情做错了好。”</p><p></p><p></p><h1>设计具有适应性的组织</h1><p></p><p></p><p>为了构建能够在不断变化的环境中进行演进和蓬勃发展的自适应协作性技术系统——兼顾有效性和效率，用正确的方式构建出正确的事物并考虑整体性——我们需要一种结合了各种观点的整体性方法。它要求我们理解组织运营和竞争的业务环境，包括影响环境的外部力量，以便设计出有效的业务战略。它要求我们获得领域知识并理解业务领域，以便构建与业务需求和战略紧密对齐的系统。它不仅要求对齐技术解决方案，还要求对齐团队，并让它们的交互与我们构建的系统和计划的战略保持同步演进。</p><p></p><p></p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/adaptive-socio-technical-systems-flow/en/resources/28figure-2-1688720198596.jpg\" /></p><p></p><p>图2——Wardley Mapping、领域驱动设计和团队拓扑相结合</p><p></p><p>换句话说：一种设计、构建和演进针对快速变化流而优化的自适应协作性技术系统的方法可能是将Wardley Mapping、领域驱动设计（DDD）和团队拓扑这些点连接起来。</p><p></p><p></p><h1>使用Wardley Map来可视化环境</h1><p></p><p></p><p>要理解组织运营和竞争所处的业务环境，创建Wardley Map是一个很好的起点。Wardley Map是Wardley Mapping的一部分——Simon Wardley发明的一种商业战略框架。Wardley Map可以对环境和价值链的演变进行可视化。它提供了一种结构化的方式来讨论环境，并帮助我们识别出组织可以创新、提高效率或外包以获得竞争优势的领域。</p><p></p><p>在创建Wardley Map时，我们通常从确定用户和用户需求开始——它们是Map的锚点。用户可以是客户、商业伙伴、股东、内部用户，等等。在一个在线教学解决方案的示例中，如图3所示，教师和学生就是用户。教师可以创建课程内容、做出课堂计划并在学生学习期间提供支持。学生的需求是学习课程、发起和接受帮助，以及接收评估反馈。两者都需要注册和登录。一系列向用户传递价值的组件直接或间接地满足了这些用户需求。教师和学生直接与在线教学组件发生交互，这个组件对用户是可见的，位于价值链的顶部。此时，在线教学组件是一个单体大泥球，如果我们从DDD的视角来看它，我们可以将其分解为更小的部分。</p><p></p><p></p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/adaptive-socio-technical-systems-flow/en/resources/23figure-3-1688720198596.jpg\" /></p><p></p><p>图3——Wardley Map的价值链（Y轴）</p><p></p><p>在线教学组件依赖于其他组件，例如基础设施组件（数据存储、搜索引擎、消息代理SMTP服务器、运行在虚拟机组件之上的计算平台组件）。它们对用户不太可见，并处于价值链的更下方的位置。</p><p></p><p>价值链的组件通常被映射到各个演化阶段，例如创世纪、定制构建、产品（+租赁）（现成产品或开源解决方案）和商品（+实用组件）。每个演化阶段都具有不同的特征，如图4所示。Wardley Map左侧光谱位置的组件比光谱右侧的组件变化得更加频繁。在左边，我们面临的是高度不确定性和未被定义、未被充分理解的市场。而在右侧光谱上，组件变得更加稳定、知名、广泛和标准化，市场也变得明确和成熟。</p><p></p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/adaptive-socio-technical-systems-flow/en/resources/14figure-4-1688720198596.jpg\" /></p><p></p><p>图4——各个演变阶段的特征</p><p></p><p>我们可以利用这些特征来确定价值链组件或在线教学解决方案的演化阶段，如图5所示。在线教学组件反映了一个经常变化并能够提供竞争优势的不稳定组件，它应该进入到定制构建演化阶段。对于基础设施组件，如搜索引擎、数据存储、消息代理等，我们目前正在使用开源解决方案，而虚拟机组件由服务器托管提供商作为现成产品提供，所以当前状态的基础设施组件进入了产品（+租赁）演化阶段。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/adaptive-socio-technical-systems-flow/en/resources/12figure-5-1688720198596.jpg\" /></p><p></p><p>图5——价值链组件与各个演化阶段映射（X轴）</p><p></p><p>这个Wardley Map代表了第一次迭代。Wardley Map并不会精确完美地表示环境，它只会提供有用的抽象和近似。与一群人一起创建Wardley Map会带来相当大的价值，它可以促进参与者对环境的共同理解。与他人分享Wardley Map有助于对自己的假设提出挑战。这些对话有助于共同讨论和理解当前和未来的环境。我们可以将当前环境的Wardley Map作为未来讨论演化系统的基础。</p><p></p><p>Wardley Map只是Wardley Mapping的一部分。一般来说，Wardley Mapping有助于根据情境意识和战略周期活动设计和演化有效的商业战略。图6描绘的战略周期包含了“变化的表示，以及我们如何应对它”。</p><p></p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/adaptive-socio-technical-systems-flow/en/resources/9figure-6-1688720198596.jpg\" /></p><p></p><p>图6——Wardley Mapping的战略周期</p><p></p><p>战略周期包括五个部分，从目标（Purpose，描述了组织存在的原因和动机）开始。Landscape代表组织运营的竞争环境——通过Wardley Map进行了可视化，如前所述。</p><p></p><p>为了预测变化并识别出创新领域，我们需要了解影响环境的外部力量——这里被描述为气候（Climate）模式。例如，有一种气候模式是环境不是静止的，而是动态的：一切都通过需求和供应的竞争来推动演化。云托管服务就反映了这种气候模式。几十年前不存在的东西通过创世纪、定制构建阶段成为产品，然后进一步成为商品。</p><p></p><p>为了能够快速响应变化并优雅地吸收变化，Wardley Mapping建议应用与上下文无关的教义（Doctrine）原则。教义原则是每个行业都可以应用的普遍原则，与上下文无关。例如，教义原则“每个演化阶段采用适当的方法”建议在创世纪或定制构建演化阶段通过敏捷方法来构建组件，对产品（+租赁）阶段的组件使用或购买现成产品或开源软件（使用精益方法），或将商品阶段的组件外包给供应商（使用六西格玛方法）。在本文后面，我们将讨论如何将这一教义原则与DDD子领域类型相结合。</p><p></p><p>领导力是Wardley Mapping战略周期的最后一个部分，主要是关于在考虑环境、气候和教义的情况下选择什么战略。Simon Wardley提供了一系列游戏玩法，它们描述了组织在创建新市场、在既定市场参与竞争、保护现有市场地位和退出衰落市场方面可以采取的战略行动。</p><p></p><p></p><h1>从团队角度看流程优化的要求</h1><p></p><p></p><p>为了从团队角度优化快速的变更流程，我们需要避免组建孤岛功能团队。相反，我们需要致力于组建自主、跨职能的团队，他们负责设计、开发、测试、部署和运营他们负责的系统。我们需要避免繁琐的交接工作，这样在实现和发布变更时就不需要将工作交接给另一个团队。我们需要将小型、长寿命的团队作为常态。团队需要有他们所负责的系统或子系统的所有权。他们需要承担端到端责任，这样才能实现快速流动。我们需要降低团队的认知负担。如果团队的认知负担出现超载，就会成为导致质量问题和延迟交付的瓶颈。虽然团队内部的沟通是必需的，但我们也需要限制团队之间持续的高带宽沟通，以实现快速的流动（见图7）。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/adaptive-socio-technical-systems-flow/en/resources/4figure-7-1688720198596.jpg\" /></p><p></p><p>图7——从团队角度看流程优化的要求</p><p></p><p></p><h1>团队拓扑基础</h1><p></p><p></p><p>在这方面，团队拓扑能够帮到我们，它们有明确定义的团队类型（见图8）和明交互模式（见图9）。流对齐团队是指自主、跨职能且与专注于快速变化的持续工作流对齐团队。为了能够进行稳定的功能交付并专注于快速变化流，流对齐团队需要其他团队的支持，例如平台团队。平台团队为流对齐团队提供支持，并负责提供流对齐团队可以轻松使用的自助平台。平台团队为他们所负责的平台提供内部自助服务和工具。赋能团队可以被认为是内部教练，帮助流对齐团队识别和获取他们缺失的能力。复杂子系统团队——作为可选团队类型——可以在需要专业知识的、特别复杂的子系统上为流对齐对齐团队提供支持。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/adaptive-socio-technical-systems-flow/en/resources/4figure-8-1688720198596.jpg\" /></p><p></p><p>图8——团队拓扑的四种团队类型</p><p></p><p>所有这些团队类型都旨在增加自主性并减少流对齐团队的认知负担，最终实现快速变化流。</p><p></p><p>光是拥有上述这些团队类型还不足以奏效，要提升组织效能，如何让这些团队相互交互以及何时做出改变和演化也非常重要。</p><p></p><p>图9画出了团队拓扑建议的交互模式。团队在有限的时间内进行紧密的合作，这非常适合用于进行快速发现和创新，例如探索新技术。协作的时间应该是短暂的。当一个团队需要使用代码库、组件、API或平台时，可以采用“X即服务”这种方式，这些东西可以由另一个团队按照“即服务”的方式来提供。这在需要进行可预测交付的场景中表现最好。当一个团队能从另一个团队的帮助中获得收益时，促进作用才会见效。这种交互模式是给团队赋能的典型模式。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/adaptive-socio-technical-systems-flow/en/resources/4figure-9-1688720198596.jpg\" /></p><p></p><p>图9——团队拓扑的三种交互模式</p><p></p><p>流对齐团队、平台团队、赋能团队和可选的复杂子系统团队及其协作、X即服务和促进等交互模式提升了组织效能。</p><p></p><p></p><h1>识别变化流</h1><p></p><p></p><p>要应用团队拓扑并优化流程系统，我们可以将之前创建的Wardley Map作为基础。要优化快速变化流系统，我们需要知道系统中最重要的变化发生在哪里——即变化流。变化流的类型因任务、角色、活动、地理位置和客户细分导向的流类型而不同。在我们的示例中，我们关注的是Wardley Map用户需求所代表的活动流。创建课程内容、规划课程等用户需求——如图10所示——属于活动导向流类型，它们是优化流程时需要着重关注的点。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/adaptive-socio-technical-systems-flow/en/resources/4figure-10-1688720198596.jpg\" /></p><p></p><p>图10——将用户需求作为活动导向的变化流</p><p></p><p></p><h1>划分问题域并找出核心域</h1><p></p><p></p><p>用户和用户需求不仅是Wardley Map的锚点，也可以表示问题域。在这里，我们可以引入DDD。DDD可以帮助我们获取与问题域相关的领域知识，并将问题域划分为更小的部分——子域。但并非所有子域都是同等重要——有些在业务上比其他子域更有价值。我们有不同类型的子域，如图11所示。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/adaptive-socio-technical-systems-flow/en/resources/4figure-11-1688720198596.jpg\" /></p><p></p><p>图11——DDD的子域类型</p><p></p><p>核心域是问题域最重要的部分，是我们必须进行最多战略性投入并在内部为其构建软件的子域。创建课程内容、规划课程、提供学习支持和学习课程等用户需求属于核心域，它们会带来高级别的差异化。购买或外包这个子域的解决方案会影响企业取得成功，因此我们必须在内部为核心域构建软件。</p><p></p><p>学生的学习进度评估并不是很重要，但它为教师体验提供支持，对组织取得成功来说是必要的。这些用户需求属于支持子域——见图11。支持子域有助于支持核心域，虽然它们不提供竞争优势，但对组织取得成功来说是必要的，并且在其他竞争对手的解决方案中也普遍存在。如果可能，我们应该购买现成产品或使用开源软件解决方案来支持子域。如果不可能，并且必须为子域定制软件，我们也不应该在系统的这部分投入过多。</p><p></p><p>登录和注册属于通用子域的用户需求。通用子域是许多业务系统都拥有的子域，如身份验证和注册，它们不是核心，也不提供竞争优势，但又不能没有它们。这些问题通常已经有人解决过了，所以可以购买现成产品或使用开源解决方案，或将通用子域的解决方案外包给供应商。</p><p></p><p>子域类型可以帮助我们确定战略投入、定制构建、购买和外包决策的优先级。</p><p></p><p></p><h1>有界上下文作为团队边界</h1><p></p><p></p><p>子域的解决方案目前都混杂在一个紧密耦合的单体中，模型混乱，没有明确的边界。为了对变化做出响应，在线教学示例的架构需要进行具有高功能内聚性和松散耦合性的模块化。我们需要将在线教学组件分解为模块化组件，这个时候需要使用DDD的有界上下文。有界上下文对相关业务行为进行分组，并反映出域模型可以应用的边界。有界上下文不仅有助于拆分系统，也可以作为有效的所有权边界。设计有界上下文和域模型需要领域专家和开发团队之间进行紧密的合作，以获得对领域的共同理解。设计有界上下文和域模型可以使用多种互补的技术，如EventStorming、Domain Storytelling等。</p><p></p><p>图12画出了在线教学示例的有界上下文。内容创建、课程管理、课程学习和学习支持的有界上下文与核心域相关的用户需求相匹配。它们在战略上很重要，需要最多的开发工作。它们处于定制构建演化阶段，并需要在内部构建。</p><p></p><p>学生学习进度评估和通知处理的有界上下文属于支持子域，市场上可能已经有相应的解决方案。不过团队认为需要更高水平的专业化，所以要在内部构建它们，但开发投入不应过高。</p><p></p><p>身份和访问管理有界上下文属于通用子域，市场上已经存在几种解决方案，应该处于产品（+租赁）或商品（+实用组件）演化阶段。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/adaptive-socio-technical-systems-flow/en/resources/3figure-12-1688720198596.jpg\" /></p><p></p><p>图12——在线教学示例的有界上下文</p><p></p><p>有界上下文不仅有助于拆分系统，而且也可以作为有效的所有权边界，可以形成意图、可控和自主的单元。有界上下文为流对齐团队指出了合适的团队边界，如图13所示。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/adaptive-socio-technical-systems-flow/en/resources/3figure-13-1688720198596.jpg\" /></p><p></p><p>图13——有界上下文作为对齐团队的团队边界</p><p></p><p></p><h1>识别可为变化流提供支持的服务</h1><p></p><p></p><p>为了能够专注于快速变化流，流对齐团队需要其他团队的支持，他们依赖其他团队的支持来完成工作。这就需要识别出可靠变化流所需的服务，这些服务可以形成自助平台，提供易于使用的“X即服务”。一般来说，平台可以有不同的抽象层次。从高层次上看，平台可以是设计系统、数据平台等。从较低的层次看，平台可以抽象掉基础设施或横切能力。在我们的在线教学示例中，位于产品（+租赁）和商品（+实用组件）演化阶段的Wardley Map中与基础设施相关的组件可以成为平台服务，由平台团队负责提供（见图14）。</p><p></p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/adaptive-socio-technical-systems-flow/en/resources/3figure-14-1688720198596.jpg\" /></p><p></p><p>图14——为可靠变化流提供支持的服务</p><p></p><p></p><h1>可能的团队组合</h1><p></p><p></p><p>按照前面考虑的事项，这个团队组合可以作为初稿，如图15所示。一般来说，组织中的大多数团队都将是具有端到端责任的跨职能、自主的团队。为了实现清晰的责任边界，一个有界上下文只能由一个团队拥有，但一个团队可以拥有多个有界上下文。处于定制构建演化阶段的四个与核心域相关的有界上下文将在三个流对齐团队之间进行分配。我们示例中支持和通用子域相关的有界上下文将由另一个流对齐团队负责，基础设施组件将由一个或多个平台团队负责。</p><p></p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/adaptive-socio-technical-systems-flow/en/resources/3figure-15-1688720198596.jpg\" /></p><p></p><p>图15——一种可能的团队组合的初稿</p><p></p><p>平台团队可以提供各种平台来满足流对齐团队的需求，这可以在不同的Wardley Map中可视化，其中流对齐团队成为内部用户，然后我们继续找出和弥补能力差距，这个时候赋能团队就可以发挥作用了。</p><p></p><p></p><h1>从小处做起</h1><p></p><p></p><p>在应用和结合使用Wardley Mapping、领域驱动设计和团队拓扑之前，你不需要详细了解它们。你可以从对上下文最有用的部分开始。你可以先和小组在一起创建一个Wardley Map，形成对竞争环境的共同理解。在与他人创建和分享Wardley Map并挑战自己的假设时，就已经产生了重大价值。你可以将Wardley Map作为一种结构化的指导和继续对话的方式，例如，识别合适的变化流和团队边界，如本文所示。</p><p></p><p>你也可以考虑从你的团队开始，分析他们当前的认知负担和交付瓶颈。他们是否在存在重复的交接，是否在进行高水平的沟通和协调，是否存在阻塞依赖，是否缺乏所有权边界，是否存在团队认知负担过高等问题？这些对话可能有助于流对齐和识别出合适的团队边界、分解系统，等等。</p><p></p><p>或者，你也可以从你当前的软件架构开始，评估它对变化的响应能力，例如，分析哪些部分与特定变化耦合在一起以及这些部分是如何耦合在一起的。这可能会将对话引向识别适合模块化的边界，而DDD可以通过子域和有界上下文在这方面提供帮助。每一个起点的路径到了某个时候会相交，形成了流动架构。这只是设计和构建自适应协作性技术系统的一种方法。此外，你还可以用其他技术和框架来补充优化你的系统，例如价值流映射、独立服务启发式、Cynefin，等等。</p><p></p><p>作者简介：</p><p>Susanne Kaiser是德国汉堡的一位独立技术顾问，协助企业建立协作性技术系统。她热衷于将Wardley Mapping、领域驱动设计和团队拓扑连接起来，作为一种整体性方法来设计和构建适应快速变化的系统。Susanne之前是一家初创公司的首席技术官，拥有计算机科学背景和软件开发和架构方面的经验。她是“daptive Systems with Domain-Driven Design, Wardley Mapping, and Team Topologies: Architecture for Flow”（Addison-Wesley，2023）一书的作者。</p><p></p><p></p><p>查看英文：</p><p><a href=\"https://www.infoq.com/articles/adaptive-socio-technical-systems-flow/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTI1ODMzMTQsImZpbGVHVUlEIjoiWGFyRHlXeGNHemtST0tWayIsImlhdCI6MTY5MjU4MzAxNCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.wtuVuflxgm7QL6TD9Ecgjn9dOXrMqoB5CFl71xfE2Y8\">https://www.infoq.com/articles/adaptive-socio-technical-systems-flow/</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/wYLteaRbYxU8pgQIairg\">持续集成的关键：产品反馈驱动实践</a>\"</p><p><a href=\"https://www.infoq.cn/article/ZmNiV7F2973R19QVTYkO\">领域驱动探索：开启架构现代化转型之路</a>\"</p>",
    "publish_time": "2023-08-27 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Next.js + Rust 革新全栈开发，Rust没那么难",
    "url": "https://www.infoq.cn/article/Lc1XBgdrphTqv42CQ70x",
    "summary": "<p>最近，shuttle 发布了新的 Node.js CLI 包，允许用户快速引导由 Next.js 前端加 Axum 后端（一种流行的 Rust Web 框架，以易于上手、语法简单著称）开发的应用程序。</p><p></p><p>本文打算构建的示例，是一个带有登录门户的记事本应用程序，提供用户注册、用户登录、密码重置等功能。用户在登录之后可以查看、创建、更新和删除笔记内容。本文将主要关注 Rust 后端方面，对于 React.js/Next.js 前端不会过多着墨。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/07/07598477bf5108725f24e4f2889539f1.png\" /></p><p></p><p>完整代码仓库请参阅此处（<a href=\"https://github.com/joshua-mo-143/nodeshuttle-example%EF%BC%89%E3%80%82\">https://github.com/joshua-mo-143/nodeshuttle-example）。</a>\"</p><p></p><p></p><h2>马上开始</h2><p></p><p></p><p>运行以下命令，即可快速开始本次示例：</p><p></p><p><code lang=\"sql\">npx create-shuttle-app --ts </code></p><p></p><p>在按下回车键后，系统会提示我们输入名称——您可以随意起名，之后系统会自动安装 Rust 并引导一个使用 Next.js 的应用程序（由于这里我们添加了 ts 标志，所以使用的是 TypeScript）；后端部分使用 Rust，再加上相应的 npm 命令，我们可以快速着手后端和前端的开发工作。这里我们使用的后端框架为 Axum，这是一套灵活的高性能框架，语法简单而且与 tower_http（用于创建中间件的强大库）高度兼容。</p><p></p><p>shuttle 是一个云开发平台，能够简化应用程序的部署流程。它最突出的优点就是“基础设施即代码”，允许大家直接通过代码定义基础设施，无需借助复杂的控制台或外部 yaml.config 文件。这种方式不仅提高了代码的清晰度，同时也能更好地保证编译时的输出质量。需要 Postgres 实例？只需添加相应注释即可。shuttle 还支持 secrets（作为环境变量）、静态文件夹和状态持久性。</p><p></p><p>接下来，我们需要安装 sqlx-cli，这款命令行工具能帮助我们管理数据库迁移。只须运行以下简单命令，即可完成安装：</p><p></p><p><code lang=\"nginx\">cargo install sqlx-cli</code></p><p></p><p>这样，只要前往项目文件夹内的后端目录，我们就能使用 sqlx migrate add schema 创建数据库迁移。此命令会添加一个迁移文件夹（如果之前不存在）和一个以_schema.sql 形式命名的新 SQL 文件，其中的“schema”部分代表我们的迁移名称。</p><p></p><p>这个 SQL 文件包含以下内容：</p><p></p><p><code lang=\"sql\">-- backend/migrations/_schema.sql\nDROP TABLE IF EXISTS sessions;\n\nCREATE TABLE IF NOT EXISTS users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR UNIQUE NOT NULL,\n    email VARCHAR UNIQUE NOT NULL,\n    password VARCHAR NOT NULL,\n    createdAt TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP \n);\n\nCREATE TABLE IF NOT EXISTS notes (\n    id SERIAL PRIMARY KEY,\n    message VARCHAR NOT NULL,\n    owner VARCHAR NOT NULL,\n    createdAt TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP \n);\n\nINSERT INTO notes (message, owner) VALUES ('Hello world!', 'user');\n\nCREATE TABLE IF NOT EXISTS sessions (\n    id SERIAL PRIMARY KEY,\n    session_id VARCHAR NOT NULL UNIQUE,\n    user_id INT NOT NULL UNIQUE\n);</code></p><p></p><p>迁移会自动运行。但如果大家想要手动操作，也可以使用 sqlx migrate run --database-url。这种操作之所以可行，是因为我们已经将 SQL 文件设置为幂等，就是说只要已经存在该表、则不再重复创建。这里我们删除会话表，这样当应用程序重新上传之后，由于原先的 cookie 已经失效，用户就必须重新登录。</p><p></p><p>现在设置已经完成，马上进入正式开发！</p><p></p><p></p><h2>前端</h2><p></p><p></p><p>在这款应用中，我们需要以下几个页面：</p><p></p><p>登录和注册页面；忘记密码时供用户重置密码的页面；显示记录的仪表板页面；用于编辑和创建新记录的页面。</p><p></p><p>大家可以通过以下方式克隆本文中的前端示例：</p><p></p><p><code lang=\"nginx\">git clone https://github.com/joshua-mo-143/nodeshuttle-example-frontend</code></p><p></p><p>克隆的代码仓库包含一个预先设置好的 src 目录，如下图所示：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/2d/2ddfb2e3a7718a37ff3477292f125f17.png\" /></p><p></p><p>其中 components 文件夹中包含两个布局组件，我们需要将页面组件嵌套在其中；另外还有一个用于在仪表板索引页面中编辑记录的 modal。Pages 文件夹则包含我们将在应用中使用的各相关页面组件（文件名代表相应路径）。</p><p></p><p>这里的 CSS 使用 TailwindCSS，并选择 Zustand 保证在不涉及太多模板的情况下实现简单的基本状态管理。</p><p></p><p>当用户登录之后，已有消息将显示为以下形式：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/d2/d2c758112a6dbe3e58de28f8caff7e74.png\" /></p><p></p><p>在后端构建完成之后，用户就能通过前端注册和登录（使用基于 cookie 会话的身份验证机制），并查看、创建、编辑和删除自己的消息。如果用户忘记了密码，还可以通过输入电子邮件来重置密码内容。</p><p></p><p>如果大家对示例中的前端不满意，也可以参考 GitHub 代码仓库（<a href=\"https://github.com/joshua-mo-143/nodeshuttle-example%EF%BC%89%E6%9D%A5%E4%BA%86%E8%A7%A3\">https://github.com/joshua-mo-143/nodeshuttle-example）来了解</a>\" API 调用和状态管理的设置方式。</p><p></p><p>现在前端部分已经完成，接下来就是后端环节了！</p><p></p><p></p><h2>后端</h2><p></p><p></p><p>前往 backend 文件夹，我们会看到一个名为 main.rs 的文件。其中包含一个函数，此函数会创建一个基础路由程序并返回“Hello,world！”我们将使用此文件作为应用程序的入口点，然后创建我们在 main 函数中调用的其他文件。</p><p></p><p>请确保您的 Cargo.toml 文件中包含以下内容：</p><p></p><p><code lang=\"ini\"># Cargo.toml\n[package]\nname = \"static-next-server\"\nversion = \"0.1.0\"\nedition = \"2021\"\npublish = false\n\n[dependencies]\n# the rust framework we will be using - https://github.com/tokio-rs/axum/\naxum = \"0.6.1\"\n# extra functionality for Axum https://github.com/tokio-rs/axum/\naxum-extra = { version = \"0.4.2\", features = [\"spa\", \"cookie-private\"] }\n# encryption hashing for passwords - https://github.com/Keats/rust-bcrypt\nbcrypt = \"0.13.0\"\n# used for writing the CORS layer - https://github.com/hyperium/http\nhttp = \"0.2.9\"\n# send emails over SMTP - https://github.com/lettre/lettre\nlettre = \"0.10.3\"\n# random number generator (for creating a session id) - https://github.com/rust-random/rand\nrand = \"0.8.5\"\n# used to be able to deserialize structs from JSON - https://github.com/serde-rs/serde\nserde = { version = \"1.0.152\", features = [\"derive\"] }\n# environment variables on shuttle\nshuttle-secrets = \"0.12.0\"\n# the service wrapper for shuttle\nshuttle-runtime = \"0.12.0\"\n# allow us to use axum with shuttle\nshuttle-axum = \"0.12.0\"\n# this is what we use to get a shuttle-provisioned database\nshuttle-shared-db = { version = \"0.12.0\", features = [\"postgres\"] }\n# shuttle static folder support\nshuttle-static-folder = \"0.12.0\"\n# we use this to query and connect to a database - https://github.com/launchbadge/sqlx/\nsqlx = { version = \"0.6.2\", features = [\"runtime-tokio-native-tls\", \"postgres\"] }\n# middleware for axum router - https://github.com/tower-rs/tower-http\ntower-http = { version = \"0.4.0\", features = [\"cors\"] }\n# pre-req for using shuttle runtime   \ntokio = \"1.26.0\"\n# get a time variable for setting cookie max age\ntime = \"0.3.20\"</code></p><p></p><p>完成之后，接下来就是设置主函数，这样就能使用 shuttle_shared_db 和 shuttle_secrets 来获取 shuttle 免费配置的数据库并使用 secrets，具体方式如下（包括基于 cookie 的会话存储功能，为简洁起见较为粗糙）：</p><p></p><p><code lang=\"properties\">// main.rs\n #[derive(Clone)]\npub struct AppState {\n    postgres: PgPool,\n    key: Key\n}\n\nimpl FromRef for Key {\n    fn from_ref(state: &amp;AppState) -&gt; Self {\n        state.key.clone()\n    }\n}\n\n#[shuttle_runtime::main]\nasync fn axum(\n    #[shuttle_static_folder::StaticFolder] static_folder: PathBuf,\n    #[shuttle_shared_db::Postgres] postgres: PgPool,\n    #[shuttle_secrets::Secrets] secrets: SecretStore,\n) -&gt; shuttle_axum::ShuttleAxum {\n    sqlx::migrate!().run(&amp;postgres).await;\n\n    let state = AppState {\n        postgres,\n        key: Key::generate()\n    };\n\n    let router = create_router(static_folder, state);\n\n    Ok(router.into())\n}</code></p><p></p><p>现在就可以创建路由程序了！我们首先要在 backend 目录的 src 文件夹中创建一个 router.rs 文件。我们的大部分路由程序代码都将存放在这里，并在准备好之后将最终版路由程序的函数导入到主文件当中。</p><p></p><p>现在打开 router.rs 文件并创建一个函数，该函数将返回一个能够路由至注册和登录的路由程序：</p><p></p><p><code lang=\"swift\">// router.rs\n\n// typed request body for logging in - Deserialize is enabled via serde so it can be extracted from JSON responses in axum\n#[derive(Deserialize)]\npub struct LoginDetails {\n    username: String,\n    password: String,\n}\n\npub fn create_router(state: AppState, folder: PathBuf) -&gt; Router {\n// create a router that will host both of our new routes once we create them\n    let api_router = Router::new()\n           .route(\"/register\", post(register))\n           .route(\"/login, post(login))\n           .with_state(state);\n\n// return a router that nests our API router in an \"/api\" route and merges it with our static files\n   Router::new()\n       .nest(\"/api\", api_router)\n       .merge(SpaRouter::new(\"/\", static_folder).index_file(\"index.html\"))\n\n}</code></p><p></p><p>可以看到，接下来要做的就是编写路由程序中使用的函数。另外，我们也可以简单将多个方法串连起来，借此在同一路由内使用多个请求方法（后文将具体介绍）。</p><p></p><p><code lang=\"sql\">// backend/src/router.rs\npub async fn register(\n// this is the struct we implement and use in our router - we will need to import this from our main file by adding \"use crate::AppState;\" at the top of our app\n    State(state): State,\n// this is the typed request body that we receive from a request - this comes from the axum::Json type\n    Json(newuser): Json,\n) -&gt; impl IntoResponse { \n\n// avoid storing plaintext passwords - when a user logs in, we will simply verify the hashed password against the request. This is safe to unwrap as this will basically never fail\n     let hashed_password = bcrypt::hash(newuser.password, 10).unwrap();\n\n    let query = sqlx::query(\"INSERT INTO users (username, , email, password) values ($1, $2, $3)\")\n// the $1/$2 denotes dynamic variables in a query which will be compiled at runtime - we can bind our own variables to them like so:\n        .bind(newuser.username)\n        .bind(newuser.email)\n        .bind(hashed_password)\n        .execute(&amp;state.postgres);\n\n// if the request completes successfully, return CREATED status code - if not, return BAD_REQUEST\n    match query.await {\n        Ok(_) =&gt; (StatusCode::CREATED, \"Account created!\".to_string()).into_response(),\n        Err(e) =&gt; (\n            StatusCode::BAD_REQUEST,\n            format!(\"Something went wrong: {e}\"),\n        )\n            .into_response(),\n    }\n}</code></p><p></p><p>我们在这里对密码做散列处理，通过 SQLx 设置查询以创建新用户。如果成功，则返回 402 Created 状态码；如果不成功，则返回 400 Bad Request 状态码以指示错误。</p><p></p><p>模式匹配是 Rust 中一种非常强大的错误处理机制，而且提供多种使用方式：我们可以使用 if let else 和 let else，二者都涉及模式匹配，后文将具体介绍。</p><p></p><p><code lang=\"php\">// backend/src/router.rs\npub async fn login(\n    State(mut state): State,\n    jar: PrivateCookieJar,\n    Json(login): Json,\n) -&gt; Result&lt;(PrivateCookieJar, StatusCode), StatusCode&gt; {\n    let query = sqlx::query(\"SELECT * FROM users WHERE username = $1\")\n        .bind(&amp;login.username)\n        .fetch_optional(&amp;state.postgres);\n\n    match query.await {\n        Ok(res) =&gt; {\n// if bcrypt cannot verify the hash, return early with a BAD_REQUEST error\n            if bcrypt::verify(login.password, res.unwrap().get(\"password\")).is_err() {\n                return Err(StatusCode::BAD_REQUEST);\n            }\n// generate a random session ID and add the entry to the hashmap \n                let session_id = rand::random::().to_string();\n\n                sqlx::query(\"INSERT INTO sessions (session_id, user_id) VALUES ($1, $2) ON CONFLICT (user_id) DO UPDATE SET session_id = EXCLUDED.session_id\")\n                .bind(&amp;session_id)\n                .bind(res.get::(\"id\"))\n                .execute(&amp;state.postgres)\n                .await\n                .expect(\"Couldn't insert session :(\");\n\n\n            let cookie = Cookie::build(\"foo\", session_id)\n                .secure(true)\n                .same_site(SameSite::Strict)\n                .http_only(true)\n                .path(\"/\")\n                .finish();\n\n// propogate cookies by sending the cookie as a return type along with a status code 200\n            Ok((jar.add(cookie), StatusCode::OK))\n\n        }\n// if the query fails, return status code 400\n        Err(_) =&gt; Err(StatusCode::BAD_REQUEST),\n    }\n}</code></p><p></p><p>可以看到，请求仅采用各类 JSON 请求主体（因为我们将请求主体设定为 axum::Json 类型，所以它只会接受带有「username」和「password」JSON 请求主体的请求）。这样的 struct 必须实现 serde::Deserialize ，因为我们需要从 JSON 中提取数据，而且 JSON 请求参数本身将作为我们传递给路由函数的最后一个参数。</p><p></p><p>我们在登录请求中使用了名为 PrivateCookieJar 的 struct。通过这种方式，我们既可以自动处理 HTTP cookie，又不需要为其显式设置标题头（为了传播其中的变更，我们需要将其设置为返回类型并返回变更）。当用户想要访问受保护的路由时，需要从 cookie jar 当中获取值，再根据保存在数据库内的会话 ID 对其进行验证。因为使用的是私有 cookie jar，所以保存在客户端的任何 cookie 都将使用我们在初始 struct 内创建的密钥进行加密，且每次应用启动时都会生成一个新密钥。</p><p></p><p>现在我们已经添加了用于登录的路由，接下来看看如何添加用于注销的路由和用于验证会话的中间件：</p><p></p><p><code lang=\"php\">// backend/src/router.rs\npub async fn logout(State(state): State, jar: PrivateCookieJar) -&gt; Result {\n    let Some(cookie) = jar.get(\"foo\").map(|cookie| cookie.value().to_owned()) else {\n        return Ok(jar)\n    };\n\n    let query = sqlx::query(\"DELETE FROM sessions WHERE session_id = $1\")\n        .bind(cookie)\n        .execute(&amp;state.postgres);\n\n\n        match query.await {\n        Ok(_) =&gt; Ok(jar.remove(Cookie::named(\"foo\"))),\n        Err(_) =&gt; Err(StatusCode::INTERNAL_SERVER_ERROR)       \n    }\n}\n\n\n\npub async fn validate_session<b>(\n    jar: PrivateCookieJar,\n    State(state): State,\n// Request<b> and Next<b> are required types for middleware from a function in axum\n    request: Request<b>,\n    next: Next<b>,\n) -&gt; (PrivateCookieJar, Response) {\n// attempt to get the cookie - if it can't find a cookie, return 403\n    let Some(cookie) = jar.get(\"foo\").map(|cookie| cookie.value().to_owned()) else {\n\n        println!(\"Couldn't find a cookie in the jar\");\n        return (jar,(StatusCode::FORBIDDEN, \"Forbidden!\".to_string()).into_response())\n    };\n\n// attempt to find the created session\n    let find_session = sqlx::query(\"SELECT * FROM sessions WHERE session_id = $1\")\n                .bind(cookie)\n                .execute(&amp;state.postgres)\n                .await;\n\n// if the created session is OK, carry on as normal and run the route - else, return 403\n    match find_session {\n        Ok(res) =&gt; (jar, next.run(request).await),\n        Err(_) =&gt; (jar, (StatusCode::FORBIDDEN, \"Forbidden!\".to_string()).into_response())\n    }\n}</b></b></b></b></b></code></p><p></p><p><b><b><b>可以看到，在注销路由这部分，我们会尝试销毁会话、返回 cookie 删除；至于验证路由，我们尝试获取会话 cookie，并保证 cookie 会话在数据库内有效。</b></b></b></p><p></p><p><b><b><b>下面来看如何为数据库内的各项记录创建最基本的 CRUD 功能。这里我们创建一个使用 sqlx::FromRow 的 struct，这样就能轻松从数据库中提取记录，具体代码如下所示：</b></b></b></p><p></p><p><b><b><b><code lang=\"properties\">// src/backend/router.rs\n#[derive(sqlx::FromRow, Deserialize, Serialize)]\npub struct Note {\n    id: i32,\n    message: String,\n    owner: String,\n}</code></b></b></b></p><p></p><p><b><b><b>之后，我们就可以直接使用 sqlx::query_as 并将该变量分类为 struct 的向量，借此实现预期功能，如下所示：</b></b></b></p><p></p><p><b><b><b><code lang=\"javascript\">// src/backend/router.rs\npub async fn view_records(State(state): State) -&gt; Json&gt; {\n    let notes: Vec = sqlx::query_as(\"SELECT * FROM notes \")\n        .fetch_all(&amp;state.postgres)\n        .await.unwrap();\n\n    Json(notes)\n}</code></b></b></b></p><p></p><p><b><b><b>很明显，我们要做的就是通过连接查询数据库，并确保我们分类后的返回 struct 上有 sqlx::FromRow 派生宏。通过同样的方式，我们也可以轻松编写出其他路由：</b></b></b></p><p></p><p><b><b><b><code lang=\"php\">// backend/src/router.rs\n#[derive(Deserialize)]\npub struct RecordRequest {\n    message: String,\n    owner: String\n}\n\npub async fn create_record(\n    State(state): State,\n    Json(request): Json,\n) -&gt; Response {\n    let query = sqlx::query(\"INSERT INTO notes (message, owner) VALUES ($1, $2)\")\n        .bind(request.message)\n        .bind(request.owner)\n        .execute(&amp;state.postgres);\n\n    match query.await {\n        Ok(_) =&gt; (StatusCode::CREATED, \"Record created!\".to_string()).into_response(),\n        Err(err) =&gt; (\n            StatusCode::BAD_REQUEST,\n            format!(\"Unable to create record: {err}\"),\n        )\n            .into_response(),\n    }\n}\n\n// note here: the \"path\" is simply the id URL slug, which we will define later\npub async fn edit_record(\n    State(state): State,\n    Path(id): Path,\n    Json(request): Json,\n) -&gt; Response {\n\n    let query = sqlx::query(\"UPDATE notes SET message = $1 WHERE id = $2 AND owner = $3\")\n        .bind(request.message)\n        .bind(id)\n        .bind(request.owner)\n        .execute(&amp;state.postgres);\n\n    match query.await {\n        Ok(_) =&gt; (StatusCode::OK, format!(\"Record {id} edited \")).into_response(),\n        Err(err) =&gt; (\n            StatusCode::BAD_REQUEST,\n            format!(\"Unable to edit message: {err}\"),\n        )\n            .into_response(),\n    }\n}\n\npub async fn destroy_record(State(state): State, Path(id): Path) -&gt; Response {\n    let query = sqlx::query(\"DELETE FROM notes WHERE id = $1\")\n        .bind(id)\n        .execute(&amp;state.postgres);\n\n    match query.await {\n        Ok(_) =&gt; (StatusCode::OK, \"Record deleted\".to_string()).into_response(),\n        Err(err) =&gt; (\n            StatusCode::BAD_REQUEST,\n            format!(\"Unable to edit message: {err}\"),\n        )\n            .into_response(),\n    }\n}</code></b></b></b></p><p></p><p><b><b><b>现在，我们已经为这款 Web 应用创建了所有基本功能！但在合并全部路由之前，我们还有最后一项工作。如果用户想要重置密码，应当如何操作？我们当然应该再提供一条自助式的密码重置路由，下面马上开始。</b></b></b></p><p></p><p><b><b><b><code lang=\"php\">// backend/src/router.rs\n\npub async fn forgot_password(\n    State(state): State,\n    Json(email_recipient): Json,\n) -&gt; Response {\n    let new_password = Alphanumeric.sample_string(&amp;mut rand::thread_rng(), 16);\n\nlet hashed_password = bcrypt::hash(&amp;new_password, 10).unwrap();\n\n    sqlx::query(\"UPDATE users SET password = $1 WHERE email = $2\")\n            .bind(hashed_password)\n            .bind(email_recipient)\n            .execute(&amp;state.postgres)\n            .await;\n\n    let credentials = Credentials::new(state.smtp_email, state.smtp_password);\n\n    let message = format!(\"Hello!\\n\\n Your new password is: {new_password} \\n\\n Don't share this with anyone else. \\n\\n Kind regards, \\nZest\");\n\n    let email = Message::builder()\n        .from(\"noreply \".parse().unwrap())\n        .to(format!(\"&lt;{email_recipient}&gt;\").parse().unwrap())\n        .subject(\"Forgot Password\")\n        .header(ContentType::TEXT_PLAIN)\n        .body(message)\n        .unwrap();\n\n// build the SMTP relay with our credentials - in this case we'll be using gmail's SMTP because it's free\n    let mailer = SmtpTransport::relay(\"smtp.gmail.com\")\n        .unwrap()\n        .credentials(credentials)\n        .build();\n\n// this part x`doesn't really matter since we don't want the user to explicitly know if they've actually received an email or not for security purposes, but if we do then we can create an output based on what we return to the client\n    match mailer.send(&amp;email) {\n        Ok(_) =&gt; (StatusCode::OK, \"Sent\".to_string()).into_response(),\n        Err(e) =&gt; (StatusCode::BAD_REQUEST, format!(\"Error: {e}\")).into_response(),\n    }\n}\n</code></b></b></b></p><p></p><p><b><b><b>我们还需要在 Cargo.toml 层级上使用 Secrets.toml 和 Secrets.dev.toml 文件来添加必要的 secrets。为此，我们需要使用以下格式：</b></b></b></p><p></p><p><b><b><b><code lang=\"ini\"># Secrets.toml\nSMTP_EMAIL=\"your-email-goes-here\"\nSMTP_PASSWORD=\"your-email-password-goes-here\"\nDOMAIN=\".shuttleapp.rs\"\n\n# You can create a Secrets.dev.toml to use secrets in a development environment - in this case, you can set domain to \"127.0.0.1\" and copy the other two variables as required.</code></b></b></b></p><p></p><p><b><b><b>现在应用已经开发完成，接下来就是要为应用整体建立出口路由程序了。我们可以简单进行路由嵌套，并把中间件附加到受保护的路由上，如下所示：</b></b></b></p><p></p><p><b><b><b><code lang=\"typescript\">// backend/src/router.rs\npub fn api_router(state: AppState) -&gt; Router {\n// CORS is required for our app to work\n    let cors = CorsLayer::new()\n        .allow_credentials(true)\n        .allow_methods(vec![Method::GET, Method::POST, Method::PUT, Method::DELETE])\n        .allow_headers(vec![ORIGIN, AUTHORIZATION, ACCEPT])\n        .allow_origin(state.domain.parse::().unwrap());\n\n// declare the records router\n    let notes_router = Router::new()\n        .route(\"/\", get(view_records))\n        .route(\"/create\", post(create_record))\n        .route(\n// you can add multiple request methods to a route like this\n            \"/:id\",       get(view_one_record).put(edit_record).delete(destroy_record),\n        )\n        .route_layer(middleware::from_fn_with_state(\n            state.clone(),\n            validate_session,\n        ));\n\n// the routes in this router should be public, so no middleware is required\n    let auth_router = Router::new()\n        .route(\"/register\", post(register))\n        .route(\"/login\", post(login))\n        .route(\"/forgot\", post(forgot_password))\n        .route(\"/logout\", get(logout));\n\n// return router that uses all routes from both individual routers, but add the CORS layer as well as AppState which is defined in our entrypoint function\n    Router::new()\n        .route(\"/health\", get(health_check))\n        .nest(\"/notes\", notes_router)\n        .nest(\"/auth\", auth_router)\n        .with_state(state)\n        .layer(cors)\n}</code></b></b></b></p><p></p><p><b><b><b>我们可以简单定义两个路由程序来创建一个 API 路由程序，每个路由程序对应自己的路由路径（路由程序受到保护，只有会话通过验证时才会运行相应路由），之后直接返回一个带有健康检查的路由，嵌套我们之前的两个路由，最后为路由程序添加 CORS 和应用状态。</b></b></b></p><p></p><p><b><b><b>我们的最终路由函数大致如下：</b></b></b></p><p></p><p><b><b><b><code lang=\"javascript\">// backend/src/router.rs\npub fn create_router(static_folder: PathBuf, state: AppState) -&gt; Router {\n    let api_router = api_router(state);\n\n// merge our static file assets\n    Router::new()\n        .nest(\"/api\", api_router)\n        .merge(SpaRouter::new(\"/\", static_folder).index_file(\"index.html\"))\n}</code></b></b></b></p><p></p><p><b><b><b>我们接下来要在主函数（main.rs 当中）的初始入口点函数中使用此函数来生成路由程序，如下所示：</b></b></b></p><p></p><p><b><b><b><code lang=\"properties\">#[derive(Clone)]\npub struct AppState {\n    postgres: PgPool,\n    key: Key,\n    smtp_email: String,\n    smtp_password: String,\n    domain: String,\n}\n\nimpl FromRef for Key {\n    fn from_ref(state: &amp;AppState) -&gt; Self {\n        state.key.clone()\n    }\n}\n\n#[shuttle_runtime::main]\nasync fn axum(\n    #[shuttle_static_folder::StaticFolder] static_folder: PathBuf,\n    #[shuttle_shared_db::Postgres] postgres: PgPool,\n    #[shuttle_secrets::Secrets] secrets: SecretStore,\n) -&gt; shuttle_axum::ShuttleAxum {\n    sqlx::migrate!()\n        .run(&amp;postgres)\n        .await\n        .expect(\"Something went wrong with migrating :(\");\n\n    let smtp_email = secrets\n        .get(\"SMTP_EMAIL\")\n        .expect(\"You need to set your SMTP_EMAIL secret!\");\n\n    let smtp_password = secrets\n        .get(\"SMTP_PASSWORD\")\n        .expect(\"You need to set your SMTP_PASSWORD secret!\");\n\n// we need to set this so we can put it in our CorsLayer\n    let domain = secrets\n        .get(\"DOMAIN\")\n        .expect(\"You need to set your DOMAIN secret!\");\n\n    let state = AppState {\n        postgres,\n        key: Key::generate(),\n        smtp_email,\n        smtp_password,\n        domain,\n    };\n\n    let router = create_router(static_folder, state);\n\n    Ok(router.into())   \n}</code></b></b></b></p><p></p><p><b><b><b>请注意，对于从文件导入的函数，如果其位于前面提到的同一文件目录当中（use router），则需要在 lib.rs 文件中对其做定义；如果大家需要将函数从一个文件导入至另一个非主入口点文件中，也得进行同样的操作。</b></b></b></p><p></p><p><b><b><b>现在编程部分全部结束，大家可以试试实际部署效果了！</b></b></b></p><p></p><p></p><h2><b><b><b>部署</b></b></b></h2><p></p><p></p><p><b><b><b>感谢 shuttle，整个部署流程非常简单，只需在项目的根目录中运行 npm run deploy 即可。如果没有错误，shuttle 会启动我们的应用并返回部署信息列表和由 shuttle 配置的数据库连接字符串。如果需要再次查找此数据库字符串，可以在项目的 backend 目录下运行 cargo shuttle status 命令。</b></b></b></p><p></p><p><b><b><b>在实际部署之前，大家可能还需要提前运行 cargo fmt 和 cargo clippy，因为 Web 服务的构建过程中可能出现警告或错误。如果没有这些组件，大家也可以分别用 rustup component add rustfmt 和 rustup component add clippy 来替代——这里向各位 Rust 开发者强烈推荐这两款工具，绝对是您工具箱中的必备选项。</b></b></b></p><p></p><p></p><h2><b><b><b>总结</b></b></b></h2><p></p><p></p><p><b><b><b>感谢大家阅读本文！希望这篇文章能带您深入了解如何轻松构建 Rust Web 服务。过去几年间，Rust 实现了显著发展，也降低了新手学习的准入门槛。如果大家还停留在 Rust“生人勿近”的旧观念中，那实在是大可不必，现在正是上手体验的好时机。相信 Rust 强大的功能和愈发完善的用户友好度会给您留下深刻印象。</b></b></b></p><p></p><p></p><h5><b><b><b>原文链接：</b></b></b></h5><p></p><p></p><p><b><b><b><a href=\"https://joshmo.hashnode.dev/nextjs-and-rust-an-innovative-approach-to-full-stack-development\">https://joshmo.hashnode.dev/nextjs-and-rust-an-innovative-approach-to-full-stack-development</a>\"</b></b></b></p><p></p><p><b><b><b>相关阅读：</b></b></b></p><p></p><p><b><b><b><a href=\"\">为什么说&nbsp;Next.js&nbsp;13 是一个颠覆性版本</a>\"</b></b></b></p><p><b><b><b><a href=\"\">Next.js&nbsp;实践：从 SSR 到 CSR 的优雅降级</a>\"</b></b></b></p><p><b><b><b><a href=\"\">我们如何使用&nbsp;Next.js&nbsp;将 React 加载时间缩短 70%</a>\"</b></b></b></p><p><b><b><b><a href=\"\">先别急着“用&nbsp;Rust&nbsp;重写”，可能没有说的那么安全</a>\"</b></b></b></p>",
    "publish_time": "2023-08-27 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]