[
  {
    "title": "JEP423：G1引入区域固定机制，降低GC延迟",
    "url": "https://www.infoq.cn/article/zqBCAomCykqjGONLASep",
    "summary": "<p>在评审结束后，JEP 423（<a href=\"https://openjdk.org/jeps/423?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDQxNzI5MzIsImZpbGVHVUlEIjoiTkprYm5lYlc1NUNyN0VrUiIsImlhdCI6MTcwNDE3MjYzMiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.d9jrujWHBR0TfcexDFsAnL5No9yFJHeJTW8k530DFSM\">Region Pinning for G1</a>\"）已经被集成到 JDK 22 中。这个JEP旨在通过为<a href=\"https://docs.oracle.com/en/java/javase/17/gctuning/garbage-first-g1-garbage-collector1.html#GUID-ED3AB6D3-FD9B-4447-9EDF-983ED2F7A573?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDQxNzI5MzIsImZpbGVHVUlEIjoiTkprYm5lYlc1NUNyN0VrUiIsImlhdCI6MTcwNDE3MjYzMiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.d9jrujWHBR0TfcexDFsAnL5No9yFJHeJTW8k530DFSM\">G1垃圾回收器</a>\"实现区域固定来降低GC延迟。这使得在Major GC和Minor GC期间可以固定任意区域，并且可以避免在实现JNI关键区域时禁用垃圾回收。</p><p></p><p>JEP 423 解决了Java与C和C++等非托管语言之间的互操作性问题。<a href=\"https://docs.oracle.com/en/java/javase/21/docs/specs/jni/index.html?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDQxNzI5MzIsImZpbGVHVUlEIjoiTkprYm5lYlc1NUNyN0VrUiIsImlhdCI6MTcwNDE3MjYzMiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.d9jrujWHBR0TfcexDFsAnL5No9yFJHeJTW8k530DFSM\">JNI</a>\"，作为互操作性的关键组件，允许Java应用程序调用其他语言编写的原生应用程序和库，或反过来。它提供了<a href=\"https://docs.oracle.com/en/java/javase/21/docs/specs/jni/functions.html#getprimitivearraycritical-releaseprimitivearraycritical?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDQxNzI5MzIsImZpbGVHVUlEIjoiTkprYm5lYlc1NUNyN0VrUiIsImlhdCI6MTcwNDE3MjYzMiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.d9jrujWHBR0TfcexDFsAnL5No9yFJHeJTW8k530DFSM\">获取和释放Java对象指针的函数</a>\"，这些函数必须成对使用。在获取和释放指针之间执行的代码被视为关键区域，在此期间，JVM必须确保GC不移动关联的Java对象。默认的GC，即G1，在这些关键区域中会<a href=\"https://tschatzl.github.io/2021/06/28/evacuation-failure.html?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDQxNzI5MzIsImZpbGVHVUlEIjoiTkprYm5lYlc1NUNyN0VrUiIsImlhdCI6MTcwNDE3MjYzMiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.d9jrujWHBR0TfcexDFsAnL5No9yFJHeJTW8k530DFSM\">完全禁用垃圾回收</a>\"，导致严重的延迟。这种方法通常会导致线程停滞、不必要的内存耗尽，甚至在极端情况下会导致VM过早关闭。</p><p></p><p>G1引入区域固定从根本上改变了这种方式。JEP 423允许G1在GC期间固定包含关键对象的特定内存区域，而不是<a href=\"https://tschatzl.github.io/2021/06/28/evacuation-failure.html?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDQxNzI5MzIsImZpbGVHVUlEIjoiTkprYm5lYlc1NUNyN0VrUiIsImlhdCI6MTcwNDE3MjYzMiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.d9jrujWHBR0TfcexDFsAnL5No9yFJHeJTW8k530DFSM\">禁用GC</a>\"。这是通过在每个区域中维护关键对象的计数来实现的，在获取关键对象时增加计数，在释放时减少。当计数非零时，该区域被视为被固定，不会在GC期间被清理。这确保了关键对象不会被移动，避免了禁用GC，并显著降低了延迟。</p><p></p><p>这个新特性是Java垃圾回收机制的一项重大进步。它旨在解决延迟问题，并在没有活动的JNI关键区域存在时保证GC停顿时间不出现回归。即使存在这样的区域，回归也是最小的。在Major GC和Minor GC期间实现区域固定证明了这种解决方案的健壮性。</p><p></p><p>不过，JEP 423也存在潜在的风险和假设。一个重大风险是，如果应用程序同时固定多个区域，可能会导致堆内存耗尽。虽然目前没有直接解决方案，但从已经实现了类似机制的<a href=\"https://wiki.openjdk.org/display/shenandoah/Main?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDQxNzI5MzIsImZpbGVHVUlEIjoiTkprYm5lYlc1NUNyN0VrUiIsImlhdCI6MTcwNDE3MjYzMiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.d9jrujWHBR0TfcexDFsAnL5No9yFJHeJTW8k530DFSM\">Shenandoah</a>\" GC来看，这种风险是可控的。</p><p></p><p>总的来说，JEP 423为OpenJDK的G1垃圾回收器引入了重大的技术增强。区域固定特性解决了与Java本地接口（JNI）关键区域相关的延迟问题，改进了JVM在与非托管语言发生互操作时的垃圾回收处理。这表明了OpenJDK在努力完善和优化Java性能和互操作性能力方面所做的持续不断的努力。</p><p></p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/12/region-pinning-to-g1-gc/\">https://www.infoq.com/news/2023/12/region-pinning-to-g1-gc/</a>\"</p>",
    "publish_time": "2024-01-05 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "发布Vue3让尤雨溪吃尽苦头：犯了3个错，每一个都需开发者警惕",
    "url": "https://www.infoq.cn/article/GWJYTKfF6iubD9hrTOKH",
    "summary": "<p></p><p></p><blockquote>Vue 3 的发布让其创始人尤雨溪吃了不少苦头，这样也让他知道，未来再处理框架升级时需要在策略上做出重大改变。</blockquote><p></p><p>&nbsp;</p><p>在2023年 VueConf 多伦多大会上，<a href=\"https://github.com/vuejs\">Vue.js</a>\" 的创始人<a href=\"https://github.com/yyx990803\">尤雨溪</a>\"向与会者透露，在 Vue（一款用于构建用户界面的渐进式 JavaScript 框架） 从版本 2 升级到版本 3 的过程中，他吸取了一些教训。</p><p></p><p></p><h2>错误一：一次发布太多微小但破坏性的变更</h2><p></p><p>&nbsp;</p><p>尤雨溪在 <a href=\"https://www.youtube.com/watch?v=Hz_zCR28oKE\">11 月发布的一段视频</a>\"中说道：“我们犯的第一个错误，是一次发布太多微小但破坏性的变更。问题的关键在于，单独的每个小变更都很容易处理，但是当这些变更合在一起时，所带来的复杂性会呈指数级增长。”</p><p>&nbsp;</p><p>通过这个教训，他意识到在进行变更时，优先保持原有功能的可用性是明智之举。他进一步补充到，这一做法也将给框架维护者的工作流程带来变革，未来他们将采用逐步弃用的周期性原则进行框架升级。</p><p>&nbsp;</p><p>“对于我们想要变更、破坏或移除的每一项内容，都应该始终首先保持其一切运行正常，然后再考虑弃用，同时应该引入一个新特性的可选阶段，此阶段在不破坏任何现有功能的前提下，允许用户自主选择是否采用新特性。最终，在未来版本中将那些需要废弃的特性移除。”</p><p>&nbsp;</p><p>他解释说，Vue 的维护者将会在不同版本之间采取分阶段的变更策略，以避免再次出现“一大堆破坏性的变更同时发布”的情况。他将这个计划与 Angular 和 Ember 的升级方法进行了比较，这两个框架在主要版本之间都分散了小的破坏性变更，并且时间跨度相对较长。</p><p>&nbsp;</p><p>“Vue 已经发展到了一个阶段，我相信长远发展所需的良好升级策略将变得至关重要。我们可以保证，在短期内，绝对不会考虑进行任何破坏性变更。对于长期来说，我希望 Vue 3 能成为稳定的基础版本，并且未来我们将会非常认真地对待这种变更。”</p><p>&nbsp;</p><p></p><p></p><h2>错误二：低估了升级对生态库的影响</h2><p></p><p>&nbsp;</p><p>尤雨溪说道，他学到的第二个教训是，在进行变更时要及时与生态库的作者联系，以确保在发布到注册中心之前解决与生态库适配的问题。</p><p>&nbsp;</p><p>“导致第二个错误的原因，是我低估了升级对生态库的影响。我忽略了生态库的作者适配 Vue 3 所需要花费的工作量。”</p><p>&nbsp;</p><p>由于他们对许多内部 API 和行为做了变更，对于依赖这些内部行为的大型库而言，升级到 Vue 3 变得“非常困难”。这导致了诸如Nuxt、Beautify等主要生态库的升级拖延时间很长。</p><p>&nbsp;</p><p>“事实上，这些也是有互相依赖关系的应用因为升级难度而停滞在旧版本的首要原因之一。所以这里学到的教训是，生态系统依赖的重要性不容忽视。”</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/9a/9a63109d6214dff0c41c16979f69d7f2.png\" /></p><p></p><p>&nbsp;</p><p>为了应对这种情况，Vue 采用了一个对生态系统进行<a href=\"https://thenewstack.io/poorly-configured-ci-cd-systems-can-be-a-backdoor-into-your-infrastructure/\">自动化持续集成的系统</a>\"，该系统可以自动测试 Vue 的所有核心变更与其上下游所依赖库的兼容情况。</p><p>&nbsp;</p><p>“目前我们已经成功集成了超过 15 个项目到系统中，而且未来还将继续增加。在发布之前，可以针对每个提交运行所有这些下游库，这样就可以在发布之前检测出潜在问题。通过这个系统，我们还能够与这些生态库的作者密切合作，共同解决可能出现的问题，以确保在发布时一切都能够顺利进行。”</p><p>&nbsp;</p><p>“Vue 不鼓励，甚至禁止生态库的作者们使用其内部 API，因为这是导致这类库升级困难的主要因素之一。”</p><p>&nbsp;</p><p>“由于大多数项目都支持 <a href=\"https://thenewstack.io/how-to-get-advantages-of-typescript-in-javascript/\">TypeScript</a>\"，现在我们可以在类型级别和运行时级别强制执行这一点。虽然我们仍需要向外部公开一些内部 API，以供官方工具或库使用。但对于无法直接控制的生态库，我们将从类型定义中移除这些私有 API，以防止这些库使用它们。”</p><p></p><p>&nbsp;</p><p></p><h2>错误三：分多个阶段发布</h2><p></p><p>&nbsp;</p><p>将发布分阶段是一个错误。<a href=\"https://github.com/vuejs/core\">Vue 3 的核心模块</a>\"是在2020年9月发布的，然而，当时许多生态系统相关的部分仍在开发中。在发布 Vue 核心模块的稳定版时，官网文档的一个主要问题是，没有将组合 API 作为最高优先概念进行宣传。此外，在官方库、迁移指南、开发工具支持等方面也都存在一些遗漏。</p><p>&nbsp;</p><p>“当时我们这样做的原因是，我们觉得应该先发布一些关键的东西，这样生态系统就有动力去尝试。但结果是，发布一个没有完整生态系统的版本会给早期的使用者带来了困惑。”</p><p>&nbsp;</p><p>尤雨溪承认，在大版本发布中，最重要的应该是优先确保一切准备就绪，而不是匆忙发布。</p><p>&nbsp;</p><p>“更重要的是，在大版本发布之前，应该先找到收集反馈的方法，并与库的维护者合作推进升级工作。这是与利益相关者和生态系统合作更主动积极地行为，这也是未来进行重大变更时要去改进的地方。”</p><p>&nbsp;</p><p></p><p></p><h2>Vue 3 做对了什么？</h2><p></p><p>&nbsp;</p><p>Vue 在这个版本中也做对了一些事情，首当其冲的就是采用了 TypeScript。</p><p>&nbsp;</p><p>“现在，对于前端解决方案来说类型检查是基本要求。任何一个主要的TypeScript 或前端领域的解决方案，你只要观察一下就会发现 ，现在人们第一关注的就是其对 TypeScript 集成和支持情况。”</p><p>&nbsp;</p><p>TypeScript 已经被证明在长期项目和大团队环境中极大增强了代码的可维护性。将代码库迁移到 TypeScript 也显著提高了 Vue 本身的可维护性，为未来的迭代奠定了坚实的基础。</p><p>&nbsp;</p><p>另一个 Vue 做对的事情是采用了组合式 API。虽然一开始人们对改特性产生疑问，但对 Vue 来说效果很好。</p><p>&nbsp;</p><p>“我们还记得早期引入<a href=\"https://vuejs.org/guide/extras/composition-api-faq.html\">组合式 API</a>\" 的时候。尽管它是受到了 <a href=\"https://thenewstack.io/the-pros-and-cons-of-using-react-today/\">React hooks</a>\" 的启发，但它深深植于 Vue 自己的响应系统。虽然，在初期阶段引起不少争议。人们并不真正理解我们为什么要这样做。”</p><p>&nbsp;</p><p>事实上，仍然有人更偏爱 Options API，但相对于组合式 API，它存在一些限制。这部分是因为 Vue 的用户群发生了变化。在早期，大多数用户关注的是小到中型的场景，主要解决的问题是如何与现有后端系统轻松集成。但随着时间的推移，Vue 的维护者们看到用户构建了更复杂且要求更高的场景，包括更大规模的单页面应用程序。</p><p>&nbsp;</p><p>“首先，为了适应不断变化的用户群体，其次也为了满足行业不断变化的需求，我必须提供一些解决方案，来解决由这些新需求带来的问题，这就是可扩展性。因此，组合式 API 的创造就是试图在尽可能多地保留 Vue 原始的用户友好性的前提下，提供一种支持这种可扩展性的方法。”</p><p>&nbsp;</p><p>那些采用组合式 API 的人会发现其真正的好处所在，他补充说。</p><p>&nbsp;</p><p>”这样使社区的价值更大化，比如<a href=\"https://vueuse.org/\">VueUse</a>\"，它为我们提供了一系列非常有用的实用工具，那些不适合在 Vue 核心模块中解决的问题，被社区很好地解决。事实上，我认为 VueUse 可能也是直接因组合式 API 最大受益者之一。”</p><p>&nbsp;</p><p>Vue 还在投资开发者体验方面做出了正确的选择。实际上这也是当下流行的 Web 构建工具 Vite 诞生的原因，它起源于一个仅服务于 Vue 的开发服原型。现在，许多框架都在使用 Vite，包括 Nuxt。</p><p>&nbsp;</p><p>通过对 IDE 的投资，Vue 见证了整个生态系统的受益，造福了 Web 开发者。这项投资孕育出了 Volar，这是一个包含 Vue 语言服务和 Vue TSC 的子项目的总项目，而Vue TSC 是一个命令行界面，它封装了 TypeScript 并为 Vue 组件提供了命令行检查。</p><p>&nbsp;</p><p>“和 Vite 类似，这整套工具最初也只服务于 Vue，但随后发展成了一个包括一系列工具的生态系统，旨在帮助框架构建更强大的 IDE 和支持 TypeScript。Volar 现在也正在发展成为一个独立于框架之外的核心模块，将来不仅支持 Vue，还要支持 <a href=\"https://thenewstack.io/how-to-use-astro-with-a-sprinkling-of-react/\">Astro</a>\"、<a href=\"https://mdxjs.com/\">MDX</a>\" 以及其他可能采用它的框架。”</p><p>&nbsp;</p><p>尤雨溪声称这是 Vue 生态系统独有的特性。“我们看到很多好的想法都是先从 Vue 生态系统开始，然后产生了比 Vue 生态系统更大的影响。”</p><p>&nbsp;</p><p>最后，尤雨溪表示，Vue 3 实现了所设定的目标，包括更好的性能、更好的类型支持、更好的可扩展性和更好的开发体验。随着对 Vue 2 的支持在本月结束，Vue 3 的下载量已经接近50%，Vue 3 的采用率在过去一年几乎翻了一番。</p><p>&nbsp;</p><p>参考链接：</p><p><a href=\"https://thenewstack.io/what-vues-creator-learned-the-hard-way-with-vue-3/\">https://thenewstack.io/what-vues-creator-learned-the-hard-way-with-vue-3/</a>\"</p><p></p><p><a href=\"https://www.youtube.com/watch?v=Hz_zCR28oKE\">https://www.youtube.com/watch?v=Hz_zCR28oKE</a>\"</p><p>&nbsp;</p><p></p><h5>相关阅读：</h5><p></p><p></p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247504585&amp;idx=2&amp;sn=23b3382c245b4f3d02bdb000c6cbdf20&amp;chksm=f952678ace25ee9c1ec8fd3e32c9cc0c503efad0fe074fb73630ffa396a113e3ba449531b755&amp;scene=27#wechat_redirect\">Vue.js&nbsp;最佳静态站点生成器对比</a>\"</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzA3MzE4ODY0Mg==&amp;mid=2455993739&amp;idx=1&amp;sn=9326ae8a0b80cae03a5c7c2c10b5c7e5&amp;chksm=888509c6bff280d084803aadeeffbaad1382c7e30a765f94d70f32b30293974274e4d2bd0d2b&amp;scene=27#wechat_redirect\">强烈推荐：一个&nbsp;Vue.js&nbsp;在线挑战平台</a>\"</p><p><a href=\"https://www.infoq.cn/article/2xrYYumuivXCH9fozjju\">Vue.js&nbsp;前后端同构方案之准备篇—代码优化</a>\"</p><p><a href=\"https://www.infoq.cn/article/22jiqjCXXcs0DajEFT0h\">从 React 切换到&nbsp;Vue.js</a>\"</p>",
    "publish_time": "2024-01-05 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]