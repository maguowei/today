[
  {
    "title": "代码覆盖率是一个无用的管理指标",
    "url": "https://www.infoq.cn/article/1KurZhZ4KXYE2BpqMl7v",
    "summary": "<p>多年来，技术领导者们普遍认为代码覆盖率是衡量软件产品质量的一个强有力的指标。这种观点表面上看起来合理：测试越彻底，代码覆盖率就越高，软件就应该更加健壮、更不容易出错。这个想法已经深深地植根于我们的脑海中。但是，如果我有证据证明代码覆盖率本质上是错误的呢？如果我能通过向你展示一个简单的想法让你不再怀疑我的观点呢？</p><p></p><h1>代码覆盖率</h1><p></p><p>&nbsp;</p><p>简单地说，代码覆盖率是衡量测试“触及”或“覆盖”了多少代码的一种指标。假设我们的软件产品包含了测试用例，并至少在每次发布之前都执行这些测试。在执行这些测试时，它们会对产品执行操作，从而让代码跑起来。很快，我们就意识到，如果跟踪哪些代码被测试用例执行了就可以度量执行了多少代码。我们把被执行的代码与产品中总代码量的比例叫作“代码覆盖率”。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/99/9996267a40db59027869507ae7e06591.png\" /></p><p></p><p>&nbsp;这是一个非常简单的度量指标。如果我们有100行代码，但测试只执行了其中的75行，那么我们的代码覆盖率就是75%。</p><p>&nbsp;</p><p>很快，我们就意识到了更重要的事情：如果代码覆盖率不是100%，那就还有没有被测试执行的代码，就是未经测试的代码！</p><p>&nbsp;</p><p>拥有未经测试的代码是危险的，因为它们可能存在缺陷。此外，它们还可能包含关键的业务功能，如果我们修改了这些代码，可能会丢掉这些功能。所以，拥有高代码覆盖率是必须的。</p><p></p><h1>代码覆盖率谬论</h1><p></p><p>&nbsp;</p><p>但现在我们的面前摆着一个谬论：我们知道，拥有未覆盖的代码意味着我们的测试可能遗漏了重要的场景，但反过来并不成立。</p><p>&nbsp;</p><p>例如，在前面的例子中，我们的代码覆盖率是75%。换句话说，这表明25%的代码行根本没有被任何测试执行过，这显然向我们指出了一个风险点。我们可以肯定地说，这25%的代码没有经过任何测试验证，因此可能成为缺陷和维护问题的温床。</p><p>&nbsp;</p><p>然而，这也是我们可能会陷入谬论陷阱的地方：虽然我们可以自信地说未经测试的代码隐藏着潜在的错误和对未来开发的阻碍，但我们可以相信反过来也是对的。我们可能会认为覆盖了代码意味着它有更少的错误和更少的维护问题。但是，那只是一种直觉，甚至看起来似乎合理，而事实却并非如此。</p><p>&nbsp;</p><p>事实是，我们可以拥有100%的代码覆盖率，但仍然有满是错误和难以维护的代码。</p><p></p><h1>一个简单的例子</h1><p></p><p>&nbsp;</p><p>假设我们有一个简单的计算两数之和的函数：</p><p><code lang=\"null\">function addition(a, b) {\n  return a + b;\n}</code></p><p>&nbsp;</p><p>能覆盖100%代码的最简单的测试是怎样的？只需要进行一次加法运算就能覆盖到所有代码：</p><p><code lang=\"null\">test('the addition function', () =&gt; {\n  addition(3, 4);\n});</code></p><p>&nbsp;</p><p>这个测试覆盖了100%的代码。然而，它是无用的。为什么？如果我们把加法实现改成这样：</p><p><code lang=\"null\">function addition(a, b) {\n  return a - b;\n}</code></p><p>&nbsp;</p><p>测试仍然可以通过！</p><p>&nbsp;</p><p>如果你是一名程序员，你可能已经知道问题出在哪里。问题不在于代码覆盖率，而在于测试本身。测试确实覆盖了100%的代码，但它并没有断言或检查任何东西。这就是为什么错误地实现逻辑（用减法代替加法）仍然能够通过测试。所以，这似乎是一个糟糕的例子……不是的。</p><p>&nbsp;</p><p>事实证明，对于这个非常简单的小例子，我们可以很容易地看到测试中的问题。但如果代码库里有成千上万行代码呢？有人能轻松地找出一个没有正确验证其结果的测试吗？这是极不可能的。</p><p>&nbsp;</p><p>所以，测试可能是错误的，断言也可能是错误的，场景可能被忽略，但我们仍然可以吹嘘拥有100%的代码覆盖率。问题正好出在这里。</p><p></p><h1>问题的根源</h1><p></p><p>&nbsp;</p><p>这个问题的根源在于，代码覆盖率是关于代码的度量指标，而不是关于业务的。</p><p>&nbsp;</p><p>尽管代码覆盖率可能是揭示未被测试的代码的一个很好的指标，但它并不能告诉我们与业务相关的东西以及项目是如何满足业务目标的。</p><p>&nbsp;</p><p>代码覆盖率关注软件测试的技术层面，但不一定会考虑在构建软件时需要满足的更广泛的业务目标和需求。它衡量了被测试代码的范围，但并不能提供关于软件是否真正达到其预期目的、满足用户需求或与更广泛的业务战略保持一致的见解。</p><p>&nbsp;</p><p>代码覆盖率唯一做到的就是评估你是否在测试期间执行了所有代码，而这很容易就可以达到。</p><p>&nbsp;</p><p>规则1：执行所有方法。为每一个函数编写一个测试用例。这将会覆盖到所有方法。所以，如果你有两个函数，就写两个测试用例。</p><p><code lang=\"null\">function one() {\n  // ...\n}\ntest('function one', () =&gt; {\n  one();\n});\n\n\nfunction two() {\n  // ...\n}\ntest('function two', () =&gt; {\n  two();\n});</code></p><p>&nbsp;</p><p>规则2：执行所有分支。为每一个条件语句创建一个额外的测试用例，确保它满足条件。这将覆盖所有分支内的所有代码。</p><p><code lang=\"null\">function conditional(condition) {\n  if (condition) {\n    // ...\n  } else {\n    // ...\n  }\n}\n\n\ntest('condition true', () =&gt; {\n  conditional(true);\n});\ntest('condition false', () =&gt; {\n  conditional(false);\n});</code></p><p>&nbsp;</p><p>到需要注意的是，要达到100%的代码覆盖率并不总是需要编写额外的测试：</p><p><code lang=\"null\">function conditional(condition) {\n  if (condition) {\n    // ...\n  } \n  // ...\n}\n\n\ntest('conditional', () =&gt; {\n  conditional(true);\n});</code></p><p>&nbsp;</p><p>不需要更多的规则了。我已经展示了“if”语句，但“while”和“switch”也是如此。对其他函数的调用已经被规则1覆盖了，所以，就些就够了。</p><p>&nbsp;</p><p>那么这些规则与业务有什么关系呢？没有。而这就是问题所在。</p><p>&nbsp;</p><p></p><h1>真实的经历</h1><p></p><p>&nbsp;</p><p>我想讨论两种不同的情况，代码覆盖率在其中扮演了欺骗性的角色。</p><p>&nbsp;</p><p>几年前，在一个聚会上，我遇到了一位在软件开发公司工作的开发人员，他向我讲述了他为FDA（美国卫生与公众服务部下属的联邦机构食品和药物管理局）开发软件产品的经历。</p><p>&nbsp;</p><p>情况是这样的：FDA要求60%的代码覆盖率，而他们的产品没有测试用例，所以代码覆盖率是0%。</p><p>&nbsp;</p><p>当FDA要求60%的代码覆盖率时，意味着他们希望看到至少60%的代码在测试期间被执行。这是一种保证软件在不同条件下可以正常运行的方式，或者至少他们希望如此。</p><p>&nbsp;</p><p>那么真实发生了什么？</p><p>&nbsp;</p><p>因为他们没有测试用例，所以开始着手创建测试用例。最初，他们试图创建有意义的测试，彻底检查最关键的功能，并在各种条件下验证正确行为。但随着时间的推移，继续创建测试变得越来越困难，而代码覆盖率几乎没有增加。很快，他们意识到自己在与时间赛跑。</p><p>&nbsp;</p><p>绝望的时刻需要绝望的措施。他们将注意力从创建有价值的测试转移到简单地增加代码覆盖率百分比上。他们执行测试，查看代码覆盖率报告，然后调整测试，最大程度地执行更多的代码，以此来快速提升代码覆盖率。他们不再考虑测试是否有价值，因为他们将数量置于质量之上。</p><p>&nbsp;</p><p>这花了他们3个月，他说这是他整个开发职业生涯中最糟糕的经历。</p><p>&nbsp;</p><p>你可能在想，这是一种极端的情况，至少，他们的行为是值得怀疑的，而且，这肯定这不是软件行业的常见做法。别着急，再仔细想想。</p><p>&nbsp;</p><p>事实证明，每一个开发人员在每一次交付时都会踩到同样的定时炸弹。</p><p>&nbsp;</p><p>所以，如果一个开发人员被迫交付带有测试用例的代码，并要求具备一定的最低代码覆盖率，并且需要在某个截止日期内完成（即使是他们自己估计的），那么前面经历的教训也同样适用。</p><p>&nbsp;</p><p>我的第二次经历就是这样的。不久前，我的一个客户要求我协助他的一个团队进行测试。关于测试有很多需要讨论的地方，感觉测试既费钱又费时间。这家公司要求至少80%的代码覆盖率，这让我想起了之前的经历。</p><p>&nbsp;</p><p>所以，我做了唯一一件合理的事情：我下载了代码，查看了测试。一个小时后，我意识到我无法理解其中的任何一个测试用例。</p><p>&nbsp;</p><p>我运行了测试，它们通过了，然后我开始尝试做一些试验。因为我不明白这些测试用例是如何工作的，所以我拿到了代码并故意破坏它们，结果让我吃惊：尽管代码被破坏了，测试仍然可以通过。</p><p>&nbsp;</p><p>代码覆盖率之所以达到要求，并不是因为测试得彻底，而是因为它们只是偶然地执行到了代码。</p><p>&nbsp;</p><p>这两次经历都在告诉我同一个道理，强制要求代码覆盖率可能不是一个好的管理实践。</p><p>&nbsp;</p><p></p><h1>实验</h1><p></p><p>&nbsp;</p><p>正如之前所承诺的，我将展示一个实验，一个简单而有效的实验，它将毫无疑问地证明作为管理指标的代码覆盖率是无用的。</p><p>&nbsp;</p><p>它基于Allen Holub的观察：</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/43/43dd1262480b911885cbbe2ad0e67723.png\" /></p><p></p><p></p><blockquote>推文内容：我想过写一个自动代码覆盖率生成器，它只创建测试，这些测试通过随机参数调用程序中的每一个函数/方法，并且总是能通过。达到80%的覆盖率小菜一碟。可见代码覆盖率并不是一个有用的指标。</blockquote><p></p><p>&nbsp;</p><p>这个想法很简单，对吧？正如我前面提到的，要达到100%的代码覆盖率，我们只需要满足两个规则：一个是执行所有函数，一个是执行所有分支。事实证明Allen Holub也是这么想的：一个是让测试执行所有函数/方法，一个是通过使用随机参数来覆盖分支。</p><p>&nbsp;</p><p>如果我们真是这么做的，那么这些测试与我们的业务目标会有什么关系呢？一点都没有！它只会毫不留情地运行所有代码，而不考虑我们的业务。</p><p>&nbsp;</p><p>所以，问题是：Allen Holub说的是对的吗？</p><p>&nbsp;</p><p>自动化生成代码覆盖率可能有点困难，但如果我们限定在随机输入的前提下，而不需要分析代码分支，那么它的复杂性就会大大降低。那么，让我们开始实验吧！</p><p>&nbsp;</p><p>在我的第一次尝试中，我选择了Java。因为Java具有反射能力，所以它是一种非常容易用于自动化测试的语言，并且我已经有一些公共代码库可以用来检查生成器。所以，我在这里做了第一次概念验证：</p><p>&nbsp;</p><p><a href=\"https://github.com/drpicox/classroom--cards-game--2022/blob/feature/autotest/src/test/java/com/drpicox/stage1/TestStage1.java\">https://github.com/drpicox/classroom--cards-game--2022/blob/feature/autotest/src/test/java/com/drpicox/stage1/TestStage1.java</a>\"</p><p>&nbsp;</p><p>这段简单的代码只创建了具有公共构造函数和无参数的类的所有实例，并执行了所有没有参数的方法。</p><p>&nbsp;</p><p>尽管它很简单，但已经达到了11%的代码覆盖率。这远低于80%，但这是预料之中的。</p><p>&nbsp;</p><p>到了这里，我意识到我需要执行带有参数的构造函数和方法，而且可以通过“作弊”直接执行私有方法，采用与Spring或JPA所采用的相同的机制。这打开了一个新的兔子洞。所以，有了指明了正确方向的第一次概念验证，以及可以将这个实验作为学位项目的可能性，我决定将这个实验列入学位项目的通过资格中。</p><p>&nbsp;</p><p>在这里，我必须感谢Gerard Torrent。他接受了挑战，尽管他们的学位内容几乎与编译器理论无关，但他还是创造了一种不一样的更容易被人们理解的方法。</p><p>&nbsp;</p><p>他不是通过一个单一的测试来遍历所有代码，而是构建了一个代码生成器，为每一个方法和可能的参数创建一个测试。他还添加了其他功能，例如，如果一个方法需要其他对象，就创建它们，经过一轮又一轮的迭代，整体代码覆盖率得到了提升。有时侯他独自工作，有时候与我联手进一步提高覆盖率。我们做到了。</p><p></p><h1>结果</h1><p></p><p>&nbsp;</p><p>是的，我们做到了。我们达到了80%的代码覆盖率，甚至更高。</p><p>&nbsp;</p><p>我让Gerard进行逐步迭代，并获取结果，以便能够更深入地了解代码覆盖率是如何实现的。</p><p>&nbsp;</p><p>代码覆盖率是这样逐步实现的：</p><p>&nbsp;</p><p>我的第一个参考实现：11%执行所有以null作为参数的构造函数：20%只执行public void方法：23%执行所有的public方法：50%执行所有public和private方法：50%创建所需参数的实例（不再有null）：65%为所需的实例创建实例（嵌套）：69%每个参数测试三个不同的值：69%在可能的情况下使用Spring实例化类：85%</p><p>&nbsp;</p><p></p><blockquote>需要注意的是，测试私有方法是一种反模式，请不要这么做。它只是本演示的一部分，因为它可以帮助人为地提高代码覆盖率。</blockquote><p></p><p>&nbsp;</p><p>所以，最后的结果是：85%的代码覆盖率</p><p>&nbsp;</p><p>这是在不考虑业务逻辑的情况下生成代码，然后呢？</p><p>&nbsp;</p><p></p><h1>结论</h1><p></p><p>&nbsp;</p><p>Allen Holub之所以提出80%的覆盖率，并不是因为他认为这是一个合理的目标，而是因为80%是大多数公司的普遍要求。事实上，他正在寻找一种方法来证明强制代码覆盖率最低要求是错误的。</p><p>&nbsp;</p><p>现在我们知道，我们可以构建一个简单的库，无论业务是什么，它都可以执行大部分代码，并人为地提高代码覆盖率。我们不需要AI、花哨的LLM、代码复杂度分析，只需要随机地执行函数，你就能满足任何一家公司对最低代码覆盖率的要求。</p><p>&nbsp;</p><p>即使在那些代码覆盖率可能略高一些的公司，你也可以通过抛出几个手写的手动测试用例来达到额外的覆盖率要求。</p><p>&nbsp;</p><p>那么，将代码覆盖率作为管理指标会为我们带来什么？什么也没有。</p><p>&nbsp;</p><p>以前，我们知道开发人员可以在不执行测试的情况下通过伪造来达到更高的代码覆盖率，而现在我们知道我们也可以通过自动化工具来快速提高覆盖率。</p><p>&nbsp;</p><p>所以，如果只是通过随机执行代码就能达到很高的代码覆盖率，那么这个指标就没什么用了。</p><p>&nbsp;</p><p></p><h1>下一步</h1><p></p><p>&nbsp;</p><p>下一步是什么？现在我们知道代码覆盖率对管理无用，那么我们能做些什么？</p><p>&nbsp;</p><p>首先也是最重要的是：代码覆盖率对开发人员仍然很重要。这已经被包括Martin Fowler在内的许多人讨论了很长时间。他在一篇文章中解释说，代码覆盖率的唯一目的是找到未经测试的代码。这有助于开发人员发现他在写代码时犯下的错误和错误假设。如果用对了代码覆盖率，当它处于较低的水平时，有助于引发重要的业务讨论，并揭示新的功能可能性或被人们误解的东西。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/a4/a45a8bdd6dec7e3766b6e6ce22e90cef.png\" /></p><p></p><p>代码覆盖率的作用（Martin Fowler）</p><p>&nbsp;</p><p>其次，我们有TDD或BDD，它们可能是创建测试的唯一合理的方法。开发人员可能被要求在写好代码之后创建测试，其主要问题在于没有人能够确保这些测试可以正确执行。我们需要看到它们失败，并看着新代码如何纠正它们，只有这样才能让我们确信我们正确地创建了这些测试。</p><p>&nbsp;</p><p>最后，我们应该关注业务。测试只有在能够直接帮助我们验证业务逻辑按照预期执行时才有意义。因此，与其依赖只关注代码的晦涩指标，不如选择更关注业务的其他指标，例如业务规则覆盖率：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/35/3571564e007b59a5aeee2ffe6fc6a3e0.png\" /></p><p></p><p>&nbsp;</p><p>这也是一个相当简单的指标，与代码覆盖率非常相似，也存在一些问题，但由于它更多地关注业务，所以比代码覆盖率更加有效。</p><p></p><p>原文链接：</p><p><a href=\"https://drpicox.medium.com/confirmed-code-coverage-is-a-useless-management-metric-35afa05e8549\">https://drpicox.medium.com/confirmed-code-coverage-is-a-useless-management-metric-35afa05e8549</a>\"</p>",
    "publish_time": "2023-10-06 07:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Netflix为Envoy开发新功能，实现零配置服务网格",
    "url": "https://www.infoq.cn/article/FIJogsHAUGQVwIiuPVEp",
    "summary": "<p>Netflix在<a href=\"https://netflixtechblog.com/zero-configuration-service-mesh-with-on-demand-cluster-discovery-ac6483b52a51?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTU1OTgsImZpbGVHVUlEIjoiNDdrZ012amJ2bkl5bE0zViIsImlhdCI6MTY5NjIxNTI5OCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.6zMFSmh_RObQOtqH0kWOnNHCPY_0XiZWuiEAHDWQ8dE\">这篇文章</a>\"中描述了他们为什么与Envoy社区和<a href=\"https://kinvolk.io/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTU1OTgsImZpbGVHVUlEIjoiNDdrZ012amJ2bkl5bE0zViIsImlhdCI6MTY5NjIxNTI5OCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.6zMFSmh_RObQOtqH0kWOnNHCPY_0XiZWuiEAHDWQ8dE\">Kinvolk</a>\"合作为Lyft开源的代理<a href=\"https://www.envoyproxy.io/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTU1OTgsImZpbGVHVUlEIjoiNDdrZ012amJ2bkl5bE0zViIsImlhdCI6MTY5NjIxNTI5OCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.6zMFSmh_RObQOtqH0kWOnNHCPY_0XiZWuiEAHDWQ8dE\">Envoy</a>\"实现了一项新功能。这个叫作<a href=\"https://github.com/envoyproxy/envoy/pull/18723?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTU1OTgsImZpbGVHVUlEIjoiNDdrZ012amJ2bkl5bE0zViIsImlhdCI6MTY5NjIxNTI5OCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.6zMFSmh_RObQOtqH0kWOnNHCPY_0XiZWuiEAHDWQ8dE\">按需集群发现</a>\"的新功能帮助Netflix实现了零配置服务网格。</p><p></p><p><a href=\"https://en.wikipedia.org/wiki/Inter-process_communication?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTU1OTgsImZpbGVHVUlEIjoiNDdrZ012amJ2bkl5bE0zViIsImlhdCI6MTY5NjIxNTI5OCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.6zMFSmh_RObQOtqH0kWOnNHCPY_0XiZWuiEAHDWQ8dE\">进程间通信(IPC)</a>\" 对于Netflix来说至关重要。自Netflix从2010年将所有基础设施转移到云端(AWS)，就一直需要使用针对云原生环境的工具。其中一些工具是商业版的，一些是内部开发的。为了方便管理IPC，Netflix开发了用于服务发现的<a href=\"https://netflixtechblog.com/netflix-shares-cloud-load-balancing-and-failover-tool-eureka-c10647ef95e5?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTU1OTgsImZpbGVHVUlEIjoiNDdrZ012amJ2bkl5bE0zViIsImlhdCI6MTY5NjIxNTI5OCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.6zMFSmh_RObQOtqH0kWOnNHCPY_0XiZWuiEAHDWQ8dE\">Eureka</a>\"和用于IPC的<a href=\"https://netflixtechblog.com/announcing-ribbon-tying-the-netflix-mid-tier-services-together-a89346910a62?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTU1OTgsImZpbGVHVUlEIjoiNDdrZ012amJ2bkl5bE0zViIsImlhdCI6MTY5NjIxNTI5OCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.6zMFSmh_RObQOtqH0kWOnNHCPY_0XiZWuiEAHDWQ8dE\">Ribbon</a>\"。Eureka的主要目标是用虚拟IP(VIP)抽象目标服务的名称，并且如果有必要的话还可以确保与安全虚拟IP(VIP)的安全通信。目标服务名称和通信类型(安全或不安全)是服务连接到另一个服务所需的信息。IPC客户端使用目标VIP或SVIP实例化，Eureka客户端负责VIP或SVIP和端口到IP的转换，从Eureka服务器获取信息。其缺点是从<a href=\"https://www.nginx.com/resources/glossary/load-balancing/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTU1OTgsImZpbGVHVUlEIjoiNDdrZ012amJ2bkl5bE0zViIsImlhdCI6MTY5NjIxNTI5OCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.6zMFSmh_RObQOtqH0kWOnNHCPY_0XiZWuiEAHDWQ8dE\">负载均衡器</a>\"迁移到Eureka存在<a href=\"https://en.wikipedia.org/wiki/Single_point_of_failure?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTU1OTgsImZpbGVHVUlEIjoiNDdrZ012amJ2bkl5bE0zViIsImlhdCI6MTY5NjIxNTI5OCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.6zMFSmh_RObQOtqH0kWOnNHCPY_0XiZWuiEAHDWQ8dE\">单点故障</a>\"问题。</p><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/11/118f32b8fb7954d8add3edeb04ecd86f.webp\" /></p><p></p><p><a href=\"https://netflixtechblog.com/zero-configuration-service-mesh-with-on-demand-cluster-discovery-ac6483b52a51?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTU1OTgsImZpbGVHVUlEIjoiNDdrZ012amJ2bkl5bE0zViIsImlhdCI6MTY5NjIxNTI5OCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.6zMFSmh_RObQOtqH0kWOnNHCPY_0XiZWuiEAHDWQ8dE\">使用Eureka的IPC</a>\"</p><p></p><p>这种架构存在了很长时间，不过Netflix因为一些原因需要迁移到<a href=\"https://en.wikipedia.org/wiki/Service_mesh?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTU1OTgsImZpbGVHVUlEIjoiNDdrZ012amJ2bkl5bE0zViIsImlhdCI6MTY5NjIxNTI5OCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.6zMFSmh_RObQOtqH0kWOnNHCPY_0XiZWuiEAHDWQ8dE\">服务网格</a>\"，主要的三个原因如下：</p><p></p><p>现在使用了<a href=\"https://en.wikipedia.org/wiki/REST?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTU1OTgsImZpbGVHVUlEIjoiNDdrZ012amJ2bkl5bE0zViIsImlhdCI6MTY5NjIxNTI5OCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.6zMFSmh_RObQOtqH0kWOnNHCPY_0XiZWuiEAHDWQ8dE\">REST</a>\"、<a href=\"https://graphql.org/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTU1OTgsImZpbGVHVUlEIjoiNDdrZ012amJ2bkl5bE0zViIsImlhdCI6MTY5NjIxNTI5OCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.6zMFSmh_RObQOtqH0kWOnNHCPY_0XiZWuiEAHDWQ8dE\">graphQL</a>\"和<a href=\"https://grpc.io/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTU1OTgsImZpbGVHVUlEIjoiNDdrZ012amJ2bkl5bE0zViIsImlhdCI6MTY5NjIxNTI5OCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.6zMFSmh_RObQOtqH0kWOnNHCPY_0XiZWuiEAHDWQ8dE\">gRPC</a>\"混合的IPC技术。已经从Java基础架构迁移到了多语言架构。向IPC客户端中添加功能。</p><p></p><p>Netflix决定使用Envoy集中实现IPC功能集，并让使用各种语言开发的客户端尽可能简单。此外，Envoy支持发现抽象（Discovery Abstraction），因此IPC客户端可以继续使用它。缺点是Envoy需要在代理配置中指定集群，这对Netflix架构来说是个问题，因为一个服务可能与十几个集群进行通信。此外，Netflix的架构是不断变化的，这意味着集群会随着时间的推移而变化。为了解决这个问题，Netflix团队调研了一些方案：</p><p></p><p>让服务所有者定义他们的服务需要通信的集群。根据服务的调用图自动生成Envoy配置。将所有的集群信息推送给每个应用。</p><p></p><p>但所有这些方案都存在缺点，因此他们最终的解决方案是在运行时按需获取集群信息。为了实现这个解决方案，Envoy需要一个新特性。于是，Envoy社区、Netflix和Kinvolk合作开发了<a href=\"https://github.com/envoyproxy/envoy/pull/18723?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTU1OTgsImZpbGVHVUlEIjoiNDdrZ012amJ2bkl5bE0zViIsImlhdCI6MTY5NjIxNTI5OCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.6zMFSmh_RObQOtqH0kWOnNHCPY_0XiZWuiEAHDWQ8dE\">按需集群发现(ODCDS)</a>\" 功能。现在，代理可以在第一次连接时查找集群信息。新的流程如下：</p><p></p><p>客户端的请求进入Envoy；根据主机地址提取目标集群信息。如果集群是已知的，进入步骤7；如果集群不存在，请求被暂停；向控制平面上的集群发现服务(CDS)端点发出请求。控制平面根据服务的配置和Eureka注册信息生成自定义CDS响应；Envoy拿到集群信息(CDS)，通过端点发现服务(EDS)拉取端点信息，然后根据VIP或SVIP的Eureka状态信息返回集群的端点；客户端的请求继续；Envoy像往常一样处理请求：使用负载均衡算法选择一个端点并发出请求。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b9/b960734194a88248f864d019f71a7bba.webp\" /></p><p></p><p><a href=\"https://netflixtechblog.com/zero-configuration-service-mesh-with-on-demand-cluster-discovery-ac6483b52a51?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTYyMTU1OTgsImZpbGVHVUlEIjoiNDdrZ012amJ2bkl5bE0zViIsImlhdCI6MTY5NjIxNTI5OCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.6zMFSmh_RObQOtqH0kWOnNHCPY_0XiZWuiEAHDWQ8dE\">使用Eureka和Envoy的IPC</a>\"</p><p></p><p>这个流程的执行速度为毫秒级，但在某些场景中，服务需要更低的延迟。为了解决这个问题，目前的解决方案有：</p><p></p><p>服务需在发出第一个请求之前预先定义目标集群或建立主要连接。在代理启动时，根据历史请求模式从控制平面预推送集群信息。</p><p></p><p>Netflix和Envoy社区将继续合作改进Envoy。</p><p></p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/09/zero-config-service-mesh-netflix/\">https://www.infoq.com/news/2023/09/zero-config-service-mesh-netflix/</a>\"</p>",
    "publish_time": "2023-10-06 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "全球十大最有价值AI初创企业公布，这家26岁华裔青年创办的AI独角兽估值仅次于OpenAI",
    "url": "https://www.infoq.cn/article/xYXCTKLkttJOJNd6P832",
    "summary": "<p>过去两年以来，AI领域经历了一波显著演变，而其核心则是生成式AI的快速崛起。所谓生成式AI，是一种能够通过简单操作生成文本、图像、音频等结果的AI技术，所遵循的操作命令则被称为提示词。</p><p>&nbsp;</p><p>值得注意的是，这一进步催生出了全新的行业，初创企业和老牌巨头都开始挖掘生成式AI中的潜力。凭借其快速生成多样化内容的能力，生成式AI在从创意产业到数据分析的各个领域，都激发起广泛的创新可能性。随着企业利用这项技术来简化流程、吸引客户并开发前沿产品，市场动态自然也会随之变化、呈现出前所未有的新形态。</p><p>&nbsp;</p><p>生成式AI对于行业格局的影响堪称深远，老牌公司也就此有了冲击新高峰的机会。随着成熟企业拥抱生成式AI，并将其整合至原本的运营体系当中，其市值开始大幅飙升。随着领域内竞争态势的加剧，人们逐渐发现有效运用生成式AI的能力，已经成为决定公司未来命运和增长轨迹的决定性因素。</p><p>&nbsp;</p><p>生成式AI带来的变革性力量不仅作用于单一公司，而是构建起一个创新与技术进步的整体环境。随着创造性探索与实践应用的融合，生成式AI正凭借一条条提示词塑造着未来。</p><p>&nbsp;</p><p>在跟风险投资家或者初创公司的创始人们交流时，他们往往会抛出这样一个共同观点：过去两年间，实现融资和良好估值已经越来越困难。现实数据也确实支持这一观察。但当我们把目光投向AI领域，则会出现极为鲜明的对比。在这个舞台上，初创公司、特别是那些基于生成式AI的初创公司，他们的实际表现几乎与消极的整体环境截然相反。</p><p>&nbsp;</p><p>AI企业确实表现出非凡的能力，可以吸引到大量资金（通常可达数十亿美元之巨），同时获得可观的市场估值。这场席卷全球的经济衰退，似乎没有给他们的发展轨迹蒙上哪怕一丝阴影。</p><p>&nbsp;</p><p>在今天的文章中，我们将探讨全球十家估值最高的AI初创公司。他们不仅筹集到数十亿美元，而且总估值已然突破500亿美元大关。</p><p>&nbsp;</p><p>快速分析：如下图所示，这些公司中有九家总部位于美国，唯一的一家非美国公司来自加拿大。另外，其中九家为独角兽企业，一家已经成长为“十角兽”。除了Tiger Global和红杉等VC和PE领域的大牌之外，其他知名投资方还包括微软、谷歌、英伟达和Salesforce等大型科技公司。排名前六的公司中，有四家正在开发大语言模型，而且相互之间处于直接竞争关系。排名第七、八、九的三家公司，则主要利用AI产品为客服中心提供服务。榜单中只有一家厂商专攻GPT打包器产品。</p><p>&nbsp;</p><p>下图，就是在估值上傲视同侪的十大AI初创企业。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/48/48cf788d7a317d155032cbadcfef7593.png\" /></p><p></p><p>全球估值最高的十大AI初创公司。</p><p></p><h3>1) OpenAI – 290亿美元 billion</h3><p></p><p>总融资规模：113亿美元</p><p>主要投资方：微软</p><p>&nbsp;</p><p>OpenAI目前的市场估值高达290亿美元，成为全球估值最高的AI初创公司。其最著名的投资方就是微软，软件帝国通过一项复杂交易共向该公司注资达110亿美元。截至目前，OpenAI总计筹集到113亿美元资金。</p><p>&nbsp;</p><p>这家公司于2015年12月正式创立，除了Sam Altman、Greg Brockman、Ilya Sutskever、John Schulman 和&nbsp;Wojciech Zaremba之外，还有“硅谷钢铁侠”马斯克的参与。OpenAI希望以造福全人类的方式创造先进的通用人工智能（AGI）。截至目前，该公司专注于构建大语言模型，这是一种意在理解自然语言的AI方案。模型经过大量数据的训练，能够生成与人类相似的文本等多种输出形式。</p><p>&nbsp;</p><p>该公司于2020年6月发布了GPT-3（即生成式预训练Transformer 3），成为真正意义上的突破性大语言模型，拥有1750亿个参数（用于控制模型如何处理数据的内部设置）。GPT-3与OpenAI此前模型的最大区别，在于其庞大的整体规模（作为前代产品，GPT-2仅有15亿个参数）和生成与人类相似文本的能力。</p><p>&nbsp;</p><p>但真正让OpenAI进入公众视野的还得说ChatGPT，这是一款以GPT-3为基础构建而成的对话聊天机器人。ChatGPT于2022年11月启动，成功弥合了AI与人类之间的交互鸿沟，成为AI进步中的标志性里程碑。发布后短短两个月时间内，聊天机器人就赢得1亿用户，以创纪录的速度成为发展最快的消费级互联网产品。在此之后，该公司又陆续推出了多种新功能、产品和大语言模型。</p><p>&nbsp;</p><p>关于OpenAI发展历程的有趣之处在于，该公司的最初定位其实是非营利组织，但在2019年起转向有限利润结构，用以吸引外部投资和技术人才（提供股票期权）。这种模式允许公司在业务成功的前提下向股东提供有限的分红。而超出设定上限的回报，则归OpenAI的原始非营利实体所有。作为其中的营利性实体，Openai LP将OpenAI非营利组织视为其控股股东。</p><p>&nbsp;</p><p>该公司在结构和所有权方面还有另外一个有趣的点，其联合创始人兼CEO Sam Altman并不持有公司的任何所有权股份。</p><p>&nbsp;</p><p>OpenAI的目标是在2024年实现10亿美元收入。他们目前主要靠提供高级版ChatGPT（价格为19美元）来赚钱，并向开发商和企业收取在产品中使用其LLM API的费用。</p><p></p><h3>2) Scale – 73亿美元</h3><p></p><p>总融资规模：6亿美元</p><p>主要投资方：Dragoneer、Tiger Global、Greenoaks</p><p>&nbsp;</p><p>Scale（前ScaleAI）是全球估值第二高的私人AI公司，其估值为73亿美元。迄今为止，该公司已经于2021年4月筹集到6亿美元的资金，其中E轮融资筹得3.25亿美元。Scale的投资方包括Dragoneer、Greenoaks、Tiger Global、Coatue、Coatue、Index、Founders Fund、Founders Fund和Y Combinator等。</p><p>&nbsp;</p><p>作为一家由Alexandr Wang，Lucy Guo和Brandon Zhang于2016年成立的公司，Scale希望通过提供高质量的训练数据来加快AI应用程序的开发进展。值得一提的是，作为ScaleAI的创始人，Alexandr Wang是一位年仅26岁的华裔青年，目前他所创办的公司已经成为硅谷最杰出的人工智能公司之一。该公司的业务范围涵盖数据注释、数据管理和机器学习运营，这些服务将帮助用户团队在生产环境中部署并管理其机器学习模型。据该公司介绍，他们迄今为止已经完成了超75亿条数据注释。</p><p>&nbsp;</p><p>Scale的客户包括生成式AI平台、领先的技术厂商和政府机构。该公司还成为有意研发大语言模型的企业（包括OpenAI）的首选合作伙伴，帮助他们为客户训练此类模型。</p><p>&nbsp;</p><p>这家总部位于旧金山的企业在非洲、菲律宾等全球多地组织起一支人力大军，参与对不同AI模型进行分类和数据标注。这部分工作主要通过旗下子公司Remotasks完成，但这家公司因为工人薪酬过低而面临批评，据称还经常推迟或停发应付工资。</p><p>&nbsp;</p><p>根据公司CEO的介绍，Scale在2021年完成了最后一轮融资，当时其年内收入期望为1亿美元。</p><p></p><h3>3) Anthropic – 50亿美元</h3><p></p><p>总融资规模：11亿美元</p><p>主要投资方：SK电信、谷歌、Spark Capital</p><p>&nbsp;</p><p>Anthropic由OpenAI公司前研究副总裁Dario Amodei和他的姐姐Daniela（OpenAI前安全与政策副总裁）共同建立。除他们二人，这家企业还至少吸引了其他九位前OpenAI员工。</p><p>&nbsp;</p><p>截至目前，这家公司已经筹集到11亿美元，其中包括本月初韩国SK电信投入的1亿美元。该公司很快成长为全球估值第三高的AI初创企业，据报道估值为50亿美元。尽管该公司本身尚未正式确认这个数字，但多家信誉良好的媒体报道了其今年年初的融资活动，称目前估值为50亿美元。值得注意的是，该公司最终虽然披露了融资轮细节，但仍决定不公布具体估值。另有媒体表示，该公司的交易前估值应该是41亿美元。</p><p>&nbsp;</p><p>该公司希望构建起可靠、可解释且有说服力的大语言模型（他们称其&nbsp;为AI系统）。官方网站提到，“我们开发出大规模的AI系统，以便在最容易暴露问题的各个技术前沿中研究其安全性。我们使用这些见解来建立起更安全、可协调且更加可靠的模型，再转化成Claude之类能够在外部部署的系统成果。”</p><p>&nbsp;</p><p>作为Anthropic打造的AI助手，Claude于今年早些时候首次亮相，可以通过基于聊天的界面和API进行访问。该公司目前掌握两款大语言模型：Claude 2，他们的主力模型，主要用于复杂的推理、创作、对话、编码和较为具体的任务创建场景；另外还有Claude Instant，一款更具成本效益的模型，可稳定完成随意闲聊、文本分析、总结和文档解析等工作。</p><p>&nbsp;</p><p>目前，其聊天机器人和API的访问均未全面开放。聊天机器人处于对外公测阶段，而API业务访问则仅向特定合作伙伴提供。</p><p></p><h3>4) Hugging Face – 45亿美元</h3><p></p><p>总融资规模：4亿美元</p><p>主要投资方：谷歌、亚马逊、英伟达</p><p>&nbsp;</p><p>Hugging Face本月早些时候刚刚从全球最大的几家科技巨头处筹得2.35亿美元，目前是以45亿美元估值排名第四的明显AI初创公司。迄今为止，该公司的融资总额已接近4亿美元，其投资方包括谷歌、亚马逊、英伟达、Salesforce、AMD、英特尔、高通、Lux Capital、红杉资本和Coatue。</p><p>&nbsp;</p><p>Hugging Face由 Clément Delangue、Julien Chaumond&nbsp;和 Thomas Wolf 于 2016 年创立，最初只是想为青少年开发一款聊天机器人。但随着后续发展，它开始转向AI的另一领域——构建机器学习技术平台，推动机器学习大众化。</p><p>&nbsp;</p><p>该公司常被称为机器学习领域的GitHub，在平台之上向开发人员开放对数千个预训练机器学习模型及自研模型的浏览、使用和共享，同时提供跨社区互动、数据集下载和模型自动训练等服务。这家初创公司的专业账户每月收费9美元，企业账户中的每位用户月费则为20美元。他们还提供模型托管服务，最低价格为每小时0.06美元。</p><p>&nbsp;</p><p>根据福布斯的报道，该公司的年收入估计在3000万至5000万美元之间。</p><p></p><h3>5) Inflection AI – 40亿美元</h3><p></p><p>总融资规模：15.25亿美元</p><p>主要投资方：英伟达、微软、谷歌</p><p>&nbsp;</p><p>这家公司由多位科技界的重量级人物于2022年创立，包括LinkedIn 联合创始人 Reid Hoffman、Google DeepMind 联合创始人 Mustafa Suleyman 以及 DeepMind 前首席科学家&nbsp;Karén&nbsp;Simonyan。Inflection AI是一家AI工作室，希望为每个人打造个性化AI。他们的首款产品于今年年初推出，是一款名为Pi（代表个人智能）的AI助手。</p><p>&nbsp;</p><p>根据报道，就在两个月前，该公司通过一轮13亿美元的巨额融资获得了40亿美元估值。此轮融资由微软、里德·霍夫曼、比尔·盖茨、埃里克·施密特和英伟达领投，一举将融资总额推上15.25亿美元。最新估值让Inflection成为全球估值第五高的私人AI公司，也是资金最为充足的初创企业之一。</p><p>&nbsp;</p><p>Pi助手由该公司自研的大语言模型Inflection -1提供支持，项目于今年6月正式披露。Inflection计划尽快通过对话式API将该服务向开发者用户开放。由于这是一家垂域整合型AI工作室，因此其AI训练和推理等工作均在内部自主完成。</p><p>&nbsp;</p><p>该公司宣称，其Inflection-1大语言模型在计算性能方面傲视同侪，“在常用于比较大语言模型性能的各类基准测试中”优于GPT-3.5、LLaMA、Chinchilla和PaLM-540B。</p><p></p><h3>6) Cohere – 22亿美元</h3><p></p><p>总融资规模：4.45亿美元</p><p>主要投资方：Inovia Capital、英伟达、Tiger Global</p><p>&nbsp;</p><p>Cohere是这份榜单上唯一一家非美国初创企业。Cohere总部位于加拿大多伦多，由前Google Brain团队成员Aidan Gomez、Nick Frosst&nbsp;以及 Ivan Zhu 于 2019 年创立。该公司开发的大语言模型能够理解并生成与人类相似的文本，与OpenAI、Anthropic和Inflection属于直接竞争关系，且主要关注企业服务。</p><p>&nbsp;</p><p>在今年6月的最后一轮融资（2.7亿美元）当中，Cohere获得了22亿美元的估值。截至目前，该公司已经从英伟达、甲骨文、Salesforce、Inovia Capital和Tiger Global等投资方处筹集到总计4.45亿美元。据报道，Tiger Global一直在就收购该公司部分股份的方案寻求谈判，一旦成功有望将Cohere的估值推上30亿美元。</p><p>&nbsp;</p><p>就在一个月前，这家加拿大AI初创公司推出了Coral，一款专为企业设计的AI助手。Coral能够帮助员工完成各种任务，例如回答客户问题和分析业务数据。当员工提出问题时，它能使用公司内部的信息及其他信源给出答案。它可以对接企业内的100多种数据源，包括文档、数据库等。</p><p>&nbsp;</p><p>目前Coral尚处于内测阶段，以该公司最新的Command模型为基础，这套模型仍保持着每周更新。同时，Cohere的Command模型也可通过API供外部开发者在自己的产品中使用。</p><p></p><h3>7) Dialpad – 22亿美元</h3><p></p><p>总融资规模：4.18亿美元</p><p>主要投资方：Iconiq Capital、软银、Omers</p><p>&nbsp;</p><p>Dialpad由Craig Walker、John Rector 和 Brian Peterson 于 2011 年创立，是一款面向企业的AI统一通信与客服中心平台，可帮助企业通过语音、消息和视频会议等渠道与客户开展交互。</p><p>&nbsp;</p><p>与榜单上的大多数其他公司不同，Dialpad并不是一家AI公司。其目前的主要业务是为客户提供多种AI驱动型服务，并凭借22亿美元的估值成为全球第七大私人AI公司。迄今为止，该公司已筹集到4.18亿美元资金，其中包括2021年最新一轮融资获得的1.7亿美元。Dialpad的投资方包括Iconiq、软银、Omers、Amasia、GV、Andreessen Horowitz 和 Salesforce Venture。</p><p>&nbsp;</p><p>该公司在官方网站上宣称，其产品已经得到7000家品牌客户的采用，包括Motorola Solutions、Netflix、T-Mobile 和 Uber 等。</p><p></p><h3>8) Asapp – 16亿美元</h3><p></p><p>总融资规模：4亿美元</p><p>主要投资方：Fidelity、Dragoneer</p><p>&nbsp;</p><p>总部位于纽约的Asapp拥有16亿美元估值，成为全球第八大最有价值的AI初创公司。2021年，该公司通过C轮融资从Fidelity和Dragoneer处筹得1.2亿美元，使其迄今为止的融资总额达到4亿美元。</p><p>&nbsp;</p><p>Asapp由Gustavo Sapoznik&nbsp;于 2014 年创立，主要为客服中心提供各类AI产品及服务，帮助其优化运营、提高座席生产力及销售执行效率。</p><p>&nbsp;</p><p>该公司宣称，其服务能够帮助客服中心将平均处理时间缩短10%以上、流程上手周期减半、增强客户服务体验，并自动处理70%的响应内容。它能自动总结所有客户交互，并利用据称是全球最准确的语音到文本技术实现呼叫内容转录。</p><p>&nbsp;</p><p>这家初创公司喜欢自称为AI研究公司，旨在推进AI发展以增强人类活动，帮助企业解决种种现实难题。Asapp的官方网站写道，“我们当前的议程包括客户服务领域的一系列重要工作。这个领域向来充斥着各种问题与大量数据，也是创新和应用AI/机器学习技术的理想场景。通过我们在面向任务对话、自然语言处理和语音识别方面的研究，我们为消费级公司带来了极具影响力的绩效提升。这不仅对企业客户具有现实意义，更是全体消费者的福音。”</p><p></p><h3>9) Cresta AI – 16亿美元</h3><p></p><p>总融资规模：1.51亿美元</p><p>主要投资方：Tiger Global、红杉资本</p><p>&nbsp;</p><p>Cresta AI也是一家专注利用生成式AI改善客服中心运营效能的初创公司。Cresta由S. Zayd Enam、Sebastian Thrun和Tim Shi于 2017 年创立，主要为客服中心提供AI驱动工具，帮助他们提高客户支持效果、增强销售运营效率。</p><p>&nbsp;</p><p>其技术能够提供实时指导、日常任务自动化，并基于数据分析生成见解，据此为客服人员增添助力。他们的目标是提高座席工作效率、缩短处理时间并提高整体客户服务质量。</p><p>&nbsp;</p><p>该公司在官网上写道，“Cresta的实时智能平台依托于生成式AI技术，可帮助客服、经理和部门领导者协同工作，最大限度提高收入、服务效率并创造卓越的客户体验。与客服中心内使用的传统工具相比，Cresta能够分析复杂的陈述、情绪、情感和行为，帮助更深入地理解客户对话内容。”</p><p>&nbsp;</p><p>Cresta的估值同样为16亿美元，碰巧跟竞争对手Asapp在本次全球估值最高AI初创公司榜单上并列第八。2022年3月，该公司在由Tiger Global领投的C轮融资中筹得8000万美元。</p><p>&nbsp;</p><p>Cresta的产品得到全球多家领先企业的使用，包括希尔顿、洲际酒店集团酒店及度假村、CarMax、Blue Nile、Earthlink、Intuit以及保时捷。</p><p></p><h3>10) Jasper – 15亿美元</h3><p></p><p>总融资规模：1.31亿美元</p><p>主要投资方： Insight Partners、Foundation Capital</p><p>&nbsp;</p><p>考虑到Asapp和Cresta在全球估值最高的AI初创公司榜单上并列第八，所以Jasper只能屈居第十位。该公司去年刚刚筹集到1.25亿美元，目前估值为15亿美元。他们也是GPT打包器业务领域估值最高的AI初创公司，主要负责在OpenAI的GPT技术之上构建自己的服务。</p><p>&nbsp;</p><p>Jasper 由 Dave Rogenmoser、Chris Hull和John Philip Morgan于 2017 年创立，前身为Proof公司。最初，其主要业务是通过产品帮助企业提高网站转化率。但在2021年，这家初创企业经历了一波转型，推出一款名为Jarvis AI的AI写作工具。之后经过品牌重塑，就有了我们现在所知的Jasper公司。用他们自己的话来说，Jasper是一款创意型AI助手，能够帮助企业根据自身品牌形象创建宣传内容。</p><p>&nbsp;</p><p>这家初创公司提供三种主要工具。其一能帮助用户编写内容，包括博文和社交媒体帖子。其二是Chrome扩展程序，可以在Google Docs和Gmail等应用程序中为用户提供编写建议。其三则是AI图像生成器，名为Jasper Art。Jasper也通过API对外开放自家技术方案。</p><p>&nbsp;</p><p>这家总部位于奥斯汀的AI公司宣称，其2021年的收入总额为4500万美元，据报道有望在2022年进一步增长至7500万美元。尽管刚刚完成一波巨额融资，但Jasper还是被迫在几个月后进行了一波裁员，据称此举是为了重塑公司团队。</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://aibeat.co/highest-valued-ai-startups/\">https://aibeat.co/highest-valued-ai-startups/</a>\"</p>",
    "publish_time": "2023-10-06 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Java近期新闻：JCP 25周年、外部函数&内存API、Eclipse Epicyro",
    "url": "https://www.infoq.cn/article/cR6cA98S1jv7e8KHGfpy",
    "summary": "<p></p><h4>OpenJDK</h4><p></p><p>上个周，JEP 454（<a href=\"https://openjdk.org/jeps/454\">外部函数&amp;内存API</a>\"）已经从JEP Draft 8310626状态<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-September/008260.html\">提升</a>\"到Candidate状态。该JEP建议最终确定这个已经经历了两轮孵化和三轮预览的特性：JEP 412（<a href=\"https://openjdk.org/jeps/412\">外部函数&amp;内存API第一轮孵化</a>\"）在JDK 17中交付；JEP 419（<a href=\"https://openjdk.org/jeps/419\">外部函数&amp;内存API第二轮孵化</a>\"）在JDK 18中交付；JEP 424（<a href=\"https://openjdk.org/jeps/424\">外部函数&amp;内存API第一次预览</a>\"）在JDK 19中交付；JEP 434（<a href=\"https://openjdk.org/jeps/434\">外部函数&amp;内存API第二次预览</a>\"）在JDK 20中交付；JEP 442（<a href=\"https://openjdk.org/jeps/442\">外部函数&amp;内存API第三次预览</a>\"）将在即将发布的JDK 21 GA版本中交付。自上一个版本以来的改进包括：新增清单属性Enable-Native-Access，使可执行JAR文件中的代码可以调用受限方法，而无需使用--enable-native-access标识；允许客户端以编程方式构建C函数描述符，避免使用特定于平台的常量；改进对本地内存可变长数组的支持；在本地字符串中支持多个字符集。</p><p>&nbsp;</p><p></p><h4>JCP</h4><p></p><p>2023年9月13日，<a href=\"https://www.javasig.com/\">纽约Java特别兴趣小组</a>\"和<a href=\"https://gsjug.org/\">Garden State Java用户组</a>\"在纽约市的纽约梅隆银行举办了一场特别活动，来自JCP（Java Community Process）<a href=\"https://jcp.org/en/participation/committee\">执行委员会</a>\"（EC）的行业专家参加了小组讨论，谈了他们在JCP EC最美好的回忆以及在即将发布的JDK 21 GA版本中最喜欢的功能。庆祝活动包括Bellsoft性能架构师<a href=\"https://www.linkedin.com/in/dchuyko/\">Dmitry Chuyko</a>\"的JDK 21演示，以及JCP 25周年庆典。要了解有关此次活动的更多细节，请阅读<a href=\"https://www.infoq.com/news/2023/09/jcp-25th-anniversary/\">InfoQ的这篇新闻报道</a>\"。</p><p>&nbsp;</p><p></p><h4>JDK 21</h4><p></p><p><a href=\"https://github.com/openjdk/jdk/releases/tag/jdk-21%2B35\">Build 35</a>\"仍是JDK 21<a href=\"https://jdk.java.net/20/\">早期访问构建</a>\"的当前构建。要了解关于这个版本的更多细节，请查看<a href=\"https://jdk.java.net/21/release-notes\">发布说明</a>\"。</p><p>&nbsp;</p><p></p><h4>JDK 22</h4><p></p><p>JDK 22<a href=\"https://jdk.java.net/22/\">早期访问构建</a>\"<a href=\"https://github.com/openjdk/jdk/releases/tag/jdk-22%2B15\">Build 15</a>\"在上周发布，其中包括Build 14的<a href=\"https://github.com/openjdk/jdk/compare/jdk-22%2B14...jdk-22%2B15\">更新</a>\"，主要是修复了各种<a href=\"https://bugs.openjdk.org/issues/?jql=project%20%3D%20JDK%20AND%20fixversion%20%3D%2022%20and%20%22resolved%20in%20build%22%20%3D%20b15%20order%20by%20component%2C%20subcomponent\">问题</a>\"。要了解关于这个版本的更多细节，请查看<a href=\"https://jdk.java.net/22/release-notes\">发布说明</a>\"。</p><p>&nbsp;</p><p>对于<a href=\"https://openjdk.org/projects/jdk/22/\">JDK 22</a>\"和<a href=\"https://openjdk.java.net/projects/jdk/21/\">JDK 21</a>\"，我们鼓励开发人员通过<a href=\"https://bugreport.java.com/bugreport/\">Java Bug数据库</a>\"报告Bug。</p><p>&nbsp;</p><p></p><h4>Spring Framework</h4><p></p><p>经历了两周的平静之后，Spring团队发布了<a href=\"https://spring.io/projects/spring-framework\">Spring Framework</a>\"、<a href=\"https://spring.io/projects/spring-data\">Spring Data</a>\"和<a href=\"https://spring.io/tools\">Spring Tools</a>\"的点版本和里程碑版本。</p><p>&nbsp;</p><p><a href=\"https://spring.io/blog/2023/09/14/spring-framework-6-1-m5-released\">Spring Framework 6.1.0的第五个里程碑版本</a>\"带来了Bug修复、依赖项升级和一系列新特性，其中包括：将新的接口RestClient用于可观察性；作为对其Jakarta Annotations版本的补充，恢复对JSR-250（Java平台通用注解）中定义的@ManagedBean注解和JSR 330（<a href=\"https://jcp.org/en/jsr/detail?id=330\">Java依赖注入</a>\"）中定义的@Named注解的支持，改进项目向Spring 6.0及更高版本的迁移；修改JdbcTestUtils&nbsp;类中定义的方法签名，使其接受JdbcOperations接口而不是JdbcTemplate类的实例。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/spring-projects/spring-framework/releases/tag/v6.1.0-M5\">发布说明</a>\"。</p><p>&nbsp;</p><p>同样，Spring Framework 6.0.12和5.3.30也带来了Bug修复、依赖项升级和一些新特性，其中包括：优化在ClassUtils类中定义的getMostSpecificMethod()方法；优化StringUtils类中的空格检查；消除了在创建scoped bean实例时会导致性能瓶颈的冗余的类和注解查找。要了解关于这些版本的更多细节，请查看<a href=\"https://github.com/spring-projects/spring-framework/releases/tag/v6.0.12\">6.0.12</a>\"和<a href=\"https://github.com/spring-projects/spring-framework/releases/tag/v5.3.30\">5.3.30</a>\"版本的发布说明。</p><p>&nbsp;</p><p><a href=\"https://spring.io/blog/2023/09/15/spring-data-2023-1-0-m3-released\">Spring Data 2023.1.0的第三个里程碑版本</a>\"（代号为Vaughn）带来了一些值得注意的变化，其中包括：支持JDK 21；通过配置Java Executor接口使用虚拟线程；支持Kotlin<a href=\"https://kotlinlang.org/docs/inline-classes.html\">值类</a>\"；<a href=\"https://spring.io/projects/spring-data-jdbc\">Spring Data JDBC</a>\"单查询加载。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/spring-projects/spring-data-commons/wiki/Spring-Data-2023.1-%28Vaughan%29-Release-Notes\">发布说明</a>\"。</p><p>&nbsp;</p><p>同样，Spring Data的2023.0.4、2022.0.10和2021.2.16版本以及所有的<a href=\"https://spring.io/blog/2023/09/15/spring-data-2023-0-4-2022-0-10-and-2021-2-16-released\">服务版本</a>\"主要也是修复了Bug和和升级了依赖项，其中包括：Spring Data Commons 3.1.4、3.0.10和2.7.14；Spring Data MongoDB 4.1.4、4.0.10和3.4.16；Spring Data Elasticsearch 5.1.4、5.0.10和4.4.16；Spring Data Neo4j 7.1.4、7.0.10和6.3.16。</p><p>&nbsp;</p><p>用于Eclipse、Visual Studio Code和Theia的<a href=\"https://spring.io/blog/2023/09/13/spring-tools-4-20-0-released\">Spring Tools 4.20.0发布</a>\"，主要特性包括：修复了一些Bug；支持Eclipse IDE 2023-09；为了显示特定于Spring的验证，改进了Java Reconciling支持，并从头开始重新构建，然后为了能适用于大型代码库做了性能优化。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/spring-projects/sts4/releases/tag/4.20.0.RELEASE\">发布说明</a>\"。</p><p>&nbsp;</p><p></p><h4>Payara</h4><p></p><p>Payara<a href=\"https://blog.payara.fish/whats-new-in-the-september-2023-payara-platform-release\">发布</a>\"了2023年9月版的<a href=\"https://www.payara.fish/\">Payara平台</a>\"，其中包括社区版6.2023.9、企业版6.6.0和企业版5.55.0，主要是提供了安全修复，以解决<a href=\"https://nvd.nist.gov/vuln/detail/CVE-2017-12617\">CVE-2017-12617</a>\"（这是一个在各种Apache Tomcat版本[启用了HTTP PUT]都存在的漏洞，攻击者可以将特制的JSP文件上传到服务器，这样，当它被请求时，它所包含的任何代码都将由服务器执行）和<a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-1370\">CVE-2023-1370</a>\"（这是<a href=\"https://netplex.github.io/json-smart/\">JSON-smart</a>\"中的一个漏洞，由于没有进行限制，解析嵌套太深的JSON结构化数组和对象时可能会导致栈溢出进而导致软件崩溃）。该版本还带来了一些改进，其中包括：从Jakarta EJB EJBContext接口中删除了过时的方法：getEnvironment()、getCallerIdentity()和isCallerInRole(Identity)，这些方法是在Payara EJBContextImpl类中实现的；改进了Hazelcast <a href=\"https://docs.hazelcast.com/imdg/3.12/cp-subsystem/cp-subsystem\">CP Subsystem</a>\"的功能。要了解关于这些版本的详细信息，请查看<a href=\"https://docs.payara.fish/community/docs/Release%20Notes/Release%20Notes%206.2023.9.html\">社区版6.2023.9</a>\"、<a href=\"https://docs.payara.fish/enterprise/docs/Release%20Notes/Release%20Notes%206.6.0.html\">企业版6.6.0</a>\"和<a href=\"https://docs.payara.fish/enterprise/docs/5.55.0/Release%20Notes/Release%20Notes%205.55.0.html\">企业版5.55.0</a>\"的发布说明。</p><p>&nbsp;</p><p></p><h4>Quarkus</h4><p></p><p>Red Hat<a href=\"https://quarkus.io/blog/cve-2023-4853/\">发布</a>\"了<a href=\"https://quarkus.io/\">Quarkus</a>\"的3.3.3、3.2.6和2.6.11.Final版本，修复了<a href=\"https://access.redhat.com/security/cve/cve-2023-4853\">CVE-2023-4853</a>\"（攻击者可以通过该漏洞绕过HTTP安全策略，因为这些安全策略在接受请求时没有正确地清除某些字符排列，从而导致对权限的判断错误，导致未经授权的端点访问和拒绝服务）。要了解关于这些版本的更多细节，请查看<a href=\"https://github.com/quarkusio/quarkus/releases/tag/3.3.3\">3.3.3</a>\"、<a href=\"https://github.com/quarkusio/quarkus/releases/tag/3.2.6.Final\">3.2.6</a>\"和<a href=\"https://github.com/quarkusio/quarkus/releases/tag/2.16.11.Final\">2.16.11版本</a>\"的变更日志。</p><p>&nbsp;</p><p></p><h4>Micronaut</h4><p></p><p>Micronaut基金会<a href=\"https://micronaut.io/2023/09/13/micronaut-framework-4-1-1-released/\">发布</a>\"了<a href=\"https://micronaut.io/\">Micronaut 4.1.1</a>\"版本，其中包括<a href=\"https://github.com/micronaut-projects/micronaut-core/releases/tag/v4.1.5\">Micronaut Core 4.1.5</a>\"和模块更新：<a href=\"https://micronaut-projects.github.io/micronaut-oracle-cloud/latest/guide/\">Micronaut Oracle Cloud</a>\"、<a href=\"https://micronaut-projects.github.io/micronaut-aot/latest/guide/\">Micronaut AOT</a>\"、<a href=\"https://micronaut-projects.github.io/micronaut-data/latest/guide/\">Micronaut Data</a>\"、<a href=\"https://micronaut-projects.github.io/micronaut-kafka/latest/guide/\">Micronaut Kafka</a>\"、<a href=\"https://micronaut-projects.github.io/micronaut-kotlin/latest/guide/\">Micronaut Kotlin Integrations</a>\"、<a href=\"https://micronaut-projects.github.io/micronaut-test/latest/guide/\">Micronaut Test</a>\"、<a href=\"https://micronaut-projects.github.io/micronaut-test/latest/guide/\">Micronaut Validation</a>\"和<a href=\"https://micronaut-projects.github.io/micronaut-multitenancy/latest/guide/\">Micronaut Multitenancy</a>\"。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/micronaut-projects/micronaut-platform/releases/tag/v4.1.1\">发布说明</a>\"。</p><p>&nbsp;</p><p></p><h4>Helidon</h4><p></p><p><a href=\"https://helidon.io/\">Helidon</a>\" 2.6.3是一个Bug修复版本，有一些值得注意的变化，其中包括：用ServerConfiguration接口中定义的namedSocket()方法替换已弃用的socket()方法；更新在ServerRequest接口中定义的requestduri()方法，以便可以正确地处理IPv6地址格式；将OciMetricsDataTest类中定义的beforeEach()方法的访问指示符从private更改为public，因为JUnit @BeforeEach注解的文档已明确说明该方法不能是私有或静态的。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/helidon-io/helidon/releases/tag/2.6.3\">发布说明</a>\"。</p><p>&nbsp;</p><p></p><h4>MicroProfile</h4><p></p><p>在迈向MicroProfile 6.1的道路上，<a href=\"https://github.com/eclipse/microprofile-telemetry/blob/main/README.adoc\">MicroProfile Telemetry</a>\"规范的1.1-RC3版本修复了JaxRsServerAsyncTestEndpoint TCK测试类中的一个部署问题。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/eclipse/microprofile-telemetry/releases/tag/1.1-RC3\">发布说明</a>\"。</p><p>&nbsp;</p><p></p><h4>Eclipse基金会</h4><p></p><p>OmniFishEE<a href=\"https://twitter.com/OmniFishEE/status/1702263849984885156\">推出</a>\"了一个新的Eclipse EE4J项目<a href=\"https://github.com/eclipse-ee4j/epicyro/blob/main/README.md\">Epicyro</a>\"，它将作为<a href=\"https://jakarta.ee/specifications/authentication/\">Jakarta Authentication</a>\"规范的兼容实现。该项目将为身份验证机制定义一个通用的低级SPI。其中的控制器将与调用者和容器环境交互以获取调用者凭据并进行验证，然后将经过身份验证的标识（如名称和组）传递给容器。目前，Epicyro是一个<a href=\"https://github.com/eclipse-ee4j/epicyro/releases/tag/3.0.0-M1-RELEASE\">里程碑版本</a>\"，从3.0.0版本开始，它将与Jakarta Authentication 3.0.0保持一致。</p><p>&nbsp;</p><p></p><h4>Apache软件基金会</h4><p></p><p><a href=\"https://groovy-lang.org/\">Apache Groovy</a>\" 5.0.0的<a href=\"https://www.mail-archive.com/announce@apache.org/msg08500.html\">第二个Alpha版本</a>\"提供了Bug修复、依赖项升级和改进，其中包括：停止使用曾经在sun.reflect包中定义的MagicAccessorImpl类；JsonOutput类应该像处理POGO（Plain Old Groovy Object）那样处理Java记录；使用@Generated注解将Groovy脚本中的main/run方法标记为由编译器生成。要了解关于该版本的更多细节，请查看<a href=\"https://issues.apache.org/jira/secure/ReleaseNote.jspa?projectId=12318123&amp;version=12353570\">发布说明</a>\"。</p><p>&nbsp;</p><p>同样，Apache Groovy 4.0.15<a href=\"https://www.mail-archive.com/announce@apache.org/msg08501.html\">发布</a>\"，也修复了一些Bug，升级了依赖项，并改进了JsonOutput类，使其可以像处理POGO那样处理Java记录。要了解关于该版本的更多细节，请查看<a href=\"https://issues.apache.org/jira/secure/ReleaseNote.jspa?projectId=12318123&amp;version=12353571\">发布说明</a>\"。</p><p>&nbsp;</p><p>为了与Quarkus保持一致，<a href=\"https://github.com/apache/camel-quarkus/blob/main/README.adoc\">Camel Quarkus</a>\" 3.2.0<a href=\"https://camel.apache.org/blog/2023/09/camel-quarkus-release-3.2.0/\">提供</a>\"了一些值得注意的问题解决方案，涉及：在dev模式下gRPC应用程序编译失败；扩展<a href=\"https://www.splunk.com/\">Splunk</a>\"、<a href=\"https://saxonica.com/welcome/welcome.xml\">Saxonica</a>\"和<a href=\"https://quarkus.io/guides/grpc-getting-started\">gRPC扩展</a>\"的测试覆盖；在使用<a href=\"https://quarkus.io/guides/security-ldap\">LDAP域扩展</a>\"执行完整性检查时的InvocationTargetException。要了解关于该版本的更多细节，请查看<a href=\"https://camel.apache.org/releases/q-3.2.0/\">发布说明</a>\"。</p><p>&nbsp;</p><p></p><h4>Grails</h4><p></p><p>Grails基金会<a href=\"https://grails.org/blog/2023-09-11-the-new-grails-plugin-portal.html\">推出</a>\"了一个重新设计的<a href=\"https://grails.org/plugins.html\">Grails插件门户</a>\"，主要特性包括：改进了搜索功能；所有插件的分页列表；排名靠前的插件列表；最新发布的插件。该门户的前一个版本一直为频繁停机、资源利用率高和性能差所困扰。</p><p>&nbsp;</p><p></p><h4>Micrometer</h4><p></p><p><a href=\"https://github.com/micrometer-metrics/micrometer/blob/main/README.md\">Micrometer Metrics</a>\"的1.12.0-M3、1.11.4、1.10.11和1.9.15版本都提供了依赖项升级，并修复了一个Bug，以确保LongTaskTimer和FunctionTimer接口产生的数据一致。1.12.0-M3版本提供的新特性包括：hasAnObservationWithAKeyValue()方法的一个变体，用于测试KeyValue接口；提供一种方法，基于ObservationPredicate接口（即Java BiPredicate接口）中的父节点来决定是否使用Spring Security中的/actuator端点；向Observation接口中定义的嵌套Event接口添加时间戳。要了解关于这些版本的更多细节，请查看<a href=\"https://github.com/micrometer-metrics/micrometer/releases/tag/v1.12.0-M3\">1.12.0-M3</a>\"、<a href=\"https://github.com/micrometer-metrics/micrometer/releases/tag/v1.11.4\">1.11.4</a>\"、<a href=\"https://github.com/micrometer-metrics/micrometer/releases/tag/v1.10.11\">1.10.11</a>\"和<a href=\"https://github.com/micrometer-metrics/micrometer/releases/tag/v1.9.15\">1.9.15</a>\"版本的发布说明。</p><p>&nbsp;</p><p>同样，<a href=\"https://github.com/micrometer-metrics/tracing/blob/main/README.md\">Micrometer Tracing</a>\"的1.2.0-M3、1.1.5和1.0.10版本也都提供了依赖项升级和Bug修复，其中包括：当线程完成任务后，ObservationAwareSpanThreadLocalAccessor类不释放嵌套的SpanAction类实例；添加ThreadLocalAccessor接口，使用Reactor来传播Baggage接口的实例。1.2.0-M3版本有一个新特性，即允许在span上设置事件的时间戳。要了解关于这些版本的更多细节，请查看<a href=\"https://github.com/micrometer-metrics/tracing/releases/tag/v1.2.0-M3\">1.2.0-M3</a>\"、<a href=\"https://github.com/micrometer-metrics/tracing/releases/tag/v1.1.5\">1.1.5</a>\"和<a href=\"https://github.com/micrometer-metrics/tracing/releases/tag/v1.0.10\">1.0.10</a>\"版本的发布说明。</p><p>&nbsp;</p><p></p><h4>Piranha</h4><p></p><p><a href=\"https://piranha.cloud/\">Piranha</a>\" 23.9.0<a href=\"https://github.com/piranhacloud/piranha/releases/tag/v23.9.0\">发布</a>\"，带来了一些值得注意的变化，其中包括：新增PidFeature类，改进进程ID的处理；修复了<a href=\"https://www.sonarsource.com/products/sonarcloud/\">SonarCloud</a>\"的一个测试问题；新增IsolatedWebAppFeature类，改进对Web应用程序的处理。要了解关于该版本的更多细节，请查看<a href=\"https://javadoc.io/doc/cloud.piranha/project/latest/index.html\">官方文档</a>\"和<a href=\"https://github.com/piranhacloud/piranha/issues?q=is%3Aissue+-label%3Awontfix+milestone%3A23.9.0+is%3Aclosed\">问题跟踪系统</a>\"。</p><p>&nbsp;</p><p></p><h4>JobRunr</h4><p></p><p><a href=\"https://www.jobrunr.io/\">JobRunr</a>\" 6.3.1发布。这是一个基于持久化存储的分布式Java后台处理库。该版本有一些显著的变化：如果quarkus.jobrunr.job-scheduler.enabled属性设置为false，则Quarkus扩展会抛出NullPointerException；添加缺失的Spring AOT提示，提示缺失会导致使用JobRunr 6.3.0和Spring Boot 3.1.3的应用程序异常；在升级到Spring Boot 3.1.2和JobRunr 6.3.0之后，@Job注解不注册JobFilter接口的实例。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/jobrunr/jobrunr/releases/tag/v6.3.1\">发布说明</a>\"。</p><p>&nbsp;</p><p></p><h4>JHipster</h4><p></p><p><a href=\"https://www.jhipster.tech/jhipster-lite/\">JHipster Lite</a>\" 0.42.0<a href=\"https://twitter.com/pascalgrimaud/status/1702250519589179500\">发布</a>\"，其中包括Bug修复、依赖项升级和新特性/增强，诸如：新增StatisticsCriteria类，用于向/stats端点添加标准；删除不必要的TestNG依赖；新增checkstyle模块，用于在构建期间检查未使用的导入。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/jhipster/jhipster-lite/releases/tag/v0.42.0\">发布说明</a>\"。</p><p>&nbsp;</p><p></p><h4>Reactor项目</h4><p></p><p><a href=\"https://github.com/reactor/reactor/blob/main/README.md\">Reactor</a>\" 2023.0.0的<a href=\"https://github.com/reactor/reactor/releases/tag/2023.0.0-M3\">第三个里程碑版本</a>\"升级了依赖项，包括：reactor-core 3.6.0-M3、reactor-pool 1.0.2、reactor-netty 1.1.11和reactor-kafka 1.3.21。此外，2023.0.0-M3版本也进行了调整，其中reactor-addons 3.5.1和reactor-kotlin-extensions 1.2.2构件保持不变。要了解关于这个版本的更多细节，请查看<a href=\"https://github.com/reactor/reactor/compare/2023.0.0-M2...2023.0.0-M3\">变更日志</a>\"。</p><p>&nbsp;</p><p>同样，<a href=\"https://github.com/reactor/reactor/releases/tag/2022.0.11\">第11个维护版本</a>\"Reactor 2022.0.11也升级了依赖项，包括：reactor-core 3.5.10、&nbsp;reactor-netty 1.1.11、&nbsp;reactor-kafka 1.3.21&nbsp;和reactor-pool 1.0.2。2022.0.11版本也进行了调整，其中reactor-addons 3.5.1&nbsp;和reactor-kotlin-extensions 1.2.2构件保持不变。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/reactor/reactor/compare/2022.0.10...2022.0.11\">变更日志</a>\"。</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/09/java-news-roundup-sep11-2023/\">https://www.infoq.com/news/2023/09/java-news-roundup-sep11-2023/</a>\"</p>",
    "publish_time": "2023-10-06 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]