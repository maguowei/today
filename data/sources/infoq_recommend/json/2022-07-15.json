[
  {
    "title": "Java中的面向数据编程",
    "url": "https://www.infoq.cn/article/e0cVtyDv3LwKAvJ3076N",
    "summary": "<p>近年来，<a href=\"https://openjdk.java.net/projects/amber/\">Amber</a>\"项目为Java带来了许多新特性——<a href=\"https://www.infoq.com/articles/java-local-variable-type-inference/\">局部变量类型推断</a>\"、<a href=\"https://www.infoq.com/articles/java-text-blocks/\">文本块</a>\"、<a href=\"https://www.infoq.com/articles/java-14-feature-spotlight/\">记录类</a>\"、<a href=\"https://www.infoq.com/articles/java-sealed-classes/\">封印类</a>\"、<a href=\"https://www.infoq.com/articles/java-pattern-matching/\">模式匹配</a>\"等等。虽然这些特性都是独立的，但也可以组合在一起使用。具体地说，记录类、封印类和模式匹配组合在一起让Java的面向数据编程变得更容易。在本文中，我们将讨论什么是面向数据编程，以及它如何影响Java的编程方式。</p><p></p><h2>面向对象编程</h2><p></p><p>任何一种编程范式的目标都是管理复杂性。但复杂性会以多种形式出现，并不是所有的范式都能同等处理好所有形式的复杂性。大多数编程范式都有一个口号：“一切皆……”面向对象编程的口号是“一切皆对象”，函数式编程的口号是“一切皆函数”，基于Actor的系统的口号是“一切皆Actor”等等。（当然，这些都是为了达到某种效果而夸大的说法。）</p><p></p><p>OOP鼓励我们使用定义了状态和行为的对象对复杂的实体和过程进行建模。OOP鼓励封装性（协调对对象状态的访问）和多态性（使用公共接口与多种实体交互），尽管实现这些目标的机制因面向对象编程语言而异。当我们用对象对世界进行建模时，我们被鼓励按照is-a（储蓄帐户是一个银行帐户）和has-a（储蓄帐户有一个所有者和账号）的关系来思考问题。</p><p></p><p>虽然一些开发者大声宣告面向对象编程是一次失败的试验，但事实却很微妙。与其他所有的工具一样，它非常适合用来做一些事情，但也不太适合用来做另一些事情。OOP做不好的事情可能可以用糟糕来形容，许多人都曾见过被运用得荒谬至极的OOP原则。但是，如果我们了解OOP的优点和缺点，就可以在它提供更多价值的地方使用它，在它提供较少价值的地方使用其他语言。</p><p></p><p>OOP在定义和保持边界方面做得很出色——维护的边界、版本控制的边界、封装的边界、编译的边界、兼容性的边界、安全性的边界，等等。独立维护的库独立于依赖它们的应用程序（以及库彼此之间）而构建、维护和演化，如果我们希望能够自由地从库的一个版本迁移到下一个版本，就需要确保库和它们的客户端之间有清晰的、定义良好的和深思熟虑的边界。平台库可能有访问底层操作系统和硬件的特权，这些权限必须加以小心的控制。我们需要在平台库和应用程序之间建立一个牢固的边界来保持系统的完整性。OO语言为我们提供了精确定义和保持这些边界的工具。</p><p></p><p>将一个大程序划分为具有明确边界的部分，有助于我们管理复杂性，因为它支持模块化推理——一次只分析程序的一部分，但仍然具备对整个程序进行推理的能力。对于单体程序来说，设置合理的内部边界有助于我们构建跨多个团队的更大的应用程序。Java在单体时代兴盛并非偶然。</p><p></p><p>从那时起，程序变得越来越小，我们不再构建大单体，而是将许多较小的服务组合成较大的应用程序。在小型服务中，对内部边界的需求较少，足够小的服务可以由单个团队（甚至一个开发人员）维护。类似地，在这些较小的服务中，我们对长时间运行的有状态流程进行建模的需求也较少。</p><p></p><h2>面向数据编程</h2><p></p><p>Java的强静态类型和基于类的模型对于较小的程序仍然非常有用，只是发挥作用的方式不同。OOP鼓励我们使用类对业务实体和流程进行建模，而具有更少内部边界的小代码库通常会从使用类来建模数据的方式中获得更多好处。我们的服务负责处理来自外部的请求，例如带有非类型化JSON/XML/YAML有效载荷的HTTP请求。但是，只有最简单的服务才会直接使用这种数据。我们希望数字能够被表示成int或long，而不是数字字符串，日期被表示成像LocalDateTime这样的类，列表被表示成集合，而不是用逗号分隔的长字符串。(并且，在处理数据之前，我们希望在边界上对数据进行验证。)</p><p></p><p>面向数据编程鼓励我们将数据建模为不可变数据，并单独保留包含操作数据的业务逻辑代码。随着小型程序趋势的发展，Java提供了新的工具，可以更容易地将数据建模为数据（记录），直接建模替代实体（封印类），以及灵活地分解多态数据模式（模式匹配）。</p><p></p><p></p><blockquote>面向数据编程鼓励我们将数据建模为不可变数据，而记录类、封印类和模式匹配使这方面的工作变得更容易。但这并不意味着要放弃静态类型。我们可以只使用非类型化的Map和List进行面向数据编程（通常在JavaScript等编程语言中这样做的），但静态类型在安全性、可读性和可维护性方面仍然提供了很多东西，即使我们只对普通数据建模。（无原则的面向数据编程通常被称为“字符串类型”，因为它使用字符串来建模不应该被建模为字符串的东西，如数字、日期和列表。）</blockquote><p></p><p></p><h2>Java中的面向数据编程</h2><p></p><p>记录类、封印类和模式匹配可以组合在一起支持面向数据编程。我们可以用记录类来进行简单的数据建模，用封印类来进行选择建模，模式匹配为我们提供了一种简单且类型安全的方式来处理多态数据。对模式匹配的支持是逐步实现的，第一个迭代只添加了类型测试模式，并且只能在instanceof中使用，第二次迭代支持switch中的类型测试模式，最近，Java 19中添加了<a href=\"https://openjdk.java.net/jeps/405\">记录类的解构模式</a>\"。本文中的示例将使用所有这些特性。</p><p></p><p>虽然记录类的语法比较简洁，但它们的主要优点是我们可以干净而简单地对聚合进行建模。与其他的数据建模一样，我们都需要做出创造性的决策，总有一些建模方式比其他的更好。组合使用记录类和封印类还更容易让非法状态变得无法表示，从而进一步提高安全性和可维护性。</p><p></p><h2>示例：命令行选项</h2><p></p><p>作为第一个例子，我们来看一下如何对命令行程序的选项进行建模。有些选项有参数，有些没有。有些参数可以是任意字符串，有些是更结构化的格式，如数字或日期。在处理命令行选项时，我们必须在程序执行的早期拒绝错误的选项和格式错误的参数。一种快速而粗暴的方法是循环遍历命令行参数，对于遇到的每一个选项，将它们存在或不存在的状态以及选项的参数保存在变量中。这很简单，但问题在于我们的程序依赖了一组字符串类型的全局变量。如果我们的程序很小，这可能没有问题，但它的伸缩性不是很好。随着程序的增长，这不仅会降低可维护性，也会降低程序的可测试性——我们只能通过命令行来测试整个程序。</p><p></p><p>一种不那么快速和复杂的方法是创建一个表示命令行选项的类，然后将命令行解析为选项对象列表。假设我们有一个类似cat的程序，它可以将一个或多个文件中的行复制到另一个文件中，将文件裁剪到特定的行数，并选择性地包含行号，我们可以使用enum和Option类对这些选项进行建模：</p><p></p><p><code lang=\"java\">enum MyOptions { INPUT_FILE, OUTPUT_FILE, MAX_LINES, PRINT_LINE_NUMBERS }\nrecord OptionValue(MyOptions option, String optionValue) { }\nstatic List parseOptions(String[] args) { ... }\n</code></p><p></p><p>这是对前一种方法的改进，至少现在在命令行选项的解析和使用之间有了清晰的分离，这意味着我们可以通过向命令行shell提供选项列表来测试业务逻辑。但这仍然不够好，有些选项是没有参数的，但我们从选项的enum中看不出这一点，我们仍然需要用一个带有optionValue字段的OptionValue对象。而有参数的选项总是字符串类型。</p><p></p><p>更好的方法是直接对每个选项进行建模。在以前，这么做可能会很冗长，但幸运的是，现在已经不是这样了。我们可以使用一个封印类来表示一个选项，并且每个选项都有一个记录类：</p><p></p><p><code lang=\"java\">sealed interface Option { \n    record InputFile(Path path) implements Option { }\n    record OutputFile(Path path) implements Option { }\n    record MaxLines(int maxLines) implements Option { }\n    record PrintLineNumbers() implements Option { }\n}\n</code></p><p></p><p>Option的子类是纯数据。选项的值有漂亮干净的名称和类型，有参数的选项使用了适当的类型来表示参数，没有参数的选项不需要使用可能会被错误解释的无用参数变量。此外，使用模式匹配switch处理选项变得很容易（通常每个选项需要一行代码）。因为Option是封印类，所以编译器会进行类型检查，一个switch可以处理所有的选项类型。（如果以后添加更多的选项类型，编译器会提醒我们哪些switch需要扩展。)</p><p></p><p>我们可能都写过与上述两个版本类似的代码，尽管我们可能知道的更多。如果无法清晰、简洁地对数据进行建模，要“正确”实现这个目标通常需要做很多的工作（或写很多的代码）。</p><p></p><p>我们所做的是将来自调用边界（命令行参数）混乱、无类型的数据转换为强类型的、经过验证的、容易操作的（通过模式匹配）数据，并让非法状态（例如指定--input-file，而不是提供有效路径）变得不可表示。程序的其余部分可以安全地使用它。</p><p></p><h2>代数数据类型</h2><p></p><p>这种组合使用记录类和封印类型就是代数数据类型（ADT）的一个例子。记录类是“乘积类型”的一种形式，之所以这么说，是因为它们的状态空间是它们组件状态空间的笛卡尔乘积。封印类是“和类型”的一种形式，之所以这么说，是因为值的集合是备选值集合的和（并集）。这种简单的机制组合（聚合和选择）比看上去的更加强大，在许多编程语言中都有出现。（我们的例子仅限于一个层级，但这并不一定是一般的情况。一个封印接口的子类型也可以是另一个封印接口，可以对更复杂的结构进行建模。）</p><p></p><p>在Java中，代数数据类型可以被精确地建模成封印的层次结构，其叶子是记录类。在解释代数数据类型方面，Java具有许多理想的属性。它们具有名词性质，类型和组件具有人类可读的名称。它们是不可变的，因此它们更简单、更安全，并且可以自由共享，而不用担心受到干扰。它们很容易测试，因为它们只包含数据（可能附带一些从数据派生出来的行为）。我们可以很容易地将它们序列化到磁盘或通过网络传输。它们具有很强的表现力，可在广泛的数据领域中建模。</p><p></p><h2>应用：复杂的返回类型</h2><p></p><p>复杂返回类型是代数数据类型最简单但最常用的应用之一。由于一个方法只能返回一个值，我们总是喜欢通过复杂的方式来表示返回值，例如使用null表示“Not Found”，将多个值编码成一个字符串，或用一个抽象的类型（数组、List或Map）将方法返回的所有不同类型的信息填充到单个载体对象中。代数数据类型可以很容易地实现这些目的，让之前的这些方法变得不那么诱人。</p><p></p><p>我们给出了一个例子，说明如何使用封印类在不使用异常的情况下抽象成功和失败条件：</p><p></p><p><code lang=\"java\">sealed interface AsyncReturn {\n    record Success(V result) implements AsyncReturn { }\n    record Failure(Throwable cause) implements AsyncReturn { }\n    record Timeout() implements AsyncReturn { }\n    record Interrupted() implements AsyncReturn { }\n}\n</code></p><p></p><p>这种方法的优点是，客户端可以通过对结果进行模式匹配来统一处理成功和失败，而不是当有返回值时表示调用成功，当catch块捕捉到异常时表示调用失败：</p><p></p><p><code lang=\"java\">AsyncResult r = future.get();\nswitch (r) {\n    case Success(var result): ...\n    case Failure(Throwable cause): ...\n    case Timeout(): ...\n    case Interrupted(): ...\n}\n</code></p><p></p><p>封印类的另一个好处是，如果switch中没有default，编译器会提醒你是否忘记了一个case。（在有检查异常时，编译器也会提醒你，但以一种更具有侵入性的方式。）</p><p></p><p>另一个例子，假设我们有一个服务，它根据名称查找实体（用户、文档、组等），结果分别是“未找到匹配项”、“找到精确匹配项”和“没有找到精确匹配项，但有接近匹配项”。我们可以考虑将它们塞进一个列表或数组，虽然这样可能更容易编写搜索API，但却难以理解、使用或测试。代数数据类型很容易就可以解决这个问题。我们可以编写一个简洁的API来准确表达我们的意图：</p><p></p><p><code lang=\"java\">sealed interface MatchResult { \n    record NoMatch() implements MatchResult { }\n    record ExactMatch(T entity) implements MatchResult { }\n    record FuzzyMatches(Collection&gt; entities) \n        implements MatchResult { }\n\n    record FuzzyMatch(T entity, int distance) { }\n}\n\nMatchResult findUser(String userName) { ... }\n</code></p><p></p><p>如果我们在浏览代码或JavaDoc时遇到这个层次结构，我们会很容易知道这个方法可能返回的是什么，以及如何处理它的结果：</p><p></p><p><code lang=\"java\">Page userSearch(String user) { \n    return switch (findUser(user)) { \n        case NoMatch() -&gt; noMatchPage(user);\n        case ExactMatch(var u) -&gt; userPage(u);\n        case FuzzyMatches(var ms) -&gt; disambiguationPage(ms.stream()\n                                                          .sorted(FuzzyMatch::distance))\n                                                          .limit(MAX_MATCHES)\n                                                          .toList());\n}\n</code></p><p></p><p>这种清晰的返回值提升了API的可读性和易用性，也更容易编写，因为代码实际上是根据需求编写的。与之相反的是，试图想出（和记录）“聪明”的编码，将复杂的结果塞进像数组或Map这样的抽象载体中需要做更多的工作。</p><p></p><h2>应用：临时的数据结构</h2><p></p><p>代数数据类型对于建模临时通用的数据结构来说也很有用。常用的Optional类可以被建模为代数数据类型：</p><p></p><p><code lang=\"java\">sealed interface Opt { \n    record Some(T value) implements Opt { }\n    record None() implements Opt { }\n}\n</code></p><p></p><p>（这实际上是大多数函数式语言对Optional的定义方式。）针对Opt的常见操作可以通过模式匹配来实现：</p><p></p><p><code lang=\"java\">static Opt<u> map(Opt opt, Function mapper) { \n    return switch (opt) { \n        case Some(var v) -&gt; new Some&lt;&gt;(mapper.apply(v));\n        case None() -&gt; new None&lt;&gt;();\n    }\n}\n</u></code></p><p></p><p><u>类似地，二叉树可以这样表示：</u></p><p></p><p><u><code lang=\"java\">sealed interface Tree { \n    record Nil() implements Tree { }\n    record Node(Tree left, T val, Tree right) implements Tree { }\n}\n</code></u></p><p></p><p><u>我们可以通过模式匹配实现通常的操作：</u></p><p></p><p><u><code lang=\"java\">static boolean contains(Tree tree, T target) { \n    return switch (tree) { \n        case Nil() -&gt; false;\n        case Node(var left, var val, var right) -&gt; \n            target.equals(val) || left.contains(target) || right.contains(target);\n    };\n}\n\nstatic void inorder(Tree t, Consumer c) { \n    switch (tree) { \n        case Nil(): break;\n        case Node(var left, var val, var right):\n            inorder(left, c);\n            c.accept(val);\n            inorder(right, c);\n    };\n}\n</code></u></p><p></p><p><u>像遍历这样的常见行为“显然”应该作为接口的抽象方法，将它写成静态方法似乎有些奇怪。的确，将一些方法放到接口中是没有问题的。但记录类、封印类和模式匹配的组合为我们提供了新的选择。我们可以用老方法实现它们（将抽象方法放在基类中，在子类中实现具体的方法），也可以作为抽象类的默认方法在一个地方实现模式匹配，也可以实现为静态方法，或者（如果不需要递归）在使用的地方进行临时内联遍历。</u></p><p></p><p><u>因为数据结构是专门为这种情况而设计的，我们可以选择是否将行为与数据放在一起。这种方法与OO并不矛盾，它是我们的工具箱的一个有用的补充，让我们可以根据实际需要与OO一起使用。</u></p><p></p><h2><u>示例：JSON</u></h2><p></p><p><u>如果你仔细看过<a href=\"https://docs.oracle.com/javaee/7/api/javax/json/JsonValue.html\">JSON规范</a>\"，你会发现JSON也是一个ADT：</u></p><p></p><p><u><code lang=\"java\">sealed interface JsonValue { \n    record JsonString(String s) implements JsonValue { }\n    record JsonNumber(double d) implements JsonValue { }\n    record JsonNull() implements JsonValue { }\n    record JsonBoolean(boolean b) implements JsonValue { }\n    record JsonArray(List values) implements JsonValue { }\n    record JsonObject(Map pairs) implements JsonValue { }\n}\n</code></u></p><p></p><p><u>如果使用了这种表示，从JSON中提取相关信息的代码就会非常简单。如果我们想匹配JSON {\"name\":\"John\", \"age\":30, \"city\":\"New York\"}就是：</u></p><p></p><p><u><code lang=\"java\">if (j instanceof JsonObject(var pairs)\n    &amp;&amp; pairs.get(\"name\") instanceof JsonString(String name)\n    &amp;&amp; pairs.get(\"age\") instanceof JsonNumber(double age)\n    &amp;&amp; pairs.get(\"city\") instanceof JsonString(String city)) { \n    // 使用name、age、city\n}\n</code></u></p><p></p><p><u>当我们将数据建模为不可变数据，创建聚合和提取内容（或将其重新打包为另一种形式）就变得很简单，而且由于当某些内容不匹配时模式匹配会优雅地失败，分解这个JSON的代码相对来说就没有复杂的控制流程。（虽然我们可能倾向于使用比这个示例更具有工业强度的JSON库，但实际上我们只需要额外的几十行解析代码就可以实现一个解析工具，不仅遵循JSON规范中列出的词法规则，而且可以将它们转换为JsonValue。）</u></p><p></p><h2><u>更加复杂的领域</u></h2><p></p><p><u>到目前为止，我们看到的例子要么是跨整个调用边界使用返回值，要么是建模通用领域（如列表和树结构）。但其实同样的方法对于更复杂的应用程序特定领域也很有用。如果我们想要对一个算术表达式进行建模，可以这样做：</u></p><p></p><p><u><code lang=\"java\">sealed interface Node { }\nsealed interface BinaryNode extends Node { \n    Node left();\n    Node right();\n}\n\nrecord AddNode(Node left, Node right) implements BinaryNode { }\nrecord MulNode(Node left, Node right) implements BinaryNode { }\nrecord ExpNode(Node left, int exp) implements Node { }\nrecord NegNode(Node node) implements Node { }\nrecord ConstNode(double val) implements Node { }\nrecord VarNode(String name) implements Node { }\n</code></u></p><p></p><p><u>有了抽象了加法和乘法的封印接口BinaryNode，我们在匹配Node时就有了更多选择。我们可以通过匹配BinaryNode来同时处理加法和乘法，或者根据情况分别处理它们。语言本身仍然会确保我们涵盖了所有的情况。</u></p><p></p><p><u>为这些表达式编写求值器很简单。由于表达式中有变量，我们需要存储它们，并将其传给求值器：</u></p><p></p><p><u><code lang=\"java\">double eval(Node n, Function vars) { \n    return switch (n) { \n        case AddNode(var left, var right) -&gt; eval(left, vars) + eval(right, vars);\n        case MulNode(var left, var right) -&gt; eval(left, vars) * eval(right, vars);\n        case ExpNode(var node, int exp) -&gt; Math.exp(eval(node, vars), exp);\n        case NegNode(var node) -&gt; -eval(node, vars);\n        case ConstNode(double val) -&gt; val;\n        case VarNode(String name) -&gt; vars.apply(name);\n    }\n}\n</code></u></p><p></p><p><u>定义终端节点的记录类实现了toString，但输出可能比我们想要的更详细。我们可以编写一个格式化器来生成看起来更像数学表达式的输出：</u></p><p></p><p><u><code lang=\"java\">String format(Node n) { \n    return switch (n) { \n        case AddNode(var left, var right) -&gt; String.format(\"(\"%s + %s)\", \n                                                           format(left), format(right));\n        case MulNode(var left, var right) -&gt; String.format(\"(\"%s * %s)\", \n                                                           format(left), format(right));\n        case ExpNode(var node, int exp) -&gt; String.format(\"%s^%d\", format(node), exp);\n        case NegNode(var node) -&gt; String.format(\"-%s\", format(node));\n        case ConstNode(double val) -&gt; Double.toString(val);\n        case VarNode(String name) -&gt; name;\n    }\n}\n</code></u></p><p></p><p><u>和以前一样，我们可以将它们作为静态方法，或作为基类的实例方法，但只提供一个实现，或作为普通的实例方法——我们可以自由选择对领域来说最具可读性的方法。</u></p><p></p><p><u>在抽象地定义了领域之后，我们还可以轻松地添加其他操作。我们可以很容易地对单个变量进行符号微分：</u></p><p></p><p><u><code lang=\"java\">Node diff(Node n, String v) { \n    return switch (n) { \n        case AddNode(var left, var right) \n            -&gt; new AddNode(diff(left, v), diff(right, v)); \n        case MulNode(var left, var right) \n            -&gt; new AddNode(new MulNode(left, diff(right, v)), \n                           new MulNode(diff(left, v), right))); \n        case ExpNode(var node, int exp) \n            -&gt; new MulNode(new ConstNode(exp), \n                           new MulNode(new ExpNode(node, exp-1), \n                                       diff(node, v)));\n        case NegNode(var node) -&gt; new NegNode(diff(node, var));\n        case ConstNode(double val) -&gt; new ConstNode(0);\n        case VarNode(String name) -&gt; name.equals(v) ? new ConstNode(1) : new ConstNode(0);\n    }\n}\n</code></u></p><p></p><p><u>在记录类和模式匹配出现之前，编写这种代码的标准方法是访问者模式。模式匹配显然比访问者模式更简洁，也更灵活和强大。访问者模式需要为访问构建领域，并添加严格的约束。模式匹配支持更多的临时多态。最关键的是，模式匹配具有更好的可组合性，我们可以使用嵌套模式来表达复杂的条件，而这在使用访问者模式时要复杂得多。例如，当一个乘法节点的一个子节点是常数时，上面的代码将生成混乱的树结构。我们可以使用嵌套模式更容易地处理这些特殊情况：</u></p><p></p><p><u><code lang=\"java\">Node diff(Node n, String v) { \n    return switch (n) { \n        case AddNode(var left, var right) \n            -&gt; new AddNode(diff(left, v), diff(right, v)); \n        // k*node或node*k等特殊情况\n        case MulNode(var left, ConstNode(double val) k) \n            -&gt; new MulNode(k, diff(left, v));\n        case MulNode(ConstNode(double val) k, var right) \n            -&gt; new MulNode(k, diff(right, v));\n        case MulNode(var left, var right) \n            -&gt; new AddNode(new MulNode(left, diff(right, v)), \n                           new MulNode(diff(left, v), right))); \n        case ExpNode(var node, int exp) \n            -&gt; new MulNode(new ConstNode(exp), \n                           new MulNode(new ExpNode(node, exp-1), \n                                       diff(node, v)));\n        case NegNode(var node) -&gt; new NegNode(diff(node, var));\n        case ConstNode(double val) -&gt; new ConstNode(0);\n        case VarNode(String name) -&gt; name.equals(v) ? new ConstNode(1) : new ConstNode(0);\n    }\n}\n</code></u></p><p></p><p><u>如果使用访问者模式——尤其是在多个层次的嵌套中——很快就会变得相当混乱和容易出错。</u></p><p></p><h2><u>这不是一种或的关系</u></h2><p></p><p><u>这里阐述的许多想法可能看起来有点“不像Java”，因为我们大多数人都被教导将实体和过程建模成对象。但在现实中，我们的程序通常使用相对简单的数据，这些数据通常来自“外部世界”，我们不能指望它完全与Java的类型系统相匹配。（在我们的JSON示例中，我们将数字建模为双精度值，但实际上JSON规范对数值范围并没有特别说明，系统边界的代码将不得不做出决定是否截断或拒绝难以表示的数值。）</u></p><p></p><p><u>当我们在建模复杂的实体或编写像java.util.stream这样的库时，OO技术为我们提供了很多东西。但是，当我们在构建处理普通数据的简单服务时，面向数据编程技术可能会为我们提供一条更直接的路径。类似地，在跨API边界交换复杂的结果时（例如我们的匹配结果示例），使用ADT定义一个特别的数据模式通常比将结果和行为交织成一个有状态的对象更加简单和清晰（Java Matcher API就是这样做的）。</u></p><p></p><p><u>OOP和面向数据编程技术并不矛盾，它们分别针对不同的粒度和场景。我们可以根据具体情况随意混合搭配。</u></p><p></p><h2><u>跟随数据</u></h2><p></p><p><u>无论是建模一个简单的返回值，还是一个更复杂的领域（如JSON或我们的表达式树），都有一些简单的原则可以让我们得到简单、可靠的面向数据的代码。</u></p><p></p><p><u>只对数据建模。使用记录类对数据进行建模，每个记录类只建模一项内容，明确每个记录类的内容，并为组件选择明确的名字。如果存在多个选项，比如“纳税申报单要么由纳税人提交，要么由法人代表提交”，将这些选项建模为封印类，并将每个选项建模为一个记录类。记录类的行为应该仅限于从数据本身实现派生量，比如格式化。数据是不可变的。如果我们想要对数据建模，就不应该担心数据会发生变化。记录类为我们提供了一些帮助，因为它们是不可变的，但仍然需要一些规则来避免让可变性注入到我们的数据模型中。在边界处验证数据。在将数据注入系统之前，我们需要确保它们是有效的。这可以在记录类的构造函数中完成（如果验证逻辑被应用在所有的实例上），或者通过从另一个数据源接收数据的边界代码来完成。让非法状态无法被表示。记录类和封印类让错误的状态无法被表示出来。这比一直要检查数据有效性要好得多！就像不变性消除了程序中许多常见的错误来源一样，避免对无效数据进行建模也起到了类似的作用。这种方法的一个潜在好处是可测试性。当代码的输入和输出是简单且定义良好的数据时，不仅测试代码很容易，而且为生成式测试（通常可以比手动编写测试用例更有效地发现Bug）打开了大门。</u></p><p></p><p><u>记录类、封印类和模式匹配的组合使得遵循这些原则变得更加容易，从而获得更简洁、可读和可靠的程序。考虑到Java面向对象编程根深蒂固的基础，面向数据编程可能有点陌生，但这些技术非常值得被添加到我们的工具箱中。</u></p><p></p><p><u>原文链接：</u></p><p></p><p><u><a href=\"https://www.infoq.com/articles/data-oriented-programming-java/\">Data Oriented Programming in Java</a>\"</u></p>",
    "publish_time": "2022-07-15 08:59:07",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "是时候开始培养无代码开发人员了",
    "url": "https://www.infoq.cn/article/J3kf7kFFke7irqkNP3HH",
    "summary": "<p>现如今，公司商业应用程序的数量和种类多到让人无所适从，举例来说，一家中等规模的公司就有800多个。虽然很多人喜欢将这说成是SaaS失控的一个案例，但这并不是真正的问题所在。真正的问题是，这些应用程序中的大多数现如今都是由非开发人员管理的。</p><p>&nbsp;</p><p>我所说的开发人员并不是指会编码的人。我认为，不一定非要会编码才能成为一名开发人员。更重要的是像工程师一样思考。当一家企业的CRM、HCM、ERP、LMS、MAP以及几十甚至几百个第三方应用程序，被那些没有接受过训练、不会像开发人员那样思考的人修改、构建和管理时，他们所追求的短期结果会导致长期的灾难。</p><p>&nbsp;</p><p>在这篇文章中，我将说明一下，为什么我认为2022年适合这些公司迎头赶上，开始培训并推动人们转型为商业应用无代码开发人员。</p><p></p><h1>没有工程师会导致技术债务瘫痪</h1><p></p><p>我所接触的很多中大型公司都会遇到一个简单的问题：管理员想取消商业应用程序中的一个字段，那可能是Salesforce、NetSuite或Zendesk。他们怀疑没有什么地方使用这个字段。他们没有看到任何活动，如果能把它清理掉就好了。但是，他们无法确定。他们以前试过，这个字段对他们的一个公式来说至关重要，这个公式出问题会导致业务部门的部分仪表板失效，因为担心这个，所以他们没有采取任何行动。Salto首席执行官Rami Tamir称这是<a href=\"https://www.salto.io/blog/business-applications-are-a-product-you-are-an-engineer-and-this-is-your-call-to-action\">技术债务瘫痪</a>\"。放大到企业范围，这是一个严重的问题。</p><p>&nbsp;</p><p>比如说，销售团队想改变选单上的选项，但CRM团队花了一个季度的时间才弄明白，而在这一个季度里，有不少交易被误导了。或者，董事会决定进行IPO，但却意识到，无法使他们混乱的NetSuite实例及时符合SOX标准。或者，营销团队想要加强电子邮件活动来解决潜在客户短缺的问题，但商业应用程序团队却需要6个月的时间来移植这些部分。</p><p>&nbsp;</p><p>这些问题会以各种方式表现出来。考虑下我从客户那里听到的这三个真实的例子。</p><p>&nbsp;</p><p>一家国际化SaaS公司使用了NetSuite ERP。在他们财年的最后一天，许多关键的报表突然停止了工作，他们无法结束这个季度。整个团队争分夺秒，但直到深夜才发现，有人在生产中改变了一些“保存的搜索”，却不知道他们的实现中有其他关键的部分在使用。</p><p>&nbsp;</p><p>一家大型零售商使用Zendesk作为客户支持系统。一名管理员直接在生产环境中定义触发器时犯了一个小错误，向几十万不知情的客户发了一封令人困惑的电子邮件，然后变成了大量新的工单。</p><p>&nbsp;</p><p>一家大型的公共SaaS公司无法弄清楚为什么它的销售线索转化率出现大幅下降。经过几个月的分析，该公司终于发现，由于Salesforce中有一个工作流卡住了但未被检测到，所以就没有把某项活动的线索分配给销售代表。这些线索就这样搁置在那里，无人问津。</p><p>&nbsp;</p><p>所有这些问题都会对资产负债表产生实实在在的影响。它们使企业的竞争力下降。随着这些问题的复杂化，企业的发展速度会越来越慢，而那些规模相对较小的、灵活的竞争对手将悄悄地赶超他们。无论企业在允许每个业务部门选择自己的系统以快速行动方面做了什么权衡，最终都会为错误和失误所扼杀。而这一切主要都是因为这些系统不是在受过培训的开发人员的指导下开发的。</p><p></p><h1>开发人员是汲取了六十年智慧的人</h1><p></p><p>如果公司希望他们的商业系统在其发展过程中保持正常运行，就需要解决两个问题。第一个是关注软件开发领域，并以良好的实践为指导，比如<a href=\"https://www.salto.io/blog/bridging-the-gap-bringing-software-development-methods-to-bizapps-part-3\">组织中使用的DevOps和敏捷开发方法</a>\"。</p><p>&nbsp;</p><p>近60年来，软件开发人员一直在处理与如今的商业应用经理类似的问题：他们需要一种方法，让许多远程团队协同构建一个高度分布式的系统。这需要通过质量检查来确保没有漏洞，需要预生产环境来确保测试不会导致什么后果，需要版本控制来维护应用程序的多个版本，以防出现问题。</p><p>&nbsp;</p><p>如果开发人员专门负责商业应用，他们就会把这些习惯和工具带入这个过程。他们会从可重用性、关注点分离和弹性的角度来思考问题，会使用类似于Git这样的工具来管理分叉、分支、合并和提交修改，允许多人协作并减少人为错误。也许最重要的是有整体思维。</p><p>&nbsp;</p><p>如今，大多数管理商业应用的团队都处于孤岛之中。你有CRM团队，财务应用团队，还有各种形式的“公民开发者”购买和管理的SaaS，每个人都在努力减轻自己团队的工作。这些系统中的大多数都大到足以成为自己的生态系统，并包含许多产品。它们也会集成并分享数据。深谙软件开发方法和原则的人，对这个问题的看法与如今大多数人的看法大不相同：这不是将800多个产品集成在一起。它们是一个产品——公司的操作系统——新增的任何产品在构建和管理时都需要考虑整体的完整性。</p><p>&nbsp;</p><p>而这只是第一个问题。第二个问题是：许多商业应用的构建也不是为了让那些具有开发思维的人去管理。</p><p>&nbsp;</p><p>也就是说，大多数商业系统的构建都考虑到了用户的成长。构建的系统界面是为了让终端用户能够完成工作，而不是让管理员把一切都安排好。此外，如果从应用程序生命周期发展的角度考虑，构建只是为了解决第一步的问题。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/59/59ba18d6e3423537c340921ad6bc88ab.png\" /></p><p></p><p><a href=\"https://pages.salto.io/hubfs/Other/Salto%20Forbes%20No%20Code%20Interfaces%202.jpg\">图片来源</a>\"</p><p>&nbsp;</p><p>也就是说，它们没有提供原生功能，让你可以做开发人员可能会想做的事，如版本管理、搜索整个代码库的能力、管理多个环境的能力，以及在某些情况下，将变更从沙盒推送到生产环境的基本能力。现在，有些应用提供“开发”环境，但很少能提供你所需要的一切。</p><p>&nbsp;</p><p>值得庆幸的是，第二个问题的解决方法就是第一个问题的解决方法：把软件开发人员的知识教给更多的商业系统管理员。经常，开发人员并没有他们需要的所有系统，因此，他们会构建或借用他们需要的东西来完成工作，使用Git工具将他们正在构建的东西抽象成可管理的块，使用工单系统来记录和排定优先级，并在需要时构建自己的工具。</p><p>&nbsp;</p><p>如果商业系统管理员经过培训后开始像开发人员一样思考，那么他们就会开始争取更多这样的功能，我敢打赌，更多的商业系统供应商会构建这些功能。如果他们不这样做，那些新科“开发人员”将像工程师一样，希望能自己构建。</p><p></p><h2>无代码，没问题</h2><p></p><p>还记得之前的那三个真实的案例吗？那些在使用NetSuite、Zendesk和Salesforce时遇到问题的公司？其中每一家都采用了无代码DevOps工具和方法，构建系统防护栏。</p><p>&nbsp;</p><p>这家使用NetSuite的国际化SaaS公司已经为其最重要的配置实现了告警。如果有人对保存的搜索所做的修改会影响结束本季度工作，那么管理员就会收到告警。</p><p>&nbsp;</p><p>使用Zendesk的大型零售商现在禁止管理员直接修改生产环境。相反，他们从DevOps中借鉴了“版本管理”和沙盒的做法——每个管理员在自己的沙盒中开发配置，然后将其移到另一个沙盒中进行整合，再移到另一个沙盒中进行测试，然后才在生产环境中实施。</p><p>&nbsp;</p><p>这家错失销售机会的大型公共SaaS公司现在使用了一个DevOps工具，让它可以查看每个Salesforce组织的完整“蓝图”，并能够进行检查和修改。当有重要的工作流不工作时，他们就可以发现并测试，然后在几天而不是几个月内修复它。</p><p></p><h1>是时候培养无代码开发人员了</h1><p></p><p>如果商业应用世界从过去60年的软件开发思维、框架和方法中吸取了经验，那么你看到的技术债务瘫痪就会少很多。销售和营销团队因运营受阻的情况会更少。公司发展受商业系统阻碍的情况也会更少。</p><p>&nbsp;</p><p>我相信，系统应该和业务同步发展，并支持业务的增长。实现这一目标的唯一途径是增加无代码开发人员。</p><p></p><p>作者简介：</p><p>Gil Hoffer是Salto首席技术官和联合创始人。这是一家软件即服务（SaaS）应用集中式管理工具供应商，帮助业务团队获得商业应用的控制和可见性，其方式类似于DevOps对IT的改革。他曾任甲骨文公司软件开发副总裁和以色列国防军首席技术官。</p><p>&nbsp;</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/growing-nocode-developers/\">It’s Time to Start Growing No-Code Developers</a>\"</p>",
    "publish_time": "2022-07-15 09:09:46",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "RabbitMQ 将在3.11版本中推出“超级流”",
    "url": "https://www.infoq.cn/article/W7ayyUv5Wx1K5csq36CX",
    "summary": "<p>继 3.9 版本引入“流”式数据结构后，RabbitMQ将在 3.11 版本中再次带来一个新功能：超级流（super streams），RabbitMQ官方称之为“历史上最酷名称之一”。超级流是一种通过将大流划分为较小流来进行横向扩展的方法。</p><p>&nbsp;</p><p>超级流是位于流之上的结构，但不是“流”的2.0版本，它使用 RabbitMQ Streams扩展发布和消费，将一个大的逻辑流划分为多个分区流，在多个集群节点上分割存储和流量。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b2/b2f0e2ad85e1f3d1ac0d1de0e0c81dd9.png\" /></p><p></p><p>消息可不经过交换直接进入分区流，但需在客户端库使用拓扑信息来确定将消息路由到哪里以及从哪里使用它们。另外，超级流还可以在消费者处理期间保持分区内消息的顺序。</p><p>&nbsp;</p><p>应用程序发布到超级流的消息必须发送到其中一个分区，应用程序可以选择分区，比较灵活，从而可以避免服务器端的瓶颈。客户端可以实现超级流消费者模式，可同时从超级流的所有分区中消费，还可以启用单个活动消费者，同时通过代理协调以确保给定分区上一次只有一个消费者。</p><p>&nbsp;</p><p>了解更多：</p><p><a href=\"https://blog.rabbitmq.com/posts/2022/07/rabbitmq-3-11-feature-preview-super-streams/\">https://blog.rabbitmq.com/posts/2022/07/rabbitmq-3-11-feature-preview-super-streams/</a>\"</p>",
    "publish_time": "2022-07-15 10:25:40",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]