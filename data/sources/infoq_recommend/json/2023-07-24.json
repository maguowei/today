[
  {
    "title": "“初代”数字孪生巨头，如何把虚拟孪生应用于产品全生命周期管理",
    "url": "https://www.infoq.cn/article/N2gWCU0NhYWjmyxwwy2R",
    "summary": "<p>达索系统（Dassault Systemes）成立于1981年，最初是法国达索宇航（Dassault Aviation，欧洲战斗机三雄之一“阵风”制造商）的信息化部门，1981年从达索宇航分离独立发展。如今，<a href=\"https://www.3ds.com/zh-hans/?utm_campaign=202306_chi_3dxp_dassaultsystemes_zh_CMP2164_gilt&amp;utm_medium=cpc&amp;utm_source=baidu&amp;utm_content=search&amp;utm_term=site-dassault-brand-dassault-dasuoxitong-pc\">达索系统</a>\"已经是全球头部工业软件提供商，主要提供三维体验平台（3DExperience），涵盖设计、仿真、制造、协作、数据智能等解决方案，服务于11大行业，是全球几乎所有飞机制造商的技术服务商，也为全球90%的汽车制造企业提供一体化的解决方案。</p><p></p><p>经过40多年的积淀，达索系统跨越了从三维建模（CAD）、数字样机（DMU）到产品生命周期管理（PLM）再到三维体验平台的技术升级，并且在上世纪末就提出了对产品从设计研发、仿真验证到生产制造、使用维护的全生命周期进行数字化的理念。而在<a href=\"https://xie.infoq.cn/article/dc15615d5d5f0eae10972fb89\">数字孪生</a>\"受关注度持续攀升的今天，达索系统进一步提出了虚拟孪生的概念，强调关注数字化对象的历史演进和对未来发展进行预测。</p><p></p><p>在最新一期的 InfoQ《<a href=\"https://www.infoq.cn/theme/192\">超级连麦. 数智大脑</a>\"》直播中，达索系统技术咨询部业务咨询高级经理杨宠介绍了虚拟孪生的概念及其与数字孪生的异同，同时揭示了虚拟孪生技术在产品全生命周期中具体如何发挥作用，从而帮助企业更好地反馈和优化业务结果，减少成本浪费，实现高质量发展。</p><p></p><p>以下是分享全文（经 InfoQ 进行不改变原意的编辑整理）（点击链接可查看完整<a href=\"https://www.infoq.cn/video/axF9GTTK8NAZpglDfCsb\">直播回放</a>\"）：</p><p></p><h2>虚拟孪生≠数字孪生</h2><p></p><p></p><p>达索系统的企业宗旨是利用我们的软件和产品，去推动企业持续创新，最终实现产品、自然和生命的和谐状态。而这个宗旨的实现与虚拟孪生技术紧密相连。</p><p></p><p>大家可能对数字孪生的概念比较熟悉，根据Gartner的定义，它指的是现实世界实体的数字表达，体现的形式和核心要素是软件对象或者模型镜像。在这基础上，达索在2020年提出了虚拟孪生的概念，它不仅仅是现实世界实体的数字表达，还包含了这个数字化对象的演进历史，比如它从哪里来，如何经过设计、仿真、验证，最终制造出来成为一个实体。除此之外，还包括对它未来的预测，比如这个实体产品在使用过程中如何运作、如何更好地进行维修保养服务等等。</p><p></p><p>换句话说，虚拟孪生涵盖了产品全生命周期的过程。那么，我们为什么要提出这样一个概念呢？</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/55/5550bf06ac9ef5141f00dd5e11afa2c4.png\" /></p><p></p><p>从上图中，我们可以看到，左边是实体在虚拟世界的一个数字镜像，右边是现实世界的产品。我们认为，一个产品最早都是从虚拟开始的，包括需求调研、功能设计、逻辑设计，到三维模型定义，以及后面的仿真验证、工艺设计，再到产线上把实物制造出来。</p><p></p><p>虚实之间的关系，首先是一个从虚到实的过程（称为V2R，Virtual to Real）。在虚拟世界里，经过研发、设计并且制造出来的物理实体，最后要交付给客户进行实际的使用或者运行。而在运行过程中，会产生大量的数据，包括IoT数据以及使用过程中机器的传感器数据等等。</p><p></p><p>所以，这时候还会有另外一个回路，我们称为R2V，即从Real到Virtual的过程。也就是说，我们在现实世界中获取到的知识、积累的数据会反馈到虚拟世界，对虚拟世界的下一代产品提供更多提升、创新的机会。</p><p></p><p>这就是虚拟孪生的重要目的，即利用数字化的手段从性能表现、成本控制等各个方面去更好地改造我们的现实世界。</p><p></p><p>另外，对于我们国家而言，虚拟孪生的意义可能还要更加具像化。根据我国的发展规划，到2035年，要实现人均国民生产总值2万到3万美元的跨越，而要实现这个远景目标，一个重要的途径就是高质量发展。落实高质量发展，主要有两大抓手，一是<a href=\"https://www.infoq.cn/article/LBC3Rujd6xFoYfS2duGf\">数字经济</a>\"，二是绿色发展，其中数字经济又包括了数字产业化和产业数字化。而我们认为，虚拟孪生概念很好地贴合了产业数字化的发展课题，它能够更好地帮助企业利用数字技术改造传统制造业。</p><p></p><p>那么，如何构建虚拟孪生呢？它有三个基本要素，分别是数字模型、全量全要素数据，以及人的协作。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/a9/a9c7b87b9bb719e02a9f893f09815698.png\" /></p><p></p><p>其中，模型指的就是在数字世界中的精准模型，从广义上来说，它们不仅仅是大家比较熟悉的三维模型，还包含了产品前端市场需求分解后的工程需求模型体系，以及前面提到的功能设计、逻辑设计、仿真、工艺设计再到三维建模的体系化的工程模型体系，同时也包括产线的布局规划，比如产线机器人如何运作等等；</p><p></p><p>第二个要素是<a href=\"https://www.infoq.cn/article/Au8A0GLJcHPNJQp3Vizx\">数据</a>\"，也就是在模型的基础上叠加全量、全要素的数据。所谓全量，指的是深度的问题，也就是说数据数量必须要足够完整，而全要素指的是数据的种类和维度必须齐全，它们将影响模型的精准度；</p><p></p><p>第三个要素是人的协作。因为不管技术如何演进，最终的产品都是为人服务的，因此，我们希望在构建虚拟孪生的过程中，不仅要整合企业内部的员工，还要从研发、工艺到设计和供应链，实现跨生态链的连接，把供应商体系、消费者等角色也纳入进来，从而确保产品在整个全生命周期过程中，都有更好的体验。</p><p></p><h2>虚拟孪生如何在产品全生命周期发挥作用</h2><p></p><p></p><p>下面具体看看虚拟孪生在整个产品全生命周期的各个阶段如何发挥作用。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/f6/f60bd6b5fbe5fdd8513be223dfcfed5d.png\" /></p><p></p><p>首先，从设计阶段开始，以动力电池行业为例，对于电芯、电池包等这些原材料的选择，整个过程就可以放到虚拟环境中进行，比如对电池的分子级别的分析，对电池包热分析、老化分析、强度的仿真等等；再比如汽车行业的自动驾驶技术研发，如果要在物理世界对自动驾驶进行合规性认证，需要一辆车日夜不停地跑数百年的时间，才能完成所有场景的验证，这时候，只需要把车辆的动力学模型，叠加上环境模型，放到虚拟世界进行充分的仿真验证，就可以快速推动自动驾驶技术的研发速度和技术成熟度。</p><p></p><p>往下，进入工艺设计、规划阶段，这个过程要看工装设备、<a href=\"https://www.infoq.cn/article/1fSLGpl1K3OYX6AgLZ34\">产线机器人</a>\"、总装线的布局等等是否合理。还以汽车为例，比如从冲压、焊装、涂装再到总装，机器人效率是否够高，产线整体节能减排效果是否最优，机械臂是否都达到了规范的操作角度等等，这些问题都可以反馈到虚拟孪生系统中进行仿真和评估。</p><p></p><p>再往后是制造和供应链环节，在这个过程中，企业需要考虑市场需求与产线生产能力的匹配，包括生产的排程等等，这些规划在正式投产之前就可以先在虚拟环境进行分析验证。而在具体制造过程中，关键是生产的执行、产线设备状况、产品质量管理、仓库管理等等，每个环节相关数据的收集，最后都会反馈到具体的制造执行中。</p><p></p><p>最后是服务环节，比如利用大数据分析和仿真模拟，可以进行预防性的维修保养，在产品还没有发生问题的时候，就可以提前提出维修保养的时间建议，甚至为其提前准备好维护的零部件，从而降低产品运行过程中可能发生的宕机的概率和时间。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/da/da3763085134407613094b00b983e61b.png\" /></p><p>虚拟孪生在航空业产品全生命周期的应用</p><p></p><h2>虚拟孪生应用案例及未来展望</h2><p></p><p></p><p>以下跟大家分享几个虚拟孪生的典型应用案例：</p><p></p><p>第一个是优化产线布局的案例。大家知道，如果一个产线真正布置到车间里之后发现问题再进行调整和优化，成本是非常高的，因此，我们帮助一个客户在产线设计阶段就完成了完整的虚拟验证，验证每个机器人和工作单元是不是进行了最优的操作，产线的节拍是否合适，从而保证产线在真正进入工厂之后，能够一次性成功投产，并且布局效能最高。</p><p></p><p>第二个是服务优化的案例。以航空发动机为例，它是飞机的核心部件，只有使得飞机飞起来才能创造价值，停在地面都是成本，所以，我们可以利用虚拟孪生为航空发动机提供设备服务保障，确保它的可靠运行，减少故障带来的成本损失。</p><p></p><p>比如，在运行过程中，航空发动机上大量传感器会持续把运行数据传输到地面的数据中心，在拿到这些数据之后，我们就可以进行充分的分析，一旦发现故障可能性，就可以及时采取应对措施，包括预测分析发动机可能在多长时间后发生什么类型的故障，然后提前在相应的维修网点配备维修备件，在飞机抵达目的地之后及时提供备件更换服务，确保发动机的可靠性。</p><p></p><p>第三个是产品设计环节的案例。我们知道，快消品行业非常注重对用户需求满足和体验优化，但与此同时，还要兼顾成本控制。这时候，可以在设计研发阶段引入虚拟孪生，通过反复的What-If分析，评估采用方案A和方案B的结果，目标成本可以达到什么程度，具体可以满足哪些客户需求等等，通过在设计阶段进行多方案的比对，从而在成本控制和客户需求之间达到一个更优的平衡。</p><p></p><p>最后，展望虚拟孪生技术，我们认为，它不仅可以赋能制造业的产品生命周期过程，甚至还可以在生命科学等领域创造价值。比如，对于医生来说，可以在为病人进行手术之前，在虚拟孪生环境基于相关的模型进行虚拟演练，从而提高手术的成功率，为病人提供更好的医疗服务。这实际上就体现了达索系统通过虚拟孪生实现产品、自然与生命的和谐状态的企业宗旨。</p><p></p><h4>嘉宾介绍：</h4><p></p><p>杨宠，达索系统技术咨询部业务咨询高级经理。华中科技大学工学博士。曾供职于盖德信息技术有限公司 、国际商业机器有限公司（IBM） 、参数技术软件有限公司（PTC） ，为多家制造业企业提供过业务咨询和数字化咨询服务。</p><p></p><p>延展阅读：<a href=\"https://www.infoq.cn/article/1fSLGpl1K3OYX6AgLZ34\">《揭秘“灯塔工厂”的 AI 应用案例和规模化策略》</a>\"</p>",
    "publish_time": "2023-07-24 08:30:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "我眼中的CSS革命：新特性潜力无限",
    "url": "https://www.infoq.cn/article/E5uA6Gtd7VkIoaebIHzd",
    "summary": "<p></p><h2>变化</h2><p></p><p>&nbsp;</p><p>我从2000年初那会开始用CSS了。在那之前，我们一直用表格加GIF图来设计网页布局，CSS出现之后我们终于走进了“文明社会”。从此CSS成了我最喜欢的编程语言，而回顾它这么多年来的发展，有一件事是肯定的：CSS不再是当初的样子了。我们在2003年编写的CSS跟2013年总有很大区别，而如今又一个十年过去，我们如今编写的CSS比之前更强大、但也更加复杂。</p><p>&nbsp;</p><p>当然，CSS的进化绝非一蹴而就。就如同Web一样，CSS也是逐步演进，最终成了今天的样子。大家还记得第一次用上box-shadow、background-size还有border-radius时的兴奋之情吗？对，这就是CSS前进路上的一个个脚印。</p><p>&nbsp;</p><p>不知道大家有没有关注今年在阿姆斯特丹举办的CSS Day大会，我看了现场直播，而且明显感觉这次跟以往不同。CSS此番迎来了一系列根本层面的变化，甚至有种到了技术奇点的意思。也就是说，CSS由此分成了2020年代前与2020年代后两大阶段。想要选定某个元素的父元素，但浏览器本身又不支持解析CSS？没关系，现在可以直接用:has()。想根据容器大小调整元素，又担心可能造成无限循环？别担心，现在可以用容器查询和随附的新长度单位。这些功能都对CSS乃至整个Web平台做出了有益且大家睽违已久的补充。与其他现代功能（例如自定义属性、min（）、max（）、clamp（））以及关键字大小调整（例如min-content、max-content和fit-content）相结合，我们就能打造出前所未有的灵活组件和强大布局。总而言之，我们如今理解和编写CSS的基本方式已经发生了根本性转变。</p><p>&nbsp;</p><p></p><h2>根本性变革</h2><p></p><p>&nbsp;</p><p>除此之外，标志CSS进入新时代的其实是另一个更大、更加根本性的转变：</p><p>&nbsp;</p><p>CSS现已成为最强大的Web设计工具。</p><p>&nbsp;</p><p>多年以来，设计师必须经历一场艰难卓绝的斗争，才能打造出高质量的网站成果、把自己的想法真正在浏览器当中呈现出来。与此同时，诸如“我真的很抱歉，但您的设计无法用CSS实现”每天都被前端开发者们无奈地说出。设计师设想中的漂亮构图虽然备受好评，但对于CSS这种仍在发展的语言来说显得太过先进。谁能理解并克服CSS中的种种局限甚至说“怪癖”，谁才有望开发出杀手级的出色网站。</p><p>&nbsp;</p><p>于是乎，设计师们吸取一教训，开始创建兼容性更强的布局，比如几乎全部使用12列平均网格。这明显就是开发平台本身的不足所导致。</p><p>&nbsp;</p><p>但如今，情况已经大为不同。</p><p>&nbsp;</p><p>想在Figma、Adobe XD或者Sketch等主流设计工具中模拟并设计出一个能充分发挥CSS网格潜力的布局？做不到。想通过取色器等工具在OKLCH等广色域色彩空间中定义某种颜色，从而在现代屏幕上呈现出更加鲜艳自然的色彩？不可能。想要模拟流体排版，根据窗口或容器大小动态缩放字体，并像在CSS中使用clamp()那样定义最小值和最大值？不可能。或者说定义一种备用字体，在默认网络字体无法加载时立刻顶上？还是不可能。是的，目前市面上任何一种设计工具都已经跟不上CSS的发展。在这个新时代，CSS上只需几行就能轻松实现的功能，反而在设计端找不到对应的选项。设计工具成了前端开发中的新瓶颈。</p><p>&nbsp;</p><p>在去年的一场演讲中，我曾提到应该解决设计工具和CSS间差距越拉越大的问题。从自身出发，我们能做的也只有密切协作、推出更多原型设计，让更多人能在网页设计和开发的交叉点上工作。但这一切并不容易，而且都需要时间。有些团队已经展开了探索，并以新的、协同度更高的方式荼。但对大多数人而言，打破旧习惯显然不是易事。</p><p>&nbsp;</p><p></p><h2>工具的变化</h2><p></p><p>&nbsp;</p><p>总体而言，我希望看到人们对于CSS在设计过程中的认知和作用得到扭转，将瀑布式流程末尾的样式演示工具变成早期设计决策中的核心工具。如此一来，熟悉使用CSS进行原型设计和Web组件构建的设计师将更具价值。作为设计工程领域的自由职业者，我对这一点充满信心。</p><p>&nbsp;</p><p>在CSS Day的演讲上，曾有人问现在的设计师到底要不要学CSS。而专家Heyton给出的答案是：CSS已经成为一种设计工具、一种达成目的的手段，一种可供探索和使用的素材。更重要的是，它成为一种可供思考和决策的工具，开始步入设计舞台的最中央。</p><p>&nbsp;</p><p>“我是按设计工具来学习CSS的，这就是我对设计的理想。设计代表着一种思维过程……它非常抽象，反映的是我们尝试成就某事的路径。在路径当中，我们需要借助各种各样的工具。这种工具可能是Figma，可能是Photoshop，也可能是CSS。”</p><p>&nbsp;</p><p>这就是新CSS，有史以来最强大的Web设计工具。只有用好CSS，我们才能发挥平台上的现代功能；只有将CSS引入设计，我们才能建立起能灵活适应不同环境、不同内容类型的设计方案；也只有使用新CSS，我们才能真正打造出优雅高效、简洁有力的真Web成果。正如Heyton所言：“我不知道到底该不该用CSS，但它肯定值得一用。”</p><p>&nbsp;</p><p></p><h5>原文链接：</h5><p></p><p></p><p><a href=\"https://matthiasott.com/notes/the-new-css?utm_source=CSS-Weekly&amp;utm_campaign=Issue-554&amp;utm_medium=web\">https://matthiasott.com/notes/the-new-css?utm_source=CSS-Weekly&amp;utm_campaign=Issue-554&amp;utm_medium=web</a>\"</p><p>&nbsp;</p><p></p><h5>相关阅读：</h5><p></p><p></p><p><a href=\"https://xie.infoq.cn/article/ff08f11ef5199eac739bcd96d\">一文吃透 CSS 样式中颜色与颜色值的应用</a>\"</p><p><a href=\"https://xie.infoq.cn/article/b43f7080697e3b13f8f1de01a\">CSS 样式中颜色与颜色值的应用</a>\"</p><p><a href=\"https://www.infoq.cn/article/9cUfR6WbcwTyXJzsFxMY\">CSS 选择器的一场革命，:has() 高级使用指南</a>\"</p><p><a href=\"https://xie.infoq.cn/article/329a83f021eebaf46f1ffccf2\">css 过去及未来展望—分析 css 演进及排版布局的考量</a>\"</p>",
    "publish_time": "2023-07-24 11:15:25",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "npm前员工自曝，生态内部存在严重bug | 附避坑指南",
    "url": "https://www.infoq.cn/article/NhSzg8cH4eHfWMppRDV9",
    "summary": "<p></p><p></p><blockquote>最近，npm 前工程经理 Darcy Clarke 在一份报告中指出，npm 注册没有根据相应 tarball 包的内容验证清单信息。Clarke 说，这会导致双重事实来源，攻击者可以利用它来隐藏脚本或依赖项。&nbsp;这一点影响很大。例如，npm 上有个包可能会显示它没有依赖项，而实际上它有。同样，它显示的包名或版本可能与 package.json 中的不同，而这可能会导致缓存中毒。更糟糕的是，它可以隐藏它将在安装期间运行脚本的事实。</blockquote><p></p><p>&nbsp;</p><p>在接受 InfoQ 采访时，Sonatype 安全研究员 Ax Sharma 强调，这种不一致不一定是恶意的，可能是源于合法的克隆或分叉，或者是由于开发人员在更新包时没有清理过时的元数据。他还提出了一点小小的异议：</p><p>&nbsp;</p><p></p><blockquote>相信 package.json 并不一定比相信包的 npmjs 页面更好——两者都不是完全可靠的。</blockquote><p></p><p>&nbsp;</p><p>根据 Sharma 的说法，要解决这个问题需要借助安全工具进行更深入的分析，例如，对恶意文件或受到攻击的文件进行基于散列的分析，即高级二进制指纹。</p><p>&nbsp;</p><p>另一个有用的建议来自 J. M. Rossy 的推特，他建议默认关闭脚本。</p><p>&nbsp;</p><p>如果你对这个清单之惑感兴趣，请阅读 Clarke 的原文，其中有许多其他的见解。</p><p>&nbsp;</p><p>以下为原文翻译。</p><p>&nbsp;</p><p></p><blockquote>简单自我介绍，2019 年 7 月至 2022 年 12 月期间，我负责 npm CLI 团队的工程管理。2020年我参与了 GitHub 收购 npm 项目.。2022年12 月，我因各种原因离开了 GitHub。</blockquote><p></p><p>&nbsp;</p><p>如今，各类新兴供应链攻击可谓层出不穷，而本文要向大家分享的则是其中一例——我个人称之为“manifest混淆”（manifest confusion）。</p><p>&nbsp;</p><p></p><h2>故事背景</h2><p></p><p>&nbsp;</p><p>在Node生态系统发展到如今全球用户达数千万、创建超过310万个软件包、月下载量高达2080亿次的规模之前，当初该项目的贡献者数量曾非常有限。当然，社区越小，大家就越感觉安心，毕竟没有哪个黑客团队会找这么“瘦”的目标下手。但随着时间推移，npm注册表被逐步开发出来，人们可以免费贡献并检查其中的开源代码，语料库的组织政策和实践也迎来同步发展。</p><p>&nbsp;</p><p>从诞生之初，npm项目就非常信任注册表的客户端与服务器端。现在回想起来，这种高度依赖客户端来处理数据验证的作法真的很有问题。但也正是凭借这项策略，是让JavaScript工具生态得以快速成长并在数据形态中有所体现。</p><p>&nbsp;</p><p></p><h2>发生甚么事了？</h2><p></p><p>&nbsp;</p><p>npm公共注册表不会使用包tarball中的内容来验证manifest信息，反而是依赖npm兼容的客户端进行解释和强制验证/一致性。事实上，在研究这个问题时，我发现服务器似乎从未承担过验证任务。</p><p>&nbsp;</p><p>如今，registry.npmjs.com 允许用户通过PUT请求将软件包发布至相应的包URI，例如：</p><p>&nbsp;</p><p>https://registry.npmjs.com/-/。</p><p>&nbsp;</p><p>该端点会接收一条请求body，内容如下所示（请注意：在经历近15年的发展之前，如今的npm及其他注册表API仍然严重缺乏记录信息）：</p><p>&nbsp;</p><p><code lang=\"null\">{\n  _id: ,\n  name: ,\n  'dist-tags': { ... },\n  versions: {\n    '': {\n      _id: '@`,\n      name: '',\n      version: '',\n      dist: {\n        integrity: '',\n        shasum: '',\n        tarball: ''\n      }\n      ...\n    }\n  },\n  _attachments: {\n    0: {\n      content_type: 'application/octet-stream',\n      data: '',\n      length: ''\n    }\n  }\n}</code></p><p>&nbsp;</p><p>目前的问题是，version元数据（也就是「manifest」数据）是独立于存放有软件包package.json的tarball而独立提交的。这两部分信息之间从未进行过相互验证，而且我们往往搞不清依赖项、脚本、许可证等数据的“权威事实来源”究竟是谁。据我所知，tarball才是唯一拥有签名，且有着可离线存储及验证的完整性值的工件。从这些角度看，它应该才是正确的来源；但令人意外的是，package.json当中的name&nbsp;&amp;&nbsp;version&nbsp;字段实际上很可能与manifest中的字段不同，因为二者间不会进行相互验证。</p><p></p><h3>示例</h3><p></p><p></p><p>在npmjs.com上生成身份验证令牌(例如：&nbsp;https://www.npmjs.com/settings//tokens/new&nbsp;- 选择 \"Automation\" 以方便测试)启动一个新项目 (例如：&nbsp;mkdir test &amp;&amp; cd test/ &amp;&amp; npm init -y)安装helper库（例如：npm install ssri libnpmpack npm-registry-fetch)创建一个子目录，作为“真实”的软件包及内容（例如&nbsp;mkdir pkg &amp;&amp; cd pkg/ &amp;&amp; npm init -y)修改该包的内容……在项目根目录中创建一个&nbsp;publish.js&nbsp;文件，内容如下：</p><p>&nbsp;</p><p><code lang=\"null\">;(async () =&gt; {\n  // libs\n  const ssri = require('ssri')\n  const pack = require('libnpmpack')\n  const fetch = require('npm-registry-fetch')\n\n\n  // pack tarball &amp; generate ingetrity\n  const tarball = await pack('./pkg/')\n  const integrity = ssri.fromData(tarball, {\n    algorithms: [...new Set(['sha1', 'sha512'])],\n  })\n\n\n  // craft manifest\n  const name = ''\n  const version = ''\n  const manifest = {\n    _id: name,\n    name: name,\n    'dist-tags': {\n      latest: version,\n    },\n    versions: {\n      [version]: {\n        _id: `${name}@${version}`,\n        name,\n        version,\n        dist: {\n          integrity: integrity.sha512[0].toString(),\n          shasum: integrity.sha1[0].hexDigest(),\n          tarball: '',\n        },\n        scripts: {},\n        dependencies: {},\n      },\n    },\n    _attachments: {\n      0: {\n        content_type: 'application/octet-stream',\n        data: tarball.toString('base64'),\n        length: tarball.length,\n      },\n    },\n  }\n\n\n  // publish via PUT\n  fetch(name, {\n    '//registry.npmjs.org/:_authToken': '',\n    method: 'PUT',\n    body: manifest,\n  })\n})()</code></p><p>&nbsp;</p><p>可随意修改其中&nbsp;manifest&nbsp;键（例如，我在这里去掉了&nbsp;scripts&nbsp;&amp;&nbsp;dependencies&nbsp;)；运行程序（例如：&nbsp;node publish.js)；导航至&nbsp;https://registry.npmjs.com//&nbsp;&amp;&nbsp;https://www.npmjs.com/package//v/?activeTab=explore&nbsp;以查看差异。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/9f/9f86efed26016ca9cabcf62ae88c6740.png\" /></p><p></p><p>&nbsp;</p><p>以上示例中的软件包是用不同manifest发布的，其各有对应的package.json，请参考：</p><p>&nbsp;<a href=\"https://www.npmjs.com/darcyclarke-manifest-pkg\">https://www.npmjs.com/darcyclarke-manifest-pkg</a>\"&nbsp;</p><p>&nbsp;<a href=\"https://registry.npmjs.com/darcyclarke-manifest-pkg/\">https://registry.npmjs.com/darcyclarke-manifest-pkg/</a>\"</p><p></p><h2>&nbsp;Bug, bug, 到处是bug</h2><p></p><p>&nbsp;</p><p>如果大家想用更简单的办法重现这种不一致性，现在也可以使用 npm CLI。一旦在项目中发现binding.gyp文件，它就会在npm发布期间改变manifest内容。这种行为似乎在我加入npm团队之前（即6.x或更早版本）就已经存在于客户端内，而且已经给众多用户惹出了不少麻烦。</p><p>&nbsp;</p><p>npm init -ytouch binding.gypnpm publish可以看到，&nbsp;\"node-gyp rebuild\"&nbsp;scripts.install&nbsp;条目已被自动添加至manifest当中，但却未被添加至tarball的&nbsp;package.json&nbsp;当中。例如：</p><p>&nbsp;<a href=\"https://registry.npmjs.com/darcyclarke-binding\">https://registry.npmjs.com/darcyclarke-binding</a>\"&nbsp;&nbsp;<a href=\"https://unpkg.com/darcyclarke-binding@1.0.0/package.json\">https://unpkg.com/darcyclarke-binding@1.0.0/package.json</a>\"</p><p>&nbsp;</p><p>这种不一致现象在&nbsp;node-canvas中经常出现：</p><p><a href=\"https://www.npmjs.com/package/node-canvas/v/2.9.0?activeTab=explore\">https://www.npmjs.com/package/node-canvas/v/2.9.0?activeTab=explore</a>\"<a href=\"https://registry.npmjs.com/node-canvas/2.9.0\">https://registry.npmjs.com/node-canvas/2.9.0</a>\"<a href=\"https://github.com/npm/cli/issues/5234\">https://github.com/npm/cli/issues/5234</a>\"</p><p>&nbsp;</p><p></p><h2>相关影响</h2><p></p><p>&nbsp;</p><p>这个bug可能会以多种方式影响消费者/最终用户：</p><p>缓存中毒（即保存的包可能与注册表/URI中的名称+版本规格不匹配；安装未知/未列出的依赖项（欺骗安全/审计工具）；安装未知/未列出的脚本（欺骗安全/审计工具）；引发潜在降级攻击（保存到项目中的版本规格，为不符合要求/易受攻击的包版本）。</p><p>&nbsp;</p><p></p><h2>已知受到影响的第三方组织/实体：</h2><p></p><p>&nbsp;</p><p>Snyk:&nbsp;<a href=\"https://security.snyk.io/package/npm/darcyclarke-manifest-pkg\">https://security.snyk.io/package/npm/darcyclarke-manifest-pkg</a>\"CNPMJS/Chinese Mirror:&nbsp;<a href=\"https://npmmirror.com/package/darcyclarke-manifest-pkg\">https://npmmirror.com/package/darcyclarke-manifest-pkg</a>\"Cloudflare Mirror:&nbsp;<a href=\"https://registry.npmjs.cf/darcyclarke-manifest-pkg/2.1.15\">https://registry.npmjs.cf/darcyclarke-manifest-pkg/2.1.15</a>\"Skypack:&nbsp;<a href=\"https://cdn.skypack.dev/-/darcyclarke-manifest-pkg@v2.1.15\">https://cdn.skypack.dev/-/darcyclarke-manifest-pkg@v2.1.15</a>\"UNPKG:&nbsp;<a href=\"https://unpkg.com/darcyclarke-manifest-pkg@2.1.15/package.json\">https://unpkg.com/darcyclarke-manifest-pkg@2.1.15/package.json</a>\"JSPM:&nbsp;<a href=\"https://ga.jspm.io/npm:darcyclarke-manifest-pkg@2.1.15/package.json\">https://ga.jspm.io/npm:darcyclarke-manifest-pkg@2.1.15/package.json</a>\"Yarn:&nbsp;<a href=\"https://yarnpkg.com/package/darcyclarke-manifest-pkg\">https://yarnpkg.com/package/darcyclarke-manifest-pkg</a>\"</p><p>&nbsp;</p><p>&nbsp;</p><p></p><blockquote>更新：前文提到，Socket Security易受到manifest混淆问题的影响。自2022年9月5日起，Socket方面已开始使用tarball内的package.json文件作为事实来源，且要求显示包的准确信息（例如依赖项、许可证、脚本等）。截至本文发布时，darcyclarke0-manifest-pkg的软件包页面错误地引用了过时的数据，但Socket团队很快解决了这个问题。这里要称赞一声，Socket可能是首个正确处理此问题的项目团队。</blockquote><p></p><p>&nbsp;</p><p>此问题还会以下面介绍的几种方式，影响到所有已知的主要JavaScript包管理器。jFrog的Artifacory等第三方注册表实现似乎也继承了该API的设计/问题，因此使用这些私有注册表实例的所有客户端也会出现相同的问题/不一致。</p><p>&nbsp;</p><p>注意，各类包管理器和工具对应不同的应用场景。它们要么使用/引用软件包的注册表manifest，要么使用/引用tarball的package.json（主要是为了通过缓存机制提高安装性能）。</p><p>&nbsp;</p><p>这里需要强调的是，生态系统目前仍普遍存在错误假设，即manifest的内容始终与tarball的package.json内容一致（这主要是因为注册表API说明文档过少，且docs.npmjs.com多次提到注册表会将package.json的内容存储为元数据——但却没有强调其实是由客户端负责确保一致性）。</p><p>&nbsp;</p><p></p><h2>npm@6</h2><p></p><p></p><h3>执行manifest/tarball中不存在的脚本</h3><p></p><p></p><p>重现步骤：</p><p>安装一个格式经过篡改的依赖项:&nbsp;npx npm@6 install darcyclarke-manifest-pkg@2.1.13See that lifecycle scripts are being executed even though none are present in the manifest &amp; the registry has not registered the package as having install script (ie.可以看到，虽然在manifest中并不存在/注册表尚未将包注册为具有安装脚本，但生命周期脚本仍在执行（即&nbsp;hasInstallScript&nbsp;为&nbsp;undefined/false) 参考：</p><p>&nbsp;<a href=\"https://registry.npmjs.org/darcyclarke-manifest-pkg/2.1.13\">https://registry.npmjs.org/darcyclarke-manifest-pkg/2.1.13</a>\"&nbsp;</p><p></p><p>代码/包请参考：</p><p><a href=\"https://github.com/npm/minify-registry-metadata/blob/main/lib/index.js\">https://github.com/npm/minify-registry-metadata/blob/main/lib/index.js</a>\"</p><p>node_modules/darcyclarke-manifest-pkg当中的package.json反映tarball条目。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/71/71cbb2e4e858254b0c5c93e13a633440.png\" /></p><p></p><p>&nbsp;</p><p></p><h3>安装manifest/tarball中不存在的依赖项</h3><p></p><p>&nbsp;</p><p>由于包tarball会被缓存在全局存储当中，所以如果--prefer-offline配置与--no-package-lock共同使用，则下一次在系统中对该包运行install时，隐藏在tarball中的依赖项也会被安装。</p><p>重现步骤：</p><p>安装&nbsp;npx npm@6 install darcyclarke-manifest-pkg@2.1.13再次运行安装…&nbsp;npx npm@6 install --prefer-offline --no-package-lock</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/5a/5a3580cf29effdeddd197f7c654b897c.png\" /></p><p></p><p></p><h2>npm@9</h2><p></p><p></p><h3>安装manifest/tarball中不存在的依赖项</h3><p></p><p></p><p>与npm@6,类似，npm@9在使用--offline配置时也会直接安装经过缓存的tarball package.json当中引用的依赖项。</p><p>&nbsp;</p><p></p><blockquote>注意：其中似乎存在争用条件，即--offline可能会/可能不会被从缓存内提取，因此重现结果并不稳定。</blockquote><p></p><p>&nbsp;</p><p>重现步骤：</p><p>安装格式经过篡改的依赖项以将其缓存；在安装时使用--offline配置并/或关闭可用网络（例如： npm install --offline --no-package-lock)可以看到，manifest中并未引用的依赖项也会被安装。</p><p>&nbsp;</p><p></p><h2>yarn@1</h2><p></p><p>&nbsp;</p><p></p><h3>执行manifest/tarball中不存在的安装脚本</h3><p></p><p>&nbsp;</p><p>与 npm@6 &amp; npm@9类似，yarn@1 会tarball中引用、但manifest并未引用的脚本，反之亦然。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/c3/c3e208eaf879533f7bd33cdbeb3cec3d.png\" /></p><p></p><p>&nbsp;</p><p></p><h3>使用tarball中的version字段——暴露潜在降级攻击向量</h3><p></p><p></p><p>现在大家已经了解，tarball的内容定义可以与manifest有所不同；在这种情况下，yarn@1顺理成章地在升级/降级之后，再把错误版本保存回当前项目的package.json当中（可能令用户在后续安装中遭受降级攻击）。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/35/35f32f33193f0fa1a584950cf83e1df2.png\" /></p><p></p><p>&nbsp;</p><p></p><h2>pnpm@7</h2><p></p><p></p><h3>执行manifest/tarball中不存在的安装脚本</h3><p></p><p></p><p>重现步骤：</p><p>与之前几个案例类似，pnpm会运行tarball中存在、但manifest并未引用的脚本，反之亦然。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/a5/a53c4e8ea43a751ce77609d6097480d2.png\" /></p><p></p><p>&nbsp;</p><p></p><h2>CWE分类/细分</h2><p></p><p>&nbsp;</p><p>此漏洞可能涉及多种CWE分类。至少如果我们把此问题视为“特例”，则以上情况应该被归纳为“服务端安全的客户端实施”（即CWE-602——但我严重怀疑这种判断并不适用。我在下文中会具体分析各种问题及其相应CWE分类，且分别提供参考代码）。</p><p></p><p><a href=\"https://cwe.mitre.org/data/definitions/602.html\">CWE-602: 服务端安全的客户端实施</a>\"长期以来，我们一直严重依赖客户端（即npm&nbsp;CLI）完成本应在服务器端完成的工作；代码参考：&nbsp;<a href=\"https://github.com/npm/cli/blob/latest/workspaces/libnpmpublish/lib/publish.js\">https://github.com/npm/cli/blob/latest/workspaces/libnpmpublish/lib/publish.js#L63</a>\"<a href=\"https://cwe.mitre.org/data/definitions/94.html\">CWE-94: 代码生成控制不当（「代码注入」）</a>\"这会影响全体用户（包括&nbsp;npm等包管理器）; 如下所述，这会导致其出现各种问题<a href=\"https://cwe.mitre.org/data/definitions/295.html\">CWE-295: 证书生成不当</a>\"即使内容（包括&nbsp;name,&nbsp;version,&nbsp;dependencies,&nbsp;license,&nbsp;scripts&nbsp;等)与相关注册表索引有所不同，tarball仍可获得签名并被赋予完整性值<a href=\"https://cwe.mitre.org/data/definitions/325.html\">CWE-325: 缺少加密步骤</a>\"manifest数据未经签名，因此无法离线缓存或验证；缺少与tarball的package.json及包manifest相符的数据子集的哈希值/验证；<a href=\"https://cwe.mitre.org/data/definitions/656.html\">CWE-656: 依赖构建于封闭的安全性</a>\"由于缺乏关于注册表API的说明文档，因此很难发现该问题。</p><p></p><h2>GitHub为此做了哪些努力？</h2><p></p><p>&nbsp;</p><p>据我所知，GitHub大概在2022年11月4日左右发现了这个问题；经过独立研究之后，我认为这个问题的潜在影响/风险要比最初的判断大得多，因此于3月9日提交了一份包含个人发现的HackerOne报告。3月21日，GitHub关闭了该工单，表示他们正在“内部”处理这个问题。据我了解，之后GitHub没有取得任何&nbsp;重大进展，也没有公开发布这个问题。相反，他们在过去半年间逐渐放弃了npm的产品地位，且拒绝更新或提供关于补救措施的相关说明。</p><p></p><h2>可行的解决方案</h2><p></p><p>&nbsp;</p><p>GitHub正陷入不可逆转的困境。事实上，npmjs.com就是在这样的状态下运行了十余年，意味着目前的安全状况已经被深深嵌入代码当中，再难实现广泛修复。如前所述，npm&nbsp;CLI本身也依赖于这种设计，而且目前还可能存在其他非恶意用途。</p><p></p><p>该做点什么……应开展进一步调查，确定注册表内受影响条目的具体范围，这将有助于确定滥用情况。如果差异量不太大（但考虑到当前manifest变体的可观规模，这种可能性恐怕很低），那么也许可以根据tarball的package.json重新生成包含差异的manifest。从现在起，根据研究/发现对manifest中高权限/已知密钥强制执行/验证。尽快将npm公共注册表API及其相应的请求/响应对象记录下来。</p><p></p><h2>用户能做点什么？</h2><p></p><p>&nbsp;</p><p>与认识的任何使用npm注册表manifest数据的已知工具作者/维护者联系，确保他们知情并想办法在适当时转而使用包内容作为元数据（即除了name&nbsp;&amp;&nbsp;version之外的所有内容）。另外，请从现在起严格执行/验证注册表代理的一致性。</p><p></p><h5>原文链接：</h5><p></p><p><a href=\"https://blog.vlt.sh/blog/the-massive-hole-in-the-npm-ecosystem\">https://blog.vlt.sh/blog/the-massive-hole-in-the-npm-ecosystem</a>\"</p><p></p><h5>相关阅读：</h5><p></p><p><a href=\"https://xie.infoq.cn/article/68c7b3477e46c8cb05402a1aa\">前端开发：node.js 的 node 包管理器&nbsp;npm&nbsp;安装以及...</a>\"</p><p><a href=\"https://xie.infoq.cn/article/7404283d515ca3de1bedd14fc\">NPM&nbsp;实用命令与快捷方式</a>\"</p><p><a href=\"https://xie.infoq.cn/article/a64989cdc2b9cdee73fea23bb\">前端包管理工具&nbsp;npm&nbsp;yarn cnpm npx</a>\"</p><p><a href=\"https://www.infoq.cn/article/DvD8AkqdMqvuQpAw1heP\">Npm,Inc. 发布&nbsp;Npm&nbsp;Pro，面向独立 JavaScript 开发人员</a>\"</p><p></p><p>&nbsp;</p>",
    "publish_time": "2023-07-24 11:16:57",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "中国研发效能管理白皮书—从价值流管理到研发效能管理",
    "url": "https://www.infoq.cn/article/y6K49q7Ctmir5ro9wFZC",
    "summary": "<p></p><h3>研究背景</h3><p></p><p>近年来，中国企业研发正在从粗放型走向精益型，研发工作的“高效能”成为几乎每个研发团队的共同追求。</p><p></p><p>中国软件服务产业也在近 5 到 10 年中得到了飞速发展，技术服务的边界不断拓展，赋能高效研发的产品层出不穷，适合中国研发环境的技术服务体系在不断完善。从结果上看，中国企业正在高效能研发的路径上快速前进。</p><p></p><p>本份报告以中国高效能研发企业为研究对象，尝试解读市场中具有代表性的高效能研发解决方案。本次报告由五个篇章组成，包括 CI/CD 、企业级软件架构、研发效能管理等主题。研究小组期待可以通过研究，帮助中国企业研发团队获得高效能研发新知。</p><p></p><p>作为本次报告的最后一个篇章，本书先是讨论了价值流管理相关的定义、特征、主要分析指标、发展历程。再从价值流管理面临的问题出发，讨论并得出中国场景下需要在需求价值流和工程实践流的双流模型，最终落地研发效能管理。</p><p></p><p>最后，本书分析研发效能管理的关键要素，并总结输出研发效能管理的方法论体系（GDAI），四步走帮助企业落地研发效能管理。再结合成功案例，在案例中展现研发效能管理的效果与价值。</p><p></p><h3>目录</h3><p></p><p>价值流管理定义与背景价值流管理行业发展现状极狐 GitLab 研发效能管理</p><p></p><p>扫码下载</p><p><img src=\"https://static001.geekbang.org/infoq/fe/fe0e3878a03224cf558ab25affb46248.jpeg\" /></p><p></p>",
    "publish_time": "2023-07-24 12:00:31",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]