[
  {
    "title": "架构师（2023 年 6 月）",
    "url": "https://www.infoq.cn/article/YfSrmISxZaJhgjIvSMJ4",
    "summary": "<h2>卷首语</h2>\n<p><strong>作者｜褚杏娟</strong></p>\n<p>“用 Rust 重写”正流行。</p>\n<p>一直以来，在 Windows 内核中的主要语言是 C，内核之外的大部分代码是 C++。但在最新的 Windows 11 Insider Preview 版本中，微软纳入了内存安全编程语言 Rust，这无疑又添了一把火。还有个人开发者用 Rust 写了类似 Kubernetes 的应用。</p>\n<p>但同时也有开发者指出，单纯用 Rust 重写大型 C/C++ 系统组件只会引入额外的攻击面：新组件和现有代码间的外部函数接口（FFI）。在一些情况下，“安全”Rust 函数其实比原本的“不安全”C 函数更糟糕。</p>\n<p>Rust 还是 C/C++，似乎是个问题：Rust 使用相似的语法并且可用于许多与 C++ 相同的任务，但 C++ 拥有更大的社区、更广泛的用例、更多的框架，并且得到了很多公司的认可。而由于其静态类型特性，Rust 在安全性、编写速度和防止不正确/不安全的代码方面更好。</p>\n<p>近日，在黑客新闻上有关于选择<a href=\"https://news.ycombinator.com/item?id=36206908\">Rust 还是 C 或 C++</a>的讨论。</p>\n<p>“我会选择 Rust，因为它相比C更符合开发者的‘人体工程学’。即使是像标准 linter 和包管理器 (Cargo) 这样的小东西，在编写惯用代码方面也大有帮助。”有开发者表示。</p>\n<p>“C是永远的选择。它是社区希望尽早制定规范的唯一语言，这使 C 掌握在程序员手中，而不是编译器创建者手中。”也有开发者说道。</p>\n<p>还有“端水”的开发者说道，“把 C 学得足够好来解决 C++ 和 Rust 试图解决的痛点，C 简单但并不容易；再学习足够多的 Rust 以提高工作效率；然后学习足够的 C++ 以便与现有的大量 C++ 代码进行交互。”</p>\n<p>作为一名开发者，你更支持哪种语言呢？</p>\n<h4></h4>\n<p><strong>目录</strong></p>\n<p><strong>热点 | Hot</strong></p>\n<p>纪念陈皓（左耳朵耗子）</p>\n<p>微软 Bing Chat 全面开放，所有人可用！官宣多项重大升级，日活用户超过 1 亿</p>\n<p>比 Python 快 35000 倍！LLVM&amp;Swift 之父宣布全新编程语言 Mojo：编程被颠覆了</p>\n<p>从微服务转为单体架构、成本降低 90%，亚马逊内部案例引发轰动！</p>\n<p>“TypeScript 不值得！”前端框架 Svelte 作者宣布重构代码，反向迁移到 JavaScript 引争议</p>\n<p><strong>访谈文章 | Interview</strong></p>\n<p>一个价值 70 亿美元的教训！如何避免平台工程变成“大灾难”？</p>\n<p>云原生网关当道，三大主流厂商如何“竞技”？</p>\n<p><strong>案例研究 | Case Study</strong></p>\n<p>喜马拉雅 KV 存储演进之路</p>\n<p>通用电气在平台工程上浪费70亿美元的教训</p>\n<p>天眼查基于 Apache Doris 构建统一实时数仓实</p>\n<p>平安开放银行模式探索实践：从物联网金融到开放联盟</p>\n<p><strong>推荐文章 | Article</strong></p>\n<p>探索 OpenAI 平台架构</p>\n<p>花 8 年转型微服务却得不到回报，问题出在哪儿？</p>\n<p>云原生时代，如何建设稳定性可观测体系？</p>\n<p>不谈技术了，聊聊车企研发效能和文化冲突问题怎么解</p>\n<p><strong>特别专题｜eBPF 探索与应用：如何掀起平台革命</strong></p>\n<p>从石器时代到成为“神”，一文讲透 eBPF 技术发展演进史</p>\n<p>颠覆传统、应用大爆发，eBPF 何以改变 Linux？</p>\n<p>无声的平台革命：eBPF 是如何从根本上改造云原生平台的</p>\n<p>网易伏羲私有云基于 eBPF 的云原生网络可观测性探索与实践</p>\n<p><strong>特别专栏 | Video</strong></p>\n<p>本月，这些视频值得一看！</p>",
    "publish_time": "2023-06-08 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Istio的未来：无Sidecar和带有Ambient Mesh的Sidecar",
    "url": "https://www.infoq.cn/article/hh12UJcPhkRmKoQLKyK7",
    "summary": "<p><a href=\"https://istio.io/latest/blog/2022/introducing-ambient-mesh/\">Istio的Ambient Mesh（环境网格）</a>\"为Istio服务网格引入了一个新的无Sidecar（Sidecar-Less）数据平面选项，其目的是简化应用程序的启动，增加增量采用，并降低Istio网格用户的基础设施成本。</p><p></p><p>Ambient Mesh能同时支持Sidecar数据平面架构和无Sidecar数据平面两种架构，因此我们可以根据应用程序的需求来选择其中一种或两者。在Istio 1.16中，Sidecar得到了增强，以支持<a href=\"https://istio.io/latest/blog/2022/introducing-ambient-mesh/#building-an-ambient-mesh\">HBONE</a>\"&nbsp;（HTTP-Based Overlay Network Environment），因此它们可以通过<a href=\"https://www.solo.io/blog/understanding-istio-ambient-ztunnel-and-secure-overlay/\">ztunnel</a>\"（零信任隧道，提供安全覆盖层）或/和waypoint代理（提供第7层处理层）与无Sidecar应用程序进行互操作，这些应用程序也需要能理解HBONE。</p><p></p><h2>Ambient无Sidecar的优势</h2><p></p><p></p><p>Ambient的最大优势是它不需要对应用程序进行任何更改，这就是它被称为ambient的原因。Ambient无Sidecar数据平面被设计成对应用程序是透明的，例如，不需要为应用程序改变CI/CD管道，也不需要在数据平面出现新漏洞（基于Envoy的waypoint代理或基于Rust的ztunnel，更多详细信息请参阅下文）时重启应用程序。除了不需要更改应用程序外，无Sidecar数据平面还消除了Istio的许多Sidecar<a href=\"https://istio.io/latest/docs/ops/deployment/requirements/\">应用程序要求</a>\"，如服务器发送优先协议、无法支持Kubernetes Jobs或保留的sidecar端口列表，从而扩大了对应用程序的支持。</p><p></p><p>Ambient中的两层（安全覆盖层和L7处理层）数据平面方式允许我们更好地逐步采用Ambient无Sidecar数据平面，而不是全有或全无sidecar注入。我们可以从安全覆盖层开始，同时享受该层带来的所有好处，比如具有加密身份的mTLS、简单的第4层授权策略和遥测。在没有任何L7处理的情况下，安全覆盖层显著地减少了CVE和其他补丁的攻击面和更新数据平面的频率。两层架构使我们能够根据所需付费，并独立于工作负载扩展服务网格数据平面，从而降低了基础设施的成本。</p><p></p><h2>Istio Ambient的开发有什么新动向?</h2><p></p><p></p><p>Istio团队正在努力将Ambient Mesh作为下一个Istio版本的一部分，我们已经建立了ztunnel和ambient<a href=\"https://github.com/orgs/istio/projects\">项目委员会</a>\"来跟踪我们的进展，并衷心欢迎来自社区的贡献。所有Ambient Mesh贡献者会在<a href=\"https://github.com/istio/community/blob/master/WORKING-GROUPS.md#working-group-meetings\">美国东部时间每周三的下午1点开会</a>\"，讨论新的设计文档或贡献者的任何担忧。以下是我想强调的两大变化：</p><p></p><h3>基于Rust的ztunnel</h3><p></p><p></p><p>当Istio的Ambient服务网格于2022年9月7日发布时，ztunnel组件是使用Envoy代理实现的，因为我们想让每个人都能尽早安装并探索Istio的Ambient Mesh。在最初发布后不久，社区评估了ztunnel是应该继续使用Envoy还是应该用Rust从头开始重写，John Howard开始了<a href=\"https://github.com/istio/ztunnel/\">基于Rust的ztunnel项目</a>\"。关于如何简化基于Envoy的ztunnel，并消除对内部监听器的需求，我们进行了大量的思考，但最终，社区决定加入基于Rust的ztunel项目，原因如下：</p><p>Rust天生适合做高性能、低利用率的网络代理。Ztunnel提供的安全覆盖层，其功能和攻击面都大大减少了，因此与全特性代理相比，它更容易编写。Rust有丰富的库可供使用，包括<a href=\"https://tokio.rs/\">Tokio异步运行时</a>\"。Rust有一个明确的CVE流程可供我们利用。最后但同样重要的是，与Envoy不同，Rust通过其Tokio库原生支持工作窃取（work stealing）。这对于ztunnel有效地重用连接非常重要。</p><p></p><p>想要了解更多关于基于Rust的ztunnel与基于Envoy的ztunel的决定，请参阅<a href=\"https://istio.io/latest/blog/2023/rust-based-ztunnel/\">这篇博客文章</a>\"，其中详细解释的我们想法。</p><p></p><h3>只包含目的服务的waypoint代理</h3><p></p><p></p><p>当Istio的Ambient服务网格最初发布时，waypoint代理配置比ztunnel配置更容易理解，因为它只处理共享同一服务帐户的工作负载，例如每个服务帐户一个waypoint代理。然而，waypoint代理配置仍然非常复杂，因为源waypoint代理知道Kubernetes集群中的所有其他服务，而不管这些服务是否是实际的目的服务。</p><p></p><p><img src=\"https://imgopt.infoq.com/articles/istio-ambient-mesh/en/resources/2Image-1-1678453126032.jpeg\" /></p><p></p><p>图1：源waypoint代理能感知所有的其他服务（此处只展示了无Sidecar服务，但它们也可能是网格外服务的Sidecar）</p><p></p><p>Istio v1.1中引入的<a href=\"https://istio.io/latest/docs/reference/config/networking/sidecar/\">Sidecar</a>\"资源通常用于Istio环境中，以减少Envoy Sidecar的配置，从而提高Envoy Sidecar的性能和资源利用率。当我们开始评估是否需要为waypoint代理（也是基于Envoy的）支持Sidecar资源时，我们意识到我们可以通过提供一个仅支持目的服务的waypoint代理即可大幅削减waypoint代理的配置。</p><p></p><p>通过只关注目的服务的waypoint代理，waypoint代理配置仅需包含非常有限的动态集群、端点和路由相关的详细信息即可，其中waypoint代理需要连接到这些动态集群、端点和路由，而无需将所有潜在连接到其运行的Kubernetes集群中的任何服务的详细信息都包含内。这一更改有效地消除了对waypoint代理支持Sidecar资源的需求，也避免了用户手动配置Sidecar资源。</p><p></p><p><img src=\"https://imgopt.infoq.com/articles/istio-ambient-mesh/en/resources/3image2-1678453126032.jpeg\" /></p><p></p><p>图 2：目的waypoint知道目的服务，但不知道其他服务</p><p></p><p>例如，在我的Kubernetes集群中，我将sleep、helloworld和httpbin应用程序以无Sidecar的形式部署在了default命名空间中。我还将httpbin应用程序与Sidecar一起部署在foo命名空间中。</p><p></p><p><img src=\"https://imgopt.infoq.com/articles/istio-ambient-mesh/en/resources/4image3-1678453126032.jpeg\" /></p><p></p><p>图3：在没有Sidecar的情况下部署的helloworld、httpbin和sleep应用程序，以及foo命名空间中使用Sidecar部署的httpbin</p><p></p><p>以下是foo命名空间中httpbin的sidecar的路由配置，这与源waypoint代理非常相似，因为两者都知道所有其他服务的路由：</p><p></p><p><img src=\"https://imgopt.infoq.com/articles/istio-ambient-mesh/en/resources/4image4-1678453126032.jpeg\" /></p><p></p><p>图4：httpbin的sidecar路由配置</p><p></p><p>相比之下，以下是httpbin大大减少了waypoint代理的路由配置。请注意，在foo命名空间中没有与helloworld或sleep应用程序或httpbin应用程序相关的路由。虽然这里使用动态路由作为示例，但与Sidecar相比，动态集群和端点也减少了仅限于目的的waypoint代理。</p><p></p><p><img src=\"https://imgopt.infoq.com/articles/istio-ambient-mesh/en/resources/1Iamge5-1678453126032.jpeg\" /></p><p></p><p>图5：httpbin的waypoint代理路由配置</p><p></p><p>只包含目的服务的waypoint代理意味着不会包含任何的源waypoint代理。如果没有源waypoint代理，如果我们的目的服务没有waypoint代理（例如AWS Lambda服务），并且我们想在连接到目的服务时添加弹性，会发生什么呢？</p><p></p><p>在这种情况下，我们需要一个出口网关或专用代理来处理出口流量。这个代理的优点在于，它将包含一个精简的列表，其中列出了我们需要连接的外部服务，而不会出现前面提到的臃肿配置问题，也不需要使用Sidecar资源或目的服务中的 networking.istio.io/exportTo 注解来修剪不必要的配置。</p><p></p><h2>Ambient无Sidecar模式这么好，那Sidecar呢？</h2><p></p><p></p><p>Sidecar不会很快消失，我们可以继续使用Sidecar，只要我们觉得舒服，或者仅仅是因为我们已经从安全团队那里获得了所有的必要批准。即使Ambient无Sidecar已经成熟了，我预计Sidecar仍将继续在以下用例中发挥重要作用：</p><p></p><p></p><h3>1. 源服务需要特定的客户端配置</h3><p></p><p></p><p>对于只包含目的服务的waypoint，waypoint就像是目的服务的网关，其中waypoint代理实现流量管理和政策执行功能。这也意味着所有源服务共享相同的实施，缺乏配置特定于客户端配置覆盖的能力。在Istio的VirtualService资源中，我们可以使用sourceLabels配置特定于给定源的故障注入或重试或超时的覆盖；例如，<a href=\"https://istio.io/latest/docs/reference/config/networking/virtual-service/#HTTPFaultInjection-Delay\">仅为带有标签“env:prod”的客户端pod添加HTTP故障注入</a>\"。</p><p></p><p>如果我们的特定源服务想要对重试/超时/故障注入/负载均衡器配置执行客户端覆盖，该怎么办呢？我们可以使用Sidecar，它能为每个客户端提供细粒度的配置覆盖，这样我们的客户端就不需要使用目的服务提供的默认值了。</p><p></p><p><img src=\"https://imgopt.infoq.com/articles/istio-ambient-mesh/en/resources/1Image6-1678453126032.jpeg\" /></p><p></p><p>图6：Source1使用Sidecar进行配置覆盖</p><p></p><p></p><h3>2. 目的服务需要特定于目的工作负载的策略</h3><p></p><p></p><p>waypoint代理是按服务帐户或名称空间来设计的；对于共享同一服务帐户的服务来说，如果其需要比服务帐户更细粒度的配置，该怎么办呢？例如，对于共享同一个服务帐户的Destination1服务和Destination2服务来说，Destination1服务需要特定的Telemetry或WasmPlugin或RequestAuthentication或EnvoyFilter配置，而Destination2服务不需要。当我们需要比每个服务帐户更细粒度的特定于目的服务的配置时，我们可以继续使用Sidecar。或者，我们可以使用自己的服务帐户为Destination1创建一个专用的waypoint代理，而不是使用Sidecar代理运行。</p><p></p><p><img src=\"https://imgopt.infoq.com/articles/istio-ambient-mesh/en/resources/3image7-1678453126032.jpeg\" /></p><p></p><p>图7：使用Sidecar在Destination 1服务上执行特定于目的服务的策略</p><p></p><p></p><h3>3.Sidecar和无Sidecar可以共存和互操作</h3><p></p><p></p><p>Sidecar和无Sidecar的起始边界是在命名空间级别，在命名空间级别上，我们可以通过istio.io/dataplane mode=ambient命名空间标签将一个或多个特定的命名空间定义为sidecar-less。当sidecar注入标签与命名空间上的ambient sidecar-less标签共存时，sidecar注入标签总是获胜。这种设计确保了我们可以根据特定的业务需求轻松地从Sidecar迁移到无Sidecar，或者从是无Sidecal迁移到Sidecar。</p><p></p><h2>Istio Ambient Mesh的未来</h2><p></p><p></p><p>Istio社区正在为Ambient Mesh做很多令人兴奋的事情。Ambient Mesh已经从实验分支中分离出来，<a href=\"https://istio.io/latest/blog/2023/ambient-merged-istio-main/\">并合并到了上游的主干上</a>\"，这样它就可以很容易地与即将发布的Istio 1.18或更新版本一起安装。我们正在继续发展Ambient Mesh，以提高其性能、可扩展性和可调试性，正如上述基于Rust的ztunnel和仅包含目的服务的waypoint代理的更新所显示的那样。随着社区致力于使Ambient Mesh生产成为Istio的默认产品，我们邀请你共同参与这一旅程，请在Istio&nbsp;<a href=\"https://istio.slack.com/\">Slack</a>\"或<a href=\"https://github.com/istio/istio\">GitHub</a>\"的ambient频道中提供反馈或贡献，以帮助我们共同塑造Ambient Mesh。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/istio-ambient-mesh/\">https://www.infoq.com/articles/istio-ambient-mesh/</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/iyuaBJ1GmJ3xwk8uJQLf\">国内首例社区双栈Istio方案落地经验，实现代码已开源</a>\"</p><p><a href=\"https://www.infoq.cn/article/qMrc8W6ZtODZyb7214wv\">在 Istio 中使用 Kata 容器注入工作负载</a>\"</p><p><a href=\"https://www.infoq.cn/article/stCMjmTuODmzZmGzaNUr\">再见 Sidecar：eBPF 能抢过 Istio 服务网格的风头吗？</a>\"</p>",
    "publish_time": "2023-06-08 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]