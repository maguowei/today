[
  {
    "title": "解读Go语言的2022：泛型时代开启",
    "url": "https://www.infoq.cn/article/W8pG2j0kB9JVKkluM5BO",
    "summary": "<p>作者 | 郝林</p><p>编辑 | 蔡芳芳</p><p></p><p>本文是 “2022 InfoQ 年度技术盘点与展望” 系列文章之一，由 InfoQ 编辑部制作呈现，重点聚焦 Go 语言在 2022 年的重要进展、动态，希望能帮助你准确把握 2022 年 Go 语言的核心发展脉络，在行业内始终保持足够的技术敏锐度。</p><p></p><p>“InfoQ 年度技术盘点与展望”是 InfoQ 全年最重要的内容选题之一，将涵盖操作系统、数据库、AI、大数据、云原生、架构、大前端、编程语言、开源安全、数字化十大方向，后续将聚合延展成专题、迷你书、直播周、合集页面，在 InfoQ 媒体矩阵陆续放出，欢迎大家持续关注。</p><p></p><p>之所以在这样一篇年度解读文章的标题直接提到“泛型”，是因为 Go 语言的泛型在 2022 年终于浮出了水面！并且，它在功能方面已经大致完整了。圈内的开发者们都知道，这是 Go 社区（当然包括中国的 Go 社区）多年请愿的结果。</p><p></p><p>虽然 Go 语言是 Google 公司出品并主导开发的，但它毫无疑问也是广大 Go 语言爱好者的心头肉。可以说，对于 Go 语言泛型的正式登场，至少有一半功劳属于 Go 语言的爱好者们。</p><p></p><p>肯定会有一些程序员，尤其是那些不以 Go 为主要语言的程序员会说“Go 语言的进展太慢了，其他众多新的编程语言甚至那些较老的编程语言早就支持泛型了，可 Go 语言墨迹了这么多年才搞出泛型”。确实，单就泛型这方面来说，Go 语言的脚步确实很慢，可这主要是因为 Go 语言想要做到完全向后兼容，并力求让 Go 语言的泛型完美契合其自身的精炼的编程哲学和简约的编码风格。要知道，做加法容易，而做减法却很难。不过不管怎样，Go 语言的泛型终于落地了！就连现如今清心寡欲的作者也忍不住心中的喜悦！</p><p></p><p>好了，感慨完毕，我们还是回归正题吧。下面，我们就一起从头至尾捋一捋 Go 语言在 2022 年的发展和变化，以及它将会在 2023 年如何继续前行。</p><p></p><p></p><h2>趋势概览</h2><p></p><p></p><p>Go 在今年的 11 月 10 日刚满 13 岁。它已经长大并进入了少年期，不算是一门新的编程语言了。但 Go 依然保持着非常好地向后兼容。很显然，这是一件很不容易的事。</p><p></p><p>从业界知名的编程语言排行榜 TIOBE Index 绘制的折线图来看，Go 语言的采用趋势在过去三年间基本上保持平稳。</p><p></p><p>更具体地说，根据使用情况统计，在 2020 年下半年到 2021 年上半年的这段时间里，Go 语言的使用率有略微提升，但时至今日又差不多回到了 2019 年的水平。与其在 2016 年到 2017 年间的大爆发相比，如今 Go 语言的使用率已经基本上稳定下来了。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/d6/d67faded3bb1aa56be1fa18d8be86562.png\" /></p><p></p><p>图 1 - TIOBE Index 之 Go 语言趋势</p><p></p><p>不过，就作者个人而言，感觉是有些奇怪的。按理说，Go 语言泛型的落地应该能够引起一波采用 Go 语言的小高潮，但事实上这一情况并没有出现。这可能就是“波澜不惊”的最佳诠释吧？可能因为大家都等得太久了，真到了重大的新特性来临之时却不太能兴奋得起来了。</p><p></p><p>当然了，这也可能是因为 Go 语言在应用领域方面的攻城掠地已经基本完成，而且在其优势领域的使用率已经趋于饱和。而对于那些新兴领域，比如机器学习、人工智能、机器人、元宇宙等，Go 语言还没有显著的优势，尤其是还没有杀手级框架或工具出现。在这种情况下，Go 语言在使用统计上的平稳趋势也是一种必然。</p><p></p><p>现在换一个维度，我们横向来看，Go 语言的排名相较于前两年有比较明显的提升。如下图所示。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/79/79c37fcde1522d94595e36ec3d117c25.png\" /></p><p></p><p>图 2 - TIOBE Index（2022 年 11 月）</p><p></p><p>我们可以看到，Go 语言在 2021 年年底的 TIOBE Index 排名中位于第 18 位。这低于它在 2020 年年底的排名（第 16 位），以及它在 2019 年年底的排名（第 15 位），也算是一个小谷底了。然而，在今年的年底，Go 语言的排名却大幅提升了，甚至，它已经摸到了 Top10 的边界！如果作者没记错的话，Go 语言最近一次进入 Top10 是在 2018 年的年底。如今，4 年过去了，Go 语言终于又有希望重回 Top10 了。</p><p></p><p>我们还可以看到，至今常年占据 Top10 的依然是那些老生常谈，甚至是那些老得不能再老的编程语言。相比之下，Go 语言真真切切算是年轻一派的优秀编程语言了。当然，除了 Go 语言之外，还有图形化的儿童编程语言 Scratch、Apple 公司出品的编程语言 Swift，以及近年来出尽风头的系统级编程语言 Rust。它们都很年轻，却都已经进入了 Top20，也是非常优秀的。作者也很看好它们。</p><p></p><p>在简单分析了 Go 语言在 TIOBE Index 中的排名之后，我们再来看看新晋出炉的 StackOverflow Developer Survey 2022 吧。众所周知，StackOverflow 是全球最大的编程社区和专业问答网站。它的 Developer Survey 报告属于年度总结性报告，已经有好多年的历史了，并且深受全球软件开发者的关注和喜爱。</p><p></p><p>我们下面重点说说其中与 Go 语言强相关的内容。至于其他的内容，大家如果有兴趣的话，可以点开前面的超链接仔细阅读完整报告。</p><p></p><p>在“使用率最高的编程语言（专业组）”这一栏中，Go 语言的排名是第 13 位（如下图）。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/02/02274124410f6bdfec7438d85df888ce.png\" /></p><p></p><p>图 3 – Stackoverflow Developer Survey 2022 之使用率最高的编程语言（专业组）</p><p></p><p>如果只考虑通用的跨平台编程语言的话，Go 语言仅次于 Python、Java、C++ 和 C。这与它在 TIOBE Index 中的情况是相同的。有的程序员可能会说“JavaScript 和 TypeScript 现如今也可以算是通用的跨平台编程语言”。当然，从某种角度看，我们可以这样说。但是，它们终归不是原生的通用编程语言，都需要额外的工具或框架才能够实现“通用”。因此，我们稍微严格一点，暂且不把它们计算在内。</p><p></p><p>在应用级框架和工具栏目中，作者发现 Docker 和 Kubernetes 今年依然非常火爆。作为常用的基础工具，它们深受广大软件开发者的追捧。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/07/07e21478dd0b0eef4b94bca9c30b74f1.png\" /></p><p></p><p>图 4 – Stackoverflow Developer Survey 2022 之最受欢迎的基础工具（全体组）</p><p></p><p>从上面这幅截图我们可以看出，Docker 和 Kubernetes 在当前的排名中都已经进入了 Top5。甚至，如果只考虑专业的软件开发者的话，Docker 甚至超越了 npm，拔得头筹！</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/5d/5d0d36bb207d62c86970dfbdd3fde3bf.png\" /></p><p></p><p>图 5 – Stackoverflow Developer Survey 2022 之最受欢迎的基础工具（专业组）</p><p></p><p>毫无疑问，npm 是 JavaScript 世界中 Top1 的工具，其应用是相当相当广泛的。更何况，在全世界的软件开发者当中，不论是专业的开发者还是业余的开发者，使用 JavaScript 语言的人都是最多的。所以，Docker 能够超越它真的是一件非常值得骄傲的事！</p><p></p><p>大家应该都知道，Docker 和 Kubernetes 都是使用 Go 语言开发出来的。在云计算领域，尤其是容器技术领域，它们都是绝对的王者！因此，如果你想进入云计算领域，或者想使用 Go 语言开发基于云的应用程序，那么最起码应该学会甚至熟练使用 Docker。</p><p></p><p>好啦，以上算是一个令人激动的小插曲。现在，让我们把焦点再转回到编程语言的排名上来。</p><p></p><p>在 Stackoverflow Developer Survey 的报告中，有一个非常有特色的栏目。我们经常戏称它为“爱恨交织”栏目，其原名是“Most loved, dreaded, and wanted”。</p><p></p><p>在这个栏目里，共有七万一千多名开发者回答了相应的问题。在他们当中，有 64.58% 的人喜爱 Go 语言，而有另外的 35.43% 的人憎恨 Go 语言（或者说对 Go 语言有恐惧感）。在所有为大众所熟知的编程语言当中，Go 语言排在了第 8 位。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/71/71fc7191947ddcc27fc297caa566178f.png\" /></p><p></p><p>图 6 – Stackoverflow Developer Survey 2022 之让人“爱恨交织”的编程语言</p><p></p><p>在这份排名中的 Rust、TypeScript 和 Julia 作为更加年轻的编程语言后来居上。不过，如果我们查看相邻的“最想学习的编程语言”排名的话，就会发现 Go 语言的位置靠前了很多，处于第 4 位，仅次于 Rust、Python 和 TypeScript，并且从百分比数值上来看相差无几。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/7f/7fc137b987565485845e695dd06e3242.png\" /></p><p></p><p>图 7 – Stackoverflow Developer Survey 2022 之大家最想学习的编程语言</p><p></p><p>看起来，程序员们应该都很喜欢追新，不是吗？这起码与作者的所见所闻是比较吻合的。当然了，只有那些优秀的新兴编程语言才有进入 Top10 的机会。</p><p></p><p>可以想象，Docker 和 Kubernetes 在这个“爱恨交织”栏目中肯定是名列前茅的。事实也确实如此，它们分列“Loved vs. Dreaded”一栏中的前两位。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/2f/2f8257983b3697ae7e954ecc12e6e072.png\" /></p><p></p><p>图 8 – Stackoverflow Developer Survey 2022 之让人“爱恨交织”的基础工具</p><p></p><p>而且，在“Want”一栏，它们拥有着一骑绝尘的态势。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/c6/c63950f475b2b9a6860a096b75388dd0.png\" /></p><p></p><p>图 9 – Stackoverflow Developer Survey 2022 之大家最想学习的基础工具</p><p></p><p>顺便说一句，在“爱恨交织”栏目里，同样拥有“一骑绝尘”态势的还有 Visual Studio Code（以下简称 VSCode）。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/65/65d5193c317bb8325ef4d4ed79faddb0.png\" /></p><p></p><p>图 10 – Stackoverflow Developer Survey 2022 之大家最想学习的集成开发环境</p><p></p><p>作者为什么会在这里提到 VSCode 呢？因为，在 2022 年订阅我的技术专栏的读者当中，非 gopher（gopher 的意思是 Go 语言粉丝）的人明显增多。他们问的最多的一个问题就是：“要是使用 Go 语言开发程序的话，有哪些好用的代码编辑器或者 IDE 吗？”</p><p></p><p>我的回答一般都是 VSCode 和 GoLand。</p><p></p><p>微软公司出品的 VSCode 是 Go 语言爱好者最常用的免费代码编辑器。我们使用它时，外加 Go 语言官方团队出品的 vscode-go 插件就基本上可以满足平常的需求了。</p><p></p><p>而 GoLand 是 JetBrains 公司出品的，但它收费而且价格不菲。作者在这里绝不是给 JetBrains 公司做广告，但是 GoLand 真的很贵、很好用。如果你对于配置编程工具非常不耐烦，并且预算很充足的话，那么我会强烈推荐你使用 GoLand。</p><p></p><p>顺便说一句，如果你是 Vim 那一派的话，Go 社区中也有相应的 vim-go 插件。</p><p></p><p>好了，关于 Go 语言发展趋势的整体解读，我们就暂告一段落吧。下面，我们从更新迭代的角度来看看 Go 语言在 2022 年都有哪些进展。</p><p></p><h2>年度回顾</h2><p></p><p></p><h3>支持泛型</h3><p></p><p></p><p>Go 语言在 2022 年最大的变化莫过于添加了对泛型（generics）的支持。这对于 Go 语言的广大使用者来说，也是感受最明显的变化。</p><p></p><p>早在 2022 年 2 月正式发布的 1.18 版本，Go 语言就包含了类型参数提案（即 Type Parameters Proposal）中描述的通用功能的实现。这包括了需要对 Go 语言本身进行的主要的更改。注意，这些更改是完全向后兼容的。这也是 Go 语言官方对于 Go 1.x 版本更新的一贯原则和保证。</p><p></p><p>Go 语言官方团队为此编写和修改了大量的代码。虽然这些代码并未经过超大规模的验证，但是 Go 语言团队对它们的质量和功效是非常有信心的。不过，也不排除这种可能：一些使用泛型的代码适用于 1.18 版本，但在以后的版本中会变得无效，或者说需要稍加修改才能使其有效。因为，这次为了支持泛型的改动实在是太大了。按照 Go 官方的说法，这种不完全兼容的可能性会被尽可能减小，但是无法对此做出 100% 保证。</p><p></p><p>虽然我们都喜欢 100% 确定的东西，但是万事万物都不可能有 100% 的稳定性和可预测性。尤其是，对软件开发有一定理解的朋友们肯定都知道，没有哪一个软件是没有 bug 的，也没有哪一个软件功能可以保证 100% 的正确。所以，我们需要用更加宽容的心态来看待 Go 语言的这次超大级别的更新。</p><p></p><p>实际上我们也不用太过担心。因为从 Go 语言的 issue 列表上看，泛型相关的 bug 如今也已经发现和修复得差不多了。Go 语言的泛型已经趋于稳定，我们已经可以放心地将其用在生产级代码上了。</p><p></p><p>从语法上说，Go 语言的类型参数（可以理解为“泛型”的另一种称谓）并未使用那个在其他编程语言中常见的尖括号（即“&lt;”和“&gt;”），而用的是方括号（即“[”和“]”）。这也是程序员们感受的最大一点不同。</p><p></p><p>请注意，我们在这里所说的“对泛型的支持”实际上是“对自定义泛型的支持”。因为 Go 语言内置的一些数据类型从一开始就是支持泛型的，比如：</p><p></p><p><code lang=\"go\">var map1 = map[int]string{}\n</code></p><p></p><p>或者</p><p></p><p><code lang=\"go\">var slice1 = []string{}\n</code></p><p></p><p>然而，在 Go 1.18 之前，使用者们自己编写的函数或者类型是无法添加泛型定义的。</p><p></p><p>下面重点来了。在 Go 1.18 中，对泛型的具体支持都有哪些呢？请看下文。</p><p></p><p>1. 自定义的函数声明或类型声明都可以包含类型参数。</p><p></p><p>请看如下代码：</p><p></p><p><code lang=\"go\">type Pair[K ~int, E ~string] struct {    \n    Key  K    \n    Elem E\n}\n</code></p><p></p><p>所谓的类型参数声明，其实就是对一个类型所涉及到的关联类型的泛化定义。例如，对于结构体类型中的每个字段，我们都必须分别定义其类型。这些字段的类型就是它们所属的结构体类型的关联类型。</p><p></p><p>这里的泛化定义的意思是，我们在声明一个类型的时候，并不指定它的关联类型具体是哪一个或哪几个，而只定义相应的范围。等到这个类型被实例化的时候，再由那个编写实例化代码的程序员去设定类型参数的具体信息。这样的话，我们就可以定义出更加抽象的类型，而把具体化的工作留给使用它的人。</p><p></p><p>这与“声明接口类型，并把其作为某些函数参数或变量的类型”的编程手法有着异曲同工之妙，都是为了提升代码的灵活性，并增强其扩展的能力。不过需要注意的是，类型参数的值与函数参数的值或变量的值是不同的。一个类型参数的值必须是代表了某个已存在类型的标识符（或者说类型字面量）。另外，类型参数值代表的既可以是结构体这样的具体类型，也可以是接口那样的抽象类型。而函数参数或变量的值，则必须是某个具体类型的确切值。</p><p></p><p>另一方面，Go 语言的类型参数声明与它的函数参数声明是类似的。在上述代码的方括号中，K 和 E 分别是两个类型参数的标识符，类似于函数参数的名称。而～int 和～string 则分别是两个类型参数的类型约束（type constraint），类似于函数参数的类型声明。至于在 int 和 string 的前面为什么会有“～”这个符号，我们稍后再说。</p><p></p><p>正因为结构体类型 Pair 的声明里包含了类型参数 K 和 E 的声明，所以在它的主体当中，我们自然可以自由地使用 K 和 E。如代码所示，我们把 Pair 的字段 Key 的类型声明为 K，并把字段 Elem 的类型声明为 E。这样一来，Pair 的类型参数就与其主体实现了联动。这种联动将会在我们对 Pair 类型进行实例化的时候得以体现。</p><p></p><p>2. 对于带有类型参数的函数或类型，可以通过在它们的名称后面追加方括号并指定相应的类型参数值来进行实例化。</p><p></p><p>示例如下：</p><p></p><p><code lang=\"go\">var pair1 Pair[int, string] = Pair[int, string]{\n    Key: 1,\n    Elem: \"a\",\n}\n</code></p><p></p><p>我们在这里声明了一个 Pair[int, string] 类型的变量 pair1，并把一个 Pair[int, string] 类型的值赋给了它。请注意，我们在对一个带有类型参数的类型进行实例化的时候，也必须对它的类型参数进行实例化。在这里，Pair[int, string] 中的 int 和 string 就是分别对 Pair 的类型参数 K 和 E 的实例化。</p><p></p><p>还记得吗？我们当初在声明 Pair 类型的时候，把它的类型参数列表编写成 [K ~int, E ~string]。其中，~int 是类型参数 K 的类型约束，而~string 则是类型参数 E 的类型约束。那么，这里的 Pair[int, string] 中的 int 和 string，分别作为 K 和 E 的值就是合法的，可以通过编译。至于为什么，我们马上就会说到。</p><p></p><p>先接着看其余的代码。因为在 Pair 类型的声明当中，字段 Key 的类型声明是 K，字段 Elem 的类型声明是 E。所以，在实例化 Pair[int, string] 的时候，我们自然就可以把某个 int 类型的值（这里是 1）赋给 Key，并把某个 string 类型的值（这里是\"a\"）赋给 Elem。</p><p></p><p>3. 新符号“~”已被添加到了运算符和标点符号的集合中。</p><p></p><p>我们再看 Pair 类型的声明：</p><p></p><p><code lang=\"go\">type Pair[K ~int, E ~string] struct {    \n  Key  K    \n  Elem E\n}\n</code></p><p></p><p>我们大可以把这里的符号“～”理解为“潜在”。代码“K ~int”的意思是，只要一个类型（假定为 A）的潜在类型是 int，那么就可以满足我们在这段代码中对 K 所做的类型约束，这就意味着 A 类型的字面量可以作为类型参数 K 的值。同样的道理，代码“E ~string”的意思是，只要一个类型（假定为 B）的潜在类型是 string，那么就可以满足我们在这段代码中对 E 所做的类型约束，这就意味着 B 类型的字面量可以作为类型参数 E 的值。也正因为如此，类型 Pair[int, string] 才是合乎语法规则的，它的类型参数都已通过了有效的实例化。</p><p></p><p>至于什么是“潜在类型”，Go 语言规范对此有明确的解释。具体内容是：每个类型 T 都有一个潜在类型。如果 T 是 Go 语言内置的布尔类型、数字类型、字符串类型之一，或者是某个类型字面量，那么相应的潜在类型就是 T 本身。否则，T 的潜在类型就是 T 在其声明中引用的类型的潜在类型。</p><p></p><p>下面举个例子。如果我们又编写了如下代码：</p><p></p><p><code lang=\"go\">type MyInt int\ntype MyStr string\n</code></p><p></p><p>那么，对于当前的 Pair 类型声明来说，下面的代码也是合法的：</p><p></p><p><code lang=\"go\">var pair2 Pair[MyInt, MyStr] = Pair[MyInt, MyStr]{\n  Key: 2,\n  Elem: \"b\",\n}\n</code></p><p></p><p>更确切的说，类型 Pair[MyInt, MyStr] 是合乎语法规则的。因为，从前面的说明和代码可知，MyInt 的潜在类型是 int，而 MyStr 的潜在类型是 string。它们分别符合 Pair 类型的声明里对类型参数 K 和 E 的定义。</p><p></p><p>4. 接口类型的声明中现已允许嵌入任意类型，以及由符号“｜”联结的联合类型和由~T 代表的类型元素，而不只是之前允许的其他接口类型。不过，这样的接口只能用于泛型中的类型约束。</p><p></p><p>这段话是什么意思呢？我们来详细解析一下。</p><p></p><p>为了配合 Go 语言对泛型的支持，官方团队对接口类型的声明语法做了很多的增强。</p><p></p><p>使用 Go 语言的程序员们都知道，以前的接口声明只能像下面这样：</p><p></p><p><code lang=\"go\">type Reader interface { \n Read(p []byte) (n int, err error)\n}\n</code></p><p></p><p>或者这样：</p><p></p><p><code lang=\"go\">type ReadCloser interface { \n Reader \n Close() error\n}\n</code></p><p></p><p>也就是说，在接口类型声明的主体中，我们可以嵌入任意数量的非重复的方法声明，也可以嵌入任何其他非重复的接口类型（用接口名称来代表）。我们称这两者为合法的接口元素。但除此之外，我们就不能添加任何东西了。</p><p></p><p>然而，从 Go 1.18 开始，合法的接口元素又多了一种。Go 官方把这种接口元素称为类型集合（type set）。</p><p></p><p>一个类型集合可以仅包含单独的类型（由类型的名称代表，如：T），也可以包含代表了某个潜在类型的～T，还可以是联合类型（如：T1｜T2｜T3，其中的符号“｜”可以被理解为“并集”），甚至可以是它们的混合（如：T1｜～T2｜～T3）。而且，对此我们可以分多行来写，只要它们所代表的类型是具体的且不存在重复即可。</p><p></p><p>不过要注意，包含了类型集合的接口类型只能被用在泛型相关的类型约束当中。例如，有如下代码：</p><p></p><p><code lang=\"go\">type FloatUnion interface {\n ~float32 | ~float64\n}\n\ntype FloatMaker interface {\n FloatUnion\n MakeZero()\n} \n</code></p><p></p><p>可以看到，含有类型集合的接口 FloatUnion 是可以被嵌入到其他接口类型的声明里面的（或者说，其他的接口类型可以扩展 FloatUnion 接口）。但如此一来，不但 FloatUnion 接口不能被用作任何值、变量、字段、参数、结果的类型，而且 FloatMaker 接口也会是这样。换句话说，对这种接口的用途限制具有传递性。</p><p></p><p>5. 新的内置标识符 any 是空接口的别名。它可以代替 interface{}。</p><p></p><p>这一条说得很直白。单词 any 现在属于关键字了。它代表了空接口，也就是 interface{}。但是，空接口本身的含义却因泛型支持的出现而增多了。</p><p></p><p>从 Go 1.18 开始，空接口自带类型集合，并且它的类型集合包含了所有的非接口类型。注意，这里的“所有”不但代表当前已存在的所有非接口类型，而且还囊括了将来会在程序中出现的所有非接口类型。也就是说，空接口的类型集合拥有无限多的非接口类型。</p><p></p><p>这与空接口的设立初衷是一致的，即：空接口是包罗万象的，也是类型之树的唯一树根。在 Go 语言中，任何接口都是空接口的扩展接口，任何类型都是空接口的实现类型。这样来看，任何类型，不论是抽象类型还是具体类型，都是对空接口所代表的类型空间的进一步圈定。</p><p></p><p>对于类型参数中的类型约束来说也是这样。空接口的类型集合包括了无限多的非接口类型，这使得任何类型约束所代表的类型集合都将是空接口的类型集合的一个子集。这是“进一步圈定”的另一种表现形式。因此，空接口在 Go 语言全面支持泛型之后，依然能够作为其类型系统的根基。</p><p></p><p>6. 新的内置标识符 comparable 也代表一个接口类型。</p><p></p><p>顾名思义，comparable 接口的含义是“可比较的”。只要一个类型符合以下两种情况中的一种，我们就可以断定它实现了 comparable 接口：</p><p></p><p>这个类型不是接口类型，并且它的值可以通过使用操作符 == 或 ！= 进行比较。这个类型是接口类型，而且其类型集合中的每一个类型都实现了 comparable 接口。</p><p></p><p>比如，像 int、float32、rune、string 这样的基本类型肯定都实现了 comparable 接口，而切片（slice）类型、字典（map）类型以及任何的函数类型肯定就不是 comparable 接口的实现类型。</p><p></p><p>再比如，我们在前面声明过的 FloatUnion：</p><p></p><p><code lang=\"go\">type FloatUnion interface { \n ~float32 | ~float64\n}\n</code></p><p></p><p>可以确定它肯定实现了 comparable 接口。但如果我们把其中的~float64 替换为~[]float64，那么它就不再是 comparable 接口的扩展接口了。</p><p></p><p>请注意，comparable 接口，以及任何直接或间接地嵌入了（或者说扩展了）comparable 的接口都只能被用于类型约束。它们不能被用作任何值、变量、字段、参数、结果的类型。</p><p></p><p>显而易见，与 any 接口一样，comparable 接口也是专门为了类型参数（或者说泛型）才引入的。同样的，comparable 接口也自带了类型集合。它的类型集合包含了所有可以被比较的类型。这样的类型既可以是已经存在的，也可以是尚未出现的。</p><p></p><p>除了上述 6 个很重要的改动之外，Go 团队还为使用者们准备了 3 个实验性质的代码包。这些代码包并不在 Go 标准库当中，而是位于 Go 语言官方专门设立的实验包 golang.org/x/exp 里。这意味着，它们的 API 并不在 Go 1.x 的兼容性保证范围之内。并且，随着 Go 团队对泛型支持的进一步深入，这些代码包也可能会发生非向后兼容的变化。具体如下：</p><p></p><p>代码包 golang.org/x/exp/constraints：其中包含了对泛型编程非常有用的一些类型约束，如 constraints.Ordered 接口等等。代码包 golang.org/x/exp/slices：其包含了不少对于切片操作非常有用的函数。而且，对于这些函数所操作的切片，其元素类型可以是任意的。比如，泛型函数 func BinarySearch(x []E, target E) (int, bool)、func CompactS ~[]E, E comparable S、func SortE constraints.Ordered 等等。从这些函数的签名上我们就可以看出，它们的通用性都得益于泛型。这样的通用性在 Go 语言支持泛型之前都是不可能存在的。代码包 golang.org/x/exp/maps：与 golang.org/x/exp/slices 包类似，其中包含了一些针对字典的非常通用的泛型函数，如：func ClearM ~map[K]V, K comparable, V any、func CloneM ~map[K]V, K comparable, V any M、func KeysM ~map[K]V, K comparable, V any []K 等。</p><p></p><p>真正了解 Go 语言的程序员们肯定都知道，Go 团队经常会向 golang.org/x/exp 包中放入一些实验性的代码。他们往往会通过这种方式来实现一些或新鲜或激进的想法。如果某些代码在这里通过了使用者们的检验，并被认为已经足够成熟，那么它们就有希望被添加到 Go 语言的标准库当中。Go 团队正是依靠这种渐进式升级的方式，在保证标准库稳定的同时，使其创新性得以延续。</p><p></p><p>再说回泛型。尽管 Go 语言团队为了泛型做了如此多的工作，但到目前为止，Go 语言的泛型实现仍然存在一些小限制（主要体现更加细致的编程语法、值成员访问等方面）。不过，这些小限制在大多数情况下并不会妨碍我们在应用程序中使用泛型。而且，Go 语言团队也已经预告将在未来的版本中对此进行改进。所以，作者就不在这里一一列举了。</p><p></p><p>到这里，相信大家已经有所体会，“支持泛型”可以说是 Go 语言正式发布以来最大、最复杂且最重要的一项变化了。很显然，Go 语言本身的泛型支持工作离彻底完成还有一小段距离。而对于 Go 语言的技术社区来讲，更加重要的是，这项变化将意味着 Go 语言生态系统的大规模翻新。</p><p></p><p>到目前为止，Go 语言的生态系统已经非常庞大。因此，Go 语言的这项变化将会给 Go 社区带来很可观的压力。那些 Go 程序员们常用的第三方开发框架和工具必然需要一定的时间才能够跟进这项变化，而完美契合这项变化也许还需要更多的时间。这其实也是 Go 团队当初在考虑“是否添加泛型支持”的时候，涉及到的一个很重要的负面因素。</p><p></p><p>但无论如何，Go 语言在这件事情上的第一步（也是非常重要的一步）已经迈出并平稳落地了。我们现在只希望，Go 语言以及 Go 语言技术社区能够在这个良好的基础之上继续稳步前行、平滑过渡。</p><p></p><h3>模糊测试</h3><p></p><p></p><p>我们都知道，Go 语言原生支持的测试已有三种，即：功能测试、基准测试（或称性能测试），以及示例测试。而从 1.18 版本开始，Go 语言本身支持的测试又多了一种，那就是模糊测试（fuzz test）。</p><p></p><p>所谓模糊测试是一种自动化测试技术，这种测试可以通过不断地调整应用程序的输入值来试图查找应用程序内部可能存在的错误，尤其是那些我们平常不太能注意到（或称边缘情况）的错误。正因为不太能注意到，所以在编写测试代码的时候，我们往往会有意或无意地忽视掉它们。这个时候，模糊测试就可以被用来查缺补漏了。而且，这种查缺补漏也是非常重要的，特别是在面向安全的测试当中。</p><p></p><p>这里所说的模糊，其含义是对应用程序的输入值（或者说参数值）的模糊。更确切地讲，模糊测试程序会对应用代码（如函数、结构体、接口方法等）进行若干次调用。而每一次调用都会在预先准备好的语料库（corpus，此为模糊测试的专用术语）当中随机地挑选出一个条目（corpus entry），并把该条目作为参数值输入给应用代码。</p><p></p><p>请注意，模糊测试的语料库与我们熟知的普通单元测试（如功能测试、基准测试等）的测试用例在生成方面有一个很大的不同。在普通的单元测试中，测试用例都是需要我们专门去准备的。这也算是普通单元测试的一种局限性。因为测试用例的规模与我们的测试工作量是成正比的，而且起码是线性的关系。我们越想全面地测试应用代码，我们的工作量就越大。由于我们的精力和时间是有限的，而且也不可能无限期地测试下去，因此普通的单元测试在测试覆盖度方面就会存在天然的限制，而且很难突破。</p><p></p><p>而在模糊测试中，语料库的生成是自动化完成的。模糊测试程序会自动生成一定规模的语料库。而我们只需事先向它提供一个规模非常小的种子语料库（seed corpus），甚至只包含一两个条目就可以。</p><p></p><p>这个种子语料库存在的目的，只是为了指导模糊测试引擎对语料库的自动生成，比如，单个语料库条目里需要包含几个输入值，以及每个输入值都是什么类型的，诸如此类。假设，作为测试目标的函数 A 只有一个参数，那么种子语料库中的每个条目只包含一个值即可。如果作为测试目标的函数 B 有两个参数，那么种子语料库里的单个条目就应该包含两个值。以此类推。</p><p></p><p>当然了，没有任何一个工具是完美的。虽然模糊测试可以大大地节省我们的测试工作量，但它也有一个小缺点，那就是：我们无法对语料库提供的参数值进行精细的控制。更确切地说，在模糊测试的过程中，我们不能确定应用代码每次被调用时接收到的输入值具体是什么。在某些情况下，这可能会妨碍我们对应用代码返回的输出值（或者说结果值）的正确性判断。倘若确实需要，我们可能就要额外添加一些测试代码来做专门的判断了。如果这样的情况很多，那么我们可能还需要重新权衡是否一定要使用模糊测试，而不是用普通的功能测试或基准测试。</p><p></p><p>好了，到了这里，想必大家已经大致了解模糊测试是什么，以及我们大概应该如何运用它。至于具体怎样给 Go 程序做模糊测试，其实还是很简单的。它与之前已经存在的功能测试和基准测试的编写方式大同小异，我们稍微迁移一下以前的测试经验就基本上可以搞定。因此，作者在这里就不再赘述了。如果你想对此做深入了解，那么可以去访问 fuzzing landing page 以及 the fuzzing proposal。</p><p></p><h3>工作区模式</h3><p></p><p></p><p>Go 语言的工作区模式（go workspace）是建立在 Go 模块模式（go module）之上的一种项目管理模式，主要体现在 go 标准命令之中。</p><p></p><p>Go 模块模式在 2021 年发布的 Go 1.17 中已经完全稳定下来了。我们可以通过 go mod 命令来创建和管理我们的 Go 模块。如果我们开发的 Go 项目已经达到了一定的规模，那么往往就需要把它拆分成多个模块，以便让它继续保持高内聚、低耦合的状态。这对于代码和项目的维护都是相当有利的。</p><p></p><p>比如，我们有一个名叫 MyProject 的 Go 项目（同时也是一个 Go 模块）。它的存放路径是 /path/go /haolin/Demo/MyProject。现在，我们想把其中的一些基础代码分离出来，以便进行独立的开发和维护。我们仔细地抽出那些基础代码，并它们放入到了一个名叫 MyLib 的模块中，并同样存放在 /path/go/haolin/Demo 目录之下。</p><p></p><p>这两个模块分别有自己的 go.mod 文件。MyProject 模块在它的 go.mod 文件中的名称为 github.com/hyper0x/MyProject，而 MyLib 模块在它的 go.mod 文件中的名称为 github.com/hyper0x/MyLib。不过请注意，这两个模块并不实际存在于网址 <a href=\"https://github.com/hyper0x\">https://github.com/hyper0x</a>\" 之下。这里只是作为示意而已。</p><p></p><p>在这之后，我们在 MyProject 模块里导入并使用 MyLib 中的代码包。但当我们想编译 MyProject 模块的时候却发现，go 命令无法正确编译 MyProject，提示找不到 MyLib 里的那个代码包。碰到这种情况，我们需要在 MyProject 所在的路径下运行：</p><p></p><p><code lang=\"go\">$ go mod edit -replace github.com/hyper0x/MyLib=../MyLib\n</code></p><p></p><p>这条命令的主要功能是，在 MyProject 模块的 go.mod 文件中加入如下内容：</p><p></p><p><code lang=\"go\">replace github.com/hyper0x/MyLib =&gt; ../MyLib\n</code></p><p></p><p>其含义是，将本模块中的源码文件里的 github.com/hyper0x/MyLib 定位到本地的路径（即 /path/go/haolin/Demo/MyLib）之上。</p><p></p><p>做好以上准备工作后，我们再在同样的路径下运行：</p><p></p><p><code lang=\"go\">$ go get github.com/hyper0x/MyLib\n</code></p><p></p><p>其功能是，在对应的 go.mod 文件中添加相应的依赖包信息。</p><p></p><p>好了，现在我们再次编译 MyProject 模块就不会有问题了。因为我们已经把本地的 MyLib 模块正确地设置为了 MyProject 模块的依赖包。</p><p></p><p>不过，这里有一个问题，上述的 replace 指令中存在一个本地的路径。如果开发这两个模块的人不止我一个，也就是说需要通过多人协作来开发项目，那么，我这里的本地路径在别人那里就是不正确的了。因为不同的开发者几乎不可能确保把同一个项目存放在自己的计算机中的相同路径之下。我们常常称这类问题为“本地路径问题”。</p><p></p><p>这个时候，Go 语言的 workspace 模式（也就是工作区模式）就派上用场了。具体的做法是，我们在 /path/go/haolin/Demo 这个路径（也就是 MyProject 模块和 MyLib 模块的上一级目录的路径）之下运行：</p><p></p><p><code lang=\"go\">$ go work init\n$ go work use ./MyLib\n</code></p><p></p><p>这里的第一条命令的功能是，把路径 /path/go/haolin/Demo 所代表的目录设置为 Go 工作区。它会在这个路径下添加一个名为 go.work 的文件。第二条命令的功能是，让子目录./MyLib 所代表的模块成为该工作区的一个共用模块。如此一来，该工作区中的其他 Go 模块就可以直接导入并使用 MyLib 模块中的代码包了。</p><p></p><p>此外，我们还需要在 MyProject 模块所在的路径下运行命令：</p><p></p><p><code lang=\"go\">$ go mod edit -dropreplace=github.com/hyper0x/MyLib\n</code></p><p></p><p>并以此删除掉对应的 go.mod 文件中包含的那个带有本地路径的 replace 指令。由于我们前面针对（/path/go/haolin/Demo 路径所代表的）相应 Go 工作区的设置，这里的这个 replace 指令的消失并不会造成任何问题。MyProject 模块依然可以通过编译。</p><p></p><p>至此我们可以看到，由于 Go 工作区模式的出现，我们的 Go 项目无论包含有多少个模块，也无论需要多少人进行怎样的协作调试和开发，都不用担心出现“本地路径问题”。这给团队级别的项目开发，尤其是大规模的协作开发，带来了非常大的便利。我们终于不用再为此频繁地修改 go.mod 文件了。这个 Go 项目管理上的痛点终于被消除了！</p><p></p><h3>内存模型更新</h3><p></p><p></p><p>在 1.19 版本中，Go 语言的内存模型已经过了修改（详见 the Go memory model）。这使得它与其他编程语言如 C、C++、Java、JavaScript、Rust 和 Swift 使用的内存模型保持了一致。</p><p></p><p>Go 语言只提供可以保证访问顺序一致性的原子操作，而不是像其他编程语言那样使用更加宽松的形式。更确切地说，在 Go 语言中，除非直接或间接地使用了相应的原子操作，否则并发地读写共享的数据必会引发数据竞争（data race）。顺便说一句，从根本上讲，Go 语言标准库中提供的其他同步或异步的数据访问工具基于的其实都是原子操作。</p><p></p><p>随着内存模型的更新，Go 1.19 在 sync/atomic 包中加入了一些新的类型，如 atomic.Bool、atomic.Int32、atomic.Int64、atomic.Uint32、atomic.Uint64，以及 atomic.Uintptr 和 atomic.Pointer[T]。很显然，与 sync/atomic 包中原有的诸如 AddXXX、CompareAndSwapXXX、LoadXXX 之类的原子函数相比，新的原子类型可以帮助我们更加方便和彻底地运用原子操作，同时也可以避免很多容易发生的编程失误。不得不说，我们已经等待这些原子类型很久了。</p><p></p><p>到这里，作者已经对 Go 语言在 2022 年的重大更新进行了相应的说明。这其中的重中之重肯定是泛型，所以作者对此的着墨也明显更多。至于那些在作者看来不那么重要或相对较小的更新，大家可以去浏览 Go 语言官方出具的版本说明（Go 1.18 Release Notes 和 Go 1.19 Release Notes），这里就不一一列出了。</p><p></p><h2>未来展望</h2><p></p><p></p><p>实际上，与 Go 1.18 相比，Go 1.19 算是一个更新量很小的版本迭代。这主要是因为，在影响巨大的特性加入之后，Go 语言及其团队和社区确实需要一段时间去消化它。这里其实有很多的工作要做，比如：进一步评估和验证、功能调整和修补、社区推广和反馈收集、代码优化和改进、文档补全和细化，等等。</p><p></p><p>不过，在明年即将发布的 Go 1.20 当中，随着上述工作的稳步推进和趋于完善，还是有一些值得关注的新东西的。下面只列举作者认为最喜闻乐见且可能最常用的几个更新：</p><p></p><p>支持同时囊括多个其他错误值的单个错误值：届时 errors 包中会提供一个新的函数 Join，用来把多个错误值包装成一个单一的错误值。另外 fmt.Errorf 函数也将允许在其模版字符串（即第一个参数值）中出现多个（用于包装错误值的占位动词）%w。函数 errors.Unwrap 到时候也会以 []error（即 error 的切片）作为结果值的类型，而不是之前的 error，以便一次性地返回所有被包装的错误值。这无疑大大增加了错误包装代码的灵活性，并间接地加强了错误判断代码的功能。sync.Map 的增强：sync.Map 类型里将会出现几个新方法，如 Swap、CompareAndSwap、CompareAndDelete 等。这些方法将如 sync/atomic 包里的相应函数那样，可以让单一的原子操作中包含多个动作。在 sync.Map 的场景下，这将支持针对键值对的更加复杂的原子操作，如上述方法所对应的比较并更新、比较并删除等。使用过 sync.Map 的程序员们应该都知道，对于这种操作，我们在之前不得不使用额外的同步工具来保证其并发的安全性。支持从切片到数组的转换：我们都知道，把数组转换成切片很容易，只要在一个数组上执行切片操作就可以得到一个指向那个数组的切片。这样的切片就相当于一个架设在数组之上的窗口。然而，现在的 Go 语言却不支持对应的反向操作。虽然我们通过少许的魔法代码就可以实现这样的操作，但是它肯定没有“array2 := [5]int(slice1)”这样的代码方便。后者正是将会在 Go 1.20 中合法化的代码，只一行就能完成从切片到数组的转换。不过要注意，上面这小段代码只会返回 slice1 的底层数组的副本，而不是这个底层数组本身。所以，我们之后对 slice1 中元素的修改将不会影响到 array2（但肯定会继续影响到 slice1 的底层数组）。</p><p></p><p>顺便提一下。已经在 Go 社区中引发热议的代码包 arena 及其配套代码可能会在 1.20 版本中以实验特性的方式出现。作者很看好 arena，因为它可以在某些情况下大大地减少内存分配和释放的次数，从而显著减轻 GC 的压力。</p><p></p><p>在作者看来，arena 包的功能类似于 Zig 编程语言中的内存分配器（allocator）。不过相比之下，Go 语言的实现肯定是大大简化的，因为它在 Go 语言中只需起到一定的辅助作用即可。整体来看，其做法是，在需要使用大块内存时先通过 arena 包中的 API 进行显式的内存空间申请，然后再根据实时的需要对其中的子空间进行取用，最后当无需再使用这块内存的时候再利用 arana 中的 API 进行整体释放。简单来说，这属于一种“整体化分配、碎片化使用、整体化释放”的内存空间使用范式。关于它更详细的说明可参看 Proposal: arena: new package providing memory arenas。</p><p></p><p>除了上述这些，Go 1.20 还会对编译器、标准工具、标准库等方面进行诸多的改进，详情可查看 Go 1.20 Release Notes(DRAFT)。如果在你阅读这篇文章的时候，Go 1.20 已经正式发布了，那么就可以直接去看 Go 1.20 Release Notes。</p><p></p><h2>总结</h2><p></p><p></p><p>好了，我们现在来快速地总结一下。</p><p></p><p>Go 语言在 2022 年的最大更新莫过于对自定义泛型类型和泛型函数的支持。新增的模糊测试 API 和工具将显著减少程序员们的测试工作量。工作区模式让我们在同时开发多个 Go 模块，尤其是多人协作开发的时候方便了许多（解决了一个很明显的痛点）。而在内存模型方面的修改则进一步增强了 Go 语言在数据访问方面的一致性保证。</p><p></p><p>在 2023 年，Go 语言将继续全方位地优化和改进其在各个方面的功能和性能。我们在前面已经列举了 Go 官方团队在错误处理、并发编程、便捷语法、内存管理方面的计划。作者相信，这些计划将会有条不紊地进行，并在将来让 Go 语言成为更加优秀、更加流行的编程语言。</p><p></p><p>希望大家继续关注 Go 语言和 Go 技术社区，尤其是国内的 Go 技术社区。同时，作者也希望能有更多的小伙伴参与到 Go 社区的建设甚至 Go 语言本身的改进当中去。如果正在阅读本文的你还没有尝试过 Go 语言，那么别再犹豫了，赶快到这里下载 Go 语言，并开始尝试编写 Go 程序吧！</p><p></p><p>1. Go 1.18 Release Notes: <a href=\"https://go.dev/doc/go1.18\">https://go.dev/doc/go1.18</a>\"</p><p>2. Go 1.19 Release Notes: <a href=\"https://go.dev/doc/go1.19\">https://go.dev/doc/go1.19</a>\"</p><p>3. Go 1.20 Release Notes(DRAFT): <a href=\"https://tip.golang.org/doc/go1.20\">https://tip.golang.org/doc/go1.20</a>\"</p><p>4. 其他相关的 Go 语言官方文档</p><p>5. Go 语言源码及其修改记录</p><p></p><p>往期盘点文章：</p><p>1. <a href=\"https://www.infoq.cn/article/2015-review-go/?accessToken\">解读 2015 之 Golang 篇：Golang 的全迸发时代</a>\"</p><p>2. <a href=\"https://www.infoq.cn/article/2016-review-go?accessToken\">解读 2016 之 Golang 篇：极速提升，逐步超越</a>\" </p><p>3.&nbsp;<a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651000049&amp;idx=1&amp;sn=7c95c644ec604f2f58fc33a284287c58&amp;chksm=bdbef4a28ac97db400ed198031492985b3c033bed8bbaa84bca689d2bb0f828209496b8464bf&amp;scene=21#wechat_redirect\">Go 语言的 2017 年终总结</a>\"</p><p>4. <a href=\"https://www.infoq.cn/article/4LsxhHGpAG1Gq-q4KVO4\">解读 2018 之 Go 语言篇（上）：为什么 Go 语言越来越热？</a>\"</p><p>5. <a href=\"https://www.infoq.cn/article/X-Qy0Mfprf6xObsZjlV\">解读 2018 之 Go 语言篇（下）：明年有哪些值得期待？</a>\"</p><p>6.&nbsp;<a href=\"https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&amp;mid=2247499528&amp;idx=1&amp;sn=40a26b336af4f4a9f3c06bc5d5eb17ca&amp;scene=21#wechat_redirect\">解读 Go 语言的 2019：如果惊喜不再 还有哪些值得关注？</a>\"</p><p>7.&nbsp;<a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651059903&amp;idx=2&amp;sn=95df331796d9347101a70cc21d100ecd&amp;scene=21#wechat_redirect\">解读 Go 语言的 2020：变革前夜</a>\"</p><p>8. <a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651103271&amp;idx=2&amp;sn=e24fc8fff0b050bf0d90024171d8ebac&amp;scene=21#wechat_redirect\">解读 Go 语言的 2021：稳定为王</a>\"</p><p></p><p>作者简介：</p><p>郝林，国内知名编程布道者、技术社群 GoHackers 的发起人和组织者，微信公众号“螺旋码”（视频号同名）主理人。发布过多个 Go 语言技术教程，包括开源的《Go 命令教程》、极客时间的付费专栏《Go 语言核心 36 讲》，以及图灵原创图书《Go 并发编程实战》，等等。其中专栏和图书拥有数万订阅者或购买者，开源教程 star 数也有数千。另外，他还在 2020 年出版了一本名为《Julia 编程基础》的技术图书。</p>",
    "publish_time": "2022-12-27 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "PHP 8：类和枚举",
    "url": "https://www.infoq.cn/article/XkIrT3XLmZFW9XdoJS1F",
    "summary": "<p></p><blockquote>本文属于专题文章<a href=\"https://www.infoq.cn/theme/php8-article-series\">《深入浅出 PHP 8》</a>\"。根据<a href=\"https://w3techs.com/technologies/details/pl-phptps://feed.infoq.com/php8-article-series/\">w3tech</a>\"的数据，PHP仍是互联网上使用最为广泛的脚本语言之一，77.3%的网站在服务器端均使用该编程语言。PHP 8为我们带来了许多新功能与优化，具体将在本系列文章中分析。</blockquote><p></p><p></p><p>我们将在本文中总结PHP 8中类相关的新特性，包括：</p><p>枚举，在类之上的一层，用于指定一个类型可能值的枚举列表。类属性新增只读修饰符，使属性在初始化后无法被修改。构造函数参数优化，可将构造函数参数值自动分配给一个对象属性。</p><p></p><h2>只读类属性</h2><p></p><p>在诸如数值对象的情况中，开发者们常常费尽脑汁让类的属性不可变。一般来说，在构造函数中初始化属性后，该属性理论上来说不能再被修改。另一种可行手段是将属性变为私有，且只声明一个公共getter方法。这种方法虽然减少了修改的空间，但仍不能排除变更的可能性。为使类属性不变，PHP 8.1新增了对有类型的属性的只读支持，类型化的属性均可通过新的readonly关键词声明为只读。下面这段代码声明了int类型$a的只读属性，属性值仅在构造函数中设置一次。运行时脚本输出为1。</p><p></p><p><code lang=\"php\"><!--?php\nclass A {\n   public readonly int $a;\n   public function __construct(int $a) {     \n       $this--->a = $a;\n   }\n}\n$a = new A(1);\necho $a-&gt;a;\n</code></p><p></p><p>可通过以下这段赋值语句将属性修改为只读：$a-&gt;a = 2;</p><p></p><p>该语句会导致如下报错：Fatal error: Uncaught Error: Cannot modify readonly property A::$a </p><p></p><p>只读readonly属性必须有类型，尝试用这段脚本将未类型化的属性变为只读：</p><p></p><p><code lang=\"php\"><!--?php\nclass A {\n   public readonly  $a;\n   public function __construct(int $a) {        \n       $this--->a = $a;\n   }\n}\n$a = new A(1);\n</code></p><p></p><p>脚本报错信息如下：Fatal error: Readonly property A::$a must have type。</p><p></p><p>如果你想不指定只读属性的类型，可以将其声明为混合型，如：public readonly mixed $a;。</p><p></p><p>除类型限制外，readonly属性还有其他限制：只读的属性不能被声明为static，可参见下面这段脚本的演示：</p><p></p><p><code lang=\"php\"><!--?php\nclass A {\n   public static readonly int $a;\n   public function __construct(int $a) {        \n       $this--->a = $a;\n   }\n}\n$a = new A(1);\n</code></p><p></p><p>脚本报错信息如下：Fatal error: Static property A::$a cannot be readonly。</p><p></p><p>只读的属性只能在其被声明的作用域内被初始化。下面这段脚本在属性声明的作用域之外初始化了只读属性：</p><p></p><p><code lang=\"php\"><!--?php\nclass A {\n   public  readonly int $a;\n}\n$a = new A();\n$a--->a=1; \n</code></p><p></p><p>运行时脚本报错信息如下：Fatal error: Uncaught Error: Cannot initialize readonly property A::$a from global scope。</p><p></p><p>虽然也可以在初始化时为只读属性分配默认值，但这么做用处不大，因为类常量也能做到。因此，为只读属性设置一个默认值不被允许。下面这段脚本试图为一个只读属性声明默认值：</p><p></p><p><code lang=\"php\"><!--?php\nclass A {\n   public  readonly int $a=1;\n   public function __construct(int $a) {        \n       $this--->a = $a;\n   }\n}\n</code></p><p></p><p>运行时脚本报错信息如下：Fatal error: Readonly property A::$a cannot have default value。</p><p></p><p>只读属性这一功能的目的，是使一个类属性不可变。因此，只读属性在初始化之后无法通过unset()重置。下面这段脚本尝试在初始化一个只读属性后对其调用unset()：。</p><p></p><p><code lang=\"php\"><!--?php\nclass A {\n   public  readonly int $a;   \n   public function __construct(int $a) {        \n       $this--->a = $a;\n       unset($this-&gt;a);\n   }\n}\n$a = new A(1);\n</code></p><p></p><p>运行时脚本报错信息如下：Fatal error: Uncaught Error: Cannot unset readonly property A::$a 。</p><p></p><p>但在初始化之前却可以对只读属性调用unset()，比如下面这段脚本：</p><p></p><p><code lang=\"php\"><!--?php\nclass A {\n   public  readonly int $a;\n     \n   public function __construct(int $a) {\n        unset($this--->a);\n       $this-&gt;a = $a;        \n   }\n} \n$a = new A(1);\necho $a-&gt;a;\n</code></p><p></p><p>脚本运行成功，输出值为1。</p><p></p><p>简单的重新赋值或其他运算符操作都无法修改readonly属性。下面这段脚本没有通过重新赋值语句修改只读属性，而是试图对其使用增量运算符：</p><p></p><p><code lang=\"php\"><!--?php\nclass A {\n   public  readonly int $a;     \n   public function __construct(int $a) {         \n       $this--->a = $a;       \n   }\n} \n$a = new A(1);\n$a-&gt;a++;\n</code></p><p></p><p>目的一样，因此错误信息也是一样的：Fatal error: Uncaught Error: Cannot modify readonly property A::$a。</p><p></p><p>实际上，不变的仅仅是readonly的属性，不影响其中存储的对象或资源。我们可以修改任何存储在readonly属性中对象及非只读属性。这段脚本试图通过一个类型为object的只读属性$obj，设置类属性$a的数值。</p><p></p><p><code lang=\"php\"><!--?php\nclass A {\n   public int $a;\n    public function __construct(public readonly object $obj) {}\n}\n$a = new A(new stdClass); \n$a--->obj-&gt;a=1; \necho $a-&gt;obj-&gt;a;\n</code></p><p></p><p>脚本运行成功，输出为1。</p><p></p><p>PHP 8.2中将新增的只读类作为对先前只读类属性功能的扩展。如果一个类使用readonly修饰符声明，那么其中所有的类属性均默认为只读。只读类的类属性必须有类型且非静态，以下面这段脚本为例：</p><p></p><p><code lang=\"php\">readonly class A\n{\n    public int $a;\n    public string $b;\n    public array $c;\n    \n    public function __construct() {\n        $this-&gt;a = 1;\n        $this-&gt;b = \"hello\";\n        $this-&gt;c = [\n                    \"1\" =&gt; \"one\",\n                    \"2\" =&gt; \"two\",\n                   ];\n    }\n}\n</code></p><p></p><p>只读类的确有一些限制；它不能定义动态属性，只有只读类才能扩展另一个只读类。</p><p></p><h2>构造函数属性提升</h2><p></p><p>PHP 8.0中新引入的构造函数属性提升功能取代了类属性声明和初始化。具体请见下面这段脚本，类属性$pt1、$pt2、$pt3及$pt4均在Rectangle类中声明，并在类的构造函数中初始化。</p><p></p><p><code lang=\"php\"><!--?php\n\nclass Point {\n    public function __construct(\n        public float $pt = 0.0,\n    ) {}\n}\n\nclass Rectangle {\n\n  public Point $pt1;\n  public Point $pt2;\n  public Point $pt3; \n  public Point $pt4;\n\n  public function __construct(\n        Point $pt1,\n        Point $pt2,\n        Point $pt3,\n        Point $pt4,\n    ) {\n        $this--->pt1 = $pt1;\n        $this-&gt;pt2 = $pt2;\n        $this-&gt;pt3 = $pt3;\n        $this-&gt;pt4 = $pt4;\n        \n  }\n}\n</code></p><p></p><p>新增构造函数属性提升后，脚本会缩减到以下内容：</p><p></p><p><code lang=\"php\"><!--?php\n \nclass Point {\n    public function __construct(\n        public float $pt = 0.0,\n    ) {}\n}\n\nclass Rectangle {\n \n  public function __construct(\n       public Point $pt1,\n       public Point $pt2,\n       public Point $pt3,\n       public Point $pt4,\n    ) {\n         \n  }\n}\n</code--></code></p><p></p><p><code lang=\"php\">构造函数本身可以为空，在其中的语句会在构造函数入参提升至对应类属性后运行。构造函数提升至类属性所要满足的唯一条件是包含有一个可见性修改器。构造函数的参数值会自动赋给同名的类属性。</code></p><p></p><p><code lang=\"php\">下面这段使用Rectangle类的类构造函数调用的脚本示例，展示了如何自动提升并初始化公共构造函数参数至类属性：</code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><!--?php\n …\n …\n $pt1=new Point();\n $pt2=new Point();\n $pt3=new Point();\n $pt4=new Point();\n\n $a = new Rectangle($pt1,$pt2,$pt3,$pt4);\n\n// 类属性值输出为：\nvar_dump($a--->pt1);\nvar_dump($a-&gt;pt2);\nvar_dump($a-&gt;pt3);\nvar_dump($a-&gt;pt4);\n</code></code></p><p></p><p><code lang=\"php\">可以看出，脚本的确添加了类属性且被隐式初始化，其输出如下：</code></p><p></p><p><code lang=\"php\"><code lang=\"php\">object(Point)#1 (1) { [\"pt\"]=&gt; float(0) } \nobject(Point)#2 (1) { [\"pt\"]=&gt; float(0) } \nobject(Point)#3 (1) { [\"pt\"]=&gt; float(0) } \nobject(Point)#4 (1) { [\"pt\"]=&gt; float(0) }\n</code></code></p><p></p><p><code lang=\"php\">如果构造函数参数不包含可见性修改器，则不会被正确提升至对应类属性。但并不是所有构造函数参数都需要被提升。以下这段脚本中参数$pt4没有声明可见性修饰符，因此也没有构造器参数提升。</code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><!--?php\n \nclass Point {\n    public function __construct(\n        public float $pt = 0.0,\n    ) {}\n}\n\nclass Rectangle {\n \n  public function __construct(\n       public Point $pt1,\n       public Point $pt2,\n       public Point $pt3,\n       Point $pt4,\n    ) {\n       \n  }\n}\n</code--></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">同理，调用Rectangle类构造器并输出类属性值。但这个例子中因为$pt4没有可见性修饰器，没有被提升至对应类属性，所以结果不尽相同。我们会得到一个警告信息：Warning: Undefined property: Rectangle::$pt4</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">需要像下面这段脚本中一样，明确声明并初始化$pt4类属性：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php \nclass Point {\n    public function __construct(\n        public float $pt = 0.0,\n    ) {}\n}\n\nclass Rectangle {\n \n  public Point $pt4;\n\n  public function __construct(\n       public Point $pt1,\n       public Point $pt2,\n       public Point $pt3,\n       Point $pt4,\n    ) {\n       $this--->pt4=$pt4;\n  }\n}\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">这样，我们就可以和之前一样调用构造函数，并得到一样的类属性输出结果。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">类构造函数参数被提升至对应类属性还需要满足的另一个条件是，构造函数不能是可调用类型。下面这段脚本声明了一个可调用类型的构造函数参数：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass Rectangle { \n  \n  public function __construct(\n       public callable $pt1,\n       public callable $pt2,\n       public callable $pt3,\n       public callable $pt4,\n    ) {\n        \n  }\n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">脚本运行时会生成一条错误信息：Fatal error: Property Rectangle::$pt1 cannot have type callable。</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">在PHP 8系列的首篇文章中，我们分析了如何在初始化器中使用new的操作符，以及如何为函数参数初始化默认值。new操作符同样可被用于设置构造器参数的默认值以及构造器属性提升，如下面这段脚本所示：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass Point {\n    public function __construct(\n        public float $pt = 0.0,\n    ) {}\n}\n\nclass Rectangle {\n  public function __construct(\n       public Point $pt1=new Point(),\n       public Point $pt2=new Point(),\n       public Point $pt3=new Point(),\n       public Point $pt4=new Point(),\n    ) {\n         \n  }\n}\n</code--></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">这个Rectangle类的构造函数可以在没有任何构造函数入参的情况下被调用，并输出提升后的类属性值：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">$a = new Rectangle();\nvar_dump($a-&gt;pt1);\nvar_dump($a-&gt;pt2);\nvar_dump($a-&gt;pt3);\nvar_dump($a-&gt;pt4);\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">object(Point)#2 (1) { [\"pt\"]=&gt; float(0) } \nobject(Point)#3 (1) { [\"pt\"]=&gt; float(0) } \nobject(Point)#4 (1) { [\"pt\"]=&gt; float(0) } \nobject(Point)#5 (1) { [\"pt\"]=&gt; float(0) }\n</code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\">在define()中使用对象</code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\">内置define()函数可用于定义命名常量。随着PHP 8.1的出现，对象也可以传入define()，如下面这段脚本所示：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass Point {\n    public function __construct(\n        public float $pt = 0.0,\n    ) {}\n} \n\ndefine(\"PT1\", new Point(1.0));\nvar_dump(PT1); \n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">脚本输出为：object(Point)#1 (1) { [\"pt\"]=&gt; float(1) }。</code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">类常量可被声明为final</code></code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">PHP 8.1中，允许使用final关键字声明类常量。除此之外，如果一个类常量在类中被声明为final，那么任何其的扩展类都不能覆盖或重新定义该常量的数值。在下面这段脚本中，类常量c在类A中被声明为final，但又在扩展类A的类B中被重新定义：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\nclass A\n{\n    final public const c = 1;\n}\nclass B extends A\n{\n    public const c = 2;\n}\n</code--></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">脚本运行后会出现以下报错信息：Fatal error: B::c cannot override final constant A::c。</code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">特殊的::class常量可用于对象</code></code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">从PHP 8.0开始，特殊的::class常量不仅允许在编译时进行绝对类名的解析，也可用于类对象。区别在于类名解析出现在运行时的对象中，而类则用于编译时解析。将::class用于对象等同于对对象调用get_class()。下面这段脚本对类A中的一个对象使用了::class，输出为“A”：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php \nclass A {\n} \n$a = new A();\nprint $a::class;\n?-->\n</code></code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\">接口常量可被覆盖</code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\">从PHP 8.1开始，接口常量可以被继承的类或接口覆盖。在下面这段脚本中，接口常量c被同名的类常量覆盖，用于覆盖的常量值可以相同也可以不同。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\ninterface A\n{\n    public const c = 1;\n}\n\nclass B implements A\n{\n    public const c = 2;\n\n   public function __construct() { \n        \n   }\n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">两个常量值均可被输出：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">echo A::c;\necho B::c;\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">1\n2\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">但如果接口常量被声明为final则不能被覆盖，这一点与被声明为final的类常量同理。下面这段脚本试图覆盖一个被声明为final的接口常量：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\ninterface A\n{\n    final public const c = 1;\n}\n\nclass B implements A\n{\n    public const c = 2;\n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">脚本运行会输出下面这段错误信息：Fatal error: B::c cannot override final constant A::c。</code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">自动加载函数__autoload()被移除</code></code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">在PHP 7.2.0中被废弃的__autoload()函数在PHP 8.0中被移除。如果调用__autoload()则会输出下面这段错误信息：Fatal error: Uncaught Error: Call to undefined function __autoload()。</code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">枚举</code></code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">缩写为enum的枚举，是用于声明一个具有明确可能值的一个新增自定义类型功能。语言结构enum可用于声明一个枚举，最简单的枚举可以为空：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">enum FirstEnum {\n}\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">一个enum可以通过case关键字声明可能值，比如：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">enum SortType {\n  case Asc;\n  case Desc;\n  case Shuffle;\n}\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">因为枚举与类这二者的相似性，相关讲解会一同进行。</code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\">为什么说枚举与类相似</code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\">枚举即为类。示例中的枚举SortType是一个类，其中的可能值均为类的对象实例。枚举与类、接口、特征共用相同的命名空间。枚举与类均可自动加载。每个枚举值，如SortType枚举中的Asc、Desc及Shuffle均为对象实例。枚举值的实例可以通过object的类型检查。枚举值或case名称在内部表示为类常量，因此区分大小写。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">枚举在诸如以下几类的场景中非常有用：</code></code></p><p><code lang=\"php\"><code lang=\"php\">对系列常量的结构化替代；数据建模；单体式编程；定义领域模型；不支持的数值无法显示，可减少代码测试的验证工作。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">下面我们会配合示例对枚举进行探讨。枚举值本身是对象，因此对象能用的地方枚举值也能用，其中就包括函数的参数类型和返回类型。在下面这段脚本中，函数的参数类型和返回类型均为枚举SortType。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nenum SortType  \n{\n \n  case Asc;\n  case Desc;\n  case Shuffle;\n \n}\nclass A {\n\n  public function sortType():SortType{\n    return SortType::Asc;\n  }\n \n}\n$a=new A();\nvar_dump($a--->sortType());\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">脚本的输出为：enum(SortType::Asc)。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">和系列中的首篇文章一样，我们还是使用数组排序的例子。sortArray函数的类型是SortType枚举类型。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">function sortArray(SortType $sortType) { \n\n  $arrayToSort=array(\"B\", \"A\", \"f\", \"C\");\n  …\n  …\n}\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">枚举对象的数值可用==操作符比对：if ($sortType == SortType::Asc){...}。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">同样的例子但使用枚举，效果如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\nenum SortType {\n  case Asc;\n  case Desc;\n  case Shuffle;\n   \n}\n \nfunction sortArray(SortType $sortType) { \n\n$arrayToSort=array(\"B\", \"A\", \"f\", \"C\");\n\n    if ($sortType == SortType::Asc) {\n             sort($arrayToSort);\n             foreach ($arrayToSort as $key =--> $val) {\n                echo \"$key = $val \";\n             }  \n        } elseif ($sortType == SortType::Desc) {\n             rsort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  \n        } elseif ($sortType == SortType::Shuffle){\n              \n             shuffle($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  \n     }\n}\n$val = SortType::Asc;\nsortArray($val);\nsortArray(SortType::Desc);\nsortArray(SortType::Shuffle); \n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">我们的数组排序示例脚本的输出如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">0 = A 1 = B 2 = C 3 = f \n0 = f 1 = C 2 = B 3 = A \n0 = f 1 = A 2 = B 3 = C\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">因为枚举例或者说可能值是一个对象实例，因此需要配合instanceof操作符与枚举值一起使用，如：if ($sortType instanceof SortType) {...}。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">枚举值不会被转换为字符串，因此不能当作字符串使用。也就是说，如果直接用字符串入参调用sortArray()函数：sortArray('Shuffle');。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">就会导致报错：Fatal error: Uncaught TypeError: sortArray(): Argument #1 ($sortType) must be of type SortType, string given。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">所有枚举值或例均有一个name只读属性，该属性值为枚举例的名称，区分大小写。name属性可用于调试，如用这段打印语句输出“Asc”：print SortType::Asc-&gt;name; 。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">枚举值不可重复，且区分大小写。下面这段脚本中的枚举值满足这一要求：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nenum SortType  \n{\n \n  case Asc;\n  case Desc;\n  case ASC;\n \n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">但这段脚本中的枚举值有重复：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nenum SortType  \n{\n  case Asc;\n  case Desc;\n  case Asc;\n}\n</code--></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">脚本会输出以下错误信息：Fatal error: Cannot redefine class constant SortType::Asc我们在此讨论的均为基本枚举或者说纯粹枚举，纯粹枚举只会定义没有关联数据的纯粹枚举值。下面我们要讨论的另一种枚举类型被称作是回退枚举。</code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">回退枚举</code></code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">回退枚举的枚举值定义了字符串类型或int类型的标量替代，如：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">enum SortType:int {\n  case Asc=1;\n  case Desc=2;\n  case Shuffle=3;\n}\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">标量替代可以是int类型或字符串类型，但不能是二者联合的int|string，所有回退枚举值必须声明一个标量值，以这段回退枚举脚本为例：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\nenum SortType:int {\n  case Asc=1;\n  case Desc=2;\n  case Shuffle;\n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">会生成以下错误信息：Fatal error: Case Shuffle of backed enum SortType must have a value。</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">回退枚举的标量替代不能重复。下面这段脚本试图为两个枚举值声明同样的标量替代：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\nenum SortType:int {\n  case Asc=1;\n  case Desc=2;\n  case Shuffle=2;\n}\n</code--></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">脚本输出的错误信息如下：Fatal error: Duplicate value in enum SortType for cases Desc and Shuffle。</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">标量替代可以为字面值，也可以为字面表达式，如：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nenum SortType:int {\n  case Asc=1;\n  case Desc=2+1;\n  case Shuffle=3-3;\n}\n</code--></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">所有回退枚举值或回退枚举用例都有一个只读属性value，其属性值为回退枚举值的标量值。以下面这段脚本为例，打印语句会输出Desc枚举值的标量替代值：print SortType::Desc-&gt;value;。</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">这里的value是只读属性且不可修改。下面这段脚本试图给回退枚举值的value属性赋值为一个变量的引用：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">$sortType = SortType::Desc;\n$ref = &amp;$sortType-&gt;value;\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">这段赋值语句会输出以下错误信息：Fatal error: Uncaught Error: Cannot modify readonly property SortType::$value 。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">回退枚举实现了一个内部接口BackedEnum，其中包含两个方法：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">from(int|string): self：以一个回退枚举用例的标量枚举值为入参，返回对应的枚举用例。如果标量值没有对应用例则返回ValueError。tryFrom(int|string): ?self：以回退枚举用例的标量枚举值为入参，输出对应枚举用例。如果标量值没有对应用例则返回空。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">下面这段脚本展示了这两种方法的使用场景：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\n enum SortType:int {\n  case Asc=1;\n  case Desc=2;\n  case Shuffle=3;\n}\n\n$sortType =  SortType::from(1);\n \nprint $sortType--->value; \necho “<br />”;\n$sortType = SortType::tryFrom(4) ?? SortType::Desc;\nprint $sortType-&gt;value;  \necho “<br />”;\n\n$sortType =  SortType::from(\"4\");\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">1\n2\nFatal error: Uncaught ValueError: 4 is not a valid backing value for enum \"SortType\"\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">方法from()和tryFrom()使用严格和弱类型模式，默认为弱类型模式，也就意味着隐式转换。如下面这段脚本所示，用于integer的浮点和字符串值均会被转换为整数值：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nenum SortType:int {\n  case Asc=1;\n  case Desc=2;\n  case Shuffle=3;\n}\n\n$sortType =  SortType::from(1.0);\n \nprint $sortType--->value; \necho \"<br />\";\n$sortType = SortType::tryFrom(\"4\") ?? SortType::Desc;\nprint $sortType-&gt;value;  \necho \"<br />\";\n$sortType =  SortType::from(\"2.0\");\nprint $sortType-&gt;value; \n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">1\n2\n2\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">如果期望类型为int，那么传入的字符串必须要能够转换为integer，否则：$sortType = SortType::from(\"A\");这段脚本会生成下面这条错误信息：Fatal error: Uncaught TypeError: SortType::from(): Argument #1 ($value) must be of type int, string given在严格类型模式中，无法使用这种类型转换，否则会输出以下错误信息：Fatal error: Uncaught TypeError: SortType::from(): Argument #1 ($value) must be of type int, float given。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">纯粹枚举和回退枚举均有一个内部接口的UniEnum实现，提供静态方法cases()，可输出枚举的可能值或枚举情况。下面这段脚本演示了cases()的使用方法：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php  \n enum SortType  {\n  case Asc;\n  case Desc;\n  case Shuffle;\n   \n}\n \nenum BackedSortType:int {\n  case Asc=1;\n  case Desc=2;\n  case Shuffle=3;\n}\n\nvar_dump(SortType::cases());\n\nvar_dump(BackedSortType::cases());\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">输出为：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"text\">array(3) { [0]=&gt; enum(SortType::Asc) [1]=&gt; enum(SortType::Desc) [2]=&gt; enum(SortType::Shuffle) } \n\narray(3) { [0]=&gt; enum(BackedSortType::Asc) [1]=&gt; enum(BackedSortType::Desc) [2]=&gt; enum(BackedSortType::Shuffle) }\n</code></code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">枚举可包含方法也可实现接口</code></code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">无论纯粹枚举还是回退枚举，均可声明方法，这点与类的方法实例类似。枚举同样也可以实现接口，但必须在函数之外的实现接口函数。下面这段脚本类似先前的数组排序例子，但包含一个实现了接口的枚举。该枚举除了实现接口函数外，还额外实现了一个不属于该接口的函数：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\ninterface SortType\n{\n    public function sortType(): string;\n}\n\nenum SortTypeEnum implements SortType   {\n  case Asc;\n  case Desc;\n  case Shuffle;\n  \n public function sortType(): string\n    {\n        return match($this) {\n            SortTypeEnum::Asc =--> 'Asc',\n            SortTypeEnum::Desc =&gt; 'Desc',\n            SortTypeEnum::Shuffle =&gt; 'Shuffle',\n        };\n    }\n\n   public function notFromInterface(): string\n    {\n        return \"Function Not From Interface\";\n    }\n}\n \nfunction sortArray(SortType $sortType) { \n\n$arrayToSort=array(\"B\", \"A\", \"f\", \"C\");\nif ($sortType-&gt;sortType() == \"Asc\") {\n             sort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n        } elseif ($sortType-&gt;sortType() == \"Desc\") {\n             rsort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n        } elseif ($sortType-&gt;sortType() == \"Shuffle\"){\n              \n             shuffle($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n          }\n         elseif  ($sortType instanceof SortType){\n              \n             sort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  \n }\n}\n$val = SortTypeEnum::Asc;\n \nsortArray(SortTypeEnum::Asc);\nsortArray(SortTypeEnum::Desc);\nsortArray(SortTypeEnum::Shuffle);\nprint SortTypeEnum::Asc-&gt;notFromInterface(); \n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">这段脚本的输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"text\">0 = A 1 = B 2 = C 3 = f\n0 = f 1 = C 2 = B 3 = A\n0 = C 1 = f 2 = B 3 = A\nFunction Not From Interface \n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">回退枚举同样也可以实现接口并提供额外的方法，如下面这段脚本所示：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\ninterface SortType\n{\n    public function sortType(): string;\n}\n\nenum SortTypeEnum: string implements SortType\n{\n  case Asc = 'A';\n  case Desc = 'D';\n  case Shuffle = 'S';\n   \n public function sortType(): string\n    {\n        return match($this--->value) {\n            'A' =&gt; 'Asc',\n            'D' =&gt; 'Desc',\n            'S' =&gt; 'Shuffle',\n        };\n    }\n\n   public function notFromInterface(): string\n    {\n        return \"Function Not From Interface\";\n    }\n}\n \nfunction sortArray(SortType $sortType) { \n\n$arrayToSort=array(\"B\", \"A\", \"f\", \"C\");\n    if ($sortType-&gt;sortType() == \"Asc\") {\n             sort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n        } elseif ($sortType-&gt;sortType() == \"Desc\") {\n             rsort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n        } elseif ($sortType-&gt;sortType() == \"Shuffle\"){\n              \n             shuffle($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n          }\n         elseif  ($sortType instanceof SortType){\n              \n             sort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  \n    }\n} \n \nsortArray(SortTypeEnum::Asc);\nsortArray(SortTypeEnum::Desc);\nsortArray(SortTypeEnum::Shuffle);\nprint SortTypeEnum::Asc-&gt;notFromInterface(); \n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">0 = A 1 = B 2 = C 3 = f\n0 = f 1 = C 2 = B 3 = A\n0 = C 1 = f 2 = B 3 = A\nFunction Not From Interface \n</code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\">枚举可声明静态方法</code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\">枚举也可以声明静态方法。继续使用上面的数组排序例子，我们在其中声明了一个静态方法chooseSortType()，该方法可依据要排序的数组长度选择排序类型：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\nenum SortType \n{\n \n  case Asc;\n  case Desc;\n  case Shuffle;\n\n   public static function chooseSortType(int $arraySize): static\n    {\n        return match(true) {\n            $arraySize < 10 =--> static::Asc,\n            $arraySize &lt; 20 =&gt; static::Desc,\n            default =&gt; static::Shuffle,\n        };\n    }\n}\n \nfunction sortArray(array $arrayToSort) { \n \n    if (SortType::chooseSortType(count($arrayToSort)) == SortType::Asc) {\n             sort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n        } elseif (SortType::chooseSortType(count($arrayToSort)) == SortType::Desc) {\n             rsort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n        } elseif (SortType::chooseSortType(count($arrayToSort)) == SortType::Shuffle){\n              \n             shuffle($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n        }\n          \n} \n \n\n$arrayToSort=array(\"B\", \"A\", \"f\", \"C\");\nsortArray($arrayToSort); \n\n$arrayToSort=array(\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\");\n\nsortArray($arrayToSort);\n\n$arrayToSort=array(\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\");\n\nsortArray($arrayToSort);\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"text\">0 = A 1 = B 2 = C 3 = f\n0 = f 1 = f 2 = f 3 = C 4 = C 5 = C 6 = B 7 = B 8 = B 9 = A 10 = A 11 = A\n0 = A 1 = B 2 = B 3 = C 4 = B 5 = C 6 = f 7 = A 8 = f 9 = C 10 = B 11 = f 12 = f 13 = A 14 = A 15 = B 16 = C 17 = f 18 = A 19 = B 20 = C 21 = f 22 = C 23 = A \n</code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\">枚举可声明常量</code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\">枚举同样可声明常量。下面这段脚本中声明了一个常量A：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nenum SortType  \n{\n \n  case Asc;\n  case Desc;\n  case Shuffle;\n  \n  public  const A = 1;\n \n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">声明的常量可以引用枚举本身的场景，这些场景也回会是常量。下面这段数组排序脚本中使用的是在枚举中声明的常量：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\nenum SortType \n{\n \n  case Asc;\n  case Desc;\n  case Shuffle;\n\n   public const ASCENDING = self::Asc;\n   public const DESCENDING = self::Desc;\n   public const SHUFFLE = self::Shuffle;\n}\n \nfunction sortArray(SortType $sortType) { \n    $arrayToSort=array(\"B\", \"A\", \"f\", \"C\");\n    if ($sortType == SortType::Asc) {\n             sort($arrayToSort);\n             foreach ($arrayToSort as $key =--> $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n        } elseif ($sortType == SortType::Desc) {\n             rsort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n        } elseif ($sortType == SortType::Shuffle){\n              \n             shuffle($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  \n    }\n}\n\nsortArray(SortType::ASCENDING); \nsortArray(SortType::DESCENDING); \nsortArray(SortType::SHUFFLE); \n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"text\">0 = A 1 = B 2 = C 3 = f\n0 = f 1 = C 2 = B 3 = A\n0 = C 1 = B 2 = f 3 = A\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">因为枚举值本身是常量，因此明确的常量不能重新定义一个枚举的值，比如下面这段脚本中所演示的：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nenum SortType:int {\n\n  public const Asc = \"Asc\";\n  case Asc=1+1;\n  case Desc=2;\n  case Shuffle=3; \n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">脚本会输出以下这段错误信息：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">Fatal error: Cannot redefine class constant SortType::Asc </code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">枚举值必须在编译时可评估，如下面这段脚本中的枚举常量所示：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \nenum SortType:int {\n\n  const CONSTANT=4;\n\n  case Asc=1;\n  case Desc=2;\n  case Shuffle=CONSTANT;\n}\n</code--></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">会输出以下错误信息：Fatal error: Enum case value must be compile-time evaluatable。</code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">使用特质的枚举</code></code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">枚举可以使用特质（trait）。下面这段数组排序脚本声明了一个ChooseSortType特质，并在枚举中使用了该特质：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\ntrait ChooseSortType {\n\n     public function chooseSortType(int $arraySize): SortType\n    {\n        return match(true) {\n            $arraySize < 10 =--> SortType::Asc,\n            $arraySize &lt; 20 =&gt; SortType::Desc,\n            default =&gt; SortType::Shuffle,\n        };\n    }\n\n}\n\nenum SortType {\n \n  use ChooseSortType;\n\n  case Asc;\n  case Desc;\n  case Shuffle;\n}\n \nfunction sortArray(SortType $sortType, array $arrayToSort) { \n \n    if ($sortType-&gt;chooseSortType(count($arrayToSort)) == SortType::Asc) {\n             sort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n        } elseif ($sortType-&gt;chooseSortType(count($arrayToSort)) == SortType::Desc) {\n             rsort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n        } elseif ($sortType-&gt;chooseSortType(count($arrayToSort)) == SortType::Shuffle){\n              \n             shuffle($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n        }\n          \n} \n \n\n$arrayToSort=array(\"B\", \"A\", \"f\", \"C\");\n\nsortArray(SortType::Desc,$arrayToSort); \n\n$arrayToSort=array(\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\");\n\nsortArray(SortType::Asc,$arrayToSort);\n\n$arrayToSort=array(\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\");\n\nsortArray(SortType::Desc,$arrayToSort);\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"text\">0 = A 1 = B 2 = C 3 = f\n0 = f 1 = f 2 = f 3 = C 4 = C 5 = C 6 = B 7 = B 8 = B 9 = A 10 = A 11 = A\n0 = B 1 = A 2 = C 3 = f 4 = B 5 = A 6 = B 7 = A 8 = B 9 = A 10 = f 11 = A 12 = C 13 = B 14 = f 15 = f 16 = C 17 = f 18 = C 19 = B 20 = C 21 = C 22 = A 23 = f \n</code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\">枚举与类有什么区别</code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\">虽然先前我们说枚举与类相似，但这二者也有很多不同之处：</code></code></p><p><code lang=\"php\"><code lang=\"php\">枚举的序列化方式与对象不同；枚举没有状态，而类的对象则有；枚举不声明构造函数，因为不需要初始化对象；枚举不能扩展其他枚举，也就意味着没有继承；不支持对象和静态属性；枚举不能用new操作符进行实例化；打印print_r语句的输出结果与类对象不同。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">下面这段脚本中更具体地展示了这二者的差异之一，枚举不能声明类属性：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nenum SortType  \n{\n  case Asc;\n  case Desc;\n  case Shuffle;\n  \n  public $var = 1;\n} \n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">脚本的报错信息为：Fatal error: Enums may not include properties。</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">另一个差异点可以在下面这段脚本中有所体现，枚举不能被实例化：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nenum SortType  \n{\n  case Asc;\n  case Desc;\n  case Shuffle;\n}\n\n$sortType=new SortType(); \n</code--></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">脚本的报错信息为：Fatal error: Uncaught Error: Cannot instantiate enum SortType。</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">可通过下面这段脚本的print_r中纯粹枚举与回退枚举进行更直观的对比：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php  \n enum SortType {\n  case Asc;\n  case Desc;\n  case Shuffle;\n}\nenum BackedSortType: int {\n  case Asc = 1;\n  case Desc = 2;\n  case Shuffle = 3;\n}\n\nprint_r(SortType::Asc);\nprint_r(BackedSortType::Desc);\n</code--></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">输出为：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"text\">SortType Enum ( [name] =&gt; Asc ) \nBackedSortType Enum:int ( [name] =&gt; Desc [value] =&gt; 2 )\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">枚举也可以声明一个__toString方法。下面这段脚本在Stringable接口中实现了枚举，并给出了__toString方法的实现。</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nenum SortType implements Stringable \n{\n  case Asc;\n  case Desc;\n  case Shuffle;\n   \n  const ASCENDING = SortType::Asc; \n     \n  public function __toString(): string {\n        return \"\";\n  }\n   \n}\n   \necho SortType::ASCENDING;\n</code--></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">脚本报错信息为：Fatal error: Enum may not include __toString。</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">本文中，我们探讨了PHP 8中大部分与类相关的功能，其中包括枚举、新增类属性只读修饰符，以及构造函数参数提升。在系列文章的下一篇中，我们将探索函数与方法相关的新功能。</code></code></code></p><p></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">原文链接：</code></code></code></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.com/articles/php8-classes-enums/\">PHP 8 - Classes and Enums</a>\"</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">相关阅读：</code></code></code></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.cn/article/XkzLrAYhV1CWPDzu72N2\">PHP 8：注解、match 表达式及其他改进</a>\"</code></code></code></p>",
    "publish_time": "2022-12-27 11:42:13",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "全栈自研“AI大底座”发布！百度智能云：智能计算基础设施正面临全面升级",
    "url": "https://www.infoq.cn/article/Ft4tqluVYC4YagxW23KT",
    "summary": "<p>12月27日，由百度智能云、中国电子技术标准化研究院主办的2022云智峰会 | 智算峰会召开。百度智能云发布国内首个全栈自研的AI基础设施“AI大底座”，并全面升级25项产品和技术。此外，搭载百度“AI大底座”全栈能力的百度阳泉智算中心正式对外开放服务，该中心是目前亚洲最大的单体智算中心。</p><p>&nbsp;</p><p>百度集团执行副总裁、百度智能云事业群总裁沈抖表示，智能化为产业创造价值的浪潮才刚开始，未来空间无限。百度智能云的“云智一体”能力已经在交通、工业、金融、政务等众多产业实践中得到了验证，目前已经可以标准化输出AI的底层能力，帮助企业实现“智能的随用随取”，真正降本增效。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/7c/7c3e9494d1b03777a724f561d65182e3.png\" /></p><p>百度集团执行副总裁、百度智能云事业群总裁沈抖</p><p></p><p>AI原生时代正加速到来，云计算产业面临“三全”变革</p><p></p><p>随着智能调度、自动驾驶、工业化联网等智能化产业应用的不断普及，中国产业正面临从数字化向智能化转移的关键窗口期。同时，大模型、AIGC等技术应用的出现，正在加速推动AI原生云的发展，这对中国的云计算产业提出了新要求。</p><p>&nbsp;</p><p>百度集团副总裁侯震宇表示，AI原生时代的加速到来，已经使得云计算产业面临“三全”变革，快速响应产业的新要求，才能把握新机遇。</p><p>&nbsp;</p><p>首先，是全面升级的智算硬件体系。AI带来更高密度的计算，AI负载占比越来越高，这就需要升级硬件体系架构，提升AI工作负载的运行效能。目前，智算硬件体系结构正在升级，多芯异构化、全面池化、微秒级互联将是未来主要发展趋势。</p><p>&nbsp;</p><p>其次，是全栈融合的智算基础设施。企业使用人工智能，需要构建新的智算基础设施，高效解决算力、算法和数据处理等多维度的问题。为了提升整体效能，就需要打造全栈融合的智算基础设施，做到全要素、端到端的优化，实现极致的资源效能和模型效能。</p><p>&nbsp;</p><p>第三，是全域泛在的智算应用场景。数据产生智能，智能穿戴设备、汽车、工厂和办公设备等智能硬件和IOT的发展，会产生海量数据，这就需要以数据为中心，构建全域泛在的智算能力，让智算无处不在，随时随地进行。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ea/ea8830cf06ba0458279e5feecee2befd.png\" /></p><p>百度集团副总裁侯震宇</p><p></p><p>针对云计算产业的三大变革，百度智能云全面升级25项产品和技术。在基础设施层面，百度发布国内首个全栈自研的AI基础设施“百度AI大底座”，发布百舸AI异构计算平台2.0。在硬件层面，升级百度太行DPU、百度自研AI芯片“昆仑芯”。</p><p>&nbsp;</p><p>侯震宇表示，昆仑芯已经量产数万片，实现了大规模的商业化落地。百度内部已经部署到搜索、小度、自动驾驶、爱奇艺等业务，百度外部也已经在金融、工业等客户的业务中使用。目前7nm昆仑芯2代相比1代，性能提升了2到3倍，性价比优于国外同级别芯片，昆仑芯3代也已经启动研发。</p><p>&nbsp;</p><p>百度发布国内首个全栈自研的AI基础设施“AI大底座”</p><p></p><p>随着大模型、AIGC为代表的AI应用不断成为行业热议话题，AI原生时代正在加速到来，这对云计算的基础设施提出了新要求：全栈融合（需要提供芯片、框架、模型、应用在内的全栈方案）、端到端优化、提供极致的资源效能和模型效能，成为未来智能计算发展的三大主流方向。</p><p>&nbsp;</p><p>但企业在构建云计算基础设施时，面临两大痛点：企业在用云时，需要把大量时间精力花在构建基础设施上，且这样的基础设施大多是拼凑组合的，没有发挥出最佳的性能和效率；基础设施中的核心部分，比如芯片、深度学习框架、大模型，需要大规模投入才能做好，一般企业无力支付巨额的研发成本。</p><p>&nbsp;</p><p>针对行业痛点问题，百度智能云今日发布国内首个全栈自研的AI基础设施“百度AI大底座”，面向企业AI开发和应用提供端到端自主可控、自我进化的解决方案，让企业可以快捷、低成本地实现“AI能力的随用随取”。</p><p>&nbsp;</p><p>“百度AI大底座”由AI IaaS层（百舸AI异构计算平台）、AI PaaS层（AI中台）两大部分组成。在AI IaaS层，整合百度自研的AI芯片“昆仑芯”，在AI计算、存储、加速、容器方面进行系统优化，提供高性价比的算力，承载海量数据的处理、超大模型的训练和推理。在AI PaaS层，整合百度两大核心自研产品（飞桨深度学习框架、百度文心大模型），打通百度的样本中心、模型中心、AI开发平台、AI服务运行平台，实现从数据存储到模型训练、生产、部署、测试的全链路、批量化生产，面向企业模型开发的全生命周期提供完整解决方案。</p><p>&nbsp;</p><p>简单来说，“百度AI大底座”是百度各项底层AI技术的集大成者，&nbsp;通过AI底层技术的通用化、模块化，实现AI服务的规模化，其目的本质上是帮助企业降本增效。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/75/7527f14bd29335a931d07bdd92e0da6b.png\" /></p><p>百度智能云今日发布：国内首个全栈自研的AI基础设施“百度AI大底座”</p><p></p><p>“AI大底座就是要帮助客户从上云，进入到用数、赋智的快车道，极大降低AI产业应用的门槛，提升效率，而企业只需要把精力聚焦在场景业务上。”沈抖说。</p><p>&nbsp;</p><p>今年9月，百度智能云推出“云智一体3.0”全新架构。整体来看，百度自研的AI技术上下贯穿了行业场景和基础底座，通过打造行业标杆应用，形成诸如智能客服、数字人等标准化的AI通用产品，进一步带动和沉淀AI PaaS 层和 AI IaaS 层的能力，打造高性价比的异构算力和高效的 AI 开发运行能力，从而形成云智一体、螺旋上升的业务模式。</p><p>&nbsp;</p><p>百度阳泉智算中心将全面对外开放</p><p></p><p>近年来，随着自动驾驶、生命科学、智能制造等领域的迅速发展，以及超大规模AI计算对算力的需求不断提高，智算中心作为人工智能产业发展的重要底层基础设施形态，成为当前政府和大型企业加速智能化升级的重要建设热点。</p><p>&nbsp;</p><p>基于百度AI大底座，百度发布“智算中心解决方案”，该解决方案涵盖物理数据中心建设能力、智算基础设施“AI大底座”、百度软硬件生态能力，可以帮助政企客户打造普惠算力平台、科技孵化平台、人才培养平台和产业聚集平台。</p><p>&nbsp;</p><p>同时，百度阳泉智算中心正式对外开放。百度副总裁谢广军表示，阳泉智算中心搭载了“百度AI大底座”全栈能力，是目前已建成的亚洲最大单体智算中心，算力规模达4EFLOPS(每秒400亿亿次浮点运算)，可满足各行业超大规模AI计算需求。此外，阳泉智算中心平均PUE低至 1.08，绿色低碳程度处于行业领先水平。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/75/7574c2854289afae690dd43a38eeeb21.png\" /></p><p>百度副总裁谢广军</p><p></p><p>除了智算中心解决方案，“百度AI大底座”已经在智能驾驶、智慧城市、金融、能源等领域实现大规模应用。</p><p>&nbsp;</p><p>在金融领域，依托百度智能云AI大底座，中国邮储银行构建了国内大型商业银行中首个落地的全行范围统一机器学习平台“邮储大脑”，建成全行机器学习平台 。上线应用后，对信用卡亿级别样本的数据清洗和数据分析时间从月级别、周级别压缩至小时级别，大大提升了最繁重的数据处理工作效率。在智能风控领域，已支持了300多个信用评级、用户风险画像等相关模型的构建，实现了以天为周期的模型迭代，并通过自动化将审批时间缩短到秒级。目前，邮储银行的AI平台已经运行100多项AI能力, 支撑18个业务系统。</p><p>&nbsp;</p><p>在电力领域，国家电网通过百度AI大底座建设“两库一平台”智能基础设施（“两库”指模型库、样本库，“一平台”指包含运行环境和训练环境的人工智能平台），在输电端构建起安全隐患识别模型、知识管理平台。在巡检一线，无人机接到工作人员指令后，可自主完成输电线路巡检作业。基于AI的智能识别算法将识别准确率提升了30个百分点，识别效率提升了5倍。在变电站，运维人员从线上接入智能调控系统，采用“一键顺控”操作，无需人员到场便可完成千伏变电站的倒闸操作，效率提升了40—60倍，启动送电时间缩短了80%。</p><p>&nbsp;</p><p>在自动驾驶领域，通过AI大底座，企业中工具链的开发者，不必再花大量精力在AI基础设施的构建上，通过端到端优化，使得自动驾驶常用的算子训练和推理的速度平均提升了100%，研发迭代效率提升100%。</p><p>&nbsp;</p><p>“智能化为行业创造价值的浪潮才刚刚开始，这就需要云计算厂商标准化地输出智能化的底层能力，把芯片、大模型、深度学习框架等高门槛的技术，变成像水电能一样供客户按需取用。”沈抖说。</p>",
    "publish_time": "2022-12-27 12:30:33",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "融云任杰：激活组织生命力 让听见炮火的人做决策",
    "url": "https://www.infoq.cn/article/cT2otUHy1jfND2j3er69",
    "summary": "<p></p><blockquote>任杰，融云联合创始人兼首席科学家，TGO 鲲鹏会（北京）学员；曾就职于微软和神州泰岳等公司，在微软两次获得全球杰出员工奖，曾负责中国联通搭建 WAP 网关、增值业务管理平台；在神州泰岳期间，带领飞信产品研发团队，从 0 到 1 完成中国移动飞信系统研发，业务峰值达到 3.8 亿注册用户；2016 年加入融云，历任 CPO、CTO 等职位，现任融云首席科学家。</blockquote><p></p><p></p><p>与这个时代的很多程序员一样，任杰的代码人生也是从游戏开始的。一款操纵矿车挖金子的古早小游戏，成功引起了任杰对计算机的好奇，他开始自学编程并在后来选择了宁夏大学的计算机专业。</p><p></p><p>1998 年任杰毕业，彼时国内互联网正值从基础设施向应用设施传导的黄金年代，任杰南下深圳进入中国移动，负责营账系统和增值业务平台研发，正式开启了通信行业旅程。</p><p></p><p>后来，他又辗转来到北京，进入了微软担任咨询顾问，专门负责电信行业。这个时期，网络技术突飞猛进，人们越来越习惯使用即时通讯软件进行沟通，尤其是在办公场景，即时通讯应用大有赶超邮件之势。也是在这个时期，任杰第一次接触<a href=\"https://xie.infoq.cn/article/ba20436c9bb6fa1416d5fc569\"> IM 即时通讯</a>\"，为央视打造了一款即时通讯产品。</p><p></p><p>2008 年，任杰加入了飞信团队，出任 CTO。他带领的技术团队从最初的 400 人发展到 1000 多人，完成了对即时通讯的原始技术和运营经验积累。</p><p></p><p>种种因素导致飞信这款国民级应用遗憾折戟，成为一代人的回忆。但一群因飞信凝聚在一起的通信人，决定把这份印记延续下去。这就是包括任杰在内的融云创始团队，他们从飞信出师，创办了通信服务品牌<a href=\"https://baike.baidu.com/item/%E8%9E%8D%E4%BA%91/18702677?fr=aladdin\">融云</a>\"，以行业首创的即时通讯 PaaS 服务出发，并在市场和客户的需求变化中突破自己不断进化。</p><p></p><h2>让星星之火成燎原之势 创业者的关键使命</h2><p></p><p></p><p>2014 年，融云以原中国移动飞信技术团队为核心，打造 To B 市场的通信云服务平台，推出了面向开发者的 IM 即时通讯 SDK。创业初期团队都认为，IM 的需求是泛行业市场的，各行业的沟通都离不开通信云服务。但看似广阔的市场里，需求热度高低不同，融云要在开放性的环境下，找到准确方向。</p><p></p><p>在几个高热度方向试水实践后，任杰和团队发现，并非所有行业都有强需求。“比如，旅游行业专注旅游资源和线路设计，房地产行业更关注房源，他们虽有少量沟通需求，但不是非常迫切。”</p><p></p><p>最终，融云明确了社交、泛娱乐的主战场，它们对 IM 有着强烈需求，且用户数量足够多。这是融云在互联网公有云市场的主要阵地，并且至今仍然是融云的主力市场之一。</p><p></p><p>而后，融云一边持续优化 IM 服务体验，一边开拓其他服务内容，比如 RTC 实时音视频 SDK，以及后来的推送、审核、美颜、白板等一系列通信周边能力。以“IM+RTC+X”的完整通信解决方案为基础，融云推出了语聊房、直播、超级群、1V1、<a href=\"https://xie.infoq.cn/article/758c1d4459288e3a55bd926f5\">元宇宙</a>\"、游戏等解决方案，服务出海开发者对创新场景的探索。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/a0/a9/a0a5d5188d29bd259901c3f8c141cca9.png\" /></p><p></p><p>2018 年，融云将自己于公有云市场沉淀的标准能力，内化为支持本地部署的私有化通信技术中台，以通信中台赋能政企协同办公产品，跟随客户进行了大量细分场景的业务沉淀。</p><p></p><p>据《2022 年中国政企数智办公平台行业研究报告》显示，2021 年数智办公平台市场规模已达 74 亿元，增速达 22.1%。随着移动化办公渗透加深带来的第一轮建设和政企内部需求升级引导的第二轮建设，预计市场在未来 3 年将以 20% 的复合增速增长。</p><p></p><p>过往的深厚积累，让融云能够对市场的需求做出敏锐响应。近期融云推出了“百幄”数智办公平台，让公司丰富的产品结构和创新的服务模式最终成型。任杰表示，“作为管理者，最重要的责任便是在各种星星之火的机会中找到燎原之势。”</p><p></p><h2>从幕后到台前 直面中大型组织客户</h2><p></p><p></p><p>不同于以往以技术“赋能”的形象，融云要亲自下场以高度产品化的“百幄”从幕后走到台前，深入政企办公业务，直面中大型组织客户。“百幄”以高频使用的内部通讯切入，以工作台为入口，围绕政企办公领域涉及到的人、工作、知识、业务、场景，将各类办公服务串联在一起，具备应用聚合能力的统一办公平台。</p><p><img src=\"https://static001.infoq.cn/resource/image/25/4d/252f7f986f2dd932b7bbaf64b8dc424d.png\" /></p><p></p><p>任杰表示，2018 年起，融云便以通信中台能力赋能千行百业的办公场景，主要交付方式是作为通讯模块被集成于办公等各种系统中。而随着数字化转型和国产化大潮的推进，政企对办公平台的需求发生了极大转变。</p><p></p><p>首先，经过多年发展的党政军国央企，大部分经历了整个发展周期，每个阶段都会建设符合当时需求的信息化系统，所采用的技术方案、部署方式也都带有明显的阶段性特色。这带来两个结果：一是政企内部“烟囱”丛生形成一座座数据孤岛，各系统服务能力的交叉又造成了资源的浪费，政企需要可以融合多个系统的统一办公平台；二是政企的信息化现状和组织结构、流程规则各不相同，需要能灵活满足自己数字化转型需求的定制化产品，而不是一个通用型产品。</p><p></p><p>其次，国产化大潮下，政企对信息安全的重视程度与日俱增，而办公通信又是其中最核心的部分。这就要求服务商在国产化适配方面有一定的积累，而对信创生态的长期适配，恰恰是融云作为技术服务厂商的专有坚持。</p><p></p><p>在这种背景下，融云推出了“百幄”数智办公平台，通过改变政企独立建设、相互割裂的业务系统搭建方式，提供统一的身份认证、统一的消息待办通知以及统一的业务应用入口，可以有效提升政企办公效率。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/cc/57/cc5e970bb4594775b15fffde5b363157.png\" /></p><p></p><p>任杰强调，除了提高效率，数智化办公平台的本质目的是要使组织更具韧性。这就强调平台要满足中大型组织的大规模并发需求，应对政企复杂组织结构跨层级、跨地域、跨系统、跨部门、跨业务的协同和管理挑战，且需具备安全和灵活属性。</p><p></p><p>在高并发、高可用能力方面，融云的通信模块具有全员使用、高频调用的特点，在高并发、高可用的架构能力方面天然具有性能优势；在信息安全方面，融云支持私有化部署，支持国密加密，完成了对所有主流国产化方案的适配，支持信创基础环境下的政企办公平台搭建等；“百幄”的模块化和组件化产品结构，可适配政企的个性化需求，为不同行业提供数智化协同办公综合解决方案。</p><p></p><h2>创新与包容文化 让团队向未来出发</h2><p></p><p></p><p>从 IM 即时通讯到 RTC 实时音视频，从关注社交泛娱乐的互联网市场到聚焦办公的政企市场，融云稳定的组织能力和快速响应市场需求的能力，得益于公司文化中对创新和包容的强调。</p><p></p><p>在团队氛围方面，融云崇尚开发性思维，“开放性思维，即能够自我否定、听取别人意见的能力”，这是任杰心目中关键人才的核心素养。“我们现在面对的情况异常复杂，需要得到足够多的信息和事实来辅佐判断。”</p><p></p><p>在人才方面，比起经验，融云更关注经历。任杰进一步解释道：经验更多反映一个人的技能图谱，而经历是看一个人的思维逻辑、方法沉淀，包含了人们在面对困难时的选择、面对失败时的收获，这些更加重要。</p><p></p><p>而在企业文化上，融云推行鼓励创新，尽可能为团队提供一个相对自由的发展空间。“我本人也比较崇尚让听见炮火的人做决策，所以在融云，一线同学也有比较大的自由决策权。”比如，“百幄”非常重要的一个设计就是场景化 Kit，这是其保持灵活性的关键，设计思路就源于团队在贴身服务政企客户中，观察到的不同客户对产品细节需求差异特点。</p><p></p><p>在任杰眼中，唯有一只能打硬仗、打胜仗的团队，方能使公司行稳致远，并通过持续深耕以优化未来布局。</p><p></p><p>今后，融云的研发重点会聚焦在更大组织容纳的方向。事实上，随着数据量的逐级增加，即使是看起来和原来类似的功能，其背后蕴藏的算法和系统架构设计的复杂程度却是呈指数级上升的。因此，为了适应政企组织的大规模人员和高复杂架构不断发展的需求，融云将会在技术层面继续投入，突破通讯录、视频会议等产品的数量限制。</p><p></p><p>而建设生态体系一直都是融云一项面向未来的重要举措，因为丰富的生态体系可以让公司沿着自身核心能力实现战略性延伸。任杰表示，未来融云将继续牵手广大合作伙伴，打造通信云服务生态体系，为用户构建一站式解决方案</p><p></p><p>报名获取《2022 年中国政企数智办公平台行业研究报告》：<a href=\"https://www.huodongxing.com/event/4678344664123?qd=tgokph\">https://www.huodongxing.com/event/4678344664123?qd=tgokph</a>\"</p><p></p>",
    "publish_time": "2022-12-27 13:54:59",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "吴恩达：2022年，AI创造了这些奇迹",
    "url": "https://www.infoq.cn/article/B4AzyxVV8HUgokkL5CML",
    "summary": "<p></p><p></p><blockquote>吴恩达在圣诞节当天发布了一年一度的年终盘点，他从纯技术的角度出发，回顾 AI 科技在 2022 年创造出的那些奇迹。在过去的一年，AI 技术取得了巨大进步，生成式 AI 成为新一轮投资的热门去向，人工智能生成的文本、图像甚至是代码已经无处不在。Vision Transformer（ViT）在 2022 年同样迎来爆发式增长，今年之内有超 17000 篇 ViT 论文发布。研究人员突破了语言模型的边界，希望解决可信度、偏见和可更新性等老大难问题。</blockquote><p></p><p></p><p></p><h2>来自吴恩达的一封信</h2><p></p><p></p><p>亲爱的朋友们，大家好：</p><p></p><p>随着新年的临近，又到了寒冬肆虐的时候。但于 AI 来说，如今的我们绝非身处寒冬，而是热浪席卷的盛夏。</p><p></p><p>如今 AI 创造出的大部分经济价值集中在监督学习工具方面，即经过训练即可生成各类短标签（垃圾邮件 / 非垃圾邮件）乃至一系列标签的集合（例如音频转录文本）。今年，建立在监督学习技术之上的生成式 AI 也掀起新一波浪潮，让 AI 得以生成复杂且引人注目的丰富输出，包括自然顺畅的图像或文本段落等。</p><p></p><p>虽然强化学习等前一阶段的新工具未能带来与炒作声量相符的成果，但生成式 AI 确实表现良好，也成为 AI 应用领域的又一崭新范例。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/fd/fd78811ec8fab5cf233bab1bb071cd63.png\" /></p><p></p><p>更重要的是，监督学习所发挥的还只是其全部潜力中的一小部分。相信还有数以百万计的监督学习潜在应用尚未成为现实。目前全球无数团队仍在尝试通过监督学习找到产品开发的最佳实践。</p><p>相信在新的一年乃至更久远的未来，生成式 AI 将继续腾飞，为每个人创造更多价值。我有幸能够生活在这个科技飞速发展的时代，也欣慰于有机会参与其中创造未来，更为自己能与各位好友分享这个瞬息万变的世界而高兴不已！</p><p></p><p>新年快乐&nbsp;</p><p>你的朋友，Andrew</p><p></p><p></p><h2>2022：令人眼花缭乱的 AI 之年</h2><p></p><p></p><p>相信很多朋友正一手端着咖啡，一手跟 ChatGPT 闲聊，想让它为自己的亲朋好友推荐几样新年礼物。回顾这一年，AI 技术无疑取得了巨大进步。无论是目前已经颇有水准的文本、图像和代码生成能力，还是未来即将出现的视频与音乐创作前景，都让用户感到兴奋莫名。</p><p></p><p>当然，人们对于 AI 创造力的下一步进展也提出了疑问。一方面，AI 发展让更多化学与物理学模型成为可能，科学发现亦由此迎来又一股助力；而另一方面，政府则开始严格管控可用于 AI 创新的专用微处理器供应。在这个矛盾丛生、复杂多变的新时代，就让我们从纯技术的角度出发，回顾 AI 科技在 2022 年创造出的那些奇迹。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/5b/5b435dccc0570c85221eaab92bb74663.png\" /></p><p></p><p></p><h2>合成图像已无处不在</h2><p></p><p>由 AI 生成的图片正广为流传、引发争议，同时也成为新一轮投资的热门去向。</p><p></p><p>趋势背景：新一代文本到图像生成器掀起实验热潮，如今普通人也能靠语言描述快速创作出迷人的艺术作品和幻想场景。商业企业迅速将这项技术投入使用，让 AI 图像生成成为图形创作和编辑软件中的又一必备功能。</p><p></p><p>关键驱力： 凭借友好的用户界面、妙趣横生的输出结果和开放的 API 与模型，媒体生成类模型如今已经成为 AI 技术的“形象代言人”。</p><p></p><p>OpenAI 于今年 4 月发布 DALL-E 2，超过 150 万用户参与了这套模型的 beta 测试。到 9 月，DALL-E 2 模型全面开放。微软通过资助 OpenAI 获得了对该成果的独家商业所有权，并迅速将模型集成到 Azure AI 即服务平台当中。今年 7 月，各社交媒体平台上出现了大量一键式艺术创作方案，这些略显粗糙的图像背后依托的则是相对简单的 Craiyon。Stability AI 很快通过开源模型 Stable Diffusion 将 AI 图像创作推向新高潮——今年 11 月，此模型更新为 2.0 版，并最终吸引到超 1 亿美元新资本。Adobe 和照片存储业两大巨头 Getty Images 与 Shutterstock，纷纷将图像生成模型集成到自家产品和服务当中。此类程序可能根据给出的文本提示生成截然不同的结果。PromptBase 则开辟出新的市场空间，可根据描述生成有趣的文本字符串图形。</p><p></p><p>一切都很美，只是：这类模型是根据抓取自网络的图像训练而成。与大语言模型一样，它们也同样继承了线上内容中的偏见和煽动性表达方式。</p><p></p><p>Lensa AI 是一款照片编辑应用，可根据用户的自拍照生成“魔法头像”。尽管在移动应用排行榜上迅速蹿红，但其成功也伴随着不少争议——不少用户，特别是女性用户，发现该应用会刻意在输出图像中添加性化元素。视觉艺术家在线社区 ArtStation 也推出了自己的文本到图像功能。很多艺术家觉得，这种几秒钟内就能模仿艺术家个人风格的计算机程序可能威胁到他们的职业生涯，因此纷纷抵制该网站。</p><p></p><p>新闻背后：Diffusion 模型最初的输出结果只能用噪音来形容，但随后会通过一系列步骤有选择地去除低质量内容。由加州大学伯克利分校和斯坦福大学研究人员于 2015 年推出的这套模型经历了数年开发，最终成果表明其已经能够创作出足以匹敌生成对抗网络（GAN）的高水平图像。Stability AI 的 Stable Diffusion 正是以 Diffusion 模型为核心。另一方面，作为基于 GAN 的 DALL-E 的缔造者，OpenAI 也几乎在同一时间用 Diffusion 模型对自家成果进行了更新。</p><p></p><p>现状解读：新年中，相信计算机辅助创作革命将继续酝酿蓄力。生成式图像的风潮也绝不会止步于二维平面。谷歌和 Meta 今年都公布了令人印象深刻的文本到视频模型，而 OpenAI 的文本到 3D 对象也将生成速度提升到了新的量级。</p><p></p><p></p><h2>程序员的好朋友：编程助手大显身手</h2><p></p><p></p><p>软件项目进度又落后了？别怕，AI 新应用能帮忙。</p><p></p><p>趋势背景：事实证明，只要对代码做出微调，语言模型就能很快像经济丰富的开发者那样编写出软件例程……当然，输出质量仍然有待商榷。</p><p></p><p>关键驱力：AI 驱动的代码生成器正登陆各大企业，甚至小开发商和非技术人士也能轻松使用。</p><p></p><p>今年伊始，Ebay 就尝试将低代码工具交到非工程师的手中，让他们在无需 AI 或机器学习专业知识的情况下构建和部署模型。今年 2 月，DeepMind 推出了 AlphaCode。这是一款转换器，接受了 12 种编程语言共 8600 万种程序的预训练，甚至针对编码竞赛的参赛作品进行了调优。在推理阶段，它能生成上百万种可能的解决方案并过滤掉低质量的条目。最终，它在 10 场编码比赛中击败了半数以上的参赛者。今年 6 月，GitHub 开放了 Copilot 功能。这是一款能实时提供编码建议的自动补全系统，普通用户须支付订阅费方可使用，但学生和经过认证的开源开发者可以免费访问。</p><p></p><p>新闻背后： OpenAI GPT-3 语言模型的用户们早在 2020 年就发现，该模型完全可以生成能跑的代码。一年之后，OpenAI 又推出了名为 Codex 的调优版本，这就是如今 GitHub Copilot 的雏形。</p><p></p><p>一切都很美，但是： 这项技术的公开可用版本还无法编写复杂的程序。而且其输出乍看之下往往正确，但跑起来的结果却是错的。此外，Copilot 项目还身陷法律风险。针对 GitHub、OpenAI 和微软的集体诉讼认为，Codex 的训练过程违反了开源许可协议。最终判决结果很可能对文本、图像和其他媒体的生成模型产生深远的法律影响。</p><p></p><p>现状解读：AI 驱动型编码工具在短时间内还不太可能取代人类程序员，但它们确有可能顶替技术问答网站 Stack Overflow，成为开发者们最喜爱的疑难问询小助手。</p><p></p><p></p><h2>AI 之眼也在进化</h2><p></p><p></p><p>Vision Transformer（ViT）在 2022 年同样迎来爆发式增长。</p><p></p><p>趋势背景： 研究人员们在今年之内发表了超 17000 篇 ViT 论文，它们的共同主题就是：将自注意力与卷积结合起来。</p><p></p><p>关键驱力：Google Brain 的一支团队在 2020 年率先推出 Vision Transformer（ViT），此后该架构经历了持续改进。最终的努力让 ViT 获得了适应新任务的能力，同时也解决了不少此前难以克服的短板。</p><p></p><p>ViT 能够从海量数据中获得良好学习效果，因此 Meta 和索邦大学的研究人员希望能“仅”靠数百万示例数据集就让模型获得理想性能。他们使用数据增强和模型正则化等源自 transformer 模型的特定改造尝试提高性能。</p><p></p><p>韩国仁荷大学的研究人员修改了其中两个关键组件，使 ViT 更像卷积神经网络。他们首先将图像失势成具有更多重叠的小图块，之后修改了自注意力机制以关注每个图块的相邻图块、而非当前图块自身，这样模型就能了解该为相邻图块赋予均匀权重还是选择性权重。这些修改显著提高了模型准确性。</p><p></p><p>印度孟买理工学院的研究人员为 ViT 配备了卷积层。由于权重共享，卷积能够在本地处理像素、同时降低内存占用量。在准确性和速度方面，他们的卷积 ViT 也优于常规版本的 ViT 以及 Performer、Nyströformer 和 Linear Transformer 等 transformers 运行时优化方案。这种方法也得到了其他多支团队的采纳。</p><p></p><p>新闻背后：虽然不少 ViT 研究的目标在于最终取代卷积神经网络（CNN），但目前的主流趋势显然是将两者结合起来。ViT 的优势，在于它能够从大、小两个尺度考量图像内所有像素间的关系。但它的缺点是，模型需要额外的训练才能在随机初始化后融入 CNN 架构以进行学习。CNN 的局部上下文窗口（即其中只有局部像素较为重要）和权重共享（使其能够以相同的方式处理不同的图像位置）能帮助 transformers 从较少数据中学习到更多模式。</p><p></p><p>现状解读：过去一年来，Vision Transformer 的应用范围得到了极大拓展。ViT 已经能够生成真假难辨的连续视频帧，从 2D 图像序列到生成 3D 场景，并检测点云中的对象。如果没有这些成果，近期大火的 Diffusion 模型恐怕也无法达成如此惊艳的文本到图像生成进步。&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/07/07dc2f75726560ea0d87ea882417617c.png\" /></p><p></p><p></p><h2>语言模型持续扩展</h2><p></p><p>研究人员突破了语言模型的边界，希望解决可信度、偏见和可更新性等老大难问题。</p><p></p><p>趋势背景： 虽然不少 AI 实验室都想通过改进数据集和训练方法（包括训练单一 transformer 翻译上千种语言的方法）提升大语言模型的复杂度，但也有一些研究者尝试扩展模型架构，希望借此实现网络搜索、外部文档查询和更强的新信息适应效果。</p><p></p><p>关键驱力： 如今的语言模型虽然表现出强大的文本生成能力，但在辨别事实、控制“脑洞”和消除社会偏见方面仍然孱弱。研究人员正努力让语言模型的输出更值得依赖，同时减少煽动性。</p><p></p><p>2021 年底，DeepMind 提出了 RETRO，一种能从 MassivText 数据集中检索段落、并将其整合至输出中的模型。Al21 Labs 于春季推出的 Jurassic-X 引入了一套模块，包含一个计算器加一套维基百科查询系统，能够对语言模型就数学问题、历史事实等做出的回答执行事实验证。斯坦福大学和洛桑联邦理工学院的研究人员创建了 SERAC，这是一套无需重新训练、即可用新信息更新语言模型的系统。它有一套独立的系统，专门用于存储新数据并学习与之相关的查询结果，借此调整最终输出。Meta 构建的 Atlas，是一种能从文档数据库中检索信息以回答问题的语言模型。此方案于今年 8 月发布，参数量仅为 110 亿的 Atlas 在回答问题时表现甚至优于包含 5400 亿参数的 PaLM。今年晚些时候，OpenAI 对 ChatGPT 做出调优，以最大限度减少不真实、偏见性或有害性输出。由专人对该模型的训练数据质量进行排名，之后利用强化学习算法奖励模型优先生成与高排名结果相似的输出。上述发展趋势，也让人们对语言模型提出了更加微妙且动态的基准要求。为响应号召，130 多家机构在 BIG-bench 项目中展开合作，尝试联手解决通过表情符号推断电影自勉、参与模拟试验和检测逻辑谬误等一系列任务。</p><p></p><p>新闻背后：在取得进展的同时，语言模型也闹也不少乱子。Meta 公开展示的 Galactica 是一套可生成关于科学及技术主题文本的语言模型。但在 11 月开放展示短短三天，该模型就由于倾向于生成虚假信息和引用并不存在的来源而遭到关停。今年 8 月，同样来自 Meta 的聊天机器人 BlenderBot 3 则因散布种族主义刻板印象和阴谋论而快速弄臭了名声。</p><p></p><p>现状解读：这一年以来，文本生成领域的靠谱工具可谓争相涌现。相信成功的技术将在不久的未来，凭借一鸣惊人的新模型从激烈竞争市场上杀出一条新路。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/35/3549c4a2f622fb65b3a83fd9085130f8.png\" /></p><p></p><p></p><h2>是否有全能模型</h2><p></p><p></p><p>少数深度学习模型已经证明了自己解决几百种任务的能力。</p><p></p><p>趋势背景：过去一年，多任务模型的阵容也在急剧扩大。</p><p></p><p>关键驱力：研究人员突破了神经网络所能掌握的技能数量上限。他们的灵感来自大语言模型的新兴技能——例如无需架构调整就能创作诗歌加编写计算机程序，而利用文本和图像训练而成的模型也获得了在不同类型数据间找寻对应关系的能力。</p><p></p><p>今年春季，谷歌的 PaLM 在涉及语言理解和生成的数百项任务中，展示了小样本学习的最新成果。在某些情况下，其表现甚至优于经过调优的针对性模型或人类的平均水平。不久之后，DeepMind 发布了 Gato。其能够处理 600 多种不同任务，包括玩雅达利游戏、用机械手堆积木、生成图像说明等等，而且并不需要借助专用于这些任务的单独模型。该系统同时接受了各种数据集的监督训练，包括文本和图像识别、基于强化学习智能体生成动作等等。随着 2022 年接近尾声，谷歌研究人员又为机器人技术带来了类似的普适性能力。RT-1 也是一种 transformers 模型，能够引导机器人执行 700 多项任务。该系统能够将动作和图像令牌化，在近一年半的周期内利用多台机器人收集的 13 万组数据完成了训练。与原有技术相比，它在新任务、新环境和新对象上都表现出了强大的零样本适应性能。</p><p></p><p>新闻背后：欧盟拟议的 AI 法案最新草案很可能在 2023 年通过为法律。该法案将要求通用 AI 系统用户向当局注册，由官方评估其系统是否存在潜在滥用行为，并定期接受审计。该草案将通用 AI 系统定义为“执行图像 / 语音识别、音频 / 视频生成、模式检测、问答、翻译等普适性功能”，且“具有多种预期之内 / 之外用途”的 AI 系统。一些观察家批评该定义过于宽泛，相信后续真正具备通用性的新兴模型可能会促使监管机构进一步完善定义内容。</p><p></p><p>现状解读：目前能够推广至数百种不同任务的 AI 算法仍处于早期发展阶段。但 2022 年的实际进展，再次表明深度学习具备帮助我们达成这一目标的潜力。</p><p></p><p>&nbsp;原文链接：https://www.deeplearning.ai/the-batch/issue-176/</p>",
    "publish_time": "2022-12-27 14:22:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "全球招聘CTO，继出国抢订单之后浙江省开始“抢”技术大牛",
    "url": "https://www.infoq.cn/article/wPqcXFQHiFyHMNz7dGWS",
    "summary": "<p>浙江企业出海抢订单的热度还未退去，浙江媒体在全球高薪抢人才的新闻又引起了关注。12月26日，即将全新亮相的浙江省级传媒技术平台传播大脑科技公司（筹），正式宣布面向全球招聘CTO。</p><p>&nbsp;</p><p>传播大脑科技（浙江）股份有限公司（筹）由浙江省委宣传部指导筹建，由浙江日报报业集团、浙江广电集团、浙江出版联合集团、浙江文化产业投资集团四大省属文化国企共同注资成立，是一家“市场机制+国有控股+资本加持”的科技型产业公司。作为浙江省“传播大脑”，是浙江省媒体技术统一支撑平台和媒体技术统一对外出口。</p><p>&nbsp;</p><p>作为国有文化企业如此大阵仗招聘技术人才，尚属首次。</p><p>&nbsp;</p><p>通过浙江媒体发布的招聘信息，可以看到该CTO的核心任务是寻求内容与技术的耦合点，重塑人们接受信息的场景：“聚合省域有效数据，打破数据孤岛和垄断，实现数据汇聚和联接，打造全省统一全媒体智能中台和传播投放引擎”，“引领文化产业数字化改革，谋划具有鲜明‘媒体+技术’辨识度的标杆应用场景，以技术为牵引，探索数字文化创新发展模式。”</p><p>&nbsp;</p><p>目前给出的招聘要求上，给出的是年薪100~200万，并给予股权激励（拟）。其岗位职责是：</p><p>1、根据平台发展目标，参与制定公司战略，并根据战略规划公司技术发展，保持公司技术水平处于行业领先地位，塑造公司在行业中的影响力；</p><p>2、系统规划公司未来产品、现有产品技术路线，跟踪技术发展，着眼内容、运营业务，制定并组织实施关键性技术方案，组织攻克重难点技术，使技术与业务互相促进；</p><p>3、管理、激励、培养技术团队，平衡工作进度和团队能力提升。</p><p>&nbsp;</p><p>任职资格：</p><p>1、10年以上互联网研发相关工作经验，国内外知名互联网公司任职经历，对媒体、宣传文化等方向有一定的了解，工作计划性强，能承受较大的工作压力；</p><p>2、有较好的战略规划能力和项目统筹能力，主导过大型PAAS或SAAS平台、有一定复杂性的战略生成-产品技术架构-技术落地-商业化的闭环，并形成成功的完整案例；</p><p>3、有较好的技术管理能力和技术团队管理能力，架构设计、实施和团队管理工作经验丰富，有高负载、高并发、大数据量、分布式系统的业务架构、应用架构、技术架构、数据架构、运维架构设计开发经验。有较好领导能力、沟通能力、协调能力，熟悉互联网研发、运维各岗位特点；</p><p>4、有较好的学习能力、创新能力，掌握主流底层原理，熟悉相关算法，接轨国际成果，能跟踪和转化新兴领域的前沿技术；</p><p>5、有大数据、人工智能、区块链等相关工作经验者、GitHub 有开源项目贡献者优先。</p><p>&nbsp;</p><p>更多阅读：</p><p><a href=\"http://www.zgjx.cn/2022-12/27/c_1310686452.htm\">http://www.zgjx.cn/2022-12/27/c_1310686452.htm</a>\"</p><p><a href=\"https://news.hangzhou.com.cn/zjnews/content/2022-12/27/content_8434786.htm\">https://news.hangzhou.com.cn/zjnews/content/2022-12/27/content_8434786.htm</a>\"</p>",
    "publish_time": "2022-12-27 14:35:57",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "奇点已来，推进All on Serverless有哪些困难、如何破局？｜ 解读Serverless的2022",
    "url": "https://www.infoq.cn/article/GfljeKBdALpQt0KT96DH",
    "summary": "<p></p><p></p><p>从 2012 年提出 Serverless 到今年 2022 年刚好十年。</p><p></p><p>过去十年，上云是确定性趋势，在这个阶段企业一开始的关注点在于如何实现平滑上云。随着越来越多的企业上云，甚至很多企业系统第一天就是在云上构建，企业的核心关注点转变为如何更好地利用云的能力。</p><p></p><p>在新的阶段中，云服务的角色也从单纯的提供资源，变成了企业构建应用的新平台，帮助企业尽可能减小机器运维等低价值重复工作，聚焦于业务的创新。云厂商的核心能力转变为企业提供 Serverless 云服务，消除用云复杂度，用更简单的方式提高资源利用率，帮助企业降低成本。</p><p></p><p>这几年，不只是云厂商，大量的开源商业产品也采用了 Serverless 模式，包括 Confluent Cloud、MongoDB Atlas、Snowflake、Databricks 等。随着云厂商在存储、计算、中间件、大数据等领域推出越来越多的 Serverless 服务，云产品体系逐渐 Serverless 化，也推动着 Serverless 架构从概念进入到大规模生产落地阶段。2021 年 DataDog 发布 Serverless 研究报告，数据表明，从云原生初创公司到大型企业都在关注 Serverless，Serverless 生态已经超越了 FaaS，包含数十种服务，可以帮助开发人员构建更快、更动态的应用程序。</p><p></p><p>Serverless 奇点己来，所谓奇点，是由平稳发展转向高速发展的转折点，这也意味着 Serverless 在全行业的落地将全面爆发。</p><p></p><p>但与此同时，我们也看到，一方面是企业关注度不断上升、行业开始落地，另一方面，企业和开发者也对 Serverless 存在一些困惑和顾虑。</p><p></p><p>阿里云联合 InfoQ 收集了一些企业和开发者对现阶段 Serverless 的反馈，并于 12 月 16 日举办了云原生 Serverless 开发者评测局线下沙龙，邀请了阿里巴巴研究员、阿里云智能云原生应用平台负责人丁宇、阿里云 Serverless 研发团队、上海慧游文化 CEO 宋杰、德基网络科技有限公司大前端技术负责人刘晓伟以及南瓜电影、宝马等企业技术负责人，一起探讨 All on Serverless 过程中的挑战和经验，以期给更多落地 Serverless 的企业提供参考和借鉴。本文截取沙龙上的精彩发言。</p><p></p><p></p><h2>Serverless 到底是什么</h2><p></p><p></p><p>在谈论 Serverless 之前，我们先了解下，Serverless 是什么？</p><p></p><p>2012 年，Serverless 概念正式登上舞台。2016 年，首届 Serverless ConF 将这项技术的讨论推向高峰。2017 年，阿里云推出国内首个重磅 Serverless 产品服务 – 函数计算 FC（Function Compute），让开发者只需要专注于业务逻辑开发，而不是把大量精力花在服务器等基础设施的管理上，从而快速兑现业务价值。</p><p></p><p>2018 年至 19 年，伯克利连续发表两篇论文对 Serverless 做出定义，预测 Serverless 将会成为云时代的最重要的计算范式，Serverless 获得了越来越多的关注。</p><p></p><p>Serverless 是一个非常广义的概念，并不局限于计算。一般同时满足以下条件可称为 Serverless 服务。</p><p></p><p>第一、全托管服务。意味着企业使用抽象的服务化接口，而不是直接面对底层资源，也就没有安装、配置、维护或者更新软硬件的负担。全托管服务通常也提供了内置的容错、安全、可观测能力，用户通常不需要再重新构建这些能力。</p><p></p><p>第二、自适应弹性。意味着服务能够根据负载大小自动弹性伸缩，不但让系统能够支撑快速发展的业务，也大大提升了资源使用效率。</p><p></p><p>第三、按实际用量付费。意味着只需根据实际的执行时间、流量或调用次数付费，降低了成本。因此 Serverless 服务核心价值在于尽可能消除客户非功能性代码开发，简化应用基础设施管理的工作，从而实现研发效率的飞跃。</p><p></p><p>上海慧游文化 CEO&nbsp;宋杰亲历首届 Serverless Conf 现场，在他看来：Serverless 是一项非常颠覆的技术和解决方案，它和之前出现的所有技术创新都有本质区别，因为它牵涉到的核心问题是商业模式的改变。“类似于机器语言到高级语言的飞跃，一下子就简化了做企业级应用的程序员要关心的问题，复杂度大大降低”。</p><p></p><p></p><h2>Serverless 引领下一代应用架构</h2><p></p><p></p><p>Serverless 服务契合了研发模式演进的趋势，过去十年，各大云厂商都在不断将产品体系 Serverless 化。</p><p></p><p>作为最早推进 Serverless 在中国落地的阿里云，Serverless 演进的过程，也是云计算的发展历程。阿里巴巴研究员、阿里云智能云原生应用平台负责人丁宇在分享中提到，阿里云是国内最早做云计算的企业，从 2009 年成立开始，第一阶段从资源和 IaaS 开始做起，在这个阶段，很多技术被开源并开始大规模流行，包括大数据、AI、中间件等微服务和应用层的技术。</p><p></p><p>从云的角度来看，这时候云厂商和开源具有非常好的协同关系，于是在云上出现了很多全托管的云产品。从企业客户角度来看，要确保应用在云上可靠、高效的运行，上云后的复杂度是非常高的，这时企业进入到想要更好用云的阶段，对于云的进化来讲，也开始向服务化的方式演进，也就是说，云开始从提供资源逐渐转变成提供服务。在这样的背景下，阿里云逐渐走向 Serverless 服务形态，包括诞生诸如计算类、存储类、数据类、数据库类、大数据类甚至音视频类等 Serverless 的产品。</p><p></p><p></p><h3>阿里云 Serverless 演进和实践</h3><p></p><p></p><p>2017 年，阿里云推出 FaaS 产品函数计算 FC，这是一种以事件驱动为核心的全托管计算服务，用户只需编写代码并上传，函数计算就会自动准备好计算资源，以弹性、可靠的方式运行代码，并提供完整的可观测能力，大幅简化开发运维过程。第二年阿里云又推出了 Serverless 应用引擎 SAE，SAE 是业内首款面向应用的 Serverless PaaS 平台，屏蔽底层 IaaS 和 Kubernetes 的复杂度，提供了零代码改造、成本更优、效率更高的应用托管方案，帮用户实现单体 Web 应用、微服务应用以及定时任务的 Serverless 化。</p><p></p><p>同年领先业界推出 Serverless 容器服务 ASK，基于弹性容器实例 ECI（Elastic Container Instance），实现 1min 扩容 2000 个 pod，降低了 Kubernetes 使用门槛，让用户更专注应用程序，而非管理底层基础设施。</p><p></p><p>2020 年阿里云开源 Serverless Devs，成为业内首个支持主流 Serverless 服务 / 框架的云原生全生命周期管理的平台。2022 年 9 月该项目正式进入 CNCF Sandbox，也成为业内首个入选的 Serverless 工具项目。</p><p></p><p>Serverless 将云计算的粒度变得很细，企业选择是否采用 Serverless 产品不是单纯的软件问题，Serverless 背后需要有足够大的计算机集群和产品体系能力，才能保证其弹性满足企业复杂的业务需求 。阿里云提供了从容器到应用等各个层次的 Serverless 产品组合，并且坚定的推进产品体系的全面 Serverless 化。</p><p></p><p>目前阿里云已有 20 余款核心产品实现了 Serverless 化，阿里云函数计算 FC 日调用次数超过 200 亿次，有效支撑历年双 11 百万 QPS 洪峰，业务增速超过 300%，整体规模位居国内首位，经历超复杂场景的锤炼。Serverless 计算产品凝聚了阿里云在云原生领域的技术沉淀和最佳实践经验。</p><p></p><p>除了产品形态的改变之外， Serverless 同样带来了软件研发范式的改变。Serverless 云产品是模块化、可组合、高可用的，他们是构建应用的要素。通过 Serverless 计算组合多个云产品就可以快速构建应用。</p><p></p><p>Serverless 为基础，研发方式升级到组装式研发。组装式研发彻底颠覆了原有的软件研发方式，大幅提升研发效率，灵活应对业务挑战。根据权威机构调研统计，组装式研发相比传统模式，可为研发提效 50% 以上。</p><p></p><p>德基网络科技有限公司大前端技术负责人刘晓伟对 Serverless 的降本提效效果表示肯定。他说：“过去一年我们在做前端的 Serverless 升级改造。从支出成本角度来讲降低很多；从服务角度来看的话，需要分为几个方面，单一应用切成 Serverless 改造成本有适当增加，但一旦改造完成，后续开发效率就会高很多。“</p><p></p><p>这就是 Serverless 带来的价值：真正让开发者回归业务本身，让企业做得更少而收获更多。</p><p></p><p></p><h2>Serverless 推进中的困境和破局</h2><p></p><p></p><p>对于目前的 Serverless 来说，价值已经不言自明，当然，在规模化落地的道路上，Serverless 也会遇到一些阻力。企业开发者在是否采用这一问题上仍有犹豫和顾虑，认同技术趋势与实际应用落地之间存在一道无形的鸿沟。</p><p></p><p>丁宇认为：这就是一个技术发展过程中常见的现象，是符合技术发展规律的。Serverless 规模化落地需要一个契机。而这个契机已经到来。当前企业及开发者拥抱云计算更加积极，云已经成了一个创新平台。同时，更多产品具备了云特性，如自适应弹性、免运维等。从 Serverless 本身来讲，因为它足够先进，不是简单地替代互联网分布式架构，而是对互联网分布式架构的升级，从而形成了自己的一套体系，能够为企业带来很多显而易见的变化。</p><p></p><p>由于处在不同的时期，企业会有自己不同的选择，随着 Serverless 技术发展得更成熟，相信会有更多的企业愿意拥抱 Serverless，也许像互联网分布式架构一样成为主流架构还需要 5-10 年的时间，但是先行者往往是会拿到第一波红利的，这会让企业更具有竞争力。</p><p></p><p>目前，Java 语言仍占据国内后端开发主导地位，而 Java 语言的冷启动特性在函数计算上的并不友好。冷启动时长使得用户很难享受到 FC 毫秒计费，秒级扩容等特性带来的技术红利。</p><p></p><p>不久前 AWS 发布了消除冷启动的产品 SnapStart，使得冷启动再次成为热议话题。</p><p></p><p>冷启动包含了系统冷启动和应用冷启动两个部分。对于系统冷启动，阿里云在硬件、MicroVM、操作系统、语言运行时等进行了全栈优化。阿里云函数计算 FC 在系统冷启动阶段的性能指标业界领先。而应用冷启动和用户选择的语言以及程序逻辑本身有关系。比如 Java 类应用，启动时间通常远远高于 Node.js、Python、Go 等语言，阿里云内部一直在打磨这类技术，但实际应用会比较谨慎。因为 SnapStart 这类技术需要客户的应用程序对 SnapStart 进行适配，否则会出现程序正确性问题。今天 AWS 支持了这个技术，做了大量基础库、三方库的适配，虽然简化了客户的复杂度，但最终仍然需要客户自己保证正确性。因此阿里云提供了一些保证兼容性的方案，希望通过持续优化尽可能减少用户的适配负担。</p><p></p><p>目前，阿里云主要通过预留和闲置处理冷启动问题，另外，今年云栖大会函数计算 FC 发布了 vCPU 和内存解绑的策略，客户可以更精细化管理资源配比，资源利用率再一次得到优化，成本会进一步降低。</p><p></p><p>除此之外，厂商锁定（vendor lockin）也是阻碍 Serverless 规模化的一大困扰。对此，阿里云也有解法。</p><p></p><p>首先，阿里云已开源了 Serverless Devs，Serverless Devs 是一个开源开放的 Serverless 开发者平台，致力于为开发者提供强大的工具链体系。得益于功能的可插拔特性，Serverless Devs 可以非常简单的支持不同云厂商的项目部署，或者一键部署到不同云平台。</p><p></p><p>其次， Serverless 架构的理念本身是重塑应用的研发模式，云平台提供完整的 Serverless 产品体系，云平台提供一整套 Serverless 化的 BaaS 以及提供更为标准化、流程化的桥接。而 FaaS 更细粒度的业务处理拆分可以让业务代码开发更加简单，进而让企业多云方式的构建更加简单。</p><p></p><p>最后，企业采用多云方式，也不代表所有的业务都要进行多云，平均地分布在各朵云上，很多时候是在差异化的能力上选择最好的云，只有选择最合适的云、深度用云才能真正发挥云厂商的优势，获得更好的云资源。综上所述，如何做无锁定，厂商开放规范，不做限制，海纳百川，在一定程度上就是无厂商锁定。</p><p></p><p></p><h2>Serverless 未来的畅想和规划</h2><p></p><p></p><p>除了技术需要通关，思维的转变也是横亘在开发者面前的一道鸿沟。</p><p></p><p>Serverless 从技术创新走到应用再走到普及，对开发者而言最大挑战是系统设计模式和编码习惯的改变。</p><p></p><p>不少开发者对 Serverless 架构的学习都有疑问，到底是用原有开发范式还是需要学习新的范式？对于这个担忧，慧游文化 CEO&nbsp;宋杰认为：“Serverless 会对传统开发模式和逻辑实现颠覆，对成熟的开发人员而言挑战可能更大，学习成本方面，对于经验丰富的程序员来说，进入云原生世界，最大的障碍不是‘学习’，而是‘遗忘’。“</p><p></p><p>云原生技术打破了原有的限制，CPU、硬盘、内存没有大小限制。对于越是经验丰富的程序员来说，思维的转换就越是困难。“程序员要需要不断学习 Serverless，才能够克服固有的思维模式。希望阿里云能够提供更多的培训帮助大家实现思维定式的转换。”宋杰表示，这也是他对阿里云的期待。</p><p></p><p>除了提供更加全面丰富的 Serverless 产品与方案，作为 Serverless 中国的先行者，阿里云将持续拥抱开源，为 Serverless 用户提供多样化、可选择、更灵活的方式，提升开发者的幸福感。</p><p></p><p>“未来阿里云整个产品体系都将 Serverless 化，产品和产品之间的集成更加细腻，由点及面，将整个链路串联起来，普惠更多的企业和开发者。”丁宇表示。</p><p></p><p></p><p>如果你对本文感兴趣，欢迎在文末留言，或加入 InfoQ 写作平台话题讨论：<a href=\"https://xie.infoq.cn/\">https://xie.infoq.cn/</a>\"</p><p></p><p>后续，迷你书、专题将集合发布于 InfoQ 官网，登录 InfoQ 官网: <a href=\"https://www.infoq.cn/\">https://www.infoq.cn/</a>\"&nbsp;注册并将 InfoQ 添加进收藏夹，精彩不错过。</p><p></p><p>同时，InfoQ 年度展望直播周将于 2023 年 1 月 3 日首场开播，并持续输出精彩内容，关注 InfoQ 视频号，与行业技术大牛连麦~</p><p></p><p>今日好文推荐</p><p></p><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651152084&amp;idx=1&amp;sn=d8023ec4eb28f2f3b919c4f9a52a6c71&amp;chksm=bdb8a6878acf2f91bbc488edae954233014201c38c408b0a35c017a8dd7592a7423b61c038be&amp;scene=21#wechat_redirect\">解读数字化的2022：不再追求大而全的“军备竞赛”，用聚焦来提高转型“成功率”</a>\"</p><p></p><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651151985&amp;idx=1&amp;sn=f7e199f5c0bf378f3a022a2a96f7167c&amp;chksm=bdb8a6228acf2f34145084f0d0c41b51118865649917bd9b4033c9536558e54a90f742e94af6&amp;scene=21#wechat_redirect\">如何更好地干掉微服务架构复杂性？</a>\"</p><p></p><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651151916&amp;idx=1&amp;sn=05d92c39bed4dfe86cd775c13ba47d65&amp;chksm=bdb8a67f8acf2f6910cc1d768e5755ee1f848fcc62e877f400e74694e39393fd5fa545ac0e63&amp;scene=21#wechat_redirect\">争相上市、抢夺本土市场，未来三五年数据库将迎来大洗牌 | 解读数据库的2022</a>\"</p><p></p><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651151848&amp;idx=1&amp;sn=5883fa47b375748f2f856e1c2874c5a5&amp;chksm=bdb8a5bb8acf2cadddd445e7515ea8670a8aaeb12d0153cd512da8006d2b7d4fbc6ebab88c40&amp;scene=21#wechat_redirect\">颠覆开发模式的创新发布背后，我看见了云计算的下一个十年</a>\"</p><p></p>",
    "publish_time": "2022-12-27 14:47:24",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "ChatGPT爆红让谷歌慌了？内部发“红色代码”警告，CEO亲自部署重组AI业务以应对威胁",
    "url": "https://www.infoq.cn/article/lxDIGR1fQU5BRyH47mbe",
    "summary": "<p></p><p></p><blockquote>以ChatGPT为代表的新一代聊天机器人开始广泛应用人工智能，这波浪潮有望重塑甚至取代传统互联网搜索引擎。</blockquote><p></p><p></p><p></p><h2>内部发布“红色代码”、重组业务</h2><p></p><p></p><p>谷歌及其母公司 Alphabet 的首席执行官 Sundar Pichai 显然对最近爆火的 ChatGPT 很感兴趣，甚至可能有点慌了。</p><p></p><p>据悉，Sundar Pichai 正在为谷歌做好准备以应对他所感知到的威胁。</p><p></p><p>根据《纽约时报》看到的一份内部备忘录，谷歌 CEO Sundar Pichai 参与了一系列探讨谷歌 AI 战略的会议，而且为了应对 ChatGPT 带来的威胁甚至推翻了内部众多团队的原有工作，并正在从其他部门抽调员工，以应对 ChatGPT 的威胁。</p><p></p><p>谷歌还要求员工开发能够创建艺术品和其他图像的 AI 产品，这对标的明显是 OpenAI 的 DALL-E 技术。截至目前，DALL-E 已经吸引到超 300 万用户。</p><p></p><p>从现在到明年 5 月的另一场谷歌重要会议之间，谷歌公司的研究、信任与安全等部门和团队将被经历组织重整，旨在帮助开发和发布新的 AI 原型和产品。</p><p></p><p>据报道，谷歌管理层已经发布了“红色代码”警报。在硅谷，这就意味着拉响了“火警”。</p><p></p><p>一周前，谷歌的管理层回复员工的担忧，认为 ChatGPT 过快发展可能损害公司。在最近的一次全体会议上，考虑到 ChatGPT 的全面爆红，员工们对谷歌在 AI 领域的竞争优势提出了担忧。会上，这样一个问题得到员工们的普遍关注，“既然 LaMDA 一直在开发当中，这是不是代表谷歌已经错过了在聊天机器人领域占据优势的机会？”</p><p></p><p>Alphabet 集团 CEO SUndar Pichai 和谷歌 AI 部门长期负责人 Jeff Dean 回答了这个问题，他们表示谷歌其实完全有能力拿出类似的成果。只是一旦出了纰漏，谷歌这样的企业巨头无疑需要承担更高的经济和声誉成本。</p><p></p><p>全球有数十亿用户在使用谷歌的搜索引擎，而 ChatGPT 到 12 月初才刚刚突破 100 万用户。Dean 解释道，“该模型确实满足了人们的需求，但同时也要意识到，这些模型中仍然存在某些现实问题。”</p><p></p><p></p><h2>谷歌搜索业务或将迎来巨变</h2><p></p><p></p><p>过去三十年来，网景的网络浏览器、谷歌的搜索引擎和苹果的 iPhone 等几款尖端产品真正颠覆了整个科技行业，让上个世代的产品瞬间如同身陷焦油坑的笨拙恐龙。</p><p></p><p>就在三周前，名为 ChatGPT 的实验性聊天机器人在行业内再度掀起颠覆之风。它能够用清晰、简单的语句提供信息，而不再是没有任何温度的网站链接列表。它能以人们更易于理解的方式阐释概念，甚至可以从零开始产生想法，为用户提供商业策略、圣诞礼物建议、博客主题乃至假期计划。</p><p></p><p>尽管 ChatGPT 仍有很大的进步空间，但其发布已经引发谷歌管理层的高度警惕。有人担心公司可能正走向硅谷科技巨头最害怕的历史性转折点——面对可能颠覆企业的巨大技术变革，但却束手无策。</p><p></p><p>二十多年来，谷歌搜索引擎一直是全球互联网的主体门户。但随着这种有望重塑甚至取代传统搜索引擎的新型聊天机器人技术的出现，谷歌的核心搜索业务很可能面临严重威胁。一位谷歌高管甚至将此描述为决定谷歌未来命运的关键时刻 。</p><p>ChatGPT 是由激进派研究实验室 OpenAI 所发布，谷歌本身也是参与构建该技术的企业、实验室和研究方之一。但专家们认为，作为硅谷的老派大厂，谷歌可能很难与开发这类聊天机器人的其他小体量新公司竞争，最终因该项技术的发展成熟而业务受损。</p><p></p><p></p><h3>自研聊天机器人 LaMDA 的尴尬：与搜索业务“八字不合”</h3><p></p><p></p><p>谷歌已经投入数年时间研究聊天机器人，并且与其他大型科技企业一道积极追求 AI 技术。谷歌已经构建起一款能够与 ChatGPT 相媲美的聊天机器人。事实上，OpenAI 聊天机器人的核心技术就是由谷歌研究人员开发而成。</p><p></p><p>谷歌的聊天机器人名为 LaMDA，全称为对话应用语言模型，曾经在今年夏天得到极大关注。当时谷歌工程师 Blake Lemoine 甚至放出狠话，称该模型具有认知能力。虽然论断本身明显不靠谱，但该技术确实表明聊天机器人在近期之内取得了很大进步。</p><p></p><p>但谷歌可能并不打算利用这项新技术取代传统在线搜索，因为它跟数字广告“八字不合”，而数字广告占谷歌去年总体收入的 80% 以上。</p><p></p><p>专门研究硅谷历史的华盛顿大学教授 Margaret O’Mara 表示，“没有哪家企业真能天下无敌，大家其实各有软肋。对于一家已经在市场上取得决定性成功的企业来说，他们往往很难再走出一条完全不同的路线。”</p><p></p><p>由于这些新型聊天机器人所学到的技能来自互联网上发布的大量数据，所以它们其实会把虚构信息跟事实混淆起来。另外，它们提供的结论也往往包含对女性和有色人种的偏见。</p><p></p><p>在特定场景下，它们甚至会产生有毒言论，包括仇恨性表达。</p><p></p><p>所有这些都可能激起人们对于谷歌的反感，损害其数十年来苦恼建立的企业形象。相比之下，OpenAI 的行动表明新兴公司则没那么沉重的思想包袱，更愿意冒险用负面影响来换取业务增长。</p><p></p><p>而且即使谷歌最终能够完善自家聊天机器人，也必须解决另一个问题：这项新技术是否会吞食利润丰厚的搜索广告业务？如果聊天机器人最终用紧凑的自然语句替代了传统查询列表，那人们肯定就不用再点击广告链接了。</p><p></p><p>前雅虎与谷歌员工、目前经营技术开发初创公司 Vectara 的 Amr Awadallah 认为，“谷歌的商业模式是有问题的。如果谷歌能为每条查询都给出完美的答案，那用户就不会点击任何广告。”</p><p></p><p></p><h2>渐进式改造，还是彻底“大修”？</h2><p></p><p></p><p>行业专家们认为，随着技术的进步，谷歌必须决定是否彻底改革其搜索引擎，转而让成熟的聊天机器人成为新的旗舰业务支柱。</p><p></p><p>谷歌一直不愿广泛分享自家技术，理由是与 ChatGPT 和其他同类系统一样，这类 AI 模型会生成虚假、有毒和存在偏见的信息。LaMDA 目前只通过实验性应用 AI Test Kitchen 向部分有限用户开放。</p><p></p><p>根据一份备忘录，谷歌认为这是在不伤害用户或社会的前提下，探索先进 AI 部署可行性的唯一途径。根据会议录音，一位谷歌经理在最近的会议上承认小型企业在发布这类工具时思想包袱较轻，但强调谷歌必须介入竞争，否则最终可能被整个行业的转变抛在身后。</p><p></p><p>其他企业其实也面临类似的窘境。五年之前，微软曾经发布名为 Tay 的聊天机器人。由于经常表达出种族主义、仇外心理和各种污言秽语，微软被迫将其立即下架——而且再也没有然后。最近几周，出于大体相同的原因，Meta 也叫停了自己的聊天机器人。</p><p></p><p>通过会议录音来看，谷歌高管们认为可以先将聊天机器人技术作为面向外部企业的云计算服务，也可以尝试将其整合到简单的客服任务当中。谷歌应该严格把控官方产品的可信度与安全标准，但适当以原型版本的形式发布一些不符合这些标准的试用成果。</p><p></p><p>这些原型方案可能只限少数用户使用，比如 50 万用户，同时明确警告该技术可能产生虚假或令人反感的表述。自今年 11 月末发布以来，ChatGPT（并未解决有毒言论问题）已经得到超百万人使用。</p><p></p><p>AI 实验室 Google Brain 负责人 Zoubin Ghahramani 上个月在 ChatGPT 发布前接受采访时提到，“那种酷炫的对话演示系统，特别是能让人跟它连续交流好几轮的方案，确实能带来强烈的新鲜感。这方面尝试很重要，但并不足以真正改变社会。毕竟这些东西还不足以供人们在日常生活中放心可靠地使用。”</p><p></p><p>谷歌已经在努力使用支持 LaMDA 和 ChatGPT 等聊天机器人的底层技术增强自家搜索引擎。这种被称为“大语言模型”的技术不只能让机器参与自然语言对话，同时也有丰富的其他应用可能。</p><p></p><p>如今，这项技术能够帮助谷歌搜索引擎高亮显示能够直接回答用户问题的结果。以往，如果我们在搜索栏里输入“美容师工作时是不是需要久站？”，谷歌引擎其实根本不理解用户在问什么。但现在，谷歌已经能用简短的表述介绍皮肤护理行业的工作特点。</p><p></p><p>不少专家认为，谷歌会继续采用这种方法对搜索引擎做渐进式改造，而非彻底推翻重做。</p><p></p><p>曾在微软和谷歌担任 AI 研究员的 Margaret Mitchell 曾帮助成立道德 AI 团队，目前则在研究实验室 Hugging Face 工作。在她看来，“谷歌的搜索业务相当保守，一切都以不扰乱现有系统的有效性为前提。”</p><p></p><p>包括 Vectara 和 Neeva 在内的其他搜索引擎，也在努力以类似的方式增强搜索技术。但随着 OpenAI 等机构不断改进自家聊天机器人，特别是致力于解决有毒言论和偏见问题，这类成果最终很可能成为传统搜索引擎的可行替代品。而谁先抵达终点，谁就是新时代的赢家。</p><p></p><p>曾负责谷歌广告业务、包括搜索广告，目前在 Neeva 担任负责人的 Sridhar Ramaswamy 总结道，“去年我感觉很沮丧，因为小引擎难以摆脱谷歌的铁腕统治。但聊天机器人这类新技术带来了转折性时刻，为后发竞争者们创造了更多机会。”</p><p></p><p>不久前，在全体员工会议上，Sundar Pichai 曾大声朗读了以下问题，“对于「谷歌搜索正在消亡」这类报道标题，现在我们的心情可跟以往不一样了。Sundar，你担不担心谷歌的搜索业务？这种担忧的底层原因是什么，我们又该如何应对？”</p><p></p><p>Pichai 回应：“我觉得这是个很好的问题。谷歌仍然在保持进步，但人们总觉得谷歌取得的成就都是理所当然的。只有面向未来夺取意外的胜利，才能换来人们的惊喜和赞赏。”</p><p></p><p>参考链接：</p><p></p><p>https://www.nytimes.com/2022/12/21/technology/ai-chatgpt-google-search.html</p><p></p><p>https://www.theregister.com/2022/12/25/in_brief_ai/</p>",
    "publish_time": "2022-12-27 15:32:29",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "基于昇腾 AI 的“金奖”实践，给开发者有何启思？",
    "url": "https://www.infoq.cn/article/fLW0tvmfwU29CafXIFGH",
    "summary": "<p>12 月初，第八届“互联网 +”大学生创新创业大赛（下文称“本届大赛”）圆满落幕，该大赛由教育部主办，旨在全面深化高校创新创业教育改革、提升大学生创新创业能力、加快培养创新创业人才，纵深推进大众创业万众创新。</p><p></p><p>在本届大赛中，<a href=\"https://www.infoq.cn/article/KOXlSO37RIOdy6wFbKAJ\">华为</a>\"五大技术领域共输出 47 道命题，来自 30 个省的 249 所高校 2799 支队伍 11661 人报名华为命题，在 858 家命题企业中排名第一，其中昇腾命题报名团队人数最多。</p><p></p><p>历经激烈角逐，由北京理工大学韩煜祺博士带领的团队基于昇腾算力及 CANN 开发的创新应用《京工天鹰——昇腾赋能智能实时无人机载安防系统》(下文称“该项目”)在本次比赛中斩获金奖。本届大赛决赛有来自全国的 90 支队伍参与金奖争夺，为何该项目可以夺得金奖？该项目有何特色？带着这些疑问，InfoQ 对该项目的负责人——北京理工大学的韩煜祺博士进行了专访。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/de/de9848a5f7ee9a862ee9d5621f458e90.png\" /></p><p></p><p></p><h2>一、选题之思：AI 赋能安防监测对公共安全领域意义重大</h2><p></p><p></p><p>韩煜祺来自于北理工毛二可、龙腾院士创新团队，该团队长期深耕于机载实时信息等相关技术的研发工作，韩煜祺本人博士阶段也是从事基于无人机平台的智能化算法研究及开发。在韩煜祺带领下的京工天鹰团队共 15 个人，昇腾 AI 基础软硬件平台能提供高算力，同时具备软硬协同、自主创新等优势，十分切合该团队所有成员的兴趣，且该团队之前已经有过华为其他领域的研发经验，因此选择了昇腾 AI 的命题进行应用探索并参赛。</p><p></p><p>在决定参赛后，京工天鹰团队在选题方面做了很多考虑。安防行业的社会意义重大，传统人工或视频监测的安防方式存在盲区多、风险高、响应慢等问题，是该团队一直在关注的领域。该团队通过对机载安防市场进行调研和分析，发现该行业的市场规模很大，21 年的行业规模有近万亿元。在多次与昇腾 AI 技术团队沟通后，京工天鹰团队觉得团队自身在机载实时信息处理上有一定技术积累，加上昇腾 AI 的助力，对完成项目落地非常有信心，于是确定了《京工天鹰——昇腾赋能智能实时无人机载安防系统》这个选题。</p><p></p><p>该项目从命题揭榜到参与总决赛答辩共历时 6 个月，来自信息通信工程、光学工程及工商管理等专业的项目团队成员，在项目推进过程中各自发挥特长，比如光学工程专业的同学主要解决了紧凑型吊舱的结构设计问题；研究信息处理的同学对轻量化的智能算法进行了技术攻关；工商管理专业的同学主要对商业和市场管理方案进行了内容输出。</p><p></p><p>通过与昇腾 AI 的深入沟通并结合实际研发的任务，京工天鹰团队对昇腾的计算架构进行了深度的二次开发，缓解了算力与功耗的矛盾，基于昇腾异构计算架构 CANN 研究了图像智能处理平台及智能实时无人机载安防系统，拓展了昇腾算力的应用生态。</p><p></p><h2>二、项目实现：一款基于昇腾算力及 CANN 的创新应用</h2><p></p><p></p><p>该项目主要面向完善自主创新 AI 生态的需求，以及公共安全领域创新巡检方案的行业缺口，构建了机载的智能、实时、通用巡检方案，实现了无人机在防疫、边境和火灾等巡检场景对人、车辆等目标的检测、识别与定位等功能。</p><p></p><p>公共安全应用场景复杂多样且需求不一，人的异常行为定义具有复杂性且存在时效性，所以“对可疑车辆、行人实现自主检测及追踪定位”的功能是项目的关键核心，该功能需要具有强大的抗干扰能力和较强的鲁棒性，并能够实现异常诱因检测，具有实时性的处理算法和高性能的运行平台。</p><p></p><p>为此，京工天鹰团队提出了一系列解决方案。他们主要采用无人机相机采集航拍图像，然后将图像传输给目标检测模块，通过图像预处理、特征提取、特征匹配等一系列过程实现对物体、车辆目标的捕获；之后，依据帧间目标外观及其运动状态，对多个目标进行编目实现多目标的持续锁定与关联。</p><p></p><p>从技术创新的角度，由于无人机观测范围广、监视时间长，航拍图像分辨率高、图像容量大，对机上算法的智能化和实时性都提出了较高要求。团队使用多手段联合的神经网络轻量化模型降低对大数据、大模型的依赖，通过内嵌推理机制的智能化学习技术，采用数据 + 知识双重驱动的学习策略，在大幅降低计算复杂度的情况下，同时实现了对 20 个目标的机上实时处理功能。</p><p></p><p>而且，在系统实际落地过程中，由于其体积功耗等资源约束限制，就要求在有限的资源供给下，对模型进行适当压缩，仍能保证较好的处理精度和较高的运行效率。</p><p></p><p>结合这些场景的边界约束，从硬件层面，该项目主要采用 Atlas 系列硬件作为核心处理器，利用 CANN 对训练、推理流程进行加速优化，使<a href=\"https://www.infoq.cn/article/ZKKj2QMlrYopHAcLyMSJ\">昇腾 AI </a>\"在项目中发挥最大能效。</p><p></p><p>同时，京工天鹰团队对昇腾平台进行了二次开发，设计了多昇腾 +FPGA 的异构计算架构，通过对任务进行模态拆解并自适应匹配最高效的硬件处理资源，从而提升平台的能效比，有效平衡算法的算力需求与机载平台的功耗约束，并结合能弱化底层硬件差异性的软硬解耦中间件进行开发。软硬解耦中间件将算法任务分配后，借助 CANN 完成并行推理时的资源管理和执行使能，从而解决了算力无法满足应用需求的问题。</p><p></p><p>为了实现项目功能，从算法层面，京工天鹰团队也自研了目标检测算法、多目标跟踪算法以及模型轻量化算法等 AI 算法：</p><p>目标检测算法：在大视场的机载图像中对感兴趣目标进行快速捕获，为后续处理提供目标的初始选点；多目标跟踪算法：对检测到的目标进行时序上的特征及轨迹关联，对目标赋予稳定的标号；模型轻量化算法：将上述检测和跟踪模型进行压缩和效率优化，使智能化模型能够在有限资源的无人机平台上部署。</p><p></p><p>在算法技术攻关的过程中，由于机载航拍图像中目标呈现多尺度、多朝向分布的特点，导致目标捕获过程中存在漏检及虚警等情况。团队通过设计目标多层级特征融合及自适应角度估算等策略，提升对不同分布条件下目标外观表征能力，保证了对重点目标的精准检测与定位。</p><p></p><p>在整个软件驱动硬件的过程中，京工天鹰团队将 CANN 纳入研发的软硬解耦中间件的框架中，基于 CANN 的异构并行加速能力，对整个算法流程进行了分析和分解，充分考虑硬件特性，将不同任务负载映射到计算资源池中特定的硬件加速模块上，在整体上获得更低的处理时延和更高的能效比。</p><p></p><h2>三、昇腾 AI 赋能：切实满足项目从训练到推理的多场景算力需求</h2><p></p><p></p><p>在该项目的开发过程中，京工天鹰团队大量使用 CANN 提供的精度比较工具、算子自动调优工具以及性能瓶颈分析工具等。这些工具极大提升了开发效率，也让自研算法有了更好的执行效率，从而充分地释放昇腾算力的潜力。值得一提的是，CANN 提供的 TBE 算子开发工具使得该团队能将实验室自研的先进算法移植到昇腾平台上，通过自定义算子的开发，完成了对智能算法端到端基于昇腾算力的加速，满足了智能无人机载安防系统对高精度算法实时处理的需求。</p><p></p><p>昇腾异构计算架构 CANN ，对上承接多种 AI 框架，对下服务 AI 芯片与编程，是提升昇腾处理器计算效率的关键平台。使用 CANN 进行平台迁移的成本较低，在方案实现时，只需指定 device 为昇腾 AI 处理器，即可用昇腾 AI 处理器完成网络的开发、训练以及调试，无需额外进一步关注昇腾 AI 处理器具体的底层细节。</p><p></p><p>同时，京工天鹰团队在采用 MindStudio 打通应用流程通路时，对于新增的网络类型或结构，只需关注相关计算类算子的开发和实现。框架类算子，反向图建立和实现机制等结构可保持复用，这使得该团队在利用昇腾体系进行多场景应用开发时，拥有了非常优秀的扩展性。</p><p></p><p>韩煜祺说，在项目研发过程初期，由于项目团队对 CANN 和 Atlas 系列硬件尚不熟悉，在硬件固件、内核、驱动包等版本选择和匹配上有较大的疑惑，这个过程中，昇腾 AI 技术团队及时提供了支持，昇腾 AI 技术团队对固件、内核、驱动等内容进行了完善，京工天鹰团队从昇腾社区获取稳定的 SDK 包，经过反复沟通和验证，打通了项目的应用流程，解决了类似于推理不稳定、PCIE 偶发性断链等问题。</p><p></p><p>谈及到项目的未来发展，韩煜祺说道：“从项目揭榜开始，我们就一直和昇腾 AI 保持着密切沟通。无论是参与比赛还是未来一段时间，我们团队的定位始终是携手华为一起拓展昇腾 AI 的应用生态。”</p><p></p><p>聚焦到项目执行上，在技术层面，京工天鹰团队未来将继续发挥自己的优势，继续在人工智能和公共安全领域不断探索和耕耘，完成更多的功能实现和技术优化。在市场层面，该团队希望可以获得来自学校、技术产业转化中心的更多支持，全面推进项目的商业化。</p><p></p><p></p><h2>四、AI 未来：需要更多个“京工天鹰团队”的共同努力</h2><p></p><p></p><p>在对比众多 AI 体系后，京工天鹰团队发现昇腾 AI 具有最完善的生态体系，CANN 的全面性、易用性、灵活性使它成为一个可靠实用的工业级套件，因而该团队既可以在硬件方面设计新架构，又能在软件上创新算法并做硬件级加速，从而充分利用昇腾的强大算力。</p><p></p><p>京工天鹰团队已经深刻地体验到，CANN 作为硬件使能层，是沟通智能算法和 AI 算力的桥梁。借助张量加速引擎 TBE 的标准算子加速库和自定义算力能力，网络模型能找到优化后、可执行、高效率的算子，并可以在任务调度器、运行管理器以及驱动的助力下，充分发挥硬件的性能。</p><p></p><p>正如韩煜祺所观察到的，国内人工智能技术的发展在单点上都有非常出色的表现，包括近些年来的顶会论文以及商业技术应用上国内已经可以达到甚至超越国外水平，但目前国内“完整的”人工智能生态建设距离国际水平还有一定差距，这需要更多个“京工天鹰团队”共同努力才能追赶。</p><p></p><p>随着人工智能产业的快速发展，对高性能、低功耗的算力需求日益增大，算力建设也成为城市发展的智能根基。昇腾 AI 准确地把握了这种趋势，针对端、边、云等不同应用场景深度优化，研发了 Atlas 系列硬件，并在硬件之上成功构建了全栈软件生态，赋能了教育、制造、金融等千行百业，成功推动了千行百业转型升级。</p><p></p><p>总之，更多“京工天鹰团队”的未来值得我们期待，<a href=\"https://www.infoq.cn/article/8TTGkRGdOOUjHOKwSED2\">昇腾 </a>\"AI 的未来更值得我们期待。</p>",
    "publish_time": "2022-12-27 15:51:07",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "SUSE企业服务 帮您轻松跨越技术鸿沟",
    "url": "https://www.infoq.cn/article/aZlvjiw6ZPxd54zBpkMV",
    "summary": "<p>为您提供技术支持、专业咨询和技术培训</p>",
    "publish_time": "2022-12-27 15:55:26",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "直面成本“刺客”、拒绝繁杂技术花样，压力之下云厂商改变方向｜解读云原生的 2022",
    "url": "https://www.infoq.cn/article/psWB79HDzjsKislYsE0Y",
    "summary": "<p></p><blockquote>本文是 “2022 InfoQ 年度技术盘点与展望” 系列文章之一，由 InfoQ 编辑部制作呈现，重点聚焦云原生领域在 2022 年的重要进展、动态，希望能帮助你准确把握 2022 年云原生领域的核心发展脉络，在行业内始终保持足够的技术敏锐度。“InfoQ 年度技术盘点与展望”是 InfoQ 全年最重要的内容选题之一，将涵盖操作系统、数据库、AI、大数据、云原生、架构、大前端、编程语言、开源安全、数字化十大方向，后续将聚合延展成专题、迷你书、直播周、合集页面，在 InfoQ 媒体矩阵陆续放出，欢迎大家持续关注。特此感谢丁宇（叔同）、董晓聪、裴超、冯常健、柯琪、吕亚霖、王泽锋、于广游（按姓名首字母排序）对本文的贡献，他们的真知灼见，是本文能与大家见面的关键。</blockquote><p></p><p></p><p>数据显示，云原生计算基金会（CNCF ）拥有超过 850 家参与组织，相较去年增长 15%，其中今年新增的 220 多个成员中，有 19 个来自中国。</p><p></p><p>去年的盘点中，我们用了“抢占技术 C 位，迎来落地大爆发”的标题来总结云原生整体的发展势头。今年，云原生的发展依然可圈可点，比如开源容器编排平台采用率激增、各种行业加入到了云原生大家庭等。这次，我们将从底层基础技术和偏向场景化的应用技术两方面，对云原生今年的发展情况进行盘点，以期自顶向下地呈现出相关亮点和挑战：</p><p></p><p>容器的“黑盒”打开，混部带来了效率提升，备受企业欢迎；Serverless 基于容器完成标准化，应用“元年”开启；Service Mesh 进行新尝试，落地方式还在探索；降本增效大主题下，FinOps 理念得到快速发展；越来越多的传统行业开始应用云原生技术等。</p><p></p><h3>基础技术篇</h3><p></p><p></p><p>从物理机到虚拟机再到云原生，底层基础技术对上层应用赋能的边界在不断提升，业务研发越来越从底层事物中抽离，聚焦于本身的业务逻辑。</p><p></p><h4>容器的“黑盒”已经打开</h4><p></p><p></p><p>7 月，Kubernetes 发布了 Gateway API 0.5 版本，主要组件的 Gateway API 资源首次升级为 Beta 版。同时社区还探索如何将 Gateway API 用于网格并引入新的实验概念。这也促成了 Envoy Gateway 项目的推出。12 月， Kubernetes 原生工具集合项目 Argo 正式从 CNCF 毕业。</p><p></p><p>容器发展至今，已经完成了自身的蜕变。</p><p></p><p>在第一阶段，容器只是在解决如何做好自己内部技术组合的问题，比如怎么与服务网格、可观测性的产品结合。这期间，企业只是选一部分比较周边的业务使用容器，而容器化业务内部系统就像一个“黑盒子”，各细分组件通过 ELB 调用实现交互，容器并不能直接与每一个部分做精细互通，致使容器化业务系统跟周边业务系统的交互效果很不理想。</p><p></p><p>到了第二阶段，“黑盒子”打开，容器开始深入到整个云原生体系中，真正作为云最核心的部分，与网络、存储、数据库等做很好的结合，比如容器化业务应用可以直接与其他所有云服务通信等。</p><p></p><p>作为云原生的典型代表，如今容器技术的成熟度是最高的，同时这也意味着容器技术自身很难再有非常大的突破和变化。Kubernetes 成为行业事实标准，如今定位也类似 Linux 内核，虽然没有大的功能性迭代，但已经成为云原生领域最基本的设施，也成为企业 IT 系统的基本设施。</p><p></p><p>今年，容器的演化进入了“扫尾阶段”，开始解决原来不好做或不能做的场景应用问题。Kubernetes 这一年稳定更新的三个版本，更多是在 API 怎么更加健壮、流控怎么更好更安全、改进 Windows 支持等细节上做优化。</p><p></p><p>另外，内核提升可以为容器带来更好的隔离和性能等，因此随着容器的广泛应用，其对内核的要求也越来越高。大厂们开始往更高内核版本 5.10 上迁，Kubernetes 社区也在落地内核方面的内容，给企业带来的直接影响就是观测性上有了很大的进步，性能和隔离性的提高也很明显。</p><p></p><p>应用上，虽然容器正在大规模铺开，但如何用好容器也很有挑战，比如 Kubernetes 在调度、场景优化、降低复杂性等方面还有很大的进步空间。</p><p></p><p>微软全球副总裁柯琪表示，随着容器的广泛应用，企业部署了很多 Kubernetes 集群，如何对其管理是企业面临的问题之一。鉴于这部分与多云有部分重合，我们留到多云部分再表。</p><p></p><p></p><h5>混部</h5><p></p><p></p><p>今年，容器混部取得了较大的进展，不过这个进展并不是体现在技术上。之前混部主要是各大头部企业内部使用，对于技术细节有些“秘而不宣”的意味，但今年云厂商开始把混部技术开源或者变成云产品提供给用户。</p><p></p><p>混部就是要把各种不同的业务放在一起后对它们进行复用。听着简单，但混部有着较高的技术门槛，主要体现在调度、隔离和干扰处理上。</p><p></p><p>具体地，Linux 操作系统内核的隔离性做得不好，但 Linux 内核面向通用场景，如果要解决隔离问题就要对内核做非常深度的改造，但国内大部分企业并没有独立的内核团队，况且这样的人才也是凤毛麟角。当然，不做内核隔离只做调度混部也可以，但对资源利用率的提高就很有限。</p><p></p><p>另外，合理的调度需要有全面的应用画像，这需要大量的数据和业务去打磨算法，这在实现上也非常困难。调度实际上是一个系统性工程，并没有标准化方案，企业可以自行摸索初级方案，但更深入的可能就要使用市面上的产品。</p><p></p><p>其实，企业目的不是混部，而是为了提高资源利用率、降低成本。降低成本有两种方式：一是企业已经买好资源，内部不同业务复用这些资源，这条路线的代表就是混部；二是企业直接使用云厂商提供的成本很低的产品，这条路线的代表是 Serverless，也是大家比较好看的方向。</p><p></p><p>可以预见，下一年，Kubernetes 的演化依旧以解决场景化的细节问题为主。腾讯云容器技术总监、TKE 产品负责人于广游总结道，整体上，容器未来将呈现出以下趋势：</p><p></p><p>第一，往更高层的抽象演进。最早用容器的时候，大家关心的是容器中的资源、pod、container，但是业务并不关心这些，他们真正在意的是应用。因此，容器平台向应用平台演进会是一个趋势。</p><p></p><p>第二，不断拓应用宽度。Kubernetes 的应用已经延伸到了混合云、边缘云，在对中心、边缘、IDC 的资源进行统一调度等方面，还有技术挑战。</p><p></p><p>第三，多样化应用。企业会逐渐通过采用容器技术重塑自己的业务和全部技术栈，比如监控、日志、中间件、数据库、运维等。容器带来了好处，但它跟企业之前的技术会产生割裂，这时更多的企业会选择将所有工作负载运行到容器上，容器化间接成为企业重塑技术栈的动力。</p><p></p><p>结果就是，企业业务容器化后，还会把有状态应用、AI 业务、大数据业务、转码业务、离线业务等都容器化。所以现在的容器不仅仅与微服务挂钩，还在朝大数据、AI 等方向发展，这个趋势是非常明显的。</p><p></p><p>第四，更下沉的方向。对于平台自身而言，如何更稳定、成本更低？还有更多的细节亟待完善。</p><p></p><h4>Serverless：与容器技术体系相通</h4><p></p><p></p><p>3 月，开源 Serverless 应用框架 Knative 成为 CNCF 孵化项目。谷歌此前曾明确 Knative 不捐给任何基金会，但去年底宣布捐赠到今年 Knative 正式成为 CNCF 孵化项目，极大促进了社区的发展。5 月，开源 FaaS 项目 OpenFunction 成为 CNCF 的沙箱项目。9 月，Serverless Devs 进入 CNCF 沙箱，这也是 CNCF 首个 Serverless 工具项目。</p><p></p><p>当前用户对云服务的使用主要有两种方式。一种是把云服务作为资源使用，比如云服务器、容器等，它们不会影响用户应用的开发方式，这类就是容器化 Serverless；另一种是把云服务作为应用构建的模块，例如对象存储，消息队列等服务，用户在应用开发过程中使用这些云服务，但它们会影响用户构建应用的方式，这就是应用层 Serverless。</p><p></p><p>传统意义上的 Serverless，也被称为 FaaS，即函数形态的 Serverless。2014 年，亚马逊推出了 Amazon Lambda，其将 FaaS 理念延伸到数据库、中间件等产品，让各种应用场景下的用户都不用关心资源和集群，而是直接使用 API，这是业内公认最早的 Serverless 服务。</p><p></p><p>FaaS 的核心价值在于让整个云产品体系及生态形成一个有机整体，而不是只用来提供弹性资源。阿里巴巴研究员、阿里云智能云原生应用平台总经理丁宇（叔同）指出，用户可以利用 FaaS 组合其他 Serverless 云服务（BaaS）快速构建应用，这种组装式的研发模式将对研发效率带来革命性变化，是云解决大规模复杂软件研发挑战的关键。</p><p></p><p>另一方面，由于单纯的 FaaS Serverless 是基于函数的，其开发模式、技术体系、产品形态与容器并不相同，不能为用户提供“原汁原味”的 Kubernetes API。该方式下，用户用提交的一个代码片断进行托管，各厂商自成体系，业内没有统一的标准，短期内也很难看到有事实标准诞生。因此在于广游看来，容器的大规模流行反而暂时抑制了 FaaS Serverless 的发展，因此落地也相对缓慢。</p><p></p><p>目前，业内对于 FaaS Serverless 的发展还存在不同的看法和方向，现在也没有孰优孰劣的定论。</p><p></p><p>作为应用层面的 Serverless，以 FaaS 为核心的 Serverless 体系更加强调 Serverless BaaS 的丰富度和 BaaS 之间的深度集成，用户上手快，但需要花费时间和精力去打磨整个云产品体系。但 FaaS Serverless 的核心价值依然是被肯定的，像亚马逊云科技和阿里云还在继续这方面的深研，用更被接受的方式发挥其价值。</p><p></p><p>不过当前的实际生产中，不要求用户改变研发方式的容器化 Serverless 获得了更多的青睐，很多企业多少都了有一定的应用。</p><p></p><p>实际上，亚马逊云科技首先提出 FaaS Serverless 后，其他云厂商纷纷跟进。但单纯的 FaaS Serverless 由于对云产品要求高等原因，在国内的接受度不如海外。这种情况下，业内也开始探索其他方式。</p><p></p><p>之前，大家把 Serverless 作为一种具体的实现，而现在将其视为一种理念和价值，并尝试为这种理念和价值找到更合理的实现方式，容器化 Serverless 就是这种转变下的解决方案之一。</p><p></p><p>容器化 Serverless 发展的目标是为了兼容原本容器的技术体系、降低企业迁移的成本。容器化 Serverless 将 Serverless 与容器结合，Serverless 技术兼容容器的 API，两个技术体系打通后也意味着容器化 Serverless 是标准的。因此，各云厂商的产品标准在趋于一致，能力也在逐步完善。在这个前提下，企业服务的迁移会更容易。</p><p></p><p>当然，容器化 Serverless 不同厂商之间的产品策略也有差异。比如，微软的 Container Apps 支持 Dapr 分布式应用环境，运行在基于 AKS 的隐藏的抽象 Kubernetes 集群之上，甚至不向用户公开 Kubernetes API，阿里云则走在提供 Serverless 容器服务 ASK 的道路上。</p><p></p><h5>现状及趋势</h5><p></p><p></p><p>Serverless 的应用如今实现了“从点到面”的转变。</p><p></p><p>现在，Serverless 的稳定性和效率已经被逐渐接受，一些企业之前只是在周边的个别业务上牛刀小试，现在开始将部分核心业务放到 Serverless 上。比如阿里云完成核心云产品全面 Serverless 化，作业帮将某部分核心业务放到 Serverless 后成本节省了 20%-30%，高德业务投放平台全面采用基于函数计算构建的 Serverless 架构来支撑百万 QPS 等。</p><p></p><p>今年，很多云厂商在各自大会上都提到了 Serverless 的重要性，比如阿里云栖、亚马逊 re:Invent、腾讯数字生态大会等，但热闹的背后反而说明了 Serverless 还处于发展初期，需要推新和推广。这一年，国内 Serverless 被认为是发展元年，虽然还称不上是大规模落地，但业内在 Serverless 成为云原生未来重点方向这一点上几乎没有太多分歧。</p><p></p><p>Serverless 适用于流量波动大和需要更敏捷、更灵活开发的场景。现在 Serverless 架构可以解决微服务架构无法带来足够灵活度的问题，帮助企业快速适应业务变化。</p><p></p><p>Serverless 为能力不同的开发者抹平了技术鸿沟。如果将应用分为应用运行时（即计算部分）和 BaaS 化服务两部分，那么 Serverless 化后的架构会变得更简单。对于 BaaS 服务，可以进行全面托管并免运维 API 化，开发不需要关心资源等问题；对于定制代码部分则可以把 BaaS 的 API 组装起来，让应用开发更快建出新能力，同时不需要关心容量问题。</p><p></p><p>成本方面，对于企业为波峰预置服务器产生浪费的费用、业务需要扩容时购买机器花费的成本和精力、机器维护成本等，Serverless 都可以将这些交给程序运行，按需使用资源、动态伸缩，为企业带来降本增效的效果。</p><p></p><p>Serverless 的快速发展也会对运维领域产生一次颠覆性升级，工程师将精力更多放在开发降本等平台上，而不再关注底层的扩容、采购、网络等问题。</p><p></p><p>预计下一年，会有更多产品具备 Serverless 能力，Serverless 会变得更加普适。另外，Serverless 产品的更多细节也会进一步完善，比如如何提高产品弹性、如何进一步降低成本（如从之前的包年包月到按 CPU 利用率的计费模式）、功能如何更加丰富等。</p><p></p><p>应用上，以上两种方式虽是业内对 Serverless 应用的不同探索方向，但都各具优势和不足。业内现在有将 FaaS Serverless 和容器化 Serverless 结合起来提供解决方案的尝试：容器化 Serverles 解决资源层面的问题，应用层面的问题让 FaaS + Serverless Baas 解决。用户将不同 Serverless 化产品通过事件驱动等方式深度集成后，通过 FaaS 组合其他云服务来快速实现弹性、高可用。</p><p></p><p>当然，Serverless 虽被认为是大势，甚至被视为云未来发展最重要的价值，但从趋势到产品、到行业普遍应用，再到真正大规模落地，还需要业内的长期投入和推动。</p><p></p><h4>Service Mesh：还有挑战需要解决</h4><p></p><p></p><p>4 月，谷歌声明将 Istio 捐赠给 CNCF，9 月份 Istio 正式成为 CNCF 孵化项目。这一事件使 CNCF 社区的确定性更强，也消除了前些年大家对社区治理、法规等方面的顾虑。5 月，Envoy Gateway 项目宣布开源。该项目旨在大幅降低将 Envoy 作为 API 网关的使用门槛。9 月，Istio 宣布引入了一种新的数据平面模式 Ambient Mesh，该模式取消了以 sidecar 为中心的架构，取而代之的是无 sidecar 的方法，同时保留了 Istio 的零信任安全、遥测和流量管理的核心功能。</p><p></p><p>很多企业都是多协议、多语言栈的，他们选择使用 Service Mesh 来解决复杂的服务治理问题。Service Mesh 理念本质上是把一些非功能性的基础设施拆解到中间件中，即 sidecar。</p><p></p><p>在之前的一些实践取得正反馈后，Service Mesh 使用范围也在扩大。今年的 Service Mesh 不再局限于 RPC，开始向对象存储、加解密、MySQL、Redis 等领域深入。</p><p></p><p>但总体看，这一年，Service Mesh 落地还是遇到了大的技术挑战，远没有达到企业理想的使用状态。有一定研发能力的企业使用传统治理模式也可以做得不错，这时就不会选择完全换成 Mesh 架构，只会在一些新的、没有历史负担的业务上试用。</p><p></p><p>归根到底，Service Mesh 只是转移了复杂度，但到了一定规模后复杂度问题就会再次显现。拿当前业内应用较多的 sidecar 模式来说，它很适用于逻辑复杂的场景，如路由、治理，灵活且对业务无入侵。但是，流量劫持和对流量进行逻辑处理需要很强的扩展能力，在规模特别大的场景下，sidecar 模式的复杂度就上来了，性能优势不再明显，资源占用也变得不可忽略。可以说，sidecar 模式天生在大规模场景应用中就有一定的局限性。</p><p></p><p>为解决这个问题，今年九月，Istio 推出了 Sidecarless 的 Ambient Mesh。Ambient 是将 Istio 分成两个不同的层次：安全覆盖层（四层治理）和 七层处理层（七层治理）。但在网易数帆云原生平台负责人冯常健看来，四层治理模式将复杂度降到了 Node 级别，但可能只有对网格安全能力感兴趣的企业会尝试，而七层治理模式本质上还是独立的应用层代理，链路也并未减少。因此，对于该模式的应用，业内更多还是持观望态度。</p><p></p><p>网关层面，社区基本分为 NGINX 和 Envoy 两派：Kong 、APISIX 等基于 NGINX，网易、阿里云等更多应用 Envoy 技术栈。有人认为 NGINX 及其生态已经比较成熟了，但随着 Kubernetes Gateway API 的成熟，以及社区推出 Envoy Gateway 组件，新一轮网关标准定义的争论再次掀起。</p><p></p><p>Kubernetes Gateway API 对标的是 Ingress API。Ingress 的 API 解决流量从集群外导入集群内的问题，但表达能力较弱，使用场景有限，因此社区推出了 Kubernetes Gateway API，希望其提供更高级的网络能力。</p><p></p><p>Kubernetes Gateway API 直接促进了 Envoy Gateway 项目的发展。Envoy Gateway 进而统一了网关的控制面 API。原先网关控制面是通过 xDS 控制数据面，现在更多会基于 Kubernetes Gateway API。</p><p></p><p>实际上，现在各个企业都在从不同的方向尝试对 Service Mesh 进行完善和补充，如网易向 Envoy 社区贡献 Dubbo 核心支持能力来促进落地。虽然社区有了各种开源产品，但业内还没有形成像 Kubernetes 这样的事实标准。当有这样的一个事实标准出来后，Service Mesh 才会迎来自己的爆发。这与容器的发展轨迹是类似的。</p><p></p><p>Service Mesh 也在寻找更适合的落地方式。现在，业内有尝试不再将 Service Mesh 作为一个独立的产品，而是将其与 Serverless 结合。Serverless 不让用户去关心服务器，Service Mesh 不让用户关心服务治理，如果将服务治理的 Service Mesh 容器内置到 Serverless 平台里面，企业提交一个业务的容器进项后也会拥有 Serverless 的能力。</p><p></p><h4>硬件与云，互相影响</h4><p></p><p></p><p>6 月，阿里云发布云数据中心专用处理器 CIPU，形成“倚天 + 飞天 +CIPU”组合。11 月，亚马逊发布 Nitro v5 、Graviton 3E 系列芯片。12 月，腾讯云发布了新代次的裸金属云服务器、GPU 云服务器，此外还发布了银杉智能网卡等。同月有消息称，微软以 1.9 亿美元（约 13.2 亿人民币）的价格收购了加州 DPU 初创公司 Fungible。</p><p></p><p>从整个计算机发展历史看，软硬件迭代呈现出了交替螺旋的方式，即某个新技术出来后，都先用软件测试可行再进行小规模应用，当发展规模大到一定程度时，人们便开始考虑用硬件方式加速实现，云原生也不例外。</p><p></p><p>如今，云已经取代传统 IDC 服务器成为新的基础设施，企业开始通过硬件进一步提高效能。企业选择云原生硬件的考量主要有两点：成本和不同应用上的性能表现。</p><p></p><p>成本方面，虽然硬件开发的一次性投入相对较大，灵活性相较软件也差很多，但只要需求固化下来并开发成功后，企业采购的边际成本是非常低的。</p><p></p><p>性能方面，硬件对云的性能提升包括可靠性、稳定性、安全性等方面：</p><p></p><p>热操作能力。与传统业务不同，云是不能停机的，热操作能力，包括热升级、热迁移、热插拔等都是云提出的特殊要求，而传统硬件并不具备这些能力。现在，云计算领域里的自研硬件会在设计要求有热升级等功能，像 DPU 里任何一个组件都有热升级能力。租户隔离。云的特性之一是弹性共享，一个物理机上可能会有很多用户在运行虚拟机，怎么加强用户之间的隔离、避免互相影响，也是云对硬件提出的新要求。安全性。云上很多用户运行在一台物理机、一个网络里，如果某个用户恶意利用一些漏洞获取到其他用户的数据或者逃逸到云的平台层，那么会产生非常严重的后果。因此，云对硬件的安全性要求也非常高。传统 IDC 对带内、带外并没有做非常强的隔离，但在云上就不允许互通，这也是调整改造的方向之一。</p><p></p><p>当前云原生领域的硬件设备可以分为通用型和专用型两类，前者如 CPU，后者有 GPU、DPU。DPU 是专门为云而生的。传统情况下，服务器的 IO 更多是通过网卡、硬盘等硬件直接实现。但在云原生领域，网卡、硬盘等都是虚拟的，用户把东西发到网络或写在硬盘的动作实际上是先交给了云平台侧的软件进行加工处理后再发到网络或写入硬盘。</p><p></p><p>腾讯云高性能网络产品中心总监裴超表示，云和硬件也在彼此影响着向前发展。一方面，随着云原生应用的需求不断提高，硬件设备为了满足这些需求也在快速迭代。比如虚拟机网卡从 20G、50G，甚至迈向 100G，云原生对硬件的蓬勃发展起到了一定的刺激作用。另一方面，很多云原生软件产品的设计之初，就会有硬件专家参与进来，一起考虑未来用硬件加速的可能性。可以预计，未来的架构师、技术负责人多少都需要对硬件有所了解，以便对总体架构进行把握。</p><p></p><p>目前，云厂商已经越来越多地参与到硬件和芯片的研发当中。相较之前，一款芯片可以用三四年，现在基本保持一年一更新的频率，迭代可以算是频繁。像英特尔、AMD 等垂直芯片厂商也在努力直接了解终端客户需求，尽快推出新的芯片。</p><p></p><h3>产业落地篇</h3><p></p><p></p><h4>行业主题：降本增效</h4><p></p><p></p><p>“降本增效”无疑是今年行业的大主题。在这个背景下，整个行业不再像之前那样去追逐前沿技术，而是回归到了云的最基本价值上。这一变化也可以从今年云厂商讲故事的角度上看出来。往年，云厂商会争相发布各种技术，努力往技术前沿方向走。但今年，云厂商追求的是“do more with less\"，即如何用更少的成本帮助客户获得更多的收益。</p><p></p><h5>FinOps</h5><p></p><p></p><p>谈起降本增效，之前企业常常在这年做完后不知道下一年该怎么做，本质上是缺乏方向性的指导。正因如此，这也促进了今年指导云财务管理的 FinOps 理念的快速发展。</p><p></p><p>FinOps 的历史并不悠久，公有云早期传播者 Adobe 和 Intuit 在 2012 年首次描绘出了 FinOps 的雏形，直到数年后云成本问题日益严重才逐渐崭露头角，更多企业也是今年才刚刚接触。</p><p></p><p>成本管理的难点在于资源并不是独享的，而是共享。通常单个集群可以托管多个工作负载和应用，但云厂商的账单无法体现每个工作负载或应用消耗的资源。缺乏对多个团队如何利用或共享基础设施的可见性造成了成本“黑洞”。</p><p></p><p>FinOps 本质上是把财务和整个架构技术结合在一起，弄清楚各业务对云服务使用的具体账目，然后把资源利用率提上来，减少成本消耗。该理念要求企业首先要清楚自己具体拥有哪些资产、这些资产属于谁；其次是看这些资产的利用率怎么样，然后再结合相关的技术进行优化。</p><p></p><p>实践中，企业的架构团队搭建相应平台将成本可视化，并在 DevOps 里加入管控审批等流程，用流程去约束成本。另外企业还要引入一个“成本负责人”的角色，这个角色主要由业务部门承担，负责掌握每个部门申请资源的原因、能否创造足够的利润覆盖这部分成本、资源使用率低的话是否减配等，具体执行时则主要由 SRE 把控。</p><p></p><p>FinOps 相关产品之前更多是多云管理的商业化公司推出，今年云厂商也有陆续推出，如阿里云的 ACK FinOps 套件。云厂商有很多运行时数据，如闲置率、平均负载等，也可以为企业提供优化建议。但企业如果想真正控制成本，更多还是要自己去做。</p><p></p><p>现在也有一些 FinOps 开源项目，如腾讯云开源的 Crane 等，这些项目本身就是一个成本管理平台，会把涉及到的成本信息汇集起来做出趋势图等，帮助企业做决策。但业内目前没有完全的开源实施标准，也很难做出一个大统一的产品，因为这样的产品需要考虑的因素是方方面面的，现在只是每个细节和分支有产品雏形。</p><p></p><p>作业帮基础架构负责人董晓聪认为，FinOps 的理论体系会逐渐沉淀和完善，各企业的落地方式相差无几，不过使用的具体产品可能不同。事实上，FinOps 可能目前只要满足企业的特定需求就好，不是非要演化出这样的标准。</p><p></p><p>FinOps 一定程度上会倒逼企业进行整个技术架构的演进，促进企业用更好的技术、更好的生产力工具，或者是更少的服务去支撑更大的服务。一定程度上，FinOps 会成为撬动企业增长的一个杠杆。</p><p></p><p>当然，FinOps 不是万能的，因为“降本增效”也有成本。对于成本已成为不可承受之重、之前也没有进行过优化的企业，里面一定存在大量的技术浪费，这时候就需要花费人力优化，企业肯定能从中享受到优化红利。但如果一家企业处于高速发展阶段，有能力赚取非常高的利润去完全覆盖浪费的成本，那么肯定业务为王，暂时还不必在降本上花费很多精力。</p><p></p><p>如今，FinOps 还处在大家都很需要、但没有做得特别好的阶段。下一年，FinOps 的趋势会延续，甚至未来几年内都会是很多企业关注的重点，其应用的领域也不会局限在互联网。</p><p></p><h5>多云</h5><p></p><p></p><p>很多企业前几年就开始考虑多云架构，直到今年开始真正在生产落实。这背后的原因也是企业对成本的考虑，还有就是对稳定性需求的提升。</p><p></p><p>实际上，国内外各大云厂商都出现过大大小小的故障，很多情况下企业要依靠多云架构去弥补这部分损失。另外，只要选择了两家云厂商，选择权就到了企业手里，企业与云厂商谈判的议价关键取决于企业在云之间迁移的能力。当然，企业如果实践不好，反而会增加成本。</p><p></p><p>总之，多云要做的就是云间的闭环和自由迁移，以及能够做得更高可用，抵销对云厂商的依赖。</p><p></p><p>在多云的初级阶段，不同云上的应用管理是手动的，业务量多的时候管理员会非常痛苦。之后，多云才有了一定的自动调度和差异化配置能力，业务不用感知资源池细节和授权等问题，这样的资源池化能力正是企业需要的。</p><p></p><p>现在社区比较流行的开源集群管理产品是 Cluster API，该产品使用 Kubernetes 风格的 API 和模式自动化集群生命周期管理，谷歌、微软等云厂商都有基于 Cluster API 的服务。华为云等多家企业联合发布并开源的 Karmada，是 CNCF 首个多云容器编排平台项目。今年，Kubernetes 多集群管理平台 OCM v0.9.0 发布，来进一步改善托管集群安全性问题。实际上，虽然每个云厂商都在自己推出产品，但很大程度上也是基于上游社区的建设。</p><p></p><p>不过，华为云云原生开源负责人、CNCF 大使王泽锋也指出，现在多云、多集群的编排调度等问题还没有特别成熟的商用级解决方案。</p><p></p><p>首先是多集群的负载管理。一些负载不能放到一个集群里，而是需要建立一个容错性更强的集群体系，这个系统通常由多个 Kubernetes 集群组成。多个集群间如何部署应用、主副关系还是平等，很多细节问题都要考虑。</p><p></p><p>其次是多集群的流量管理。单集群内的流量管理，一定程度上是通过控制面来维护各个实例的健康状态、调整流量分布。但是到了多集群架构下，由于单集群自治属性强，控制面与各个单集群之间的联系减弱，并不能简单地通过两者的联系来判定哪个集群无法处理流量、需要重分配。如何实现数据面自治的多集群流量管理，是个很大的挑战。</p><p></p><p>再者，业务部署在不同的云或集群里，业务互相访问时会有网络连通性、身份授权等问题。多云的场景是多样化的，很多用户不会接受拉昂贵的专线方式，网关方式又比较适合允许有延迟、对网络可靠性要求不高的业务场景。身份授权更为棘手，多云、多集群本就是天然屏障，如何身份授权进行全局管理就是一个很大的难点。</p><p></p><p>最后，实现多云、多集群的互访后，业务还需要有较强的适应性，能够在不同的模式下工作。</p><p></p><h4>越来越多传统行业入场</h4><p></p><p></p><p>除了降本增效，今年很多企业也纷纷投入到了数字化转型当中。实践中，转型企业是用互联网技术和互联网思维方式构建自己新的数字化体系。数字化中，很多企业首选云原生技术。</p><p></p><p>今年，除了有像腾讯这样业务完成全面上云的互联网企业，还有越来越多的传统企业开始上云。工业制造行业围绕业务需要主动上云，云厂商也会根据其业务需求提供配套解决方案，金融、零售、政务、能源、物流等行业也都入局云原生。</p><p></p><p>根据云原生技术实践联盟（CNBPA）调查，95% 以上的受访央国企已经考虑或正在使用云原生技术，其中近 80% 的企业已经使用容器、微服务、DevOps 等云原生技术。支持一云多芯的全栈云原生是更贴近业务的技术应用架构，更能聚焦央国企的数字化转型。</p><p></p><p>传统企业使用云原生技术更多会从 to C 业务入手，比如个税办理等面向个体消费者的 App。当然还有像光伏行业通过“云原生 +AI”技术提升良品率类的应用。另外，传统企业在新建或升级系统时，也会优先选择更流行和最有效的技术，而云原生就在其中。</p><p></p><p>非互联网企业也积极拥抱开源，并参与云原生社区，比如波音今年加入了 CNCF 成为白金会员，中国电信、中国电子云成为 CNCF 黄金会员。</p><p></p><p>在今年 3 月，波音宣布与国外三大云计算提供商亚马逊云科技、微软和谷歌，签署了协议，扩大云运营规模并减少对本地系统的依赖。波音大部分应用都是在本地服务器上托管和维护的，很多遗留系统正在老化，需要大量维护工作，阻碍了波音开发和部署新型数字化解决方案。波音选择将大部分工作负载转移到云端的方式消除基础设施带来的限制。</p><p></p><p>像波音这样的非互联网企业进入云原生领域，是该技术更大规模落地的预兆之一。</p><p></p><h4>云安全</h4><p></p><p></p><p>或受去年 Log4j 漏洞事件的影响，加上 Kubernetes 安全事件频发，今年业内在安全方面的实际行动也很多，尤其是在供应链安全和模糊测试上。</p><p></p><p>供应链安全更靠近企业实践。之前，企业为了安全直接做物理隔离，但由此也带来了很多问题。当前阶段，企业做的比较多的是扫描检测部署的业务应用对应的版本，对于有问题的版本进行拦截，不允许其部署到生产环境中，初步保证业务的生产系统不暴露在漏洞之下。</p><p></p><p>另外，云原生给安全提供了一个新的抓手。之前的 DevOps 体系里融进安全的东西很难，而云原生的 DevOps 体系下，企业可以结合 CI/CD 技术，从软件的编码构建到测试、部署和运维的整个链路中，加入面向代码级的扫描能力、面向依赖的组件做版本的分析，并与漏洞库进行匹配，如果 CI/CD 部署对接到多云上，中间还会做防篡改等设计。</p><p></p><p>不过，作业帮基础架构 - 架构研发团队负责人吕亚霖表示，云原生也打破了安全原有的物理边界，这对安全领域也是场考验。</p><p></p><p>模糊测试是一种常用的应用程序安全测试，主要用来发现应用中的功能性缺陷、安全问题等。当前，大家对模糊测试的使用更偏单点技术。CNCF 中的多个项目都在使用模糊测试，如 Argo、Envoy、Fluent-bit、Kubernetes 等。这一年，Ada Logics 的团队持续努力将模糊测试集成到 Kubernetes Cluster API 项目中。</p><p></p><p>今年，国外云厂商在安全方面也做了很多事情，比如微软发布的Azure AD workload identity 预览版可以在 Pod 级别进行身份托管，还宣布实现在Kubernetes中支持AMD SEV-SNP，以此保护数据安全；亚马逊云科技扩展了 Amazon GuardDuty 安全监控服务的范围，增加了对部署容器的运行时环境的威胁检测。另外，很多创业公司也在做相关工作，比如五名前谷歌员工共同创建了专注开源供应链安全的 Chainguard。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/a4/a4ca5d175c640660e7ab1d62d3aaab09.png\" /></p><p></p><p>云原生安全相关项目</p><p></p><p>但在下一年，行业是否能延续对安全的重视其实还是未知的。实际上，还有很多除漏洞外的安全问题。比如多云和边缘都会加倍放大安全问题，多云里的资源访问权限和身份授权就是很大的问题，边缘很多是离线场景但又不是绝对的物理安全。能否继续重视安全，取决于人们的意识。</p><p></p><h3>写在最后</h3><p></p><p></p><p>今年在互联网历史上并不是高速发展的一年，甚至全球经济下行给行业发展蒙上了一层“寒霜”。但反过来，这样的环境也促进了行业不去关注各种花样繁多的新技术，而是朝着更好、更深度的方向发展，这对云来说是一种利好。</p><p></p><p>这一年，我们看到有些企业出于各种考虑开始“下云”，有人认为正常，也有人认为这是“开倒车”，而新上云的企业也要面对走出舒适圈带来的阵痛。实际上，上了云和能用好云是两码事，还有各种规模的企业坚持在云上运行，现在大家都还远没有触碰到云效益的天花板。</p><p></p><p>总体来看，明年，云原生领域的主旋律依旧是价值回归，业内围绕着切实可行的技术去落地、深入实践降本增效，变得更加务实。不够成熟的技术会努力找到降低门槛、找到被开发者接受的方式，相对成熟的技术继续深挖，给开发者创造更大的价值。</p><p></p><p>采访嘉宾介绍（按姓名首字母排序）：</p><p></p><p>丁宇（叔同），阿里巴巴研究员、阿里云智能云原生应用平台总经理</p><p>董晓聪，作业帮基础架构负责人</p><p>裴超，腾讯云高性能网络产品中心总监</p><p>冯常健，网易数帆云原生平台负责人</p><p>柯琪，微软全球副总裁</p><p>吕亚霖，作业帮基础架构 - 架构研发团队负责人</p><p>王泽锋， 华为云云原生开源负责人、CNCF 大使</p><p>于广游，腾讯云容器技术总监、TKE 产品负责人</p><p></p><p>如果你对本文感兴趣，欢迎在文末留言，或加入 <a href=\"https://xie.infoq.cn/\">InfoQ 写作平台话题讨论</a>\"。后续，迷你书、专题将集合发布于 InfoQ 官网，登录<a href=\"https://www.infoq.cn/\"> InfoQ 官网</a>\"注册并将 InfoQ 添加进收藏夹，精彩不错过。</p><p></p><p>同时，InfoQ 年度展望直播周将于 2023 年 1 月 3 日首场开播，并持续输出精彩内容，关注 InfoQ 视频号，与行业技术大牛连麦~</p>",
    "publish_time": "2022-12-27 16:16:09",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "写给架构师的技术债“偿还”指南",
    "url": "https://www.infoq.cn/article/KNjMAfLVCgk3yWtJ6VTw",
    "summary": "<p></p><h2>技术债务的类别</h2><p></p><p>技术债务是软件开发中用于比喻短期决定促使长期成本增加的现象，其中成本的增加类似于随时间增长的应计利息。更确切地说，团队当前为某个决定付出的工作越多，后期就越可能需要更高的工作量来纠正这个决定。</p><p>这一术语在软件行业内获得了不少的关注，但技术债务不是百害无一利的，它有时也能快速解决产品上市的问题。这个概念最早是由 Ward Cunningham 提出的：</p><p></p><p></p><blockquote>第一次交付的代码如同欠债一样，只要能通过重写还清，一点债务就能加速进程……但如果债务没有即时还清，那么就危险了。在问题代码上花费的每一分钟都会算作是债务的利息。地基不牢的实现所带来的债务负担甚至会让全部工程团队停滞不前，无论这种实现是否是面向对象的。【注 1】</blockquote><p></p><p></p><p>有两个重要的点需要注意。首先，技术债务往往是软件交付过程中很有帮助的权宜之计。没有任何产品时完美的，无数软件项目都曾过于沉迷“打磨”短期内完全够用的代码而就此消失。第二点则是，在长期可支持性面前，这些权宜之计可能会需要重新考量。</p><p></p><p>不过，我们还需要对“技术债务”这一词有明确定义才能避免引起混淆。Kruchten、Nord 及 Ozkaya 在他们的《管理技术债务》一书中，对技术债务的概念及相应管理方法做了很好的概述，这是他们给出的定义：</p><p></p><p></p><blockquote>在软件密集型的系统中，技术债务由设计和实现结构组成，这些短期内的权宜之计构建的技术环境，可能让未来的变动更加昂贵或不可能。技术债务是一种或有负债，主要影响内部系统质量，但不限于可维护性和可进化性。【注 2】</blockquote><p></p><p></p><p>这种定义深得我们喜爱，因为它更侧重于技术债务的影响，而非是其在金融债务方面的比喻，后者仅仅涵盖了部分问题所在。正如《实践中的持续架构》所言：</p><p></p><p></p><blockquote>对可维护性和可进化性的关注对技术债务的对可维护性和可进化性的关注度是影响技术债务看法的关键。这就意味着，如果系统没有对进化的期望，那么对技术债务的关注也应当是最小化的。以旅行者号航天器为例，其软件的技术债务是非常有限的，因为它没有进化的需求，维护的机会也有限。</blockquote><p></p><p></p><p>感兴趣的读者可以参阅注 2 中的《管理技术债务》，以获取关于该主题的更多内容。也可以在《管理技术债务》、《技术债务》，《技术债务和利息的实证模型》的参考文献部分，以及 雷曼法，找到更多关于技术债务的实证研究。</p><p></p><h2>什么是技术债务？</h2><p></p><p>依据 Kruchten、Nord 及 Ozkaya 的定义，技术债务可以分为以下三大类。</p><p></p><p>架构：由软件开发过程中的架构决策造成的债务。代码：难以维护或发展的临时代码。生产基础设施：为构建、测试和部署软件系统的基础设施和代码的决策。</p><p></p><p>此外，技术债务可以是无意为之，也可以是特意为之。许多业界人士认为潜在的缺陷是技术债务的一部分，而架构决策则几乎永远是在两个相互冲突的 QAR 之间权衡，因此后者是属于“有意为之”的分类。</p><p></p><h2>技术债务一词的不足</h2><p></p><p>每个术语都有不足，“技术债务”也不例外。</p><p></p><p>假设性。一个“技术债务”问题可能永远都不需要解决。或许代码很丑，但如果能正常运行且没什么副作用或依赖性，那团队完全可以专注于其他事，比如为客户提供价值。认为其需要修复则是夸大了问题本身。如果可以将问题影响局部化，那这个问题大概就不需要修复。与拥有贷款人的债务不同，团队的技术债务没有限制。贷款人会评估债务人的还款可能性，并为债务人违约时造成的后果寻求保障。习惯性滥用债务的人最终将再也无法拿到信贷的机会。</p><p></p><p>相比之下，软件团队的限制较少。自动或手动的架构、设计，以及代码审查之类都可以防止技术债务意外发生。但在复杂的系统中，审计无法找到的很多错误只会在运行的系统中出现。错误预算或许能让团队在解决缺陷之前不再新增更多功能，但它的前提条件是要能识别出错误，而技术债务就像是水下冰山，大部分都是看不见的。</p><p></p><p>但是在多数情况下，开发团队可以随便“发布”任何包含有意为之的技术债务，而不会有人要他们为自己不可持续的决定负责。事实上，如果他们在面向项目的资金模型组织中工作，那么他们要做的就是把项目发布到生产中去，让 IT 运维去头疼因此产生的问题，成功让自己甩锅。</p><p></p><p>决策推迟的成本会随着时间的推移迅速增长。但决策推迟实际不存在。决定在未来采取不同方法不过是额外的工作成本，而如果需要返工的代码有大量依赖，重写代码的成本将会叠加式增长（见《寻找管理架构性技术债务的指标》）。技术债务所暗含的复利意味着返工的成本增加，但却掩盖了造成成本增加的依赖原因。通过封装和模块化等设计策略，团队可以减少甚至完全消除变化所带来的成本。只要没出大事，多数组织都会无视技术债务。这就又让我们回到了第一个问题上，这些问题或许并不需要解决。而即使这些问题真的需要解决，商业利益相关者也大概不会重视。真正的问题在于“技术债务”这个词将重点仅仅放在了成本上，没有传达商业利益相关者会因为忽视技术债务而损失的东西。对于眼里只看得到一季度或一年的人来说，长远的可支持行没什么讨论的必要，也就可扩展性和防御破坏性安全漏洞有些许的说服力。技术债务很难用财务术语来量化。就像 Kevlin Henney 在 2022 年 QCon Plus 的演讲中所述（可参见 Ben Linders 的 InfoQ 文章《技术债务可量化为金融负债：开发者眼中的不可能》），管理者对团队无法衡量其技术债务的金融价值感到迷惑，对于耳濡目染“你无法衡量的东西，你也无法管理”【注 4】的人来说，无法表达技术债务的财务影响让团队看起来很不明智。</p><p></p><h2>架构决策和技术债务</h2><p></p><p>正如我们在前一篇文章中所述，软件架构是 QAR 驱动的决策，而这些决策可能对技术债务有积极或消极的影响，如图一所示。决策发生的时间决定了团队架构设计所要采取的方式。在项目之初，通常也是在确切定义 QAR 之前，便做出多数的架构决定，可能会导致前期架构不易发展，且随着对 QAR 更准确的定义，也需要大规模重构。与之相反，如果在敏捷架构中的每个阶段，逐步做出架构决策，可以更好地适应 QAR 的变化。</p><p></p><p>几乎所有的架构决策都是至少两个 QAR 之间的权衡。如安全性与可用性之间的抉择，无论怎么选都有可能增加技术债务，无论是优先考虑可用性但使系统更加脆弱，还是优先安全性但牺牲系统可用性。说到底，随着用户数量的增加，或者需要调整 QAR 的优先级才能让技术债务更可控，将来的某天我们总要面对这些问题。其他例子还有可扩展性和可修改性、可扩展性和上市时间。</p><p></p><p>这些决定通常被描述为“满足”，也就是“足够好”。虽然你还可以做得更好，但你选择在结果足够好时就停下来。正如《实践中的持续架构》中所言，“架构决策可以增加或削减技术债务”【注 5】。然而，具体增加或削减了多少，这是很难用财务甚至技术术语来量化的。</p><p></p><p>除非团队成员非常幸运或者知识极其渊博，否则无论是通过什么方法，他们所做的部分技术决策可能都需要根据反馈回路所带来的信息（见图一）在未来进行调整甚至彻底重做。对现有的架构决策进行调整或重做会产生额外工作量，并与其他积压的任务相竞争，后者常被期望能向利益相关者提供有用功能而被认为拥有更高优先级。因此，调整或重做架构决策相关的工作可能会被推迟，从而进一步增加系统的“技术债务”。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/63/6359fd9ea5d5d4bdf7d1a6e3c9ef12eb.png\" /></p><p></p><p>质量属性、架构决策、技术债务与反馈循环</p><p>每当团队做出决策时，都要做好所有这个决策相关工作在未来都可能要返工的准备。因此，团队需要将决策视作是需要在相当短的时间内验证或需要的假设，以确保所作的工作在未来的某一时刻不会被删除。</p><p></p><p>因为所有工作至少在验证之前，都有可能产生额外的返工工作量，所以，团队可以尝试以下几点：</p><p></p><p>推迟决策到万不得已时再决定；尽快验证必须做出的决策，以限制潜在的成本风险；通过封装和抽象等设计技巧减少依赖关系的增长。</p><p></p><p>了解并接收决策对技术债务的影响有助于团队更好地做出决策。但由于其很难通过财务术语量化，技术债务对评估决策成本没有帮助，且很难被用作是评估至少两个 QAR 之间权衡的精确评估工具。</p><p></p><p>让我们再回到安全性与可用性的例子。要想在短时间内部署一个 MVP，我们很难估算最小可用架构（MVA）在优先可用性而非安全性时所带来的财务影响。更好的方案是做出一系列最小化决策后，随着时间的推移，借助经验对其进行测试和发展。这些决策应当搭配一套最小架构实践加以补充，以帮助团队在发展产品的同时保持架构的可行性。</p><p></p><p>当然，架构工作中最重要的一部分就是沟通，即使我们无法将与决策相关的技术债务数量进行准确量化，还是可以利用这一比喻可以帮助团队沟通决策的长期影响。</p><p></p><h2>延迟维护：或许是更合适的用词？</h2><p></p><p>技术债务在工程界有另一个说法：延迟维护。延迟维护是设计优秀的大桥断裂、设计优秀的大楼坍塌、设计优秀的飞机从空中坠落的原因。在物理学中，熵的增加是有代价的，而如果无法领先熵的增长将会产生灾难性后果。</p><p></p><p>分析物理学延迟维护成本的优势在于，我们能更清晰地看到维护被推迟时，成本是如何快速累加的：如果底层钢板没什么问题，那么密封图层就足够了。而一旦钢板开始锈蚀，在重新喷漆之前就必须先清理干净旧涂层和铁锈。如果钢板已经出现裂痕，那么就还需要加固，裂痕过于严重甚至还可能需要更换全部的结构。</p><p></p><p>对于软件来说，事情远没这么简单。错误不易被检查发现，再加上组件之间交互导致返工可能影响到全部代码库。即使是“简单”的组件替换也会非常困难，因为新组件可能有副作用，或者需要不同的参数数据，而调用它的代码可能无法访问这些数据。如果变动的是如调整算法等更深层次代码，那么成本将会是指数级地增加。</p><p></p><p>但就如“维护”一词也是有限制的。“维护”通常是指对磨损部件的简单维护，但软件不会随着使用而磨损。软件的变化可能由外部事件引起，如操作系统或框架的变化、供应商倒闭，或者基础设施软件的新版本，以及更具破坏性的，由客户行为、商业运作或组织战略变化等造成的影响。</p><p></p><p>每一种用词都有其局限性，有时我们必须抛弃这些术语，才能找到更好的模型来帮助我们做出决策。</p><p></p><h2>结论</h2><p></p><p>多数团队并不认为目前的决策在未来可能会被撤销或返工，但现实中事情总会发生变化，而我们需要不同的方式以面对这些变化。虽然团队无法预测未来，但他们可以通过实验，在变更所带来的影响变得无法接收之前检测出这种可能性。</p><p></p><p>技术债务是对未来变更工作量已知的一个例子，常发生于团队决定推迟必须要完成的工作量。债务一词意味着，处理这类变化所需的成本将会随着时间的推移呈指数上升，与复利类似。但矛盾的是，正如我们在本文中所述，技术债务很难用财务术语进行量化，这也限制了它在决策评估成本模型中的作用。</p><p></p><p>虽然技术债务有助于向利益相关者传达团队决策的技术影响，但更合适的方法是通过质量属性要求重塑讨论，让利益相关者将其看作是软件系统必备的能力，而非是需要完成的工作量。</p><p></p><p>最后，感谢 Thomas Betts、Murat Erder、John Klein、Philippe Kruchten 以及 Eoin Woods 为本文的初版审阅。</p><p></p><h2>尾注</h2><p></p><p>Ward Cunningham，《WyCash 投资组合管理系统》，ACM SIGPLAN OOPS Messenger4, no.2 (1992)Philippe Kruchten, Rod Nord, and Ipek Ozkaya, 《管理技术债务：减少软件开发中的摩擦》(Addison-Wesley, 2019).Murat Erder, Pierre Pureur, and Eoin Woods, 《实践中的持续架构》 (Addison-Wesley, 2021)这句话经常被认为是 Peter Drucker 和 W.Edwards Deming 说的。Murat Erder, Pierre Pureur, and Eoin Woods, 《实践中的持续架构》 (Addison-Wesley, 2021)</p><p></p><p>原文链接：<a href=\"https://www.infoq.com/articles/technical-debt-tells-you/\">https://www.infoq.com/articles/technical-debt-tells-you/</a>\"</p><p></p><p></p><h5>相关阅读：</h5><p></p><p></p><p><a href=\"https://xie.infoq.cn/article/dfc3d5f90b35097f302e04603\">中台是企业架构的又一次实践吗？</a>\"</p><p></p><p><a href=\"https://xie.infoq.cn/article/adaeb3092ea6ae303f5fac1b4\">企业级业务架构设计：方法论与实践学习笔记二</a>\"</p><p></p><p><a href=\"https://xie.infoq.cn/article/a686033bb921267fdf8e0c71a\">阿里是如何使用分布式架构的？阿里内部学习手册分享</a>\"</p><p></p><p><a href=\"https://xie.infoq.cn/article/460610c8ceb31423663c26213\">Github 限时开源！Alibaba 最新版亿级高并发系统架构</a>\"</p>",
    "publish_time": "2022-12-27 16:44:49",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "加载速度提升 15%，关于 Python 启动加速探索与实践的解析",
    "url": "https://www.infoq.cn/article/dlNNaJu9qNlxFysI8uL0",
    "summary": "<p></p><blockquote>在 PyCon China 2022 大会上，龙蜥社区开发者严懿宸分享了主题为《Python 启动加速的探索与实践》的技术演讲。本次演讲，作者将从 CPython 社区相关工作、本方案的设计及实现，以及业务层面的集成等方面进行介绍。本文为本次演讲内容整理。</blockquote><p></p><p></p><h2>一、Python 启动速度简析</h2><p></p><p></p><p>首先从一个 <a href=\"https://www.infoq.cn/article/XahMWSZLXwqYo6TWKDvg\">Python 3</a>\" 中空解释器启动时间的好事分析开始。我们可以看到，主要的耗时都和 Python 包加载有关。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/f7/f726b0c8a4b9f18025c91ba70d9e02d2.png\" /></p><p></p><p>其中，CPU 时间中包加载占据了 30% 左右的时间；而 37% 的等待时间中，磁盘 IO 等花费的时间也和包加载有较大的关联。</p><p></p><p>熟悉 Python 机制的朋友大概知道，Python 中加载一个包首先会搜索对应的 pyc 文件，这是一种序列化的字节码格式。找到之后会对其进行反序列化，并执行其中的代码。如对应的 pyc 文件不存在，会重新编译 py 文件得到字节码，并序列化为 pyc 文件持久化保存。我们优化的主要目标主要集中在加载包这个过程，希望能够至少免去每次查找、读取、反序列化的开销。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ec/ec8ecd8e5d9662fb3846d5c14e79ff9e.png\" /></p><p></p><p>以 <a href=\"https://xie.infoq.cn/article/3c04ebb2013b34be7937fd077\">Python3.10</a>\" 为例，这里是使用 python 解释器启动一个空语句的所需时间，同时使用了&nbsp;-Ximporttime&nbsp;打印出过程中加载每一个包的耗时。可以粗略地看到，包加载时间大约占了总时间的 30% 左右。我们发现这种情况和 Java 虚拟机类似。在 Java 中，Java 会首先将 Java 源代码编译为 Java 字节码，随后由 Java 命令执行。</p><p></p><p>我们知道 Java 的优势并不包括启动速度，这种流程也是原因之一。那么 Java 如何部分解决这个问题呢？</p><p></p><h2>二、PyCDS&nbsp;（代码对象共享）设计与实现</h2><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/0b/0bded78eaa1a4f2b37a0cb58255525ff.png\" /></p><p></p><p>Java 中有一个叫做&nbsp;CDS/AppCDS&nbsp;的机制，通过将 Java 字节码和一些辅助数据持久化保存，在后续启动时使用 mmap 加载，节约了磁盘 IO 和解析验证 class 文件的开销。</p><p></p><p>很自然的想法是，如果我们希望在 Python 中使用类似的技术，目标应该是&nbsp;Python 字节码。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/28/28a92946af0ae9be5f9f74f095cbb3ce.png\" /></p><p></p><p>Python 默认从 py 文件导入模块的逻辑如上图左边所示，首先根据制定的名字获取对应的规则，随后尝试寻找 pyc 文件或重新编译。最后，使用 exec 命令利用代码和一个空 dict 来创建模块，并加入 runtime。</p><p></p><p>我们做的事情可以简化为右侧逻辑。同样根据包名，尝试从 mmap 中加载。如果成功，那么同样的 codeobject 也可以用于初始化。</p><p></p><p>这样做有什么直接的障碍？</p><p></p><p>可以看到，Python 中代码对象的 C 数据结构大致如图，包括 consts、string、bytes 等&nbsp;Python 数据类型。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/18/1879c179479ab6e6388bd8e6000cd32c.png\" /></p><p></p><p>以使用到的 codeobject 作为 root，将涉及的数据序列化存储到内存映射中。</p><p></p><p>在这一步，最直接的问题是内存随机化机制。在处理 code object 中的 Python 对象时，每个 Python 对象头中都保存着指向当前进程中对应类型信息的指针。Runtime 通过这个指针判断该对象在 Python 中的类型。</p><p></p><p>以 PyCode_Type 为例，如果不做处理，这里会丢失类型信息（红色 offset）。</p><p></p><p>为了解决这个问题，在我们创建的镜像文件中会保存涉及的对象指针。在加载时动态 patch 相关的指针。</p><p></p><p>在整个过程中涉及的&nbsp;Python 类型包括：</p><p></p><p>1. 常量（bool/None/ellipsis）</p><p>2. 字面量（float/complex）</p><p>3. 需要额外分配的变量（long/bytes/str）</p><p>4. container（tuple/frozenset）</p><p></p><p>对于常量和字面量，在内存映射中分配好空间后直接赋值即可保存；对于后两种，需要模拟 Python 中变量初始化的逻辑，创建合适的内存大小并写入对应位置。同时，对于非常量的类型，还需要对内存映射中的引用计数额外赋值，防止意外触发 Python 中的回收。</p><p></p><p>以上就是本项目的大致内容，另外关于项目的具体用法请前往&nbsp;PyCDS&nbsp;项目主页或我们在<a href=\"http://mp.weixin.qq.com/s?__biz=Mzg4MTMyMTUwMQ==&amp;mid=2247489934&amp;idx=1&amp;sn=0fa6e8987d07bfe3a2346a2a8109e6d0&amp;chksm=cf66eafcf81163ea2aabf64368eb06cbc7eac9c031099e13ba382e27f918bd57d4ff38402a26&amp;scene=21#wechat_redirect\">龙蜥实验室</a>\"上的课程查看，链接见下：</p><p>龙蜥实验室课程：</p><p>https://lab.openanolis.cn/#/apply/chapters?courseId=117</p><p>&nbsp;PyCDS&nbsp;主页：</p><p>https://github.com/alibaba/code-data-share-for-python</p>",
    "publish_time": "2022-12-27 18:25:37",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]