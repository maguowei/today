[
  {
    "title": "解读Go语言的2022：泛型时代开启",
    "url": "https://www.infoq.cn/article/W8pG2j0kB9JVKkluM5BO",
    "summary": "<p>作者 | 郝林</p><p>编辑 | 蔡芳芳</p><p></p><p>本文是 “2022 InfoQ 年度技术盘点与展望” 系列文章之一，由 InfoQ 编辑部制作呈现，重点聚焦 Go 语言在 2022 年的重要进展、动态，希望能帮助你准确把握 2022 年 Go 语言的核心发展脉络，在行业内始终保持足够的技术敏锐度。</p><p></p><p>“InfoQ 年度技术盘点与展望”是 InfoQ 全年最重要的内容选题之一，将涵盖操作系统、数据库、AI、大数据、云原生、架构、大前端、编程语言、开源安全、数字化十大方向，后续将聚合延展成专题、迷你书、直播周、合集页面，在 InfoQ 媒体矩阵陆续放出，欢迎大家持续关注。</p><p></p><p>之所以在这样一篇年度解读文章的标题直接提到“泛型”，是因为 Go 语言的泛型在 2022 年终于浮出了水面！并且，它在功能方面已经大致完整了。圈内的开发者们都知道，这是 Go 社区（当然包括中国的 Go 社区）多年请愿的结果。</p><p></p><p>虽然 Go 语言是 Google 公司出品并主导开发的，但它毫无疑问也是广大 Go 语言爱好者的心头肉。可以说，对于 Go 语言泛型的正式登场，至少有一半功劳属于 Go 语言的爱好者们。</p><p></p><p>肯定会有一些程序员，尤其是那些不以 Go 为主要语言的程序员会说“Go 语言的进展太慢了，其他众多新的编程语言甚至那些较老的编程语言早就支持泛型了，可 Go 语言墨迹了这么多年才搞出泛型”。确实，单就泛型这方面来说，Go 语言的脚步确实很慢，可这主要是因为 Go 语言想要做到完全向后兼容，并力求让 Go 语言的泛型完美契合其自身的精炼的编程哲学和简约的编码风格。要知道，做加法容易，而做减法却很难。不过不管怎样，Go 语言的泛型终于落地了！就连现如今清心寡欲的作者也忍不住心中的喜悦！</p><p></p><p>好了，感慨完毕，我们还是回归正题吧。下面，我们就一起从头至尾捋一捋 Go 语言在 2022 年的发展和变化，以及它将会在 2023 年如何继续前行。</p><p></p><p></p><h2>趋势概览</h2><p></p><p></p><p>Go 在今年的 11 月 10 日刚满 13 岁。它已经长大并进入了少年期，不算是一门新的编程语言了。但 Go 依然保持着非常好地向后兼容。很显然，这是一件很不容易的事。</p><p></p><p>从业界知名的编程语言排行榜 TIOBE Index 绘制的折线图来看，Go 语言的采用趋势在过去三年间基本上保持平稳。</p><p></p><p>更具体地说，根据使用情况统计，在 2020 年下半年到 2021 年上半年的这段时间里，Go 语言的使用率有略微提升，但时至今日又差不多回到了 2019 年的水平。与其在 2016 年到 2017 年间的大爆发相比，如今 Go 语言的使用率已经基本上稳定下来了。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/d6/d67faded3bb1aa56be1fa18d8be86562.png\" /></p><p></p><p>图 1 - TIOBE Index 之 Go 语言趋势</p><p></p><p>不过，就作者个人而言，感觉是有些奇怪的。按理说，Go 语言泛型的落地应该能够引起一波采用 Go 语言的小高潮，但事实上这一情况并没有出现。这可能就是“波澜不惊”的最佳诠释吧？可能因为大家都等得太久了，真到了重大的新特性来临之时却不太能兴奋得起来了。</p><p></p><p>当然了，这也可能是因为 Go 语言在应用领域方面的攻城掠地已经基本完成，而且在其优势领域的使用率已经趋于饱和。而对于那些新兴领域，比如机器学习、人工智能、机器人、元宇宙等，Go 语言还没有显著的优势，尤其是还没有杀手级框架或工具出现。在这种情况下，Go 语言在使用统计上的平稳趋势也是一种必然。</p><p></p><p>现在换一个维度，我们横向来看，Go 语言的排名相较于前两年有比较明显的提升。如下图所示。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/79/79c37fcde1522d94595e36ec3d117c25.png\" /></p><p></p><p>图 2 - TIOBE Index（2022 年 11 月）</p><p></p><p>我们可以看到，Go 语言在 2021 年年底的 TIOBE Index 排名中位于第 18 位。这低于它在 2020 年年底的排名（第 16 位），以及它在 2019 年年底的排名（第 15 位），也算是一个小谷底了。然而，在今年的年底，Go 语言的排名却大幅提升了，甚至，它已经摸到了 Top10 的边界！如果作者没记错的话，Go 语言最近一次进入 Top10 是在 2018 年的年底。如今，4 年过去了，Go 语言终于又有希望重回 Top10 了。</p><p></p><p>我们还可以看到，至今常年占据 Top10 的依然是那些老生常谈，甚至是那些老得不能再老的编程语言。相比之下，Go 语言真真切切算是年轻一派的优秀编程语言了。当然，除了 Go 语言之外，还有图形化的儿童编程语言 Scratch、Apple 公司出品的编程语言 Swift，以及近年来出尽风头的系统级编程语言 Rust。它们都很年轻，却都已经进入了 Top20，也是非常优秀的。作者也很看好它们。</p><p></p><p>在简单分析了 Go 语言在 TIOBE Index 中的排名之后，我们再来看看新晋出炉的 StackOverflow Developer Survey 2022 吧。众所周知，StackOverflow 是全球最大的编程社区和专业问答网站。它的 Developer Survey 报告属于年度总结性报告，已经有好多年的历史了，并且深受全球软件开发者的关注和喜爱。</p><p></p><p>我们下面重点说说其中与 Go 语言强相关的内容。至于其他的内容，大家如果有兴趣的话，可以点开前面的超链接仔细阅读完整报告。</p><p></p><p>在“使用率最高的编程语言（专业组）”这一栏中，Go 语言的排名是第 13 位（如下图）。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/02/02274124410f6bdfec7438d85df888ce.png\" /></p><p></p><p>图 3 – Stackoverflow Developer Survey 2022 之使用率最高的编程语言（专业组）</p><p></p><p>如果只考虑通用的跨平台编程语言的话，Go 语言仅次于 Python、Java、C++ 和 C。这与它在 TIOBE Index 中的情况是相同的。有的程序员可能会说“JavaScript 和 TypeScript 现如今也可以算是通用的跨平台编程语言”。当然，从某种角度看，我们可以这样说。但是，它们终归不是原生的通用编程语言，都需要额外的工具或框架才能够实现“通用”。因此，我们稍微严格一点，暂且不把它们计算在内。</p><p></p><p>在应用级框架和工具栏目中，作者发现 Docker 和 Kubernetes 今年依然非常火爆。作为常用的基础工具，它们深受广大软件开发者的追捧。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/07/07e21478dd0b0eef4b94bca9c30b74f1.png\" /></p><p></p><p>图 4 – Stackoverflow Developer Survey 2022 之最受欢迎的基础工具（全体组）</p><p></p><p>从上面这幅截图我们可以看出，Docker 和 Kubernetes 在当前的排名中都已经进入了 Top5。甚至，如果只考虑专业的软件开发者的话，Docker 甚至超越了 npm，拔得头筹！</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/5d/5d0d36bb207d62c86970dfbdd3fde3bf.png\" /></p><p></p><p>图 5 – Stackoverflow Developer Survey 2022 之最受欢迎的基础工具（专业组）</p><p></p><p>毫无疑问，npm 是 JavaScript 世界中 Top1 的工具，其应用是相当相当广泛的。更何况，在全世界的软件开发者当中，不论是专业的开发者还是业余的开发者，使用 JavaScript 语言的人都是最多的。所以，Docker 能够超越它真的是一件非常值得骄傲的事！</p><p></p><p>大家应该都知道，Docker 和 Kubernetes 都是使用 Go 语言开发出来的。在云计算领域，尤其是容器技术领域，它们都是绝对的王者！因此，如果你想进入云计算领域，或者想使用 Go 语言开发基于云的应用程序，那么最起码应该学会甚至熟练使用 Docker。</p><p></p><p>好啦，以上算是一个令人激动的小插曲。现在，让我们把焦点再转回到编程语言的排名上来。</p><p></p><p>在 Stackoverflow Developer Survey 的报告中，有一个非常有特色的栏目。我们经常戏称它为“爱恨交织”栏目，其原名是“Most loved, dreaded, and wanted”。</p><p></p><p>在这个栏目里，共有七万一千多名开发者回答了相应的问题。在他们当中，有 64.58% 的人喜爱 Go 语言，而有另外的 35.43% 的人憎恨 Go 语言（或者说对 Go 语言有恐惧感）。在所有为大众所熟知的编程语言当中，Go 语言排在了第 8 位。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/71/71fc7191947ddcc27fc297caa566178f.png\" /></p><p></p><p>图 6 – Stackoverflow Developer Survey 2022 之让人“爱恨交织”的编程语言</p><p></p><p>在这份排名中的 Rust、TypeScript 和 Julia 作为更加年轻的编程语言后来居上。不过，如果我们查看相邻的“最想学习的编程语言”排名的话，就会发现 Go 语言的位置靠前了很多，处于第 4 位，仅次于 Rust、Python 和 TypeScript，并且从百分比数值上来看相差无几。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/7f/7fc137b987565485845e695dd06e3242.png\" /></p><p></p><p>图 7 – Stackoverflow Developer Survey 2022 之大家最想学习的编程语言</p><p></p><p>看起来，程序员们应该都很喜欢追新，不是吗？这起码与作者的所见所闻是比较吻合的。当然了，只有那些优秀的新兴编程语言才有进入 Top10 的机会。</p><p></p><p>可以想象，Docker 和 Kubernetes 在这个“爱恨交织”栏目中肯定是名列前茅的。事实也确实如此，它们分列“Loved vs. Dreaded”一栏中的前两位。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/2f/2f8257983b3697ae7e954ecc12e6e072.png\" /></p><p></p><p>图 8 – Stackoverflow Developer Survey 2022 之让人“爱恨交织”的基础工具</p><p></p><p>而且，在“Want”一栏，它们拥有着一骑绝尘的态势。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/c6/c63950f475b2b9a6860a096b75388dd0.png\" /></p><p></p><p>图 9 – Stackoverflow Developer Survey 2022 之大家最想学习的基础工具</p><p></p><p>顺便说一句，在“爱恨交织”栏目里，同样拥有“一骑绝尘”态势的还有 Visual Studio Code（以下简称 VSCode）。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/65/65d5193c317bb8325ef4d4ed79faddb0.png\" /></p><p></p><p>图 10 – Stackoverflow Developer Survey 2022 之大家最想学习的集成开发环境</p><p></p><p>作者为什么会在这里提到 VSCode 呢？因为，在 2022 年订阅我的技术专栏的读者当中，非 gopher（gopher 的意思是 Go 语言粉丝）的人明显增多。他们问的最多的一个问题就是：“要是使用 Go 语言开发程序的话，有哪些好用的代码编辑器或者 IDE 吗？”</p><p></p><p>我的回答一般都是 VSCode 和 GoLand。</p><p></p><p>微软公司出品的 VSCode 是 Go 语言爱好者最常用的免费代码编辑器。我们使用它时，外加 Go 语言官方团队出品的 vscode-go 插件就基本上可以满足平常的需求了。</p><p></p><p>而 GoLand 是 JetBrains 公司出品的，但它收费而且价格不菲。作者在这里绝不是给 JetBrains 公司做广告，但是 GoLand 真的很贵、很好用。如果你对于配置编程工具非常不耐烦，并且预算很充足的话，那么我会强烈推荐你使用 GoLand。</p><p></p><p>顺便说一句，如果你是 Vim 那一派的话，Go 社区中也有相应的 vim-go 插件。</p><p></p><p>好了，关于 Go 语言发展趋势的整体解读，我们就暂告一段落吧。下面，我们从更新迭代的角度来看看 Go 语言在 2022 年都有哪些进展。</p><p></p><h2>年度回顾</h2><p></p><p></p><h3>支持泛型</h3><p></p><p></p><p>Go 语言在 2022 年最大的变化莫过于添加了对泛型（generics）的支持。这对于 Go 语言的广大使用者来说，也是感受最明显的变化。</p><p></p><p>早在 2022 年 2 月正式发布的 1.18 版本，Go 语言就包含了类型参数提案（即 Type Parameters Proposal）中描述的通用功能的实现。这包括了需要对 Go 语言本身进行的主要的更改。注意，这些更改是完全向后兼容的。这也是 Go 语言官方对于 Go 1.x 版本更新的一贯原则和保证。</p><p></p><p>Go 语言官方团队为此编写和修改了大量的代码。虽然这些代码并未经过超大规模的验证，但是 Go 语言团队对它们的质量和功效是非常有信心的。不过，也不排除这种可能：一些使用泛型的代码适用于 1.18 版本，但在以后的版本中会变得无效，或者说需要稍加修改才能使其有效。因为，这次为了支持泛型的改动实在是太大了。按照 Go 官方的说法，这种不完全兼容的可能性会被尽可能减小，但是无法对此做出 100% 保证。</p><p></p><p>虽然我们都喜欢 100% 确定的东西，但是万事万物都不可能有 100% 的稳定性和可预测性。尤其是，对软件开发有一定理解的朋友们肯定都知道，没有哪一个软件是没有 bug 的，也没有哪一个软件功能可以保证 100% 的正确。所以，我们需要用更加宽容的心态来看待 Go 语言的这次超大级别的更新。</p><p></p><p>实际上我们也不用太过担心。因为从 Go 语言的 issue 列表上看，泛型相关的 bug 如今也已经发现和修复得差不多了。Go 语言的泛型已经趋于稳定，我们已经可以放心地将其用在生产级代码上了。</p><p></p><p>从语法上说，Go 语言的类型参数（可以理解为“泛型”的另一种称谓）并未使用那个在其他编程语言中常见的尖括号（即“&lt;”和“&gt;”），而用的是方括号（即“[”和“]”）。这也是程序员们感受的最大一点不同。</p><p></p><p>请注意，我们在这里所说的“对泛型的支持”实际上是“对自定义泛型的支持”。因为 Go 语言内置的一些数据类型从一开始就是支持泛型的，比如：</p><p></p><p><code lang=\"go\">var map1 = map[int]string{}\n</code></p><p></p><p>或者</p><p></p><p><code lang=\"go\">var slice1 = []string{}\n</code></p><p></p><p>然而，在 Go 1.18 之前，使用者们自己编写的函数或者类型是无法添加泛型定义的。</p><p></p><p>下面重点来了。在 Go 1.18 中，对泛型的具体支持都有哪些呢？请看下文。</p><p></p><p>1. 自定义的函数声明或类型声明都可以包含类型参数。</p><p></p><p>请看如下代码：</p><p></p><p><code lang=\"go\">type Pair[K ~int, E ~string] struct {    \n    Key  K    \n    Elem E\n}\n</code></p><p></p><p>所谓的类型参数声明，其实就是对一个类型所涉及到的关联类型的泛化定义。例如，对于结构体类型中的每个字段，我们都必须分别定义其类型。这些字段的类型就是它们所属的结构体类型的关联类型。</p><p></p><p>这里的泛化定义的意思是，我们在声明一个类型的时候，并不指定它的关联类型具体是哪一个或哪几个，而只定义相应的范围。等到这个类型被实例化的时候，再由那个编写实例化代码的程序员去设定类型参数的具体信息。这样的话，我们就可以定义出更加抽象的类型，而把具体化的工作留给使用它的人。</p><p></p><p>这与“声明接口类型，并把其作为某些函数参数或变量的类型”的编程手法有着异曲同工之妙，都是为了提升代码的灵活性，并增强其扩展的能力。不过需要注意的是，类型参数的值与函数参数的值或变量的值是不同的。一个类型参数的值必须是代表了某个已存在类型的标识符（或者说类型字面量）。另外，类型参数值代表的既可以是结构体这样的具体类型，也可以是接口那样的抽象类型。而函数参数或变量的值，则必须是某个具体类型的确切值。</p><p></p><p>另一方面，Go 语言的类型参数声明与它的函数参数声明是类似的。在上述代码的方括号中，K 和 E 分别是两个类型参数的标识符，类似于函数参数的名称。而～int 和～string 则分别是两个类型参数的类型约束（type constraint），类似于函数参数的类型声明。至于在 int 和 string 的前面为什么会有“～”这个符号，我们稍后再说。</p><p></p><p>正因为结构体类型 Pair 的声明里包含了类型参数 K 和 E 的声明，所以在它的主体当中，我们自然可以自由地使用 K 和 E。如代码所示，我们把 Pair 的字段 Key 的类型声明为 K，并把字段 Elem 的类型声明为 E。这样一来，Pair 的类型参数就与其主体实现了联动。这种联动将会在我们对 Pair 类型进行实例化的时候得以体现。</p><p></p><p>2. 对于带有类型参数的函数或类型，可以通过在它们的名称后面追加方括号并指定相应的类型参数值来进行实例化。</p><p></p><p>示例如下：</p><p></p><p><code lang=\"go\">var pair1 Pair[int, string] = Pair[int, string]{\n    Key: 1,\n    Elem: \"a\",\n}\n</code></p><p></p><p>我们在这里声明了一个 Pair[int, string] 类型的变量 pair1，并把一个 Pair[int, string] 类型的值赋给了它。请注意，我们在对一个带有类型参数的类型进行实例化的时候，也必须对它的类型参数进行实例化。在这里，Pair[int, string] 中的 int 和 string 就是分别对 Pair 的类型参数 K 和 E 的实例化。</p><p></p><p>还记得吗？我们当初在声明 Pair 类型的时候，把它的类型参数列表编写成 [K ~int, E ~string]。其中，~int 是类型参数 K 的类型约束，而~string 则是类型参数 E 的类型约束。那么，这里的 Pair[int, string] 中的 int 和 string，分别作为 K 和 E 的值就是合法的，可以通过编译。至于为什么，我们马上就会说到。</p><p></p><p>先接着看其余的代码。因为在 Pair 类型的声明当中，字段 Key 的类型声明是 K，字段 Elem 的类型声明是 E。所以，在实例化 Pair[int, string] 的时候，我们自然就可以把某个 int 类型的值（这里是 1）赋给 Key，并把某个 string 类型的值（这里是\"a\"）赋给 Elem。</p><p></p><p>3. 新符号“~”已被添加到了运算符和标点符号的集合中。</p><p></p><p>我们再看 Pair 类型的声明：</p><p></p><p><code lang=\"go\">type Pair[K ~int, E ~string] struct {    \n  Key  K    \n  Elem E\n}\n</code></p><p></p><p>我们大可以把这里的符号“～”理解为“潜在”。代码“K ~int”的意思是，只要一个类型（假定为 A）的潜在类型是 int，那么就可以满足我们在这段代码中对 K 所做的类型约束，这就意味着 A 类型的字面量可以作为类型参数 K 的值。同样的道理，代码“E ~string”的意思是，只要一个类型（假定为 B）的潜在类型是 string，那么就可以满足我们在这段代码中对 E 所做的类型约束，这就意味着 B 类型的字面量可以作为类型参数 E 的值。也正因为如此，类型 Pair[int, string] 才是合乎语法规则的，它的类型参数都已通过了有效的实例化。</p><p></p><p>至于什么是“潜在类型”，Go 语言规范对此有明确的解释。具体内容是：每个类型 T 都有一个潜在类型。如果 T 是 Go 语言内置的布尔类型、数字类型、字符串类型之一，或者是某个类型字面量，那么相应的潜在类型就是 T 本身。否则，T 的潜在类型就是 T 在其声明中引用的类型的潜在类型。</p><p></p><p>下面举个例子。如果我们又编写了如下代码：</p><p></p><p><code lang=\"go\">type MyInt int\ntype MyStr string\n</code></p><p></p><p>那么，对于当前的 Pair 类型声明来说，下面的代码也是合法的：</p><p></p><p><code lang=\"go\">var pair2 Pair[MyInt, MyStr] = Pair[MyInt, MyStr]{\n  Key: 2,\n  Elem: \"b\",\n}\n</code></p><p></p><p>更确切的说，类型 Pair[MyInt, MyStr] 是合乎语法规则的。因为，从前面的说明和代码可知，MyInt 的潜在类型是 int，而 MyStr 的潜在类型是 string。它们分别符合 Pair 类型的声明里对类型参数 K 和 E 的定义。</p><p></p><p>4. 接口类型的声明中现已允许嵌入任意类型，以及由符号“｜”联结的联合类型和由~T 代表的类型元素，而不只是之前允许的其他接口类型。不过，这样的接口只能用于泛型中的类型约束。</p><p></p><p>这段话是什么意思呢？我们来详细解析一下。</p><p></p><p>为了配合 Go 语言对泛型的支持，官方团队对接口类型的声明语法做了很多的增强。</p><p></p><p>使用 Go 语言的程序员们都知道，以前的接口声明只能像下面这样：</p><p></p><p><code lang=\"go\">type Reader interface { \n Read(p []byte) (n int, err error)\n}\n</code></p><p></p><p>或者这样：</p><p></p><p><code lang=\"go\">type ReadCloser interface { \n Reader \n Close() error\n}\n</code></p><p></p><p>也就是说，在接口类型声明的主体中，我们可以嵌入任意数量的非重复的方法声明，也可以嵌入任何其他非重复的接口类型（用接口名称来代表）。我们称这两者为合法的接口元素。但除此之外，我们就不能添加任何东西了。</p><p></p><p>然而，从 Go 1.18 开始，合法的接口元素又多了一种。Go 官方把这种接口元素称为类型集合（type set）。</p><p></p><p>一个类型集合可以仅包含单独的类型（由类型的名称代表，如：T），也可以包含代表了某个潜在类型的～T，还可以是联合类型（如：T1｜T2｜T3，其中的符号“｜”可以被理解为“并集”），甚至可以是它们的混合（如：T1｜～T2｜～T3）。而且，对此我们可以分多行来写，只要它们所代表的类型是具体的且不存在重复即可。</p><p></p><p>不过要注意，包含了类型集合的接口类型只能被用在泛型相关的类型约束当中。例如，有如下代码：</p><p></p><p><code lang=\"go\">type FloatUnion interface {\n ~float32 | ~float64\n}\n\ntype FloatMaker interface {\n FloatUnion\n MakeZero()\n} \n</code></p><p></p><p>可以看到，含有类型集合的接口 FloatUnion 是可以被嵌入到其他接口类型的声明里面的（或者说，其他的接口类型可以扩展 FloatUnion 接口）。但如此一来，不但 FloatUnion 接口不能被用作任何值、变量、字段、参数、结果的类型，而且 FloatMaker 接口也会是这样。换句话说，对这种接口的用途限制具有传递性。</p><p></p><p>5. 新的内置标识符 any 是空接口的别名。它可以代替 interface{}。</p><p></p><p>这一条说得很直白。单词 any 现在属于关键字了。它代表了空接口，也就是 interface{}。但是，空接口本身的含义却因泛型支持的出现而增多了。</p><p></p><p>从 Go 1.18 开始，空接口自带类型集合，并且它的类型集合包含了所有的非接口类型。注意，这里的“所有”不但代表当前已存在的所有非接口类型，而且还囊括了将来会在程序中出现的所有非接口类型。也就是说，空接口的类型集合拥有无限多的非接口类型。</p><p></p><p>这与空接口的设立初衷是一致的，即：空接口是包罗万象的，也是类型之树的唯一树根。在 Go 语言中，任何接口都是空接口的扩展接口，任何类型都是空接口的实现类型。这样来看，任何类型，不论是抽象类型还是具体类型，都是对空接口所代表的类型空间的进一步圈定。</p><p></p><p>对于类型参数中的类型约束来说也是这样。空接口的类型集合包括了无限多的非接口类型，这使得任何类型约束所代表的类型集合都将是空接口的类型集合的一个子集。这是“进一步圈定”的另一种表现形式。因此，空接口在 Go 语言全面支持泛型之后，依然能够作为其类型系统的根基。</p><p></p><p>6. 新的内置标识符 comparable 也代表一个接口类型。</p><p></p><p>顾名思义，comparable 接口的含义是“可比较的”。只要一个类型符合以下两种情况中的一种，我们就可以断定它实现了 comparable 接口：</p><p></p><p>这个类型不是接口类型，并且它的值可以通过使用操作符 == 或 ！= 进行比较。这个类型是接口类型，而且其类型集合中的每一个类型都实现了 comparable 接口。</p><p></p><p>比如，像 int、float32、rune、string 这样的基本类型肯定都实现了 comparable 接口，而切片（slice）类型、字典（map）类型以及任何的函数类型肯定就不是 comparable 接口的实现类型。</p><p></p><p>再比如，我们在前面声明过的 FloatUnion：</p><p></p><p><code lang=\"go\">type FloatUnion interface { \n ~float32 | ~float64\n}\n</code></p><p></p><p>可以确定它肯定实现了 comparable 接口。但如果我们把其中的~float64 替换为~[]float64，那么它就不再是 comparable 接口的扩展接口了。</p><p></p><p>请注意，comparable 接口，以及任何直接或间接地嵌入了（或者说扩展了）comparable 的接口都只能被用于类型约束。它们不能被用作任何值、变量、字段、参数、结果的类型。</p><p></p><p>显而易见，与 any 接口一样，comparable 接口也是专门为了类型参数（或者说泛型）才引入的。同样的，comparable 接口也自带了类型集合。它的类型集合包含了所有可以被比较的类型。这样的类型既可以是已经存在的，也可以是尚未出现的。</p><p></p><p>除了上述 6 个很重要的改动之外，Go 团队还为使用者们准备了 3 个实验性质的代码包。这些代码包并不在 Go 标准库当中，而是位于 Go 语言官方专门设立的实验包 golang.org/x/exp 里。这意味着，它们的 API 并不在 Go 1.x 的兼容性保证范围之内。并且，随着 Go 团队对泛型支持的进一步深入，这些代码包也可能会发生非向后兼容的变化。具体如下：</p><p></p><p>代码包 golang.org/x/exp/constraints：其中包含了对泛型编程非常有用的一些类型约束，如 constraints.Ordered 接口等等。代码包 golang.org/x/exp/slices：其包含了不少对于切片操作非常有用的函数。而且，对于这些函数所操作的切片，其元素类型可以是任意的。比如，泛型函数 func BinarySearch(x []E, target E) (int, bool)、func CompactS ~[]E, E comparable S、func SortE constraints.Ordered 等等。从这些函数的签名上我们就可以看出，它们的通用性都得益于泛型。这样的通用性在 Go 语言支持泛型之前都是不可能存在的。代码包 golang.org/x/exp/maps：与 golang.org/x/exp/slices 包类似，其中包含了一些针对字典的非常通用的泛型函数，如：func ClearM ~map[K]V, K comparable, V any、func CloneM ~map[K]V, K comparable, V any M、func KeysM ~map[K]V, K comparable, V any []K 等。</p><p></p><p>真正了解 Go 语言的程序员们肯定都知道，Go 团队经常会向 golang.org/x/exp 包中放入一些实验性的代码。他们往往会通过这种方式来实现一些或新鲜或激进的想法。如果某些代码在这里通过了使用者们的检验，并被认为已经足够成熟，那么它们就有希望被添加到 Go 语言的标准库当中。Go 团队正是依靠这种渐进式升级的方式，在保证标准库稳定的同时，使其创新性得以延续。</p><p></p><p>再说回泛型。尽管 Go 语言团队为了泛型做了如此多的工作，但到目前为止，Go 语言的泛型实现仍然存在一些小限制（主要体现更加细致的编程语法、值成员访问等方面）。不过，这些小限制在大多数情况下并不会妨碍我们在应用程序中使用泛型。而且，Go 语言团队也已经预告将在未来的版本中对此进行改进。所以，作者就不在这里一一列举了。</p><p></p><p>到这里，相信大家已经有所体会，“支持泛型”可以说是 Go 语言正式发布以来最大、最复杂且最重要的一项变化了。很显然，Go 语言本身的泛型支持工作离彻底完成还有一小段距离。而对于 Go 语言的技术社区来讲，更加重要的是，这项变化将意味着 Go 语言生态系统的大规模翻新。</p><p></p><p>到目前为止，Go 语言的生态系统已经非常庞大。因此，Go 语言的这项变化将会给 Go 社区带来很可观的压力。那些 Go 程序员们常用的第三方开发框架和工具必然需要一定的时间才能够跟进这项变化，而完美契合这项变化也许还需要更多的时间。这其实也是 Go 团队当初在考虑“是否添加泛型支持”的时候，涉及到的一个很重要的负面因素。</p><p></p><p>但无论如何，Go 语言在这件事情上的第一步（也是非常重要的一步）已经迈出并平稳落地了。我们现在只希望，Go 语言以及 Go 语言技术社区能够在这个良好的基础之上继续稳步前行、平滑过渡。</p><p></p><h3>模糊测试</h3><p></p><p></p><p>我们都知道，Go 语言原生支持的测试已有三种，即：功能测试、基准测试（或称性能测试），以及示例测试。而从 1.18 版本开始，Go 语言本身支持的测试又多了一种，那就是模糊测试（fuzz test）。</p><p></p><p>所谓模糊测试是一种自动化测试技术，这种测试可以通过不断地调整应用程序的输入值来试图查找应用程序内部可能存在的错误，尤其是那些我们平常不太能注意到（或称边缘情况）的错误。正因为不太能注意到，所以在编写测试代码的时候，我们往往会有意或无意地忽视掉它们。这个时候，模糊测试就可以被用来查缺补漏了。而且，这种查缺补漏也是非常重要的，特别是在面向安全的测试当中。</p><p></p><p>这里所说的模糊，其含义是对应用程序的输入值（或者说参数值）的模糊。更确切地讲，模糊测试程序会对应用代码（如函数、结构体、接口方法等）进行若干次调用。而每一次调用都会在预先准备好的语料库（corpus，此为模糊测试的专用术语）当中随机地挑选出一个条目（corpus entry），并把该条目作为参数值输入给应用代码。</p><p></p><p>请注意，模糊测试的语料库与我们熟知的普通单元测试（如功能测试、基准测试等）的测试用例在生成方面有一个很大的不同。在普通的单元测试中，测试用例都是需要我们专门去准备的。这也算是普通单元测试的一种局限性。因为测试用例的规模与我们的测试工作量是成正比的，而且起码是线性的关系。我们越想全面地测试应用代码，我们的工作量就越大。由于我们的精力和时间是有限的，而且也不可能无限期地测试下去，因此普通的单元测试在测试覆盖度方面就会存在天然的限制，而且很难突破。</p><p></p><p>而在模糊测试中，语料库的生成是自动化完成的。模糊测试程序会自动生成一定规模的语料库。而我们只需事先向它提供一个规模非常小的种子语料库（seed corpus），甚至只包含一两个条目就可以。</p><p></p><p>这个种子语料库存在的目的，只是为了指导模糊测试引擎对语料库的自动生成，比如，单个语料库条目里需要包含几个输入值，以及每个输入值都是什么类型的，诸如此类。假设，作为测试目标的函数 A 只有一个参数，那么种子语料库中的每个条目只包含一个值即可。如果作为测试目标的函数 B 有两个参数，那么种子语料库里的单个条目就应该包含两个值。以此类推。</p><p></p><p>当然了，没有任何一个工具是完美的。虽然模糊测试可以大大地节省我们的测试工作量，但它也有一个小缺点，那就是：我们无法对语料库提供的参数值进行精细的控制。更确切地说，在模糊测试的过程中，我们不能确定应用代码每次被调用时接收到的输入值具体是什么。在某些情况下，这可能会妨碍我们对应用代码返回的输出值（或者说结果值）的正确性判断。倘若确实需要，我们可能就要额外添加一些测试代码来做专门的判断了。如果这样的情况很多，那么我们可能还需要重新权衡是否一定要使用模糊测试，而不是用普通的功能测试或基准测试。</p><p></p><p>好了，到了这里，想必大家已经大致了解模糊测试是什么，以及我们大概应该如何运用它。至于具体怎样给 Go 程序做模糊测试，其实还是很简单的。它与之前已经存在的功能测试和基准测试的编写方式大同小异，我们稍微迁移一下以前的测试经验就基本上可以搞定。因此，作者在这里就不再赘述了。如果你想对此做深入了解，那么可以去访问 fuzzing landing page 以及 the fuzzing proposal。</p><p></p><h3>工作区模式</h3><p></p><p></p><p>Go 语言的工作区模式（go workspace）是建立在 Go 模块模式（go module）之上的一种项目管理模式，主要体现在 go 标准命令之中。</p><p></p><p>Go 模块模式在 2021 年发布的 Go 1.17 中已经完全稳定下来了。我们可以通过 go mod 命令来创建和管理我们的 Go 模块。如果我们开发的 Go 项目已经达到了一定的规模，那么往往就需要把它拆分成多个模块，以便让它继续保持高内聚、低耦合的状态。这对于代码和项目的维护都是相当有利的。</p><p></p><p>比如，我们有一个名叫 MyProject 的 Go 项目（同时也是一个 Go 模块）。它的存放路径是 /path/go /haolin/Demo/MyProject。现在，我们想把其中的一些基础代码分离出来，以便进行独立的开发和维护。我们仔细地抽出那些基础代码，并它们放入到了一个名叫 MyLib 的模块中，并同样存放在 /path/go/haolin/Demo 目录之下。</p><p></p><p>这两个模块分别有自己的 go.mod 文件。MyProject 模块在它的 go.mod 文件中的名称为 github.com/hyper0x/MyProject，而 MyLib 模块在它的 go.mod 文件中的名称为 github.com/hyper0x/MyLib。不过请注意，这两个模块并不实际存在于网址 <a href=\"https://github.com/hyper0x\">https://github.com/hyper0x</a>\" 之下。这里只是作为示意而已。</p><p></p><p>在这之后，我们在 MyProject 模块里导入并使用 MyLib 中的代码包。但当我们想编译 MyProject 模块的时候却发现，go 命令无法正确编译 MyProject，提示找不到 MyLib 里的那个代码包。碰到这种情况，我们需要在 MyProject 所在的路径下运行：</p><p></p><p><code lang=\"go\">$ go mod edit -replace github.com/hyper0x/MyLib=../MyLib\n</code></p><p></p><p>这条命令的主要功能是，在 MyProject 模块的 go.mod 文件中加入如下内容：</p><p></p><p><code lang=\"go\">replace github.com/hyper0x/MyLib =&gt; ../MyLib\n</code></p><p></p><p>其含义是，将本模块中的源码文件里的 github.com/hyper0x/MyLib 定位到本地的路径（即 /path/go/haolin/Demo/MyLib）之上。</p><p></p><p>做好以上准备工作后，我们再在同样的路径下运行：</p><p></p><p><code lang=\"go\">$ go get github.com/hyper0x/MyLib\n</code></p><p></p><p>其功能是，在对应的 go.mod 文件中添加相应的依赖包信息。</p><p></p><p>好了，现在我们再次编译 MyProject 模块就不会有问题了。因为我们已经把本地的 MyLib 模块正确地设置为了 MyProject 模块的依赖包。</p><p></p><p>不过，这里有一个问题，上述的 replace 指令中存在一个本地的路径。如果开发这两个模块的人不止我一个，也就是说需要通过多人协作来开发项目，那么，我这里的本地路径在别人那里就是不正确的了。因为不同的开发者几乎不可能确保把同一个项目存放在自己的计算机中的相同路径之下。我们常常称这类问题为“本地路径问题”。</p><p></p><p>这个时候，Go 语言的 workspace 模式（也就是工作区模式）就派上用场了。具体的做法是，我们在 /path/go/haolin/Demo 这个路径（也就是 MyProject 模块和 MyLib 模块的上一级目录的路径）之下运行：</p><p></p><p><code lang=\"go\">$ go work init\n$ go work use ./MyLib\n</code></p><p></p><p>这里的第一条命令的功能是，把路径 /path/go/haolin/Demo 所代表的目录设置为 Go 工作区。它会在这个路径下添加一个名为 go.work 的文件。第二条命令的功能是，让子目录./MyLib 所代表的模块成为该工作区的一个共用模块。如此一来，该工作区中的其他 Go 模块就可以直接导入并使用 MyLib 模块中的代码包了。</p><p></p><p>此外，我们还需要在 MyProject 模块所在的路径下运行命令：</p><p></p><p><code lang=\"go\">$ go mod edit -dropreplace=github.com/hyper0x/MyLib\n</code></p><p></p><p>并以此删除掉对应的 go.mod 文件中包含的那个带有本地路径的 replace 指令。由于我们前面针对（/path/go/haolin/Demo 路径所代表的）相应 Go 工作区的设置，这里的这个 replace 指令的消失并不会造成任何问题。MyProject 模块依然可以通过编译。</p><p></p><p>至此我们可以看到，由于 Go 工作区模式的出现，我们的 Go 项目无论包含有多少个模块，也无论需要多少人进行怎样的协作调试和开发，都不用担心出现“本地路径问题”。这给团队级别的项目开发，尤其是大规模的协作开发，带来了非常大的便利。我们终于不用再为此频繁地修改 go.mod 文件了。这个 Go 项目管理上的痛点终于被消除了！</p><p></p><h3>内存模型更新</h3><p></p><p></p><p>在 1.19 版本中，Go 语言的内存模型已经过了修改（详见 the Go memory model）。这使得它与其他编程语言如 C、C++、Java、JavaScript、Rust 和 Swift 使用的内存模型保持了一致。</p><p></p><p>Go 语言只提供可以保证访问顺序一致性的原子操作，而不是像其他编程语言那样使用更加宽松的形式。更确切地说，在 Go 语言中，除非直接或间接地使用了相应的原子操作，否则并发地读写共享的数据必会引发数据竞争（data race）。顺便说一句，从根本上讲，Go 语言标准库中提供的其他同步或异步的数据访问工具基于的其实都是原子操作。</p><p></p><p>随着内存模型的更新，Go 1.19 在 sync/atomic 包中加入了一些新的类型，如 atomic.Bool、atomic.Int32、atomic.Int64、atomic.Uint32、atomic.Uint64，以及 atomic.Uintptr 和 atomic.Pointer[T]。很显然，与 sync/atomic 包中原有的诸如 AddXXX、CompareAndSwapXXX、LoadXXX 之类的原子函数相比，新的原子类型可以帮助我们更加方便和彻底地运用原子操作，同时也可以避免很多容易发生的编程失误。不得不说，我们已经等待这些原子类型很久了。</p><p></p><p>到这里，作者已经对 Go 语言在 2022 年的重大更新进行了相应的说明。这其中的重中之重肯定是泛型，所以作者对此的着墨也明显更多。至于那些在作者看来不那么重要或相对较小的更新，大家可以去浏览 Go 语言官方出具的版本说明（Go 1.18 Release Notes 和 Go 1.19 Release Notes），这里就不一一列出了。</p><p></p><h2>未来展望</h2><p></p><p></p><p>实际上，与 Go 1.18 相比，Go 1.19 算是一个更新量很小的版本迭代。这主要是因为，在影响巨大的特性加入之后，Go 语言及其团队和社区确实需要一段时间去消化它。这里其实有很多的工作要做，比如：进一步评估和验证、功能调整和修补、社区推广和反馈收集、代码优化和改进、文档补全和细化，等等。</p><p></p><p>不过，在明年即将发布的 Go 1.20 当中，随着上述工作的稳步推进和趋于完善，还是有一些值得关注的新东西的。下面只列举作者认为最喜闻乐见且可能最常用的几个更新：</p><p></p><p>支持同时囊括多个其他错误值的单个错误值：届时 errors 包中会提供一个新的函数 Join，用来把多个错误值包装成一个单一的错误值。另外 fmt.Errorf 函数也将允许在其模版字符串（即第一个参数值）中出现多个（用于包装错误值的占位动词）%w。函数 errors.Unwrap 到时候也会以 []error（即 error 的切片）作为结果值的类型，而不是之前的 error，以便一次性地返回所有被包装的错误值。这无疑大大增加了错误包装代码的灵活性，并间接地加强了错误判断代码的功能。sync.Map 的增强：sync.Map 类型里将会出现几个新方法，如 Swap、CompareAndSwap、CompareAndDelete 等。这些方法将如 sync/atomic 包里的相应函数那样，可以让单一的原子操作中包含多个动作。在 sync.Map 的场景下，这将支持针对键值对的更加复杂的原子操作，如上述方法所对应的比较并更新、比较并删除等。使用过 sync.Map 的程序员们应该都知道，对于这种操作，我们在之前不得不使用额外的同步工具来保证其并发的安全性。支持从切片到数组的转换：我们都知道，把数组转换成切片很容易，只要在一个数组上执行切片操作就可以得到一个指向那个数组的切片。这样的切片就相当于一个架设在数组之上的窗口。然而，现在的 Go 语言却不支持对应的反向操作。虽然我们通过少许的魔法代码就可以实现这样的操作，但是它肯定没有“array2 := [5]int(slice1)”这样的代码方便。后者正是将会在 Go 1.20 中合法化的代码，只一行就能完成从切片到数组的转换。不过要注意，上面这小段代码只会返回 slice1 的底层数组的副本，而不是这个底层数组本身。所以，我们之后对 slice1 中元素的修改将不会影响到 array2（但肯定会继续影响到 slice1 的底层数组）。</p><p></p><p>顺便提一下。已经在 Go 社区中引发热议的代码包 arena 及其配套代码可能会在 1.20 版本中以实验特性的方式出现。作者很看好 arena，因为它可以在某些情况下大大地减少内存分配和释放的次数，从而显著减轻 GC 的压力。</p><p></p><p>在作者看来，arena 包的功能类似于 Zig 编程语言中的内存分配器（allocator）。不过相比之下，Go 语言的实现肯定是大大简化的，因为它在 Go 语言中只需起到一定的辅助作用即可。整体来看，其做法是，在需要使用大块内存时先通过 arena 包中的 API 进行显式的内存空间申请，然后再根据实时的需要对其中的子空间进行取用，最后当无需再使用这块内存的时候再利用 arana 中的 API 进行整体释放。简单来说，这属于一种“整体化分配、碎片化使用、整体化释放”的内存空间使用范式。关于它更详细的说明可参看 Proposal: arena: new package providing memory arenas。</p><p></p><p>除了上述这些，Go 1.20 还会对编译器、标准工具、标准库等方面进行诸多的改进，详情可查看 Go 1.20 Release Notes(DRAFT)。如果在你阅读这篇文章的时候，Go 1.20 已经正式发布了，那么就可以直接去看 Go 1.20 Release Notes。</p><p></p><h2>总结</h2><p></p><p></p><p>好了，我们现在来快速地总结一下。</p><p></p><p>Go 语言在 2022 年的最大更新莫过于对自定义泛型类型和泛型函数的支持。新增的模糊测试 API 和工具将显著减少程序员们的测试工作量。工作区模式让我们在同时开发多个 Go 模块，尤其是多人协作开发的时候方便了许多（解决了一个很明显的痛点）。而在内存模型方面的修改则进一步增强了 Go 语言在数据访问方面的一致性保证。</p><p></p><p>在 2023 年，Go 语言将继续全方位地优化和改进其在各个方面的功能和性能。我们在前面已经列举了 Go 官方团队在错误处理、并发编程、便捷语法、内存管理方面的计划。作者相信，这些计划将会有条不紊地进行，并在将来让 Go 语言成为更加优秀、更加流行的编程语言。</p><p></p><p>希望大家继续关注 Go 语言和 Go 技术社区，尤其是国内的 Go 技术社区。同时，作者也希望能有更多的小伙伴参与到 Go 社区的建设甚至 Go 语言本身的改进当中去。如果正在阅读本文的你还没有尝试过 Go 语言，那么别再犹豫了，赶快到这里下载 Go 语言，并开始尝试编写 Go 程序吧！</p><p></p><p>1. Go 1.18 Release Notes: <a href=\"https://go.dev/doc/go1.18\">https://go.dev/doc/go1.18</a>\"</p><p>2. Go 1.19 Release Notes: <a href=\"https://go.dev/doc/go1.19\">https://go.dev/doc/go1.19</a>\"</p><p>3. Go 1.20 Release Notes(DRAFT): <a href=\"https://tip.golang.org/doc/go1.20\">https://tip.golang.org/doc/go1.20</a>\"</p><p>4. 其他相关的 Go 语言官方文档</p><p>5. Go 语言源码及其修改记录</p><p></p><p>往期盘点文章：</p><p>1. <a href=\"https://www.infoq.cn/article/2015-review-go/?accessToken\">解读 2015 之 Golang 篇：Golang 的全迸发时代</a>\"</p><p>2. <a href=\"https://www.infoq.cn/article/2016-review-go?accessToken\">解读 2016 之 Golang 篇：极速提升，逐步超越</a>\" </p><p>3.&nbsp;<a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651000049&amp;idx=1&amp;sn=7c95c644ec604f2f58fc33a284287c58&amp;chksm=bdbef4a28ac97db400ed198031492985b3c033bed8bbaa84bca689d2bb0f828209496b8464bf&amp;scene=21#wechat_redirect\">Go 语言的 2017 年终总结</a>\"</p><p>4. <a href=\"https://www.infoq.cn/article/4LsxhHGpAG1Gq-q4KVO4\">解读 2018 之 Go 语言篇（上）：为什么 Go 语言越来越热？</a>\"</p><p>5. <a href=\"https://www.infoq.cn/article/X-Qy0Mfprf6xObsZjlV\">解读 2018 之 Go 语言篇（下）：明年有哪些值得期待？</a>\"</p><p>6.&nbsp;<a href=\"https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&amp;mid=2247499528&amp;idx=1&amp;sn=40a26b336af4f4a9f3c06bc5d5eb17ca&amp;scene=21#wechat_redirect\">解读 Go 语言的 2019：如果惊喜不再 还有哪些值得关注？</a>\"</p><p>7.&nbsp;<a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651059903&amp;idx=2&amp;sn=95df331796d9347101a70cc21d100ecd&amp;scene=21#wechat_redirect\">解读 Go 语言的 2020：变革前夜</a>\"</p><p>8. <a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651103271&amp;idx=2&amp;sn=e24fc8fff0b050bf0d90024171d8ebac&amp;scene=21#wechat_redirect\">解读 Go 语言的 2021：稳定为王</a>\"</p><p></p><p>作者简介：</p><p>郝林，国内知名编程布道者、技术社群 GoHackers 的发起人和组织者，微信公众号“螺旋码”（视频号同名）主理人。发布过多个 Go 语言技术教程，包括开源的《Go 命令教程》、极客时间的付费专栏《Go 语言核心 36 讲》，以及图灵原创图书《Go 并发编程实战》，等等。其中专栏和图书拥有数万订阅者或购买者，开源教程 star 数也有数千。另外，他还在 2020 年出版了一本名为《Julia 编程基础》的技术图书。</p>",
    "publish_time": "2022-12-27 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "PHP 8：类和枚举",
    "url": "https://www.infoq.cn/article/XkIrT3XLmZFW9XdoJS1F",
    "summary": "<p></p><blockquote>本文属于专题文章<a href=\"https://www.infoq.cn/theme/php8-article-series\">《深入浅出 PHP 8》</a>\"。根据<a href=\"https://w3techs.com/technologies/details/pl-phptps://feed.infoq.com/php8-article-series/\">w3tech</a>\"的数据，PHP仍是互联网上使用最为广泛的脚本语言之一，77.3%的网站在服务器端均使用该编程语言。PHP 8为我们带来了许多新功能与优化，具体将在本系列文章中分析。</blockquote><p></p><p></p><p>我们将在本文中总结PHP 8中类相关的新特性，包括：</p><p>枚举，在类之上的一层，用于指定一个类型可能值的枚举列表。类属性新增只读修饰符，使属性在初始化后无法被修改。构造函数参数优化，可将构造函数参数值自动分配给一个对象属性。</p><p></p><h2>只读类属性</h2><p></p><p>在诸如数值对象的情况中，开发者们常常费尽脑汁让类的属性不可变。一般来说，在构造函数中初始化属性后，该属性理论上来说不能再被修改。另一种可行手段是将属性变为私有，且只声明一个公共getter方法。这种方法虽然减少了修改的空间，但仍不能排除变更的可能性。为使类属性不变，PHP 8.1新增了对有类型的属性的只读支持，类型化的属性均可通过新的readonly关键词声明为只读。下面这段代码声明了int类型$a的只读属性，属性值仅在构造函数中设置一次。运行时脚本输出为1。</p><p></p><p><code lang=\"php\"><!--?php\nclass A {\n   public readonly int $a;\n   public function __construct(int $a) {     \n       $this--->a = $a;\n   }\n}\n$a = new A(1);\necho $a-&gt;a;\n</code></p><p></p><p>可通过以下这段赋值语句将属性修改为只读：$a-&gt;a = 2;</p><p></p><p>该语句会导致如下报错：Fatal error: Uncaught Error: Cannot modify readonly property A::$a </p><p></p><p>只读readonly属性必须有类型，尝试用这段脚本将未类型化的属性变为只读：</p><p></p><p><code lang=\"php\"><!--?php\nclass A {\n   public readonly  $a;\n   public function __construct(int $a) {        \n       $this--->a = $a;\n   }\n}\n$a = new A(1);\n</code></p><p></p><p>脚本报错信息如下：Fatal error: Readonly property A::$a must have type。</p><p></p><p>如果你想不指定只读属性的类型，可以将其声明为混合型，如：public readonly mixed $a;。</p><p></p><p>除类型限制外，readonly属性还有其他限制：只读的属性不能被声明为static，可参见下面这段脚本的演示：</p><p></p><p><code lang=\"php\"><!--?php\nclass A {\n   public static readonly int $a;\n   public function __construct(int $a) {        \n       $this--->a = $a;\n   }\n}\n$a = new A(1);\n</code></p><p></p><p>脚本报错信息如下：Fatal error: Static property A::$a cannot be readonly。</p><p></p><p>只读的属性只能在其被声明的作用域内被初始化。下面这段脚本在属性声明的作用域之外初始化了只读属性：</p><p></p><p><code lang=\"php\"><!--?php\nclass A {\n   public  readonly int $a;\n}\n$a = new A();\n$a--->a=1; \n</code></p><p></p><p>运行时脚本报错信息如下：Fatal error: Uncaught Error: Cannot initialize readonly property A::$a from global scope。</p><p></p><p>虽然也可以在初始化时为只读属性分配默认值，但这么做用处不大，因为类常量也能做到。因此，为只读属性设置一个默认值不被允许。下面这段脚本试图为一个只读属性声明默认值：</p><p></p><p><code lang=\"php\"><!--?php\nclass A {\n   public  readonly int $a=1;\n   public function __construct(int $a) {        \n       $this--->a = $a;\n   }\n}\n</code></p><p></p><p>运行时脚本报错信息如下：Fatal error: Readonly property A::$a cannot have default value。</p><p></p><p>只读属性这一功能的目的，是使一个类属性不可变。因此，只读属性在初始化之后无法通过unset()重置。下面这段脚本尝试在初始化一个只读属性后对其调用unset()：。</p><p></p><p><code lang=\"php\"><!--?php\nclass A {\n   public  readonly int $a;   \n   public function __construct(int $a) {        \n       $this--->a = $a;\n       unset($this-&gt;a);\n   }\n}\n$a = new A(1);\n</code></p><p></p><p>运行时脚本报错信息如下：Fatal error: Uncaught Error: Cannot unset readonly property A::$a 。</p><p></p><p>但在初始化之前却可以对只读属性调用unset()，比如下面这段脚本：</p><p></p><p><code lang=\"php\"><!--?php\nclass A {\n   public  readonly int $a;\n     \n   public function __construct(int $a) {\n        unset($this--->a);\n       $this-&gt;a = $a;        \n   }\n} \n$a = new A(1);\necho $a-&gt;a;\n</code></p><p></p><p>脚本运行成功，输出值为1。</p><p></p><p>简单的重新赋值或其他运算符操作都无法修改readonly属性。下面这段脚本没有通过重新赋值语句修改只读属性，而是试图对其使用增量运算符：</p><p></p><p><code lang=\"php\"><!--?php\nclass A {\n   public  readonly int $a;     \n   public function __construct(int $a) {         \n       $this--->a = $a;       \n   }\n} \n$a = new A(1);\n$a-&gt;a++;\n</code></p><p></p><p>目的一样，因此错误信息也是一样的：Fatal error: Uncaught Error: Cannot modify readonly property A::$a。</p><p></p><p>实际上，不变的仅仅是readonly的属性，不影响其中存储的对象或资源。我们可以修改任何存储在readonly属性中对象及非只读属性。这段脚本试图通过一个类型为object的只读属性$obj，设置类属性$a的数值。</p><p></p><p><code lang=\"php\"><!--?php\nclass A {\n   public int $a;\n    public function __construct(public readonly object $obj) {}\n}\n$a = new A(new stdClass); \n$a--->obj-&gt;a=1; \necho $a-&gt;obj-&gt;a;\n</code></p><p></p><p>脚本运行成功，输出为1。</p><p></p><p>PHP 8.2中将新增的只读类作为对先前只读类属性功能的扩展。如果一个类使用readonly修饰符声明，那么其中所有的类属性均默认为只读。只读类的类属性必须有类型且非静态，以下面这段脚本为例：</p><p></p><p><code lang=\"php\">readonly class A\n{\n    public int $a;\n    public string $b;\n    public array $c;\n    \n    public function __construct() {\n        $this-&gt;a = 1;\n        $this-&gt;b = \"hello\";\n        $this-&gt;c = [\n                    \"1\" =&gt; \"one\",\n                    \"2\" =&gt; \"two\",\n                   ];\n    }\n}\n</code></p><p></p><p>只读类的确有一些限制；它不能定义动态属性，只有只读类才能扩展另一个只读类。</p><p></p><h2>构造函数属性提升</h2><p></p><p>PHP 8.0中新引入的构造函数属性提升功能取代了类属性声明和初始化。具体请见下面这段脚本，类属性$pt1、$pt2、$pt3及$pt4均在Rectangle类中声明，并在类的构造函数中初始化。</p><p></p><p><code lang=\"php\"><!--?php\n\nclass Point {\n    public function __construct(\n        public float $pt = 0.0,\n    ) {}\n}\n\nclass Rectangle {\n\n  public Point $pt1;\n  public Point $pt2;\n  public Point $pt3; \n  public Point $pt4;\n\n  public function __construct(\n        Point $pt1,\n        Point $pt2,\n        Point $pt3,\n        Point $pt4,\n    ) {\n        $this--->pt1 = $pt1;\n        $this-&gt;pt2 = $pt2;\n        $this-&gt;pt3 = $pt3;\n        $this-&gt;pt4 = $pt4;\n        \n  }\n}\n</code></p><p></p><p>新增构造函数属性提升后，脚本会缩减到以下内容：</p><p></p><p><code lang=\"php\"><!--?php\n \nclass Point {\n    public function __construct(\n        public float $pt = 0.0,\n    ) {}\n}\n\nclass Rectangle {\n \n  public function __construct(\n       public Point $pt1,\n       public Point $pt2,\n       public Point $pt3,\n       public Point $pt4,\n    ) {\n         \n  }\n}\n</code--></code></p><p></p><p><code lang=\"php\">构造函数本身可以为空，在其中的语句会在构造函数入参提升至对应类属性后运行。构造函数提升至类属性所要满足的唯一条件是包含有一个可见性修改器。构造函数的参数值会自动赋给同名的类属性。</code></p><p></p><p><code lang=\"php\">下面这段使用Rectangle类的类构造函数调用的脚本示例，展示了如何自动提升并初始化公共构造函数参数至类属性：</code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><!--?php\n …\n …\n $pt1=new Point();\n $pt2=new Point();\n $pt3=new Point();\n $pt4=new Point();\n\n $a = new Rectangle($pt1,$pt2,$pt3,$pt4);\n\n// 类属性值输出为：\nvar_dump($a--->pt1);\nvar_dump($a-&gt;pt2);\nvar_dump($a-&gt;pt3);\nvar_dump($a-&gt;pt4);\n</code></code></p><p></p><p><code lang=\"php\">可以看出，脚本的确添加了类属性且被隐式初始化，其输出如下：</code></p><p></p><p><code lang=\"php\"><code lang=\"php\">object(Point)#1 (1) { [\"pt\"]=&gt; float(0) } \nobject(Point)#2 (1) { [\"pt\"]=&gt; float(0) } \nobject(Point)#3 (1) { [\"pt\"]=&gt; float(0) } \nobject(Point)#4 (1) { [\"pt\"]=&gt; float(0) }\n</code></code></p><p></p><p><code lang=\"php\">如果构造函数参数不包含可见性修改器，则不会被正确提升至对应类属性。但并不是所有构造函数参数都需要被提升。以下这段脚本中参数$pt4没有声明可见性修饰符，因此也没有构造器参数提升。</code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><!--?php\n \nclass Point {\n    public function __construct(\n        public float $pt = 0.0,\n    ) {}\n}\n\nclass Rectangle {\n \n  public function __construct(\n       public Point $pt1,\n       public Point $pt2,\n       public Point $pt3,\n       Point $pt4,\n    ) {\n       \n  }\n}\n</code--></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">同理，调用Rectangle类构造器并输出类属性值。但这个例子中因为$pt4没有可见性修饰器，没有被提升至对应类属性，所以结果不尽相同。我们会得到一个警告信息：Warning: Undefined property: Rectangle::$pt4</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">需要像下面这段脚本中一样，明确声明并初始化$pt4类属性：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php \nclass Point {\n    public function __construct(\n        public float $pt = 0.0,\n    ) {}\n}\n\nclass Rectangle {\n \n  public Point $pt4;\n\n  public function __construct(\n       public Point $pt1,\n       public Point $pt2,\n       public Point $pt3,\n       Point $pt4,\n    ) {\n       $this--->pt4=$pt4;\n  }\n}\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">这样，我们就可以和之前一样调用构造函数，并得到一样的类属性输出结果。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">类构造函数参数被提升至对应类属性还需要满足的另一个条件是，构造函数不能是可调用类型。下面这段脚本声明了一个可调用类型的构造函数参数：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass Rectangle { \n  \n  public function __construct(\n       public callable $pt1,\n       public callable $pt2,\n       public callable $pt3,\n       public callable $pt4,\n    ) {\n        \n  }\n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">脚本运行时会生成一条错误信息：Fatal error: Property Rectangle::$pt1 cannot have type callable。</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">在PHP 8系列的首篇文章中，我们分析了如何在初始化器中使用new的操作符，以及如何为函数参数初始化默认值。new操作符同样可被用于设置构造器参数的默认值以及构造器属性提升，如下面这段脚本所示：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass Point {\n    public function __construct(\n        public float $pt = 0.0,\n    ) {}\n}\n\nclass Rectangle {\n  public function __construct(\n       public Point $pt1=new Point(),\n       public Point $pt2=new Point(),\n       public Point $pt3=new Point(),\n       public Point $pt4=new Point(),\n    ) {\n         \n  }\n}\n</code--></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">这个Rectangle类的构造函数可以在没有任何构造函数入参的情况下被调用，并输出提升后的类属性值：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">$a = new Rectangle();\nvar_dump($a-&gt;pt1);\nvar_dump($a-&gt;pt2);\nvar_dump($a-&gt;pt3);\nvar_dump($a-&gt;pt4);\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">object(Point)#2 (1) { [\"pt\"]=&gt; float(0) } \nobject(Point)#3 (1) { [\"pt\"]=&gt; float(0) } \nobject(Point)#4 (1) { [\"pt\"]=&gt; float(0) } \nobject(Point)#5 (1) { [\"pt\"]=&gt; float(0) }\n</code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\">在define()中使用对象</code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\">内置define()函数可用于定义命名常量。随着PHP 8.1的出现，对象也可以传入define()，如下面这段脚本所示：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass Point {\n    public function __construct(\n        public float $pt = 0.0,\n    ) {}\n} \n\ndefine(\"PT1\", new Point(1.0));\nvar_dump(PT1); \n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">脚本输出为：object(Point)#1 (1) { [\"pt\"]=&gt; float(1) }。</code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">类常量可被声明为final</code></code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">PHP 8.1中，允许使用final关键字声明类常量。除此之外，如果一个类常量在类中被声明为final，那么任何其的扩展类都不能覆盖或重新定义该常量的数值。在下面这段脚本中，类常量c在类A中被声明为final，但又在扩展类A的类B中被重新定义：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\nclass A\n{\n    final public const c = 1;\n}\nclass B extends A\n{\n    public const c = 2;\n}\n</code--></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">脚本运行后会出现以下报错信息：Fatal error: B::c cannot override final constant A::c。</code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">特殊的::class常量可用于对象</code></code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">从PHP 8.0开始，特殊的::class常量不仅允许在编译时进行绝对类名的解析，也可用于类对象。区别在于类名解析出现在运行时的对象中，而类则用于编译时解析。将::class用于对象等同于对对象调用get_class()。下面这段脚本对类A中的一个对象使用了::class，输出为“A”：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php \nclass A {\n} \n$a = new A();\nprint $a::class;\n?-->\n</code></code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\">接口常量可被覆盖</code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\">从PHP 8.1开始，接口常量可以被继承的类或接口覆盖。在下面这段脚本中，接口常量c被同名的类常量覆盖，用于覆盖的常量值可以相同也可以不同。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\ninterface A\n{\n    public const c = 1;\n}\n\nclass B implements A\n{\n    public const c = 2;\n\n   public function __construct() { \n        \n   }\n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">两个常量值均可被输出：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">echo A::c;\necho B::c;\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">1\n2\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">但如果接口常量被声明为final则不能被覆盖，这一点与被声明为final的类常量同理。下面这段脚本试图覆盖一个被声明为final的接口常量：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\ninterface A\n{\n    final public const c = 1;\n}\n\nclass B implements A\n{\n    public const c = 2;\n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">脚本运行会输出下面这段错误信息：Fatal error: B::c cannot override final constant A::c。</code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">自动加载函数__autoload()被移除</code></code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">在PHP 7.2.0中被废弃的__autoload()函数在PHP 8.0中被移除。如果调用__autoload()则会输出下面这段错误信息：Fatal error: Uncaught Error: Call to undefined function __autoload()。</code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">枚举</code></code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">缩写为enum的枚举，是用于声明一个具有明确可能值的一个新增自定义类型功能。语言结构enum可用于声明一个枚举，最简单的枚举可以为空：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">enum FirstEnum {\n}\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">一个enum可以通过case关键字声明可能值，比如：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">enum SortType {\n  case Asc;\n  case Desc;\n  case Shuffle;\n}\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">因为枚举与类这二者的相似性，相关讲解会一同进行。</code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\">为什么说枚举与类相似</code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\">枚举即为类。示例中的枚举SortType是一个类，其中的可能值均为类的对象实例。枚举与类、接口、特征共用相同的命名空间。枚举与类均可自动加载。每个枚举值，如SortType枚举中的Asc、Desc及Shuffle均为对象实例。枚举值的实例可以通过object的类型检查。枚举值或case名称在内部表示为类常量，因此区分大小写。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">枚举在诸如以下几类的场景中非常有用：</code></code></p><p><code lang=\"php\"><code lang=\"php\">对系列常量的结构化替代；数据建模；单体式编程；定义领域模型；不支持的数值无法显示，可减少代码测试的验证工作。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">下面我们会配合示例对枚举进行探讨。枚举值本身是对象，因此对象能用的地方枚举值也能用，其中就包括函数的参数类型和返回类型。在下面这段脚本中，函数的参数类型和返回类型均为枚举SortType。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nenum SortType  \n{\n \n  case Asc;\n  case Desc;\n  case Shuffle;\n \n}\nclass A {\n\n  public function sortType():SortType{\n    return SortType::Asc;\n  }\n \n}\n$a=new A();\nvar_dump($a--->sortType());\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">脚本的输出为：enum(SortType::Asc)。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">和系列中的首篇文章一样，我们还是使用数组排序的例子。sortArray函数的类型是SortType枚举类型。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">function sortArray(SortType $sortType) { \n\n  $arrayToSort=array(\"B\", \"A\", \"f\", \"C\");\n  …\n  …\n}\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">枚举对象的数值可用==操作符比对：if ($sortType == SortType::Asc){...}。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">同样的例子但使用枚举，效果如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\nenum SortType {\n  case Asc;\n  case Desc;\n  case Shuffle;\n   \n}\n \nfunction sortArray(SortType $sortType) { \n\n$arrayToSort=array(\"B\", \"A\", \"f\", \"C\");\n\n    if ($sortType == SortType::Asc) {\n             sort($arrayToSort);\n             foreach ($arrayToSort as $key =--> $val) {\n                echo \"$key = $val \";\n             }  \n        } elseif ($sortType == SortType::Desc) {\n             rsort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  \n        } elseif ($sortType == SortType::Shuffle){\n              \n             shuffle($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  \n     }\n}\n$val = SortType::Asc;\nsortArray($val);\nsortArray(SortType::Desc);\nsortArray(SortType::Shuffle); \n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">我们的数组排序示例脚本的输出如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">0 = A 1 = B 2 = C 3 = f \n0 = f 1 = C 2 = B 3 = A \n0 = f 1 = A 2 = B 3 = C\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">因为枚举例或者说可能值是一个对象实例，因此需要配合instanceof操作符与枚举值一起使用，如：if ($sortType instanceof SortType) {...}。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">枚举值不会被转换为字符串，因此不能当作字符串使用。也就是说，如果直接用字符串入参调用sortArray()函数：sortArray('Shuffle');。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">就会导致报错：Fatal error: Uncaught TypeError: sortArray(): Argument #1 ($sortType) must be of type SortType, string given。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">所有枚举值或例均有一个name只读属性，该属性值为枚举例的名称，区分大小写。name属性可用于调试，如用这段打印语句输出“Asc”：print SortType::Asc-&gt;name; 。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">枚举值不可重复，且区分大小写。下面这段脚本中的枚举值满足这一要求：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nenum SortType  \n{\n \n  case Asc;\n  case Desc;\n  case ASC;\n \n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">但这段脚本中的枚举值有重复：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nenum SortType  \n{\n  case Asc;\n  case Desc;\n  case Asc;\n}\n</code--></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">脚本会输出以下错误信息：Fatal error: Cannot redefine class constant SortType::Asc我们在此讨论的均为基本枚举或者说纯粹枚举，纯粹枚举只会定义没有关联数据的纯粹枚举值。下面我们要讨论的另一种枚举类型被称作是回退枚举。</code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">回退枚举</code></code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">回退枚举的枚举值定义了字符串类型或int类型的标量替代，如：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">enum SortType:int {\n  case Asc=1;\n  case Desc=2;\n  case Shuffle=3;\n}\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">标量替代可以是int类型或字符串类型，但不能是二者联合的int|string，所有回退枚举值必须声明一个标量值，以这段回退枚举脚本为例：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\nenum SortType:int {\n  case Asc=1;\n  case Desc=2;\n  case Shuffle;\n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">会生成以下错误信息：Fatal error: Case Shuffle of backed enum SortType must have a value。</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">回退枚举的标量替代不能重复。下面这段脚本试图为两个枚举值声明同样的标量替代：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\nenum SortType:int {\n  case Asc=1;\n  case Desc=2;\n  case Shuffle=2;\n}\n</code--></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">脚本输出的错误信息如下：Fatal error: Duplicate value in enum SortType for cases Desc and Shuffle。</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">标量替代可以为字面值，也可以为字面表达式，如：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nenum SortType:int {\n  case Asc=1;\n  case Desc=2+1;\n  case Shuffle=3-3;\n}\n</code--></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">所有回退枚举值或回退枚举用例都有一个只读属性value，其属性值为回退枚举值的标量值。以下面这段脚本为例，打印语句会输出Desc枚举值的标量替代值：print SortType::Desc-&gt;value;。</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">这里的value是只读属性且不可修改。下面这段脚本试图给回退枚举值的value属性赋值为一个变量的引用：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">$sortType = SortType::Desc;\n$ref = &amp;$sortType-&gt;value;\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">这段赋值语句会输出以下错误信息：Fatal error: Uncaught Error: Cannot modify readonly property SortType::$value 。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">回退枚举实现了一个内部接口BackedEnum，其中包含两个方法：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">from(int|string): self：以一个回退枚举用例的标量枚举值为入参，返回对应的枚举用例。如果标量值没有对应用例则返回ValueError。tryFrom(int|string): ?self：以回退枚举用例的标量枚举值为入参，输出对应枚举用例。如果标量值没有对应用例则返回空。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">下面这段脚本展示了这两种方法的使用场景：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\n enum SortType:int {\n  case Asc=1;\n  case Desc=2;\n  case Shuffle=3;\n}\n\n$sortType =  SortType::from(1);\n \nprint $sortType--->value; \necho “<br />”;\n$sortType = SortType::tryFrom(4) ?? SortType::Desc;\nprint $sortType-&gt;value;  \necho “<br />”;\n\n$sortType =  SortType::from(\"4\");\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">1\n2\nFatal error: Uncaught ValueError: 4 is not a valid backing value for enum \"SortType\"\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">方法from()和tryFrom()使用严格和弱类型模式，默认为弱类型模式，也就意味着隐式转换。如下面这段脚本所示，用于integer的浮点和字符串值均会被转换为整数值：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nenum SortType:int {\n  case Asc=1;\n  case Desc=2;\n  case Shuffle=3;\n}\n\n$sortType =  SortType::from(1.0);\n \nprint $sortType--->value; \necho \"<br />\";\n$sortType = SortType::tryFrom(\"4\") ?? SortType::Desc;\nprint $sortType-&gt;value;  \necho \"<br />\";\n$sortType =  SortType::from(\"2.0\");\nprint $sortType-&gt;value; \n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">1\n2\n2\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">如果期望类型为int，那么传入的字符串必须要能够转换为integer，否则：$sortType = SortType::from(\"A\");这段脚本会生成下面这条错误信息：Fatal error: Uncaught TypeError: SortType::from(): Argument #1 ($value) must be of type int, string given在严格类型模式中，无法使用这种类型转换，否则会输出以下错误信息：Fatal error: Uncaught TypeError: SortType::from(): Argument #1 ($value) must be of type int, float given。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">纯粹枚举和回退枚举均有一个内部接口的UniEnum实现，提供静态方法cases()，可输出枚举的可能值或枚举情况。下面这段脚本演示了cases()的使用方法：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php  \n enum SortType  {\n  case Asc;\n  case Desc;\n  case Shuffle;\n   \n}\n \nenum BackedSortType:int {\n  case Asc=1;\n  case Desc=2;\n  case Shuffle=3;\n}\n\nvar_dump(SortType::cases());\n\nvar_dump(BackedSortType::cases());\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">输出为：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"text\">array(3) { [0]=&gt; enum(SortType::Asc) [1]=&gt; enum(SortType::Desc) [2]=&gt; enum(SortType::Shuffle) } \n\narray(3) { [0]=&gt; enum(BackedSortType::Asc) [1]=&gt; enum(BackedSortType::Desc) [2]=&gt; enum(BackedSortType::Shuffle) }\n</code></code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">枚举可包含方法也可实现接口</code></code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">无论纯粹枚举还是回退枚举，均可声明方法，这点与类的方法实例类似。枚举同样也可以实现接口，但必须在函数之外的实现接口函数。下面这段脚本类似先前的数组排序例子，但包含一个实现了接口的枚举。该枚举除了实现接口函数外，还额外实现了一个不属于该接口的函数：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\ninterface SortType\n{\n    public function sortType(): string;\n}\n\nenum SortTypeEnum implements SortType   {\n  case Asc;\n  case Desc;\n  case Shuffle;\n  \n public function sortType(): string\n    {\n        return match($this) {\n            SortTypeEnum::Asc =--> 'Asc',\n            SortTypeEnum::Desc =&gt; 'Desc',\n            SortTypeEnum::Shuffle =&gt; 'Shuffle',\n        };\n    }\n\n   public function notFromInterface(): string\n    {\n        return \"Function Not From Interface\";\n    }\n}\n \nfunction sortArray(SortType $sortType) { \n\n$arrayToSort=array(\"B\", \"A\", \"f\", \"C\");\nif ($sortType-&gt;sortType() == \"Asc\") {\n             sort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n        } elseif ($sortType-&gt;sortType() == \"Desc\") {\n             rsort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n        } elseif ($sortType-&gt;sortType() == \"Shuffle\"){\n              \n             shuffle($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n          }\n         elseif  ($sortType instanceof SortType){\n              \n             sort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  \n }\n}\n$val = SortTypeEnum::Asc;\n \nsortArray(SortTypeEnum::Asc);\nsortArray(SortTypeEnum::Desc);\nsortArray(SortTypeEnum::Shuffle);\nprint SortTypeEnum::Asc-&gt;notFromInterface(); \n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">这段脚本的输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"text\">0 = A 1 = B 2 = C 3 = f\n0 = f 1 = C 2 = B 3 = A\n0 = C 1 = f 2 = B 3 = A\nFunction Not From Interface \n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">回退枚举同样也可以实现接口并提供额外的方法，如下面这段脚本所示：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\ninterface SortType\n{\n    public function sortType(): string;\n}\n\nenum SortTypeEnum: string implements SortType\n{\n  case Asc = 'A';\n  case Desc = 'D';\n  case Shuffle = 'S';\n   \n public function sortType(): string\n    {\n        return match($this--->value) {\n            'A' =&gt; 'Asc',\n            'D' =&gt; 'Desc',\n            'S' =&gt; 'Shuffle',\n        };\n    }\n\n   public function notFromInterface(): string\n    {\n        return \"Function Not From Interface\";\n    }\n}\n \nfunction sortArray(SortType $sortType) { \n\n$arrayToSort=array(\"B\", \"A\", \"f\", \"C\");\n    if ($sortType-&gt;sortType() == \"Asc\") {\n             sort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n        } elseif ($sortType-&gt;sortType() == \"Desc\") {\n             rsort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n        } elseif ($sortType-&gt;sortType() == \"Shuffle\"){\n              \n             shuffle($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n          }\n         elseif  ($sortType instanceof SortType){\n              \n             sort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  \n    }\n} \n \nsortArray(SortTypeEnum::Asc);\nsortArray(SortTypeEnum::Desc);\nsortArray(SortTypeEnum::Shuffle);\nprint SortTypeEnum::Asc-&gt;notFromInterface(); \n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">0 = A 1 = B 2 = C 3 = f\n0 = f 1 = C 2 = B 3 = A\n0 = C 1 = f 2 = B 3 = A\nFunction Not From Interface \n</code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\">枚举可声明静态方法</code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\">枚举也可以声明静态方法。继续使用上面的数组排序例子，我们在其中声明了一个静态方法chooseSortType()，该方法可依据要排序的数组长度选择排序类型：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\nenum SortType \n{\n \n  case Asc;\n  case Desc;\n  case Shuffle;\n\n   public static function chooseSortType(int $arraySize): static\n    {\n        return match(true) {\n            $arraySize < 10 =--> static::Asc,\n            $arraySize &lt; 20 =&gt; static::Desc,\n            default =&gt; static::Shuffle,\n        };\n    }\n}\n \nfunction sortArray(array $arrayToSort) { \n \n    if (SortType::chooseSortType(count($arrayToSort)) == SortType::Asc) {\n             sort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n        } elseif (SortType::chooseSortType(count($arrayToSort)) == SortType::Desc) {\n             rsort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n        } elseif (SortType::chooseSortType(count($arrayToSort)) == SortType::Shuffle){\n              \n             shuffle($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n        }\n          \n} \n \n\n$arrayToSort=array(\"B\", \"A\", \"f\", \"C\");\nsortArray($arrayToSort); \n\n$arrayToSort=array(\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\");\n\nsortArray($arrayToSort);\n\n$arrayToSort=array(\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\");\n\nsortArray($arrayToSort);\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"text\">0 = A 1 = B 2 = C 3 = f\n0 = f 1 = f 2 = f 3 = C 4 = C 5 = C 6 = B 7 = B 8 = B 9 = A 10 = A 11 = A\n0 = A 1 = B 2 = B 3 = C 4 = B 5 = C 6 = f 7 = A 8 = f 9 = C 10 = B 11 = f 12 = f 13 = A 14 = A 15 = B 16 = C 17 = f 18 = A 19 = B 20 = C 21 = f 22 = C 23 = A \n</code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\">枚举可声明常量</code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\">枚举同样可声明常量。下面这段脚本中声明了一个常量A：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nenum SortType  \n{\n \n  case Asc;\n  case Desc;\n  case Shuffle;\n  \n  public  const A = 1;\n \n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">声明的常量可以引用枚举本身的场景，这些场景也回会是常量。下面这段数组排序脚本中使用的是在枚举中声明的常量：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\nenum SortType \n{\n \n  case Asc;\n  case Desc;\n  case Shuffle;\n\n   public const ASCENDING = self::Asc;\n   public const DESCENDING = self::Desc;\n   public const SHUFFLE = self::Shuffle;\n}\n \nfunction sortArray(SortType $sortType) { \n    $arrayToSort=array(\"B\", \"A\", \"f\", \"C\");\n    if ($sortType == SortType::Asc) {\n             sort($arrayToSort);\n             foreach ($arrayToSort as $key =--> $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n        } elseif ($sortType == SortType::Desc) {\n             rsort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n        } elseif ($sortType == SortType::Shuffle){\n              \n             shuffle($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  \n    }\n}\n\nsortArray(SortType::ASCENDING); \nsortArray(SortType::DESCENDING); \nsortArray(SortType::SHUFFLE); \n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"text\">0 = A 1 = B 2 = C 3 = f\n0 = f 1 = C 2 = B 3 = A\n0 = C 1 = B 2 = f 3 = A\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">因为枚举值本身是常量，因此明确的常量不能重新定义一个枚举的值，比如下面这段脚本中所演示的：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nenum SortType:int {\n\n  public const Asc = \"Asc\";\n  case Asc=1+1;\n  case Desc=2;\n  case Shuffle=3; \n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">脚本会输出以下这段错误信息：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">Fatal error: Cannot redefine class constant SortType::Asc </code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">枚举值必须在编译时可评估，如下面这段脚本中的枚举常量所示：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \nenum SortType:int {\n\n  const CONSTANT=4;\n\n  case Asc=1;\n  case Desc=2;\n  case Shuffle=CONSTANT;\n}\n</code--></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">会输出以下错误信息：Fatal error: Enum case value must be compile-time evaluatable。</code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">使用特质的枚举</code></code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">枚举可以使用特质（trait）。下面这段数组排序脚本声明了一个ChooseSortType特质，并在枚举中使用了该特质：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\ntrait ChooseSortType {\n\n     public function chooseSortType(int $arraySize): SortType\n    {\n        return match(true) {\n            $arraySize < 10 =--> SortType::Asc,\n            $arraySize &lt; 20 =&gt; SortType::Desc,\n            default =&gt; SortType::Shuffle,\n        };\n    }\n\n}\n\nenum SortType {\n \n  use ChooseSortType;\n\n  case Asc;\n  case Desc;\n  case Shuffle;\n}\n \nfunction sortArray(SortType $sortType, array $arrayToSort) { \n \n    if ($sortType-&gt;chooseSortType(count($arrayToSort)) == SortType::Asc) {\n             sort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n        } elseif ($sortType-&gt;chooseSortType(count($arrayToSort)) == SortType::Desc) {\n             rsort($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n        } elseif ($sortType-&gt;chooseSortType(count($arrayToSort)) == SortType::Shuffle){\n              \n             shuffle($arrayToSort);\n             foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n             }  echo \"<br />\";\n        }\n          \n} \n \n\n$arrayToSort=array(\"B\", \"A\", \"f\", \"C\");\n\nsortArray(SortType::Desc,$arrayToSort); \n\n$arrayToSort=array(\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\");\n\nsortArray(SortType::Asc,$arrayToSort);\n\n$arrayToSort=array(\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\",\"B\", \"A\", \"f\", \"C\");\n\nsortArray(SortType::Desc,$arrayToSort);\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"text\">0 = A 1 = B 2 = C 3 = f\n0 = f 1 = f 2 = f 3 = C 4 = C 5 = C 6 = B 7 = B 8 = B 9 = A 10 = A 11 = A\n0 = B 1 = A 2 = C 3 = f 4 = B 5 = A 6 = B 7 = A 8 = B 9 = A 10 = f 11 = A 12 = C 13 = B 14 = f 15 = f 16 = C 17 = f 18 = C 19 = B 20 = C 21 = C 22 = A 23 = f \n</code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\">枚举与类有什么区别</code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\">虽然先前我们说枚举与类相似，但这二者也有很多不同之处：</code></code></p><p><code lang=\"php\"><code lang=\"php\">枚举的序列化方式与对象不同；枚举没有状态，而类的对象则有；枚举不声明构造函数，因为不需要初始化对象；枚举不能扩展其他枚举，也就意味着没有继承；不支持对象和静态属性；枚举不能用new操作符进行实例化；打印print_r语句的输出结果与类对象不同。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">下面这段脚本中更具体地展示了这二者的差异之一，枚举不能声明类属性：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nenum SortType  \n{\n  case Asc;\n  case Desc;\n  case Shuffle;\n  \n  public $var = 1;\n} \n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">脚本的报错信息为：Fatal error: Enums may not include properties。</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">另一个差异点可以在下面这段脚本中有所体现，枚举不能被实例化：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nenum SortType  \n{\n  case Asc;\n  case Desc;\n  case Shuffle;\n}\n\n$sortType=new SortType(); \n</code--></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">脚本的报错信息为：Fatal error: Uncaught Error: Cannot instantiate enum SortType。</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">可通过下面这段脚本的print_r中纯粹枚举与回退枚举进行更直观的对比：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php  \n enum SortType {\n  case Asc;\n  case Desc;\n  case Shuffle;\n}\nenum BackedSortType: int {\n  case Asc = 1;\n  case Desc = 2;\n  case Shuffle = 3;\n}\n\nprint_r(SortType::Asc);\nprint_r(BackedSortType::Desc);\n</code--></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">输出为：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"text\">SortType Enum ( [name] =&gt; Asc ) \nBackedSortType Enum:int ( [name] =&gt; Desc [value] =&gt; 2 )\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">枚举也可以声明一个__toString方法。下面这段脚本在Stringable接口中实现了枚举，并给出了__toString方法的实现。</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nenum SortType implements Stringable \n{\n  case Asc;\n  case Desc;\n  case Shuffle;\n   \n  const ASCENDING = SortType::Asc; \n     \n  public function __toString(): string {\n        return \"\";\n  }\n   \n}\n   \necho SortType::ASCENDING;\n</code--></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">脚本报错信息为：Fatal error: Enum may not include __toString。</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">本文中，我们探讨了PHP 8中大部分与类相关的功能，其中包括枚举、新增类属性只读修饰符，以及构造函数参数提升。在系列文章的下一篇中，我们将探索函数与方法相关的新功能。</code></code></code></p><p></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">原文链接：</code></code></code></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.com/articles/php8-classes-enums/\">PHP 8 - Classes and Enums</a>\"</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">相关阅读：</code></code></code></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.cn/article/XkzLrAYhV1CWPDzu72N2\">PHP 8：注解、match 表达式及其他改进</a>\"</code></code></code></p>",
    "publish_time": "2022-12-27 11:42:13",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "全栈自研“AI大底座”发布！百度智能云：智能计算基础设施正面临全面升级",
    "url": "https://www.infoq.cn/article/Ft4tqluVYC4YagxW23KT",
    "summary": "<p>12月27日，由百度智能云、中国电子技术标准化研究院主办的2022云智峰会 | 智算峰会召开。百度智能云发布国内首个全栈自研的AI基础设施“AI大底座”，并全面升级25项产品和技术。此外，搭载百度“AI大底座”全栈能力的百度阳泉智算中心正式对外开放服务，该中心是目前亚洲最大的单体智算中心。</p><p>&nbsp;</p><p>百度集团执行副总裁、百度智能云事业群总裁沈抖表示，智能化为产业创造价值的浪潮才刚开始，未来空间无限。百度智能云的“云智一体”能力已经在交通、工业、金融、政务等众多产业实践中得到了验证，目前已经可以标准化输出AI的底层能力，帮助企业实现“智能的随用随取”，真正降本增效。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/7c/7c3e9494d1b03777a724f561d65182e3.png\" /></p><p>百度集团执行副总裁、百度智能云事业群总裁沈抖</p><p></p><p>AI原生时代正加速到来，云计算产业面临“三全”变革</p><p></p><p>随着智能调度、自动驾驶、工业化联网等智能化产业应用的不断普及，中国产业正面临从数字化向智能化转移的关键窗口期。同时，大模型、AIGC等技术应用的出现，正在加速推动AI原生云的发展，这对中国的云计算产业提出了新要求。</p><p>&nbsp;</p><p>百度集团副总裁侯震宇表示，AI原生时代的加速到来，已经使得云计算产业面临“三全”变革，快速响应产业的新要求，才能把握新机遇。</p><p>&nbsp;</p><p>首先，是全面升级的智算硬件体系。AI带来更高密度的计算，AI负载占比越来越高，这就需要升级硬件体系架构，提升AI工作负载的运行效能。目前，智算硬件体系结构正在升级，多芯异构化、全面池化、微秒级互联将是未来主要发展趋势。</p><p>&nbsp;</p><p>其次，是全栈融合的智算基础设施。企业使用人工智能，需要构建新的智算基础设施，高效解决算力、算法和数据处理等多维度的问题。为了提升整体效能，就需要打造全栈融合的智算基础设施，做到全要素、端到端的优化，实现极致的资源效能和模型效能。</p><p>&nbsp;</p><p>第三，是全域泛在的智算应用场景。数据产生智能，智能穿戴设备、汽车、工厂和办公设备等智能硬件和IOT的发展，会产生海量数据，这就需要以数据为中心，构建全域泛在的智算能力，让智算无处不在，随时随地进行。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ea/ea8830cf06ba0458279e5feecee2befd.png\" /></p><p>百度集团副总裁侯震宇</p><p></p><p>针对云计算产业的三大变革，百度智能云全面升级25项产品和技术。在基础设施层面，百度发布国内首个全栈自研的AI基础设施“百度AI大底座”，发布百舸AI异构计算平台2.0。在硬件层面，升级百度太行DPU、百度自研AI芯片“昆仑芯”。</p><p>&nbsp;</p><p>侯震宇表示，昆仑芯已经量产数万片，实现了大规模的商业化落地。百度内部已经部署到搜索、小度、自动驾驶、爱奇艺等业务，百度外部也已经在金融、工业等客户的业务中使用。目前7nm昆仑芯2代相比1代，性能提升了2到3倍，性价比优于国外同级别芯片，昆仑芯3代也已经启动研发。</p><p>&nbsp;</p><p>百度发布国内首个全栈自研的AI基础设施“AI大底座”</p><p></p><p>随着大模型、AIGC为代表的AI应用不断成为行业热议话题，AI原生时代正在加速到来，这对云计算的基础设施提出了新要求：全栈融合（需要提供芯片、框架、模型、应用在内的全栈方案）、端到端优化、提供极致的资源效能和模型效能，成为未来智能计算发展的三大主流方向。</p><p>&nbsp;</p><p>但企业在构建云计算基础设施时，面临两大痛点：企业在用云时，需要把大量时间精力花在构建基础设施上，且这样的基础设施大多是拼凑组合的，没有发挥出最佳的性能和效率；基础设施中的核心部分，比如芯片、深度学习框架、大模型，需要大规模投入才能做好，一般企业无力支付巨额的研发成本。</p><p>&nbsp;</p><p>针对行业痛点问题，百度智能云今日发布国内首个全栈自研的AI基础设施“百度AI大底座”，面向企业AI开发和应用提供端到端自主可控、自我进化的解决方案，让企业可以快捷、低成本地实现“AI能力的随用随取”。</p><p>&nbsp;</p><p>“百度AI大底座”由AI IaaS层（百舸AI异构计算平台）、AI PaaS层（AI中台）两大部分组成。在AI IaaS层，整合百度自研的AI芯片“昆仑芯”，在AI计算、存储、加速、容器方面进行系统优化，提供高性价比的算力，承载海量数据的处理、超大模型的训练和推理。在AI PaaS层，整合百度两大核心自研产品（飞桨深度学习框架、百度文心大模型），打通百度的样本中心、模型中心、AI开发平台、AI服务运行平台，实现从数据存储到模型训练、生产、部署、测试的全链路、批量化生产，面向企业模型开发的全生命周期提供完整解决方案。</p><p>&nbsp;</p><p>简单来说，“百度AI大底座”是百度各项底层AI技术的集大成者，&nbsp;通过AI底层技术的通用化、模块化，实现AI服务的规模化，其目的本质上是帮助企业降本增效。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/75/7527f14bd29335a931d07bdd92e0da6b.png\" /></p><p>百度智能云今日发布：国内首个全栈自研的AI基础设施“百度AI大底座”</p><p></p><p>“AI大底座就是要帮助客户从上云，进入到用数、赋智的快车道，极大降低AI产业应用的门槛，提升效率，而企业只需要把精力聚焦在场景业务上。”沈抖说。</p><p>&nbsp;</p><p>今年9月，百度智能云推出“云智一体3.0”全新架构。整体来看，百度自研的AI技术上下贯穿了行业场景和基础底座，通过打造行业标杆应用，形成诸如智能客服、数字人等标准化的AI通用产品，进一步带动和沉淀AI PaaS 层和 AI IaaS 层的能力，打造高性价比的异构算力和高效的 AI 开发运行能力，从而形成云智一体、螺旋上升的业务模式。</p><p>&nbsp;</p><p>百度阳泉智算中心将全面对外开放</p><p></p><p>近年来，随着自动驾驶、生命科学、智能制造等领域的迅速发展，以及超大规模AI计算对算力的需求不断提高，智算中心作为人工智能产业发展的重要底层基础设施形态，成为当前政府和大型企业加速智能化升级的重要建设热点。</p><p>&nbsp;</p><p>基于百度AI大底座，百度发布“智算中心解决方案”，该解决方案涵盖物理数据中心建设能力、智算基础设施“AI大底座”、百度软硬件生态能力，可以帮助政企客户打造普惠算力平台、科技孵化平台、人才培养平台和产业聚集平台。</p><p>&nbsp;</p><p>同时，百度阳泉智算中心正式对外开放。百度副总裁谢广军表示，阳泉智算中心搭载了“百度AI大底座”全栈能力，是目前已建成的亚洲最大单体智算中心，算力规模达4EFLOPS(每秒400亿亿次浮点运算)，可满足各行业超大规模AI计算需求。此外，阳泉智算中心平均PUE低至 1.08，绿色低碳程度处于行业领先水平。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/75/7574c2854289afae690dd43a38eeeb21.png\" /></p><p>百度副总裁谢广军</p><p></p><p>除了智算中心解决方案，“百度AI大底座”已经在智能驾驶、智慧城市、金融、能源等领域实现大规模应用。</p><p>&nbsp;</p><p>在金融领域，依托百度智能云AI大底座，中国邮储银行构建了国内大型商业银行中首个落地的全行范围统一机器学习平台“邮储大脑”，建成全行机器学习平台 。上线应用后，对信用卡亿级别样本的数据清洗和数据分析时间从月级别、周级别压缩至小时级别，大大提升了最繁重的数据处理工作效率。在智能风控领域，已支持了300多个信用评级、用户风险画像等相关模型的构建，实现了以天为周期的模型迭代，并通过自动化将审批时间缩短到秒级。目前，邮储银行的AI平台已经运行100多项AI能力, 支撑18个业务系统。</p><p>&nbsp;</p><p>在电力领域，国家电网通过百度AI大底座建设“两库一平台”智能基础设施（“两库”指模型库、样本库，“一平台”指包含运行环境和训练环境的人工智能平台），在输电端构建起安全隐患识别模型、知识管理平台。在巡检一线，无人机接到工作人员指令后，可自主完成输电线路巡检作业。基于AI的智能识别算法将识别准确率提升了30个百分点，识别效率提升了5倍。在变电站，运维人员从线上接入智能调控系统，采用“一键顺控”操作，无需人员到场便可完成千伏变电站的倒闸操作，效率提升了40—60倍，启动送电时间缩短了80%。</p><p>&nbsp;</p><p>在自动驾驶领域，通过AI大底座，企业中工具链的开发者，不必再花大量精力在AI基础设施的构建上，通过端到端优化，使得自动驾驶常用的算子训练和推理的速度平均提升了100%，研发迭代效率提升100%。</p><p>&nbsp;</p><p>“智能化为行业创造价值的浪潮才刚刚开始，这就需要云计算厂商标准化地输出智能化的底层能力，把芯片、大模型、深度学习框架等高门槛的技术，变成像水电能一样供客户按需取用。”沈抖说。</p>",
    "publish_time": "2022-12-27 12:30:33",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "融云任杰：激活组织生命力 让听见炮火的人做决策",
    "url": "https://www.infoq.cn/article/cT2otUHy1jfND2j3er69",
    "summary": "<p></p><blockquote>任杰，融云联合创始人兼首席科学家，TGO 鲲鹏会（北京）学员；曾就职于微软和神州泰岳等公司，在微软两次获得全球杰出员工奖，曾负责中国联通搭建 WAP 网关、增值业务管理平台；在神州泰岳期间，带领飞信产品研发团队，从 0 到 1 完成中国移动飞信系统研发，业务峰值达到 3.8 亿注册用户；2016 年加入融云，历任 CPO、CTO 等职位，现任融云首席科学家。</blockquote><p></p><p></p><p>与这个时代的很多程序员一样，任杰的代码人生也是从游戏开始的。一款操纵矿车挖金子的古早小游戏，成功引起了任杰对计算机的好奇，他开始自学编程并在后来选择了宁夏大学的计算机专业。</p><p></p><p>1998 年任杰毕业，彼时国内互联网正值从基础设施向应用设施传导的黄金年代，任杰南下深圳进入中国移动，负责营账系统和增值业务平台研发，正式开启了通信行业旅程。</p><p></p><p>后来，他又辗转来到北京，进入了微软担任咨询顾问，专门负责电信行业。这个时期，网络技术突飞猛进，人们越来越习惯使用即时通讯软件进行沟通，尤其是在办公场景，即时通讯应用大有赶超邮件之势。也是在这个时期，任杰第一次接触<a href=\"https://xie.infoq.cn/article/ba20436c9bb6fa1416d5fc569\"> IM 即时通讯</a>\"，为央视打造了一款即时通讯产品。</p><p></p><p>2008 年，任杰加入了飞信团队，出任 CTO。他带领的技术团队从最初的 400 人发展到 1000 多人，完成了对即时通讯的原始技术和运营经验积累。</p><p></p><p>种种因素导致飞信这款国民级应用遗憾折戟，成为一代人的回忆。但一群因飞信凝聚在一起的通信人，决定把这份印记延续下去。这就是包括任杰在内的融云创始团队，他们从飞信出师，创办了通信服务品牌<a href=\"https://baike.baidu.com/item/%E8%9E%8D%E4%BA%91/18702677?fr=aladdin\">融云</a>\"，以行业首创的即时通讯 PaaS 服务出发，并在市场和客户的需求变化中突破自己不断进化。</p><p></p><h2>让星星之火成燎原之势 创业者的关键使命</h2><p></p><p></p><p>2014 年，融云以原中国移动飞信技术团队为核心，打造 To B 市场的通信云服务平台，推出了面向开发者的 IM 即时通讯 SDK。创业初期团队都认为，IM 的需求是泛行业市场的，各行业的沟通都离不开通信云服务。但看似广阔的市场里，需求热度高低不同，融云要在开放性的环境下，找到准确方向。</p><p></p><p>在几个高热度方向试水实践后，任杰和团队发现，并非所有行业都有强需求。“比如，旅游行业专注旅游资源和线路设计，房地产行业更关注房源，他们虽有少量沟通需求，但不是非常迫切。”</p><p></p><p>最终，融云明确了社交、泛娱乐的主战场，它们对 IM 有着强烈需求，且用户数量足够多。这是融云在互联网公有云市场的主要阵地，并且至今仍然是融云的主力市场之一。</p><p></p><p>而后，融云一边持续优化 IM 服务体验，一边开拓其他服务内容，比如 RTC 实时音视频 SDK，以及后来的推送、审核、美颜、白板等一系列通信周边能力。以“IM+RTC+X”的完整通信解决方案为基础，融云推出了语聊房、直播、超级群、1V1、<a href=\"https://xie.infoq.cn/article/758c1d4459288e3a55bd926f5\">元宇宙</a>\"、游戏等解决方案，服务出海开发者对创新场景的探索。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/a0/a9/a0a5d5188d29bd259901c3f8c141cca9.png\" /></p><p></p><p>2018 年，融云将自己于公有云市场沉淀的标准能力，内化为支持本地部署的私有化通信技术中台，以通信中台赋能政企协同办公产品，跟随客户进行了大量细分场景的业务沉淀。</p><p></p><p>据《2022 年中国政企数智办公平台行业研究报告》显示，2021 年数智办公平台市场规模已达 74 亿元，增速达 22.1%。随着移动化办公渗透加深带来的第一轮建设和政企内部需求升级引导的第二轮建设，预计市场在未来 3 年将以 20% 的复合增速增长。</p><p></p><p>过往的深厚积累，让融云能够对市场的需求做出敏锐响应。近期融云推出了“百幄”数智办公平台，让公司丰富的产品结构和创新的服务模式最终成型。任杰表示，“作为管理者，最重要的责任便是在各种星星之火的机会中找到燎原之势。”</p><p></p><h2>从幕后到台前 直面中大型组织客户</h2><p></p><p></p><p>不同于以往以技术“赋能”的形象，融云要亲自下场以高度产品化的“百幄”从幕后走到台前，深入政企办公业务，直面中大型组织客户。“百幄”以高频使用的内部通讯切入，以工作台为入口，围绕政企办公领域涉及到的人、工作、知识、业务、场景，将各类办公服务串联在一起，具备应用聚合能力的统一办公平台。</p><p><img src=\"https://static001.infoq.cn/resource/image/25/4d/252f7f986f2dd932b7bbaf64b8dc424d.png\" /></p><p></p><p>任杰表示，2018 年起，融云便以通信中台能力赋能千行百业的办公场景，主要交付方式是作为通讯模块被集成于办公等各种系统中。而随着数字化转型和国产化大潮的推进，政企对办公平台的需求发生了极大转变。</p><p></p><p>首先，经过多年发展的党政军国央企，大部分经历了整个发展周期，每个阶段都会建设符合当时需求的信息化系统，所采用的技术方案、部署方式也都带有明显的阶段性特色。这带来两个结果：一是政企内部“烟囱”丛生形成一座座数据孤岛，各系统服务能力的交叉又造成了资源的浪费，政企需要可以融合多个系统的统一办公平台；二是政企的信息化现状和组织结构、流程规则各不相同，需要能灵活满足自己数字化转型需求的定制化产品，而不是一个通用型产品。</p><p></p><p>其次，国产化大潮下，政企对信息安全的重视程度与日俱增，而办公通信又是其中最核心的部分。这就要求服务商在国产化适配方面有一定的积累，而对信创生态的长期适配，恰恰是融云作为技术服务厂商的专有坚持。</p><p></p><p>在这种背景下，融云推出了“百幄”数智办公平台，通过改变政企独立建设、相互割裂的业务系统搭建方式，提供统一的身份认证、统一的消息待办通知以及统一的业务应用入口，可以有效提升政企办公效率。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/cc/57/cc5e970bb4594775b15fffde5b363157.png\" /></p><p></p><p>任杰强调，除了提高效率，数智化办公平台的本质目的是要使组织更具韧性。这就强调平台要满足中大型组织的大规模并发需求，应对政企复杂组织结构跨层级、跨地域、跨系统、跨部门、跨业务的协同和管理挑战，且需具备安全和灵活属性。</p><p></p><p>在高并发、高可用能力方面，融云的通信模块具有全员使用、高频调用的特点，在高并发、高可用的架构能力方面天然具有性能优势；在信息安全方面，融云支持私有化部署，支持国密加密，完成了对所有主流国产化方案的适配，支持信创基础环境下的政企办公平台搭建等；“百幄”的模块化和组件化产品结构，可适配政企的个性化需求，为不同行业提供数智化协同办公综合解决方案。</p><p></p><h2>创新与包容文化 让团队向未来出发</h2><p></p><p></p><p>从 IM 即时通讯到 RTC 实时音视频，从关注社交泛娱乐的互联网市场到聚焦办公的政企市场，融云稳定的组织能力和快速响应市场需求的能力，得益于公司文化中对创新和包容的强调。</p><p></p><p>在团队氛围方面，融云崇尚开发性思维，“开放性思维，即能够自我否定、听取别人意见的能力”，这是任杰心目中关键人才的核心素养。“我们现在面对的情况异常复杂，需要得到足够多的信息和事实来辅佐判断。”</p><p></p><p>在人才方面，比起经验，融云更关注经历。任杰进一步解释道：经验更多反映一个人的技能图谱，而经历是看一个人的思维逻辑、方法沉淀，包含了人们在面对困难时的选择、面对失败时的收获，这些更加重要。</p><p></p><p>而在企业文化上，融云推行鼓励创新，尽可能为团队提供一个相对自由的发展空间。“我本人也比较崇尚让听见炮火的人做决策，所以在融云，一线同学也有比较大的自由决策权。”比如，“百幄”非常重要的一个设计就是场景化 Kit，这是其保持灵活性的关键，设计思路就源于团队在贴身服务政企客户中，观察到的不同客户对产品细节需求差异特点。</p><p></p><p>在任杰眼中，唯有一只能打硬仗、打胜仗的团队，方能使公司行稳致远，并通过持续深耕以优化未来布局。</p><p></p><p>今后，融云的研发重点会聚焦在更大组织容纳的方向。事实上，随着数据量的逐级增加，即使是看起来和原来类似的功能，其背后蕴藏的算法和系统架构设计的复杂程度却是呈指数级上升的。因此，为了适应政企组织的大规模人员和高复杂架构不断发展的需求，融云将会在技术层面继续投入，突破通讯录、视频会议等产品的数量限制。</p><p></p><p>而建设生态体系一直都是融云一项面向未来的重要举措，因为丰富的生态体系可以让公司沿着自身核心能力实现战略性延伸。任杰表示，未来融云将继续牵手广大合作伙伴，打造通信云服务生态体系，为用户构建一站式解决方案</p><p></p><p>报名获取《2022 年中国政企数智办公平台行业研究报告》：<a href=\"https://www.huodongxing.com/event/4678344664123?qd=tgokph\">https://www.huodongxing.com/event/4678344664123?qd=tgokph</a>\"</p><p></p>",
    "publish_time": "2022-12-27 13:54:59",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "吴恩达：2022年，AI创造了这些奇迹",
    "url": "https://www.infoq.cn/article/B4AzyxVV8HUgokkL5CML",
    "summary": "<p></p><p></p><blockquote>吴恩达在圣诞节当天发布了一年一度的年终盘点，他从纯技术的角度出发，回顾 AI 科技在 2022 年创造出的那些奇迹。在过去的一年，AI 技术取得了巨大进步，生成式 AI 成为新一轮投资的热门去向，人工智能生成的文本、图像甚至是代码已经无处不在。Vision Transformer（ViT）在 2022 年同样迎来爆发式增长，今年之内有超 17000 篇 ViT 论文发布。研究人员突破了语言模型的边界，希望解决可信度、偏见和可更新性等老大难问题。</blockquote><p></p><p></p><p></p><h2>来自吴恩达的一封信</h2><p></p><p></p><p>亲爱的朋友们，大家好：</p><p></p><p>随着新年的临近，又到了寒冬肆虐的时候。但于 AI 来说，如今的我们绝非身处寒冬，而是热浪席卷的盛夏。</p><p></p><p>如今 AI 创造出的大部分经济价值集中在监督学习工具方面，即经过训练即可生成各类短标签（垃圾邮件 / 非垃圾邮件）乃至一系列标签的集合（例如音频转录文本）。今年，建立在监督学习技术之上的生成式 AI 也掀起新一波浪潮，让 AI 得以生成复杂且引人注目的丰富输出，包括自然顺畅的图像或文本段落等。</p><p></p><p>虽然强化学习等前一阶段的新工具未能带来与炒作声量相符的成果，但生成式 AI 确实表现良好，也成为 AI 应用领域的又一崭新范例。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/fd/fd78811ec8fab5cf233bab1bb071cd63.png\" /></p><p></p><p>更重要的是，监督学习所发挥的还只是其全部潜力中的一小部分。相信还有数以百万计的监督学习潜在应用尚未成为现实。目前全球无数团队仍在尝试通过监督学习找到产品开发的最佳实践。</p><p>相信在新的一年乃至更久远的未来，生成式 AI 将继续腾飞，为每个人创造更多价值。我有幸能够生活在这个科技飞速发展的时代，也欣慰于有机会参与其中创造未来，更为自己能与各位好友分享这个瞬息万变的世界而高兴不已！</p><p></p><p>新年快乐&nbsp;</p><p>你的朋友，Andrew</p><p></p><p></p><h2>2022：令人眼花缭乱的 AI 之年</h2><p></p><p></p><p>相信很多朋友正一手端着咖啡，一手跟 ChatGPT 闲聊，想让它为自己的亲朋好友推荐几样新年礼物。回顾这一年，AI 技术无疑取得了巨大进步。无论是目前已经颇有水准的文本、图像和代码生成能力，还是未来即将出现的视频与音乐创作前景，都让用户感到兴奋莫名。</p><p></p><p>当然，人们对于 AI 创造力的下一步进展也提出了疑问。一方面，AI 发展让更多化学与物理学模型成为可能，科学发现亦由此迎来又一股助力；而另一方面，政府则开始严格管控可用于 AI 创新的专用微处理器供应。在这个矛盾丛生、复杂多变的新时代，就让我们从纯技术的角度出发，回顾 AI 科技在 2022 年创造出的那些奇迹。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/5b/5b435dccc0570c85221eaab92bb74663.png\" /></p><p></p><p></p><h2>合成图像已无处不在</h2><p></p><p>由 AI 生成的图片正广为流传、引发争议，同时也成为新一轮投资的热门去向。</p><p></p><p>趋势背景：新一代文本到图像生成器掀起实验热潮，如今普通人也能靠语言描述快速创作出迷人的艺术作品和幻想场景。商业企业迅速将这项技术投入使用，让 AI 图像生成成为图形创作和编辑软件中的又一必备功能。</p><p></p><p>关键驱力： 凭借友好的用户界面、妙趣横生的输出结果和开放的 API 与模型，媒体生成类模型如今已经成为 AI 技术的“形象代言人”。</p><p></p><p>OpenAI 于今年 4 月发布 DALL-E 2，超过 150 万用户参与了这套模型的 beta 测试。到 9 月，DALL-E 2 模型全面开放。微软通过资助 OpenAI 获得了对该成果的独家商业所有权，并迅速将模型集成到 Azure AI 即服务平台当中。今年 7 月，各社交媒体平台上出现了大量一键式艺术创作方案，这些略显粗糙的图像背后依托的则是相对简单的 Craiyon。Stability AI 很快通过开源模型 Stable Diffusion 将 AI 图像创作推向新高潮——今年 11 月，此模型更新为 2.0 版，并最终吸引到超 1 亿美元新资本。Adobe 和照片存储业两大巨头 Getty Images 与 Shutterstock，纷纷将图像生成模型集成到自家产品和服务当中。此类程序可能根据给出的文本提示生成截然不同的结果。PromptBase 则开辟出新的市场空间，可根据描述生成有趣的文本字符串图形。</p><p></p><p>一切都很美，只是：这类模型是根据抓取自网络的图像训练而成。与大语言模型一样，它们也同样继承了线上内容中的偏见和煽动性表达方式。</p><p></p><p>Lensa AI 是一款照片编辑应用，可根据用户的自拍照生成“魔法头像”。尽管在移动应用排行榜上迅速蹿红，但其成功也伴随着不少争议——不少用户，特别是女性用户，发现该应用会刻意在输出图像中添加性化元素。视觉艺术家在线社区 ArtStation 也推出了自己的文本到图像功能。很多艺术家觉得，这种几秒钟内就能模仿艺术家个人风格的计算机程序可能威胁到他们的职业生涯，因此纷纷抵制该网站。</p><p></p><p>新闻背后：Diffusion 模型最初的输出结果只能用噪音来形容，但随后会通过一系列步骤有选择地去除低质量内容。由加州大学伯克利分校和斯坦福大学研究人员于 2015 年推出的这套模型经历了数年开发，最终成果表明其已经能够创作出足以匹敌生成对抗网络（GAN）的高水平图像。Stability AI 的 Stable Diffusion 正是以 Diffusion 模型为核心。另一方面，作为基于 GAN 的 DALL-E 的缔造者，OpenAI 也几乎在同一时间用 Diffusion 模型对自家成果进行了更新。</p><p></p><p>现状解读：新年中，相信计算机辅助创作革命将继续酝酿蓄力。生成式图像的风潮也绝不会止步于二维平面。谷歌和 Meta 今年都公布了令人印象深刻的文本到视频模型，而 OpenAI 的文本到 3D 对象也将生成速度提升到了新的量级。</p><p></p><p></p><h2>程序员的好朋友：编程助手大显身手</h2><p></p><p></p><p>软件项目进度又落后了？别怕，AI 新应用能帮忙。</p><p></p><p>趋势背景：事实证明，只要对代码做出微调，语言模型就能很快像经济丰富的开发者那样编写出软件例程……当然，输出质量仍然有待商榷。</p><p></p><p>关键驱力：AI 驱动的代码生成器正登陆各大企业，甚至小开发商和非技术人士也能轻松使用。</p><p></p><p>今年伊始，Ebay 就尝试将低代码工具交到非工程师的手中，让他们在无需 AI 或机器学习专业知识的情况下构建和部署模型。今年 2 月，DeepMind 推出了 AlphaCode。这是一款转换器，接受了 12 种编程语言共 8600 万种程序的预训练，甚至针对编码竞赛的参赛作品进行了调优。在推理阶段，它能生成上百万种可能的解决方案并过滤掉低质量的条目。最终，它在 10 场编码比赛中击败了半数以上的参赛者。今年 6 月，GitHub 开放了 Copilot 功能。这是一款能实时提供编码建议的自动补全系统，普通用户须支付订阅费方可使用，但学生和经过认证的开源开发者可以免费访问。</p><p></p><p>新闻背后： OpenAI GPT-3 语言模型的用户们早在 2020 年就发现，该模型完全可以生成能跑的代码。一年之后，OpenAI 又推出了名为 Codex 的调优版本，这就是如今 GitHub Copilot 的雏形。</p><p></p><p>一切都很美，但是： 这项技术的公开可用版本还无法编写复杂的程序。而且其输出乍看之下往往正确，但跑起来的结果却是错的。此外，Copilot 项目还身陷法律风险。针对 GitHub、OpenAI 和微软的集体诉讼认为，Codex 的训练过程违反了开源许可协议。最终判决结果很可能对文本、图像和其他媒体的生成模型产生深远的法律影响。</p><p></p><p>现状解读：AI 驱动型编码工具在短时间内还不太可能取代人类程序员，但它们确有可能顶替技术问答网站 Stack Overflow，成为开发者们最喜爱的疑难问询小助手。</p><p></p><p></p><h2>AI 之眼也在进化</h2><p></p><p></p><p>Vision Transformer（ViT）在 2022 年同样迎来爆发式增长。</p><p></p><p>趋势背景： 研究人员们在今年之内发表了超 17000 篇 ViT 论文，它们的共同主题就是：将自注意力与卷积结合起来。</p><p></p><p>关键驱力：Google Brain 的一支团队在 2020 年率先推出 Vision Transformer（ViT），此后该架构经历了持续改进。最终的努力让 ViT 获得了适应新任务的能力，同时也解决了不少此前难以克服的短板。</p><p></p><p>ViT 能够从海量数据中获得良好学习效果，因此 Meta 和索邦大学的研究人员希望能“仅”靠数百万示例数据集就让模型获得理想性能。他们使用数据增强和模型正则化等源自 transformer 模型的特定改造尝试提高性能。</p><p></p><p>韩国仁荷大学的研究人员修改了其中两个关键组件，使 ViT 更像卷积神经网络。他们首先将图像失势成具有更多重叠的小图块，之后修改了自注意力机制以关注每个图块的相邻图块、而非当前图块自身，这样模型就能了解该为相邻图块赋予均匀权重还是选择性权重。这些修改显著提高了模型准确性。</p><p></p><p>印度孟买理工学院的研究人员为 ViT 配备了卷积层。由于权重共享，卷积能够在本地处理像素、同时降低内存占用量。在准确性和速度方面，他们的卷积 ViT 也优于常规版本的 ViT 以及 Performer、Nyströformer 和 Linear Transformer 等 transformers 运行时优化方案。这种方法也得到了其他多支团队的采纳。</p><p></p><p>新闻背后：虽然不少 ViT 研究的目标在于最终取代卷积神经网络（CNN），但目前的主流趋势显然是将两者结合起来。ViT 的优势，在于它能够从大、小两个尺度考量图像内所有像素间的关系。但它的缺点是，模型需要额外的训练才能在随机初始化后融入 CNN 架构以进行学习。CNN 的局部上下文窗口（即其中只有局部像素较为重要）和权重共享（使其能够以相同的方式处理不同的图像位置）能帮助 transformers 从较少数据中学习到更多模式。</p><p></p><p>现状解读：过去一年来，Vision Transformer 的应用范围得到了极大拓展。ViT 已经能够生成真假难辨的连续视频帧，从 2D 图像序列到生成 3D 场景，并检测点云中的对象。如果没有这些成果，近期大火的 Diffusion 模型恐怕也无法达成如此惊艳的文本到图像生成进步。&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/07/07dc2f75726560ea0d87ea882417617c.png\" /></p><p></p><p></p><h2>语言模型持续扩展</h2><p></p><p>研究人员突破了语言模型的边界，希望解决可信度、偏见和可更新性等老大难问题。</p><p></p><p>趋势背景： 虽然不少 AI 实验室都想通过改进数据集和训练方法（包括训练单一 transformer 翻译上千种语言的方法）提升大语言模型的复杂度，但也有一些研究者尝试扩展模型架构，希望借此实现网络搜索、外部文档查询和更强的新信息适应效果。</p><p></p><p>关键驱力： 如今的语言模型虽然表现出强大的文本生成能力，但在辨别事实、控制“脑洞”和消除社会偏见方面仍然孱弱。研究人员正努力让语言模型的输出更值得依赖，同时减少煽动性。</p><p></p><p>2021 年底，DeepMind 提出了 RETRO，一种能从 MassivText 数据集中检索段落、并将其整合至输出中的模型。Al21 Labs 于春季推出的 Jurassic-X 引入了一套模块，包含一个计算器加一套维基百科查询系统，能够对语言模型就数学问题、历史事实等做出的回答执行事实验证。斯坦福大学和洛桑联邦理工学院的研究人员创建了 SERAC，这是一套无需重新训练、即可用新信息更新语言模型的系统。它有一套独立的系统，专门用于存储新数据并学习与之相关的查询结果，借此调整最终输出。Meta 构建的 Atlas，是一种能从文档数据库中检索信息以回答问题的语言模型。此方案于今年 8 月发布，参数量仅为 110 亿的 Atlas 在回答问题时表现甚至优于包含 5400 亿参数的 PaLM。今年晚些时候，OpenAI 对 ChatGPT 做出调优，以最大限度减少不真实、偏见性或有害性输出。由专人对该模型的训练数据质量进行排名，之后利用强化学习算法奖励模型优先生成与高排名结果相似的输出。上述发展趋势，也让人们对语言模型提出了更加微妙且动态的基准要求。为响应号召，130 多家机构在 BIG-bench 项目中展开合作，尝试联手解决通过表情符号推断电影自勉、参与模拟试验和检测逻辑谬误等一系列任务。</p><p></p><p>新闻背后：在取得进展的同时，语言模型也闹也不少乱子。Meta 公开展示的 Galactica 是一套可生成关于科学及技术主题文本的语言模型。但在 11 月开放展示短短三天，该模型就由于倾向于生成虚假信息和引用并不存在的来源而遭到关停。今年 8 月，同样来自 Meta 的聊天机器人 BlenderBot 3 则因散布种族主义刻板印象和阴谋论而快速弄臭了名声。</p><p></p><p>现状解读：这一年以来，文本生成领域的靠谱工具可谓争相涌现。相信成功的技术将在不久的未来，凭借一鸣惊人的新模型从激烈竞争市场上杀出一条新路。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/35/3549c4a2f622fb65b3a83fd9085130f8.png\" /></p><p></p><p></p><h2>是否有全能模型</h2><p></p><p></p><p>少数深度学习模型已经证明了自己解决几百种任务的能力。</p><p></p><p>趋势背景：过去一年，多任务模型的阵容也在急剧扩大。</p><p></p><p>关键驱力：研究人员突破了神经网络所能掌握的技能数量上限。他们的灵感来自大语言模型的新兴技能——例如无需架构调整就能创作诗歌加编写计算机程序，而利用文本和图像训练而成的模型也获得了在不同类型数据间找寻对应关系的能力。</p><p></p><p>今年春季，谷歌的 PaLM 在涉及语言理解和生成的数百项任务中，展示了小样本学习的最新成果。在某些情况下，其表现甚至优于经过调优的针对性模型或人类的平均水平。不久之后，DeepMind 发布了 Gato。其能够处理 600 多种不同任务，包括玩雅达利游戏、用机械手堆积木、生成图像说明等等，而且并不需要借助专用于这些任务的单独模型。该系统同时接受了各种数据集的监督训练，包括文本和图像识别、基于强化学习智能体生成动作等等。随着 2022 年接近尾声，谷歌研究人员又为机器人技术带来了类似的普适性能力。RT-1 也是一种 transformers 模型，能够引导机器人执行 700 多项任务。该系统能够将动作和图像令牌化，在近一年半的周期内利用多台机器人收集的 13 万组数据完成了训练。与原有技术相比，它在新任务、新环境和新对象上都表现出了强大的零样本适应性能。</p><p></p><p>新闻背后：欧盟拟议的 AI 法案最新草案很可能在 2023 年通过为法律。该法案将要求通用 AI 系统用户向当局注册，由官方评估其系统是否存在潜在滥用行为，并定期接受审计。该草案将通用 AI 系统定义为“执行图像 / 语音识别、音频 / 视频生成、模式检测、问答、翻译等普适性功能”，且“具有多种预期之内 / 之外用途”的 AI 系统。一些观察家批评该定义过于宽泛，相信后续真正具备通用性的新兴模型可能会促使监管机构进一步完善定义内容。</p><p></p><p>现状解读：目前能够推广至数百种不同任务的 AI 算法仍处于早期发展阶段。但 2022 年的实际进展，再次表明深度学习具备帮助我们达成这一目标的潜力。</p><p></p><p>&nbsp;原文链接：https://www.deeplearning.ai/the-batch/issue-176/</p>",
    "publish_time": "2022-12-27 14:22:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]