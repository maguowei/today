[
  {
    "title": "Java新特性完整指南：Switch模式匹配",
    "url": "https://www.infoq.cn/article/iOAJIJop5bKQflD0lF9A",
    "summary": "<p>Switch语句由选择器表达式和包含case标签的switch块组成；对选择器表达式进行求值，并切换到与求值结果相匹配的case标签所对应的执行路径。</p><p></p><p>在原来switch语句中，case…:标签语法采用的是穿透语义（fall-through semantics）。Java 14增加了对新标签语法case ...-&gt; 的支持，该语法采用的是非穿透语义。</p><p></p><p>Java 14还增加了对switch表达式的支持。Switch表达式的计算结果为单个值。该版本还引入了yield语句，用于显式地生成一个值。</p><p></p><p>支持switch表达式（另有一篇<a href=\"https://www.agileconnection.com/article/switch-expressions-java-14-add-simplicity-and-agility\">文章</a>\"进行了详细讨论）是指可以将switch用于需要表达式（如赋值语句）的实例。</p><p></p><h2>问题</h2><p></p><p></p><p>即使有了Java 14所做的功能增强，switch语句的使用还是有一些限制：</p><p></p><p>Switch选择器表达式只支持特定类型，即基本整型数据类型byte、short、char和int；对应的装箱形式Byte、Short、Character和Integer；String类；枚举类型。Switch选择器表达式的计算结果只能与常量做相等比较。在匹配case标签和常量值时只对一个值进行检查。null 值的处理方式与其他值不同。错误处理方式不统一。枚举的作用域不是很合理。</p><p></p><h2>解决方案</h2><p></p><p></p><p>为了克服这些限制，人们已经提出并实现了一种实用、便捷的解决方案：switch语句模式匹配和表达式。这个解决方案解决了上面提到的所有问题。</p><p></p><p>Switch模式匹配是在JDK 17中引入的，JDK 18、19和20对其做了改进，JDK 21最终将其完成。</p><p></p><p>模式匹配从以下几个方面克服了传统switch语句的局限性：</p><p></p><p>选择器表达式的类型可以是整型基本类型（不包括long类型），也可以是任何引用类型。除了常量之外，case标签还可以包含模式。不同于常量case标签只能应用于一个值，模式case标签可以应用于多个值。引入了一个新的case标签case p，其中p是一个模式。Case标签可以包含null。Case标签后面有一个可选的when子句，可用于条件模式匹配或受保护模式匹配。带有when的case标签被称为受保护case标签。枚举常量的case标签可以限定。当使用枚举常量时，选择器表达式不一定要是枚举类型。引入MatchException，在模式匹配中实现更统一的错误处理。传统的switch语句和穿透语义也支持模式匹配。模式匹配的一个好处是方便<a href=\"https://www.infoq.com/articles/data-oriented-programming-java/\">面向数据的编程</a>\"，例如提高复杂数据查询的性能。</p><p></p><h2>什么是模式匹配？</h2><p></p><p></p><p>模式匹配是一个功能强大的特性，它扩展了程序中控制流结构的功能。除了可以匹配传统上支持的常量外，该特性还允许选择器表达式与多个模式进行匹配。Switch语句的语义并没有变化；与switch选择器表达式的值进行匹配的case标签可能包含模式，如果选择器表达式的值与一个case标签模式匹配成功，就会选中控制流中那个case标签所对应的执行路径。唯一的增强是，选择器表达式既可以是基本整型（不包括long类型），也可以是任何引用类型。除了常量之外，case标签还可以包含模式。此外，还有一个新增功能是，case标签支持null和限定枚举常量。</p><p></p><p>以下是switch块中switch标签的语法：</p><p></p><p><code lang=\"java\">SwitchLabel:\n  case CaseConstant { , CaseConstant }\n  case null [, default]\n  case Pattern\n  default\n</code></p><p></p><p>模式匹配既可以用于具有穿透语义的传统case…:标签语法，也可以用于非穿透语义的case…-&gt;标签语法。尽管如此，必须注意的是，一个switch块不能同时使用这两种类型的case标签。</p><p></p><p>得益于这些修改，模式匹配让开发人员可以实现更复杂的控制流结构，为代码逻辑的处理提供了更丰富的方法。</p><p></p><h2>环境设置</h2><p></p><p></p><p>要运行本文中的示例代码，唯一的先决条件是安装Java 20或Java 21。与Java 20相比，Java 21只做了一项增强，即在case标签中支持限定枚举常量。可以通过以下命令查看Java版本：</p><p></p><p><code lang=\"java\">java --version\njava version \"20.0.1\" 2023-04-18\nJava(TM) SE Runtime Environment (build 20.0.1+9-29)\nJava HotSpot(TM) 64-Bit Server VM (build 20.0.1+9-29, mixed mode, sharing)\n</code></p><p></p><p>因为在Java 20中，switch模式匹配是一个预览特性，所以必须使用以下语法运行javac和java命令：</p><p></p><p><code lang=\"java\">javac --enable-preview --release 20 SampleClass.java\njava --enable-preview  SampleClass\n</code></p><p></p><p>但是，也可以使用<a href=\"https://openjdk.java.net/jeps/330\">源码启动器</a>\"直接运行它，命令行如下：</p><p></p><p><code lang=\"plain\">java --source 20 --enable-preview Main.java\n</code></p><p></p><p>还有一个<a href=\"https://docs.oracle.com/javase/9/jshell/introduction-jshell.htm#JSHEL-GUID-630F27C8-1195-4989-9F6B-2C51D46F52C8\">jshell</a>\"选项，但也需要启用预览功能：</p><p></p><p><code lang=\"java\">jshell --enable-preview\n</code></p><p></p><h2>一个简单的模式匹配示例</h2><p></p><p></p><p>我们从一个简单的模式匹配示例开始，其中，switch表达式的选择器表达式类型是引用类型Collection ；case标签包含case p形式的模式。</p><p></p><p><code lang=\"java\">import java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.Stack;\nimport java.util.Vector;\n\npublic class SampleClass {\n    static Object get(Collection c) {\n\n        return switch (c) {\n            case Stack s -&gt; s.pop();\n            case LinkedList l -&gt; l.getFirst();\n            case Vector v -&gt; v.lastElement();\n            default -&gt; c;\n        };\n    }\n\n    public static void main(String[] argv) {\n\n        var stack = new Stack();\n        stack.push(\"firstStackItemAdded\");\n        stack.push(\"secondStackItemAdded\");\n        stack.push(\"thirdStackItemAdded\");\n\n        var linkedList = new LinkedList();\n\n        linkedList.add(\"firstLinkedListElementAdded\");\n        linkedList.add(\"secondLinkedListElementAdded\");\n        linkedList.add(\"thirdLinkedListElementAdded\");\n\n        var vector = new Vector();\n\n        vector.add(\"firstVectorElementAdded\");\n        vector.add(\"secondVectorElementAdded\");\n        vector.add(\"thirdVectorElementAdded\");\n\n        System.out.println(get(stack));\n        System.out.println(get(linkedList));\n        System.out.println(get(vector));\n    }\n}\n</code></p><p></p><p>编译并运行这个Java应用程序，输出如下：</p><p></p><p><code lang=\"java\">thirdStackItemAdded\nfirstLinkedListElementAdded\nthirdVectorElementAdded\n</code></p><p></p><h2>模式匹配支持所有引用类型</h2><p></p><p></p><p>在上面给出的示例中，选择器表达式的类型是Collection类类型。但是，选择器表达式的类型可以是任何引用类型。因此，case标签模式可以是与选择器表达式的值兼容的任何引用类型。例如，下面是经过修改的SampleClass类，它使用了Object类型的选择器表达式，而case标签模式除了之前使用的Stack、LinkedList和Vector等引用类型外，还包括一个记录模式和一个数组引用类型的模式。</p><p></p><p><code lang=\"java\">import java.util.LinkedList;\nimport java.util.Stack;\nimport java.util.Vector;\n\nrecord CollectionType(Stack s, Vector v, LinkedList l) {\n}\n\npublic class SampleClass {\n    static Object get(Object c) {\n        return switch (c) {\n            case CollectionType r -&gt; r.toString();\n            case String[] arr -&gt; arr.length;\n            case Stack s -&gt; s.pop();\n            case LinkedList l -&gt; l.getFirst();\n            case Vector v -&gt; v.lastElement();\n            default -&gt; c;\n        };\n    }\n\n    public static void main(String[] argv) {\n\n        var stack = new Stack();\n        stack.push(\"firstStackItemAdded\");\n        stack.push(\"secondStackItemAdded\");\n        stack.push(\"thirdStackItemAdded\");\n\n        var linkedList = new LinkedList();\n\n        linkedList.add(\"firstLinkedListElementAdded\");\n        linkedList.add(\"secondLinkedListElementAdded\");\n        linkedList.add(\"thirdLinkedListElementAdded\");\n\n        var vector = new Vector();\n\n        vector.add(\"firstVectorElementAdded\");\n        vector.add(\"secondVectorElementAdded\");\n        vector.add(\"thirdVectorElementAdded\");\n\n        var r = new CollectionType(stack, vector, linkedList);\n        System.out.println(get(r));\n        String[] stringArray = {\"a\", \"b\", \"c\"};\n\n        System.out.println(get(stringArray));\n        System.out.println(get(stack));\n        System.out.println(get(linkedList));\n        System.out.println(get(vector));\n\n    }\n}\n</code></p><p></p><p>这次的输出如下：</p><p></p><p><code lang=\"java\">CollectionType[s=[firstStackItemAdded, secondStackItemAdded, thirdStackItemAdded\n], v=[firstVectorElementAdded, secondVectorElementAdded, thirdVectorElementAdded\n], l=[firstLinkedListElementAdded, secondLinkedListElementAdded, thirdLinkedList\nElementAdded]]\n3\nthirdStackItemAdded\nfirstLinkedListElementAdded\nthirdVectorElementAdded\n</code></p><p></p><h2>Null case标签</h2><p></p><p></p><p>传统上，如果选择器表达式的计算结果为空，则switch语句在运行时会抛出NullPointerException。选择器表达式为空不是编译时问题。下面这个简单的应用程序有一个匹配所有case标签的default ，我们通过它演示下选择器表达式为空如何导致运行时异常NullPointerException。</p><p></p><p><code lang=\"java\">import java.util.Collection;\n\npublic class SampleClass {\n    static Object get(Collection c) {\n        return switch (c) {\n            default -&gt; c;\n        };\n    }\n\n    public static void main(String[] argv) {\n        get(null);\n    }\n}\n</code></p><p></p><p>我们可以在switch块外面显式地检测空值，并仅在值非空时执行switch，但这涉及到添加if-else代码。在新的模式匹配特性中，Java增加了对null的支持。下面这个应用程序中的switch语句使用case null来检测选择器表达式的值是否为空。</p><p></p><p><code lang=\"java\">import java.util.Collection;\n\npublic class SampleClass {\n    static void get(Collection c) {\n\n        switch (c) {\n            case null -&gt; System.out.println(\"Did you call the get with a null?\");\n            default -&gt; System.out.println(\"default\");\n        }\n    }\n\n    public static void main(String[] argv) {\n        get(null);\n    }\n}\n</code></p><p></p><p>在运行时，应用程序输出如下：</p><p></p><p><code lang=\"java\">你在调用get方法时使用了null参数？\n</code></p><p></p><p>case null可以与case default合并，如下所示：</p><p></p><p><code lang=\"java\">import java.util.Collection;\n\npublic class SampleClass {\n    static void get(Collection c) {\n        switch (c) {\n            case null, default -&gt; System.out.println(\"Did you call the get with a null?\");\n        }\n    }\n\n    public static void main(String[] argv) {\n        get(null);\n    }\n}\n</code></p><p></p><p>但是，case null不能与任何其他case标签合并。例如，下面的类将case null与一个模式为Stack s的case标签做了合并：</p><p></p><p><code lang=\"java\">import java.util.Collection;\nimport java.util.Stack;\n\npublic class SampleClass {\n    static void get(Collection c) {\n        switch (c) {\n            case null, Stack s -&gt; System.out.println(\"Did you call the get with a null?\");\n            default -&gt; System.out.println(\"default\");\n        }\n    }\n\n    public static void main(String[] args) {\n        get(null);\n    }\n}\n</code></p><p></p><p>该类将产生如下编译时错误：</p><p></p><p><code lang=\"java\">SampleClass.java:11: error: 非法case标签合并\n          case null, Stack s -&gt; System.out.println(\"Did you call the get with a null?\");\n</code></p><p></p><h2>带有when子句的受保护模式</h2><p></p><p></p><p>有时，开发人员可能会使用与布尔表达式计算结果做匹配的条件式case标签模式。这时，when子句就派上用场了。该子句会计算布尔表达式，形成所谓的“受保护模式”。如下所示，代码中的第一个case标签使用when子句判断Stack是否为空。</p><p></p><p><code lang=\"java\">import java.util.Stack;\nimport java.util.Collection;\n\npublic class SampleClass {\n    static Object get(Collection c) {\n        return switch (c) {\n            case Stack s when s.empty() -&gt; s.push(\"first\");\n            case Stack s2 -&gt; s2.push(\"second\");\n            default -&gt; c;\n        };\n    }\n}\n</code></p><p></p><p>对应的代码在-&gt; 右侧，只有在Stack为空时才会执行。</p><p></p><h2>对于带有模式的case标签，顺序很重要</h2><p></p><p></p><p>在使用带模式的case标签时，开发人员必须确保不会因为顺序产生任何与类型或子类型层次结构相关的问题。这是因为，与常量case标签不同，case标签中的模式使得选择器表达式可以匹配多个包含模式的case标签。Switch模式匹配特性会匹配第一个模式与选择器表达式值相同的标签。</p><p></p><p>如果一个case标签模式的类型是在它之前出现的另一个case标签模式的类型的子类型，则会发生编译时错误，因为后一个case标签将被识别为不可访问代码。</p><p></p><p>下面是一个演示程序，你可以编译并运行它，其中类型为Object的case标签模式控制了后续类型为Stack的代码标签模式。</p><p></p><p><code lang=\"java\">import java.util.Stack;\n\npublic class SampleClass {\n    static Object get(Object c) {\n        return switch (c) {\n            case Object o  -&gt; c;\n            case Stack s  -&gt; s.pop();\n        };\n    }\n}\n</code></p><p></p><p>在编译这个类时，会产生以下错误信息：</p><p></p><p><code lang=\"java\">SampleClass.java:12: error: 该case标签为它前面的case标签所控制\n        case Stack s  -&gt; s.pop();\n             ^\n</code></p><p></p><p>像下面这样对调两个case标签的顺序就可以修复这个编译时错误：</p><p></p><p><code lang=\"java\">public class SampleClass {\n    static Object get(Object c) {\n        return switch (c) {\n            case Stack s  -&gt; s.pop();\n            case Object o  -&gt; c;\n        };\n    }\n}\n</code></p><p></p><p>类似地，如果case标签包含的模式与前面出现的无条件/非保护模式case标签具有相同的引用类型，则会导致编译类型的错误，就像下面的类这样：</p><p></p><p><code lang=\"java\">import java.util.Stack;\nimport java.util.Collection;\n\npublic class SampleClass {\n    static Object get(Collection c) {\n        return switch (c) {\n            case Stack s -&gt; s.push(\"first\");\n            case Stack s2 -&gt; s2.push(\"second\");\n        };\n    }\n}\n</code></p><p></p><p>上述代码在编译时会产生以下错误：</p><p></p><p><code lang=\"java\">SampleClass.java:13: error: 该case标签为它前面的case标签所控制\n        case Stack s2 -&gt; s2.push(\"second\");\n             ^\n</code></p><p></p><p>为了避免这种错误，case标签的顺序应该直观、可读。应该首先列出常量标签，然后是case null标签、受保护的模式标签和非受保护类型的模式标签。default case标签可以与case null 标签合并，也可以单独作为最后一个case标签。下面的类演示了正确的排序：</p><p></p><p><code lang=\"java\">import java.util.Collection;\nimport java.util.Stack;\nimport java.util.Vector;\n\npublic class SampleClass {\n    static Object get(Collection c) {\n        return switch (c) {\n            case null -&gt; c;  //case label null\n            case Stack s when s.empty() -&gt; s.push(\"first\");  // 受保护case标签\n            case Vector v when v.size() &gt; 2 -&gt; v.lastElement();  // 受保护case标签\n            case Stack s -&gt; s.push(\"first\");  // 非受保护case标签\n            case Vector v -&gt; v.firstElement();  // 非受保护case标签\n            default -&gt; c;\n        };\n    }\n}\n</code></p><p></p><h2>模式匹配可用于传统的switch语句和穿透语义</h2><p></p><p></p><p>模式匹配特性与它是switch语句还是switch表达式无关。模式匹配也与使用穿透语义的case…:标签还是使用非穿透语义的case…-&gt;标签无关。在下面的示例中，模式匹配与switch语句而不是与switch表达式一起使用。case标签使用了具有穿透语义的case…:。第一个case标签中的when子句使用了一个受保护的模式。</p><p></p><p><code lang=\"java\">import java.util.Stack;\nimport java.util.Collection;\n\npublic class SampleClass {\n    static void get(Collection c) {\n        switch (c) {\n            case Stack s when s.empty(): s.push(\"first\"); break;\n            case Stack s : s.push(\"second\");  break;\n            default : break;\n        }\n    }\n}\n</code></p><p></p><h2>模式变量的作用域</h2><p></p><p></p><p>模式变量是出现在case标签模式中的变量。模式变量的作用域仅限于出现在-&gt;箭头右侧的块、表达式或throw语句。请看下面的演示代码，default中使用了来自它前面的case标签的模式变量。</p><p></p><p><code lang=\"java\">import java.util.Stack;\n\npublic class SampleClass {\n    static Object get(Object c) {\n        return switch (c) {\n            case Stack s -&gt; s.push(\"first\");\n            default -&gt; s.push(\"first\");\n        };\n    }\n}\n</code></p><p></p><p>上述代码会产生以下编译错误：</p><p></p><p><code lang=\"java\">import java.util.Collection;\nSampleClass.java:13: error: cannot find symbol\n        default -&gt; s.push(\"first\");\n                   ^\n  symbol:   variable s\n  location: class SampleClass\n</code></p><p></p><p>出现在受保护case标签模式中的模式变量，其作用域包括when子句，如下所示：</p><p></p><p><code lang=\"java\">import java.util.Stack;\nimport java.util.Collection;\n\npublic class SampleClass {\n    static Object get(Collection c) {\n        return switch (c) {\n            case Stack s when s.empty() -&gt; s.push(\"first\");\n            case Stack s -&gt; s.push(\"second\");\n            default -&gt; c;\n        };\n    }\n}\n</code></p><p></p><p>由于模式变量的作用域有限，所以相同的模式变量名可以跨多个case标签使用。前面的例子说明了这一点，其中模式变量s用在了两个不同的case标签中。</p><p></p><p>当处理具有穿透语义的case标签时，模式变量的作用域扩展到了:右侧的一组语句。这就是为什么在上一节中，使用模式匹配和传统的switch语句，可以在两个case标签中使用相同的模式变量名。但是，具有穿透语义的case标签声明模式变量会导致编译时错误。关于这一点，下面的类可以证明：</p><p></p><p><code lang=\"java\">import java.util.Stack;\nimport java.util.Vector;\nimport java.util.Collection;\n\npublic class SampleClass {\n    static void get(Collection c) {\n        switch (c) {\n            case Stack s : s.push(\"second\");\n            case Vector v  : v.lastElement();\n            default : System.out.println(\"default\");\n        }\n    }\n}\n</code></p><p></p><p>第一个语句组中缺少break; 语句，如果第二个语句组中的模式变量v未初始化，则switch可能会在第二个语句组处失败。上述类会产生如下编译时错误：</p><p></p><p><code lang=\"java\">SampleClass.java:12: error: 非法穿透到模式\n        case Vector v  : v.lastElement();\n             ^\n</code></p><p></p><p>只需在第一个语句组中添加break; 语句就可以修复这个错误：</p><p></p><p><code lang=\"java\">import java.util.Stack;\nimport java.util.Vector;\nimport java.util.Collection;\n\npublic class SampleClass {\n    static void get(Collection c) {\n        switch (c) {\n            case Stack s : s.push(\"second\"); break;\n            case Vector v  : v.lastElement();\n            default : System.out.println(\"default\");\n        }\n    }\n}\n</code></p><p></p><h2>每个case标签只能有一个模式</h2><p></p><p></p><p>无论是类型为case…:的case标签，还是类型为case…-&gt;的case标签，都不允许在单个case标签中组合使用多个模式，否则会导致编译时错误。也许不太明显，在单个case标签中组合使用多个模式会导致非法穿透，如下所示：</p><p></p><p><code lang=\"java\">import java.util.Stack;\nimport java.util.Vector;\nimport java.util.Collection;\n\npublic class SampleClass {\n    static Object get(Collection c) {\n        return switch (c) {\n            case Stack s, Vector v -&gt; c;\n            default -&gt; c;\n        };\n    }\n}\n</code></p><p></p><p>上述代码会产生以下编译时错误：</p><p></p><p><code lang=\"java\">SampleClass.java:11: error: 非法穿透到模式\n        case Stack s, Vector v -&gt; c;\n                      ^\n</code></p><p></p><h2>一个switch块中只能有一个匹配所有的case标签</h2><p></p><p></p><p>无论是switch语句还是switch表达式，在一个switch块中包含多个匹配所有的case标签都会导致编译时错误。匹配所有的case标签是指：</p><p></p><p>一个带有模式、可以无条件匹配选择器表达式的case标签default case标签请看下面的演示类：</p><p></p><p><code lang=\"java\">import java.util.Collection;\n\npublic class SampleClass {\n    static Object get(Collection c) {\n        return switch (c) {\n            case Collection coll -&gt; c;\n            default -&gt; c;\n        };\n    }\n}\n</code></p><p></p><p>编译这个类会产生以下错误信息：</p><p></p><p><code lang=\"java\">SampleClass.java:13: error: switch同时具有无条件模式和default标签\n        default -&gt; c;\n        ^\n</code></p><p></p><h2>类型覆盖的穷尽性</h2><p></p><p></p><p>穷尽性意味着switch块必须处理选择器表达式所有可能的值。穷尽性要求只有在下列一项或多项适用的情况下才能满足：</p><p></p><p>a) 使用模式switch表达式/语句；</p><p></p><p>b) 使用case null；</p><p></p><p>c) 选择器表达式不属于以下遗留类型：char、 byte、short、int、Character、 Byte、Short、Integer、String或枚举类型。</p><p></p><p>为了实现穷尽性，如果子类型不多的话，则可以为选择器表达式类型的每个子类型添加case标签。然而，如果子类型众多，这种方法可能会很啰嗦；例如，为Object类型的选择器表达式的每个引用类型添加case标签，甚或为Collection类型的选择器表达式的每个子类型添加case标签，都是不可行的。</p><p></p><p>为了演示穷尽性要求，请看下面这个类：</p><p></p><p><code lang=\"java\">import java.util.Collection;\nimport java.util.Stack;\nimport java.util.LinkedList;\nimport java.util.Vector;\n\npublic class SampleClass {\n    static Object get(Collection c)   {\n        return switch (c) {\n            case Stack s  -&gt; s.push(\"first\");\n            case null  -&gt; throw new NullPointerException(\"null\");\n            case LinkedList l    -&gt; l.getFirst();\n            case Vector v  -&gt; v.lastElement();\n        };\n    }\n}  \n</code></p><p></p><p>该类会产生以下编译时错误消息：</p><p></p><p><code lang=\"java\">SampleClass.java:10: error: switch表达式未涵盖所有可能的输入值\n                return switch (c) {\n                       ^\n</code></p><p></p><p>如下所示，只需要增加一个default case标签就可以解决这个问题：</p><p></p><p><code lang=\"java\">import java.util.Collection;\nimport java.util.Stack;\nimport java.util.LinkedList;\nimport java.util.Vector;\n\npublic class SampleClass {\n    static Object get(Collection c)   {\n        return switch (c) {\n            case Stack s  -&gt; s.push(\"first\");\n            case null  -&gt; throw new NullPointerException(\"null\");\n            case LinkedList l    -&gt; l.getFirst();\n            case Vector v  -&gt; v.lastElement();\n            default -&gt; c;\n        };\n    }\n}  \n</code></p><p></p><p>像下面这样，如果匹配所有的case标签所带有的模式可以无条件匹配选择器表达式，那么就可以满足穷尽性要求，但它无法显式地处理任何子类型。</p><p></p><p><code lang=\"java\">import java.util.Collection;\n\npublic class SampleClass {\n    static Object get(Collection c)   {\n        return switch (c) {\n            case Collection coll  -&gt; c;\n        };\n    }\n}  \n</code></p><p></p><p>default case标签可用于满足穷尽性，但如果选择器表达式可能的取值非常少，有时候可以避免使用它。例如，如果选择器表达式的类型为java.util.Vector，只需提供一个子类java.util.Stack的case标签模式就可以避免。类似地，如果选择器表达式是密封类类型，则只有在密封类类型的permits子句中声明的类需要由switch块处理。</p><p></p><h2>Switch case标签中的泛型记录模式</h2><p></p><p></p><p>Java 20增加了对switch语句/表达式中泛型记录模式类型参数推断的支持。作为一个例子，考虑以下泛型记录：</p><p></p><p><code lang=\"java\">record Triangle<s>(S firstCoordinate, T secondCoordinate,V thirdCoordinate){};\n</code></p><p></p><p>在下面的switch块中，推断出的record模式如下：</p><p></p><p><code lang=\"java\">Triangle(var f, var s, var t):\n \nstatic void getPt(Triangle tr){\n        switch (tr) {\n           case Triangle(var f, var s, var t) -&gt; …;\n           case default -&gt; …;\n        }\n}\n</code></p><p></p><h2>使用MatchException进行错误处理</h2><p></p><p></p><p>Java 19引入了java.lang.Runtime类的一个新的子类，旨在用更统一的方式处理模式匹配期间的异常。这个名为java.lang.MatchException的新类是一个预览API。MatchException不是专门为switch中的模式匹配而设计的，而是为所有模式匹配语言结构而设计的。当模式匹配最终未能匹配提供的任何模式时，在运行时可能就会抛出MatchException。关于这一点，请看下面的应用程序。该应用程序的case标签中有一个record模式，而它所要匹配的record声明了一个除数为0的访问器方法。</p><p></p><p><code lang=\"java\">record DivisionByZero(int i) {\n    public int i() {\n        return i / 0;\n    }\n}\n\n\n\npublic class SampleClass {\n\n    static DivisionByZero get(DivisionByZero r) {\n        return switch(r) {\n        case DivisionByZero(var i) -&gt; r;\n        };\n\n    }\n\n    public static void main(String[] argv) {\n\n        get(new DivisionByZero(42));\n    }\n}\n</code></p><p></p><p>示例应用程序编译通过，没有错误，但运行时会抛出MatchException异常：</p><p></p><p><code lang=\"java\">Exception in thread \"main\" java.lang.MatchException: java.lang.ArithmeticException: / by zero\n        at SampleClass.get(SampleClass.java:7)\n        at SampleClass.main(SampleClass.java:14)\nCaused by: java.lang.ArithmeticException: / by zero\n        at DivisionByZero.i(SampleClass.java:1)\n        at SampleClass.get(SampleClass.java:1)\n        ... 1 more\n</code></p><p></p><h2>小结</h2><p></p><p></p><p>本文介绍了Java新增的对switch控制流结构模式匹配的支持。其主要改进是switch的选择器表达式可以是任何引用类型，并且switch的case标签可以包含模式，包括条件模式匹配。而且，如果你不愿意更新整个代码库，那么模式匹配也支持使用传统的switch语句及其穿透语义。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/pattern-matching-for-switch/\">https://www.infoq.com/articles/pattern-matching-for-switch/</a>\"</p>",
    "publish_time": "2023-07-18 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]