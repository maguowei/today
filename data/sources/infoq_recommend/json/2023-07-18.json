[
  {
    "title": "Java新特性完整指南：Switch模式匹配",
    "url": "https://www.infoq.cn/article/iOAJIJop5bKQflD0lF9A",
    "summary": "<p>Switch语句由选择器表达式和包含case标签的switch块组成；对选择器表达式进行求值，并切换到与求值结果相匹配的case标签所对应的执行路径。</p><p></p><p>在原来switch语句中，case…:标签语法采用的是穿透语义（fall-through semantics）。Java 14增加了对新标签语法case ...-&gt; 的支持，该语法采用的是非穿透语义。</p><p></p><p>Java 14还增加了对switch表达式的支持。Switch表达式的计算结果为单个值。该版本还引入了yield语句，用于显式地生成一个值。</p><p></p><p>支持switch表达式（另有一篇<a href=\"https://www.agileconnection.com/article/switch-expressions-java-14-add-simplicity-and-agility\">文章</a>\"进行了详细讨论）是指可以将switch用于需要表达式（如赋值语句）的实例。</p><p></p><h2>问题</h2><p></p><p></p><p>即使有了Java 14所做的功能增强，switch语句的使用还是有一些限制：</p><p></p><p>Switch选择器表达式只支持特定类型，即基本整型数据类型byte、short、char和int；对应的装箱形式Byte、Short、Character和Integer；String类；枚举类型。Switch选择器表达式的计算结果只能与常量做相等比较。在匹配case标签和常量值时只对一个值进行检查。null 值的处理方式与其他值不同。错误处理方式不统一。枚举的作用域不是很合理。</p><p></p><h2>解决方案</h2><p></p><p></p><p>为了克服这些限制，人们已经提出并实现了一种实用、便捷的解决方案：switch语句模式匹配和表达式。这个解决方案解决了上面提到的所有问题。</p><p></p><p>Switch模式匹配是在JDK 17中引入的，JDK 18、19和20对其做了改进，JDK 21最终将其完成。</p><p></p><p>模式匹配从以下几个方面克服了传统switch语句的局限性：</p><p></p><p>选择器表达式的类型可以是整型基本类型（不包括long类型），也可以是任何引用类型。除了常量之外，case标签还可以包含模式。不同于常量case标签只能应用于一个值，模式case标签可以应用于多个值。引入了一个新的case标签case p，其中p是一个模式。Case标签可以包含null。Case标签后面有一个可选的when子句，可用于条件模式匹配或受保护模式匹配。带有when的case标签被称为受保护case标签。枚举常量的case标签可以限定。当使用枚举常量时，选择器表达式不一定要是枚举类型。引入MatchException，在模式匹配中实现更统一的错误处理。传统的switch语句和穿透语义也支持模式匹配。模式匹配的一个好处是方便<a href=\"https://www.infoq.com/articles/data-oriented-programming-java/\">面向数据的编程</a>\"，例如提高复杂数据查询的性能。</p><p></p><h2>什么是模式匹配？</h2><p></p><p></p><p>模式匹配是一个功能强大的特性，它扩展了程序中控制流结构的功能。除了可以匹配传统上支持的常量外，该特性还允许选择器表达式与多个模式进行匹配。Switch语句的语义并没有变化；与switch选择器表达式的值进行匹配的case标签可能包含模式，如果选择器表达式的值与一个case标签模式匹配成功，就会选中控制流中那个case标签所对应的执行路径。唯一的增强是，选择器表达式既可以是基本整型（不包括long类型），也可以是任何引用类型。除了常量之外，case标签还可以包含模式。此外，还有一个新增功能是，case标签支持null和限定枚举常量。</p><p></p><p>以下是switch块中switch标签的语法：</p><p></p><p><code lang=\"java\">SwitchLabel:\n  case CaseConstant { , CaseConstant }\n  case null [, default]\n  case Pattern\n  default\n</code></p><p></p><p>模式匹配既可以用于具有穿透语义的传统case…:标签语法，也可以用于非穿透语义的case…-&gt;标签语法。尽管如此，必须注意的是，一个switch块不能同时使用这两种类型的case标签。</p><p></p><p>得益于这些修改，模式匹配让开发人员可以实现更复杂的控制流结构，为代码逻辑的处理提供了更丰富的方法。</p><p></p><h2>环境设置</h2><p></p><p></p><p>要运行本文中的示例代码，唯一的先决条件是安装Java 20或Java 21。与Java 20相比，Java 21只做了一项增强，即在case标签中支持限定枚举常量。可以通过以下命令查看Java版本：</p><p></p><p><code lang=\"java\">java --version\njava version \"20.0.1\" 2023-04-18\nJava(TM) SE Runtime Environment (build 20.0.1+9-29)\nJava HotSpot(TM) 64-Bit Server VM (build 20.0.1+9-29, mixed mode, sharing)\n</code></p><p></p><p>因为在Java 20中，switch模式匹配是一个预览特性，所以必须使用以下语法运行javac和java命令：</p><p></p><p><code lang=\"java\">javac --enable-preview --release 20 SampleClass.java\njava --enable-preview  SampleClass\n</code></p><p></p><p>但是，也可以使用<a href=\"https://openjdk.java.net/jeps/330\">源码启动器</a>\"直接运行它，命令行如下：</p><p></p><p><code lang=\"plain\">java --source 20 --enable-preview Main.java\n</code></p><p></p><p>还有一个<a href=\"https://docs.oracle.com/javase/9/jshell/introduction-jshell.htm#JSHEL-GUID-630F27C8-1195-4989-9F6B-2C51D46F52C8\">jshell</a>\"选项，但也需要启用预览功能：</p><p></p><p><code lang=\"java\">jshell --enable-preview\n</code></p><p></p><h2>一个简单的模式匹配示例</h2><p></p><p></p><p>我们从一个简单的模式匹配示例开始，其中，switch表达式的选择器表达式类型是引用类型Collection ；case标签包含case p形式的模式。</p><p></p><p><code lang=\"java\">import java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.Stack;\nimport java.util.Vector;\n\npublic class SampleClass {\n    static Object get(Collection c) {\n\n        return switch (c) {\n            case Stack s -&gt; s.pop();\n            case LinkedList l -&gt; l.getFirst();\n            case Vector v -&gt; v.lastElement();\n            default -&gt; c;\n        };\n    }\n\n    public static void main(String[] argv) {\n\n        var stack = new Stack();\n        stack.push(\"firstStackItemAdded\");\n        stack.push(\"secondStackItemAdded\");\n        stack.push(\"thirdStackItemAdded\");\n\n        var linkedList = new LinkedList();\n\n        linkedList.add(\"firstLinkedListElementAdded\");\n        linkedList.add(\"secondLinkedListElementAdded\");\n        linkedList.add(\"thirdLinkedListElementAdded\");\n\n        var vector = new Vector();\n\n        vector.add(\"firstVectorElementAdded\");\n        vector.add(\"secondVectorElementAdded\");\n        vector.add(\"thirdVectorElementAdded\");\n\n        System.out.println(get(stack));\n        System.out.println(get(linkedList));\n        System.out.println(get(vector));\n    }\n}\n</code></p><p></p><p>编译并运行这个Java应用程序，输出如下：</p><p></p><p><code lang=\"java\">thirdStackItemAdded\nfirstLinkedListElementAdded\nthirdVectorElementAdded\n</code></p><p></p><h2>模式匹配支持所有引用类型</h2><p></p><p></p><p>在上面给出的示例中，选择器表达式的类型是Collection类类型。但是，选择器表达式的类型可以是任何引用类型。因此，case标签模式可以是与选择器表达式的值兼容的任何引用类型。例如，下面是经过修改的SampleClass类，它使用了Object类型的选择器表达式，而case标签模式除了之前使用的Stack、LinkedList和Vector等引用类型外，还包括一个记录模式和一个数组引用类型的模式。</p><p></p><p><code lang=\"java\">import java.util.LinkedList;\nimport java.util.Stack;\nimport java.util.Vector;\n\nrecord CollectionType(Stack s, Vector v, LinkedList l) {\n}\n\npublic class SampleClass {\n    static Object get(Object c) {\n        return switch (c) {\n            case CollectionType r -&gt; r.toString();\n            case String[] arr -&gt; arr.length;\n            case Stack s -&gt; s.pop();\n            case LinkedList l -&gt; l.getFirst();\n            case Vector v -&gt; v.lastElement();\n            default -&gt; c;\n        };\n    }\n\n    public static void main(String[] argv) {\n\n        var stack = new Stack();\n        stack.push(\"firstStackItemAdded\");\n        stack.push(\"secondStackItemAdded\");\n        stack.push(\"thirdStackItemAdded\");\n\n        var linkedList = new LinkedList();\n\n        linkedList.add(\"firstLinkedListElementAdded\");\n        linkedList.add(\"secondLinkedListElementAdded\");\n        linkedList.add(\"thirdLinkedListElementAdded\");\n\n        var vector = new Vector();\n\n        vector.add(\"firstVectorElementAdded\");\n        vector.add(\"secondVectorElementAdded\");\n        vector.add(\"thirdVectorElementAdded\");\n\n        var r = new CollectionType(stack, vector, linkedList);\n        System.out.println(get(r));\n        String[] stringArray = {\"a\", \"b\", \"c\"};\n\n        System.out.println(get(stringArray));\n        System.out.println(get(stack));\n        System.out.println(get(linkedList));\n        System.out.println(get(vector));\n\n    }\n}\n</code></p><p></p><p>这次的输出如下：</p><p></p><p><code lang=\"java\">CollectionType[s=[firstStackItemAdded, secondStackItemAdded, thirdStackItemAdded\n], v=[firstVectorElementAdded, secondVectorElementAdded, thirdVectorElementAdded\n], l=[firstLinkedListElementAdded, secondLinkedListElementAdded, thirdLinkedList\nElementAdded]]\n3\nthirdStackItemAdded\nfirstLinkedListElementAdded\nthirdVectorElementAdded\n</code></p><p></p><h2>Null case标签</h2><p></p><p></p><p>传统上，如果选择器表达式的计算结果为空，则switch语句在运行时会抛出NullPointerException。选择器表达式为空不是编译时问题。下面这个简单的应用程序有一个匹配所有case标签的default ，我们通过它演示下选择器表达式为空如何导致运行时异常NullPointerException。</p><p></p><p><code lang=\"java\">import java.util.Collection;\n\npublic class SampleClass {\n    static Object get(Collection c) {\n        return switch (c) {\n            default -&gt; c;\n        };\n    }\n\n    public static void main(String[] argv) {\n        get(null);\n    }\n}\n</code></p><p></p><p>我们可以在switch块外面显式地检测空值，并仅在值非空时执行switch，但这涉及到添加if-else代码。在新的模式匹配特性中，Java增加了对null的支持。下面这个应用程序中的switch语句使用case null来检测选择器表达式的值是否为空。</p><p></p><p><code lang=\"java\">import java.util.Collection;\n\npublic class SampleClass {\n    static void get(Collection c) {\n\n        switch (c) {\n            case null -&gt; System.out.println(\"Did you call the get with a null?\");\n            default -&gt; System.out.println(\"default\");\n        }\n    }\n\n    public static void main(String[] argv) {\n        get(null);\n    }\n}\n</code></p><p></p><p>在运行时，应用程序输出如下：</p><p></p><p><code lang=\"java\">你在调用get方法时使用了null参数？\n</code></p><p></p><p>case null可以与case default合并，如下所示：</p><p></p><p><code lang=\"java\">import java.util.Collection;\n\npublic class SampleClass {\n    static void get(Collection c) {\n        switch (c) {\n            case null, default -&gt; System.out.println(\"Did you call the get with a null?\");\n        }\n    }\n\n    public static void main(String[] argv) {\n        get(null);\n    }\n}\n</code></p><p></p><p>但是，case null不能与任何其他case标签合并。例如，下面的类将case null与一个模式为Stack s的case标签做了合并：</p><p></p><p><code lang=\"java\">import java.util.Collection;\nimport java.util.Stack;\n\npublic class SampleClass {\n    static void get(Collection c) {\n        switch (c) {\n            case null, Stack s -&gt; System.out.println(\"Did you call the get with a null?\");\n            default -&gt; System.out.println(\"default\");\n        }\n    }\n\n    public static void main(String[] args) {\n        get(null);\n    }\n}\n</code></p><p></p><p>该类将产生如下编译时错误：</p><p></p><p><code lang=\"java\">SampleClass.java:11: error: 非法case标签合并\n          case null, Stack s -&gt; System.out.println(\"Did you call the get with a null?\");\n</code></p><p></p><h2>带有when子句的受保护模式</h2><p></p><p></p><p>有时，开发人员可能会使用与布尔表达式计算结果做匹配的条件式case标签模式。这时，when子句就派上用场了。该子句会计算布尔表达式，形成所谓的“受保护模式”。如下所示，代码中的第一个case标签使用when子句判断Stack是否为空。</p><p></p><p><code lang=\"java\">import java.util.Stack;\nimport java.util.Collection;\n\npublic class SampleClass {\n    static Object get(Collection c) {\n        return switch (c) {\n            case Stack s when s.empty() -&gt; s.push(\"first\");\n            case Stack s2 -&gt; s2.push(\"second\");\n            default -&gt; c;\n        };\n    }\n}\n</code></p><p></p><p>对应的代码在-&gt; 右侧，只有在Stack为空时才会执行。</p><p></p><h2>对于带有模式的case标签，顺序很重要</h2><p></p><p></p><p>在使用带模式的case标签时，开发人员必须确保不会因为顺序产生任何与类型或子类型层次结构相关的问题。这是因为，与常量case标签不同，case标签中的模式使得选择器表达式可以匹配多个包含模式的case标签。Switch模式匹配特性会匹配第一个模式与选择器表达式值相同的标签。</p><p></p><p>如果一个case标签模式的类型是在它之前出现的另一个case标签模式的类型的子类型，则会发生编译时错误，因为后一个case标签将被识别为不可访问代码。</p><p></p><p>下面是一个演示程序，你可以编译并运行它，其中类型为Object的case标签模式控制了后续类型为Stack的代码标签模式。</p><p></p><p><code lang=\"java\">import java.util.Stack;\n\npublic class SampleClass {\n    static Object get(Object c) {\n        return switch (c) {\n            case Object o  -&gt; c;\n            case Stack s  -&gt; s.pop();\n        };\n    }\n}\n</code></p><p></p><p>在编译这个类时，会产生以下错误信息：</p><p></p><p><code lang=\"java\">SampleClass.java:12: error: 该case标签为它前面的case标签所控制\n        case Stack s  -&gt; s.pop();\n             ^\n</code></p><p></p><p>像下面这样对调两个case标签的顺序就可以修复这个编译时错误：</p><p></p><p><code lang=\"java\">public class SampleClass {\n    static Object get(Object c) {\n        return switch (c) {\n            case Stack s  -&gt; s.pop();\n            case Object o  -&gt; c;\n        };\n    }\n}\n</code></p><p></p><p>类似地，如果case标签包含的模式与前面出现的无条件/非保护模式case标签具有相同的引用类型，则会导致编译类型的错误，就像下面的类这样：</p><p></p><p><code lang=\"java\">import java.util.Stack;\nimport java.util.Collection;\n\npublic class SampleClass {\n    static Object get(Collection c) {\n        return switch (c) {\n            case Stack s -&gt; s.push(\"first\");\n            case Stack s2 -&gt; s2.push(\"second\");\n        };\n    }\n}\n</code></p><p></p><p>上述代码在编译时会产生以下错误：</p><p></p><p><code lang=\"java\">SampleClass.java:13: error: 该case标签为它前面的case标签所控制\n        case Stack s2 -&gt; s2.push(\"second\");\n             ^\n</code></p><p></p><p>为了避免这种错误，case标签的顺序应该直观、可读。应该首先列出常量标签，然后是case null标签、受保护的模式标签和非受保护类型的模式标签。default case标签可以与case null 标签合并，也可以单独作为最后一个case标签。下面的类演示了正确的排序：</p><p></p><p><code lang=\"java\">import java.util.Collection;\nimport java.util.Stack;\nimport java.util.Vector;\n\npublic class SampleClass {\n    static Object get(Collection c) {\n        return switch (c) {\n            case null -&gt; c;  //case label null\n            case Stack s when s.empty() -&gt; s.push(\"first\");  // 受保护case标签\n            case Vector v when v.size() &gt; 2 -&gt; v.lastElement();  // 受保护case标签\n            case Stack s -&gt; s.push(\"first\");  // 非受保护case标签\n            case Vector v -&gt; v.firstElement();  // 非受保护case标签\n            default -&gt; c;\n        };\n    }\n}\n</code></p><p></p><h2>模式匹配可用于传统的switch语句和穿透语义</h2><p></p><p></p><p>模式匹配特性与它是switch语句还是switch表达式无关。模式匹配也与使用穿透语义的case…:标签还是使用非穿透语义的case…-&gt;标签无关。在下面的示例中，模式匹配与switch语句而不是与switch表达式一起使用。case标签使用了具有穿透语义的case…:。第一个case标签中的when子句使用了一个受保护的模式。</p><p></p><p><code lang=\"java\">import java.util.Stack;\nimport java.util.Collection;\n\npublic class SampleClass {\n    static void get(Collection c) {\n        switch (c) {\n            case Stack s when s.empty(): s.push(\"first\"); break;\n            case Stack s : s.push(\"second\");  break;\n            default : break;\n        }\n    }\n}\n</code></p><p></p><h2>模式变量的作用域</h2><p></p><p></p><p>模式变量是出现在case标签模式中的变量。模式变量的作用域仅限于出现在-&gt;箭头右侧的块、表达式或throw语句。请看下面的演示代码，default中使用了来自它前面的case标签的模式变量。</p><p></p><p><code lang=\"java\">import java.util.Stack;\n\npublic class SampleClass {\n    static Object get(Object c) {\n        return switch (c) {\n            case Stack s -&gt; s.push(\"first\");\n            default -&gt; s.push(\"first\");\n        };\n    }\n}\n</code></p><p></p><p>上述代码会产生以下编译错误：</p><p></p><p><code lang=\"java\">import java.util.Collection;\nSampleClass.java:13: error: cannot find symbol\n        default -&gt; s.push(\"first\");\n                   ^\n  symbol:   variable s\n  location: class SampleClass\n</code></p><p></p><p>出现在受保护case标签模式中的模式变量，其作用域包括when子句，如下所示：</p><p></p><p><code lang=\"java\">import java.util.Stack;\nimport java.util.Collection;\n\npublic class SampleClass {\n    static Object get(Collection c) {\n        return switch (c) {\n            case Stack s when s.empty() -&gt; s.push(\"first\");\n            case Stack s -&gt; s.push(\"second\");\n            default -&gt; c;\n        };\n    }\n}\n</code></p><p></p><p>由于模式变量的作用域有限，所以相同的模式变量名可以跨多个case标签使用。前面的例子说明了这一点，其中模式变量s用在了两个不同的case标签中。</p><p></p><p>当处理具有穿透语义的case标签时，模式变量的作用域扩展到了:右侧的一组语句。这就是为什么在上一节中，使用模式匹配和传统的switch语句，可以在两个case标签中使用相同的模式变量名。但是，具有穿透语义的case标签声明模式变量会导致编译时错误。关于这一点，下面的类可以证明：</p><p></p><p><code lang=\"java\">import java.util.Stack;\nimport java.util.Vector;\nimport java.util.Collection;\n\npublic class SampleClass {\n    static void get(Collection c) {\n        switch (c) {\n            case Stack s : s.push(\"second\");\n            case Vector v  : v.lastElement();\n            default : System.out.println(\"default\");\n        }\n    }\n}\n</code></p><p></p><p>第一个语句组中缺少break; 语句，如果第二个语句组中的模式变量v未初始化，则switch可能会在第二个语句组处失败。上述类会产生如下编译时错误：</p><p></p><p><code lang=\"java\">SampleClass.java:12: error: 非法穿透到模式\n        case Vector v  : v.lastElement();\n             ^\n</code></p><p></p><p>只需在第一个语句组中添加break; 语句就可以修复这个错误：</p><p></p><p><code lang=\"java\">import java.util.Stack;\nimport java.util.Vector;\nimport java.util.Collection;\n\npublic class SampleClass {\n    static void get(Collection c) {\n        switch (c) {\n            case Stack s : s.push(\"second\"); break;\n            case Vector v  : v.lastElement();\n            default : System.out.println(\"default\");\n        }\n    }\n}\n</code></p><p></p><h2>每个case标签只能有一个模式</h2><p></p><p></p><p>无论是类型为case…:的case标签，还是类型为case…-&gt;的case标签，都不允许在单个case标签中组合使用多个模式，否则会导致编译时错误。也许不太明显，在单个case标签中组合使用多个模式会导致非法穿透，如下所示：</p><p></p><p><code lang=\"java\">import java.util.Stack;\nimport java.util.Vector;\nimport java.util.Collection;\n\npublic class SampleClass {\n    static Object get(Collection c) {\n        return switch (c) {\n            case Stack s, Vector v -&gt; c;\n            default -&gt; c;\n        };\n    }\n}\n</code></p><p></p><p>上述代码会产生以下编译时错误：</p><p></p><p><code lang=\"java\">SampleClass.java:11: error: 非法穿透到模式\n        case Stack s, Vector v -&gt; c;\n                      ^\n</code></p><p></p><h2>一个switch块中只能有一个匹配所有的case标签</h2><p></p><p></p><p>无论是switch语句还是switch表达式，在一个switch块中包含多个匹配所有的case标签都会导致编译时错误。匹配所有的case标签是指：</p><p></p><p>一个带有模式、可以无条件匹配选择器表达式的case标签default case标签请看下面的演示类：</p><p></p><p><code lang=\"java\">import java.util.Collection;\n\npublic class SampleClass {\n    static Object get(Collection c) {\n        return switch (c) {\n            case Collection coll -&gt; c;\n            default -&gt; c;\n        };\n    }\n}\n</code></p><p></p><p>编译这个类会产生以下错误信息：</p><p></p><p><code lang=\"java\">SampleClass.java:13: error: switch同时具有无条件模式和default标签\n        default -&gt; c;\n        ^\n</code></p><p></p><h2>类型覆盖的穷尽性</h2><p></p><p></p><p>穷尽性意味着switch块必须处理选择器表达式所有可能的值。穷尽性要求只有在下列一项或多项适用的情况下才能满足：</p><p></p><p>a) 使用模式switch表达式/语句；</p><p></p><p>b) 使用case null；</p><p></p><p>c) 选择器表达式不属于以下遗留类型：char、 byte、short、int、Character、 Byte、Short、Integer、String或枚举类型。</p><p></p><p>为了实现穷尽性，如果子类型不多的话，则可以为选择器表达式类型的每个子类型添加case标签。然而，如果子类型众多，这种方法可能会很啰嗦；例如，为Object类型的选择器表达式的每个引用类型添加case标签，甚或为Collection类型的选择器表达式的每个子类型添加case标签，都是不可行的。</p><p></p><p>为了演示穷尽性要求，请看下面这个类：</p><p></p><p><code lang=\"java\">import java.util.Collection;\nimport java.util.Stack;\nimport java.util.LinkedList;\nimport java.util.Vector;\n\npublic class SampleClass {\n    static Object get(Collection c)   {\n        return switch (c) {\n            case Stack s  -&gt; s.push(\"first\");\n            case null  -&gt; throw new NullPointerException(\"null\");\n            case LinkedList l    -&gt; l.getFirst();\n            case Vector v  -&gt; v.lastElement();\n        };\n    }\n}  \n</code></p><p></p><p>该类会产生以下编译时错误消息：</p><p></p><p><code lang=\"java\">SampleClass.java:10: error: switch表达式未涵盖所有可能的输入值\n                return switch (c) {\n                       ^\n</code></p><p></p><p>如下所示，只需要增加一个default case标签就可以解决这个问题：</p><p></p><p><code lang=\"java\">import java.util.Collection;\nimport java.util.Stack;\nimport java.util.LinkedList;\nimport java.util.Vector;\n\npublic class SampleClass {\n    static Object get(Collection c)   {\n        return switch (c) {\n            case Stack s  -&gt; s.push(\"first\");\n            case null  -&gt; throw new NullPointerException(\"null\");\n            case LinkedList l    -&gt; l.getFirst();\n            case Vector v  -&gt; v.lastElement();\n            default -&gt; c;\n        };\n    }\n}  \n</code></p><p></p><p>像下面这样，如果匹配所有的case标签所带有的模式可以无条件匹配选择器表达式，那么就可以满足穷尽性要求，但它无法显式地处理任何子类型。</p><p></p><p><code lang=\"java\">import java.util.Collection;\n\npublic class SampleClass {\n    static Object get(Collection c)   {\n        return switch (c) {\n            case Collection coll  -&gt; c;\n        };\n    }\n}  \n</code></p><p></p><p>default case标签可用于满足穷尽性，但如果选择器表达式可能的取值非常少，有时候可以避免使用它。例如，如果选择器表达式的类型为java.util.Vector，只需提供一个子类java.util.Stack的case标签模式就可以避免。类似地，如果选择器表达式是密封类类型，则只有在密封类类型的permits子句中声明的类需要由switch块处理。</p><p></p><h2>Switch case标签中的泛型记录模式</h2><p></p><p></p><p>Java 20增加了对switch语句/表达式中泛型记录模式类型参数推断的支持。作为一个例子，考虑以下泛型记录：</p><p></p><p><code lang=\"java\">record Triangle<s>(S firstCoordinate, T secondCoordinate,V thirdCoordinate){};\n</code></p><p></p><p>在下面的switch块中，推断出的record模式如下：</p><p></p><p><code lang=\"java\">Triangle(var f, var s, var t):\n \nstatic void getPt(Triangle tr){\n        switch (tr) {\n           case Triangle(var f, var s, var t) -&gt; …;\n           case default -&gt; …;\n        }\n}\n</code></p><p></p><h2>使用MatchException进行错误处理</h2><p></p><p></p><p>Java 19引入了java.lang.Runtime类的一个新的子类，旨在用更统一的方式处理模式匹配期间的异常。这个名为java.lang.MatchException的新类是一个预览API。MatchException不是专门为switch中的模式匹配而设计的，而是为所有模式匹配语言结构而设计的。当模式匹配最终未能匹配提供的任何模式时，在运行时可能就会抛出MatchException。关于这一点，请看下面的应用程序。该应用程序的case标签中有一个record模式，而它所要匹配的record声明了一个除数为0的访问器方法。</p><p></p><p><code lang=\"java\">record DivisionByZero(int i) {\n    public int i() {\n        return i / 0;\n    }\n}\n\n\n\npublic class SampleClass {\n\n    static DivisionByZero get(DivisionByZero r) {\n        return switch(r) {\n        case DivisionByZero(var i) -&gt; r;\n        };\n\n    }\n\n    public static void main(String[] argv) {\n\n        get(new DivisionByZero(42));\n    }\n}\n</code></p><p></p><p>示例应用程序编译通过，没有错误，但运行时会抛出MatchException异常：</p><p></p><p><code lang=\"java\">Exception in thread \"main\" java.lang.MatchException: java.lang.ArithmeticException: / by zero\n        at SampleClass.get(SampleClass.java:7)\n        at SampleClass.main(SampleClass.java:14)\nCaused by: java.lang.ArithmeticException: / by zero\n        at DivisionByZero.i(SampleClass.java:1)\n        at SampleClass.get(SampleClass.java:1)\n        ... 1 more\n</code></p><p></p><h2>小结</h2><p></p><p></p><p>本文介绍了Java新增的对switch控制流结构模式匹配的支持。其主要改进是switch的选择器表达式可以是任何引用类型，并且switch的case标签可以包含模式，包括条件模式匹配。而且，如果你不愿意更新整个代码库，那么模式匹配也支持使用传统的switch语句及其穿透语义。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/pattern-matching-for-switch/\">https://www.infoq.com/articles/pattern-matching-for-switch/</a>\"</p>",
    "publish_time": "2023-07-18 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "揭秘“灯塔工厂”的AI应用案例和规模化策略",
    "url": "https://www.infoq.cn/article/1fSLGpl1K3OYX6AgLZ34",
    "summary": "<p>友达光电成立于1996年，是光电行业最早进行智能制造转型的企业。在光电行业从规模竞争转向价值竞争的背景下，光电企业生产的产品形态呈现少量多样、高规格、定制化的趋势；但面板的生产周期仍然非常长，管理的幅度很宽，复杂性高；与此同时，面板价格出现变化，成本改善的速度比较慢。</p><p></p><p>各种内外部的因素，促使<a href=\"https://www.infoq.cn/article/ZGkKXpk51tTmHwOYCVKx\">友达光电</a>\"在2015年前后着手推动全面性的数字化转型。而在2017年，整个集团内部就开始大量导入AI推动预测式的制造、预测式的研发和预测式的运营。</p><p></p><p>2021年，友达光电入选世界灯塔工厂，当时麦肯锡团队对友达光电给出的评鉴结果就是“大数据与AI技术开发与广泛应用，展现工业4.0自驱动的永续发展动能。”在这个过程中，友达光电培育了超过800位AI专家，累计了超过2000个AI模型（如今已经超过3000个），在工厂里实时运行。</p><p></p><p>基于这些亲身实践经验，友达光电对AI的应用形成了比较清晰的思路和路径。在最新一期的 InfoQ《<a href=\"https://www.infoq.cn/theme/192\">超级连麦. 数智大脑</a>\"》直播中，友达工业服务全资子公司艾聚达总经理赖骏凯，揭秘了友达光电作为“灯塔工厂”背后的AI应用案例和规模化策略。</p><p></p><p>以下是分享全文（经 InfoQ 进行不改变原意的编辑整理）（点击链接可查看完整<a href=\"https://www.infoq.cn/video/axF9GTTK8NAZpglDfCsb\">直播回放</a>\"）：</p><p>&nbsp;</p><p>今天跟大家分享四个议题：第一，友达光电自身数字化转型的背景，以及在这个过程中创造的价值；第二，AI在工业领域的应用成功案例；第三，AI扩散的关键策略；最后，总结一下企业如何提升新型竞争力。</p><p></p><h2>品质提升是AI应用最重要的场景之一</h2><p></p><p></p><p>下面，我们以车载品质管理系统作为一个切入点。</p><p></p><p>大家都知道，AI被应用于非常多领域，而在制造中，品质提升是非常重要的一个应用场景。以车用市场为例，很多人可能对IATF16949品质管理体系非常熟悉，在每个制程过程中，我们都会去分析它的失效模式、失效原因，并且找到一个更好的管制方式，从而降低它的发生率，降低失效的严重度。</p><p></p><p>但是，过往的这种改善过程是存在天花板的，我们很难持续地去取得很好的改善成果。而<a href=\"https://www.infoq.cn/article/FRXOJ4dDWCK34mzO9EDM\">AI</a>\"可以帮助我们去突破这些改善的边界，甚至去拓展我们的管理幅度。</p><p></p><p>举个例子：过去我们大多使用的是统计方式在做失效分析，随着数据越来越多，分析维度就会有所短缺。而如果使用AI数据科学相关技术，就可以建构更高维度的分析能力，当分析能力越做越好，分析越来越细致，就有可能实现所谓的“无忧生产”的状态。</p><p></p><p>在整个监控和管理的过程中，我们也可以充分的使用AI技术。比如，在检测环节导入AI工业质检来建构智能化的检测能力；在产线发生率管理的过程中，也可以导入AI智能监控技术来建构智能化的管理能力，进而实现生产过程的精细化管理。</p><p></p><p>接下来，聚焦数据科学、工业质检、智能监控三个方面，给大家分享一下AI在工业品质提升场景的具体应用案例。</p><p></p><p> AI数据科学</p><p></p><p>首先，看AI数据科学。大家知道，最早企业做品质管理或品质改善更多是基于老师傅的经验去做分析，虽然后来衍生出了很多统计学方法，包括6-Sigma、SPC、DoE等等，但它们本质上还存在着老师傅的主观经验，并且分析的维度变量也是比较少的。</p><p></p><p>直到2015年之后，AI机器学习的分析方式陆续出现，我们开始有机会通过AI的方式去做全样本的建模，通过数据来驱动客观分析，实现高维度分析，甚至可以去预测产品状态。经过大量的实践，我们得到结论就是，AI的分析通常会做得比人更好。因为，过去我们遇到问题更多是事后解决，但通过AI，我们完全可以预测未来可能发生什么问题，并在这之前先行解决，或者进行干涉，从而减少产能的损失、良率的损失，实现事前管理。</p><p></p><p>以我们早期在友达光电内部进行良率改善的一个应用为例：比如面对W Spot这样的产品缺陷，过去我们花了很长时间去做改善，良率损失已经控制在0.5%左右，但是已经很难再找到改善的环节。直到使用了AI技术，我们在大量数据内部找到了两个新的关键因子。根据过往人的经验，我们并不认为这两个因素会影响到产品品质，而经过AI分析，我们尝试去做分析和小量实验，发现经过对两个参数的优化，我们的良率的确得到了改善，最后把不良率降到了0%。这是非常明显的良率改善。</p><p></p><p>除了类似这种隐性因子挖掘之外，AI技术还能提供非常多的帮助。例如参数推荐，我们在PCB行业做过一个应用案例，就是在金属镀膜的过程中（镀金或镀铜），成本材料非常高，如果镀的金层厚度过高，就会造成成本上升，如果厚度过薄，就会影响到产品良率。这时候，就要可以通过AI去做参数最优化的推荐，在兼顾成本跟品质的前提下给出最好的参数，这个参数过往都是由老师傅的经验决定的，但有可能它并不是最好的。</p><p></p><p>如今，相似的应用已经非常广泛，在过去多年时间里，我们已经在内外部超过12个行业实现了落地应用，包括PCB、半导体、光电行业，以及传统的石化橡胶、医疗、食品、传统材料研发等等。甚至，不只是制造端，在产供研销等环节都可以，例如人力资源领域，可以用AI去做离职率的预测，再比如厂务端，可以用AI去预测用电量等等。这些都是新技术带给我们的一些新能力的扩展。</p><p></p><p>AI工业质检</p><p></p><p>针对<a href=\"https://www.infoq.cn/article/MDuweEQy7Qr1FNHFXzfN\">工业质检</a>\"，很多企业会导入AOI的产线，但是，过去的AOI技术存在一定的技术短板，往往会因为规格越来越高，检出的缺陷越来越细微，从而产生大量误判，而当误判量变高，就需要有人工进行后续的拦检。这意味着，在这个过程中必然会产生额外的人力成本。对于这个问题，AI工业质检的方法可以很好地优化。</p><p></p><p>以半导体行业应用为例：我们知道，半导体制程非常复杂，在晶圆的制造测试过程中有超过40到60道的制造和检测过程，需要大量的AOI机台在产线上去做产品的质量把关。我们有一个客户遇到过这样一个问题，他们每天经过AOI检测出来的照片超过100万张，日班和夜班分别有50个人在做复判，人力成本非常高，并且因为是人在做判别，所以效率很低，这也造成产线上任何良率异常回馈速度都非常慢，从而导致更多的产品损失。</p><p></p><p>利用AI，我们可以把大量的AOI识别的照片通过AI去做模型训练，训练完成的这个模型可以下发到边缘进行推理，让后续所有AOI机台产生的NG图片都可以通过推理平台第一时间完成复判，另外少量还没有办法用AI复判的部分会由人跟机器去做协作进行一些补充标注，并且这些图片也会继续输入到模型中进行重新训练，进而进行持续地模型优化。</p><p></p><p>在这个案例中，我们通过AI方式帮企业节省了60%-80%的人工成本，并且因为复判精准度越来越高，速度越来越快，也使得企业产品良率得到了6%-8%的提升。</p><p></p><p>当然，除了半导体之外还有非常多的行业都可以使用AI去实现误判率降低。例如SMT行业也一样有在炉后进行AOI/AVI外观检测的需求，当发现元件异常、元件偏移等等，就需要非常多人员投入进行复判，这时候就可以使用AI技术去降低误判率，实现人工成本的降低。</p><p></p><p>工业智能监控</p><p></p><p>智能监控方面，这也是很多企业的痛点。过去，制造企业常常是通过人工查验去控管各个环节，比如在制造园区、车间内的人员是否都佩戴好安全帽、无尘鞋、防尘衣等等，是否存在安全遗患；比如，在关键岗位，工作人员是否按照动作标准和规范进行操作，包括生产过程中的节拍管制以及设备异常波动等等。而人工查验的方式，不但非常低效，而且没办法做到24小时主动管理。</p><p></p><p>这时候，通过AI智能监控技术，可以在园区既有的视频或者加装新的摄像头基础上，通过视频采集加上AI模型，对任何异常进行识别判断，并形成闭环的管理机制。比如安全的部分，可以识别人员的防护衣穿戴是否规范，在卸货过程中人员的位置是否安全，或者货梯有没有出现违规载人，甚至只是最简单的上下楼梯走路玩手机等行为，这些都可以通过AI技术形成24小时全天候、主动式的园区安全管理。</p><p></p><p>除此之外，我们也可以使用AI智能监控技术实现“防呆”。举例来说，在制造过程中，我们有个涂胶的设备，它的胶头会随着作业时间越来越大，以往这很难管理，只有它变大到连续性产生涂胶异常，在品质检测时候才能发现并介入管理。但现在，我们在旁边装了摄像头，可以24小时监控，只要一发现胶头，就可以跟设备去实时联动，让设备停下来，这就不会造成产品的品质异常。</p><p></p><p>当然，在制造过程中，我们还可以通过AI技术去管理人员的动作，或者装配过程中监控是否有缺件少件等等，从而进行品质监控。</p><p></p><h2>无代码平台是实现AI扩散和“全民AI”的重要抓手</h2><p></p><p></p><p>大家可以看到，如今AI应用越来越广泛，企业关心的不只是AI的某个应用导入，还包括如何更快速地扩散企业内的AI应用，甚至是实现“全民AI”的愿景。这个过程，需要企业投入非常多的资源支持，同时也充满各种阻碍和挑战，比如人才不足、成本高昂、模型训练速度缓慢，或者成效不明确等等。</p><p></p><p>但是，随着技术的迭代，AI技术的使用成本会越来越低，比如现在已经有很多的<a href=\"https://xie.infoq.cn/article/350cb793667b1139c6eb6c8dc\">无代码</a>\"AI平台可以助力企业快速完成人才的赋能和技术的落地。</p><p></p><p>比如，过去我们做AI数据分析的流程非常长，涉及数据预处理、特征工程、模型训练、模型评估以及非常多的代码工程，但现在，我们通过无代码平台，在整个过程中完全不需要使用到代码，只要点击几下就可以把AI的模型跑出来，从而完成数据分析的工作。</p><p></p><p>以某半导体龙头企业为例，他们通过无代码平台工具在3个月内赋能了内部70个员工，使其拥有了AI数据科学分析能力，借此，在新产品的良率上得到了0.5%的提升。在封测行业，良率已经非常高，因此0.5%是一个非常大的改善，同时，这也使得他们在整体成本控制上得到了很好的改善。</p><p></p><p>机器视觉应用也是相似的，通过这些无代码平台，企业只要把视频数据上传到平台上完成标注，一键就可以完成模型的训练，并且可以一键部署到边缘硬件，从而提升超过70%以上的开发效率。</p><p></p><p>今年第一季度，麦肯锡发布了《全球灯塔网络：续写工业4.0新篇章》，其中谈到，根据对全球超过100个灯塔工厂的观察，他们总结出这些企业之所以做得比较快、比较完善的最核心原因，就是他们参与人员非常多，有超过50%的员工都参与了数字化转型，超过30%企业的COE组织参与了数字化转型。</p><p></p><p>但是，在非灯塔工厂里面，这样的人才比例平均不到30%，一个企业要做数字化转型，其中最关键的就是数字化人才的培养，只有人才足够多，才能让数字化的扩张速度更快。就人工智能本身来说，我们可以使用无代码的工具让80%的关键员工都能在很短的时间内自主运用人工智能的技术。</p><p></p><p>最后再分享一个来自于麦肯锡的资料，相关数据显示，那些早期已经开始大量使用AI的企业，目前已经进入快速提升效益的阶段，在同行业中，这意味着这些企业的竞争力会快速被放大，反之，那些没有采取行动的企业可能就会存在竞争力的相对流失。</p><p></p><h4>嘉宾介绍</h4><p></p><p>赖骏凯，艾聚达总经理。大数据与人工智能专家，拥有超过18年的光电行业制造运营经验，作为友达昆山智能制造负责人，2016年开始参与友达光电数字化转型工作。目前担任友达工业服务全资子公司艾聚达总经理，同时也是省级两化融合特聘讲师，重庆邮电大学先进制造工程学院客座教授。</p>",
    "publish_time": "2023-07-18 10:37:22",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]