[
  {
    "title": "华为盘古大模型3.0发布：不开源，现阶段谈投入和收益为时尚早",
    "url": "https://www.infoq.cn/article/Ay9xCWPdOe5rVBlpeXf0",
    "summary": "<p>2023年7日-9日，<a href=\"https://developer.huaweicloud.com/HDC.Cloud2023.html\">华为开发者大会2023（Cloud）</a>\"期间，华为发布盘古大模型3.0。华为盘古大模型最早在<a href=\"https://www.infoq.cn/article/uA57iVqYczit1b1ODjBi\">2021年发布</a>\"，发展到今天，盘古大模型已经在金融、制造、医药研发、煤矿、铁路等诸多行业发挥作用。</p><p></p><p>华为云CTO张宇昕在接受 InfoQ 采访时表示，华为盘古大模型全栈技术均由华为自主创新，从算力到基础的算子、基础的框架到盘古的开发平台以及模型均没有采用任何开源技术。另外，由于华为云盘古大模型的定位是“AI&nbsp; for&nbsp; Industries”，这些行业大模型里沉淀了客户的知识经验，所以华为不会、也不可能把客户的资产开放出来，也就是说盘古大模型不会开源，而是走商业闭源的道路。</p><p></p><p>据华为常务董事、华为云 CEO 张平安介绍，盘古大模型3.0是面向行业的大模型系列，包括“5+N+X”三层架构：L0层是5个基础大模型，包括自然语言、视觉、多模态、预测、科学计算，提供满足行业场景中的多种技能需求。</p><p></p><p>盘古3.0为客户提供100亿参数、380亿参数、710参数和1000亿参数的系列化基础大模型，匹配客户不同场景、不同时延、不同响应速度的行业多样化需求。同时提供全新能力集，包括NLP大模型的知识问答、文案生成、代码生成，以及多模态大模型的图像生成、图像理解等能力，这些技能都可以供客户和伙伴企业直接调用。无论多大参数规模的大模型，盘古提供一致的能力集。</p><p></p><p>L1层是N个行业大模型，华为云既可以提供使用行业公开数据训练的行业通用大模型，包括政务，金融，制造，矿山，气象等大模型；也可以基于行业客户的自有数据，在盘古大模型的L0和L1层上，为客户训练自己的专有大模型。</p><p></p><p>L2层是为客户提供X个细化场景的模型，更加专注于政务热线、网点助手、先导药物筛选、传送带异物检测、台风路径预测等具体行业应用或特定业务场景，为客户提供“开箱即用”的模型服务。</p><p></p><p>盘古大模型采用完全的分层解耦设计，一方面是为了快速适配、快速满足行业的多变需求，背后更是华为希望借此构筑出良好的商业模式的考虑。</p><p></p><p>在解耦的三层设计之上，客户既可以为自己的大模型加载独立的数据集，也可以单独升级基础模型，可以单独升级能力集。在L0和L1大模型的基础上，华为云还为客户提供了大模型行业开发套件，通过对客户自有数据的二次训练，客户就可以拥有自己的专属行业大模型。同时，根据客户不同的数据安全与合规诉求，盘古大模型还提供了公用云、大模型云专区、混合云多样化的部署形态。</p><p></p><p>张平安强调，盘古大模型的路标图价值将更注重于行业应用的深化和扩展。团队已经在铁路、煤矿、金融和政府等行业开展了大模型的应用，并且还有许多行业需要大模型的支持。未来，团队将加快行业大模型的开发速度，并且在行业垂直领域深化应用。</p><p></p><p>算力是训练大模型的基础。本次大会上，张平安还宣布单集群2000P Flops算力的<a href=\"https://www.infoq.cn/article/ZKKj2QMlrYopHAcLyMSJ\">昇腾AI</a>\"云服务在华为云的乌兰察布和贵安AI算力中心同时上线。昇腾AI云服务除了支持华为全场景AI框架昇思MindSpore外，还支持Pytorch、Tensorflow等主流AI框架。</p><p></p><p>毫无疑问，大模型的投入是巨大的。不过张平安亦坦言，现阶段讨论盘古大模型的成本与收益还为时尚早，华为在贵阳和乌兰察布投入了大量昇腾AI算力，并相信把昇腾AI算力做好之后，中国的许多行业以及重塑将会采用盘古大模型。</p>",
    "publish_time": "2023-07-10 07:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "C++变化太大！该重新学习这门语言了",
    "url": "https://www.infoq.cn/article/glGY3r8TpkNUaKf39si2",
    "summary": "<p>C++是一门古老但不断演进的语言。你几乎可以使用它来做任何事情，而且可以在很多地方找到它的身影。实际上，C++的发明者Bjarne Stroustrup将其<a href=\"https://accu.org/journals/overload/29/161/stroustrup/\">描述为</a>\"一切事物的隐形基础。有时，它可以深入到另外一门语言的库中，因为C++可以用于性能关键的路径中。它可以在小型的嵌入式系统中运行，也可以为视频游戏提供动力。你的浏览器可能正在使用它。C++几乎无处不在！</p><p></p><h2>C++为何如此重要</h2><p></p><p></p><p>迄今为止，C++已经存在了很长的时间，但是其变化也是非常大的，尤其是2011年之后。当时，推出了一个名为C++11的新标准，标志着一个频繁更新的时代正式开启。如果你从C++11就没有使用过C++，那么你有很多东西需要补习，这要从哪里开始呢？</p><p></p><p>该语言是需要编译的，面向特定的架构，如PC、大型机、嵌入式设备、定制硬件，或者你想到的其他东西。如果你需要代码在不同类型的机器上运行，那需要重新编译它。这有缺点也有优点。不同的配置会带来更多的维护工作，但编译到特定架构能够让你“因地制宜（down to the metal）”，从而获得速度方面的优势。</p><p></p><p>不管你的目标是哪种平台，均需要一个编译器。你还需要一个编辑器或集成开发环境（IDE）来编写C++代码。<a href=\"https://isocpp.org/get-started\">ISOCpp</a>\"给出了一个资源清单，包括C++编译器。Gnu编译器集（Gnu compiler collection，gcc）、Clang和Visual Studio均有免费版本。你甚至可以使用<a href=\"https://godbolt.org/\">Matt Godbolt的编译器探索器</a>\"，在浏览器上尝试基于各种编译器的代码。编译器可能支持不同版本的C++，所以必须在编译器标记中说明你所需要的版本，例如g++的-std=c++23或Visual Studio的/std:c++latest。ISOCpp网站上有一个<a href=\"https://isocpp.org/wiki/faq\">FAQ区域</a>\"，概述了最近的一些变化，包括C++11和C++14，以及整体的概览。另外，还有多本关于C++最近版本的图书。</p><p></p><h2>使用Vector快速了解C++11</h2><p></p><p></p><p>如果你已经被落下了，那么大量的资源可能会让你不知所措。但是，我们可以通过一个小例子来理解一些基础知识。停下来，亲自动手试一试往往是最好的学习方法。因此，我们从简单基础的东西开始吧！</p><p></p><p>一个很有用（且简单）的起点是不太起眼的vector，它位于std命名空间的vector头文件中。CppReference提供了一个<a href=\"https://en.cppreference.com/w/cpp/container/vector\">概述</a>\"，告诉我们vector是一个序列容器，封装了动态大小的数组。因此，vector包含了一个连续的元素序列，我们可以根据需要调整vector的大小。vector本身是一个类模板，因此它需要一个类型，例如std::vector。我们可以使用push_back将一个条目添加到vector的尾部。C++11引入了一个名为emplace_back的新方法，该方法取值来构造一个新的条目。对于int，代码看上去是一样的：</p><p></p><p><code lang=\"cpp\">std::vector numbers;\nnumbers.push_back(1);\nnumbers.emplace_back(1);\n</code></p><p></p><p>如果我们有比int更复杂的东西，那么就可能在emplace版本中获得性能方面的收益，因为emplace版本可以就地构造条目，从而避免对其进行复制。</p><p></p><p>C++11引入了_r-value引用_和_移动语义（move semantics）_来避免不必要的复制。潜在的性能改善是C++11的驱动力之一，后续的版本都是在此基础上进行的。为了解释什么是r-value引用，我们可以考虑前面样例中的push_back方法。它有两个重载形式，其中一个会接受一个常量引用，即const T&amp;值，另外一个接受一个r-value引用，即T&amp;&amp;值。第二个版本会将元素移动到vector中，这可以避免复制临时对象。与之类似，emplace_back的签名通过r-value引用来获取参数，Args&amp;&amp;…，同样允许移动参数而无需复制。移动语义是一个很大的话题，我们只是接触到了它的皮毛。如果你想了解更多详情的话，Thomas Becker在2013年撰写了一篇很好的<a href=\"http://thbecker.net/articles/rvalue_references/section_01.html\">文章</a>\"，介绍了它的细节。</p><p></p><p>我们创建一个vector并在其中放置几个条目，然后使用来自iostream头文件的std::cout展示其内容。我们使用流插入操作符&lt;&lt;来显示这些元素。我们基于vector的size编写一个for循环，并使用操作符[]来访问每个元素：</p><p></p><p><code lang=\"cpp\">#include \n#include \n\nvoid warm_up()\n{\n    std::vector numbers;\n    numbers.push_back(1);\n    numbers.emplace_back(1);\n    for(int i=0; i<<=\"\" numbers[i]=\"\" '=\"\" ';=\"\" }=\"\" '\\n';=\"\" int=\"\" main()=\"\" warm_up();=\"\" <=\"\" code=\"\"></code></p><p></p><p><code lang=\"cpp\">该代码会显示两个1。这段代码可以在<a href=\"https://godbolt.org/z/YeGrvsbb5\">编译器探索器</a>\"上找到。</code></p><p></p><h2><code lang=\"cpp\">类模板参数推断</code></h2><p></p><p><code lang=\"cpp\">让我们做一些更有意思的事情，并学习一下现代的C++。我们构建几个数字三角，会发现它们之间存在一个模式。数字三角的值是1，3，6，10……它们分别由1，1+2，1+2+3，1+2+3+4，……相加而成。如果我们这些斯诺克球架起来，就可以组成一个三角形，它也因此得名：</code></p><p></p><p><code lang=\"cpp\"><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/relearning-cpp-11/en/resources/18figure-1-1683536195865.jpg\" /></code></p><p></p><p><code lang=\"cpp\">如果再增加一排，我们就会再增加六个斯诺克球。再加一排就会增加七个，以此类推。</code></p><p></p><p><code lang=\"cpp\">为了得到数字1，2，3等，我们可以构建一个充满1的vector，然后将这些数字相加。我们可以直接创建一个vector，比如18个1，而不必再增加另一个循环。我们说明想要多少个元素，然后再指明它的值：</code></p><p></p><p><code lang=\"cpp\"><code lang=\"cpp\">   std::vector numbers(18, 1);\n</code></code></p><p></p><p><code lang=\"cpp\">注意我们不需要再声明了。因为从C++17开始，_<a href=\"https://en.cppreference.com/w/cpp/language/class_template_argument_deduction\">类模板参数推断（CTAD）</a>\"就已经实现了。编译器可以推断出我们指的是int，因为我们要求的值是1，这是一个int。如果我们需要显示vector，那么可以使用_基于range的for循环。此时，我们不必使用基于vector索引的传统for循环，而是声明一个类型，甚至可以使用新的关键字auto，告诉编译器判断类型，然后是冒号和容器：</code></p><p></p><p><code lang=\"cpp\"><code lang=\"cpp\">   for (auto i : numbers)\n    {\n        std::cout &lt;&lt; i &lt;&lt; ' ';\n    }\n    std::cout &lt;&lt; '\\n';   \n</code></code></p><p></p><p><code lang=\"cpp\">CTAD和基于range的for循环是C++11以来引入的一些便利特性。</code></p><p></p><h2><code lang=\"cpp\">Range</code></h2><p></p><p><code lang=\"cpp\">有了由“1”组成的vector，我们就可以包含numeric头文件，并使用部分的和来填充一个新的vector，如1，1+1，1+1+1……，这样就有了1，2，3……我们需要声明新vector的类型，因为这里要从一个空的vector开始，如果没有任何值可供使用，那么编译器将无法推断其类型。partial_sum需要开头和结尾的数字，最后我们需要使用back_inserter，这样目标vector会根据需要增长：</code></p><p></p><p><code lang=\"cpp\"><code lang=\"cpp\">    #include \n…\n    std::vector numbers(18, 1);\n    std::vector sums;\n    std::partial_sum(numbers.begin(), numbers.end(),\n        std::back_inserter(sums));\n</code></code></p><p></p><p><code lang=\"cpp\">这样我们就得到了1到18的数字，均包含边界值。我们已经完成了数字三角的部分工作，但是C++现在可以让我们的代码更加简洁。C++11引入了iota函数，也位于numeric头文件中，它能够用不断增加的值填充一个容器：</code></p><p></p><p><code lang=\"cpp\"><code lang=\"cpp\">std::vector sums(18);\nstd::iota(sums.begin(), sums.end(), 1);\n</code></code></p><p></p><p><code lang=\"cpp\">实际上，C++23引入了一个range版本，它会为我们找到对应的begin和end：</code></p><p></p><p><code lang=\"cpp\"><code lang=\"cpp\">  std::ranges::iota(sums, 1);\n</code></code></p><p></p><p><code lang=\"cpp\">C++23还没有得到广泛的支持，所以可能需要等到你的编译器提供range版本。numeric和algorithm头文件中的很多算法都有两个版本，其中一个需要一对输入迭代器（即first and last），另一个则是range版本，只需要接受容器即可。ranges重载正在逐渐添加到标准C++中。ranges提供的功能远远超过我们这里避免声明两个迭代器的场景。我们可以过滤和转换输出，将这些东西连接在一起，并使用视图来避免复制数据。ranges支持惰性计算，所以视图的内容会在需要的时候才评估计算出来。Ivan Čukić的<a href=\"https://www.manning.com/books/functional-programming-in-c-plus-plus\">Functional Programming in C++</a>\"一书在这方面提供了更多的细节（书中还包含更多的内容）。</code></p><p></p><p><code lang=\"cpp\">我们需要做的最后一件事就是形成数字三角。查看vector的部分和：</code></p><p></p><p><code lang=\"cpp\"><code lang=\"cpp\">   std::partial_sum(sums.begin(), sums.end(), sums.begin());\n</code></code></p><p></p><p><code lang=\"cpp\">我们已经得到了想要的数字三角，即1，3，6，10，15……171。</code></p><p></p><p><code lang=\"cpp\">我们注意到，有些算法有ranges版本，那我们可以尝试一个。前两个三角数字是1和3是奇数，然后是两个偶数6和10。这个模式是不是可持续的呢？如果我们对vector进行转换，用点号“.”来标记奇数，用星号“*”来标记偶数，就能看出最终结果。我们可以声明一个新的vector来存放转换结果。对于每个数字，仅需要一个字符，所以我们需要一个char类型的vector：</code></p><p></p><p><code lang=\"cpp\"><code lang=\"cpp\">std::vector odd_or_even.\n</code></code></p><p></p><p><code lang=\"cpp\">我们可以编写一个简短的函数，它会获取一个int并返回对应的字符：</code></p><p></p><p><code lang=\"cpp\"><code lang=\"cpp\">char flag_odd_or_even(int i)\n{\n    return i % 2 ? '.' : '*';\n}\n</code></code></p><p></p><p><code lang=\"cpp\">如果i % 2的值不为零，这就是一个奇数，所以我们返回.，否则，返回*。我们可以在来自algorithm头文件的transform函数中使用这个自己的函数。最初的版本需要一对输入迭代器（first和last）、一个输出迭代器和一个_一元函数（unary function）_，该函数会接受一个输入，就像我们的flag_odd_or_even函数这样。C++20引入了一个ranges版本，它能够接受一个输入源，而不是一对迭代器，另外还需要一个输出迭代器和一元函数。这意味着我们可以通过如下方式来转换先前生成的和：</code></p><p></p><p><code lang=\"cpp\"><code lang=\"cpp\">   std::vector odd_or_even;\n    std::ranges::transform(sums,\n        std::back_inserter(odd_or_even),\n        flag_odd_or_even);\n</code></code></p><p></p><p><code lang=\"cpp\">输出将会如下所示：</code></p><p></p><p><code lang=\"cpp\"><code lang=\"cpp\">. . * * . . * * . . * * . . * * . .\n</code></code></p><p></p><p><code lang=\"cpp\">看上去，我们确实是不断地得到两个奇数，然后是两个偶数。Stack Exchange的数学网站<a href=\"https://math.stackexchange.com/questions/4511290/parity-pattern-of-triangle-numbers\">阐述了出现这种现象的原因</a>\"。</code></p><p></p><h2><code lang=\"cpp\">Lambdas</code></h2><p></p><p><code lang=\"cpp\">我们使用另一个新的C++特性对我们的代码做最后的改进。如果我们想要看一下实际的转换代码的话，那需要要转移到另外一个地方才能看到这个一元函数都做了些什么。</code></p><p></p><p><code lang=\"cpp\">C++11引入了匿名函数或<a href=\"https://en.cppreference.com/w/cpp/language/lambda\">lambda表达式</a>\"的特性。它们看起来与有名称的函数类似，将参数放在括号中，将函数主体放到花括号中，但是它们没有名字，不需要返回类型，并且有一个用[]表示的捕获组：</code></p><p></p><p><code lang=\"cpp\"><code lang=\"cpp\">[](int i) { return i%2? '.':'*'; }\n</code></code></p><p></p><p><code lang=\"cpp\">如果与有名称的函数进行对比，会看到两者的相似性：</code></p><p></p><p><code lang=\"cpp\"><code lang=\"cpp\">char flag_odd_or_even(int i){ return i % 2 ? '.' : '*'; }\n</code></code></p><p></p><p><code lang=\"cpp\">我们可以在捕获组中声明变量，这会给我们一个_闭包_。这些内容超出了本文的范围，但是在函数式编程中它们是非常强大和常见的。</code></p><p></p><p><code lang=\"cpp\">如果我们将一个lambda分配给一个变量，</code></p><p></p><p><code lang=\"cpp\"><code lang=\"cpp\">auto lambda = [](int i) { return i % 2 ? '.' : '*'; };\n</code></code></p><p></p><p><code lang=\"cpp\">那么，我们就可以像调用有名称的函数那样调用它：</code></p><p></p><p><code lang=\"cpp\"><code lang=\"cpp\">lambda(7);\n</code></code></p><p></p><p><code lang=\"cpp\">这个特性允许我们使用lambda重写转换调用：</code></p><p></p><p><code lang=\"cpp\"><code lang=\"cpp\">    std::ranges::transform(sums,\n        std::back_inserter(odd_or_even),\n        [](int i) { return i%2? '.':'*'; });\n</code></code></p><p></p><p><code lang=\"cpp\">这样的话，我们就可以在一个地方看到转换函数，而不必再去查看其他的地方了。</code></p><p></p><h2><code lang=\"cpp\">总结</code></h2><p></p><p><code lang=\"cpp\">将所有的内容组合在一起，就形成了如下的代码：</code></p><p></p><p><code lang=\"cpp\"><code lang=\"cpp\">#include \n#include \n#include \n#include \n\nint main()\n{\n    std::vector sums(18);\n    std::iota(sums.begin(), sums.end(), 1);\n    std::partial_sum(sums.begin(), sums.end(), sums.begin());\n\n    std::vector odd_or_even;\n    std::ranges::transform(sums,\n        std::back_inserter(odd_or_even),\n        [](int i) { return i%2? '.':'*'; });\n\n    for (auto c : odd_or_even)\n    {\n        std::cout &lt;&lt; c &lt;&lt; ' ';\n    }\n    std::cout &lt;&lt; '\\n';\n}\n</code></code></p><p></p><p><code lang=\"cpp\">我们使用了ranges、lambda和基于range的for循环，浏览了移动语义，并练习了对vector的使用。对于首次重回C++的人来说，这是一个不错的起点！</code></p><p></p><p><code lang=\"cpp\">你可以在编译器探索器中<a href=\"https://godbolt.org/z/xbWs9vjvs\">尝试上述的代码</a>\"。</code></p><p></p><p><code lang=\"cpp\">作者简介：</code></p><p><code lang=\"cpp\">Frances Buontempo有多年的C++经验，还有过使用Python和其他各种语言的经验。她曾发表过关于C++的演讲，并且是ACCU的Overload杂志的编辑。她有数学背景，为PragProg写了一本关于遗传算法和机器学习的书，并且正在为Manning写一本名为C++ Bookcamp的C++书，以帮助那些被现代C++落下的人迎头赶上。</code></p><p></p><p><code lang=\"cpp\">原文链接：</code></p><p><code lang=\"cpp\"><a href=\"https://www.infoq.com/articles/relearning-cpp-11/\">Relearning C++ After C++11</a>\"</code></p>",
    "publish_time": "2023-07-10 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "阿里转岗先离职：清空司龄裁员不给钱？大模型“国家队”亮相，6家公司名单公布；我国第一个独立开源操作系统正式发布｜Q资讯",
    "url": "https://www.infoq.cn/article/1gfWbQ9EdahUF8ZVUCuE",
    "summary": "<p></p><h4>蚂蚁集团回应被罚71.23亿元</h4><p></p><p>&nbsp;</p><p>证监会消息，近期，针对蚂蚁集团及旗下机构过往年度在公司治理、金融消费者保护、参与银行保险机构业务活动、从事支付结算业务、履行反洗钱义务和开展基金销售业务等方面存在的违法违规行为，金融管理部门依据《中国人民银行法》《反洗钱法》《银行业监督管理法》《保险法》《证券投资基金法》《消费者权益保护法》等，对蚂蚁集团及旗下机构处以罚款（含没收违法所得）71.23亿元。要求蚂蚁集团关停违规开展的“相互宝”业务，并依法补偿消费者利益。</p><p>&nbsp;</p><p>对此，蚂蚁集团回应称，“2020年以来，蚂蚁集团在金融管理部门指导下积极推进各项整改，目前已完成相关整改事项。今天，蚂蚁集团收到金融管理部门行政处罚决定书，我们对此诚恳接受、坚决服从，并将进一步夯实合规治理水平。”</p><p>&nbsp;</p><p></p><h4>GPT-4 API 全面开放使用</h4><p></p><p>&nbsp;</p><p>7 月 7 日，OpenAI 在官网宣布 GPT-4 API 全面开放使用。现所有付费 API 用户都可直接访问 8K 上下文的 GPT-4，无需任何等待。预计到 7 月底之前，OpenAI 会向全新的开发人员开放 GPT-4 API 使用权限。此外，OpenAI 还推出了 GPT-3.5 Turbo、DALL·E 和 Whisper API。</p><p>&nbsp;</p><p>API 详细使用说明地址：<a href=\"https://platform.openai.com/docs/guides/gpt\">https://platform.openai.com/docs/guides/gpt</a>\"</p><p>&nbsp;</p><p></p><h4>字节要造机器人，团队计划扩充到上百人</h4><p></p><p>&nbsp;</p><p>据了解，字节机器人团队已有约 50 人，计划年底扩充到上百人，并生产一些服务字节自己的电商履约需求，能在仓库里分拣、打包货物的机器人。字节机器人团队目前隶属于字节 AI Lab，其负责人是 AI Lab 总监李航。李航曾担任华为诺亚方舟实验室主任和首席科学家，2017 年加入字节，现在向字节副总裁、算法技术负责人杨震原汇报。</p><p>&nbsp;</p><p>据此前报道，字节跳动近年来已多次出手投资机器人相关公司，包括未来机器人、大寰机器人等，主要还是工业智能制造相关领域，与今日爆料的消息较为吻合。爆料还称，字节跳动对于人形机器人持观望态度，认为“像波士顿动力这种做了 30 年还不盈利的行为，可能不适合字节”。&nbsp;</p><p></p><h4>大模型“国家队”亮相，6家公司名单公布</h4><p></p><p>&nbsp;</p><p>2023世界人工智能大会期间，国家人工智能标准化总体组宣布我国首个大模型标准化专题组组长单位名单。据悉，我国大模型标准化专题组组长单位为上海人工智能创新中心。</p><p>&nbsp;</p><p>另外，北京百度网讯科技有限公司、阿里云智能集团、科大讯飞股份有限公司、三六零安全科技股份有限公司、华为云计算技术有限公司、中国移动通信有限公司研究院六家企业担任联合组长单位。现场进行了证书颁发并启动大模型测试国家标准制订。</p><p></p><h4>微软 Edge 浏览器用户数量正逼近 3 亿</h4><p></p><p>&nbsp;</p><p>根据 Atlas 公布的数据，<a href=\"https://www.infoq.cn/article/DRwEE6dPCooXz85r8jYS\">微软 Edge</a>\" 浏览器在整合必应聊天（Bing Chat）之后，用户规模快速增长了 5000 万，目前正逼近 3 亿大关。</p><p>&nbsp;</p><p>根据计算数据，谷歌 Chrome 浏览器拥有将近 34 亿用户；Safari 浏览器拥有 11 亿用户；微软 Edge 浏览器拥有 2.85 亿用户，逼近 3 亿。</p><p>&nbsp;</p><p></p><h4>扎克伯格发布 Threads“肉搏”马斯克：16小时3000万注册用户</h4><p></p><p>&nbsp;</p><p>美国时间7月5日，原计划在6日正式上线的 <a href=\"https://www.infoq.cn/article/WAb5hXYcthvYjYqVMyxN\">Threads</a>\" 意外提前发布，这是 Meta 旗下一款对标推特的应用 App，发布后，Threads 以风卷残云之势迅速笼络第一波用户，一些原先在推特上粉丝人数最多的名人，例如比尔盖茨、夏奇拉等人，都第一时间开设了 Threads 账号。</p><p>&nbsp;</p><p>Meta 创始人扎克伯格更是斗志满满，其本人的 Threads 账号一度成为了 Threads 实时“战绩”播报中心：“一小时突破500万”，“今天早上突破3000万”……据悉，发布不到24小时内，Threads 已经蹿升至美国苹果应用商店免费应用下载量榜首。</p><p>&nbsp;</p><p></p><h4>马斯克奇葩新规激怒用户！网友气炸狂喷，推特大宕机</h4><p></p><p>&nbsp;</p><p>近期，马斯克宣布推特新规：不登录不给看，被激怒的网友直接将推特搞宕机。随后马斯克表示：未经验证的用户只能浏览 600 个帖子。广大用户直接被气炸，推特“平替” Mastodon 一天新增账户超过 26000 个。马斯克阴阳怪气地表示：讽刺的是，因为抱怨浏览限制而导致了浏览限制。</p><p>&nbsp;</p><p>Twitter 搜索可见度24 小时下降 32%，“我们正在实时目睹，世界上有史以来最大的SEO上的自戕式毁灭。”推特网友表示。马斯克将这一切归咎于AI公司白嫖数据。实际上，有网友认为这是马斯克接手推特后，想方设法赚钱的途径之一。据悉，马斯克最近也被爆出患上抑郁症，正在服用药物做抵抗。</p><p>&nbsp;</p><p></p><h4>阿里转岗需先离职再入职，清空司龄裁员不给钱？</h4><p></p><p>&nbsp;</p><p>据报道，阿里计划将把绩效考核周期从半年改为季度，绩效奖金也将按季度发放，晋升、转岗等规则也将调整。另一项重大改变体现在内部转岗制度。以往阿里员工可以在集团各事业群自由转岗，新制度实施之后，员工要转岗至其他事业群，需要先离职再入职，以往司龄将清空。</p><p>&nbsp;</p><p>有员工透露，随着事业群拆分，一些变革已经在悄悄发生：新员工不再需要去杭州阿里总部参加为期两周的百阿（百年阿里）培训。此外，多名阿里员工表示，最近工作压力迅速增加，“996 又回来了”。</p><p>&nbsp;</p><p></p><h4>微软云 Azure 营收规模曝光，不及亚马逊 AWS 的一半</h4><p></p><p>&nbsp;</p><p>一份法庭文件显示，微软首席执行官 Satya Nadella 告诉公司董事会，在截至去年6月的12个月里，Azure 的云服务业务将产生340亿美元的收入，该数字不及竞争对手亚马逊云科技同期 720 亿美元营收规模的一半。这些文件后来从法院网站上删除了。</p><p>&nbsp;</p><p>多年来，微软一直对其 Azure 云业务部门的真实规模严加保密，使投资者无法了解它的实力到底如何。这一消息可能会让一些投资者感到震惊，因为这意味着 Azure 在云计算业务中的市场份额比大多数分析公司估计的要小几个百分点。</p><p>&nbsp;</p><p></p><h4>苹果公众号文章被批毁三观</h4><p></p><p>&nbsp;</p><p>日前，苹果官方公众号“Apple”发布了一篇“用 Mac 的斜杠青年，杠上开了什么花”的文章，其中部分文案被网友吐槽毁三观。文案提到，“一咬牙，卖掉有好感的男生送的演唱会门票，用这笔启动资金下了500份贴纸、胶带订单，自留一份，其余开网店售卖”。</p><p>&nbsp;</p><p>正是这句文案引来众多网友吐槽，称“这个真的有点三观不正了”“苹果这个文案也太败好感了吧&nbsp;”“苹果这文案要是性别一换”“寓意深刻啊”等等。苹果客服回应称，此事已登记记录，会向相关部门反馈。</p><p>&nbsp;</p><p></p><h4>ChatGPT&nbsp;暂停测试 Browse with Bing 功能</h4><p></p><p>&nbsp;</p><p>OpenAI 近日暂停了 ChatGPT 的 Browse with Bing 功能测试。该功能测试暂停的原因是因为借助 Browse with Bing 功能，用户可以绕过某些网站的付费机制，让用户免费阅读付费内容。Browse with Bing 功能是 OpenAI 为&nbsp;ChatGPT 付费用户提供的一个功能，他允许 ChatGPT 付费用户通过 Bing 搜索引擎来获取信息。</p><p>&nbsp;</p><p></p><h4>美国考虑限制中国用户使用美国云计算服务</h4><p></p><p>&nbsp;</p><p>WSJ 援引知情人士的消息报道，美国政府正准备限制中国企业使用美国云计算服务。这项新规如果被采纳，可能会要求亚马逊、微软等美国云服务提供商在向中国客户提供使用先进制程 AI 芯片的云计算服务之前，必须先获得美国政府许可。</p><p>&nbsp;</p><p>这项拟议的限制措施被认为是要堵上一个重大漏洞。中国的 AI 公司可能通过使用云服务绕开了现行的出口管制规定，比如使用英伟达的 A100 芯片。美国商务部预计将在未来几周内公布这一行动。</p><p>&nbsp;</p><p></p><h4>我国第一个独立开源操作系统正式发布</h4><p></p><p>&nbsp;</p><p>据报道，我国首个开源桌面操作系统“开放麒麟1.0”正式发布，标志着我国拥有了操作系统组件自主选型、操作系统独立构建的能力，填补了我国在这一领域的空白。</p><p>&nbsp;</p><p>据了解，包括“开放麒麟”在内的麒麟系列操作系统可以在电脑或手机等硬件产品上运行，目前已经应用在金融、海关、能源等众多行业中，除此之外，麒麟系列操作系统还保障了我国嫦娥探月、天问探火等重大航天工程的顺利实施。据机构测算，2025年中国操作系统市场规模高达586亿元。</p><p></p>",
    "publish_time": "2023-07-10 10:14:21",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]