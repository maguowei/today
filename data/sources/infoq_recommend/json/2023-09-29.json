[
  {
    "title": "处理Java CVE：发现、检测、分析和解决",
    "url": "https://www.infoq.cn/article/KeENUbFvYPbptAb86jAX",
    "summary": "<p>现代 Java 应用程序是建立在无数开源库之上的。这些库封装了常见的重复代码，使应用程序员能够专注于提供客户价值。但使用这些库也有代价——安全漏洞。流行库中的安全问题可以让恶意者以低廉的代价攻击广泛的目标。</p><p>&nbsp;</p><p>因此，在持续集成流水线中进行依赖漏洞检查(即软件组合分析或<a href=\"https://en.wikipedia.org/wiki/Software_composition_analysis\">SCA</a>\")至关重要。不幸的是，安全世界并不是非黑即白；一个漏洞在某个应用程序中可能是无害的，在另一个应用程序中却是一个关键问题，因此扫描始终需要人工监督，以确定报告是否误报。</p><p>&nbsp;</p><p>本文将探讨在过去几年中标准 Spring Boot 项目中常见的漏洞示例。本文是从软件工程师的角度编写的。重点将转向在使用广泛可用的工具，如 <a href=\"https://owasp.org/www-project-dependency-check/\">OWASP 依赖项检查</a>\" 时工程师所面临的挑战。</p><p>&nbsp;</p><p>由于软件工程师致力于提供产品价值，他们会将安全视为他们的诸多责任之一。尽管安全很重要，但由于其他任务的复杂性，安全反而有时会妨碍工作导致被忽视。</p><p></p><h2>解决漏洞的生命周期</h2><p></p><p></p><p>典型的漏洞生命周期如下。</p><p></p><h3>发现</h3><p></p><p></p><p>安全研究员通常会发现漏洞。然后漏洞会被报告给受影响的开源软件项目，并通过一系列非营利组织最终进入 NIST 国家漏洞数据库（NVD）。例如，<a href=\"https://nvd.nist.gov/vuln/detail/cve-2022-22965\">Spring4Shell</a>\" 漏洞就是通过这种方式记录的。</p><p></p><h3>检测</h3><p></p><p></p><p>当报告一个漏洞时，需要检测应用程序是否包含有漏洞的依赖项。幸运的是，我们有大量的工具可用于协助检测。</p><p>&nbsp;</p><p>其中一个流行的解决方案是使用 OWASP 依赖项检查 - 它可以作为 <a href=\"http://jeremylong.github.io/DependencyCheck/dependency-check-gradle/index.html\">Gradle</a>\" 或 <a href=\"http://jeremylong.github.io/DependencyCheck/dependency-check-maven/index.html\">Maven</a>\" 插件使用。当执行时，它会将你应用程序的所有依赖项与 NIST NVD 数据库和 <a href=\"https://ossindex.sonatype.org/\">Sonatype OSS index</a>\" 进行比较。它允许你阻止警告并生成报告，并且很容易集成到持续集成流水线中。主要缺点是它有时会误报，因为 NIST NVD 数据库没有用理想的格式提供数据。此外，第一次运行需要很长时间，因为它会下载整个漏洞数据库。</p><p>&nbsp;</p><p>我们还有各种免费和商业的工具可以使用，例如 <a href=\"https://docs.github.com/en/code-security/dependabot/dependabot-alerts/about-dependabot-alerts\">GitHub Dependabot</a>\"、<a href=\"https://checkmarx.com/cxsca-open-source-scanning/\">Checkmarx</a>\" 和 <a href=\"https://snyk.io/series/open-source-security/software-composition-analysis-sca/\">Snyk</a>\"。一般来说，这些工具的功能类似，扫描所有依赖项并将其与已知漏洞的数据库进行比较。商业提供商通常投资维护更准确的数据库。因此，商业工具可能会提供更少的误报甚至负面的结果。</p><p></p><h3>分析</h3><p></p><p></p><p>在检测到漏洞后，开发者必须进行分析以确定其影响。正如下面的示例所示，这通常是最具挑战性的部分。进行分析的人必须理解漏洞报告、应用程序代码和部署环境，以确定漏洞是否可以被充分利用。通常，这项任务由应用程序员来完成，因为他们是唯一具备所有必要上下文的人。</p><p></p><h3>解决方案</h3><p></p><p></p><p>必须解决这个漏洞。</p><p>理想情况下，可以通过升级有漏洞的依赖项到修复版本来解决问题。如果尚未发布修复程序，应用开发程序员可以采用某种临时办法，例如更改配置、过滤输入等。很多情况下，漏洞报告都是误报。通常情况下，在给定的环境中无法利用该漏洞。在这种情况下，必须阻止这样的报告，以防止我们习惯性地产生失败的漏洞报告。</p><p>&nbsp;</p><p>一旦分析完成，解决方案通常是直截了当的，但如果有数十个服务需要修补，就会耗费相当的时间。因此，尽可能简化解决方案的过程就非常重要。由于这通常是繁琐的手动工作，建议尽可能自动化。像 <a href=\"https://github.com/dependabot\">Dependabot</a>\" 或 <a href=\"https://github.com/renovatebot/renovate\">Renovate</a>\" 这样的工具在这方面可以一定程度上提供帮助。</p><p></p><h2>漏洞示例</h2><p></p><p></p><p>让我们来看一些漏洞示例以及在解决它们时可能遇到的问题。</p><p></p><h3>Spring4Shell（CVE-2022-22965，评分9.8）</h3><p></p><p></p><p>让我们从一个严重的漏洞开始 - <a href=\"https://spring.io/security/cve-2022-22965\">Spring Framework RCE 通过 JDK 9+ 上的数据绑定</a>\"，也称为 Spring4Shell，它允许攻击者通过调用 HTTP 端点远程执行代码。</p><p>&nbsp;</p><p>检测</p><p></p><p>这个漏洞很容易被检测到。Spring 是一个相当知名的框架；这个漏洞存在于大多数版本中，并且在互联网上讨论得很多。自然而然，所有的检测工具都能检测到它。</p><p>&nbsp;</p><p>分析</p><p></p><p>在漏洞的 <a href=\"https://spring.io/blog/2022/03/31/spring-framework-rce-early-announcement\">早期公告</a>\" 中，它指出只有使用 Spring WebMvc/Webflux 部署为 Servlet 容器中的 WAR 的应用程序才会受到影响。理论上，使用嵌入式 Servlet 容器进行部署应该是安全的。不幸的是，公告缺乏漏洞的详细信息，这导致很难确认事实是否的确如此。然而，这个漏洞非常严重，应该尽快采取措施予以缓解。</p><p>&nbsp;</p><p>解决方案</p><p></p><p>修复方法是在几个小时内发布的，所以最好的方法是等待修复和升级。像 Dependabot 或 Renovate 这样的工具可以帮助你在所有服务中完成此操作。</p><p>&nbsp;</p><p>如果有意愿更早解决漏洞，可以使用这个<a href=\"https://spring.io/blog/2022/03/31/spring-framework-rce-early-announcement#disallowed-fields\">临时方法</a>\"。但这意味着应用一个不清楚其作用的晦涩的配置。手动在所有服务上应用它，或者只是等待修复，这样的决定意味着很有挑战性。</p><p></p><h3>HttpInvoker RCE（CVE-2016-1000027，评分9.8）</h3><p></p><p></p><p>让我们继续关注一下 Spring。这个 <a href=\"https://nvd.nist.gov/vuln/detail/cve-2016-1000027\">漏洞</a>\" 与 Spring4Shell 9.8 具有相同的严重性。但是人们可能会注意到这是 2016 年的事情，并想知道为什么它还没有被修复，或者为什么它没有一个花哨的名字。原因在于，它位于 HttpInvoker 组件中，该组件用于 RPC 通信样式。它在 2000 年左右很受欢迎，但现在已经很少使用了。更令人困惑的是，这个漏洞在 2020 年出于一些管理上的原因才被公布，这已经是在最初报告的四年后的事情了。</p><p>&nbsp;</p><p>检测</p><p></p><p>这个问题是由 OWASP 依赖检查和其他工具报告的。由于它并没有影响很多人，所以没有成为头条新闻。</p><p>&nbsp;</p><p>分析</p><p></p><p><a href=\"https://nvd.nist.gov/vuln/detail/cve-2016-1000027\">NIST CVE 详细信息</a>\"并未透露太多信息：</p><p></p><blockquote>如果用于Java 反序列化未经信任的数据，Pivotal Spring Framework 5.3.16存在潜在的远程代码执行（RCE）问题。根据库在产品中的实现方式，此问题可能会也可能不会发生，并且可能需要进行身份验证。</blockquote><p></p><p></p><p>这听起来非常严重，需要立即关注并通过链接搜索更多<a href=\"https://www.tenable.com/security/research/tra-2016-20\">详细信息</a>\"。然而，这个问题只在使用HttpInvokerServiceExporter时才会出现，所以实际上只是一个误报。</p><p>&nbsp;</p><p>解决方案</p><p></p><p>由于 Pivotal 认为这并不是一个错误，因此没有发布修复版本的库。它是过时代码的一个特性，本应仅用于内部通信。几年后，整个功能在 Spring 6 中被完全删除。</p><p>&nbsp;</p><p>唯一需要采取的行动是阻止该警告。可以使用免费的 OWASP 依赖检查工具，但如果需要为每个服务手动执行此操作，这个过程可能非常耗时。</p><p>&nbsp;</p><p>有几种简化流程的方法。其中一种方法是通过指定 URL，在所有项目中公开使用一个共享的<a href=\"https://jeremylong.github.io/DependencyCheck/general/suppression.html\">抑制文件</a>\"。最后，你可以使用像 <a href=\"https://www.dependencyshield.com/\">Dependency Shield</a>\" 这样的简单服务来简化整个抑制流程。重要的是，需要一个流程来简化抑制操作，因为大多数报告很可能是误报。</p><p>&nbsp;</p><p></p><h3>SnakeYAML RCE（CVE-2022-1471，评分9.8）</h3><p></p><p></p><p>又出现了一个<a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-1471\">重大漏洞</a>\"，这次是在SnakeYAML解析库中。再次涉及远程代码执行，评分为9.8。但是，它只适用于使用SnakeYAML的Constructor类来解析攻击者提供的YAML的情况。</p><p>&nbsp;</p><p>检测</p><p></p><p>这是通过漏洞扫描工具检测出来的。SnakeYAML被Spring用于解析YAML配置文件，所以它非常常见。</p><p>&nbsp;</p><p>分析</p><p></p><p>应用程序是否正在解析可能由攻击者提供的YAML，例如在REST API上？是否使用了不安全的Constructor类？如果是这样，你的系统恐怕就存在漏洞。如果仅用于解析Spring配置文件，系统就是<a href=\"https://bitbucket.org/snakeyaml/snakeyaml/wiki/CVE-2022-1471\">安全的</a>\"。必须由了解代码及其用法的人来做出决策。情况可能很关键，需要立即关注和纠正，也可能是安全的，因此可以忽略它。</p><p>&nbsp;</p><p>解决方案</p><p></p><p>问题很快得到解决。让问题变得棘手的是SnakeYAML不是直接的依赖项；它是通过Spring间接引入的，这使得升级变得异常困难。如果你想升级SnakeYAML，可以采用以下几种方法。</p><p>如果使用了Spring Boot的依赖管理插件和Spring Boot BOM，a. 可以覆盖snakeyaml.version变量。b. 可以覆盖依赖管理<a href=\"https://docs.spring.io/dependency-management-plugin/docs/current/reference/html/#dependency-management-configuration-dsl\">声明</a>\"。如果没有使用依赖管理，必须添加SnakeYAML为项目的直接依赖项，并覆盖版本。</p><p>&nbsp;</p><p>当与复杂的多项目构建结合使用时，工具几乎无法自动升级版本。Dependabot和Renovate都无法做到这一点。即使是像Snyk这样的商业工具也无法成功升级，因为\"无法升级，依赖项是在外部进行管理的\"。</p><p>&nbsp;</p><p>当然，一旦版本被覆盖，重要的是记得在Spring中更新版本后，删除覆盖。在我们的情况中，最好在新版本使用在Spring之前，暂时抑制警告。</p><p></p><h2>误判的Avro漏洞</h2><p></p><p></p><p>漏洞 <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-43045\">CVE-2021-43045</a>\" 是Avro库的.NET版本中的一个错误，因此不太可能影响Java项目。那么，为什么会被报告呢？不幸的是，<a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-43045#vulnConfigurationsArea\">NIST报告</a>\"包含cpe:2.3:a:apache:avro:*:*:*:*:*:*:*:*标识符。难怪工具错误地将org.apache.avro/avro@1.9.0识别为漏洞，尽管它来自完全不同的生态系统。</p><p>&nbsp;</p><p>解决方案: 抑制</p><p></p><h2>总结</h2><p></p><p></p><p>让我们回顾一下解决漏洞的不同阶段，以及如何尽可能简化它，这样报告才不会阻碍工程师过长时间。</p><p>&nbsp;</p><p>检测</p><p></p><p>检测的最重要部分是避免习惯失败的依赖检查。理想情况下，如果检测到存在漏洞依赖项，构建应该失败。为了实现这一点，解决方案需要尽可能简单快速。没有人希望由于误报而遇到破坏的流水线。</p><p>&nbsp;</p><p>由于OWASP依赖性检查主要使用NIST NVD数据库，它有时会出现误报的情况。然而，正如我们所观察到的，误报是不可避免的，因为分析并不总是直接明了的。</p><p>&nbsp;</p><p>分析</p><p></p><p>这是一个困难的部分，实际上，在这个部分，工具无法提供太多帮助。以SnakeYAML远程代码执行漏洞为例。要使其有效，必须非安全地使用库，例如解析来自攻击者的数据。遗憾的是，没有工具能够可靠地检测出一个应用程序及其所有库中是否包含有漏洞的代码。因此，这部分总是需要一些人工的干预。</p><p>&nbsp;</p><p>解决方案</p><p></p><p>对于直接依赖项，将库升级到修复版本相对要简单。像Dependabot和Renovate这样的工具可以帮助完成这个过程。然而，如果有漏洞的依赖项是通过传递依赖或依赖管理引入的，这些工具就会失败。手动覆盖依赖项可能是单个项目可接受的解决方案。对于维护多个服务的情况，我们应该引入集中管理的依赖管理，来简化这个过程。</p><p>&nbsp;</p><p>大多数报告都是误报，因此有一种简单的方法来抑制警告非常重要。在使用OWASP依赖检查时，可以尝试使用<a href=\"https://jeremylong.github.io/DependencyCheck/general/suppression.html\">共享的抑制文件</a>\"，或者像Dependency Shield这样的工具来帮助完成这个任务。</p><p>&nbsp;</p><p>通常情况下，暂时抑制报告是有意义的。可以暂时解除流水线阻塞，直到有人有时间仔细分析报告，或者直到引入该依赖项的项目更新了传递依赖项。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/dealing-with-java-cves/\">https://www.infoq.com/articles/dealing-with-java-cves/</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/QB87kOkWjf6jXxODkd9T\">Java 21：最新进展一览</a>\"</p><p><a href=\"https://www.infoq.cn/article/wti8XjbwvZdWSr79kOc6\">Java 近期新闻：单查询加载、GraalVM、GlassFish、JReleaser、Quarkus、Micronaut</a>\"</p>",
    "publish_time": "2023-09-29 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Node.js 2023 版本发布：加速 JavaScript 开发",
    "url": "https://www.infoq.cn/article/pcy0BDHgmVWzmrTWIHqV",
    "summary": "<p>Node.js 团队近期发布了 <a href=\"https://github.com/nodejs/node/releases/tag/v20.6.0\">20.6.0 版本</a>\"，对环境变量配置、模块解析、模块自定义进行提升，同样还有对 C++ 垃圾回收的实验性支持。</p><p>&nbsp;</p><p>本次更新中为开发人员新增了对 .env文件的内置支持功能.这类文件采用 INI 文件格式，提供对环境变量的简单配置方法。开发者可通过命令行指令 node --env-file=config.env index.js，轻松执行应用的预设初始化。这项更新简化了环境变量的管理。</p><p>&nbsp;</p><p>另一项值得关注的变化涉及未标记的 import.meta.resolve(specifier) 函数。这项调整在使 Node.js 与其他服务器端运行时及浏览器保持一致方面，发挥了至关重要的作用。这一函数为模块解析提供了绝对 URL 字符串，增强了跨平台的兼容性，简化了不同环境下的模块管理。</p><p>&nbsp;</p><p>Node.js 20.6.0 也在 node:module命名空间中引入了新 API register。该 API 简化了模块自定义钩子，允许开发人员指定钩子的导出文件，促进主应用程序线程与钩子线程之间的通信渠道。鼓励开发人员能过渡到使用 --import和 register，从而更为高效地完成钩子的注册。</p><p>&nbsp;</p><p>Node.js 20.6.0 还增强了模块自定义钩子加载，允许其管理 ES 模块和 CommonJS 源。这部分新增加的灵活性简化了加载和自定义 Node.js 模块的过程，消除了对废弃 API 的依赖。</p><p>&nbsp;</p><p>Node.js 的 C++ 附加组件目前已增加对 C++ 垃圾回收的实验性支持，增强了对 V8 内存管理的兼容性。这项支持保证了 Node.js 可以用 v8::CppHeap启动，，允许使用 V8 的  头进行内存分配。虽然根据子版本和补丁更新不同，这项支持的稳定性可能会有所不同，但 C++ 的垃圾回收器在 Chromium 中运行记录良好，使其成为开发 C++ 附加组件的理想选择。</p><p>&nbsp;</p><p><a href=\"https://www.infoq.com/news/2023/04/node-20-new-permission-model/\">发布于2023年4月</a>\"的 Node.js 20 带来了诸多重大变化，其中包括对 ES2023 的采用、对 WebAssembly 系统接口（WASI）的实验性支持，以及基于性能和稳定性的考量，将 V8 JavaScript 引擎升至 11.3版本。这次版本通过引入实验性的权限模型增强了安全性，配置稳定的测试运行期，并引入单一可执行应用的功能，从而确保了 Node.js 应用在未安装 Node.js 的系统中分布数量。这些进展再加上对新操作系统的支持、对 TypeScript 兼容性的优化，以及新开发者工具和 API 的引入，都是对 Node.js 的巩固。</p><p>&nbsp;</p><p>Node.js 20 目前处于测试阶段，并将<a href=\"https://nodejs.dev/en/about/releases/\">于2023年10月24日过渡到长期支持</a>\"（LTS）。这代表着至少在未来三年内，该版本将得到包括安全更新和错误修复在内的持续支持。</p><p>&nbsp;</p><p></p><h5>原文链接：</h5><p></p><p><a href=\"https://www.infoq.com/news/2023/09/node-js-2023-edition/\">https://www.infoq.com/news/2023/09/n</a>\"<a href=\"https://www.infoq.com/news/2023/09/node-js-2023-edition/\">ode</a>\"<a href=\"https://www.infoq.com/news/2023/09/node-js-2023-edition/\">-</a>\"<a href=\"https://www.infoq.com/news/2023/09/node-js-2023-edition/\">js</a>\"<a href=\"https://www.infoq.com/news/2023/09/node-js-2023-edition/\">-</a>\"<a href=\"https://www.infoq.com/news/2023/09/node-js-2023-edition/\">2023</a>\"<a href=\"https://www.infoq.com/news/2023/09/node-js-2023-edition/\">-e</a>\"<a href=\"https://www.infoq.com/news/2023/09/node-js-2023-edition/\">dition</a>\"<a href=\"https://www.infoq.com/news/2023/09/node-js-2023-edition/\">/</a>\"</p><p>&nbsp;</p><p></p><h5>相关阅读：</h5><p></p><p><a href=\"https://xie.infoq.cn/article/be78c75026bf0ede1253828fe\">Node.js 未来发展趋势</a>\"</p><p><a href=\"https://www.infoq.cn/article/juXB8EaoJrlLx4vB7ttD\">Node 之父着急宣布：Deno&nbsp;将迎来重大变革，更好地兼容</a>\"</p><p><a href=\"https://xie.infoq.cn/article/aad4610523c72781f0dd5b5b7\">Node&nbsp;版本控制</a>\"</p><p><a href=\"https://www.infoq.cn/article/9QU4eRfjNmNjidpjRkUI\">Node.js 20 正式发布</a>\"</p>",
    "publish_time": "2023-09-29 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]