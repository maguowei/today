[
  {
    "title": "使用External Secrets Operator管理Kubernetes的Secret",
    "url": "https://www.infoq.cn/article/Njt8a0wwGyd1Xt8dLMdx",
    "summary": "<p>Kubernetes的Secret机制允许我们将敏感信息存储中央存储库etcd中，这是一种比在Pod定义或容器镜像中存储信息更安全的方式。然而，Kubernetes目前还没有能力管理Secret的生命周期，所以有时候我们需要使用外部系统来管理这些敏感信息。随着我们需要管理的Secret数量的增长，我们可能需要额外的工具来简化和更好地管理它们。在本文中，我们将详细介绍其中的一种工具<a href=\"https://external-secrets.io/\">External Secrets Operator</a>\"。</p><p></p><h2>什么是Secret</h2><p></p><p>Secret是用于管理人到应用程序以及应用程序到应用程序访问权限的数字凭证。它们可以以密码、加密密钥、令牌等形式存在。</p><p></p><h2>什么是Secret管理</h2><p></p><p>Secret管理就是指安全地管理数字凭证的创建、存储、轮换和撤销，同时消除或至少尽量减少人为的参与，并减少潜在的错误来源。</p><p></p><h2>什么是Kubernetes Secret</h2><p></p><p>容器需要访问敏感数据来执行基本操作，如与数据库、API和其他系统集成。在Kubernetes中，Secret是包含数字凭证（如密码、令牌或密钥）的对象，使用Secret可以避免在Pod定义或容器镜像中存储敏感信息。</p><p></p><h2>问题分析</h2><p></p><p>我们都知道如何使用Secret连接到外部服务。下面是一个简单的使用Secret连接数据库的架构示例。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/32/9b/32339cf98bf793fda6d840250d342b9b.png\" /></p><p></p><p>我们有一个微服务（或者单体，如果你愿意的话），它使用Secret（用户名和密码）连接数据库。</p><p></p><p>当你开始支持开发、测试和生产等多种环境时，管理和同步所有这些Secret就变得有点困难了。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/90/8e/9052c060a6e2141300fb8b215552ca8e.png\" /></p><p></p><p>现在，想象一下你将应用程序拆分为多个服务，每个服务都有自己的外部依赖，比如数据库、第三方API等，这会导致架构变得更复杂。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/5b/6c/5bc6a0e45d3cca913b338ayy90c6436c.png\" /></p><p></p><p>要在Kubernetes中搭建上述的多服务环境将面临许多挑战，包括：</p><p></p><p>你可能需要管理数百个Secret。管理Secret的生命周期（如创建、存储、轮换和撤销）变得很困难。引入新服务和具有特定访问权限的用户变得越来越困难。你必须考虑如何安全地分发Secret。基于上述的原因，你可以考虑选择第三方Secret管理工具来减轻与管理Kubernetes Secret相关的工作量。</p><p></p><p>一些流行的工具和供应商如下：</p><p></p><p>云供应商：AWS Secrets Manager、Google Secret Manager、Azure Key Vault、IBM Cloud Secrets Manager、Oracle Key Vault；开源工具：HashiCorp Vault。我们需要的是一个简单的解决方案，至少能够解决其中的一些问题，将存储在外部Secret管理工具中的Secret带到我们的集群中，并在我们的应用程序中继续使用Kubernetes的Secret。这意味着我们需要一个组件将外部Secret信息同步到集群中，而这就是External Secrets Operator的亮点所在。</p><p></p><h2>Operator设计模式</h2><p></p><p>在深入了解External Secrets Operator之前，先让我们来快速回顾一下什么是Kubernetes Operator。</p><p></p><p>我们已经知道，每个Kubernetes集群都有一个理想的状态。这个状态决定了应该运行哪些工作负载（Pod、部署等）、这些工作负载应该使用哪些镜像，以及这些工作负载应该使用哪些资源。控制器是集群中的控制循环，它监控对象的当前状态，将其与期望的状态进行比较，并根据需要对其进行修改。我们也将这些控制循环称为调和循环。</p><p></p><p>下面是这个过程的一般示意图。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/0d/76/0d7fb877b1d4caf64b3f1ed222ac5c76.png\" /></p><p>这种使用声明式状态和控制器管理应用程序和基础设施资源的过程被称为Operator设计模式。有时候，控制器和Operator这两个术语可以互换使用。二者的不同之处在于，Operator具有特定领域知识，知道如何通过读取所需的定义和使用控制器更新集群来创建和管理资源。</p><p></p><h2>什么是External Secrets Operator（ESO）</h2><p></p><p>ESO是一种Kubernetes Operator，它连接到我们上面提到的外部Secret管理系统，读取Secret信息并将它们注入到Kubernetes的Secret中。它是自定义API资源的集合，为管理Secret生命周期的外部API提供了抽象。</p><p></p><h4>External Secrets Operator的结构</h4><p></p><p>与所有其他Kubernetes Operator一样，ESO由以下几个主要部分组成：</p><p></p><p>自定义资源定义（Custom Resource Definitions，CRD）——它们定义了Operator可用的配置选项的数据模式，在我们的示例中是<a href=\"https://github.com/external-secrets/external-secrets/blob/main/config/crds/bases/external-secrets.io_secretstores.yaml\">SecretStore</a>\"和<a href=\"https://github.com/external-secrets/external-secrets/blob/main/config/crds/bases/external-secrets.io_externalsecrets.yaml\">ExternalSecret</a>\"定义。可编程结构——它们使用所选的编程语言（在我们的例子中是Go）定义与上面的CRD相同的数据模式。自定义资源（Custom Resource，CR）——它们包含CRD定义的值，并描述Operator的配置。控制器——控制器操作自定义资源，并负责创建和管理资源。它们可以用任何编程语言构建，ESO的控制器是用Go构建的。</p><p></p><h4>外部Secret提供程序</h4><p></p><p>ESO使用不同的提供程序连接到外部Secret管理系统，并将Secret拉入集群。这些提供程序是通过SecretStore和ExternalSecret资源配置的，稍后我们将介绍它们。你可以在<a href=\"https://github.com/external-secrets/external-secrets/tree/main/pkg/provider\">这里</a>\"找到我们所使用的提供程序的源代码。</p><p></p><p>Secret提供程序的结构其实很简单：</p><p></p><p><code lang=\"go\">type Provider interface{\n  //通过NewClient构造一个SecretsManagerProvider\n  NewClient(ctx context.Context, store GenericStore, kube client.Client, namespace string) (SecretsClient, error)\n\n  //ValidateStore方法检查提供的Secret存储是否有效\n  ValidateStore(store GenericStore) error\n}\n</code></p><p></p><p>正如你在上面看到的，每个提供程序都提供了用于验证存储配置和实例化SecretsClient对象的函数。</p><p></p><p>SecretsClient实例负责验证Secret配置，并以各种形式提取Secret：</p><p></p><p><code lang=\"go\">type SecretsClient interface{\n  GetSecret(ctx context.Context, ref ExternalSecretDataRemoteRef) ([]byte, error)\n\n  Validate() (ValidationResult, error)\n\n  GetSecretMap(ctx context.Context, ref ExternalSecretDataRemoteRef) (map[string][]byte, error)\n\n  GetAllSecrets(ctx context.Context, ref ExternalSecretFind) (map[string][]byte, error)\n\n   Close(ctx context.Context) error\n}\n</code></p><p></p><p>让我们来看看之前提到的资源类型是如何同步外部Secret的。</p><p></p><h4>SecretStore资源</h4><p></p><p>你可以通过SecretStore资源配置想要访问的外部Secret管理服务，并通过指定身份验证所需的配置来访问它。</p><p></p><p>下面是访问AWS Secrets Manager的配置示例：</p><p></p><p><code lang=\"go\">apiVersion: external-secrets.io/v1beta1\nkind: SecretStore\nmetadata:\n  name: secretstore-sample\nspec:\n  provider:\n    aws:\n    service: SecretsManager\n    region: us-east-1\n    auth:\n      secretRef:\n        accessKeyIDSecretRef:\n          name: awssm-secret\n          key: access-key\n        secretAccessKeySecretRef:\n          name: awssm-secret\n          key: secret-access-key\n</code></p><p></p><h4>ExternalSecret资源</h4><p></p><p>SecretStore定义了如何访问Secret，ExternalSecret资源则定义应该获取哪些Secret。它持有SecretStore引用，因此ESO的控制器可以使用ExternalSecret资源（调用SecretStore资源指定的配置）来创建Kubernetes Secret。</p><p></p><p>下面是使用secretStoreRef属性连接这两个资源的示例：</p><p></p><p><code lang=\"go\">apiVersion: external-secrets.io/v1beta1\nkind: ExternalSecret\nmetadata:\n  name: example\nspec:\n  refreshInterval: 1h\n  secretStoreRef:\n    name: secretstore-sample\n    kind: SecretStore\n  target:\n    name: secret-to-be-created\n    creationPolicy: Owner\n  data:\n  - secretKey: secret-key-to-be-managed\n    remoteRef:\n      key: provider-key\n      version: provider-key-version\n      property: provider-key-property\n  dataFrom:\n  - extract:\n      key: remote-key-in-the-provider\n</code></p><p></p><p>在应用程序开始启动时，所有的提供程序都将自己注册到ESO。注册动作就是将提供程序对象及其配置信息添加到Map中。当ESO控制器需要访问Secret存储时，它就使用这个Map来查找存储。在创建自己的Secret提供程序时，我们也会遵循同样的实现规范。</p><p></p><h2>ESO如何同步Secret</h2><p></p><p>正如我们在上面的Operator设计模式小节中所讲的那样，控制器通过无限循环来调和集群的当前状态和期望状态之间的漂移。ESO控制器也不例外。在每一次调和循环中，<a href=\"https://github.com/external-secrets/external-secrets/blob/main/pkg/controllers/externalsecret/externalsecret_controller.go\">外部Secret控制器</a>\"会执行以下这些操作。</p><p></p><p>为当前调和循环读取外部Secret配置；通过secretStoreRef属性获取被外部Secret配置引用的SecretStore；使用存储定义中的提供程序名称查找上面提到的提供程序Map，找到与Secret关联的提供程序；使用存储提供程序名称实例化一个Secret客户端；使用Secret客户端从外部系统获取Secret数据；如果没有Secret数据返回，且删除策略被设置为“Delete”，就会从集群中删除Secret数据。如果删除策略被设置为“Retain”，则Secret将保持原样；假设成功获取到了外部Secret，就会在集群中创建Kubernetes密钥，并被应用到任意指定的模板中。</p><p></p><h2>创建一个简单的ESO提供程序</h2><p></p><p>本小节的目标是创建一个非常简单的ESO提供程序。请记住，我们在这里所做的绝对不适合用在生产环境中。要获得更优雅的、可用于生产环境的解决方案，可以在理解了如何添加提供程序之后查看提供程序的源代码。</p><p></p><p>以下是向ESO中添加新Secret提供程序的步骤。</p><p></p><p>为新的Secret提供程序添加配置模式；创建类型定义，将CRD定义映射到Go语言的结构体；添加提供程序实现；在register.go中注册新的提供程序。创建并部署。</p><p></p><h4>一个简单的Secret管理服务</h4><p></p><p>为了让本教程尽可能简单，并且考虑到ESO已经涵盖了大多数用于管理Secret的常见外部系统，我们将在本教程中使用Node.js Express作为Secret服务器。</p><p></p><p>下面是服务的实现。</p><p></p><p><code lang=\"java\">const express = require('express');\nconst router = express.Router();\n \nconst keys = [];\n \n/* GET keys listing as a JSON array */\nrouter.get('/', (req, res, next) =&gt; {\n   res.send(keys);\n});\n \n/* GET a single key as a JSON object. */\nrouter.get('/:key', (req, res) =&gt; {\n   const key = keys.find(k =&gt; k.key === req.params.key);\n   res.send(key);\n})\n \nmodule.exports = router;\n</code></p><p></p><h4>添加新的CRD定义</h4><p></p><p>我们需要让Kubernetes知道新提供程序的配置。这是自定义资源的最小定义。</p><p></p><p><code lang=\"go\">express:\n  description: Configuration to sync secrets using Express provider\n  properties:\n    host:\n      type: string\n  required:\n    - host\n  type: object\n</code></p><p></p><p>这个定义应该与其他CRD一样添加到deploy/crds/bundle.yaml。新的提供程序只有一个配置属性host，它告诉提供程序Secret服务在哪里。</p><p></p><h4>为提供程序配置创建类型</h4><p></p><p>为了让提供程序从控制器获取配置，我们还需要添加必要的类型，将配置转换为Go语言的结构体。</p><p></p><p><code lang=\"go\">package v1beta1\n \ntype ExpressProvider struct {\n   Host string `json:\"host\"`\n}\n</code></p><p></p><p>可以看到，CRD的配置与上面的结构体是相匹配的。在运行时，提供程序将接收到上述结构的配置。</p><p></p><h4>实现提供程序</h4><p></p><p>我们的提供程序需要实现Provider和SecretClient接口。基本上，我们需要创建一个SecretClient实例并将它返回。我们需要实现SecretClient的GetSecret函数。我们还可以添加验证逻辑来检查存储的配置是否正确。下面是提供程序的基本实现。</p><p></p><p><code lang=\"go\">package express\n \nimport (\n   \"context\"\n   \"encoding/json\"\n   \"fmt\"\n   esv1beta1 \"github.com/external-secrets/external-secrets/apis/externalsecrets/v1beta1\"\n   \"io/ioutil\"\n   \"log\"\n   \"net/http\"\n   \"net/url\"\n   \"sigs.k8s.io/controller-runtime/pkg/client\"\n   \"time\"\n)\n \nconst (\n   errNilStore              = \"nil store found\"\n   errMissingStoreSpec      = \"store is missing spec\"\n   errMissingProvider       = \"storeSpec is missing provider\"\n   errInvalidProvider       = \"invalid provider spec. Missing express field in store %s\"\n   errInvalidExpressHostURL = \"invalid express host URL\"\n)\n \n// this struct will hold the keys that the service returns\ntype keyValue struct {\n   Key   string `json:\"key\"`\n   Value string `json:\"value\"`\n}\n \ntype Provider struct {\n   config  *esv1beta1.ExpressProvider\n   hostUrl string\n}\n\n// NewClient this is where we initialize the SecretClient and return it for the controller to use\nfunc (p *Provider) NewClient(ctx context.Context, store esv1beta1.GenericStore, kube client.Client, namespace string) (esv1beta1.SecretsClient, error) {\n   config := store.GetSpec().Provider.Express\n \n   return &amp;Provider{\n       config:  config,\n       hostUrl: config.Host,\n   }, nil\n}\n \nfunc (p *Provider) GetAllSecrets(ctx context.Context, ref esv1beta1.ExternalSecretFind) (map[string][]byte, error) {\n   return nil, fmt.Errorf(\"GetAllSecrets not implemented\")\n}\n \n// GetSecret reads the secret from the Express server and returns it. The controller uses the value here to\n// create the Kubernetes secret\nfunc (p *Provider) GetSecret(ctx context.Context, ref esv1beta1.ExternalSecretDataRemoteRef) ([]byte, error) {\n   expressClient := http.Client{\n       Timeout: time.Second * 5,\n   }\n \n   req, err := http.NewRequest(http.MethodGet, p.hostUrl+\"/keys/\"+ref.Key, nil)\n   if err != nil {\n       log.Fatal(err)\n   }\n   \n   fmt.Printf(\"Sending request to: %s\\n\", p.hostUrl+\"/keys/\"+ref.Key)\n \n   res, getErr := expressClient.Do(req)\n   if getErr != nil {\n       return nil, fmt.Errorf(\"error getting the secret %s\", ref.Key)\n   }\n \n   if res.Body != nil {\n       defer res.Body.Close()\n   }\n \n   body, readErr := ioutil.ReadAll(res.Body)\n   if readErr != nil {\n       return nil, fmt.Errorf(\"error reading secret %s\", ref.Key)\n   }\n   fmt.Printf(\"body: %s\\n\", body)\n \n   secret := keyValue{}\n   jsonErr := json.Unmarshal(body, &amp;secret)\n   if jsonErr != nil {\n       return nil, fmt.Errorf(\"bad key format: %s\", ref.Key)\n   }\n   return []byte(secret.Value), nil\n}\n \n// ValidateStore validates the store configuration to prevent unexpected errors\nfunc (p *Provider) ValidateStore(store esv1beta1.GenericStore) error {\n   if store == nil {\n       return fmt.Errorf(errNilStore)\n   }\n\n    spec := store.GetSpec()\n   if spec == nil {\n       return fmt.Errorf(errMissingStoreSpec)\n   }\n \n   if spec.Provider == nil {\n       return fmt.Errorf(errMissingProvider)\n   }\n \n   provider := spec.Provider.Express\n   if provider == nil {\n       return fmt.Errorf(errInvalidProvider, store.GetObjectMeta().String())\n   }\n \n   hostUrl, err := url.Parse(provider.Host)\n   if err != nil {\n       return fmt.Errorf(errInvalidExpressHostURL)\n   }\n \n   if hostUrl.Host == \"\" {\n       return fmt.Errorf(errInvalidExpressHostURL)\n   }\n \n   return nil\n}\n\n// registers the provider object to process on each reconciliation loop\nfunc init() {\n   esv1beta1.Register(&amp;Provider{}, &amp;esv1beta1.SecretStoreProvider{\n       Express: &amp;esv1beta1.ExpressProvider{},\n   })\n}\n</code></p><p></p><h2>将提供程序注册到提供程序列表中</h2><p></p><p>下一步是在register.go中导入提供程序模块，用于初始化它的函数。</p><p></p><p><code lang=\"go\">package register\n \nimport (\n   …\n   _ \"github.com/external-secrets/external-secrets/pkg/provider/express\"\n   …\n)\n</code></p><p></p><h4>部署用于测试的ESO</h4><p></p><p>ESO文档描述了将ESO部署到Kubernetes集群所需的步骤。不过，因为我们是在本地运行，所以可以通过手动运行Makefile中定义的任务来加快开发和测试过程。</p><p></p><p>首先部署CRD。</p><p></p><p><code lang=\"go\">make crds.install\n</code></p><p></p><p>然后在本地运行ESO。</p><p></p><p><code lang=\"go\">make run\n</code></p><p></p><h4>用Secret来测试提供程序</h4><p></p><p>为了测试提供程序，我们需要将SecretStore和ExternalSecret配置部署到集群中。SecretStore配置将指向Express服务器，ExternalSecret配置将把存储在Express服务器中的Secret映射成Kubernetes Secret。</p><p></p><p><code lang=\"go\">apiVersion: external-secrets.io/v1beta1\nkind: SecretStore\nmetadata:\n name: secretstore-express\nspec:\n provider:\n   express:\n     host: http://express-secrets-service\n---\napiVersion: external-secrets.io/v1beta1\nkind: ExternalSecret\nmetadata:\n name: express-external-secret\nspec:\n refreshInterval: 1h\n \n secretStoreRef:\n   kind: SecretStore\n   name: secretstore-express\n \n target:\n   name: my-express-secret\n   creationPolicy: Owner\n \n data:\n   - secretKey: secretKey # Key given to the secret to be created on the cluster\n     remoteRef:\n       key: my-secret-key\n</code></p><p></p><p>部署上面的清单。</p><p></p><p><code lang=\"go\">kubectl apply -f secret.yaml \n</code></p><p></p><p>如果一切都进展得很顺利，这个Secret应该会出现在Kubernetes集群中。</p><p></p><p><code lang=\"plain\">kubectl get secret my-express-secret -o yam\n</code></p><p></p><p>下面是Kubernetes API的输出。</p><p></p><p><code lang=\"go\">apiVersion: v1\ndata:\n  secretKey: dGhpcy1pcy1hLXNlY3JldA==\nimmutable: false\nkind: Secret\n</code></p><p></p><h2>总结</h2><p></p><p>在本文中，我们解释了为什么要使用External Secrets Operator，并展示了如何开发外部Secret提供程序。External Secrets Operator是一个用于在多租户和多服务环境中管理Secret的强大工具，许多<a href=\"https://github.com/external-secrets/external-secrets/blob/main/ADOPTERS.md\">组织</a>\"都在生产环境中使用它。</p><p></p><p>作者简介：</p><p></p><p>Önsel Akin是一名拥有25年软件开发经验的软件架构师。他曾身兼数职，与开发、设计思维和产品开发团队密切合作。他曾在许多大型软件开发公司工作，担任软件工程师和软件架构师。他喜欢玩《万智牌》，有时间也会设计手机游戏。他是Container Solutions的云原生工程师。</p><p></p><p>原文链接：</p><p></p><p><a href=\"https://www.infoq.com/articles/k8s-external-secrets-operator/\">Managing Kubernetes Secrets with the External Secrets Operator</a>\"</p>",
    "publish_time": "2022-08-14 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]