[
  {
    "title": "TypeScript中的Object.keys类型为什么非要这么设计？",
    "url": "https://www.infoq.cn/article/1RbbRPFKwQsGdDa8B7oJ",
    "summary": "<p>如果大家比较熟悉TypeScript开发，那肯定遇到过下面这种情况：</p><p>&nbsp;</p><p><code lang=\"null\">interface Options {\n  hostName: string;\n  port: number;\n}\n\n\nfunction validateOptions (options: Options) {\n  Object.keys(options).forEach(key =&gt; {\n    if (options[key] == null) {\n        // @error {w=12} Expression of type 'string' can't be used to index type 'Options'.\n      throw new Error(`Missing option ${key}`);\n    }\n  });\n}\n\n</code></p><p>&nbsp;</p><p>&nbsp;</p><p>乍看之下，这个错误完全是莫名其妙。我们完全可以使用options&nbsp;键来访问options&nbsp;，但TypeScript为什么还非要报错？</p><p>&nbsp;</p><p>只要通过将&nbsp;Object.keys(options)&nbsp;强制转换为&nbsp;(keyof&nbsp;typeof options)[]，就能有效规避这个问题。</p><p>&nbsp;</p><p><code lang=\"null\">const keys = Object.keys(options) as (keyof typeof options)[];\nkeys.forEach(key =&gt; {\n  if (options[key] == null) {\n    throw new Error(`Missing option ${key}`);\n  }\n});</code></p><p>&nbsp;</p><p>既然方法如此简单，TypeScript为什么不出手解决？</p><p>&nbsp;</p><p>查看Object.keys的类型定义，我们会看到如下内容：</p><p>&nbsp;</p><p><code lang=\"null\">// typescript/lib/lib.es5.d.ts\n\n\ninterface Object {\n  keys(o: object): string[];\n}\n\n</code></p><p>&nbsp;</p><p>这个类型定义非常简单，即接收object&nbsp;并返回string[]。</p><p>&nbsp;</p><p>也就是说，我们可以轻松让这个方法接收通用参数T&nbsp;并返回(keyof T)[]。</p><p>&nbsp;</p><p><code lang=\"null\">class Object {\n  keys(o: T): (keyof T)[];\n}\n\n</code></p><p>&nbsp;</p><p>&nbsp;</p><p>只要这样定义Object.keys，就不会触发任何类型错误。</p><p>&nbsp;</p><p>所以大家第一反应肯定是把Object.keys定义成这样，可TypeScript偏没有这么做。究其原因，与TypeScript的结构类型系统有关。</p><p>&nbsp;</p><p></p><h2>TypeScript中的结构类型</h2><p></p><p>&nbsp;</p><p>只要发现有属性丢失或者类型错误，TypeScript就会马上报错。</p><p>&nbsp;</p><p><code lang=\"null\">function saveUser(user: { name: string, age: number }) {}\n\n\nconst user1 = { name: \"Alex\", age: 25 };\nsaveUser(user1); // OK!\n\n\nconst user2 = { name: \"Sarah\" };\nsaveUser(user2);\n         // @error {w=5} Property 'age' is missing in type { name: string }.\n\n\nconst user3 = { name: \"John\", age: '34' };\nsaveUser(user3);\n         // @error {w=5} Types of property 'age' are incompatible.\\n  Type 'string' is not assignable to type 'number'.\n\n</code></p><p>&nbsp;</p><p>&nbsp;</p><p>但如果我们提交的是无关的属性，那TypeScript不会做出任何反应。</p><p>&nbsp;</p><p><code lang=\"null\">function saveUser(user: { name: string, age: number }) {}\n\n\nconst user = { name: \"Alex\", age: 25, city: \"Reykjavík\" };\nsaveUser(user); // Not a type error\n\n</code></p><p>&nbsp;</p><p>这就是结构类型系统的设计思路。如果A是B的超集（即A包含B中的所有属性），则可以将类型A分配给B。</p><p>&nbsp;</p><p>但如果A是B的真超集（即A中的属性比B更多），则：</p><p>A可被分配给B，但B不可被分配给A。</p><p>&nbsp;</p><p>注意：除了需要是属性的超集之外，具体属性类型也有影响。</p><p>&nbsp;</p><p>以上讲解可能过于抽象，下面咱们从更具体的例子入手。</p><p>&nbsp;</p><p><code lang=\"null\">type A = { foo: number, bar: number };\ntype B = { foo: number };\n\n\nconst a1: A = { foo: 1, bar: 2 };\nconst b1: B = { foo: 3 };\n\n\nconst b2: B = a1;\nconst a2: A = b1;\n      // @error {w=2} Property 'bar' is missing in type 'B' but required in type 'A'.\n\n</code></p><p>&nbsp;</p><p>其中的关键点在于，当我们面对一个类型T的对象时，也就相当于确定该对象至少包含T中的属性。</p><p>&nbsp;</p><p>但我们并不知道T是否切实存在，所以Object.keys的类型机制才会是现在这个样子。下面我们再举一例。</p><p>&nbsp;</p><p></p><h3>Object.keys的不安全用法</h3><p></p><p>&nbsp;</p><p>假设我们正为某项Web服务创建一个端点，此端点会创建一个新用户。我们的现有User接口如下所示：</p><p>&nbsp;</p><p><code lang=\"null\">interface User {\n  name: string;\n  password: string;\n}\n\n</code></p><p>&nbsp;</p><p>在将用户保存至数据库之前，我们先要确保这里的User对象有效。</p><p>name必须为非空。password必须有至少6个字符。</p><p>&nbsp;</p><p>因此，我们创建一个validators对象，其中包含User中每个属性的验证函数：</p><p>&nbsp;</p><p><code lang=\"null\">const validators = {\n  name: (name: string) =&gt; name.length &lt; 1\n    ? \"Name must not be empty\"\n    : \"\",\n  password: (password: string) =&gt; password.length &lt; 6\n    ? \"Password must be at least 6 characters\"\n    : \"\",\n};\n\n</code></p><p>&nbsp;</p><p>之后我们再创建一个validateUser&nbsp;函数，通过这些验证器运行User对象：</p><p>&nbsp;</p><p><code lang=\"null\">function validateUser(user: User) {\n  // Pass user object through the validators\n}\n\n</code></p><p>&nbsp;</p><p>因为我们需要验证user中的各个属性，所以可以用Object.keys迭代user中的属性：</p><p>&nbsp;</p><p><code lang=\"null\">function validateUser(user: User) {\n  let error = \"\";\n  for (const key of Object.keys(user)) {\n    const validate = validators[key];\n    error ||= validate(user[key]);\n  }\n  return error;\n}\n\n</code></p><p>&nbsp;</p><p>注意：这部分代码片段中存在类型错误，但我们暂不细究，稍后再进一步讨论。</p><p>&nbsp;</p><p>这种方法的问题是，user用户可能包含validators中不存在的属性。</p><p>&nbsp;</p><p><code lang=\"null\">interface User {\n  name: string;\n  password: string;\n}\n\n\nfunction validateUser(user: User) {}\n\n\nconst user = {\n  name: 'Alex',\n  password: '1234',\n  email: \"alex@example.com\",\n};\nvalidateUser(user); // OK!\n\n</code></p><p>&nbsp;</p><p>&nbsp;</p><p>即使User并没有指定email属性，由于结构类型允许提交无关属性，所以这里也不会触发类型错误。</p><p>&nbsp;</p><p>在运行时中，email属性会导致validator处于undefined状态，并在调用时抛出错误。</p><p>&nbsp;</p><p><code lang=\"null\">for (const key of Object.keys(user)) {\n  const validate = validators[key];\n  error ||= validate(user[key]);\n            // @error {w=8} TypeError: 'validate' is not a function.\n}\n\n</code></p><p>&nbsp;</p><p>好在TypeScript会在这段代码实际运行之前，就提醒我们其中存在类型错误。</p><p>&nbsp;</p><p><code lang=\"null\">for (const key of Object.keys(user)) {\n  const validate = validators[key];\n                   // @error {w=15} Expression of type 'string' can't be used to index type '{ name: ..., password: ... }'.\n  error ||= validate(user[key]);\n                     // @error {w=9} Expression of type 'string' can't be used to index type 'User'.\n}\n\n</code></p><p>&nbsp;</p><p>现在相信大家能够理解Object.keys的类型为什么要这样设计了。其实质，就是强制提醒我们对象中可能包含类型系统无法识别的属性。</p><p>&nbsp;</p><p>有了以上结构类型和潜在问题的知识储备，下面我们一起来看如何发挥结构类型的设计优势。</p><p>&nbsp;</p><p></p><h3>实际运用结构类型</h3><p></p><p>&nbsp;</p><p>结构类型带来了很大的灵活性，允许接口准确声明自己需要的属性。下面还是通过实例加以演示。</p><p>&nbsp;</p><p>设想我们编写了一个函数以解析KeyboardEvent，并返回触发器的快捷方式。</p><p>&nbsp;</p><p><code lang=\"null\">function getKeyboardShortcut(e: KeyboardEvent) {\n  if (e.key === \"s\" &amp;&amp; e.metaKey) {\n    return \"save\";\n  }\n  if (e.key === \"o\" &amp;&amp; e.metaKey) {\n    return \"open\";\n  }\n  return null;\n}\n\n</code></p><p>&nbsp;</p><p>为了确保代码按预期工作，下面我们编写一些单元测试：</p><p>&nbsp;</p><p><code lang=\"null\">expect(getKeyboardShortcut({ key: \"s\", metaKey: true }))\n  .toEqual(\"save\");\n\n\nexpect(getKeyboardShortcut({ key: \"o\", metaKey: true }))\n  .toEqual(\"open\");\n\n\nexpect(getKeyboardShortcut({ key: \"s\", metaKey: false }))\n  .toEqual(null);\n\n</code></p><p>&nbsp;</p><p>&nbsp;</p><p>看起来不错，但TypeScript会报错：</p><p>&nbsp;</p><p><code lang=\"null\">getKeyboardShortcut({ key: \"s\", metaKey: true });\n                    // @error {w=27,shiftLeft=48} Type '{ key: string; metaKey: true; }' is missing the following properties from type 'KeyboardEvent': altKey, charCode, code, ctrlKey, and 37 more.\n\n</code></p><p>&nbsp;</p><p>一个个指定37个额外属性根本就不现实，我们当然可以将参数转换为KeyboardEvent来解决这个问题：</p><p>&nbsp;</p><p><code lang=\"null\">getKeyboardShortcut({ key: \"s\", metaKey: true } as KeyboardEvent);\n\n</code></p><p>&nbsp;</p><p>但这可能遮盖掉其他可能发生的类型错误。</p><p>&nbsp;</p><p>所以正确的思路，应该是更新getKeyboardShortcut以确保仅从事件中声明它需要的属性。</p><p>&nbsp;</p><p><code lang=\"null\">interface KeyboardShortcutEvent {\n  key: string;\n  metaKey: boolean;\n}\n\n\nfunction getKeyboardShortcut(e: KeyboardShortcutEvent) {}\n\n</code></p><p>&nbsp;</p><p>现在测试代码需要满足的条件大大收窄，处理起来自然更加轻松。</p><p>&nbsp;</p><p>函数与全局KeyboardEvent类型的耦合也更少，且能够在更多上下文中使用。换言之，灵活性得到显著提升。</p><p>&nbsp;</p><p>而这一切之所以可行，显然要归功于结构类型。作为后者的超集，KeyboardEvent可被分配给KeyboardShortcutEvent，这就回避了KeyboardEvent中的37个不相关属性。</p><p>&nbsp;</p><p><code lang=\"null\">window.addEventListener(\"keydown\", (e: KeyboardEvent) =&gt; {\n  const shortcut = getKeyboardShortcut(e); // This is OK!\n  if (shortcut) {\n    execShortcut(shortcut);\n  }\n});\n\n</code></p><p>&nbsp;</p><p></p><h5>原文链接：</h5><p></p><p></p><p><a href=\"https://alexharri.com/blog/typescript-structural-typing\">https://alexharri.com/blog/typescript-structural-typing</a>\"</p><p></p><h5>&nbsp;相关阅读：</h5><p></p><p></p><p><a href=\"https://xie.infoq.cn/article/6ff79700fb3bfa972c1beebf3\">TypeScript 与 JavaScript：你应该知道的区别</a>\"</p><p><a href=\"https://www.infoq.cn/article/dDXbcLHT7teNYSPL3sm7\">“TypeScript 不值得！”前端框架 Svelte 作者宣布重构代码，反向迁移到 JavaScript 引争议</a>\"</p><p><a href=\"https://xie.infoq.cn/article/b7f556a866805cf5c71be7af8\">Typescript- 类型检测和变量的定义</a>\"</p><p><a href=\"https://xie.infoq.cn/article/5cf66bfa800154e86868a1849\">理论 + 实践：从原型链到继承模式，掌握 Object 的精髓 </a>\"</p>",
    "publish_time": "2023-08-28 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]