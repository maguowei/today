[
  {
    "title": "TypeScript中的Object.keys类型为什么非要这么设计？",
    "url": "https://www.infoq.cn/article/1RbbRPFKwQsGdDa8B7oJ",
    "summary": "<p>如果大家比较熟悉TypeScript开发，那肯定遇到过下面这种情况：</p><p>&nbsp;</p><p><code lang=\"null\">interface Options {\n  hostName: string;\n  port: number;\n}\n\n\nfunction validateOptions (options: Options) {\n  Object.keys(options).forEach(key =&gt; {\n    if (options[key] == null) {\n        // @error {w=12} Expression of type 'string' can't be used to index type 'Options'.\n      throw new Error(`Missing option ${key}`);\n    }\n  });\n}\n\n</code></p><p>&nbsp;</p><p>&nbsp;</p><p>乍看之下，这个错误完全是莫名其妙。我们完全可以使用options&nbsp;键来访问options&nbsp;，但TypeScript为什么还非要报错？</p><p>&nbsp;</p><p>只要通过将&nbsp;Object.keys(options)&nbsp;强制转换为&nbsp;(keyof&nbsp;typeof options)[]，就能有效规避这个问题。</p><p>&nbsp;</p><p><code lang=\"null\">const keys = Object.keys(options) as (keyof typeof options)[];\nkeys.forEach(key =&gt; {\n  if (options[key] == null) {\n    throw new Error(`Missing option ${key}`);\n  }\n});</code></p><p>&nbsp;</p><p>既然方法如此简单，TypeScript为什么不出手解决？</p><p>&nbsp;</p><p>查看Object.keys的类型定义，我们会看到如下内容：</p><p>&nbsp;</p><p><code lang=\"null\">// typescript/lib/lib.es5.d.ts\n\n\ninterface Object {\n  keys(o: object): string[];\n}\n\n</code></p><p>&nbsp;</p><p>这个类型定义非常简单，即接收object&nbsp;并返回string[]。</p><p>&nbsp;</p><p>也就是说，我们可以轻松让这个方法接收通用参数T&nbsp;并返回(keyof T)[]。</p><p>&nbsp;</p><p><code lang=\"null\">class Object {\n  keys(o: T): (keyof T)[];\n}\n\n</code></p><p>&nbsp;</p><p>&nbsp;</p><p>只要这样定义Object.keys，就不会触发任何类型错误。</p><p>&nbsp;</p><p>所以大家第一反应肯定是把Object.keys定义成这样，可TypeScript偏没有这么做。究其原因，与TypeScript的结构类型系统有关。</p><p>&nbsp;</p><p></p><h2>TypeScript中的结构类型</h2><p></p><p>&nbsp;</p><p>只要发现有属性丢失或者类型错误，TypeScript就会马上报错。</p><p>&nbsp;</p><p><code lang=\"null\">function saveUser(user: { name: string, age: number }) {}\n\n\nconst user1 = { name: \"Alex\", age: 25 };\nsaveUser(user1); // OK!\n\n\nconst user2 = { name: \"Sarah\" };\nsaveUser(user2);\n         // @error {w=5} Property 'age' is missing in type { name: string }.\n\n\nconst user3 = { name: \"John\", age: '34' };\nsaveUser(user3);\n         // @error {w=5} Types of property 'age' are incompatible.\\n  Type 'string' is not assignable to type 'number'.\n\n</code></p><p>&nbsp;</p><p>&nbsp;</p><p>但如果我们提交的是无关的属性，那TypeScript不会做出任何反应。</p><p>&nbsp;</p><p><code lang=\"null\">function saveUser(user: { name: string, age: number }) {}\n\n\nconst user = { name: \"Alex\", age: 25, city: \"Reykjavík\" };\nsaveUser(user); // Not a type error\n\n</code></p><p>&nbsp;</p><p>这就是结构类型系统的设计思路。如果A是B的超集（即A包含B中的所有属性），则可以将类型A分配给B。</p><p>&nbsp;</p><p>但如果A是B的真超集（即A中的属性比B更多），则：</p><p>A可被分配给B，但B不可被分配给A。</p><p>&nbsp;</p><p>注意：除了需要是属性的超集之外，具体属性类型也有影响。</p><p>&nbsp;</p><p>以上讲解可能过于抽象，下面咱们从更具体的例子入手。</p><p>&nbsp;</p><p><code lang=\"null\">type A = { foo: number, bar: number };\ntype B = { foo: number };\n\n\nconst a1: A = { foo: 1, bar: 2 };\nconst b1: B = { foo: 3 };\n\n\nconst b2: B = a1;\nconst a2: A = b1;\n      // @error {w=2} Property 'bar' is missing in type 'B' but required in type 'A'.\n\n</code></p><p>&nbsp;</p><p>其中的关键点在于，当我们面对一个类型T的对象时，也就相当于确定该对象至少包含T中的属性。</p><p>&nbsp;</p><p>但我们并不知道T是否切实存在，所以Object.keys的类型机制才会是现在这个样子。下面我们再举一例。</p><p>&nbsp;</p><p></p><h3>Object.keys的不安全用法</h3><p></p><p>&nbsp;</p><p>假设我们正为某项Web服务创建一个端点，此端点会创建一个新用户。我们的现有User接口如下所示：</p><p>&nbsp;</p><p><code lang=\"null\">interface User {\n  name: string;\n  password: string;\n}\n\n</code></p><p>&nbsp;</p><p>在将用户保存至数据库之前，我们先要确保这里的User对象有效。</p><p>name必须为非空。password必须有至少6个字符。</p><p>&nbsp;</p><p>因此，我们创建一个validators对象，其中包含User中每个属性的验证函数：</p><p>&nbsp;</p><p><code lang=\"null\">const validators = {\n  name: (name: string) =&gt; name.length &lt; 1\n    ? \"Name must not be empty\"\n    : \"\",\n  password: (password: string) =&gt; password.length &lt; 6\n    ? \"Password must be at least 6 characters\"\n    : \"\",\n};\n\n</code></p><p>&nbsp;</p><p>之后我们再创建一个validateUser&nbsp;函数，通过这些验证器运行User对象：</p><p>&nbsp;</p><p><code lang=\"null\">function validateUser(user: User) {\n  // Pass user object through the validators\n}\n\n</code></p><p>&nbsp;</p><p>因为我们需要验证user中的各个属性，所以可以用Object.keys迭代user中的属性：</p><p>&nbsp;</p><p><code lang=\"null\">function validateUser(user: User) {\n  let error = \"\";\n  for (const key of Object.keys(user)) {\n    const validate = validators[key];\n    error ||= validate(user[key]);\n  }\n  return error;\n}\n\n</code></p><p>&nbsp;</p><p>注意：这部分代码片段中存在类型错误，但我们暂不细究，稍后再进一步讨论。</p><p>&nbsp;</p><p>这种方法的问题是，user用户可能包含validators中不存在的属性。</p><p>&nbsp;</p><p><code lang=\"null\">interface User {\n  name: string;\n  password: string;\n}\n\n\nfunction validateUser(user: User) {}\n\n\nconst user = {\n  name: 'Alex',\n  password: '1234',\n  email: \"alex@example.com\",\n};\nvalidateUser(user); // OK!\n\n</code></p><p>&nbsp;</p><p>&nbsp;</p><p>即使User并没有指定email属性，由于结构类型允许提交无关属性，所以这里也不会触发类型错误。</p><p>&nbsp;</p><p>在运行时中，email属性会导致validator处于undefined状态，并在调用时抛出错误。</p><p>&nbsp;</p><p><code lang=\"null\">for (const key of Object.keys(user)) {\n  const validate = validators[key];\n  error ||= validate(user[key]);\n            // @error {w=8} TypeError: 'validate' is not a function.\n}\n\n</code></p><p>&nbsp;</p><p>好在TypeScript会在这段代码实际运行之前，就提醒我们其中存在类型错误。</p><p>&nbsp;</p><p><code lang=\"null\">for (const key of Object.keys(user)) {\n  const validate = validators[key];\n                   // @error {w=15} Expression of type 'string' can't be used to index type '{ name: ..., password: ... }'.\n  error ||= validate(user[key]);\n                     // @error {w=9} Expression of type 'string' can't be used to index type 'User'.\n}\n\n</code></p><p>&nbsp;</p><p>现在相信大家能够理解Object.keys的类型为什么要这样设计了。其实质，就是强制提醒我们对象中可能包含类型系统无法识别的属性。</p><p>&nbsp;</p><p>有了以上结构类型和潜在问题的知识储备，下面我们一起来看如何发挥结构类型的设计优势。</p><p>&nbsp;</p><p></p><h3>实际运用结构类型</h3><p></p><p>&nbsp;</p><p>结构类型带来了很大的灵活性，允许接口准确声明自己需要的属性。下面还是通过实例加以演示。</p><p>&nbsp;</p><p>设想我们编写了一个函数以解析KeyboardEvent，并返回触发器的快捷方式。</p><p>&nbsp;</p><p><code lang=\"null\">function getKeyboardShortcut(e: KeyboardEvent) {\n  if (e.key === \"s\" &amp;&amp; e.metaKey) {\n    return \"save\";\n  }\n  if (e.key === \"o\" &amp;&amp; e.metaKey) {\n    return \"open\";\n  }\n  return null;\n}\n\n</code></p><p>&nbsp;</p><p>为了确保代码按预期工作，下面我们编写一些单元测试：</p><p>&nbsp;</p><p><code lang=\"null\">expect(getKeyboardShortcut({ key: \"s\", metaKey: true }))\n  .toEqual(\"save\");\n\n\nexpect(getKeyboardShortcut({ key: \"o\", metaKey: true }))\n  .toEqual(\"open\");\n\n\nexpect(getKeyboardShortcut({ key: \"s\", metaKey: false }))\n  .toEqual(null);\n\n</code></p><p>&nbsp;</p><p>&nbsp;</p><p>看起来不错，但TypeScript会报错：</p><p>&nbsp;</p><p><code lang=\"null\">getKeyboardShortcut({ key: \"s\", metaKey: true });\n                    // @error {w=27,shiftLeft=48} Type '{ key: string; metaKey: true; }' is missing the following properties from type 'KeyboardEvent': altKey, charCode, code, ctrlKey, and 37 more.\n\n</code></p><p>&nbsp;</p><p>一个个指定37个额外属性根本就不现实，我们当然可以将参数转换为KeyboardEvent来解决这个问题：</p><p>&nbsp;</p><p><code lang=\"null\">getKeyboardShortcut({ key: \"s\", metaKey: true } as KeyboardEvent);\n\n</code></p><p>&nbsp;</p><p>但这可能遮盖掉其他可能发生的类型错误。</p><p>&nbsp;</p><p>所以正确的思路，应该是更新getKeyboardShortcut以确保仅从事件中声明它需要的属性。</p><p>&nbsp;</p><p><code lang=\"null\">interface KeyboardShortcutEvent {\n  key: string;\n  metaKey: boolean;\n}\n\n\nfunction getKeyboardShortcut(e: KeyboardShortcutEvent) {}\n\n</code></p><p>&nbsp;</p><p>现在测试代码需要满足的条件大大收窄，处理起来自然更加轻松。</p><p>&nbsp;</p><p>函数与全局KeyboardEvent类型的耦合也更少，且能够在更多上下文中使用。换言之，灵活性得到显著提升。</p><p>&nbsp;</p><p>而这一切之所以可行，显然要归功于结构类型。作为后者的超集，KeyboardEvent可被分配给KeyboardShortcutEvent，这就回避了KeyboardEvent中的37个不相关属性。</p><p>&nbsp;</p><p><code lang=\"null\">window.addEventListener(\"keydown\", (e: KeyboardEvent) =&gt; {\n  const shortcut = getKeyboardShortcut(e); // This is OK!\n  if (shortcut) {\n    execShortcut(shortcut);\n  }\n});\n\n</code></p><p>&nbsp;</p><p></p><h5>原文链接：</h5><p></p><p></p><p><a href=\"https://alexharri.com/blog/typescript-structural-typing\">https://alexharri.com/blog/typescript-structural-typing</a>\"</p><p></p><h5>&nbsp;相关阅读：</h5><p></p><p></p><p><a href=\"https://xie.infoq.cn/article/6ff79700fb3bfa972c1beebf3\">TypeScript 与 JavaScript：你应该知道的区别</a>\"</p><p><a href=\"https://www.infoq.cn/article/dDXbcLHT7teNYSPL3sm7\">“TypeScript 不值得！”前端框架 Svelte 作者宣布重构代码，反向迁移到 JavaScript 引争议</a>\"</p><p><a href=\"https://xie.infoq.cn/article/b7f556a866805cf5c71be7af8\">Typescript- 类型检测和变量的定义</a>\"</p><p><a href=\"https://xie.infoq.cn/article/5cf66bfa800154e86868a1849\">理论 + 实践：从原型链到继承模式，掌握 Object 的精髓 </a>\"</p>",
    "publish_time": "2023-08-28 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "“视象新生”火山引擎视频云 & AIGC 技术大会",
    "url": "https://www.infoq.cn/article/qG430Mt6jRohJ6eVYbkf",
    "summary": "<p>8 月 22 日，由火山引擎与 NVIDIA 联合举办的“火山引擎视频云 &amp;AIGC 技术大会”圆满落幕！本次大会以“视象新生”为主题，聚焦体验创新，火山引擎视频云将携手投资机构、意见领袖、合作伙伴、行业代表，共话全行业视频化时代新趋势，视频技术新边界，视频化普惠新进程和场景融合新体验，驱动企业创新增长。</p>",
    "publish_time": "2023-08-28 10:24:57",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "探秘金融大模型与AIGC新浪潮：QCon 2023 北京站闭门交流会，你准备好了吗？",
    "url": "https://www.infoq.cn/article/JZCu0u5R4LUatr0Fgxqg",
    "summary": "<p>有没有觉得最近金融科技和人工智能的发展简直是翻天覆地？如果你也像我一样对这些话题充满好奇和热情，那么我有个好消息要告诉你！在今年的 <a href=\"https://qcon.infoq.cn/202309/beijing/schedule\">QCon 2023 全球软件开发大会</a>\"（北京） 上，我们准备了两场非常硬核的闭门交流会，专门深挖这两个领域的前沿问题。</p><p>&nbsp;</p><p>这不是一场普通的讲座，而是一个真正能让你触摸到行业脉搏，和大咖近距离交流的平台。我们将一起探讨金融领域如何更好地运用大模型，以及在AIGC浪潮下如何提升研发效能。</p><p>&nbsp;</p><p>如果你对这些话题有兴趣，或者想要在这两个领域有所突破，千万不要错过这次机会！赶快继续往下看，了解更多详情吧！</p><p></p><h3>闭门交流会详细信息</h3><p></p><p>时间：9&nbsp;月&nbsp;3&nbsp;日下午&nbsp;14:00-18:00</p><p>地点：北京·富力万丽酒店</p><p>议程安排：</p><p>主题一：金融领域落地大模型落地探索时间：14:00-15:40话题介绍：在当今的金融领域，大模型不仅是一种技术趋势，更是推动金融创新和颠覆性变革的核心力量。随着大数据和算法的不断进步，如何高效地在金融领域落地这些大模型，已经成为行业的重要议题。子话题：金融大模型的核心技术与应用趋势。金融领域的数据挑战：如何训练和部署大模型。大模型在金融风控、量化交易和客户服务中的实际案例。金融大模型的伦理和合规性问题。主题二：AIGC&nbsp;浪潮下的研发效能提升时间：16:20-18:00话题介绍：AIGC&nbsp;浪潮为技术研发带来了前所未有的机遇，同时也伴随着巨大的挑战。在这个时代，如何提升研发效能，不仅关乎组织的竞争力，更关乎未来的可持续发展。子话题：AIGC浪潮的核心驱动因素与研发趋势。研发团队如何应对AIGC的技术挑战。AIGC在产品迭代、质量保证和持续集成中的作用。提升研发团队的协作和响应速度：最佳实践与工具。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d7/d7e2b72e12ddac9c386890e3144c0bfb.jpeg\" /></p><p></p><p>我们诚挚地邀请您参与这两场闭门交流会，与行业内的专家和先驱们一同探讨、交流和学习。无论您是金融领域的从业者，还是对AIGC和研发效能感兴趣的技术人员，这里都将是一个难得的学习和交流平台。</p><p></p><h3>报名方式</h3><p></p><p>本次闭门交流会专为QCon的购票观众量身定制。如果您对这场高端交流充满期待，赶紧<a href=\"https://chat.openai.com/?model=gpt-4-plugins#\">点击这里</a>\"进行报名吧！不仅能体验三天的激情碰撞和知识分享，还有机会与行业大咖进行面对面的深度对话。</p><p></p><h3>结语</h3><p></p><p>在这个快速发展和不断变革的时代，让我们一同把握机会，探索未来，共同推动行业的进步和发展。期待在 <a href=\"https://qcon.infoq.cn/202309/beijing/schedule\">QCon 2023 全球软件开发大会</a>\" 相见。</p><p>&nbsp;</p>",
    "publish_time": "2023-08-28 10:40:19",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]