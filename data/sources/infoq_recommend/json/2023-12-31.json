[
  {
    "title": "2024年，你应该知道的5种React设计模式",
    "url": "https://www.infoq.cn/article/LKQoKOpYBOHt8Y444skv",
    "summary": "<p>如果你在开发工作中使用的是React框架，那么首当其冲要学习的就是思考如何设计组件。组件设计并非简单地将多个组件合成一个集合，而是需要思考如何设计更小、复用性更强的组件。例如，思考下面这张组件图：</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/15/157e528ec457fc0f38830381f53a9604.png\" /></p><p>&nbsp;</p><p><a href=\"https://bit.cloud/showoff/design/~graph\">简化的组件图</a>\"</p><p>&nbsp;</p><p>图中有三个组件，分别是：</p><p>&nbsp;</p><p>Typography组件Footer组件Sizeable Box组件</p><p>&nbsp;</p><p>如图所示，Typography组件同时被Footer和Sizeable Box组件使用。通常我们以为这样，就能构建一个简单、易维护和易排除错误的应用了。但其实只是这样思考组件的设计是远远不够的。</p><p>&nbsp;</p><p>如果你知道如何从组件的视角思考问题，就可以通过在React组件中使用设计模式来提高代码的整体模块性、可扩展性和可维护性。</p><p>&nbsp;</p><p>因此，下面这五种设计模式，是你在使用React时必须要掌握的。</p><p>&nbsp;</p><p></p><h2>模式一：基础组件</h2><p></p><p></p><p>首先，在使用React时候，请尝试为应用设计基础组件。</p><p>&nbsp;</p><p><a href=\"https://blog.bitsrc.io/how-to-build-better-react-components-in-2024-2d930b1f30b1\">基础UI组件</a>\"，就是一个具备默认行为且支持定制化的组件。</p><p>&nbsp;</p><p>例如，每个应用都会通过基础的样式、按钮设计或者基础的排版，来实现应用在视觉和交互上的一致性。这些组件的设计特点是：</p><p>&nbsp;</p><p>组件会应用一组默认的配置。因此，使用者无需进行任何额外的配置，就可以快速基于默认配置使用组件。组件可以支持定制化，使用者通过定制化可以覆盖组件的默认行为，从而为组件提供自定义的整体视觉和交互效果。</p><p>&nbsp;</p><p>通过一个Button组件就能很好地说明基础组件模式的实现。示例如下：</p><p>&nbsp;</p><p>Button组件可能会有诸如空心、实心等不同形态。Button组件可能会有默认的文本。</p><p>&nbsp;</p><p>现在你就可以利用基础组件模式进行设计，使组件的使用者可以改变其行为。<a href=\"https://bit.cloud/lakinduhewa/react-design-patterns/base/button\">请参考我基于基础组件模式完成的Button组件</a>\"，示例代码如下：</p><p>&nbsp;</p><p><code lang=\"null\">import React, { ButtonHTMLAttributes } from 'react';\n\n\n// 按钮组件的形态：实心或者空心\ntype ButtonVariant = 'filled' | 'outlined';\n\n\nexport type ButtonProps = {\n  /**\n   * the variant of the button to use \n   * @default 'outlined'\n   */\n  variant?: ButtonVariant;\n} &amp; ButtonHTMLAttributes;;\n\n\nconst ButtonStyles: { [key in ButtonVariant]: React.CSSProperties } = {\n  filled: {\n    backgroundColor: 'blue', // Change this to your filled button color\n    color: 'white',\n  },\n  outlined: {\n    border: '2px solid blue', // Change this to your outlined button color\n    backgroundColor: 'transparent',\n    color: 'blue',\n  },\n};\n\n\nexport function Button({ variant = 'outlined', children, style, ...rest }: ButtonProps) {\n  return (\n    <button type=\"button\">\n      {children}\n    </button>\n  );\n}</code></p><p>&nbsp;</p><p>仔细观察代码会发现，这里Button组件的props类型合并了原生HTML中button标签属性的全部类型。这意味着，使用者除了可以为Button组件设置默认配置外，还可以设置诸如onClick、aria-label等自定义配置。这些自定义配置会通过扩展运算符传递给Button组件内部的button标签。</p><p>&nbsp;</p><p>通过不同的上下文设置，可以看到不同的Button组件的形态，效果截图如下图。</p><p>&nbsp;</p><p>这个可以查看具体设置：</p><p><a href=\"https://bit.cloud/lakinduhewa/react-design-patterns/base/button/~compositions\">https://bit.cloud/lakinduhewa/react-design-patterns/base/button/~compositions</a>\"</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/3b/3b2238b4f5a28309198066a57557b80a.png\" /></p><p>&nbsp;</p><p>基础组件在不同上下文中的使用效果</p><p>&nbsp;</p><p>通过不同的上下文，你可以设定组件的行为。这可以让组件成为更大组件的基础。</p><p>&nbsp;</p><p></p><h2>模式二：组合组件</h2><p></p><p>&nbsp;</p><p>在成功创建了基础组件后，你可能会希望基于基础组件创建一些新的组件。</p><p>&nbsp;</p><p>例如，你可以使用之前创建的Button组件来实现一个标准的DeleteButton组件。通过在应用中使用该DeleteButton，可以让应用中所有删除操作在颜色、形态以及字体上保持一致。</p><p>&nbsp;</p><p>不过，如果出现重复组合一组组件来实现相同效果的现象，那么你可以考虑将它们封装到一个组件中。</p><p>&nbsp;</p><p><a href=\"https://bit.cloud/lakinduhewa/react-design-patterns/composition/delete-button\">下面，让我们来看看其中一种实现方案：</a>\"</p><p><a href=\"https://bit.cloud/lakinduhewa/react-design-patterns/composition/delete-button\">https://bit.cloud/lakinduhewa/react-design-patterns/composition/delete-button</a>\"</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/4b/4bcbf9c58d8763d7ecea22e5ec7fa756.png\" /></p><p>&nbsp;</p><p></p><p>使用组合模式创建组件</p><p>&nbsp;</p><p>如上面的<a href=\"https://bit.cloud/lakinduhewa/react-design-patterns/composition/delete-button/~graph\">组件依赖图</a>\"所示，DeleteButton组件使用基础的Button组件为所有与删除相关的操作提供标准的实现。下面是基本代码实现：</p><p>&nbsp;</p><p><code lang=\"null\">// 这里引入了，基础按钮组件和其props\nimport { Button, ButtonProps } from '@lakinduhewa/react-design-patterns.base.button';\nimport React from 'react';\n\n\nexport type DeleteButtonProps = {} &amp; ButtonProps;\n\n\nexport function DeleteButton({ ...rest }: DeleteButtonProps) {\n  return (\n    <button>\n      DELETE\n    </button>\n  );\n}</code></p><p>&nbsp;</p><p>我们使用基于模式一创建的Button组件来实现的DeleteButton组件的效果如下：</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/53/537cba69cec820d758f54696c34a1d6a.png\" /></p><p>&nbsp;</p><p></p><p>现在我们可以在应用中使用统一的删除按钮。此外，如果你使用类似Bit的构建系统进行组件的设计和构建，那么当Button组件发生改变时，可以让<a href=\"https://bit.cloud/lakinduhewa/react-design-patterns/~ripple-ci/job/lakinduhewa-main-tlP1aG7L0\">CI服务自动将此改变传递到DeleteButton组件</a>\"上，就像下面这样（当Button组件从0.0.3升级到了0.0.4，那么CI服务会自动触发，将DeleteButton组件从0.0.1升级到0.0.2）：</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/d2/d24bc0ef23fab4865cf0cfa08c6c522d.png\" /></p><p>Bit上的一个CI构建</p><p></p><p>&nbsp;</p><p></p><h2>模式三：使用Hooks</h2><p></p><p></p><p>React Hooks 是<a href=\"https://legacy.reactjs.org/docs/hooks-overview.html\">React v16</a>\"就推出来的特性，它不依赖类组件实现状态管理、负效应等概念。简而言之，就是你可以通过利用Hooks API摆脱对类组件的使用需求。useSate和useEffect是最广为人知的两个Hooks API，但本文不打算讨论它们，我想重点讨论如何利用Hooks来提高组件的整体可维护性。</p><p>&nbsp;</p><p>例如，请考虑下面这个场景：</p><p>&nbsp;</p><p>有一个BlogList组件。BlogList组件会通过调用一个简单的API，获取博客文章列表数据，同时将其渲染在组件上。</p><p>&nbsp;</p><p>基于上面的案例，你可能会像下面这样将API逻辑直接写在函数组件中：</p><p>&nbsp;</p><p><code lang=\"null\">import React, { useState, useEffect } from 'react';\nimport axios from 'axios';\nconst BlogList = () =&gt; {\n    const [blogs, setBlogs] = useState([]);\n    const [isLoading, setIsLoading] = useState(true);\n    const [error, setError] = useState(null);\n    useEffect(() =&gt; {\n        axios.get('https://api.example.com/blogs')\n            .then(response =&gt; {\n                setBlogs(response.data);\n                setIsLoading(false);\n            })\n            .catch(error =&gt; {\n                setError(error);\n                setIsLoading(false);\n            });\n    }, []);\n    if (isLoading) return </code></p><div><code lang=\"null\">Loading...</code></div><code lang=\"null\">;\n    if (error) return <div>Error: {error.message}</div>;\n    return (\n        <div>\n            <h2>Blog List</h2>\n            <ul>\n                {blogs.map(blog =&gt; (\n                    <li>{blog.title}</li>\n                ))}\n            </ul>\n        </div>\n    );\n};\nexport default BlogList;</code><p></p><p>&nbsp;</p><p>这样写，组件也能正常工作。它将会获取博客文章列表并且渲染在UI上。但是，这里将UI逻辑和API逻辑混在一起了。</p><p>&nbsp;</p><p>理想情况下，React组件应该不需要关系如何获取数据。而只需要关心接收一个数据数组，然后将其呈现在DOM上。</p><p>&nbsp;</p><p>因此，实现这一目标的最佳方法是将API逻辑抽象到React Hook中，以便在组件内部进行调用。这样做就可以打破API调用与组件之间的耦合。通过这种方式，就可以在不影响组件的情况下，修改底层的数据获取逻辑。</p><p>&nbsp;</p><p>其中一种实现方式如下。</p><p>&nbsp;</p><p></p><h3>1.useBlog hook</h3><p></p><p></p><p><code lang=\"null\">import { useEffect, useState } from 'react';\nimport { Blog } from './blog.type';\nimport { Blogs } from './blog.mock';\n\n\nexport function useBlog() {\n  const [blogs, setBlogs] = useState([]);\n  const [loading, setLoading] = useState(false);\n\n\n  useEffect(() =&gt; {\n    setLoading(true);\n     // 注意：这里的setTimeout非实际需要，只是为了模拟API调用\n    setTimeout(() =&gt; {\n      setBlogs(Blogs);\n      setLoading(false);\n    }, 3000);\n  }, []);\n\n\n  return { blogs, loading }\n}</code></p><p>&nbsp;</p><p>如上代码所示，useBlog hook获取博客列表数据，然后赋值给状态变量，最后通过导出变量给到消费者（BlogList组件）使用：</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/e0/e06bc1effc8224cbaf6608ebce84e560.png\" /></p><p>&nbsp;</p><p></p><p>Hook效果</p><p>&nbsp;</p><p></p><h3>2.BlogList组件</h3><p></p><p></p><p><code lang=\"null\">import React from 'react';\n// 引入上面封装的 useBlog hook\nimport { useBlog } from '@lakinduhewa/react-design-patterns.hooks.use-blog';\nexport function BlogList() {\n  const { blogs, loading } = useBlog();\n  if (loading) {\n    return (\n      </code></p><p><code lang=\"null\">We are loading the blogs...</code></p><code lang=\"null\">\n    )\n  }\n  return (\n    <ul>\n      {blogs.map((blog) =&gt; <ol>\n        {blog.title}\n      </ol>)}\n    </ul>\n  );\n}</code><p></p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/fb/fb76665bd10e4984c973efde8e4841ed.png\" /></p><p></p><p>&nbsp;</p><p>BlogList组件效果</p><p>&nbsp;</p><p>通过调用useBlog和使用其导出的状态变量，我们在BlogList组件中使用了Hooks。如此，相对于之前，我们可以减少大量代码，并以最少的代码和精力维护两个组件。</p><p>&nbsp;</p><p>此外，当你使用类似Bit这样的构建系统时（就像我一样），只需将useBlog组件导入本地开发环境，然后再修改完成之后重新推送回Bit Cloud。Bit Cloud的构建服务器可以依托依赖树将此修改传递给整个应用。因此如果只执行一些简单修改，甚至不需要访问整个应用。</p><p>&nbsp;</p><p></p><h2>模式四：React Providers</h2><p></p><p></p><p>此模式的核心是解决组件状态共享。我们都曾是props下钻式传递的受害者。但如果你还没有经历过，那这里简单解释下：“props下钻式传递”就是当你在组件树中进行props传递时，这些props只会在最底层组件中被使用，而中间层的组件都不会使用该props。例如，看看下面这张图：</p><p><img src=\"https://static001.geekbang.org/infoq/05/052de38f4635336ef1c6dd038b4abe31.png\" /></p><p>props下钻式传递</p><p></p><p>&nbsp;</p><p>从BlogListComponent一直向下传递一个isLoading的props到Loader。但是，isLoading只在Loader组件中使用。因此，在这种情况下，组件不但会引入不必要的props，还会有性能开销。因为当isLoading发生变化时，即使组件没有使用它，React依然会重新渲染你的组件树。</p><p>&nbsp;</p><p>因此，解决方案之一就是通过利用React Context来使用React Context Provider模式。React Context是一组组件的状态管理器，通过它，你可以为一组组件创建特定的上下文。通过这种方式，你可以在上下文中定义和管理状态，让不同层级的组件都可以直接访问上下文，并按需使用props。这样就可以避免props下钻式传递了。</p><p>&nbsp;</p><p>主题组件就是该模式的一个常见场景。例如，你需要在应用程序中全局访问主题。但将主题传递到应用中的每个组件并不现实。你可以创建一个包含主题信息的Context，然后通过Context来设置主题。看一下<a href=\"https://bit.cloud/lakinduhewa/react-design-patterns/contexts/consumer-component\">我是如何通过React Context实现主题</a>\"的，以便更好地理解这一点：</p><p><a href=\"https://bit.cloud/lakinduhewa/react-design-patterns/contexts/consumer-component\">https://bit.cloud/lakinduhewa/react-design-patterns/contexts/consumer-component</a>\"</p><p>&nbsp;</p><p><code lang=\"null\">import { useContext, createContext } from 'react';\nexport type SampleContextContextType = {\n  /**\n   * primary color of theme.\n   */\n  color?: string;\n};\nexport const SampleContextContext = createContext({\n  color: 'aqua'\n});\nexport const useSampleContext = () =&gt; useContext(SampleContextContext);</code></p><p>&nbsp;</p><p>在Context中定义了一种主题颜色，它将在所有实现中使用该颜色来设置字体颜色。接下来，我还导出了一个hook——useSampleContext，该hook让消费者可以直接使用Context。</p><p>&nbsp;</p><p>只是这样还不行，我们还需要定义一个Provider。Provider是回答 \"我应该与哪些组件共享状态？\"问题的组件。<a href=\"https://bit.cloud/lakinduhewa/react-design-patterns/contexts/sample-context/~code/sample-context-context-provider.tsx\">Provider的实现示例如下：</a>\"</p><p>&nbsp;</p><p><code lang=\"null\">import React, { ReactNode } from 'react';\nimport { SampleContextContext } from './sample-context-context';\nexport type SampleContextProviderProps = {\n  /**\n   * primary color of theme.\n   */\n  color?: string,\n  /**\n   * children to be rendered within this theme.\n   */\n  children: ReactNode\n};\nexport function SampleContextProvider({ color, children }: SampleContextProviderProps) {\n  return {children}\n}</code></p><p>&nbsp;</p><p>Provider在管理初始状态和设置Context可访问状态的组件方面起着至关重要的作用。</p><p>&nbsp;</p><p>接下来，你可以创建一个<a href=\"https://bit.cloud/lakinduhewa/react-design-patterns/contexts/consumer-component\">消费者组件</a>\"来使用状态：</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/49/491455537d509ef21169e065110a7f78.png\" /></p><p>&nbsp;</p><p></p><p>消费者组件</p><p>&nbsp;</p><p></p><h2>模式五：条件渲染</h2><p></p><p></p><p>最后一个想和大家分享的是条件渲染模式。今天，人人都知道React中的条件渲染。它通过条件判断来选择组件进行渲染。</p><p>&nbsp;</p><p>但在实际使用中我们的用法常常是错误的：</p><p>&nbsp;</p><p><code lang=\"null\">// ComponentA.js\nconst ComponentA = () =&gt; {\n    return </code></p><div><code lang=\"null\">This is Component A</code></div><code lang=\"null\">;\n};\n// ComponentB.js\nconst ComponentB = () =&gt; {\n    return <div>This is Component B</div>;\n};\n// ConditionalComponent.js\nimport React, { useState } from 'react';\nimport ComponentA from './ComponentA';\nimport ComponentB from './ComponentB';\nconst ConditionalComponent = () =&gt; {\n    const [toggle, setToggle] = useState(true);\n    return (\n        <div>\n            <button> setToggle(!toggle)}&gt;Toggle Component</button>\n            {toggle ?  : }\n        </div>\n    );\n};\nexport default ConditionalComponent;</code><p></p><p>&nbsp;</p><p>你是否注意到，这里我们将基于条件的逻辑耦合到了JSX代码片段中。通常，你不应该在JSX代码中中添加任何与计算相关的逻辑，而只将与UI渲染相关的内容放在其中。</p><p>&nbsp;</p><p>解决这个问题的方法之一是使用条件渲染组件模式。创建一个可重用的React组件，该组件可以根据条件渲染两个不同的组件。<a href=\"https://bit.cloud/lakinduhewa/react-design-patterns/base/conditional\">它的实现过程如下</a>\"：</p><p>&nbsp;</p><p><code lang=\"null\">import React, { ReactNode } from 'react';\nexport type ConditionalProps = {\n  /**\n   * the condition to test against\n   */\n  condition: boolean\n  /**\n   * the component to render when condition is true\n   */\n  whenTrue: ReactNode\n  /**\n   * the component to render when condition is false\n   */\n  whenFalse: ReactNode\n};\nexport function Conditional({ condition, whenFalse, whenTrue }: ConditionalProps) {\n  return condition ? whenTrue : whenFalse;\n}</code></p><p>&nbsp;</p><p>我们创建了一个可以按条件渲染两个组件的组件。当我们将其集成到其他组件中时，会使代码更简洁，因为无需在React组件中加入复杂的渲染逻辑。你可以像下面这样使用它：</p><p>&nbsp;</p><p><code lang=\"null\">export const ConditionalTrue = () =&gt; {\n  return (\n    \n  );\n}\nexport const ConditionalFalse = () =&gt; {\n  return (\n    \n  );\n}</code></p><p>&nbsp;</p><p>实际的输入如下：</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/00/00e4f51a0533efeb947a407b4e01a889.png\" /></p><p>&nbsp;</p><p></p><p></p><h2>总结</h2><p></p><p>&nbsp;</p><p>掌握这五种设计模式，为2024年做好充分准备，构建出可扩展和可维护的应用吧。</p><p>&nbsp;</p><p>如果你想详细深入本文中讨论的模式，<a href=\"https://bit.cloud/lakinduhewa/react-design-patterns\">请随时查看我在Bit Cloud的空间</a>\"：</p><p><a href=\"https://bit.cloud/lakinduhewa/react-design-patterns\">https://bit.cloud/lakinduhewa/react-design-patterns</a>\"</p><p>&nbsp;</p><p>感谢你的阅读！</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://blog.bitsrc.io/react-design-patterns-for-2024-5f2696868222\">https://blog.bitsrc.io/react-design-patterns-for-2024-5f2696868222</a>\"</p><p></p><p></p><h5>相关阅读：</h5><p></p><p></p><p><a href=\"https://www.infoq.cn/article/4ydKY3wbZDp7Eei0JJm1\">React&nbsp;JS 广受业界认可，高级开发者年薪百万</a>\"</p><p><a href=\"https://www.infoq.cn/article/Tv3SyqoivXMWUoj8qSMT\">从新&nbsp;React&nbsp;文档看未来 Web 的开发趋势</a>\"</p><p><a href=\"https://www.infoq.cn/article/CZKMjHaxbf1Z7xcSzisX\">我被&nbsp;React&nbsp;劫持了，很痛苦又离不开</a>\"</p><p><a href=\"http://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247516803&amp;idx=1&amp;sn=f584917f8afe2f7bb10f8686acb040cf&amp;chksm=f95237c0ce25bed6980bdc34c630cbda97d0325a489663440b4c904499ca81da31729d476476&amp;scene=27#wechat_redirect\">React&nbsp;开发者们的 Solid.js&nbsp;快速入门教程</a>\"</p>",
    "publish_time": "2023-12-31 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "阿里被判向京东赔偿10亿；要求销毁 ChatGPT，微软和 OpenAI被起诉；阿里云大调整：混合云部分团队裁员30%｜Q资讯",
    "url": "https://www.infoq.cn/article/Iq6xEIuN0a68X2fcXP7V",
    "summary": "<p></p><blockquote>阿里云再调整：混合云部分团队裁员30%，IoT业务线裁员50%；雷军回应小米汽车价格；京东宣布明年起一线业务人员年固定薪酬上涨近100%；杭州破获重大勒索病毒案：借助ChatGPT优化程序；谷歌创始人亲自给Gemini写代码；文心一言用户规模破1亿......</blockquote><p></p><p>&nbsp;</p><p></p><h2>科技公司</h2><p></p><p></p><h4>阿里“二选一”案败诉，被判赔偿京东10亿元</h4><p></p><p>&nbsp;</p><p>12月29日，北京市高级人民法院对京东诉浙江天猫网络有限公司、浙江天猫技术有限公司、阿里巴巴集团控股有限公司“二选一”案做出一审判决，认定其滥用市场支配地位实施“二选一”的垄断行为成立，对京东造成严重损害，并判决向京东赔偿10亿元。</p><p>&nbsp;</p><p>据公开报道，2013年，京东曾公开表态商家被阿里巴巴强迫“二选一”。2015年，因“二选一”政策引发商家广泛不满，京东向国家工商总局实名举报阿里巴巴。2017年，京东向北京市高级人民法院正式起诉阿里巴巴“二选一”；2019年，最高人民法院作出终审裁定，驳回阿里关于“管辖权异议”的请求，认定北京市高级人民法院对此案负责。</p><p>&nbsp;</p><p></p><h4>雷军回应小米汽车价格：9.9万不可能，“尊重一下科技”</h4><p></p><p>&nbsp;</p><p>12月28日，小米举行了小米汽车技术发布会，雷军针对智能驾驶、智能座驾、超级电机、电池以及一体化压铸五大核心技术进行了详细的讲解。</p><p>&nbsp;</p><p>此前行业内曾传言小米汽车首款车起售价14.9万元。雷军在讲解产品时表示，同等性能和配置的产品售价都在40万元以上，“不要再讲9.9万了，不可能的，也不要再讲14.9万，我们还是要尊重科技。”</p><p>&nbsp;</p><p>截至 2023 年二季度，小米汽车相关研发人员已接近 3000 人。近期，雷军在接受媒体采访时表示，小米第一辆车整体投入了3400名工程师，整个研发投入超过了100亿。</p><p>&nbsp;</p><p></p><h4>京东宣布明年起一线业务人员年固定薪酬上涨近100%</h4><p></p><p>&nbsp;</p><p>12月27日晚，京东集团宣布，2024年1月1日起京东采销等一线业务人员的年固定薪酬大幅上涨近100%，2024年初京东零售全员将平均加薪不低于20%。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/1e/1eeca2538b82a14a65b697b064cf0508.jpeg\" /></p><p></p><p>&nbsp;</p><p>综合媒体报道，这次调整逻辑主要是将京东零售所有线上业务人员的原月度绩效工资、浮动年终奖均增加到固定薪酬中，享受4倍月薪固定年终奖，调整后年度固定薪酬涨幅接近100%。此外，业务Boss单元额外按照同比改善幅度进行业绩提点，可获得上不封顶的业绩激励。提点方案将在2024年1月由各事业部公布。</p><p>&nbsp;</p><p>浮动绩效变为固定工资也算是落袋为安，变相提高了员工的基础待遇。这不是京东近两年来第一次调整薪资。去年11月22日，京东创始人刘强东在给全体员工的邮件中表示，要对员工和高管待遇推行“一升一降”措施。提高基层员工福利待遇，同时尽量减轻公司压力，自2023年1月1日起，京东集团高级管理人员的现金薪酬降低10%-20%不等，职位越高降得越多。</p><p>&nbsp;</p><p></p><h4>纽约时报起诉微软和 OpenAI 侵犯版权，索赔数十亿美元</h4><p></p><p>&nbsp;</p><p>美东时间 12 月 27 日，纽约时报以版权问题为由起诉微软和OpenAI，主要因为这两家公司未经授权而使用《纽约时报》所发表的作品来培训其AI技术。《纽约时报》也成为了第一家起诉这些AI公司的美国大型媒体机构。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/59/59d8600dad8b2ba06e00eb00c594a6fa.png\" /></p><p></p><p>&nbsp;</p><p>《纽约时报》在起诉书中称，其所发表的数百万篇文章被OpenAI和微软用来训练其自动聊天机器人，而这些机器人现在又作为可靠信息的来源，与《纽约时报》相竞争。递交法院的文件显示，纽约时报寻求让微软和 OpenAI 承担“数十亿美元的法定损害赔偿和实际损失”。</p><p>&nbsp;</p><p>《纽约时报》还敦促 OpenAI 和微软销毁任何使用《纽约时报》版权材料的聊天机器人模型和训练数据。</p><p>&nbsp;</p><p></p><h4>杭州破获重大勒索病毒案：借助ChatGPT优化程序</h4><p></p><p>&nbsp;</p><p>据人民日报消息，杭州上城区网警近日破获一起重大勒索病毒案件，犯罪团伙成员均有网络安防相关资质，且在实施犯罪过程中借助ChatGPT进行程序优化。</p><p>&nbsp;</p><p>11月20日，上城网警接到辖区某公司报案称，该公司名下相关服务器遭勒索病毒攻击，导致公司所有系统无法正常运行，对方勒索2万USDT（泰达币）。警方随即组建技术攻坚团队开展侦查。专案组对被攻击服务器进行细致勘验、提取木马程序进行分析和对嫌疑人勒索使用的虚拟币地址进行多维度研判，成功锁定2名犯罪嫌疑人。</p><p>&nbsp;</p><p>11月30日，专案组在内蒙古自治区呼和浩特市成功抓获韩某、祁某，并于次日在北京抓获2名同案犯罪嫌疑人李某、郝某。至此，该团伙4名犯罪嫌疑人全部落网。</p><p>&nbsp;</p><p>该团伙4人均有网络安防相关资质，且有供职大型网络科技公司经历。他们对分工负责编写勒索病毒版本、借助ChatGPT进行程序优化、开展漏洞扫描、渗透获取权限、植入勒索病毒、实施敲诈勒索的犯罪事实供认不讳。</p><p>&nbsp;</p><p></p><h4>华为内部人士称PC鸿蒙系统接近完成</h4><p></p><p>&nbsp;</p><p>据媒体报道，从华为内部人士处了解到，除手机鸿蒙之外，PC端的鸿蒙操作系统已经接近完成。此前华为被曝出2024年发布鸿蒙PC端系统，而鸿蒙更加独立、走向更多终端也意味着华为手机的稳定基本盘和加速回归。</p><p>&nbsp;</p><p>此前报道，曾担任华为终端BG软件部总裁、华为消费者业务AI与智慧全场景业务部总裁的王成录博士在被问及明年是否有PC端鸿蒙系统时回复了一个“有”字，也就是说，最快明年就可以在市面上看到鸿蒙PC。</p><p>&nbsp;</p><p></p><h4>阿里云再调整：混合云部分团队裁员30%，IoT业务线裁员50%</h4><p></p><p>&nbsp;</p><p>据晚点报道，阿里云正在裁减为政企客户定制行业解决方案的项目制业务，并在 IoT（物联网）业务线砍掉硬件集成业务并缩减相关人员。混合云事业部部分团队裁员比例达到 30%。IoT 硬件集成业务裁员比例超 50%，该部门剩下的人员将被打散并至其他业务。</p><p>&nbsp;</p><p>同时，阿里云正扩大公共云事业部和 AI 部门的招聘。阿里云招聘官网目前在招岗位约 500 个，人数超 1500 人。</p><p>&nbsp;</p><p>通过调整，阿里云希望抓住新机会，重回快速增长轨道，调整后公共云成为战略重点。在三季度的财报电话会上，阿里巴巴集团 CEO 和阿里云智能集团 CEO 吴泳铭说，阿里云的战略定位是：“AI 驱动、公共云优先。”</p><p>&nbsp;</p><p></p><h2>IT业界</h2><p></p><p>&nbsp;</p><p>&nbsp;</p><p></p><h4>谷歌创始人亲自给Gemini写代码</h4><p></p><p>&nbsp;</p><p>据报道，谷歌联合创始人谢尔盖·布林（Sergey Brin）出现在谷歌最新大招Gemini大模型的核心贡献者名单中。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/22/22048b516ca17eaa5cda4516046fb131.jpeg\" /></p><p></p><p>今年布林已50岁，坐拥千亿身家还在第一线奋战，这事在𝕏上一经发布，即刻引来大量关注。有Gemini开发人员回应这个消息时说，“这个名单是随机排列的，实际上他每天跟我们待在一起，经常结对编程。”</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/83/83943f2f41a1e135c2102a1de55eff18.jpeg\" /></p><p></p><p>&nbsp;</p><p>Sergey Brin显然是该项目的实际编码人员，网友感叹：“无论身价多少，工程师本质上就是工程师，没有什么可以削弱这一点。”</p><p>&nbsp;</p><p>&nbsp;</p><p></p><h4>文心一言用户规模破1亿</h4><p></p><p>&nbsp;</p><p>“文心一言用户规模突破1亿。”12 月 28 日，百度首席技术官、深度学习技术及应用国家工程研究中心主任王海峰在第十届 WAVE SUMMIT 深度学习开发者大会上宣布。自 8 月 31 日获准开放对公众提供服务以来，文心一言的用户提问量一路上扬，基本与文心大模型的效果提升同步。越来越多的用户在信任和使用文心一言。</p><p>&nbsp;</p><p></p><h4>OpenAI发布GPT提示词工程指南</h4><p></p><p>&nbsp;</p><p><a href=\"https://openai.com/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM4MzQ2MzIsImZpbGVHVUlEIjoiTDlrQkJqUW5ncnUycnhrSyIsImlhdCI6MTcwMzgzNDMzMiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo1MDA3OTEyfQ.bgxK9HZlgzZ5CgqnrTxFb7TgqZVLiGAPCxECbfK6XoQ\">OpenAI</a>\"最近发布了一份提示词工程指南。该指南列出了六种策略，旨在从GPT模型获得更好的响应，并着重关注<a href=\"https://openai.com/gpt-4?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM4MzQ2MzIsImZpbGVHVUlEIjoiTDlrQkJqUW5ncnUycnhrSyIsImlhdCI6MTcwMzgzNDMzMiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo1MDA3OTEyfQ.bgxK9HZlgzZ5CgqnrTxFb7TgqZVLiGAPCxECbfK6XoQ\">GPT-4</a>\"的示例。</p><p>&nbsp;</p><p>该指南的六个高级策略包括：撰写清晰的说明、提供参考文本、将复杂任务分解为更简单的子任务、给模型时间“思考”、使用外部工具以及系统性地测试变更。每个策略都被细分为一组具体可行的 策略，并附有示例提示词。许多策略都基于LLM（语言模型）研究的结果，例如<a href=\"https://en.wikipedia.org/wiki/Prompt_engineering#Chain-of-thought?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM4MzQ2MzIsImZpbGVHVUlEIjoiTDlrQkJqUW5ncnUycnhrSyIsImlhdCI6MTcwMzgzNDMzMiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo1MDA3OTEyfQ.bgxK9HZlgzZ5CgqnrTxFb7TgqZVLiGAPCxECbfK6XoQ\">链式思维提示词</a>\"或<a href=\"https://openai.com/research/summarizing-books?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM4MzQ2MzIsImZpbGVHVUlEIjoiTDlrQkJqUW5ncnUycnhrSyIsImlhdCI6MTcwMzgzNDMzMiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo1MDA3OTEyfQ.bgxK9HZlgzZ5CgqnrTxFb7TgqZVLiGAPCxECbfK6XoQ\">递归摘要</a>\"。</p><p>&nbsp;</p><p>其他几个LLM提供商也都有提供提示词工程技巧。Microsoft Azure将访问GPT模型作为一种服务，他们提供了与OpenAI类似的<a href=\"https://learn.microsoft.com/en-us/azure/ai-services/openai/concepts/advanced-prompt-engineering?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM4MzQ2MzIsImZpbGVHVUlEIjoiTDlrQkJqUW5ncnUycnhrSyIsImlhdCI6MTcwMzgzNDMzMiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo1MDA3OTEyfQ.bgxK9HZlgzZ5CgqnrTxFb7TgqZVLiGAPCxECbfK6XoQ\">技巧清单</a>\"。他们的指南还提供了有关设置模型参数（例如温度和top_p）的技巧，这些参数控制模型输出生成的随机性。谷歌的<a href=\"https://www.infoq.com/news/2023/12/google-launches-gemini/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM4MzQ2MzIsImZpbGVHVUlEIjoiTDlrQkJqUW5ncnUycnhrSyIsImlhdCI6MTcwMzgzNDMzMiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo1MDA3OTEyfQ.bgxK9HZlgzZ5CgqnrTxFb7TgqZVLiGAPCxECbfK6XoQ\">Gemini</a>\" API文档包含了几种<a href=\"https://ai.google.dev/docs/prompt_best_practices?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE3MDM4MzQ2MzIsImZpbGVHVUlEIjoiTDlrQkJqUW5ncnUycnhrSyIsImlhdCI6MTcwMzgzNDMzMiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo1MDA3OTEyfQ.bgxK9HZlgzZ5CgqnrTxFb7TgqZVLiGAPCxECbfK6XoQ\">提示词设计策略</a>\"，以及有关设置top_p和温度值的建议。</p>",
    "publish_time": "2023-12-31 11:57:50",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]