[
  {
    "title": "2024年，你应该知道的5种React设计模式",
    "url": "https://www.infoq.cn/article/LKQoKOpYBOHt8Y444skv",
    "summary": "<p>如果你在开发工作中使用的是React框架，那么首当其冲要学习的就是思考如何设计组件。组件设计并非简单地将多个组件合成一个集合，而是需要思考如何设计更小、复用性更强的组件。例如，思考下面这张组件图：</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/15/157e528ec457fc0f38830381f53a9604.png\" /></p><p>&nbsp;</p><p><a href=\"https://bit.cloud/showoff/design/~graph\">简化的组件图</a>\"</p><p>&nbsp;</p><p>图中有三个组件，分别是：</p><p>&nbsp;</p><p>Typography组件Footer组件Sizeable Box组件</p><p>&nbsp;</p><p>如图所示，Typography组件同时被Footer和Sizeable Box组件使用。通常我们以为这样，就能构建一个简单、易维护和易排除错误的应用了。但其实只是这样思考组件的设计是远远不够的。</p><p>&nbsp;</p><p>如果你知道如何从组件的视角思考问题，就可以通过在React组件中使用设计模式来提高代码的整体模块性、可扩展性和可维护性。</p><p>&nbsp;</p><p>因此，下面这五种设计模式，是你在使用React时必须要掌握的。</p><p>&nbsp;</p><p></p><h2>模式一：基础组件</h2><p></p><p></p><p>首先，在使用React时候，请尝试为应用设计基础组件。</p><p>&nbsp;</p><p><a href=\"https://blog.bitsrc.io/how-to-build-better-react-components-in-2024-2d930b1f30b1\">基础UI组件</a>\"，就是一个具备默认行为且支持定制化的组件。</p><p>&nbsp;</p><p>例如，每个应用都会通过基础的样式、按钮设计或者基础的排版，来实现应用在视觉和交互上的一致性。这些组件的设计特点是：</p><p>&nbsp;</p><p>组件会应用一组默认的配置。因此，使用者无需进行任何额外的配置，就可以快速基于默认配置使用组件。组件可以支持定制化，使用者通过定制化可以覆盖组件的默认行为，从而为组件提供自定义的整体视觉和交互效果。</p><p>&nbsp;</p><p>通过一个Button组件就能很好地说明基础组件模式的实现。示例如下：</p><p>&nbsp;</p><p>Button组件可能会有诸如空心、实心等不同形态。Button组件可能会有默认的文本。</p><p>&nbsp;</p><p>现在你就可以利用基础组件模式进行设计，使组件的使用者可以改变其行为。<a href=\"https://bit.cloud/lakinduhewa/react-design-patterns/base/button\">请参考我基于基础组件模式完成的Button组件</a>\"，示例代码如下：</p><p>&nbsp;</p><p><code lang=\"null\">import React, { ButtonHTMLAttributes } from 'react';\n\n\n// 按钮组件的形态：实心或者空心\ntype ButtonVariant = 'filled' | 'outlined';\n\n\nexport type ButtonProps = {\n  /**\n   * the variant of the button to use \n   * @default 'outlined'\n   */\n  variant?: ButtonVariant;\n} &amp; ButtonHTMLAttributes;;\n\n\nconst ButtonStyles: { [key in ButtonVariant]: React.CSSProperties } = {\n  filled: {\n    backgroundColor: 'blue', // Change this to your filled button color\n    color: 'white',\n  },\n  outlined: {\n    border: '2px solid blue', // Change this to your outlined button color\n    backgroundColor: 'transparent',\n    color: 'blue',\n  },\n};\n\n\nexport function Button({ variant = 'outlined', children, style, ...rest }: ButtonProps) {\n  return (\n    <button type=\"button\">\n      {children}\n    </button>\n  );\n}</code></p><p>&nbsp;</p><p>仔细观察代码会发现，这里Button组件的props类型合并了原生HTML中button标签属性的全部类型。这意味着，使用者除了可以为Button组件设置默认配置外，还可以设置诸如onClick、aria-label等自定义配置。这些自定义配置会通过扩展运算符传递给Button组件内部的button标签。</p><p>&nbsp;</p><p>通过不同的上下文设置，可以看到不同的Button组件的形态，效果截图如下图。</p><p>&nbsp;</p><p>这个可以查看具体设置：</p><p><a href=\"https://bit.cloud/lakinduhewa/react-design-patterns/base/button/~compositions\">https://bit.cloud/lakinduhewa/react-design-patterns/base/button/~compositions</a>\"</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/3b/3b2238b4f5a28309198066a57557b80a.png\" /></p><p>&nbsp;</p><p>基础组件在不同上下文中的使用效果</p><p>&nbsp;</p><p>通过不同的上下文，你可以设定组件的行为。这可以让组件成为更大组件的基础。</p><p>&nbsp;</p><p></p><h2>模式二：组合组件</h2><p></p><p>&nbsp;</p><p>在成功创建了基础组件后，你可能会希望基于基础组件创建一些新的组件。</p><p>&nbsp;</p><p>例如，你可以使用之前创建的Button组件来实现一个标准的DeleteButton组件。通过在应用中使用该DeleteButton，可以让应用中所有删除操作在颜色、形态以及字体上保持一致。</p><p>&nbsp;</p><p>不过，如果出现重复组合一组组件来实现相同效果的现象，那么你可以考虑将它们封装到一个组件中。</p><p>&nbsp;</p><p><a href=\"https://bit.cloud/lakinduhewa/react-design-patterns/composition/delete-button\">下面，让我们来看看其中一种实现方案：</a>\"</p><p><a href=\"https://bit.cloud/lakinduhewa/react-design-patterns/composition/delete-button\">https://bit.cloud/lakinduhewa/react-design-patterns/composition/delete-button</a>\"</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/4b/4bcbf9c58d8763d7ecea22e5ec7fa756.png\" /></p><p>&nbsp;</p><p></p><p>使用组合模式创建组件</p><p>&nbsp;</p><p>如上面的<a href=\"https://bit.cloud/lakinduhewa/react-design-patterns/composition/delete-button/~graph\">组件依赖图</a>\"所示，DeleteButton组件使用基础的Button组件为所有与删除相关的操作提供标准的实现。下面是基本代码实现：</p><p>&nbsp;</p><p><code lang=\"null\">// 这里引入了，基础按钮组件和其props\nimport { Button, ButtonProps } from '@lakinduhewa/react-design-patterns.base.button';\nimport React from 'react';\n\n\nexport type DeleteButtonProps = {} &amp; ButtonProps;\n\n\nexport function DeleteButton({ ...rest }: DeleteButtonProps) {\n  return (\n    <button>\n      DELETE\n    </button>\n  );\n}</code></p><p>&nbsp;</p><p>我们使用基于模式一创建的Button组件来实现的DeleteButton组件的效果如下：</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/53/537cba69cec820d758f54696c34a1d6a.png\" /></p><p>&nbsp;</p><p></p><p>现在我们可以在应用中使用统一的删除按钮。此外，如果你使用类似Bit的构建系统进行组件的设计和构建，那么当Button组件发生改变时，可以让<a href=\"https://bit.cloud/lakinduhewa/react-design-patterns/~ripple-ci/job/lakinduhewa-main-tlP1aG7L0\">CI服务自动将此改变传递到DeleteButton组件</a>\"上，就像下面这样（当Button组件从0.0.3升级到了0.0.4，那么CI服务会自动触发，将DeleteButton组件从0.0.1升级到0.0.2）：</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/d2/d24bc0ef23fab4865cf0cfa08c6c522d.png\" /></p><p>Bit上的一个CI构建</p><p></p><p>&nbsp;</p><p></p><h2>模式三：使用Hooks</h2><p></p><p></p><p>React Hooks 是<a href=\"https://legacy.reactjs.org/docs/hooks-overview.html\">React v16</a>\"就推出来的特性，它不依赖类组件实现状态管理、负效应等概念。简而言之，就是你可以通过利用Hooks API摆脱对类组件的使用需求。useSate和useEffect是最广为人知的两个Hooks API，但本文不打算讨论它们，我想重点讨论如何利用Hooks来提高组件的整体可维护性。</p><p>&nbsp;</p><p>例如，请考虑下面这个场景：</p><p>&nbsp;</p><p>有一个BlogList组件。BlogList组件会通过调用一个简单的API，获取博客文章列表数据，同时将其渲染在组件上。</p><p>&nbsp;</p><p>基于上面的案例，你可能会像下面这样将API逻辑直接写在函数组件中：</p><p>&nbsp;</p><p><code lang=\"null\">import React, { useState, useEffect } from 'react';\nimport axios from 'axios';\nconst BlogList = () =&gt; {\n    const [blogs, setBlogs] = useState([]);\n    const [isLoading, setIsLoading] = useState(true);\n    const [error, setError] = useState(null);\n    useEffect(() =&gt; {\n        axios.get('https://api.example.com/blogs')\n            .then(response =&gt; {\n                setBlogs(response.data);\n                setIsLoading(false);\n            })\n            .catch(error =&gt; {\n                setError(error);\n                setIsLoading(false);\n            });\n    }, []);\n    if (isLoading) return </code></p><div><code lang=\"null\">Loading...</code></div><code lang=\"null\">;\n    if (error) return <div>Error: {error.message}</div>;\n    return (\n        <div>\n            <h2>Blog List</h2>\n            <ul>\n                {blogs.map(blog =&gt; (\n                    <li>{blog.title}</li>\n                ))}\n            </ul>\n        </div>\n    );\n};\nexport default BlogList;</code><p></p><p>&nbsp;</p><p>这样写，组件也能正常工作。它将会获取博客文章列表并且渲染在UI上。但是，这里将UI逻辑和API逻辑混在一起了。</p><p>&nbsp;</p><p>理想情况下，React组件应该不需要关系如何获取数据。而只需要关心接收一个数据数组，然后将其呈现在DOM上。</p><p>&nbsp;</p><p>因此，实现这一目标的最佳方法是将API逻辑抽象到React Hook中，以便在组件内部进行调用。这样做就可以打破API调用与组件之间的耦合。通过这种方式，就可以在不影响组件的情况下，修改底层的数据获取逻辑。</p><p>&nbsp;</p><p>其中一种实现方式如下。</p><p>&nbsp;</p><p></p><h3>1.useBlog hook</h3><p></p><p></p><p><code lang=\"null\">import { useEffect, useState } from 'react';\nimport { Blog } from './blog.type';\nimport { Blogs } from './blog.mock';\n\n\nexport function useBlog() {\n  const [blogs, setBlogs] = useState([]);\n  const [loading, setLoading] = useState(false);\n\n\n  useEffect(() =&gt; {\n    setLoading(true);\n     // 注意：这里的setTimeout非实际需要，只是为了模拟API调用\n    setTimeout(() =&gt; {\n      setBlogs(Blogs);\n      setLoading(false);\n    }, 3000);\n  }, []);\n\n\n  return { blogs, loading }\n}</code></p><p>&nbsp;</p><p>如上代码所示，useBlog hook获取博客列表数据，然后赋值给状态变量，最后通过导出变量给到消费者（BlogList组件）使用：</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/e0/e06bc1effc8224cbaf6608ebce84e560.png\" /></p><p>&nbsp;</p><p></p><p>Hook效果</p><p>&nbsp;</p><p></p><h3>2.BlogList组件</h3><p></p><p></p><p><code lang=\"null\">import React from 'react';\n// 引入上面封装的 useBlog hook\nimport { useBlog } from '@lakinduhewa/react-design-patterns.hooks.use-blog';\nexport function BlogList() {\n  const { blogs, loading } = useBlog();\n  if (loading) {\n    return (\n      </code></p><p><code lang=\"null\">We are loading the blogs...</code></p><code lang=\"null\">\n    )\n  }\n  return (\n    <ul>\n      {blogs.map((blog) =&gt; <ol>\n        {blog.title}\n      </ol>)}\n    </ul>\n  );\n}</code><p></p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/fb/fb76665bd10e4984c973efde8e4841ed.png\" /></p><p></p><p>&nbsp;</p><p>BlogList组件效果</p><p>&nbsp;</p><p>通过调用useBlog和使用其导出的状态变量，我们在BlogList组件中使用了Hooks。如此，相对于之前，我们可以减少大量代码，并以最少的代码和精力维护两个组件。</p><p>&nbsp;</p><p>此外，当你使用类似Bit这样的构建系统时（就像我一样），只需将useBlog组件导入本地开发环境，然后再修改完成之后重新推送回Bit Cloud。Bit Cloud的构建服务器可以依托依赖树将此修改传递给整个应用。因此如果只执行一些简单修改，甚至不需要访问整个应用。</p><p>&nbsp;</p><p></p><h2>模式四：React Providers</h2><p></p><p></p><p>此模式的核心是解决组件状态共享。我们都曾是props下钻式传递的受害者。但如果你还没有经历过，那这里简单解释下：“props下钻式传递”就是当你在组件树中进行props传递时，这些props只会在最底层组件中被使用，而中间层的组件都不会使用该props。例如，看看下面这张图：</p><p><img src=\"https://static001.geekbang.org/infoq/05/052de38f4635336ef1c6dd038b4abe31.png\" /></p><p>props下钻式传递</p><p></p><p>&nbsp;</p><p>从BlogListComponent一直向下传递一个isLoading的props到Loader。但是，isLoading只在Loader组件中使用。因此，在这种情况下，组件不但会引入不必要的props，还会有性能开销。因为当isLoading发生变化时，即使组件没有使用它，React依然会重新渲染你的组件树。</p><p>&nbsp;</p><p>因此，解决方案之一就是通过利用React Context来使用React Context Provider模式。React Context是一组组件的状态管理器，通过它，你可以为一组组件创建特定的上下文。通过这种方式，你可以在上下文中定义和管理状态，让不同层级的组件都可以直接访问上下文，并按需使用props。这样就可以避免props下钻式传递了。</p><p>&nbsp;</p><p>主题组件就是该模式的一个常见场景。例如，你需要在应用程序中全局访问主题。但将主题传递到应用中的每个组件并不现实。你可以创建一个包含主题信息的Context，然后通过Context来设置主题。看一下<a href=\"https://bit.cloud/lakinduhewa/react-design-patterns/contexts/consumer-component\">我是如何通过React Context实现主题</a>\"的，以便更好地理解这一点：</p><p><a href=\"https://bit.cloud/lakinduhewa/react-design-patterns/contexts/consumer-component\">https://bit.cloud/lakinduhewa/react-design-patterns/contexts/consumer-component</a>\"</p><p>&nbsp;</p><p><code lang=\"null\">import { useContext, createContext } from 'react';\nexport type SampleContextContextType = {\n  /**\n   * primary color of theme.\n   */\n  color?: string;\n};\nexport const SampleContextContext = createContext({\n  color: 'aqua'\n});\nexport const useSampleContext = () =&gt; useContext(SampleContextContext);</code></p><p>&nbsp;</p><p>在Context中定义了一种主题颜色，它将在所有实现中使用该颜色来设置字体颜色。接下来，我还导出了一个hook——useSampleContext，该hook让消费者可以直接使用Context。</p><p>&nbsp;</p><p>只是这样还不行，我们还需要定义一个Provider。Provider是回答 \"我应该与哪些组件共享状态？\"问题的组件。<a href=\"https://bit.cloud/lakinduhewa/react-design-patterns/contexts/sample-context/~code/sample-context-context-provider.tsx\">Provider的实现示例如下：</a>\"</p><p>&nbsp;</p><p><code lang=\"null\">import React, { ReactNode } from 'react';\nimport { SampleContextContext } from './sample-context-context';\nexport type SampleContextProviderProps = {\n  /**\n   * primary color of theme.\n   */\n  color?: string,\n  /**\n   * children to be rendered within this theme.\n   */\n  children: ReactNode\n};\nexport function SampleContextProvider({ color, children }: SampleContextProviderProps) {\n  return {children}\n}</code></p><p>&nbsp;</p><p>Provider在管理初始状态和设置Context可访问状态的组件方面起着至关重要的作用。</p><p>&nbsp;</p><p>接下来，你可以创建一个<a href=\"https://bit.cloud/lakinduhewa/react-design-patterns/contexts/consumer-component\">消费者组件</a>\"来使用状态：</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/49/491455537d509ef21169e065110a7f78.png\" /></p><p>&nbsp;</p><p></p><p>消费者组件</p><p>&nbsp;</p><p></p><h2>模式五：条件渲染</h2><p></p><p></p><p>最后一个想和大家分享的是条件渲染模式。今天，人人都知道React中的条件渲染。它通过条件判断来选择组件进行渲染。</p><p>&nbsp;</p><p>但在实际使用中我们的用法常常是错误的：</p><p>&nbsp;</p><p><code lang=\"null\">// ComponentA.js\nconst ComponentA = () =&gt; {\n    return </code></p><div><code lang=\"null\">This is Component A</code></div><code lang=\"null\">;\n};\n// ComponentB.js\nconst ComponentB = () =&gt; {\n    return <div>This is Component B</div>;\n};\n// ConditionalComponent.js\nimport React, { useState } from 'react';\nimport ComponentA from './ComponentA';\nimport ComponentB from './ComponentB';\nconst ConditionalComponent = () =&gt; {\n    const [toggle, setToggle] = useState(true);\n    return (\n        <div>\n            <button> setToggle(!toggle)}&gt;Toggle Component</button>\n            {toggle ?  : }\n        </div>\n    );\n};\nexport default ConditionalComponent;</code><p></p><p>&nbsp;</p><p>你是否注意到，这里我们将基于条件的逻辑耦合到了JSX代码片段中。通常，你不应该在JSX代码中中添加任何与计算相关的逻辑，而只将与UI渲染相关的内容放在其中。</p><p>&nbsp;</p><p>解决这个问题的方法之一是使用条件渲染组件模式。创建一个可重用的React组件，该组件可以根据条件渲染两个不同的组件。<a href=\"https://bit.cloud/lakinduhewa/react-design-patterns/base/conditional\">它的实现过程如下</a>\"：</p><p>&nbsp;</p><p><code lang=\"null\">import React, { ReactNode } from 'react';\nexport type ConditionalProps = {\n  /**\n   * the condition to test against\n   */\n  condition: boolean\n  /**\n   * the component to render when condition is true\n   */\n  whenTrue: ReactNode\n  /**\n   * the component to render when condition is false\n   */\n  whenFalse: ReactNode\n};\nexport function Conditional({ condition, whenFalse, whenTrue }: ConditionalProps) {\n  return condition ? whenTrue : whenFalse;\n}</code></p><p>&nbsp;</p><p>我们创建了一个可以按条件渲染两个组件的组件。当我们将其集成到其他组件中时，会使代码更简洁，因为无需在React组件中加入复杂的渲染逻辑。你可以像下面这样使用它：</p><p>&nbsp;</p><p><code lang=\"null\">export const ConditionalTrue = () =&gt; {\n  return (\n    \n  );\n}\nexport const ConditionalFalse = () =&gt; {\n  return (\n    \n  );\n}</code></p><p>&nbsp;</p><p>实际的输入如下：</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/00/00e4f51a0533efeb947a407b4e01a889.png\" /></p><p>&nbsp;</p><p></p><p></p><h2>总结</h2><p></p><p>&nbsp;</p><p>掌握这五种设计模式，为2024年做好充分准备，构建出可扩展和可维护的应用吧。</p><p>&nbsp;</p><p>如果你想详细深入本文中讨论的模式，<a href=\"https://bit.cloud/lakinduhewa/react-design-patterns\">请随时查看我在Bit Cloud的空间</a>\"：</p><p><a href=\"https://bit.cloud/lakinduhewa/react-design-patterns\">https://bit.cloud/lakinduhewa/react-design-patterns</a>\"</p><p>&nbsp;</p><p>感谢你的阅读！</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://blog.bitsrc.io/react-design-patterns-for-2024-5f2696868222\">https://blog.bitsrc.io/react-design-patterns-for-2024-5f2696868222</a>\"</p><p></p><p></p><h5>相关阅读：</h5><p></p><p></p><p><a href=\"https://www.infoq.cn/article/4ydKY3wbZDp7Eei0JJm1\">React&nbsp;JS 广受业界认可，高级开发者年薪百万</a>\"</p><p><a href=\"https://www.infoq.cn/article/Tv3SyqoivXMWUoj8qSMT\">从新&nbsp;React&nbsp;文档看未来 Web 的开发趋势</a>\"</p><p><a href=\"https://www.infoq.cn/article/CZKMjHaxbf1Z7xcSzisX\">我被&nbsp;React&nbsp;劫持了，很痛苦又离不开</a>\"</p><p><a href=\"http://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247516803&amp;idx=1&amp;sn=f584917f8afe2f7bb10f8686acb040cf&amp;chksm=f95237c0ce25bed6980bdc34c630cbda97d0325a489663440b4c904499ca81da31729d476476&amp;scene=27#wechat_redirect\">React&nbsp;开发者们的 Solid.js&nbsp;快速入门教程</a>\"</p>",
    "publish_time": "2023-12-31 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]