[
  {
    "title": "新手入门：探索eBPF的可观测性与安全性工作流",
    "url": "https://www.infoq.cn/article/085bCgNVTETVFvAr62i4",
    "summary": "<p>本文分享了学习eBPF的经验，eBPF是一种新的云原生技术，其目标是改善可观测性和安全性工作流。我们可能感觉它的入门门槛很高，通过eBPF工具来辅助生产环境调试的步骤会很多。本文将会介绍如何使用相关的工具并将其应用到自己的开发中，请逐步迭代自己的知识，并将其用到更高级的使用场景中。最后，我们会讨论如何在CI/CD中实现自动化开发及其面临的挑战。</p><p></p><h2>如何开始入门eBPF？</h2><p></p><p></p><p>我第一次听说eBPF是在2021年，当时它是与可观测性相关的主题一起出现的，起初我并不能真正理解它的含义。描述中声称这是一种收集事件数据的新方法，有助于提升可观测性，也有助于实现安全的可观测性和实际执行。</p><p></p><p>实际上，我后来才知道，Falco使用eBPF来探查Kubernetes中容器的活动。我的学习历程是将Falco视为云原生的安全工具，而没有去质疑其底层的技术。<a href=\"https://www.oreilly.com/library/view/hacking-kubernetes/9781492081722/\">“Hacking Kubernetes”</a>\"一书帮助我完善了对容器运行时、eBPF和安全执行的学习。</p><p></p><p><a href=\"https://opsindev.news/archive/2022-06-13/#kubecon-eu\">KubeCon EU 2022上的eBPF日</a>\"，以及后续的<a href=\"https://opsindev.news/archive/2022-10-15/#ebpf-summit\">eBPF峰会活动</a>\"，都有助于说明这一点。eBPF的学习策略与技术领域的其他知识类似，也就是倾听、做笔记，但你依然无法理解它的所有内容。</p><p></p><p>参加讲座和阅读文章时，我们经常会遇到一些需要认识的术语模式，比如，我立即记住的术语包括eBPF、BPF、bcc、bpftrace和iovisor。<a href=\"https://www.brendangregg.com/index.html\">Brendan Gregg的博客</a>\"也经常被提及。</p><p></p><p>在一个社区聚会上，通过自由讨论营（barcamp）式的演讲，我问到，“如何开始使用eBPF？”。随后，我们使用三张幻灯片拉开了关于它如何运行的讨论，一起验证了相关的知识，并思考了其使用场景。在eBPF峰会上，有一个名为 <a href=\"https://github.com/isovalent/eBPF-Summit-2022-CTF\">Capture-the-Flag的环境</a>\"可以进行学习，这吸引我停下脚步并亲自进行探索挑战。随后，我决定在自己的公共学习平台o11y.love上收集<a href=\"https://o11y.love/topics/ebpf/\">所有的eBPF资源</a>\"，并决定以公开的方式进行学习，记录在这个过程中遇到的所有错误、误解和问题。</p><p></p><p>内核开发听起来很难，而且理解和入门eBPF可能存在一定的障碍。对于利用eBPF的工具和库，改变使用它们的方法，并配合生产环境的用例（例如在生产中进行调试），这极大地帮助了我的学习和迭代。对Linux操作系统、资源处理和故障排除的一般理解也很有助益。</p><p></p><p>更高层次的阐述和ebpf.io上的描述图片有助于对eBPF架构的一般理解。我非常喜欢来自Brendan Gregg的<a href=\"https://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html\">解释</a>\"：</p><p></p><p></p><blockquote>“eBPF对Linux的作用就像JavaScript对HTML的作用。（某种程度上，可以这么说。）因此，JavaScript可以让我们定义在点击鼠标等事件中运行的小型程序，而不再是静态的HTML站点，这些程序会在浏览器的安全虚拟机中运行。有了eBPF之后，我们不再是一个固定的内核，而是可以编写在磁盘I/O等事件上运行的小型程序，这些程序会在内核的安全虚拟机中运行。实际上，eBPF更像是运行JavaScript的v8虚拟机，而不是JavaScript本身。eBPF是Linux内核的一部分。”</blockquote><p></p><p></p><p>eBPF被添加到Linux内核中，以实现小型的沙箱程序。这兼顾了稳定的内核需求和少量的创新可能性，而eBPF程序能够有助于扩展和驱动创新，而不会阻碍内核的发展。</p><p></p><p>eBPF的用例包括高性能网络和负载均衡、应用程序的追踪和性能问题的排查。此外，细粒度的安全可观测性和应用/容器的运行时安全执行也是我能想到的场景。</p><p></p><p>编写eBPF程序是很难的，内核期望的是字节码，但是它手动编写的效率并不高。因此，需要有一个抽象层，包括从更高级的编程语言生成字节码的编译器。在这种情况下，经常涉及到的工具是Cilium、bcc和bpftrace。eBPF程序的校验发生在从字节码向机器特定指令集的即时编译过程中。这使得在CI/CD工作流中进行静态校验更加困难。稍后，我们会看到更多这方面的内容。</p><p></p><p>在了解了需求之后，真正的问题在于，我们有什么实际的例子可以尝试和学习，然后深入研究实际的源码？</p><p></p><h2>正式开始：游乐场</h2><p></p><p></p><p>Brendan Gregg的<a href=\"https://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html\">学习eBPF跟踪：教程和样例</a>\"博文是一个很好的起点。不同的尝试和路线最终都会回到这里进行自学。在深入研究库和eBPF程序如何构建之前，在命令行上尝试不同的工具并测试它们的效果，这是一个很好的策略。</p><p></p><p>注意：Liz Rice的<a href=\"https://www.oreilly.com/library/view/learning-ebpf/9781098135119/\">“Learning eBPF”</a>\"一书能够有助于进一步降低入门门槛，该书于2023年3月出版。</p><p></p><p>推荐的入门方式是选择具有最新内核（大约4.17版本）的Linux发行版，如Ubuntu 22.04 LTS。请使用本地虚拟化方法，或在你喜欢的云厂商上生成一个虚拟机。下面的样例使用Hetzner Cloud CLI来生成一个新的Ubuntu虚拟机：</p><p></p><p><code lang=\"text\">$ hcloud server create --image ubuntu-22.04 --type cx21 --name ebpf-chaos\n</code></p><p></p><p>请根据你的需要重新创建设置过程，可以考虑编写Ansible playbooks或脚本来重复安装步骤。这对跟团队成员分享具体学习环境中使用的工具和库会很有帮助。本文讨论的工具和想法在<a href=\"https://go.gitlab.com/xtBYnL\">GitLab上有基于Ansible的样例</a>\"。有些默认的工具需要安装（git、wget、curl、htop和docker），还有eBPF、混沌实验和可观测性等更具体的用例。</p><p></p><p>接下来的章节将讨论eBPF工具的样例。要构建和安装它们，需要Linux内核头文件和额外的依赖。在Ubuntu 22 LTS上还有一个额外的步骤就是启用<a href=\"https://wiki.ubuntu.com/Debug%20Symbol%20Packages\">DDebs仓库</a>\"，以访问调试符号（debug symbol），接下来是一个完整的编译器工具链。<a href=\"https://go.gitlab.com/PPwfc5\">该针对eBPF的Ansible配置</a>\"详细描述了安装步骤。你可以查看Git的历史记录，了解学习的步骤以及这个过程中的错误。下面的几节主要是运行这些工具，并阐述它们的使用场景。</p><p></p><h3>跟踪系统调用</h3><p></p><p></p><p>你可能已经使用过strace命令来跟踪运行中的二进制文件的系统调用，查看是否有文件被打开和权限错误等。Brendan Gregg的教程博客建议从提供execsnoop命令的<a href=\"https://github.com/iovisor/bcc\">bcc toolchain</a>\"开始。它可以跟踪exec()系统调用。一个很容易的测试方法是打开SSH连接，或者在另外一个终端上执行curl opsindev.news命令。</p><p></p><p><code lang=\"text\">$ execsnoop -t\n\n115.816 curl             879320 879305   0 /usr/bin/curl opsindev.news\n118.481 sshd             879322 67197    0 /usr/sbin/sshd -D -R\n124.287 sshd             879324 67197    0 /usr/sbin/sshd -D -R\n</code></p><p></p><p>我们已经学习了一种跟踪系统调用的新方法。bcc工具链提供了更多实用的工具和用例。从学习的角度来讲，还有哪些工具可以用来深入研究eBPF呢？</p><p></p><h3>bpftrace：高级的跟踪语言</h3><p></p><p></p><p><a href=\"https://github.com/iovisor/bpftrace\">Bpftrace</a>\"提供了自己的高层级跟踪语言，类似于DTrace这样的调试框架。乍看上去，在线样例可能会让人无所适从，但由于我们使用的是测试虚拟机，所以可以运行这些样例，以后再分析语言。Bpftrace允许我们跟踪更多的系统调用，例如open()。这个方法可以用来打开文件、套接字等，更通用地来讲，是进程可以打开的所有内容，不管是善意还是恶意的。它可以视为strace命令的一种更为现代的方式。</p><p></p><p>为了使用可预测的样例来测试bpftrace，我们可以使用这个最小化的C程序，它打开一个文件句柄来创建新文件（<a href=\"https://go.gitlab.com/0mtuqx\">源码</a>\"）：</p><p></p><p><code lang=\"text\">#include \n#include \n#include \n#include \n#include \n#include \n\nint main()\n{\n  int fd;\n\n  if ((fd=open(\"ebpf-chaos.txt\", O_WRONLY | O_CREAT, 0660)) == -1)\n  {\n    printf(\"Cannot open file.\");\n    exit(1);\n  }\n\n  close(fd);\n}\n</code></p><p></p><p>使用gcc编译器编译C程序，并在启动bpftrace命令后运行它。如果opensnoop.bt命令在Ubuntu 22 LTS上运行失败的话，请从DDeb仓库安装调试符号。</p><p></p><p><code lang=\"text\">$ gcc sim-open-file.c -o sim-open-file\n$ chmod +x sim-open-file\n$ ./sim-open-file\n</code></p><p></p><p><code lang=\"text\">$ bpftrace -e 'tracepoint:syscalls:sys_enter_openat { printf(\"%s %s\\n\", comm, str(args-&gt;filename)); }'\n\nAttaching 1 probe...\nsim-open-call /etc/ld.so.cache\nsim-open-call /lib/x86_64-linux-gnu/libc.so.6\nsim-open-call\n</code></p><p></p><p>跟踪语言允许挂钩进入特定的系统调用。要找到正确的系统调用名称，需要慢慢试验，可能还会遇到错误。我不得不将sys_enter_open改为sys_enter_openat来触发C程序中的打开文件的调用。bpftrace -l可以列出所有可跟踪的系统调用。</p><p></p><p><code lang=\"text\">$ bpftrace -l 'tracepoint:syscalls:sys_enter_open*'\ntracepoint:syscalls:sys_enter_open\ntracepoint:syscalls:sys_enter_open_by_handle_at\ntracepoint:syscalls:sys_enter_open_tree\ntracepoint:syscalls:sys_enter_openat\ntracepoint:syscalls:sys_enter_openat2\n</code></p><p></p><p>上述代码会将命令和文件名的路径打印到终端上。访问要打印的文件名需要阅读C结构的代码，以了解在这种情况下，哪些属性是可用的。</p><p></p><p>学习曲线的“顿悟时刻（aha moment）”不仅仅会看到文件打开和写入调用，而且还会加载库的依赖关系（stdlib需要libc）。bfptrace工具对于验证二进制文件是否真的加载了某些库是非常有用的，其次是使用ldd和nm来窥探依赖关系和调试符号。</p><p></p><p><code lang=\"text\">$ ldd sim-open-call\n    linux-vdso.so.1 (0x00007ffe42c78000)\n    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f24c7247000)\n    /lib64/ld-linux-x86-64.so.2 (0x00007f24c747d000)\n\n$ nm sim-open-call | grep open\n                 U open@GLIBC_2.2.5\n</code></p><p></p><h3>深入研究源码和eBPF程序</h3><p></p><p></p><p><a href=\"https://github.com/iovisor/bcc\">BPF编译器集合（BPF Compiler Collection，BCC）</a>\"提供了一些样例来学习内核和用户空间之间的数据传输和交互。以前的样例只是挂钩系统调用并立即返回。BCC在C代码中提供了内核插装，并允许使用Python或Lua编写前端用户空间的应用。按照描述，使用场景包括性能分析和网络流量控制，这都是很好的洞察点，并为以后的知识验证增加了学习难度。Python和C语言知识有助于更容易地深入研究这些样例。</p><p></p><p>另外，基于我的研究过程，推荐<a href=\"https://github.com/libbpf/libbpf\">libbpf</a>\"库，因为它的<a href=\"https://github.com/libbpf/libbpf-bootstrap\">bootstrap项目</a>\"提供了更多的演示应用。它们提供了真实的程序，可以用来实现自己的第一个eBPF程序。其中有一个样例是使用Rust编写的，允许我们按照<a href=\"https://en.wikipedia.org/wiki/Express_Data_Path\">XDP规范</a>\"检查网络流量以及数据包的大小。eXpress Data Path（XDP）允许在大规模网络调用时挂钩发送/接收的网络数据包，这会发生在中断之后和内存分配之前。例如，这可以用来悄悄地丢弃数据包（请注意后面高级的eBPF程序开发用例）。</p><p></p><p>用户需要指定端口号，这会导致再一轮的试验和错误排查。使用eth0作为接口名称无法成功运行。这个样例的输出源自同一台主机上运行的Prometheus服务器实例，产生的网络流量来自以HTTP端点探查监控目标的输出。</p><p></p><p><code lang=\"text\">$ apt install rustc cargo clang rustfmt\n\n$ git clone https://github.com/libbpf/libbpf-bootstrap\n$ cd libbpf-bootstrap/examples/rust\n$ cargo build\n$ cargo run\n\n$ sudo ./target/debug/xdp 1 #if number\n\n$ sudo tail -f /sys/kernel/debug/tracing/trace_pipe  \n\nprometheus-660     [001] d.s11 295903.782373: bpf_trace_printk: packet size: 74\nprometheus-659     [000] d.s11 295903.782735: bpf_trace_printk: packet size: 74\nprometheus-659     [000] d.s11 295903.782762: bpf_trace_printk: packet size: 54\nprometheus-671     [001] d.s11 295908.509751: bpf_trace_printk: packet size: 352\nprometheus-671     [001] d.s11 295908.513184: bpf_trace_printk: packet size: 4162\nprometheus-671     [001] d.s11 295908.513218: bpf_trace_printk: packet size: 66\nprometheus-671     [001] d.s11 295908.513295: bpf_trace_printk: packet size: 4162\nprometheus-671     [001] d.s11 295908.513307: bpf_trace_printk: packet size: 66\nprometheus-671     [001] d.s11 295908.513368: bpf_trace_printk: packet size: 1630\n</code></p><p></p><p>在构建和运行更多的样例后，我们并不完全清楚复制或修改源码是否为一个好的策略。如何将XDP样例缩减至最小的尺寸？也许有更好的方法来逐步入手编写eBPF程序代码，并增加学习过程中获得的经验。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/learning-ebpf-observability/en/resources/2figure-1-large-1684250535157.jpg\" /></p><p></p><h2>eBPF程序开发，学习更多用例</h2><p></p><p></p><p>在深入研究如何开发自己的程序之前，了解BPF和eBPF的基础知识是很重要的。eBPF是Berkley Packet Filter（BPF）的一个扩展版本，它提供了一个运行在Linux内核中的抽象虚拟机，在受控的环境中运行eBPF程序。从根本上说，Linux内核中的“老”BPF标准可以被<a href=\"https://ebpf.io/what-is-ebpf/#what-do-ebpf-and-bpf-stand-for\">称为“经典BPF”，以便于和eBPF进行区分</a>\"。</p><p></p><p>我们可以从尝试bcc工具开始，运行bpftrace并识别在日常业务和事件中有助于SRE和DevOps工程师的用例。这可能包括跟踪程序的启动/退出、查看控制组（cgroups）、观察TCP连接、检查网络接口等等。建议尽可能保持用例的简单性，以确保稳定的学习曲线。</p><p></p><p>在验证了关于eBPF的基础知识并定义了用例之后，请以<a href=\"https://ebpf.io/infrastructure/\">库和工具链</a>\"的形式探寻抽象的概念。现代编译器和库可用于Go、Rust和C/C++。在决定编写eBPF程序之前，建议先学习基本的编程语言。根据我自己的经验，在具有C++或Python知识之后，学习Rust是一条可行的发展道路。这有助于避免内存处理相关的运行时错误，与C/C++ eBPF程序相比，可以说这是一种更安全的方法。</p><p></p><p>Cillium在一个<a href=\"https://github.com/cilium/ebpf\">Golang的开源库中</a>\"实现了它的eBPF功能。除了学习编写自己的eBPF程序外，该库还提供了如下用例：将程序附加到入口/出口、计算egress流量包，以及探查网络接口（请注意XDP术语，以供后续学习）。XDP程序可以用Go编译器工具链进行构建，并接受接口名称作为命令行参数。它使用map来持久化特定IP地址的网络包的数量；对于Kubernetes节点上的任意类型的网络接口，探查容器流量或跟踪嵌入式硬件的流量都是很好的使用场景。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/learning-ebpf-observability/en/resources/2figure-2-large-1684250535158.jpg\" /></p><p></p><p>如果你觉得编写Rust代码更舒服的话，aya-rs的维护者提供了一个<a href=\"https://github.com/aya-rs/aya\">Rust开发人员工具链</a>\"，包含一本带有教程的<a href=\"https://aya-rs.dev/book/\">图书</a>\"。书中的样例实现了一个类似的XDP网络流量场景，可以直接从Cargo构建链中运行，使开发过程更加高效。</p><p></p><p><code lang=\"text\">$ git clone https://github.com/aya-rs/book aya-rs-book\n$ cd examples/xdp-hello\n$ cargo install bpf_linker\n$ cargo xtask build-ebpf\n$ cargo build\n\n$ RUST_LOG=info cargo xtask run\n</code></p><p></p><p>样例程序没有跟踪IP地址及其数据包的数量，但是这可以作为一个很好的练习，模仿Go库样例中的行为。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/learning-ebpf-observability/en/resources/2figure-3-large-1684250535158.jpg\" /></p><p></p><p>aya-rs的其他实际用例是持续剖析（profiling），Polar Signals的开发人员将Rust库用到了Parca代理中，用于自动的函数调用栈分析和更好的内存安全性（<a href=\"https://static.sched.com/hosted_files/cloudnativeebpfdayeu22/7f/eBPF%20Day%202022_KubeCon%20EU_%20eBPF%3F%20Safety%20First%21.pdf\">来自KubeCon EU 2022 eBPF日上的幻灯片</a>\"和<a href=\"https://github.com/parca-dev/parca-agent/pull/377\">Pull Request</a>\"）。</p><p></p><p>有不同的方式来着手开发eBPF程序。请记住，该架构遵循将字节码编译的eBPF程序加载到内核，并需要一个用户空间的“收集器（collector）”或“打印器（printer）”。通信是通过套接字或文件句柄进行的。</p><p></p><h2>测试和校验eBPF程序</h2><p></p><p></p><p>在CI/CD流水线中自动化测试eBPF程序是很棘手的事情，因为内核会在加载时验证eBPF程序并拒绝潜在的不安全程序。测试将会需要一个新的虚拟机沙箱，加载eBPF程序，并模拟内核和eBPF程序相关的行为。需求包括触发事件，再次触发eBPF程序代码所订阅的钩子。根据不同的目的，这会涉及到不同的内核接口和系统调用（网络、文件访问等）。创建一个独立的单元测试mock是很难的，需要开发人员模拟一个运行中的内核。</p><p></p><p>有人<a href=\"https://blog.trailofbits.com/2023/01/19/ebpf-verifier-harness/\">试图将eBPF验证器转移到内核之外</a>\"，并允许在CI/CD中测试eBPF程序。同时，在CI/CD中加载eBPF程序需要一个运行中的Linux虚拟机，其CI/CD的runner/executor要具有较高的权限。在Ubuntu 22 LTS中，加载非特权程序默认已被禁用，可能需要通过运行sudo sysctl kernel.unprivileged_bpf_disabled=0来启用。</p><p></p><h3>CI/CD中的持续测试</h3><p></p><p></p><p>为了提供持续测试的CI/CD runner环境，建议使用Ansible/Terraform生成一个Linux虚拟机，安装CI/CD runner，将其注册到CI/CD服务器上，并准备好加载和运行eBPF程序的需求。对于不同的供应商来说，这是一个通用的模式。下面的样例使用Ansible安装并注册GitLab Runner到GitLab.com项目中，然后使用它来构建和运行eBPF程序。GitLab Runner注册了标签ebpf，它将只会执行使用了该标签的CI/CD job。</p><p></p><p><code lang=\"text\">---\n\n- name: GitLab Runner for eBPF\nhosts: all\nvars:\nansible_python_interpreter: /usr/bin/python3\ntasks:\n- name: Get GitLab repository installation script\nget_url:\nurl: \"https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh\"\ndest: /tmp/gitlab-runner.script.deb.sh\nmode: 0744\n- name: Install GitLab repository\ncommand: bash /tmp/gitlab-runner.script.deb.sh\nargs:\ncreates: \"/etc/apt/sources.list.d/runner_gitlab-runner.list\"\nbecome: true\n- name: Install GitLab Runner\napt:\nname: gitlab-runner\nstate: present\nallow_downgrade: true\nbecome: true\nenvironment:\nGITLAB_RUNNER_DISABLE_SKEL: \"true\"\n\n- name: Allow the gitlab-runner user to run any commands as root with sudo -u root\ncommunity.general.sudoers:\nname: gitlab-runner sudo\nstate: present\nuser: gitlab-runner\nrunas: root\ncommands: ALL # Review this for production usage. For demos, it is enabled, and forked MR CI/CD builds won't run.\n</code></p><p></p><p><a href=\"https://docs.gitlab.com/runner/register/\">注册</a>\"需要gl_runner_registration_token变量，该变量来自GitLab项目中针对CI/CD Runners的配置。</p><p></p><p><code lang=\"text\">---\n- name: GitLab Runner for eBPF - register once\nhosts: all\nvars:\nansible_python_interpreter: /usr/bin/python3\ntasks:\n- name: \"Configure GitLab Runner (running to populate config.toml)\"\ncommand: &gt;\ngitlab-runner register\n--non-interactive\n--url \"https://gitlab.com/\"\n--executor \"shell\"\n--tag-list ebpf\n--registration-token=\"{{ gl_runner_registration_token }}\"\n</code></p><p></p><p>GitLab runner可以在项目设置的CI/CD &gt; Runners中看到。</p><p></p><h3>在CI/CD中测试基于Rust的eBPF程序</h3><p></p><p></p><p>我们使用一个实际的eBPF程序来尝试一下CI/CD工作流，这里使用aya-rs Rust库模板作为演示样例。首先，在Linux虚拟机上本地安装Rust和所需的eBPF，以验证一切均能正常运行。</p><p></p><p><code lang=\"text\">curl https://sh.rustup.rs -sSf | sh\nsource \"$HOME/.cargo/env\"\n\nrustup install stable\nrustup install nightly\n\nrustup default stable\nrustup toolchain add nightly\nrustup component add rust-src --toolchain nightly\n\n# required for cargo-generate\napt -y install libssl-dev\n\ncargo install cargo-generate\ncargo install bpf-linker\ncargo install bindgen-cli\n</code></p><p></p><p>接下来，生成一个模板骨架树，用于使用XDP（eXpress Data Path）类型创建一个演示程序。探查ebpf-chaos-demo-xdp/src/main.rs中的代码，并更新网络接口名。然后，构建并运行程序，将日志级别设置为info（或debug）。</p><p></p><p><code lang=\"text\">cargo generate --name ebpf-chaos-demo-xdp -d program_type=xdp https://github.com/aya-rs/aya-template.git\n\nRUST_LOG=info cargo xtask run\n</code></p><p></p><p>示例代码由两部分组成：ebpf-chaos-demo-xdp-ebpf/src/main.rs中的内核空间eBPF程序和ebpf-chaos-demo-xdp/src/main.rs中的用户空间程序，后者会加载eBPF程序并将其附加至内核跟踪点。为了只构建eBPF程序，我们可以调用build-ebpf xtask并使用llvm-objdump命令检查字节码：</p><p></p><p><code lang=\"text\">cargo xtask build-ebpf\n\nllvm-objdump -S target/bpfel-unknown-none/debug/ebpf-chaos-demo-xdp\n</code></p><p></p><p>完整的源代码位于<a href=\"https://go.gitlab.com/QfjbTn\">该GitLab项目</a>\"中，可以使用GitLab CI/CD流水线进行测试。注意，它需要在runner环境中安装Rust工具链。随后的流水线运行将会使用配置好的缓存。该流水线有三个job：</p><p></p><p>install-deps准备Rust环境，这需要将CARGO_HOME变量指定为runner的项目目录。aya-rs-xdp-build-ebpf构建核心eBPF程序，并运行llvm-objdump命令。aya-rs-xdp-run运行用户空间程序，这需要sudo权限。它会将命令放到后台，捕获stdout，睡眠60秒，然后使用pkill来杀死xtask命令，最后打印捕获到的输出。</p><p></p><p>对输出分析进行增强以及思考运行eBPF程序的更多测试报告是留给读者的练习。</p><p></p><p><code lang=\"text\"># eBPF GitLab Runner required for this project\n# Note: Various commands need sudo/root access on the Linux host, see ansible-config/.\n# By default, for security reasons, CI/CD pipelines are not run from forks in the parent project.\n# See https://docs.gitlab.com/ee/ci/pipelines/merge_request_pipelines.html#use-with-forked-projects  \ndefault:\n  tags:\n    - ebpf\n\nstages:\n  - pre\n  - build\n  - run\n\nvariables:\n  RUST_LOG: \"info\"\n  RUNTIME: 300 # set to &gt;= 5*60 = 300s because cargo xtask run also compiles the binary first\n                              \n\n# These steps should not take long after subsquent runs on the Linux VM\ninstall-deps:\n  stage: pre\n  script:\n    - sudo apt install libssl-dev # required for cargo-generate on Ubuntu 22 LTS\n    - curl https://sh.rustup.rs -sSf -o rustup.sh\n    - sh rustup.sh -y --profile default\n    - source \"$HOME/.cargo/env\"\n    - rustup install stable\n    - rustup install nightly\n    - rustup default stable\n    - rustup toolchain add nightly\n    - rustup component add rust-src --toolchain nightly\n    # 'cargo install' is not idempotent. --force takes too long. Treat an error as 'ok, installed' here.\n    - cargo install cargo-generate bpf-linker bindgen-cli || true\n\naya-rs-xdp-build-ebpf:\n  stage: build\n  script:\n    - cd examples/ebpf-chaos-demo-xdp\n    - source \"$HOME/.cargo/env\"\n    - cargo xtask build-ebpf\n    - llvm-objdump -S target/bpfel-unknown-none/debug/ebpf-chaos-demo-xdp\n\naya-rs-xdp-run:\n  stage: run\n  # We need to send the cargo xtask run command into the background, capture stdout, kill it after a defined interval, and generate a test report for CI/CD\n  script:\n    - cd examples/ebpf-chaos-demo-xdp\n    - source \"$HOME/.cargo/env\"\n    - rm ${CI_PROJECT_DIR}/run.pid\n    - nohup cargo xtask run &gt; ${CI_PROJECT_DIR}/nohup.out 2&gt;&amp;1 &amp; echo $! &gt; ${CI_PROJECT_DIR}/run.pid\n    - sleep $RUNTIME\n    - kill -s TERM `cat ${CI_PROJECT_DIR}/run.pid` || true\n    - rm ${CI_PROJECT_DIR}/run.pid  \n    - cat \"${CI_PROJECT_DIR}/nohup.out\"\n    - echo \"Finished running eBPF program. TODO - analyze the output more.\"\n  artifacts:\n    expire_in: 30 days\n    paths:\n      - ${CI_PROJECT_DIR}/nohup.out\n</code></p><p></p><p>该截屏显示了运行eBPF程序的job，以及捕获网络数据包的日志输出。根据对源代码的修改，输出会发生变化并且可以进行测试。一个思路是以机器可读的格式总结捕获到的数据包，并在终止时创建一个汇总表。在CI/CD以及命令行中，这种方式更易于消费和理解。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/learning-ebpf-observability/en/resources/2figure-4-large-1684251660936.jpg\" /></p><p></p><p>将进程放入后台的方法可能无法正确地唤醒它，这可能需要更好的信号处理实现。它远远谈不上完美，你可以在这个<a href=\"https://go.gitlab.com/7xvkFu\">合并请求中看到我的学习历史</a>\"。可能有更好的方式来构建要发布的二进制文件，并通过supervisorctl或systemd命令来启动它，这是下一个学习步骤。终止和卸载过程的实现比较棘手。下面的代码片段实现了正确的信号处理，但是无法始终从运行中的内核卸载已注册的XDP链接。另一种方法是为每次的CI/CD运行生成一个新的Linux虚拟机，以避免这些可重复性相关的失败。但是，其缺点是我们需要一个Rust构建的远程缓存，以避免较长的CI/CD构建运行时间。</p><p></p><p><code lang=\"text\">// Implement signal handling for CTRL+C and SIGTERM\nuse tokio::signal::unix::{signal, SignalKind};\n\n…\n\n    let program: &amp;mut Xdp = bpf.program_mut(\"ebpf_chaos_demo_xdp\").unwrap().try_into()?;\n    program.load()?;\n    program.attach(&amp;opt.iface, XdpFlags::default())\n        .context(\"failed to attach the XDP program with default flags - try changing XdpFlags::default() to XdpFlags::SKB_MODE\")?;\n\n\n    // Implement signal handling for CTRL+C (SIGINT) and SIGTERM\n    // CTRL+C can be used for terminal tests\n    // SIGTERM will be sent from CI/CD jobs to the background process\n    let mut sigterm = signal(SignalKind::terminate())?;\n    let mut sigint = signal(SignalKind::interrupt())?;\n\n    tokio::select! {\n        _ = sigterm.recv() =&gt; { println!(\"SIGTERM shutting down\") }\n        _ = sigint.recv() =&gt; { println!(\"SIGINT shutting down\") }\n    }\n\n    Ok(())\n    // Destroying the bpf object will detach and cleanup the loaded program.\n    // Debug with 'bpftool link show'\n}\n</code></p><p></p><h3>CI/CD和DevSecOps工作流的额外待办事项</h3><p></p><p>剩下的挑战就是扩展eBPF程序以生成测试报告，并创建运行时测试环境，即通过用curl命令运行网络流量测试周期，并验证输出包的确切大小。另外，架构也很重要，要么eBPF程序被加载到内核中，并且有一个用户空间应用来读取其结果，要么eBPF程序是一个单一的二进制文件，直接附加其探针。后者需要在CI/CD job中将程序发送至后台，捕获它的输出，执行测试，然后合并测试报告。对于DevSecOps工作流来说，这个过程还有许多需要改进的地方，但我相信在不久的将来我们会达到最终的目的。</p><p></p><p>代码覆盖是测试eBPF程序的另一个新领域。目前并没有太多的工具帮助开发人员理解代码在Linux内核中运行时的路径，哪些代码区域会受到影响，哪些代码没有被覆盖到。<a href=\"https://www.elastic.co/blog/code-coverage-for-ebpf-programs\">bpfcov是由Elastic的工程师创建的</a>\"，以帮助解决这个问题，让开发人员了解eBPF程序的代码执行路径。在CI/CD中运行自动化的代码质量和安全扫描也是一项挑战：如何确定一个有可能拖慢内核操作的编程错误呢？比较有意思的是，我们可以看一下eBPF程序的持续剖析（continuous profiling）是否可以实现（本身就是使用eBPF的，如<a href=\"https://www.parca.dev/\">Parca项目</a>\"）。还有一些编程模式会规避内核验证器，并造成对软件供应链的安全攻击，通过贡献的拉取和合并请求，将恶意代码注入到已发布的eBPF程序中。这需要<a href=\"https://go.gitlab.com/vvAGaM\">DevSecOps工作流</a>\"来确保安全措施行之有效。AI可能也会提供一些帮助。</p><p></p><h2>结论</h2><p></p><p></p><p>eBPF是一种收集可观测性数据的新方法，它有助于实现网络洞察力，以及安全的可观测性和执行。为了获得最好的库、工具和框架，我们需要一起公开学习，以降低知识的壁垒，并使每个人都能做出贡献。从测试现有的工具到编写eBPF程序的详细教程，我们还有很长的路要走。在CI/CD中进行eBPF程序测试和验证是一项重要的工作，接下来就是将所有的想法带到上游，降低使用和贡献eBPF开源项目的入门门槛。</p><p></p><p>要想开始相关的工作，需要启动一个Linux虚拟机，使用脚本/Ansible进行可重复的设置，并进行测试和开发。当接口名称和内核技术阻碍学习的进度时，那就回退一步，你并没有必要完全理解eBPF的全部内容。当遇到生产环境中断时，对数据收集有一般化的了解能够提供一定的帮助。最后，但同样重要的是，这里有个提示，那就是当调试eBPF程序时，考虑在多个发行版上进行测试，避免遇到内核相关的缺陷。</p><p></p><p>作者简介：</p><p>Michael Friedrich是GitLab的高级开发人员布道者，专注于可观测性、DevSecOps和AI。Michael创建了o11y.love作为可观测性学习平台，并在他的opsindev.news通讯中分享技术趋势以及对day-2ops、eBPF、AI/MLOps的见解。在没有旅行和远程工作的时候，他喜欢搭建乐高模型。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/learning-ebpf-observability/\">Learning eBPF for Better Observability</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/5xvC1Ic6BdLQYju6YWV0\">颠覆传统、应用大爆发，eBPF&nbsp;何以改变 Linux？</a>\"</p>",
    "publish_time": "2023-07-28 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "使用Cloud Studio&Flutter完成全平台博客网站的搭建",
    "url": "https://www.infoq.cn/article/66c2a20169b6cb5906f9db64b",
    "summary": "<p></p><h1>使用Cloud Studio&amp;Flutter完成全平台博客网站的搭建</h1><p></p><p></p><p></p><h1>前言</h1><p></p><p>本文我将使用Cloud Studio 以及Flutter完成自己的一个博客平台的搭建。并且会将该项目作为模版，供大家使用。</p><p></p><p>先来看一下效果</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/51/511c76a4911f18553d552dbb600f0ff4.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ed/ed8211dafd8de7d376e3c1abcab1c46f.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/8a/8ae60b9434d140c6daaaf9b84cb472c7.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/a5/a5e191b5f571848a34747ce2714e196a.png\" /></p><p></p><h1>一.Cloud Studio</h1><p></p><p>Cloud Studio 是基于浏览器的集成式开发环境(IDE)，为开发者提供了一个永不间断的云端工作站。用户在使用CloudStudio 时无需安装，随时随地打开浏览器就能在线编程。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b2/b247a08e076eeb1470247b714e709e3e.png\" /></p><p></p><p>大家也看到了，很多模版以及环境都有提供，大家也都知道我以前是搞Flutter的，于是就先尝试了一下Flutter模版，然后刚开始，可能确实不太会，但熟悉了一会，就发现他的好处了。</p><p></p><p>Cloud Studio 作为在线IDE，包含代码高亮、自动补全、Git集成、终端等IDE的基础功能，同时支持实时调试、插件扩展等，可以帮助开发者快速完成各种应用的开发、编译与部署工作。我将这次的这个博客网站使用Cloud Studio推送到了Gitee，<a href=\"https://gitee.com/jianguo888/flutter_bloc_super\">大家可以访问。</a>\"</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/85/85f2a1b3b84e59890d93f0dc39af3747.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ae/ae50de82c3f2f13c51a7d46e99800709.png\" /></p><p></p><h1>二.应用场景</h1><p></p><p>Cloud Studio 在线编程工具适用于以下几个场景：</p><p></p><h2>2.1快速启动项目</h2><p></p><p>使用 Cloud Studio 的预置环境，您可以直接创建对应类型的工作空间，快速启动项目进入开发状态，无需进行繁琐的环境配置。</p><p></p><p>下面就是我的工作空间，大家可以下次使用的时候，进入对应的工作空间，就可以继续编写代码，很是方便。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b0/b0040e32a5c689bf98bf92eaf96c58d9.png\" /></p><p></p><h2>2.2实时调试网页</h2><p></p><p>Cloud Studio 内置预览插件，可以实时显示网页应用。当您的代码发生改变之后，预览窗口会自动刷新，这样您就可以在 Cloud Studio 内实时开发调试网页了。</p><p></p><p>下面这个就是我创建的第一个模版项目，你会发现很是方便。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/5d/5d27bf7cfaa9f6912300fa558d66a9a2.png\" /></p><p></p><h2>2.3远程访问云服务器</h2><p></p><p>Cloud Studio 支持您连接自己的云服务器，这样就可以在编辑器中查看云服务器上的文件，进行在线编程和部署工作。</p><p></p><p>只有有自己的云服务器，那么你就可以在这里通过配置，很方便的入手开发。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/de/de863fef3ecba375232895919c03e449.png\" /></p><p></p><h1>三.登录注册</h1><p></p><p>Cloud Studio 在线编程平台支持使用 <a href=\"https://coding.net/\">CODING (opens new window)</a>\"账号和 GitHub 账号，以及微信登录，可以在<a href=\"https://codingcorp.cloudstudio.net/api/public/login\">登录 (opens new window)</a>\"界面输入相应的账号登录前往 Web IDE，这里我用的是微信登录。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/6a/6aa9b20bbbcf929b84e3446d7b2f99c3.png\" /></p><p></p><h1>四.工作空间的创建与使用</h1><p></p><p>一个工作空间是一个虚拟计算单元，它包含独立的存储、计算资源以及开发环境。Cloud Studio 是以工作空间来组织的，本文为您介绍如何创建工作空间。</p><p></p><h2>4.1创建工作空间</h2><p></p><p>进入 Cloud Studio 云端 IDE，可以通过两种方式创建工作空间，第一种方式：点击模板直接创建工作空间，第二种方式：单击【新建工作空间】，进入工作空间创建页面</p><p></p><h3>4.1.1填写工作空间信息</h3><p></p><p>第一种方式点击模板创建工作空间，可自动生成工作空间名称，并运行模板的预置环境及样本代码。这里我用的是Flutter。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/6c/6c8704f10d1e27ed91ea968e7155ba8c.png\" /></p><p></p><p>第二种方式，选择创建工作空间，然后选择预置环境，填写工作空间名、描述，并选择运行环境和代码来源。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/f3/f308a840eec389da75501c2df70c2869.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/04/043f6130fff31544bdd1b464cccce74a.png\" /></p><p></p><p>工作空间名：您的工作空间的唯一标识，只能由字母、数字、下划线（_）、中划线（-）、点（.）组成，不能包含空格或其它字符。描述：对该工作空间作用的描述。运行环境：工作空间内代码运行的环境，您可以选择预置环境，包含 Ubuntu、Python、Java 和 Node.js 四种；也可以选择将其连接到自己的云服务器上，代码来源：工作空间内的代码来源，此处我们选择“空”，即不添加任何代码。</p><p></p><p>单击【创建】按钮，即可完成工作空间的创建。您还可以创建代码来自于 Git 仓库的工作空间，代码会被自动克隆到工作空间</p><p></p><h2>4.2工作空间的使用</h2><p></p><p>您可以在 Cloud Studio 云端 IDE 的工作空间内存放自己的项目代码，安装所需要的软件环境，运行或编译项目，本文为您介绍如何使用工作空间。</p><p></p><p>注意：</p><p></p><p>数量限制：目前每个用户最多可以创建 10 个工作空间，并且只能同时运行一个工作空间，如果您需要打开另一个工作空间需要先关闭当前运行中的工作空间。时间限制：每个用户每月可以免费使用工作空间共 3000 分钟，超出时间将产生扣费（连接云主机的工作空间无此限制）。</p><p></p><h3>4.2.1工作空间界面简介</h3><p></p><p>工作空间是我们主要的工作区域，主要由顶部菜单栏、左侧操作面板、右侧代码编辑区和底部状态栏组成。</p><p></p><p>您可以根据自己的习惯设置界面外观、偏好，安装自己需要的插件。</p><p></p><p>需要注意的是，您的偏好设置和插件在每个工作空间中是互相隔离的，也就是说您可以给不同的工作空间设置不同的偏好，安装不同的插件。这里面大部分和你在本地使用vscode是一样的。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/85/85f2a1b3b84e59890d93f0dc39af3747.png\" /></p><p></p><p>我们可以通过终端来进行这些操作，点击菜单栏--终端--新终端，会在底部打开一个面板，点击【终端】切换到终端。</p><p></p><h3>4.2.2管理工作空间</h3><p></p><p>在 Cloud Studio 云端 IDE 的工作空间列表页面，您可以运行、停止、删除和恢复工作空间。</p><p></p><h4>运行</h4><p></p><p>单击对应的工作空间卡片，就会在新的页面打开并运行该空间，此时该工作空间卡片上会显示“运行中”状态。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/90/90543a9c03994794b43a378679dccad2.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/48/4858759ef857ce8e1b795a5243434928.png\" /></p><p></p><h4>停止</h4><p></p><p>对于处在“运行中”状态的工作空间，单击卡片右边的【停止】，就可以停止运行该工作空间。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/fc/fc7b1dd20510c97b5ab8235d14e954f3.png\" /></p><p></p><h4>删除</h4><p></p><p>您可以删除未运行的工作空间，单击工作空间卡片右下角的【删除】即可删除。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/bc/bc00a0322626716ae455d02c8ea4019b.png\" /></p><p></p><h4>恢复</h4><p></p><p>为了防止误删除，已删除的工作空间会展示在下方“已删除的工作空间”列表中，保留24小时。在此之前您可以随时单击【恢复】，还原您的工作空间，超过 24 小时未恢复的工作空间将被永远销毁。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/0f/0f90218cbd97182a1085b5511851001a.png\" /></p><p></p><h1>五.使用 Git 进行版本控制</h1><p></p><p>Cloud Studio 云端 IDE 的工作空间支持从代码仓库创建，不过在此之前您需要将工作空间的 SSH Key 添加至对应代码托管平台的个人公钥列表。</p><p></p><h2>5.1Cloud Studio 查看SSH公钥</h2><p></p><p>这里我们点击个人头像，打开系统设置，里面有SSH公钥，然后我们把密钥复制，添加到Gitee</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/8b/8b3dbb779b8c7ad5b17ceabc83aa6d66.png\" /></p><p></p><h2>5.2Gitee添加SSH公钥</h2><p></p><p>在下图，添加SSH公钥，补充标题和公钥</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/06/066b76745a7e72c555fb3d20f9f03e5a.png\" /></p><p></p><h2>5.3Gitee上新建一个仓库</h2><p></p><p><img src=\"https://static001.geekbang.org/infoq/fb/fbea260cb81fb12c4220c91fdac51aea.png\" /></p><p></p><p>在我们的云IDE的工作空间里，打开终端。</p><p></p><h2>5.4Cloud Studio配置邮箱和密码</h2><p></p><p><code lang=\"text\">git config --global user.name \"坚果\"    \n\ngit config --global user.email \"852851198@qq.com\"                                                            \n</code></p><p></p><h2>5.5Cloud Studio提交代码</h2><p></p><p>然后初始化仓库，提交修改，添加commit信息，然后推送</p><p></p><p><code lang=\"text\">git init\ngit remote add origin git@gitee.com:jianguo888/flutter_bloc_super.git\ngit add .\ngit commit -s -m '初始化'\ngit push origin master\n</code></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/f8/f8ed19208fb1f57b2351bebee4e33a44.png\" /></p><p></p><h1>六.Flutter博客网站的开发</h1><p></p><p>Flutter 是谷歌的移动UI框架，Flutter 最近发布了 Flutter V3.10.6，可以快速在 iOS、Android、Web 等多平台上构建高质量的原生用户界面。 Flutter 可以与现有的代码一起工作。在全世界，Flutter 正在被越来越多的开发者和组织使用，并且 Flutter 是完全免费、开源的。 目前 Cloud Studio 云端 IDE 支持 Flutter Web 应用开发。这就是为什么今天我们使用在 Web、macOS 应用、Android 和 iOS 应用上运行的 flutter 创建响应式博客主题。</p><p></p><h2>6.1创建项目</h2><p></p><p>打开云IDE之后，创建一个Flutter项目，当前，我使用的是 Flutter 3.0.1</p><p></p><p>创建完成之后，我们就可以编写代码</p><p></p><p>首先打开云IDE，选择创建项目</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d3/d317bed09fff4e71284a945099afd22e.png\" /></p><p></p><p>然后这里我们给自己的项目命名</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b9/b9c9ed84c330c6420691ea4f162437a3.png\" /></p><p></p><p>等待项目加载完成</p><p></p><p>然后运行下面的这行命令</p><p></p><p><code lang=\"text\">cd ./ &amp;&amp; flutter pub get &amp;&amp; flutter run -d web-server --web-port 9000  --web-hostname 0.0.0.0 &amp;&amp; echo success\n</code></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/c1/c1fcd65cb5f8ec9ee7af6e4595aaeaba.png\" /></p><p></p><p>我们可以选择打开内置浏览器或者浏览器</p><p></p><p>这里我选择打来浏览器，大家可以看到这个项目运行成功。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/02/02bcba9297a2e885e9c965e7c7532af4.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b2/b2642d840b66c86e8355f0b38dfc2c13.png\" /></p><p></p><p>这个时候，说明我们的环境是ok的。我们可以后面的工作了</p><p></p><h2>6.2.打开端口面板实时预览调试</h2><p></p><p>点击最右边的按钮弹出预览页面。</p><p></p><p>看到这些红色的文字 To hot restart changes while running, press \"r\" or \"R\". 说明项目编译好了。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/7e/7e9ea61773e26b2776df3f8db4abc079.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/9c/9c4604a77560e3237560bdde9916e0ec.png\" /></p><p></p><p>修改代码重新编译</p><p></p><p>点击终端， 按 r 键即可重新编译， 再按预览页面的刷新按钮即可看到实时修改后的效果。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/4a/4ac845d266d5f4a60b5b1393d6be95e4.png\" /></p><p></p><p>目前 Flutter Web 应用不支持热更新，需要手动刷新页面。要项目编译完成才能代码预览页面， 否则会一直卡在 Loading 界面。一直卡在 Loading 界面可尝试刷新预览界面。</p><p></p><h2>6.3发布web版</h2><p></p><p>我们希望你完成迁移后尽快将其发布，可以作为预览版：</p><p></p><p>参考文章：https://dart.cn/null-safety/migration-guide</p><p></p><p>细心的小伙伴可能会发现,安卓有android文件夹, iOS 有ios的文件夹,但目前目录结构是没有web文件夹的,</p><p></p><h3>6.3.1. 创建web文件夹</h3><p></p><p>输入下面的命令创建web文件</p><p></p><p><code lang=\"undefined\">flutter create .\n</code></p><p></p><p>然后就会创建一系列web相关的文件 ,如下图, 目录结构也会多一个web的文件夹. 如下图</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d3/d3507c2894f6d43299fe9f103665873a.png\" /></p><p></p><h3>6.3.2. 打包web版本</h3><p></p><p>我们知道要给android手机用,需要打包apk出来, 要给iPhone手机用,需要打包ipa出来;同样的道理要给浏览器用,也需要打包web相关代码.</p><p></p><p><code lang=\"undefined\">flutter build web --web-renderer html\n\nflutter build web \n\nflutter build web --web-renderer canvaskit\n</code></p><p></p><p>这将生成包括资源的应用程序，并将文件放入项目的 /build/web 目录中。</p><p></p><p>一般的应用程序的 release 版本具有以下结构：</p><p></p><p>content_copy</p><p></p><p><code lang=\"none\">/build/web\n  assets\n    AssetManifest.json\n    FontManifest.json\n    NOTICES\n    fonts\n      MaterialIcons-Regular.ttf\n      \n    <img />\n  index.html\n  main.dart.js\n  main.dart.js.map\n</code></p><p></p><p>启动 Web 服务器（例如，python -m SimpleHTTPServer 8000，或使用 <a href=\"https://pub.flutter-io.cn/packages/dhttpd\">dhttpd</a>\" package），然后打开 /build/web 目录。在浏览器中访问 localhost:8000（前文用 Python 启动的服务器）以查看应用程序的 release 版本。</p><p></p><p>经过测试,上面三种方式都可以打包web版本, 其中第一种是针对移动端的打包方式, 第二种是一般的打包方式, 第三种是针对pc端的打包方式.</p><p></p><p>那这3种方式打包出来,运行起来有什么不同呢</p><p></p><p>flutter build web --web-renderer html 打开速度最快,兼容性好(是指ie,chrome,safari等浏览器兼容)</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d4/d44130dda9b176797ada90b434bc682e.png\" /></p><p></p><p>flutter build web 打开速度一般,兼容性好</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/3a/3a8ea748f8bfe5a34160bdf6640613ae.png\" /></p><p></p><p>flutter build web --web-renderer canvaskit 打开速度最慢,兼容性好</p><p></p><h2>6.3.3结论</h2><p></p><p>就是使用第一种打包方式会比较好</p><p></p><p><code lang=\"undefined\">flutter build web --web-renderer html\n</code></p><p></p><h2>6.4常见问题</h2><p></p><p></p><h3>坑1:  找到了index.html,用浏览器打开一片空白</h3><p></p><p>这个属于正常的, 这个不像前端web ,html css js那套,点击index.html就能访问的.  在flutter里面是不能直接访问的,一定要放到容器里面去才能访问,如:tomcat等</p><p></p><h3>坑2:  已经用nginx代理,用浏览器打开还是一片空白</h3><p></p><p>那是因为文件路径引用不对.解决办法有2种方法1:用编辑器打开index.html,能看到源文件,把,改成</p><p></p><p>方法2:用编辑器打开index.html,能看到源文件,把,改成你服务器的路径比喻说:</p><p></p><p>然后nginx代理</p><p></p><p><code lang=\"dart\">  #flutter\n    server {\n       listen       251 ;\n       server_name  flutterblog;\n       location / {\n           root   /root/study/flutter/web/;\n           index  index.html index.htm;\n        #    proxy_pass   http://127.0.0.1:12345;\n        #    access_log  /usr/local/nginx/logs/go.101.log ;\n\n       }\n    }\n</code></p><p></p><p>撒花</p><p></p><h1>七.自定义模板</h1><p></p><p>自定义模板是 Cloud Studio 云端 IDE 推出的面向团队模板能力的功能。该功能支持将当前项目作为自定义模板，能够覆盖到 Git 仓库的项目、普通项目、示例项目等，很大程度上提高了团队标准化代码开发环境的一大诉求。</p><p></p><h2>7.1自定义模板功能简介</h2><p></p><p>当前自定义模板实现的功能主要有四个方面，创建、发布、分享和管理自定义模板。</p><p></p><h2>7.2创建自定义模板</h2><p></p><p>当您处在当前项目 IDE 中，您可以创建自定义模板：</p><p></p><p>这里我把我的Flutter 博客网站发布成模版。</p><p></p><p>（1）点击功能栏中的“文件”，在下拉选项中选择“发布自定义模板”；</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/f1/f1f1359c495b50f4e438c8fb3b0652af.png\" /></p><p></p><p>（2）右侧布局窗口中会自动打开新标签页，可以选择您心仪的图标和标签，以及填写您模板的描述</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/72/7218f66b9cde2919168ca0e49953c80c.png\" /></p><p></p><p>点击完成</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/c6/c6e13b81d07edc9d67ad35b71c6b1842.png\" /></p><p></p><h2>7.3发布自定义模板</h2><p></p><p>当您成功填写完自定义模板信息后，您可以进行自定义模板发布：</p><p></p><p>（1）点击“完成”即可发布您的自定义模板；</p><p></p><p>（2）在分享前点击“再次发布”，可以修改您的发布信息后再次分享，分享链接无变化，根据原模板已创建的 IDE 实例不受影响；</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/06/064ba2459af6cb6d91771b6644c3ce93.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/16/1696749275196cf513b7a439dd19fdeb.png\" /></p><p></p><h2>7.4分享自定义模板</h2><p></p><p>当您的模板发布成功后，您可以有两种方式分享自定义模板：</p><p></p><p>（1）进入分享页，复制您的自定义模板链接，分享给您的伙伴；</p><p></p><p>坚果（个人）分享了「Flutter Blog」模板 https://cloudstudio.net/templates/r9IAX1JuTF2</p><p></p><p>（2）通过嵌入 Markdown 徽章进行分享，将模板徽章嵌入 README 文件或者博客中，您的伙伴点击徽章即可获取模板；</p><p></p><p><img src=\"https://static001.infoq.cn/static/write/img/img-copy-disabled.4f2g7h.png\" /></p><p></p><p>至此，我们的一整个流程就完成了。</p><p></p><h1>总结</h1><p></p><p>通过这一次的一个体验过程，我总结了一下几个优势：</p><p></p><p>Cloud Studio 作为 Web IDE/在线 IDE/Cloud IDE，和本地 IDE 相比具有以下优势：</p><p></p><p>无需安装，跨平台：只要有浏览器就可以使用；预置常用环境，无需手动安装；支持创建网页预览，在线开发调试。全功能：无需下载安装，随时随地开发编码，拥有媲美本地 IDE 的流畅编码体验。多环境：内置 Node.js、Java、Python 等常见环境，也可以连接到云服务器进行资源管理。兼容 VS Code 插件：若默认的配置无法满足需求，可以在线安装 VS Code 插件来增强使用体验。持久化和快速加载：随开随写，随时保存，再也无需担心断电未保存，不浪费您的每一份灵感。</p><p></p><p>在我的体验下，概括来说就是Cloud Studio 是用来开发中小型项目，在线修改代码，或者连接云服务器进行部署工作的不二之选。真正的达到了一键秒开、全持久化、预置环境及内置开发工具，跨团队无缝复制和共享，让开发化繁为简。</p>",
    "publish_time": "2023-07-28 09:01:05",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "科技领导者的崭新征途：聚焦业务协作，多维能力支撑",
    "url": "https://www.infoq.cn/article/fI93WehedVlcYx4BCBq0",
    "summary": "<p>随着数字经济的高速发展，中国科技领导者在经济高质量发展中扮演着至关重要的角色。在不确定性快速上升的时代和企业期待的转变中，他们作为中国数字经济发展的推动者和护航者，正面临着一场崭新的征途。在此背景下，InfoQ研究中心与TGO鲲鹏会共同组织发起了针对科技领导者的调研工作，制作并发布了《中国科技领导者画像研究报告》，在报告中详细拆解了科技领导者面临的时代和企业期望的变化，以及科技领导者自身的成长路径。</p><p></p><p>VUCA时代下，科技创新成为企业发展的核心动力</p><p>在复杂且不确定的VUCA时代中，科技的力量超出了传统的经济和商业的期待。越来越多的企业意识到科技赋能业务的重要性，需要科技创新提供更多解决方案，并带来新的希望和机遇。为了应对这种变化，数据驱动与敏捷迭代两方面的能力成为科技领导者应对时代挑战并推动企业发展的必备能力。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/3b/3b3c8c90d56162e69ce7a9b85513e490.png\" /></p><p></p><p>企业期待科技领导者同时具有技术能力与领导能力</p><p>科技领导者们的企业内在价值在不断提升，企业也越来越认可科技领导者所带来的技术价值。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d7/d7fa04c388fcd144afd090876632ba05.png\" /></p><p></p><p>出于这份认可，互联网行业科技领导者价值被逐渐推高并进入追捧期。在经历过市场追捧期后，非互联网行业的企业更加理性地评估CTO、CIO等职位的价值、设置与人选。企业不仅仅期望科技领导者的加入能够带来技术升级，也期望能够影响并带动生产、运营等其他团队。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/97/97b4ff91c44081197f5af0b49ff4b47c.png\" /></p><p></p><p>科技领导者不但要有相匹配的技术能力，还要具备相应的管理意识与业务认知，能够让企业的需求切实落地。</p><p>InfoQ研究中心发现，数字化程度越高的企业越是需要科技领导者具有技术战略高度视野、前沿技术理解力、技术赋能力、深度技术落地理解力。内部业务协同多样、外部服务团队多样、内部团队规模大的企业对科技领导者的团队领导能力要求越高。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e2/e2ddbcd1e1b25195f72cc1fafea638f6.png\" /></p><p></p><p>双重变化下，科技领导者画像升级</p><p>通过对时代背景和企业期望的分析，InfoQ研究中心将科技领导者人群画像升级为四大能力要求。</p><p>一是数据驱动。他们需要具备业务决策能力和实践领导力，应用数据的采集和业务流程分析，通过合适的技术、演进方案、人员成本来解决企业的问题。</p><p>二是敏捷迭代。这对科技领导者在团队内部的领导力提出了更高的要求。科技领导者需要向团队澄清目标并辅助团队成长。在团队软性文化打造上发力，为团队带来心理安全感与工作责任感，并且通过精准的个体辅导增强团队凝聚力。</p><p>三是边际融合。在各部门之间，科技领导者需要以更扎实的业务成长方法论与业务领导力，聚焦业务需求、帮助业务创新、辅助业务部门决策并协调团队之间的合作。</p><p>四是协同共生。这意味着科技领导者需要具备协作领导力。通过与内部、外部合作伙伴，如供应商、客户、合作伙伴等，建立良好的合作关系并让合作伙伴清晰地理解正在进行的工作，指导企业制定相应的技术战略和业务发展计划。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/a3/a3906168210f0ce9a3f21f7149a54aa3.png\" /></p><p></p><p>在快速变化的局势和企业的多维度期待下，科技领导者必须让业务领导力、团队领导力、个人领导力得到均衡地成长，并同时沿着技术成长、业务成长、管理成长的路径进行发展，聚焦于通用能力。不断增长的视野与能力的提升将成为他们应对时代湍流的强大武器，助力他们引领企业迈向更加光明的未来。</p><p></p><p>中国科技领导者画像正在经历着非常微妙的变化，想要了解更多中国科技领导者的人群画像、成长路径等内容，欢迎点击链接或扫描二维码添加小助手下载完整报告：<a href=\"https://www.infoq.cn/article/3amBoEYUc5mjsEP3VAVG\">https://www.infoq.cn/article/3amBoEYUc5mjsEP3VAVG</a>\"</p><p><img src=\"https://static001.geekbang.org/infoq/70/70d97552604ebf82671669e143cb27e1.png\" /></p><p></p>",
    "publish_time": "2023-07-28 10:47:41",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]