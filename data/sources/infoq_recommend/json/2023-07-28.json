[
  {
    "title": "新手入门：探索eBPF的可观测性与安全性工作流",
    "url": "https://www.infoq.cn/article/085bCgNVTETVFvAr62i4",
    "summary": "<p>本文分享了学习eBPF的经验，eBPF是一种新的云原生技术，其目标是改善可观测性和安全性工作流。我们可能感觉它的入门门槛很高，通过eBPF工具来辅助生产环境调试的步骤会很多。本文将会介绍如何使用相关的工具并将其应用到自己的开发中，请逐步迭代自己的知识，并将其用到更高级的使用场景中。最后，我们会讨论如何在CI/CD中实现自动化开发及其面临的挑战。</p><p></p><h2>如何开始入门eBPF？</h2><p></p><p></p><p>我第一次听说eBPF是在2021年，当时它是与可观测性相关的主题一起出现的，起初我并不能真正理解它的含义。描述中声称这是一种收集事件数据的新方法，有助于提升可观测性，也有助于实现安全的可观测性和实际执行。</p><p></p><p>实际上，我后来才知道，Falco使用eBPF来探查Kubernetes中容器的活动。我的学习历程是将Falco视为云原生的安全工具，而没有去质疑其底层的技术。<a href=\"https://www.oreilly.com/library/view/hacking-kubernetes/9781492081722/\">“Hacking Kubernetes”</a>\"一书帮助我完善了对容器运行时、eBPF和安全执行的学习。</p><p></p><p><a href=\"https://opsindev.news/archive/2022-06-13/#kubecon-eu\">KubeCon EU 2022上的eBPF日</a>\"，以及后续的<a href=\"https://opsindev.news/archive/2022-10-15/#ebpf-summit\">eBPF峰会活动</a>\"，都有助于说明这一点。eBPF的学习策略与技术领域的其他知识类似，也就是倾听、做笔记，但你依然无法理解它的所有内容。</p><p></p><p>参加讲座和阅读文章时，我们经常会遇到一些需要认识的术语模式，比如，我立即记住的术语包括eBPF、BPF、bcc、bpftrace和iovisor。<a href=\"https://www.brendangregg.com/index.html\">Brendan Gregg的博客</a>\"也经常被提及。</p><p></p><p>在一个社区聚会上，通过自由讨论营（barcamp）式的演讲，我问到，“如何开始使用eBPF？”。随后，我们使用三张幻灯片拉开了关于它如何运行的讨论，一起验证了相关的知识，并思考了其使用场景。在eBPF峰会上，有一个名为 <a href=\"https://github.com/isovalent/eBPF-Summit-2022-CTF\">Capture-the-Flag的环境</a>\"可以进行学习，这吸引我停下脚步并亲自进行探索挑战。随后，我决定在自己的公共学习平台o11y.love上收集<a href=\"https://o11y.love/topics/ebpf/\">所有的eBPF资源</a>\"，并决定以公开的方式进行学习，记录在这个过程中遇到的所有错误、误解和问题。</p><p></p><p>内核开发听起来很难，而且理解和入门eBPF可能存在一定的障碍。对于利用eBPF的工具和库，改变使用它们的方法，并配合生产环境的用例（例如在生产中进行调试），这极大地帮助了我的学习和迭代。对Linux操作系统、资源处理和故障排除的一般理解也很有助益。</p><p></p><p>更高层次的阐述和ebpf.io上的描述图片有助于对eBPF架构的一般理解。我非常喜欢来自Brendan Gregg的<a href=\"https://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html\">解释</a>\"：</p><p></p><p></p><blockquote>“eBPF对Linux的作用就像JavaScript对HTML的作用。（某种程度上，可以这么说。）因此，JavaScript可以让我们定义在点击鼠标等事件中运行的小型程序，而不再是静态的HTML站点，这些程序会在浏览器的安全虚拟机中运行。有了eBPF之后，我们不再是一个固定的内核，而是可以编写在磁盘I/O等事件上运行的小型程序，这些程序会在内核的安全虚拟机中运行。实际上，eBPF更像是运行JavaScript的v8虚拟机，而不是JavaScript本身。eBPF是Linux内核的一部分。”</blockquote><p></p><p></p><p>eBPF被添加到Linux内核中，以实现小型的沙箱程序。这兼顾了稳定的内核需求和少量的创新可能性，而eBPF程序能够有助于扩展和驱动创新，而不会阻碍内核的发展。</p><p></p><p>eBPF的用例包括高性能网络和负载均衡、应用程序的追踪和性能问题的排查。此外，细粒度的安全可观测性和应用/容器的运行时安全执行也是我能想到的场景。</p><p></p><p>编写eBPF程序是很难的，内核期望的是字节码，但是它手动编写的效率并不高。因此，需要有一个抽象层，包括从更高级的编程语言生成字节码的编译器。在这种情况下，经常涉及到的工具是Cilium、bcc和bpftrace。eBPF程序的校验发生在从字节码向机器特定指令集的即时编译过程中。这使得在CI/CD工作流中进行静态校验更加困难。稍后，我们会看到更多这方面的内容。</p><p></p><p>在了解了需求之后，真正的问题在于，我们有什么实际的例子可以尝试和学习，然后深入研究实际的源码？</p><p></p><h2>正式开始：游乐场</h2><p></p><p></p><p>Brendan Gregg的<a href=\"https://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html\">学习eBPF跟踪：教程和样例</a>\"博文是一个很好的起点。不同的尝试和路线最终都会回到这里进行自学。在深入研究库和eBPF程序如何构建之前，在命令行上尝试不同的工具并测试它们的效果，这是一个很好的策略。</p><p></p><p>注意：Liz Rice的<a href=\"https://www.oreilly.com/library/view/learning-ebpf/9781098135119/\">“Learning eBPF”</a>\"一书能够有助于进一步降低入门门槛，该书于2023年3月出版。</p><p></p><p>推荐的入门方式是选择具有最新内核（大约4.17版本）的Linux发行版，如Ubuntu 22.04 LTS。请使用本地虚拟化方法，或在你喜欢的云厂商上生成一个虚拟机。下面的样例使用Hetzner Cloud CLI来生成一个新的Ubuntu虚拟机：</p><p></p><p><code lang=\"text\">$ hcloud server create --image ubuntu-22.04 --type cx21 --name ebpf-chaos\n</code></p><p></p><p>请根据你的需要重新创建设置过程，可以考虑编写Ansible playbooks或脚本来重复安装步骤。这对跟团队成员分享具体学习环境中使用的工具和库会很有帮助。本文讨论的工具和想法在<a href=\"https://go.gitlab.com/xtBYnL\">GitLab上有基于Ansible的样例</a>\"。有些默认的工具需要安装（git、wget、curl、htop和docker），还有eBPF、混沌实验和可观测性等更具体的用例。</p><p></p><p>接下来的章节将讨论eBPF工具的样例。要构建和安装它们，需要Linux内核头文件和额外的依赖。在Ubuntu 22 LTS上还有一个额外的步骤就是启用<a href=\"https://wiki.ubuntu.com/Debug%20Symbol%20Packages\">DDebs仓库</a>\"，以访问调试符号（debug symbol），接下来是一个完整的编译器工具链。<a href=\"https://go.gitlab.com/PPwfc5\">该针对eBPF的Ansible配置</a>\"详细描述了安装步骤。你可以查看Git的历史记录，了解学习的步骤以及这个过程中的错误。下面的几节主要是运行这些工具，并阐述它们的使用场景。</p><p></p><h3>跟踪系统调用</h3><p></p><p></p><p>你可能已经使用过strace命令来跟踪运行中的二进制文件的系统调用，查看是否有文件被打开和权限错误等。Brendan Gregg的教程博客建议从提供execsnoop命令的<a href=\"https://github.com/iovisor/bcc\">bcc toolchain</a>\"开始。它可以跟踪exec()系统调用。一个很容易的测试方法是打开SSH连接，或者在另外一个终端上执行curl opsindev.news命令。</p><p></p><p><code lang=\"text\">$ execsnoop -t\n\n115.816 curl             879320 879305   0 /usr/bin/curl opsindev.news\n118.481 sshd             879322 67197    0 /usr/sbin/sshd -D -R\n124.287 sshd             879324 67197    0 /usr/sbin/sshd -D -R\n</code></p><p></p><p>我们已经学习了一种跟踪系统调用的新方法。bcc工具链提供了更多实用的工具和用例。从学习的角度来讲，还有哪些工具可以用来深入研究eBPF呢？</p><p></p><h3>bpftrace：高级的跟踪语言</h3><p></p><p></p><p><a href=\"https://github.com/iovisor/bpftrace\">Bpftrace</a>\"提供了自己的高层级跟踪语言，类似于DTrace这样的调试框架。乍看上去，在线样例可能会让人无所适从，但由于我们使用的是测试虚拟机，所以可以运行这些样例，以后再分析语言。Bpftrace允许我们跟踪更多的系统调用，例如open()。这个方法可以用来打开文件、套接字等，更通用地来讲，是进程可以打开的所有内容，不管是善意还是恶意的。它可以视为strace命令的一种更为现代的方式。</p><p></p><p>为了使用可预测的样例来测试bpftrace，我们可以使用这个最小化的C程序，它打开一个文件句柄来创建新文件（<a href=\"https://go.gitlab.com/0mtuqx\">源码</a>\"）：</p><p></p><p><code lang=\"text\">#include \n#include \n#include \n#include \n#include \n#include \n\nint main()\n{\n  int fd;\n\n  if ((fd=open(\"ebpf-chaos.txt\", O_WRONLY | O_CREAT, 0660)) == -1)\n  {\n    printf(\"Cannot open file.\");\n    exit(1);\n  }\n\n  close(fd);\n}\n</code></p><p></p><p>使用gcc编译器编译C程序，并在启动bpftrace命令后运行它。如果opensnoop.bt命令在Ubuntu 22 LTS上运行失败的话，请从DDeb仓库安装调试符号。</p><p></p><p><code lang=\"text\">$ gcc sim-open-file.c -o sim-open-file\n$ chmod +x sim-open-file\n$ ./sim-open-file\n</code></p><p></p><p><code lang=\"text\">$ bpftrace -e 'tracepoint:syscalls:sys_enter_openat { printf(\"%s %s\\n\", comm, str(args-&gt;filename)); }'\n\nAttaching 1 probe...\nsim-open-call /etc/ld.so.cache\nsim-open-call /lib/x86_64-linux-gnu/libc.so.6\nsim-open-call\n</code></p><p></p><p>跟踪语言允许挂钩进入特定的系统调用。要找到正确的系统调用名称，需要慢慢试验，可能还会遇到错误。我不得不将sys_enter_open改为sys_enter_openat来触发C程序中的打开文件的调用。bpftrace -l可以列出所有可跟踪的系统调用。</p><p></p><p><code lang=\"text\">$ bpftrace -l 'tracepoint:syscalls:sys_enter_open*'\ntracepoint:syscalls:sys_enter_open\ntracepoint:syscalls:sys_enter_open_by_handle_at\ntracepoint:syscalls:sys_enter_open_tree\ntracepoint:syscalls:sys_enter_openat\ntracepoint:syscalls:sys_enter_openat2\n</code></p><p></p><p>上述代码会将命令和文件名的路径打印到终端上。访问要打印的文件名需要阅读C结构的代码，以了解在这种情况下，哪些属性是可用的。</p><p></p><p>学习曲线的“顿悟时刻（aha moment）”不仅仅会看到文件打开和写入调用，而且还会加载库的依赖关系（stdlib需要libc）。bfptrace工具对于验证二进制文件是否真的加载了某些库是非常有用的，其次是使用ldd和nm来窥探依赖关系和调试符号。</p><p></p><p><code lang=\"text\">$ ldd sim-open-call\n    linux-vdso.so.1 (0x00007ffe42c78000)\n    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f24c7247000)\n    /lib64/ld-linux-x86-64.so.2 (0x00007f24c747d000)\n\n$ nm sim-open-call | grep open\n                 U open@GLIBC_2.2.5\n</code></p><p></p><h3>深入研究源码和eBPF程序</h3><p></p><p></p><p><a href=\"https://github.com/iovisor/bcc\">BPF编译器集合（BPF Compiler Collection，BCC）</a>\"提供了一些样例来学习内核和用户空间之间的数据传输和交互。以前的样例只是挂钩系统调用并立即返回。BCC在C代码中提供了内核插装，并允许使用Python或Lua编写前端用户空间的应用。按照描述，使用场景包括性能分析和网络流量控制，这都是很好的洞察点，并为以后的知识验证增加了学习难度。Python和C语言知识有助于更容易地深入研究这些样例。</p><p></p><p>另外，基于我的研究过程，推荐<a href=\"https://github.com/libbpf/libbpf\">libbpf</a>\"库，因为它的<a href=\"https://github.com/libbpf/libbpf-bootstrap\">bootstrap项目</a>\"提供了更多的演示应用。它们提供了真实的程序，可以用来实现自己的第一个eBPF程序。其中有一个样例是使用Rust编写的，允许我们按照<a href=\"https://en.wikipedia.org/wiki/Express_Data_Path\">XDP规范</a>\"检查网络流量以及数据包的大小。eXpress Data Path（XDP）允许在大规模网络调用时挂钩发送/接收的网络数据包，这会发生在中断之后和内存分配之前。例如，这可以用来悄悄地丢弃数据包（请注意后面高级的eBPF程序开发用例）。</p><p></p><p>用户需要指定端口号，这会导致再一轮的试验和错误排查。使用eth0作为接口名称无法成功运行。这个样例的输出源自同一台主机上运行的Prometheus服务器实例，产生的网络流量来自以HTTP端点探查监控目标的输出。</p><p></p><p><code lang=\"text\">$ apt install rustc cargo clang rustfmt\n\n$ git clone https://github.com/libbpf/libbpf-bootstrap\n$ cd libbpf-bootstrap/examples/rust\n$ cargo build\n$ cargo run\n\n$ sudo ./target/debug/xdp 1 #if number\n\n$ sudo tail -f /sys/kernel/debug/tracing/trace_pipe  \n\nprometheus-660     [001] d.s11 295903.782373: bpf_trace_printk: packet size: 74\nprometheus-659     [000] d.s11 295903.782735: bpf_trace_printk: packet size: 74\nprometheus-659     [000] d.s11 295903.782762: bpf_trace_printk: packet size: 54\nprometheus-671     [001] d.s11 295908.509751: bpf_trace_printk: packet size: 352\nprometheus-671     [001] d.s11 295908.513184: bpf_trace_printk: packet size: 4162\nprometheus-671     [001] d.s11 295908.513218: bpf_trace_printk: packet size: 66\nprometheus-671     [001] d.s11 295908.513295: bpf_trace_printk: packet size: 4162\nprometheus-671     [001] d.s11 295908.513307: bpf_trace_printk: packet size: 66\nprometheus-671     [001] d.s11 295908.513368: bpf_trace_printk: packet size: 1630\n</code></p><p></p><p>在构建和运行更多的样例后，我们并不完全清楚复制或修改源码是否为一个好的策略。如何将XDP样例缩减至最小的尺寸？也许有更好的方法来逐步入手编写eBPF程序代码，并增加学习过程中获得的经验。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/learning-ebpf-observability/en/resources/2figure-1-large-1684250535157.jpg\" /></p><p></p><h2>eBPF程序开发，学习更多用例</h2><p></p><p></p><p>在深入研究如何开发自己的程序之前，了解BPF和eBPF的基础知识是很重要的。eBPF是Berkley Packet Filter（BPF）的一个扩展版本，它提供了一个运行在Linux内核中的抽象虚拟机，在受控的环境中运行eBPF程序。从根本上说，Linux内核中的“老”BPF标准可以被<a href=\"https://ebpf.io/what-is-ebpf/#what-do-ebpf-and-bpf-stand-for\">称为“经典BPF”，以便于和eBPF进行区分</a>\"。</p><p></p><p>我们可以从尝试bcc工具开始，运行bpftrace并识别在日常业务和事件中有助于SRE和DevOps工程师的用例。这可能包括跟踪程序的启动/退出、查看控制组（cgroups）、观察TCP连接、检查网络接口等等。建议尽可能保持用例的简单性，以确保稳定的学习曲线。</p><p></p><p>在验证了关于eBPF的基础知识并定义了用例之后，请以<a href=\"https://ebpf.io/infrastructure/\">库和工具链</a>\"的形式探寻抽象的概念。现代编译器和库可用于Go、Rust和C/C++。在决定编写eBPF程序之前，建议先学习基本的编程语言。根据我自己的经验，在具有C++或Python知识之后，学习Rust是一条可行的发展道路。这有助于避免内存处理相关的运行时错误，与C/C++ eBPF程序相比，可以说这是一种更安全的方法。</p><p></p><p>Cillium在一个<a href=\"https://github.com/cilium/ebpf\">Golang的开源库中</a>\"实现了它的eBPF功能。除了学习编写自己的eBPF程序外，该库还提供了如下用例：将程序附加到入口/出口、计算egress流量包，以及探查网络接口（请注意XDP术语，以供后续学习）。XDP程序可以用Go编译器工具链进行构建，并接受接口名称作为命令行参数。它使用map来持久化特定IP地址的网络包的数量；对于Kubernetes节点上的任意类型的网络接口，探查容器流量或跟踪嵌入式硬件的流量都是很好的使用场景。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/learning-ebpf-observability/en/resources/2figure-2-large-1684250535158.jpg\" /></p><p></p><p>如果你觉得编写Rust代码更舒服的话，aya-rs的维护者提供了一个<a href=\"https://github.com/aya-rs/aya\">Rust开发人员工具链</a>\"，包含一本带有教程的<a href=\"https://aya-rs.dev/book/\">图书</a>\"。书中的样例实现了一个类似的XDP网络流量场景，可以直接从Cargo构建链中运行，使开发过程更加高效。</p><p></p><p><code lang=\"text\">$ git clone https://github.com/aya-rs/book aya-rs-book\n$ cd examples/xdp-hello\n$ cargo install bpf_linker\n$ cargo xtask build-ebpf\n$ cargo build\n\n$ RUST_LOG=info cargo xtask run\n</code></p><p></p><p>样例程序没有跟踪IP地址及其数据包的数量，但是这可以作为一个很好的练习，模仿Go库样例中的行为。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/learning-ebpf-observability/en/resources/2figure-3-large-1684250535158.jpg\" /></p><p></p><p>aya-rs的其他实际用例是持续剖析（profiling），Polar Signals的开发人员将Rust库用到了Parca代理中，用于自动的函数调用栈分析和更好的内存安全性（<a href=\"https://static.sched.com/hosted_files/cloudnativeebpfdayeu22/7f/eBPF%20Day%202022_KubeCon%20EU_%20eBPF%3F%20Safety%20First%21.pdf\">来自KubeCon EU 2022 eBPF日上的幻灯片</a>\"和<a href=\"https://github.com/parca-dev/parca-agent/pull/377\">Pull Request</a>\"）。</p><p></p><p>有不同的方式来着手开发eBPF程序。请记住，该架构遵循将字节码编译的eBPF程序加载到内核，并需要一个用户空间的“收集器（collector）”或“打印器（printer）”。通信是通过套接字或文件句柄进行的。</p><p></p><h2>测试和校验eBPF程序</h2><p></p><p></p><p>在CI/CD流水线中自动化测试eBPF程序是很棘手的事情，因为内核会在加载时验证eBPF程序并拒绝潜在的不安全程序。测试将会需要一个新的虚拟机沙箱，加载eBPF程序，并模拟内核和eBPF程序相关的行为。需求包括触发事件，再次触发eBPF程序代码所订阅的钩子。根据不同的目的，这会涉及到不同的内核接口和系统调用（网络、文件访问等）。创建一个独立的单元测试mock是很难的，需要开发人员模拟一个运行中的内核。</p><p></p><p>有人<a href=\"https://blog.trailofbits.com/2023/01/19/ebpf-verifier-harness/\">试图将eBPF验证器转移到内核之外</a>\"，并允许在CI/CD中测试eBPF程序。同时，在CI/CD中加载eBPF程序需要一个运行中的Linux虚拟机，其CI/CD的runner/executor要具有较高的权限。在Ubuntu 22 LTS中，加载非特权程序默认已被禁用，可能需要通过运行sudo sysctl kernel.unprivileged_bpf_disabled=0来启用。</p><p></p><h3>CI/CD中的持续测试</h3><p></p><p></p><p>为了提供持续测试的CI/CD runner环境，建议使用Ansible/Terraform生成一个Linux虚拟机，安装CI/CD runner，将其注册到CI/CD服务器上，并准备好加载和运行eBPF程序的需求。对于不同的供应商来说，这是一个通用的模式。下面的样例使用Ansible安装并注册GitLab Runner到GitLab.com项目中，然后使用它来构建和运行eBPF程序。GitLab Runner注册了标签ebpf，它将只会执行使用了该标签的CI/CD job。</p><p></p><p><code lang=\"text\">---\n\n- name: GitLab Runner for eBPF\nhosts: all\nvars:\nansible_python_interpreter: /usr/bin/python3\ntasks:\n- name: Get GitLab repository installation script\nget_url:\nurl: \"https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh\"\ndest: /tmp/gitlab-runner.script.deb.sh\nmode: 0744\n- name: Install GitLab repository\ncommand: bash /tmp/gitlab-runner.script.deb.sh\nargs:\ncreates: \"/etc/apt/sources.list.d/runner_gitlab-runner.list\"\nbecome: true\n- name: Install GitLab Runner\napt:\nname: gitlab-runner\nstate: present\nallow_downgrade: true\nbecome: true\nenvironment:\nGITLAB_RUNNER_DISABLE_SKEL: \"true\"\n\n- name: Allow the gitlab-runner user to run any commands as root with sudo -u root\ncommunity.general.sudoers:\nname: gitlab-runner sudo\nstate: present\nuser: gitlab-runner\nrunas: root\ncommands: ALL # Review this for production usage. For demos, it is enabled, and forked MR CI/CD builds won't run.\n</code></p><p></p><p><a href=\"https://docs.gitlab.com/runner/register/\">注册</a>\"需要gl_runner_registration_token变量，该变量来自GitLab项目中针对CI/CD Runners的配置。</p><p></p><p><code lang=\"text\">---\n- name: GitLab Runner for eBPF - register once\nhosts: all\nvars:\nansible_python_interpreter: /usr/bin/python3\ntasks:\n- name: \"Configure GitLab Runner (running to populate config.toml)\"\ncommand: &gt;\ngitlab-runner register\n--non-interactive\n--url \"https://gitlab.com/\"\n--executor \"shell\"\n--tag-list ebpf\n--registration-token=\"{{ gl_runner_registration_token }}\"\n</code></p><p></p><p>GitLab runner可以在项目设置的CI/CD &gt; Runners中看到。</p><p></p><h3>在CI/CD中测试基于Rust的eBPF程序</h3><p></p><p></p><p>我们使用一个实际的eBPF程序来尝试一下CI/CD工作流，这里使用aya-rs Rust库模板作为演示样例。首先，在Linux虚拟机上本地安装Rust和所需的eBPF，以验证一切均能正常运行。</p><p></p><p><code lang=\"text\">curl https://sh.rustup.rs -sSf | sh\nsource \"$HOME/.cargo/env\"\n\nrustup install stable\nrustup install nightly\n\nrustup default stable\nrustup toolchain add nightly\nrustup component add rust-src --toolchain nightly\n\n# required for cargo-generate\napt -y install libssl-dev\n\ncargo install cargo-generate\ncargo install bpf-linker\ncargo install bindgen-cli\n</code></p><p></p><p>接下来，生成一个模板骨架树，用于使用XDP（eXpress Data Path）类型创建一个演示程序。探查ebpf-chaos-demo-xdp/src/main.rs中的代码，并更新网络接口名。然后，构建并运行程序，将日志级别设置为info（或debug）。</p><p></p><p><code lang=\"text\">cargo generate --name ebpf-chaos-demo-xdp -d program_type=xdp https://github.com/aya-rs/aya-template.git\n\nRUST_LOG=info cargo xtask run\n</code></p><p></p><p>示例代码由两部分组成：ebpf-chaos-demo-xdp-ebpf/src/main.rs中的内核空间eBPF程序和ebpf-chaos-demo-xdp/src/main.rs中的用户空间程序，后者会加载eBPF程序并将其附加至内核跟踪点。为了只构建eBPF程序，我们可以调用build-ebpf xtask并使用llvm-objdump命令检查字节码：</p><p></p><p><code lang=\"text\">cargo xtask build-ebpf\n\nllvm-objdump -S target/bpfel-unknown-none/debug/ebpf-chaos-demo-xdp\n</code></p><p></p><p>完整的源代码位于<a href=\"https://go.gitlab.com/QfjbTn\">该GitLab项目</a>\"中，可以使用GitLab CI/CD流水线进行测试。注意，它需要在runner环境中安装Rust工具链。随后的流水线运行将会使用配置好的缓存。该流水线有三个job：</p><p></p><p>install-deps准备Rust环境，这需要将CARGO_HOME变量指定为runner的项目目录。aya-rs-xdp-build-ebpf构建核心eBPF程序，并运行llvm-objdump命令。aya-rs-xdp-run运行用户空间程序，这需要sudo权限。它会将命令放到后台，捕获stdout，睡眠60秒，然后使用pkill来杀死xtask命令，最后打印捕获到的输出。</p><p></p><p>对输出分析进行增强以及思考运行eBPF程序的更多测试报告是留给读者的练习。</p><p></p><p><code lang=\"text\"># eBPF GitLab Runner required for this project\n# Note: Various commands need sudo/root access on the Linux host, see ansible-config/.\n# By default, for security reasons, CI/CD pipelines are not run from forks in the parent project.\n# See https://docs.gitlab.com/ee/ci/pipelines/merge_request_pipelines.html#use-with-forked-projects  \ndefault:\n  tags:\n    - ebpf\n\nstages:\n  - pre\n  - build\n  - run\n\nvariables:\n  RUST_LOG: \"info\"\n  RUNTIME: 300 # set to &gt;= 5*60 = 300s because cargo xtask run also compiles the binary first\n                              \n\n# These steps should not take long after subsquent runs on the Linux VM\ninstall-deps:\n  stage: pre\n  script:\n    - sudo apt install libssl-dev # required for cargo-generate on Ubuntu 22 LTS\n    - curl https://sh.rustup.rs -sSf -o rustup.sh\n    - sh rustup.sh -y --profile default\n    - source \"$HOME/.cargo/env\"\n    - rustup install stable\n    - rustup install nightly\n    - rustup default stable\n    - rustup toolchain add nightly\n    - rustup component add rust-src --toolchain nightly\n    # 'cargo install' is not idempotent. --force takes too long. Treat an error as 'ok, installed' here.\n    - cargo install cargo-generate bpf-linker bindgen-cli || true\n\naya-rs-xdp-build-ebpf:\n  stage: build\n  script:\n    - cd examples/ebpf-chaos-demo-xdp\n    - source \"$HOME/.cargo/env\"\n    - cargo xtask build-ebpf\n    - llvm-objdump -S target/bpfel-unknown-none/debug/ebpf-chaos-demo-xdp\n\naya-rs-xdp-run:\n  stage: run\n  # We need to send the cargo xtask run command into the background, capture stdout, kill it after a defined interval, and generate a test report for CI/CD\n  script:\n    - cd examples/ebpf-chaos-demo-xdp\n    - source \"$HOME/.cargo/env\"\n    - rm ${CI_PROJECT_DIR}/run.pid\n    - nohup cargo xtask run &gt; ${CI_PROJECT_DIR}/nohup.out 2&gt;&amp;1 &amp; echo $! &gt; ${CI_PROJECT_DIR}/run.pid\n    - sleep $RUNTIME\n    - kill -s TERM `cat ${CI_PROJECT_DIR}/run.pid` || true\n    - rm ${CI_PROJECT_DIR}/run.pid  \n    - cat \"${CI_PROJECT_DIR}/nohup.out\"\n    - echo \"Finished running eBPF program. TODO - analyze the output more.\"\n  artifacts:\n    expire_in: 30 days\n    paths:\n      - ${CI_PROJECT_DIR}/nohup.out\n</code></p><p></p><p>该截屏显示了运行eBPF程序的job，以及捕获网络数据包的日志输出。根据对源代码的修改，输出会发生变化并且可以进行测试。一个思路是以机器可读的格式总结捕获到的数据包，并在终止时创建一个汇总表。在CI/CD以及命令行中，这种方式更易于消费和理解。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/learning-ebpf-observability/en/resources/2figure-4-large-1684251660936.jpg\" /></p><p></p><p>将进程放入后台的方法可能无法正确地唤醒它，这可能需要更好的信号处理实现。它远远谈不上完美，你可以在这个<a href=\"https://go.gitlab.com/7xvkFu\">合并请求中看到我的学习历史</a>\"。可能有更好的方式来构建要发布的二进制文件，并通过supervisorctl或systemd命令来启动它，这是下一个学习步骤。终止和卸载过程的实现比较棘手。下面的代码片段实现了正确的信号处理，但是无法始终从运行中的内核卸载已注册的XDP链接。另一种方法是为每次的CI/CD运行生成一个新的Linux虚拟机，以避免这些可重复性相关的失败。但是，其缺点是我们需要一个Rust构建的远程缓存，以避免较长的CI/CD构建运行时间。</p><p></p><p><code lang=\"text\">// Implement signal handling for CTRL+C and SIGTERM\nuse tokio::signal::unix::{signal, SignalKind};\n\n…\n\n    let program: &amp;mut Xdp = bpf.program_mut(\"ebpf_chaos_demo_xdp\").unwrap().try_into()?;\n    program.load()?;\n    program.attach(&amp;opt.iface, XdpFlags::default())\n        .context(\"failed to attach the XDP program with default flags - try changing XdpFlags::default() to XdpFlags::SKB_MODE\")?;\n\n\n    // Implement signal handling for CTRL+C (SIGINT) and SIGTERM\n    // CTRL+C can be used for terminal tests\n    // SIGTERM will be sent from CI/CD jobs to the background process\n    let mut sigterm = signal(SignalKind::terminate())?;\n    let mut sigint = signal(SignalKind::interrupt())?;\n\n    tokio::select! {\n        _ = sigterm.recv() =&gt; { println!(\"SIGTERM shutting down\") }\n        _ = sigint.recv() =&gt; { println!(\"SIGINT shutting down\") }\n    }\n\n    Ok(())\n    // Destroying the bpf object will detach and cleanup the loaded program.\n    // Debug with 'bpftool link show'\n}\n</code></p><p></p><h3>CI/CD和DevSecOps工作流的额外待办事项</h3><p></p><p>剩下的挑战就是扩展eBPF程序以生成测试报告，并创建运行时测试环境，即通过用curl命令运行网络流量测试周期，并验证输出包的确切大小。另外，架构也很重要，要么eBPF程序被加载到内核中，并且有一个用户空间应用来读取其结果，要么eBPF程序是一个单一的二进制文件，直接附加其探针。后者需要在CI/CD job中将程序发送至后台，捕获它的输出，执行测试，然后合并测试报告。对于DevSecOps工作流来说，这个过程还有许多需要改进的地方，但我相信在不久的将来我们会达到最终的目的。</p><p></p><p>代码覆盖是测试eBPF程序的另一个新领域。目前并没有太多的工具帮助开发人员理解代码在Linux内核中运行时的路径，哪些代码区域会受到影响，哪些代码没有被覆盖到。<a href=\"https://www.elastic.co/blog/code-coverage-for-ebpf-programs\">bpfcov是由Elastic的工程师创建的</a>\"，以帮助解决这个问题，让开发人员了解eBPF程序的代码执行路径。在CI/CD中运行自动化的代码质量和安全扫描也是一项挑战：如何确定一个有可能拖慢内核操作的编程错误呢？比较有意思的是，我们可以看一下eBPF程序的持续剖析（continuous profiling）是否可以实现（本身就是使用eBPF的，如<a href=\"https://www.parca.dev/\">Parca项目</a>\"）。还有一些编程模式会规避内核验证器，并造成对软件供应链的安全攻击，通过贡献的拉取和合并请求，将恶意代码注入到已发布的eBPF程序中。这需要<a href=\"https://go.gitlab.com/vvAGaM\">DevSecOps工作流</a>\"来确保安全措施行之有效。AI可能也会提供一些帮助。</p><p></p><h2>结论</h2><p></p><p></p><p>eBPF是一种收集可观测性数据的新方法，它有助于实现网络洞察力，以及安全的可观测性和执行。为了获得最好的库、工具和框架，我们需要一起公开学习，以降低知识的壁垒，并使每个人都能做出贡献。从测试现有的工具到编写eBPF程序的详细教程，我们还有很长的路要走。在CI/CD中进行eBPF程序测试和验证是一项重要的工作，接下来就是将所有的想法带到上游，降低使用和贡献eBPF开源项目的入门门槛。</p><p></p><p>要想开始相关的工作，需要启动一个Linux虚拟机，使用脚本/Ansible进行可重复的设置，并进行测试和开发。当接口名称和内核技术阻碍学习的进度时，那就回退一步，你并没有必要完全理解eBPF的全部内容。当遇到生产环境中断时，对数据收集有一般化的了解能够提供一定的帮助。最后，但同样重要的是，这里有个提示，那就是当调试eBPF程序时，考虑在多个发行版上进行测试，避免遇到内核相关的缺陷。</p><p></p><p>作者简介：</p><p>Michael Friedrich是GitLab的高级开发人员布道者，专注于可观测性、DevSecOps和AI。Michael创建了o11y.love作为可观测性学习平台，并在他的opsindev.news通讯中分享技术趋势以及对day-2ops、eBPF、AI/MLOps的见解。在没有旅行和远程工作的时候，他喜欢搭建乐高模型。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/learning-ebpf-observability/\">Learning eBPF for Better Observability</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/5xvC1Ic6BdLQYju6YWV0\">颠覆传统、应用大爆发，eBPF&nbsp;何以改变 Linux？</a>\"</p>",
    "publish_time": "2023-07-28 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "使用Cloud Studio&Flutter完成全平台博客网站的搭建",
    "url": "https://www.infoq.cn/article/66c2a20169b6cb5906f9db64b",
    "summary": "<p></p><h1>使用Cloud Studio&amp;Flutter完成全平台博客网站的搭建</h1><p></p><p></p><p></p><h1>前言</h1><p></p><p>本文我将使用Cloud Studio 以及Flutter完成自己的一个博客平台的搭建。并且会将该项目作为模版，供大家使用。</p><p></p><p>先来看一下效果</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/51/511c76a4911f18553d552dbb600f0ff4.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ed/ed8211dafd8de7d376e3c1abcab1c46f.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/8a/8ae60b9434d140c6daaaf9b84cb472c7.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/a5/a5e191b5f571848a34747ce2714e196a.png\" /></p><p></p><h1>一.Cloud Studio</h1><p></p><p>Cloud Studio 是基于浏览器的集成式开发环境(IDE)，为开发者提供了一个永不间断的云端工作站。用户在使用CloudStudio 时无需安装，随时随地打开浏览器就能在线编程。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b2/b247a08e076eeb1470247b714e709e3e.png\" /></p><p></p><p>大家也看到了，很多模版以及环境都有提供，大家也都知道我以前是搞Flutter的，于是就先尝试了一下Flutter模版，然后刚开始，可能确实不太会，但熟悉了一会，就发现他的好处了。</p><p></p><p>Cloud Studio 作为在线IDE，包含代码高亮、自动补全、Git集成、终端等IDE的基础功能，同时支持实时调试、插件扩展等，可以帮助开发者快速完成各种应用的开发、编译与部署工作。我将这次的这个博客网站使用Cloud Studio推送到了Gitee，<a href=\"https://gitee.com/jianguo888/flutter_bloc_super\">大家可以访问。</a>\"</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/85/85f2a1b3b84e59890d93f0dc39af3747.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ae/ae50de82c3f2f13c51a7d46e99800709.png\" /></p><p></p><h1>二.应用场景</h1><p></p><p>Cloud Studio 在线编程工具适用于以下几个场景：</p><p></p><h2>2.1快速启动项目</h2><p></p><p>使用 Cloud Studio 的预置环境，您可以直接创建对应类型的工作空间，快速启动项目进入开发状态，无需进行繁琐的环境配置。</p><p></p><p>下面就是我的工作空间，大家可以下次使用的时候，进入对应的工作空间，就可以继续编写代码，很是方便。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b0/b0040e32a5c689bf98bf92eaf96c58d9.png\" /></p><p></p><h2>2.2实时调试网页</h2><p></p><p>Cloud Studio 内置预览插件，可以实时显示网页应用。当您的代码发生改变之后，预览窗口会自动刷新，这样您就可以在 Cloud Studio 内实时开发调试网页了。</p><p></p><p>下面这个就是我创建的第一个模版项目，你会发现很是方便。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/5d/5d27bf7cfaa9f6912300fa558d66a9a2.png\" /></p><p></p><h2>2.3远程访问云服务器</h2><p></p><p>Cloud Studio 支持您连接自己的云服务器，这样就可以在编辑器中查看云服务器上的文件，进行在线编程和部署工作。</p><p></p><p>只有有自己的云服务器，那么你就可以在这里通过配置，很方便的入手开发。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/de/de863fef3ecba375232895919c03e449.png\" /></p><p></p><h1>三.登录注册</h1><p></p><p>Cloud Studio 在线编程平台支持使用 <a href=\"https://coding.net/\">CODING (opens new window)</a>\"账号和 GitHub 账号，以及微信登录，可以在<a href=\"https://codingcorp.cloudstudio.net/api/public/login\">登录 (opens new window)</a>\"界面输入相应的账号登录前往 Web IDE，这里我用的是微信登录。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/6a/6aa9b20bbbcf929b84e3446d7b2f99c3.png\" /></p><p></p><h1>四.工作空间的创建与使用</h1><p></p><p>一个工作空间是一个虚拟计算单元，它包含独立的存储、计算资源以及开发环境。Cloud Studio 是以工作空间来组织的，本文为您介绍如何创建工作空间。</p><p></p><h2>4.1创建工作空间</h2><p></p><p>进入 Cloud Studio 云端 IDE，可以通过两种方式创建工作空间，第一种方式：点击模板直接创建工作空间，第二种方式：单击【新建工作空间】，进入工作空间创建页面</p><p></p><h3>4.1.1填写工作空间信息</h3><p></p><p>第一种方式点击模板创建工作空间，可自动生成工作空间名称，并运行模板的预置环境及样本代码。这里我用的是Flutter。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/6c/6c8704f10d1e27ed91ea968e7155ba8c.png\" /></p><p></p><p>第二种方式，选择创建工作空间，然后选择预置环境，填写工作空间名、描述，并选择运行环境和代码来源。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/f3/f308a840eec389da75501c2df70c2869.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/04/043f6130fff31544bdd1b464cccce74a.png\" /></p><p></p><p>工作空间名：您的工作空间的唯一标识，只能由字母、数字、下划线（_）、中划线（-）、点（.）组成，不能包含空格或其它字符。描述：对该工作空间作用的描述。运行环境：工作空间内代码运行的环境，您可以选择预置环境，包含 Ubuntu、Python、Java 和 Node.js 四种；也可以选择将其连接到自己的云服务器上，代码来源：工作空间内的代码来源，此处我们选择“空”，即不添加任何代码。</p><p></p><p>单击【创建】按钮，即可完成工作空间的创建。您还可以创建代码来自于 Git 仓库的工作空间，代码会被自动克隆到工作空间</p><p></p><h2>4.2工作空间的使用</h2><p></p><p>您可以在 Cloud Studio 云端 IDE 的工作空间内存放自己的项目代码，安装所需要的软件环境，运行或编译项目，本文为您介绍如何使用工作空间。</p><p></p><p>注意：</p><p></p><p>数量限制：目前每个用户最多可以创建 10 个工作空间，并且只能同时运行一个工作空间，如果您需要打开另一个工作空间需要先关闭当前运行中的工作空间。时间限制：每个用户每月可以免费使用工作空间共 3000 分钟，超出时间将产生扣费（连接云主机的工作空间无此限制）。</p><p></p><h3>4.2.1工作空间界面简介</h3><p></p><p>工作空间是我们主要的工作区域，主要由顶部菜单栏、左侧操作面板、右侧代码编辑区和底部状态栏组成。</p><p></p><p>您可以根据自己的习惯设置界面外观、偏好，安装自己需要的插件。</p><p></p><p>需要注意的是，您的偏好设置和插件在每个工作空间中是互相隔离的，也就是说您可以给不同的工作空间设置不同的偏好，安装不同的插件。这里面大部分和你在本地使用vscode是一样的。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/85/85f2a1b3b84e59890d93f0dc39af3747.png\" /></p><p></p><p>我们可以通过终端来进行这些操作，点击菜单栏--终端--新终端，会在底部打开一个面板，点击【终端】切换到终端。</p><p></p><h3>4.2.2管理工作空间</h3><p></p><p>在 Cloud Studio 云端 IDE 的工作空间列表页面，您可以运行、停止、删除和恢复工作空间。</p><p></p><h4>运行</h4><p></p><p>单击对应的工作空间卡片，就会在新的页面打开并运行该空间，此时该工作空间卡片上会显示“运行中”状态。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/90/90543a9c03994794b43a378679dccad2.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/48/4858759ef857ce8e1b795a5243434928.png\" /></p><p></p><h4>停止</h4><p></p><p>对于处在“运行中”状态的工作空间，单击卡片右边的【停止】，就可以停止运行该工作空间。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/fc/fc7b1dd20510c97b5ab8235d14e954f3.png\" /></p><p></p><h4>删除</h4><p></p><p>您可以删除未运行的工作空间，单击工作空间卡片右下角的【删除】即可删除。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/bc/bc00a0322626716ae455d02c8ea4019b.png\" /></p><p></p><h4>恢复</h4><p></p><p>为了防止误删除，已删除的工作空间会展示在下方“已删除的工作空间”列表中，保留24小时。在此之前您可以随时单击【恢复】，还原您的工作空间，超过 24 小时未恢复的工作空间将被永远销毁。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/0f/0f90218cbd97182a1085b5511851001a.png\" /></p><p></p><h1>五.使用 Git 进行版本控制</h1><p></p><p>Cloud Studio 云端 IDE 的工作空间支持从代码仓库创建，不过在此之前您需要将工作空间的 SSH Key 添加至对应代码托管平台的个人公钥列表。</p><p></p><h2>5.1Cloud Studio 查看SSH公钥</h2><p></p><p>这里我们点击个人头像，打开系统设置，里面有SSH公钥，然后我们把密钥复制，添加到Gitee</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/8b/8b3dbb779b8c7ad5b17ceabc83aa6d66.png\" /></p><p></p><h2>5.2Gitee添加SSH公钥</h2><p></p><p>在下图，添加SSH公钥，补充标题和公钥</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/06/066b76745a7e72c555fb3d20f9f03e5a.png\" /></p><p></p><h2>5.3Gitee上新建一个仓库</h2><p></p><p><img src=\"https://static001.geekbang.org/infoq/fb/fbea260cb81fb12c4220c91fdac51aea.png\" /></p><p></p><p>在我们的云IDE的工作空间里，打开终端。</p><p></p><h2>5.4Cloud Studio配置邮箱和密码</h2><p></p><p><code lang=\"text\">git config --global user.name \"坚果\"    \n\ngit config --global user.email \"852851198@qq.com\"                                                            \n</code></p><p></p><h2>5.5Cloud Studio提交代码</h2><p></p><p>然后初始化仓库，提交修改，添加commit信息，然后推送</p><p></p><p><code lang=\"text\">git init\ngit remote add origin git@gitee.com:jianguo888/flutter_bloc_super.git\ngit add .\ngit commit -s -m '初始化'\ngit push origin master\n</code></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/f8/f8ed19208fb1f57b2351bebee4e33a44.png\" /></p><p></p><h1>六.Flutter博客网站的开发</h1><p></p><p>Flutter 是谷歌的移动UI框架，Flutter 最近发布了 Flutter V3.10.6，可以快速在 iOS、Android、Web 等多平台上构建高质量的原生用户界面。 Flutter 可以与现有的代码一起工作。在全世界，Flutter 正在被越来越多的开发者和组织使用，并且 Flutter 是完全免费、开源的。 目前 Cloud Studio 云端 IDE 支持 Flutter Web 应用开发。这就是为什么今天我们使用在 Web、macOS 应用、Android 和 iOS 应用上运行的 flutter 创建响应式博客主题。</p><p></p><h2>6.1创建项目</h2><p></p><p>打开云IDE之后，创建一个Flutter项目，当前，我使用的是 Flutter 3.0.1</p><p></p><p>创建完成之后，我们就可以编写代码</p><p></p><p>首先打开云IDE，选择创建项目</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d3/d317bed09fff4e71284a945099afd22e.png\" /></p><p></p><p>然后这里我们给自己的项目命名</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b9/b9c9ed84c330c6420691ea4f162437a3.png\" /></p><p></p><p>等待项目加载完成</p><p></p><p>然后运行下面的这行命令</p><p></p><p><code lang=\"text\">cd ./ &amp;&amp; flutter pub get &amp;&amp; flutter run -d web-server --web-port 9000  --web-hostname 0.0.0.0 &amp;&amp; echo success\n</code></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/c1/c1fcd65cb5f8ec9ee7af6e4595aaeaba.png\" /></p><p></p><p>我们可以选择打开内置浏览器或者浏览器</p><p></p><p>这里我选择打来浏览器，大家可以看到这个项目运行成功。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/02/02bcba9297a2e885e9c965e7c7532af4.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b2/b2642d840b66c86e8355f0b38dfc2c13.png\" /></p><p></p><p>这个时候，说明我们的环境是ok的。我们可以后面的工作了</p><p></p><h2>6.2.打开端口面板实时预览调试</h2><p></p><p>点击最右边的按钮弹出预览页面。</p><p></p><p>看到这些红色的文字 To hot restart changes while running, press \"r\" or \"R\". 说明项目编译好了。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/7e/7e9ea61773e26b2776df3f8db4abc079.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/9c/9c4604a77560e3237560bdde9916e0ec.png\" /></p><p></p><p>修改代码重新编译</p><p></p><p>点击终端， 按 r 键即可重新编译， 再按预览页面的刷新按钮即可看到实时修改后的效果。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/4a/4ac845d266d5f4a60b5b1393d6be95e4.png\" /></p><p></p><p>目前 Flutter Web 应用不支持热更新，需要手动刷新页面。要项目编译完成才能代码预览页面， 否则会一直卡在 Loading 界面。一直卡在 Loading 界面可尝试刷新预览界面。</p><p></p><h2>6.3发布web版</h2><p></p><p>我们希望你完成迁移后尽快将其发布，可以作为预览版：</p><p></p><p>参考文章：https://dart.cn/null-safety/migration-guide</p><p></p><p>细心的小伙伴可能会发现,安卓有android文件夹, iOS 有ios的文件夹,但目前目录结构是没有web文件夹的,</p><p></p><h3>6.3.1. 创建web文件夹</h3><p></p><p>输入下面的命令创建web文件</p><p></p><p><code lang=\"undefined\">flutter create .\n</code></p><p></p><p>然后就会创建一系列web相关的文件 ,如下图, 目录结构也会多一个web的文件夹. 如下图</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d3/d3507c2894f6d43299fe9f103665873a.png\" /></p><p></p><h3>6.3.2. 打包web版本</h3><p></p><p>我们知道要给android手机用,需要打包apk出来, 要给iPhone手机用,需要打包ipa出来;同样的道理要给浏览器用,也需要打包web相关代码.</p><p></p><p><code lang=\"undefined\">flutter build web --web-renderer html\n\nflutter build web \n\nflutter build web --web-renderer canvaskit\n</code></p><p></p><p>这将生成包括资源的应用程序，并将文件放入项目的 /build/web 目录中。</p><p></p><p>一般的应用程序的 release 版本具有以下结构：</p><p></p><p>content_copy</p><p></p><p><code lang=\"none\">/build/web\n  assets\n    AssetManifest.json\n    FontManifest.json\n    NOTICES\n    fonts\n      MaterialIcons-Regular.ttf\n      \n    <img />\n  index.html\n  main.dart.js\n  main.dart.js.map\n</code></p><p></p><p>启动 Web 服务器（例如，python -m SimpleHTTPServer 8000，或使用 <a href=\"https://pub.flutter-io.cn/packages/dhttpd\">dhttpd</a>\" package），然后打开 /build/web 目录。在浏览器中访问 localhost:8000（前文用 Python 启动的服务器）以查看应用程序的 release 版本。</p><p></p><p>经过测试,上面三种方式都可以打包web版本, 其中第一种是针对移动端的打包方式, 第二种是一般的打包方式, 第三种是针对pc端的打包方式.</p><p></p><p>那这3种方式打包出来,运行起来有什么不同呢</p><p></p><p>flutter build web --web-renderer html 打开速度最快,兼容性好(是指ie,chrome,safari等浏览器兼容)</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d4/d44130dda9b176797ada90b434bc682e.png\" /></p><p></p><p>flutter build web 打开速度一般,兼容性好</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/3a/3a8ea748f8bfe5a34160bdf6640613ae.png\" /></p><p></p><p>flutter build web --web-renderer canvaskit 打开速度最慢,兼容性好</p><p></p><h2>6.3.3结论</h2><p></p><p>就是使用第一种打包方式会比较好</p><p></p><p><code lang=\"undefined\">flutter build web --web-renderer html\n</code></p><p></p><h2>6.4常见问题</h2><p></p><p></p><h3>坑1:  找到了index.html,用浏览器打开一片空白</h3><p></p><p>这个属于正常的, 这个不像前端web ,html css js那套,点击index.html就能访问的.  在flutter里面是不能直接访问的,一定要放到容器里面去才能访问,如:tomcat等</p><p></p><h3>坑2:  已经用nginx代理,用浏览器打开还是一片空白</h3><p></p><p>那是因为文件路径引用不对.解决办法有2种方法1:用编辑器打开index.html,能看到源文件,把,改成</p><p></p><p>方法2:用编辑器打开index.html,能看到源文件,把,改成你服务器的路径比喻说:</p><p></p><p>然后nginx代理</p><p></p><p><code lang=\"dart\">  #flutter\n    server {\n       listen       251 ;\n       server_name  flutterblog;\n       location / {\n           root   /root/study/flutter/web/;\n           index  index.html index.htm;\n        #    proxy_pass   http://127.0.0.1:12345;\n        #    access_log  /usr/local/nginx/logs/go.101.log ;\n\n       }\n    }\n</code></p><p></p><p>撒花</p><p></p><h1>七.自定义模板</h1><p></p><p>自定义模板是 Cloud Studio 云端 IDE 推出的面向团队模板能力的功能。该功能支持将当前项目作为自定义模板，能够覆盖到 Git 仓库的项目、普通项目、示例项目等，很大程度上提高了团队标准化代码开发环境的一大诉求。</p><p></p><h2>7.1自定义模板功能简介</h2><p></p><p>当前自定义模板实现的功能主要有四个方面，创建、发布、分享和管理自定义模板。</p><p></p><h2>7.2创建自定义模板</h2><p></p><p>当您处在当前项目 IDE 中，您可以创建自定义模板：</p><p></p><p>这里我把我的Flutter 博客网站发布成模版。</p><p></p><p>（1）点击功能栏中的“文件”，在下拉选项中选择“发布自定义模板”；</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/f1/f1f1359c495b50f4e438c8fb3b0652af.png\" /></p><p></p><p>（2）右侧布局窗口中会自动打开新标签页，可以选择您心仪的图标和标签，以及填写您模板的描述</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/72/7218f66b9cde2919168ca0e49953c80c.png\" /></p><p></p><p>点击完成</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/c6/c6e13b81d07edc9d67ad35b71c6b1842.png\" /></p><p></p><h2>7.3发布自定义模板</h2><p></p><p>当您成功填写完自定义模板信息后，您可以进行自定义模板发布：</p><p></p><p>（1）点击“完成”即可发布您的自定义模板；</p><p></p><p>（2）在分享前点击“再次发布”，可以修改您的发布信息后再次分享，分享链接无变化，根据原模板已创建的 IDE 实例不受影响；</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/06/064ba2459af6cb6d91771b6644c3ce93.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/16/1696749275196cf513b7a439dd19fdeb.png\" /></p><p></p><h2>7.4分享自定义模板</h2><p></p><p>当您的模板发布成功后，您可以有两种方式分享自定义模板：</p><p></p><p>（1）进入分享页，复制您的自定义模板链接，分享给您的伙伴；</p><p></p><p>坚果（个人）分享了「Flutter Blog」模板 https://cloudstudio.net/templates/r9IAX1JuTF2</p><p></p><p>（2）通过嵌入 Markdown 徽章进行分享，将模板徽章嵌入 README 文件或者博客中，您的伙伴点击徽章即可获取模板；</p><p></p><p><img src=\"https://static001.infoq.cn/static/write/img/img-copy-disabled.4f2g7h.png\" /></p><p></p><p>至此，我们的一整个流程就完成了。</p><p></p><h1>总结</h1><p></p><p>通过这一次的一个体验过程，我总结了一下几个优势：</p><p></p><p>Cloud Studio 作为 Web IDE/在线 IDE/Cloud IDE，和本地 IDE 相比具有以下优势：</p><p></p><p>无需安装，跨平台：只要有浏览器就可以使用；预置常用环境，无需手动安装；支持创建网页预览，在线开发调试。全功能：无需下载安装，随时随地开发编码，拥有媲美本地 IDE 的流畅编码体验。多环境：内置 Node.js、Java、Python 等常见环境，也可以连接到云服务器进行资源管理。兼容 VS Code 插件：若默认的配置无法满足需求，可以在线安装 VS Code 插件来增强使用体验。持久化和快速加载：随开随写，随时保存，再也无需担心断电未保存，不浪费您的每一份灵感。</p><p></p><p>在我的体验下，概括来说就是Cloud Studio 是用来开发中小型项目，在线修改代码，或者连接云服务器进行部署工作的不二之选。真正的达到了一键秒开、全持久化、预置环境及内置开发工具，跨团队无缝复制和共享，让开发化繁为简。</p>",
    "publish_time": "2023-07-28 09:01:05",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "科技领导者的崭新征途：聚焦业务协作，多维能力支撑",
    "url": "https://www.infoq.cn/article/fI93WehedVlcYx4BCBq0",
    "summary": "<p>随着数字经济的高速发展，中国科技领导者在经济高质量发展中扮演着至关重要的角色。在不确定性快速上升的时代和企业期待的转变中，他们作为中国数字经济发展的推动者和护航者，正面临着一场崭新的征途。在此背景下，InfoQ研究中心与TGO鲲鹏会共同组织发起了针对科技领导者的调研工作，制作并发布了《中国科技领导者画像研究报告》，在报告中详细拆解了科技领导者面临的时代和企业期望的变化，以及科技领导者自身的成长路径。</p><p></p><p>VUCA时代下，科技创新成为企业发展的核心动力</p><p>在复杂且不确定的VUCA时代中，科技的力量超出了传统的经济和商业的期待。越来越多的企业意识到科技赋能业务的重要性，需要科技创新提供更多解决方案，并带来新的希望和机遇。为了应对这种变化，数据驱动与敏捷迭代两方面的能力成为科技领导者应对时代挑战并推动企业发展的必备能力。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/3b/3b3c8c90d56162e69ce7a9b85513e490.png\" /></p><p></p><p>企业期待科技领导者同时具有技术能力与领导能力</p><p>科技领导者们的企业内在价值在不断提升，企业也越来越认可科技领导者所带来的技术价值。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d7/d7fa04c388fcd144afd090876632ba05.png\" /></p><p></p><p>出于这份认可，互联网行业科技领导者价值被逐渐推高并进入追捧期。在经历过市场追捧期后，非互联网行业的企业更加理性地评估CTO、CIO等职位的价值、设置与人选。企业不仅仅期望科技领导者的加入能够带来技术升级，也期望能够影响并带动生产、运营等其他团队。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/97/97b4ff91c44081197f5af0b49ff4b47c.png\" /></p><p></p><p>科技领导者不但要有相匹配的技术能力，还要具备相应的管理意识与业务认知，能够让企业的需求切实落地。</p><p>InfoQ研究中心发现，数字化程度越高的企业越是需要科技领导者具有技术战略高度视野、前沿技术理解力、技术赋能力、深度技术落地理解力。内部业务协同多样、外部服务团队多样、内部团队规模大的企业对科技领导者的团队领导能力要求越高。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e2/e2ddbcd1e1b25195f72cc1fafea638f6.png\" /></p><p></p><p>双重变化下，科技领导者画像升级</p><p>通过对时代背景和企业期望的分析，InfoQ研究中心将科技领导者人群画像升级为四大能力要求。</p><p>一是数据驱动。他们需要具备业务决策能力和实践领导力，应用数据的采集和业务流程分析，通过合适的技术、演进方案、人员成本来解决企业的问题。</p><p>二是敏捷迭代。这对科技领导者在团队内部的领导力提出了更高的要求。科技领导者需要向团队澄清目标并辅助团队成长。在团队软性文化打造上发力，为团队带来心理安全感与工作责任感，并且通过精准的个体辅导增强团队凝聚力。</p><p>三是边际融合。在各部门之间，科技领导者需要以更扎实的业务成长方法论与业务领导力，聚焦业务需求、帮助业务创新、辅助业务部门决策并协调团队之间的合作。</p><p>四是协同共生。这意味着科技领导者需要具备协作领导力。通过与内部、外部合作伙伴，如供应商、客户、合作伙伴等，建立良好的合作关系并让合作伙伴清晰地理解正在进行的工作，指导企业制定相应的技术战略和业务发展计划。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/a3/a3906168210f0ce9a3f21f7149a54aa3.png\" /></p><p></p><p>在快速变化的局势和企业的多维度期待下，科技领导者必须让业务领导力、团队领导力、个人领导力得到均衡地成长，并同时沿着技术成长、业务成长、管理成长的路径进行发展，聚焦于通用能力。不断增长的视野与能力的提升将成为他们应对时代湍流的强大武器，助力他们引领企业迈向更加光明的未来。</p><p></p><p>中国科技领导者画像正在经历着非常微妙的变化，想要了解更多中国科技领导者的人群画像、成长路径等内容，欢迎点击链接或扫描二维码添加小助手下载完整报告：<a href=\"https://www.infoq.cn/article/3amBoEYUc5mjsEP3VAVG\">https://www.infoq.cn/article/3amBoEYUc5mjsEP3VAVG</a>\"</p><p><img src=\"https://static001.geekbang.org/infoq/70/70d97552604ebf82671669e143cb27e1.png\" /></p><p></p>",
    "publish_time": "2023-07-28 10:47:41",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "阿里巴巴前副总裁胡臣杰加入开源中国，推动中国开源文化蓬勃发展",
    "url": "https://www.infoq.cn/article/R6PDcN25QOuVEFYhVmFR",
    "summary": "<p>中国知名开源技术社区开源中国日前宣布，前阿里巴巴副总裁胡臣杰加入该公司，担任首席战略官一职。胡臣杰作为“国千”专家，拥有丰富的数字化工作经验和广泛的行业影响力，将在开源中国的发展战略规划及进一步推动开源文化的发展方面发挥重要作用。</p><p></p><p>在过去的职业经历中，胡臣杰曾担任阿里巴巴集团副总裁、南方航空公司首席信息官等职务。在阿里巴巴任职期间，他先后负责阿里云新零售行业线、阿里云企业战略合作事务和飞猪大交通业务等重要领域，并创办了阿里CIO学院，致力于推动开源文化在大中型企业的普及与应用。</p><p></p><p>胡臣杰在南方航空公司担任首席信息官时，深刻认识到开源技术在企业信息化建设中的巨大潜力。他坚定地采用开源软件，不仅降低了成本，还提升了团队能力，为公司节省了数千万的IT投资。此外，他曾推动实施了中国第一张电子客票、电子登机牌和电子货单等创新项目，引领了中国民航行业的数字化创新。</p><p></p><p>他表示，开源技术对于整体团队能力的提升有巨大的好处，开放的源代码让年轻人有机会深入学习和钻研。例如，南方航空曾经有一名工程师通过深入研究开源软件负载均衡方案，成功替代了昂贵的商业设备，既节约了投资，又增强了团队的技术实力。</p><p></p><p>加入开源中国后，胡臣杰将致力于推广开源技术在大中型企业和政府机构的应用，并负责开源中国与资本市场的资源对接与整合工作。同时，他还希望推动开源文化在各个领域的普及，促进开源技术与数字化转型的有机结合。</p><p></p><p>开源中国作为中国具影响力的开源软件社区平台，近日宣布完成B+轮战略融资。该社区于2008年创立，收录全球知名开源项目近10万款，并于2022年发布中国开源社区Landscape，收录200+开源社区；同时还收购了日本老牌开源社区OSDN。</p><p></p><p>开源中国旗下的代码托管平台Gitee是国内领先的代码托管服务平台，服务1000万开发者用户、26万家企业，以及2000多家高等院校。</p><p></p><p>通过胡臣杰的加入，开源中国期待进一步推动开源文化的传播与应用，为中国企业的数字化转型提供更多支持与引领。</p>",
    "publish_time": "2023-07-28 11:01:07",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "比Bing更早将LLM集成到搜索引擎中，这家由谷歌前高管创立的公司为什么还是失败了？",
    "url": "https://www.infoq.cn/article/IQrajVXjyLTw1QjFxHV5",
    "summary": "<p></p><blockquote>Neeva 更快、更简单且无广告。但做出比谷歌更好的东西，却并不足以击败谷歌。</blockquote><p></p><p>&nbsp;</p><p>在出走谷歌，创立 Neeva 以前，Sridhar Ramaswamy 曾在谷歌工作过 15 年，担任广告业务高级副总裁一职；Vivek Raghunathan 曾担任 YouTube 货币化副总裁。Ramaswamy 认为，过度依赖广告会损害搜索结果的质量，于是在 2019 年，Ramaswamy 和 Raghunathan 联合创立了搜索引擎&nbsp;Neeva。Neeva 的使命是让搜索服务回归用户，旨在通过提供优先考虑用户隐私并提供无广告体验的替代方案来颠覆搜索引擎市场。</p><p>&nbsp;</p><p>Neeva 从头开始构建了一个搜索堆栈，并组建了一个 50 人的小团队。Neeva 曾在短期内迅速吸引了大量用户，在推出后四个月内月活跃用户增长到 50 万。到 2022 年初，Neeva 已经将大语言模型集成到其搜索堆栈中，成为第一个为大多数查询提供引用的实时人工智能答案的搜索引擎。有人曾将 Neeva 看作是谷歌最强有力的竞争者。Neeva 在某些方面的确远远领先于谷歌，比如将 10 个蓝色链接替换为更直观的页面，并强调人工创建的信息。</p><p>&nbsp;</p><p>但构建搜索引擎实际上是最容易的部分。Ramaswamy 和 Raghunathan 在宣布 Neeva 关闭的博客文章中写道：“在整个旅程中，我们发现构建搜索引擎是一回事，说服普通用转向更好的选择则完全是另一回事”。Ramaswamy 和 Raghunathan 称，他们在吸引新用户方面面临着重大挑战，再加上所有公司目前面临的困难经济环境，意味着继续目前的路线已不再可行。 他们写道：“在消费者搜索领域创建可持续业务已不再可行。” “因此，在接下来的几周内，我们将关闭 neeva.com 和我们的消费者搜索产品，并转移到新的重点领域。”</p><p>&nbsp;</p><p>仅仅四年，Neeva 就停止运营了。2023 年 5 月，云数据库公司&nbsp;Snowflake 以约 1.5 亿美元收购了&nbsp;Neeva，未来将帮助服务企业客户利用 AI 去快速搜索和分析数据点、数据资产，获得数据洞察的能力。</p><p></p><h2>Neeva：构建自有搜索索引，首批集成AI功能</h2><p></p><p>&nbsp;</p><p>Neeva的计划来自一个简单的想法：谷歌的商业模式已经在拖累搜索引擎的进步。Ramaswamy认为，从长远来看，这种以广告为基础的模式必然导致搜索结果劣化。要想打造更好的搜索引擎，首先需要改变激励措施。这种改变意味着不再以展示广告为诉求，而是始终把用户体验放在第一位。这种新模式不需要让用户输入查询，也不需要帮广告商收集用户数据。其目标就是帮助人们找到自己想要的页面，并避开途中的一切障碍。</p><p>&nbsp;</p><p>David Pierce&nbsp;在一篇分析文章中指出：“从零开始构建搜索引擎既困难又昂贵，因此很多人对此根本不感兴趣。他们选择以10到25美元的价格购买 Bing 提供的 1000 条数据搜索许可，再以此为基础添加自己的功能和界面。”而 Neeva 对于彻底改革搜索技术有很多自己的想法，因此最终决定要控制底层数据。</p><p>&nbsp;</p><p>Raghunathan 表示，“我们想要加快搜索速度、充实预览内容、提供首选网站、开放个人搜索选项，但这一切都遇到了困难。”Bing API 提供的链接并不支持这些额外功能，所以Neeva的思路就成了空想。如果真想打造一套更好的搜索引擎，那Neeva就必须得亲自动手、从零起步。</p><p>&nbsp;</p><p>经过两年的构建、训练、完善、再训练和再完善，Neeva搜索引擎终于建立起完全自主的技术基础。构建自有搜索索引的一大优势就是，能给大语言模型收集到一组非常实用的训练数据。Neeva还是首批推出AI搜索助手（名为NeevaAI）的公司之一，它能总结搜索结果，有时甚至直接在页面顶端回答用户的问题。</p><p>&nbsp;</p><p>Neeva团队还建立起了带有更大图像和比较信息的购物页面，这里优先参考了Reddit和Quora等平台的结果。体育搜索也变成了漂亮的全屏记分牌。之所以这样做，就是希望大家在搜索“布拉德·皮特IMDb”或“WhatsApp Web版”时，Neeva的自动补全功能会直接将用户带入网站，压根不需要中间的结果页面。Neeva干净、简单，早期用户纷纷表示这种不骗人看广告的搜索引擎才是好引擎。</p><p>&nbsp;</p><p>但打造一款好产品和让用户喜欢上它完全是两码事。毕竟Neeva的使用体验太不同了，用户得放弃自己上网时最简单、也最根深蒂固的习惯，才能适应这种全新设计。</p><p>&nbsp;</p><p>科技行业一直有个原则，即人们不会愿意改变自己的使用习惯。Ramaswamy在采访中坦言，“我们面临的最大障碍之一，确实就是扭转用户的固有习惯。人们忘记了谷歌的成功不仅仅是开发出了更好的产品。为了实现目标，我们必须做出一系列精准的分发决策。”</p><p>&nbsp;</p><p>据报道，谷歌每年向苹果支付高达150亿美元，为的就是能在各类苹果设备的Safari浏览器中成为默认搜索引擎。谷歌同时也向Mozilla支付费用，借此成为Firefox浏览器中的首选搜索引擎。而这笔费用高达每年4.5亿美元。谷歌还跟其他设备制造商和浏览器开发商有合作，甚至跟电信运营商也有类似的交易。据《华尔街日报》报道，三星曾在2023年短暂考虑结束与谷歌的交易，但由于各种原因而最终放弃，其中包括“可能对与谷歌间的广泛业务关系产生影响”。</p><p>&nbsp;</p><p>谷歌的真正优势在于旗下的其它产品。Android是目前全球最受欢迎的移动操作系统，市场份额约占78%。Chrome则是最受欢迎的网络浏览器，市场占比约62%。在这两大平台上，谷歌自然也成为不可撼动的默认搜索引擎。</p><p></p><h2>做搜索引擎，既复杂，又简单</h2><p></p><p>&nbsp;</p><p>搜索引擎是种神奇的事物——既复杂无比，又简单纯粹。</p><p>&nbsp;</p><p>实际上，搜索引擎所做的就是编译网页数据库（即「搜索索引」），之后在每次收到查询时浏览该数据库，从中提取并交付质量最高、相关度最强的一组页面。但这过程中的每一步，都涉及着巨大的复杂性，需要做出一连串权衡。而权衡的核心有二：时间与金钱。</p><p>&nbsp;</p><p>即使创业者能建立一套不断更新的数据库，囊括互联网上的数千亿个页面，但光是它产生的存储和带宽成本就足以让地球上任何一家巨头企业破产。这还不包括每天对数据库执行无数次检索的成本。另外，搜索响应中的每一毫秒都非常重要——谷歌会在结果上方显示每次查询耗费的时间。总而言之，创业者恐怕没有足够的时间逐个查看整个数据库。</p><p>&nbsp;</p><p>此外，搜索引擎的构建还要从一个基本哲学问题开始：什么叫高质量网页？创业者必须决定哪些分歧是合理的，而哪些信息属于纯粹的胡说八道，必须搞清广告占比到多少才不会过度。那些由 AI 编写且充斥着 SEO 垃圾的网站当然不好，但个人认真撰写、且同样充斥 SEO 垃圾的美食博客则还不错。</p><p>&nbsp;</p><p>一旦完成了上述讨论并设定出明确的边界，那搜索引擎中就基本确定了需要保留的几千个域名。其中包括 CNN 和 Breitbart 等新闻网站，Reddit、Stack Overflow 和 Twitter 的热门讨论板，维基百科和 Craigslist 等工具服务，YouTube 和 Amazon 等服务平台，还有各类最顶级的食谱/体育/购物网络。有时候，创业者可以跟这些网站洽谈合作，以结构化方式直接获取数据，不再单独浏览各个页面。值得一提的是很多大平台都有专门的团队，有时甚至愿意免费配合。</p><p>&nbsp;</p><p>之后就该放出爬虫了。这些机器人能爬取给定网页上的内容，之后查找并跟踪页面上的各个链接、索引全部页面内容，就这样完成链接、索引的查找与跟踪循环。而每次爬虫访问一个页面时，都会根据之前设定的高质量网页标准对其做评估。被认定为高质量的内容将被下载至某台服务器上，于是搜索索引开始迅速膨胀。</p><p>&nbsp;</p><p>当然，爬虫也不是在哪里都受欢迎。爬虫每次打开网页，都会给内容提供商带来带宽成本。现在想象一下，一套搜索引擎每秒都会对网站上的各个页面进行加载和保存，这样的更新成本将很快超出提供商的承受能力。</p><p>&nbsp;</p><p>因此，大多数网站都设置一个名为 robots.txt 的文件，用于定义哪些爬虫可以访问其内容、哪些爬虫不行，以及允许爬虫爬取哪些 URL。从技术上讲，搜索引擎完全可以不理会 robots.txt 上的规则，但这是 Web 结构和文化中的一部分。几乎所有网站都愿意接纳谷歌和 Bing，因为它们带来的可发现性已经超过了带宽成本。也有很多人会阻止特定的服务商，例如不希望亚马逊爬取并分析他们的购物网站。其他人则制定一揽子规则：除了谷歌和 Bing 外，其余爬虫概不接待。</p><p>&nbsp;</p><p>很快，爬虫就会带回相当广泛的互联网快照。接下来的工作就是针对搜索引擎可能收到的每条查询，按顺序对全部页面做排名。大家可以按主题对页面做排序，这样就能划分成更小、更易于搜索的索引，而不是包罗万象的庞然大物。简单来讲，就是本地结果与本地结果匹配，购物与购物匹配，新闻与新闻匹配。我们需要使用大量机器学习技术来收集特定页面的主题和内容，同时也离不开人工协助。</p><p>&nbsp;</p><p>此外，还会引入评分团队，向他们展示查询和结果，并要求他们从0到10为结果的真实性打分。有时候问题很明显，如果有人搜索「Facebook」，但响应结果的第一条居然不是facebook.com，那肯定不能接受。但大多数情况下，我们会合并来自大量输入的评分，并将其馈送到索引和主题模型当中，之后不断重复这个过程。</p><p>&nbsp;</p><p>到这里，问题才刚刚解决了一半。我们还得提高所谓“查询理解”能力，也就是意识到搜索“巨石强森”和搜索“道恩·约翰逊”的人其实是想找同样的信息。最终，我们将积累起一个庞大的同义词和相似性库，并据此重写查询以降低搜索难度。而且如谷歌所说，每天他们的引擎中都有15%的全新搜索，所以这场理解人们真实需求和扩充新知识的赛跑将永远没有终点。</p><p>&nbsp;</p><p>一段时间之后，搜索引擎正式上线了，开始获得更多人的关注、点击和偏好。这里还有一项黄金标准：如果用户在点击链接后，不再立即搜索和点击其他链接，就代表当前结果的质量令人满意。而另一方面，用户们的点击量越大，就越能了解他们真正想要的是什么。</p><p>&nbsp;</p><p>此外，运行搜索引擎还需要不断在速度、成本和质量三者中取得平衡。比如，当有人输入“YouTube”并按下回车时，如果搜索整个数据库会耗费太长时间、造成不必要的带宽和存储成本；如果保留一个容纳整个互联网的数据库，不但存储成本高昂，搜索速度也会太过缓慢；如果设定只显示网络上最受欢迎的100个网站，就能保证速度和成本，但会存在内容不全面、质量不可靠的情况。同时，各个网站本身也在不断变化，搜索引擎的爬虫和排名系统也要持续跟进。</p><p>&nbsp;</p><p>参考链接：</p><p><a href=\"https://www.theverge.com/23802382/search-engine-google-neeva-android\">https://www.theverge.com/23802382/search-engine-</a>\"<a href=\"https://www.theverge.com/23802382/search-engine-google-neeva-android\">google</a>\"<a href=\"https://www.theverge.com/23802382/search-engine-google-neeva-android\">-neeva-android</a>\"</p><p><a href=\"https://www.snowflake.com/blog/snowflake-acquires-neeva-to-accelerate-search-in-the-data-cloud-through-generative-ai/\">https://www.snowflake.com/blog/snowflake-acquires-neeva-to-accelerate-search-in-the-data-cloud-through-generative-ai/</a>\"</p><p><a href=\"https://techcrunch.com/2023/05/21/google-challenger-neeva-gives-up-on-consumer-search-goes-all-in-on-ai-and-the-enterprise/\">https://techcrunch.com/2023/05/21/</a>\"<a href=\"https://techcrunch.com/2023/05/21/google-challenger-neeva-gives-up-on-consumer-search-goes-all-in-on-ai-and-the-enterprise/\">google</a>\"<a href=\"https://techcrunch.com/2023/05/21/google-challenger-neeva-gives-up-on-consumer-search-goes-all-in-on-ai-and-the-enterprise/\">-challenger-neeva-gives-up-on-consumer-search-goes-all-in-on-ai-and-the-enterprise/</a>\"</p>",
    "publish_time": "2023-07-28 14:11:37",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "“Twitter如今就像疯人院！”睡地板仍被裁女高管爆料：马斯克带来“恐惧文化”，被裁是最大解脱",
    "url": "https://www.infoq.cn/article/2P0V9B0WIGhZFAM9PvPp",
    "summary": "<p>&nbsp;</p><p></p><blockquote>大家还记得马斯克刚掌管Twitter时，那名因睡在办公室地板上的睡袋里而走红的女高管Esther Crawford 吗？当大家都以为她获得马斯克信任时，她还是被解雇了。网友有人说Crawford“阿谀奉承”，也有人讽刺她，“在办公室睡觉还不够，这真是令人震惊”。&nbsp;对此。Crawford 也在推特中回应道，“看到我在 Twitter 2.0 上全力以赴，你可能会认为我的乐观或努力工作是一个错误。那些嘲笑和嘲笑的人一定是旁观者，而不是竞技场上的人。我为团队在如此多的噪音和混乱中进行建设感到非常自豪。”&nbsp;离职后，Crawford 在社交平台上写下了一篇“我在Twitter的一份工作总结”的文章，这也让我们看到了之前的Twitter 内部管理的混乱和马斯克入主Twitter 后的随性和喜怒无常。我们翻译并整理了Crawford 的帖子，以飨读者。</blockquote><p></p><p>&nbsp;</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d3/d39cd3510ef14ea7a9d67d36c131d1e6.png\" /></p><p></p><p></p><h2>马斯克之前的Twitter：管理层都“躺平”了</h2><p></p><p>&nbsp;</p><p>跟用过Twitter的朋友们一样，我对这个经典厂牌被改成“X”也有不少看法。而当下，可能正是聊聊自己在这家公司这段工作经历的最好时机。</p><p>&nbsp;</p><p>其实我并不算是老员工，只是像大家一样热爱Twitter、使用Twitter。直到2020年我建立的初创公司被Twitter收购之后，我才开始以内部人士的角度审视一切。观察之下，我发现它既令人惊奇又有着种种诡异问题……当然，现实生活中的人和事又何尝不是如此呢。</p><p>&nbsp;</p><p>我是个内心深处喜欢给自己加压、充满紧迫感的人，而Twitter的工作氛围却孤独且官僚主义横行。出于自我意识的愚蠢权力斗争、重组和团队名称变更时常出现，粗暴打断员工们的正常安排。</p><p>&nbsp;</p><p>光是能劳动还不够，你还得懂政治。</p><p>&nbsp;</p><p>我对Twitter基础设施的陈旧和非标而感到震惊。但除了季度收益电话会议之外，几乎没有哪位高管愿意认真想想这件事，毕竟只要收益到位、还有什么不能接受的呢？员工们总感觉公司里的一切都是拿胶带缠起来的，只能算是勉强能运行。另外，大家需要一段时间才能适应一个小小的产品变更，也要拖上几个月、甚至几个季度才能完成的事实。</p><p>&nbsp;</p><p>为了适应职业发展，管理层变得愈发臃肿，企业文化也相当软弱、不太适合我自己的脾气。这里缺少良性辩论和批评，反而默认用“不好意思，做不到”和“那是其他团队的事情，别越界”来搪塞。</p><p>&nbsp;</p><p>团队可能会耗费几个月来构建一项功能，并在最后一刻再因风险太大而被毙掉。</p><p>&nbsp;</p><p>与客户的直接交流，很可能会演变成一场地盘争夺战，并在各职能部门间制造僵局。</p><p>&nbsp;</p><p>我还记得这么件事：有位同事花了一个月时间，想申请接触几位创作者。他先后接触了3位高管和6个不同的职能团队，最终有4名高管参与审批。这也太离谱了……而且遗憾的是，我亲眼看到很多极富才能的人在经历这样的流程之后，筋疲力尽、士气低落。</p><p>&nbsp;</p><p>大多数人都很擅长自己手头的工作，但在Twitter我们几乎不可能裁掉那帮人浮于事的家伙。他们只会被调到其他团队，因为经理们很少有意愿或者能力弄清要怎么把低效人士扫地出门。</p><p>&nbsp;</p><p>高绩效文化会让人们不断保持进步，而躺平文化则会让人们感到沮丧。Twitter就是这样一个地方，总让人感觉自己在浪费自己的潜力。在我任职期间，最擅长打破废话、激发愿景的人是Kayvon Beykpour，但因为他并不是CEO，所以并没有全面管理公司运营的权力。</p><p>&nbsp;</p><p>尽管存在这些实际问题，但我还是很幸运能参与到Twitter的产品、设计、工程、研究、法律、商务拓展、信任与安全、营销、公关等领域，跟最有才华的人们一起工作。通常，由具有内驱力的人们组成的小型跨职能团队往往能挑战某些关键假设，从而带来深远的业务影响。参与这些团队非常有趣，可这种感受却总是种例外、而非规则内的产物。</p><p>&nbsp;</p><p>等待2022年收购交易的那几个月尤其漫长且痛苦，感觉就像领导层集体消失了，躲在律师和法务身后。无论提出什么关于公司未来的问题，他们给出的答案都是“信托责任”那种陈词滥调。同事们开始公开讨论Twitter收购案，认为主要原因是领导层对自己规划和解决长期问题的能力缺乏信心。</p><p>&nbsp;</p><p></p><h2>马斯克带来了“恐惧文化”</h2><p></p><p>&nbsp;</p><p>虽然我对马斯克了解不多，但当时还是持谨慎乐观的态度——毕竟他建立了特斯拉和SpaceX等令人难以置信的卓越企业，还一直保持着稳定运营。也许他的介入能够改变现状，为公司注入新的活力。</p><p>&nbsp;</p><p>而之后的真实经历，用一个个具体事例给我好好上了一课。</p><p>&nbsp;</p><p>当人们问我为什么要留下时，我的答案很简单：乐观、好奇、个人成长，还有丰厚的报酬。</p><p>从一开始，我就意识到马斯克要推动的改革有些很聪明、也有些很愚蠢。但作为团队的一员，我总是秉持着“公开表扬、私下批评”的理念。我不是那种沉默寡言、埋头干活的类型，无论是在收购前还是收购后，我都不惮于公开分享自己的观点和反驳意见。</p><p>&nbsp;</p><p>而最终，我不得不接受这样一个事实：我在Twitter 2.0里找不到心理安全感，就是说我随时可能被解雇，而且连个严肃理由都没有。我已经一次次见证这样的情况，看到这对团队士气产生了怎样的负面影响。尽管我改变不了现状，但还是会尽最大努力激励那些负责重要工作的同事，也为正努力适应这种野蛮、硬核企业文化的人们提供一点情感支持。</p><p>&nbsp;</p><p>马斯克这人有一种奇特的魅力，而且他真的很有趣。他的性格里不乏各种怪癖，比如一遍遍重复同样的故事和笑话。但最大的问题是，他的情绪可能瞬间从兴奋变成愤怒，所以人们很难预判他的心情和对事情的反应。于是乎，大家越来越害怕参加会议、或者向他传达负面消息。</p><p>&nbsp;</p><p>有时候，我感觉核心团队对马斯克观点的支持有点过度积极、甚至到了狂热的地步。每当有人提醒我要小心发言时，我会礼貌地感谢他们，但也强调我就是这样的性格。我不想被笼罩在马斯克制造的恐惧文化下。他要么尊重我的特性，要么让我卷铺盖走人。无论是哪种结果，我都愿意坦然接受。</p><p>&nbsp;</p><p>我很快意识到，马斯克治下的产品和业务决策都是他直觉判断的结果，而且他似乎并不愿意寻找和依赖大量数据及专业知识来充实自己的决策过程。这对我来说真的很受打击，因为我坚信但凡能多搜集一点信息和知识，他的决策质量都能上一个台阶。相反，他会在Twitter上开展民意调查、询问朋友，甚至向他的传记作者寻求产品建议。有时候，他似乎比那些一辈子做研判的专家更相信随机反馈。我一直不明白他为什么会这样，甚至到现在也没理解。</p><p>&nbsp;</p><p>我觉得情况并不一定非得走到如今的地步，但我也不是说马斯克的到来就完全是坏事、或者应该想办法把他踢出局。他是个聪明人，有足够的钱去犯错误，并在过程当中纠正问题、找到方向。身为Twitter最大的股东，他可以在短期之内拉低公司价值，只要最终能扭转局面就行。</p><p>&nbsp;</p><p>他对速度的关注已经到了难以理解的地步，而且他明显并不害怕砸碎一个旧世界。但现在真正的问题，是他要怎么建设起一个新世界，特别是还有没有足够多的用户愿意接受他构想中的那个新世界。</p><p>&nbsp;</p><p>通过近距离马斯克，我学到了很多东西——有好的、有坏的，也有一言难尽的。他永远大胆、热情、懂得如何讲个令人振奋的故事，但同时他思维跳脱、缺乏同理心，这给Twitter员工造成了巨大的痛苦。</p><p>&nbsp;</p><p>马斯克在解决物理难题方面有着非凡的天赋，但要想打造出能促进人与人之间联系和沟通的产品，需要的则是完全不同的社交能力和情商。在这方面，他明显做得不够好。</p><p>&nbsp;</p><p>社交网络虽然很难彻底“咽气”，但仍会在一圈圈的螺旋下降中走向衰败。只有时间会告诉我们结果如何，而我衷心希望X能够站稳脚跟，毕竟良好的竞争对消费者最为有利。</p><p>&nbsp;</p><p></p><h2>“如今的Twitter简直像个疯人院”</h2><p></p><p>&nbsp;</p><p>与此同时，我对各位在幕后不知疲倦工作的员工、想要稳定平台销售产品的广告商，还有经历过混乱更新的客户们深表同情。我承认，如今的Twitter简直像个疯人院。</p><p>&nbsp;</p><p>Twitter曾经拥有迅猛的发展速度，但也饱受官僚主义之苦。而如今的X则由一位善变的领导者掌管，平台上最大的声音来自他的本能和直觉，这艘巨轮就在这样怪异的状态下继续向前行驶。</p><p>很多朋友听说我，可能是从所谓“睡袋事件”来的。当时我晚上不回家，就睡在会议室的地板上。那我就来聊聊这事好了。</p><p>&nbsp;</p><p>亲身经历这样一场病毒式的新闻传播是种有趣的经历。我被左翼人士攻击，被称为亿万富豪身边的马屁精；同时也被右翼人士攻击，因为我同时是名母亲，而他们把我妖魔化成了女性为了选择事业而放弃家庭的反面典型。</p><p>&nbsp;</p><p>值得庆幸的是，我自己没什么心理包袱，也不会对键盘侠们的说辞太过较真。毕竟要想让自己的言论在网上激起哪怕一小会热度，厚脸皮和强烈的自我意识都是必要的因素。</p><p>&nbsp;</p><p>真实故事其实非常简单。马斯克上任后，马上给我安排了一个几乎实现不了的项目期限。作为产品负责人，我永远不会要求员工做我自己做不到的事情。所以我跟一支跨多个时区的出色团队昼夜不停地赶进度，我们最终克服了困难、按时完成了交付。这段过程很辛苦，但也很有趣。</p><p>最初那几个月确实很疯狂，但这是我自己的选择，所以我从不后悔。</p><p>&nbsp;</p><p>其实大多数情况下，这种全力以赴的状态很难找到，甚至值得为之庆祝。但很明显，没人能永远以这样的速度赶工，只有在出现紧急任务时爆发一下。无论是职业生涯还是当初的学生时代，我都时不时会为重要的事情熬个夜。我并不后悔投入了这么多时间和精力，也为自己一路走来取得的进步和成果感到自豪。这是种职业道德，我愿意接受伴生而来的压力和辛劳。</p><p>&nbsp;</p><p>我觉得生活就像一场游戏，而Twitter易主之后我们瞬间进入了困难模式。当然，我喜欢接受艰难的挑战，因为这样既有趣又有益，是我们快速成长和学习的底层动力。</p><p>&nbsp;</p><p>我意识到，如今的社会正走向两极分化。但对于Twitter这款应用、它的所有者和未来前景时，我既不是忠诚的铁粉、也不是充满恨意的批评者——而是个乐观的务实者。</p><p>&nbsp;</p><p>但所谓“忠诚不绝对，就是绝对不忠诚”，我这样的态度在互联网上很不受待见，毕竟人们不能简单把我归结成支持或者反对派。可我觉得自己能够摆脱原教旨主义观念、自由看待事物，其实是件很幸福的事。任何一个人都可以被描述成英雄或者恶棍，具体要看是谁从哪个角度来讲这个故事。马斯克也一样，不能简单用认可和贬低来定义。他是个复杂的人，掌握着深不可测的金融和地缘政治力量，因此整个社会才需要他站在善良的一边，而绝不可滑向政治分歧与割裂那一边。</p><p>&nbsp;</p><p>我对他的很多决定也抱有异议，对他毫不留情毁掉那么多事物感到惊讶。但只要继续投入充足的资金和时间，更多创新事物可能也会在废墟中开花结果。</p><p>&nbsp;</p><p>至少我希望是这样。</p><p>&nbsp;</p><p></p><h2>被解雇是“最大的解脱”</h2><p></p><p>&nbsp;</p><p>有时候，人们会问我被解雇后感觉如何，其实这对我来说是这辈子最大的解脱。虽然网上怎么评价这件事的声音都有，但我可是身经百战了，并不会受什么影响。我知道我自己是怎么工作的、为什么要这么拼命，所以不会轻易被舆论所动摇。我管理的产品团队被解散也很正常，毕竟几乎所有其他项目经理都被辞退了，我又有什么特殊的呢？</p><p>&nbsp;</p><p>之后，我去好好休了个假，终于找回了休息和放松的感觉。我是个富有创造力的人，也是个勤勤恳恳的构建者，所以我尽早会回到一家高强度工作的企业。但我很感激这段能尽情思考、阅读、旅行和陪伴爱人的闲暇时光。</p><p>&nbsp;</p><p>在认真反思之后，我比以往任何时候都更加坚信，最好的结果必然来自能将头脑与心灵完美结合的伟大领导力。</p><p>&nbsp;</p><p>而且我还总结出一个对任何成功者都适用的警示故事，也是我自己没有做好的地方——我们所在的位置越高，自己的世界就会变得越小。这是个奇怪的导论，但最富有、最具权势的人，往往也是最隔绝于世界的人。</p><p>&nbsp;</p><p>我之前经常观察马斯克，他看起来非常孤独，因为他把全部时间和精力都投入到了工作上。这绝不是我想要的生活模式。</p><p>&nbsp;</p><p>金钱和名誉会造起一座心灵监狱，导致心理健康严重恶化。大家肯定都听过类似的名人轶事，他们最终都独享抑郁、偏执、自大、妄想、狂躁和行为古怪的泥潭。</p><p>&nbsp;</p><p>生活在这样一间“回声室”里相当危险，因为身处高位的人们往往会被唯唯诺诺者所包围。这帮家伙需要以此谋生，从你的成功当中分一杯羹。所以一定要分得清谁是家人、谁是朋友、谁是战友，留住我们身边的这一丝美好。只有这样，我们才能始终保持正轨，并经受得起风浪与颠沛的洗礼。每个人有时都需要直面残酷的现实，如果解雇掉所有敢于发声的人，那么现实就可能被扭曲成一个诡异变形的漩涡。</p><p>&nbsp;</p><p>我之所以关注Twitter，就是因为我痴迷于这种孤独感和在人与人间建立联系的问题。让人倍感不安的是，尽管我们建立起了一个更安全、更富裕的世界，但人类却变得越来越孤独。我不觉得这是什么必然的取舍，所以我才会在个人经历和职业生涯中一次次挑战这样的现实。</p><p>&nbsp;</p><p>总而言之，Twitter是互联网上一个奇异且特别的地方。我很庆幸自己能在它的发展历程中，扮演一个微小的角色、做出一点微小的贡献。</p><p>&nbsp;</p><p>无论接下来会发生什么，我都会继续坚持使用Twitter。这里的社交活动仍旧活跃，我也会继续关注、参与和分享热门话题。因为我不想，也绝不可能自绝于这片网络天地。</p><p>&nbsp;</p><p>也许X会取得巨大成功，但也不排除它最终会彻底失败。</p><p>&nbsp;</p><p>总之，这应该会是一段有趣的旅程，我也将对未来拭目以待。</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://esthercrawford.medium.com/an-epilogue-to-my-time-working-at-twitter-24a126098246\">https://esthercrawford.medium.com/an-epilogue-to-my-time-working-at-twitter-24a126098246</a>\"</p><p>&nbsp;</p>",
    "publish_time": "2023-07-28 14:44:20",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]