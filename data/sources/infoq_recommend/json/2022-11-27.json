[
  {
    "title": "PHP 8——注解、match表达式及其他改进",
    "url": "https://www.infoq.cn/article/XkzLrAYhV1CWPDzu72N2",
    "summary": "<p>PHP 8是<a href=\"https://www.infoq.cn/article/Q5vwc4WSOj27bawTd2S4\">PHP</a>\"的一次重大更新，它引入了一些新特性和性能优化，包括注解（attributes）、 match 表达式、 instanceof 运算符、 new 运算符、全新的JIT编译器等等。</p><p></p><p>注解（attributes）提供了一种向类、方法、函数、参数、属性和类常量中添加元数据的方法。Attributes注解类似于其他一些语言所支持的annotations注解。new 运算符仅从PHP 8.1开始可用，可用于默认参数值、静态变量的初始化设置和属性参数。 match 表达式是一种新的控制结构，它使用身份运算符（identity operator）对带有多分支条件表达式的主题表达式进行匹配，并执行匹配的分支。 instanceof 运算符以前只能用于类对象，现在也可以用于任意表达式了。 JIT（Just-In-Time）编译器带来了性能和可用性提升。</p><p></p><p>其中一些示例所基于的数据结构需要<a href=\"https://pecl.php.net/package/ds\">从此处</a>\"下载并安装 php_ds 扩展。在Windows上，需要<a href=\"https://pecl.php.net/package/ds/1.4.0/windows\">从此处</a>\"下载8.1非线程安全（Non-Thread-Safe，NTS）x64的DLL，并将php_ds-1.4.0-8.1-NTS-vs16-x64.zip文件解压缩到某个目录下。解压后，将目录中的php_ds.dll复制到PHP 8.x安装根目录中的 .\\ext 目录中，例如 C:\\PHP-8.1.9-nts-Win32-vs16-x64\\ext 。并在php.ini配置文件中添加如下行：</p><p></p><p>extension=php_ds</p><p></p><p>如果PHP内置服务器已经在运行了，那么请重新启动它。</p><p></p><h2>注解（Attributes）</h2><p></p><p>注解（Attributes）是配置指令，用于使用结构化的和机器可读的元数据注释或修饰类、方法、函数、参数、属性和类常量。“结构化”意味着可以读取和解析元数据的信息，这使得注解不同于非结构化的文档注释，后者只是普通字符串。注解可用于提供仅在某些时候相关的配置和其他信息，因此它可以是嵌入式的，而不是硬编码到PHP脚本中。以下是使用注解的典型顺序：</p><p></p><p>声明注解类。注解类是一个常规的PHP类，其前面是一行单独使用的 #[Attribute] 。该类可以选择性地声明一个构造函数。注解由其类标识；当使用该注解时，类名就是注解名。在类、方法、函数、参数、属性和类常量声明上应用或使用该注解。例如，如果注解类名为 Validate ，则该注解用作 #[Validate] 。同一注解可以在不同的声明中多次使用。并且多个注解也可以应用于同一个声明。如果需要，可以在运行时中使用<a href=\"https://www.php.net/manual/en/book.reflection.php\">反射API</a>\"获取或读取注解。注解有多种用途，例如：</p><p></p><p>提供接口的替代方案，好处是实现接口的类需要实现接口中的所有方法，而注解可以仅在需要时使用，从而避免不必要的方法实现。更改编译、诊断、代码生成和运行时行为。分离PHP引擎和扩展。PHP核心和扩展可以在某些声明上具有某些注解。在声明中嵌入特定的配置信息。例如，方法上的注解可以指示该方法监听哪些事件。从文档块迁移到注解中。默认情况下，可以在任何或所有受支持的声明类型上使用注解。但是，注解的​​使用可能仅限于使用选定的位掩码标志 Attribute::TARGET_CLASS 、 Attribute::TARGET_FUNCTION 、 Attribute::TARGET_METHOD 、 Attribute::TARGET_PROPERTY 、 Attribute::TARGET_CLASS_CONSTANT 、 Attribute::TARGET_PARAMETER 、 Attribute::TARGET_ALL  的一种或多种类型的声明上。 Attribute::TARGET_ALL  标志是默认值。使用位掩码标志 Attribute::IS_REPEATABLE ，可以在单个声明中多次使用同一注解。</p><p></p><p>接下来，我们将通过一个示例来探讨注解的使用。假设你想使用一个或多个排序函数对数组进行排序，例如 sort() 用于升序排序， rsort() 用于降序排序， shuffle() 用于随机排序。你可能还需要验证一下输入的数组，以验证它不是空数组，或者它至少有两个元素以使排序相关。排序类型信息和验证信息可以以注解的形式提供。</p><p></p><p>首先，声明用于验证的注解类。</p><p></p><p><code lang=\"php\">#[Attribute]\nclass Validate {}\n</code></p><p></p><p>然后，为排序类型声明另一个注解类。位掩码标志 Attribute::TARGET_CLASS 和 Attribute::IS_REPEATABLE 表示该注解仅用于类声明，并且该注解是可重复的。</p><p></p><p><code lang=\"php\">#[Attribute(Attribute::TARGET_CLASS|Attribute::IS_REPEATABLE)]\nclass SortType {\nfunction __construct($sortType){\n        $this-&gt;sortType = $sortType;\n    }\n}\n</code></p><p></p><p>现在声明带有 sortArray() 方法的接口。</p><p></p><p><code lang=\"php\">interface Sort \n{   \n    public function sortArray();\n}\n</code></p><p></p><p>最后，声明Sort接口的实现类。</p><p></p><p><code lang=\"php\">class SortImpl implements Sort\n{\n…}\n</code></p><p></p><p>在类中，声明两个类属性，一个用于排序类型，另一个用于要排序的数组。</p><p></p><p><code lang=\"php\">public string $sortType=\"\";\npublic $arrayToSort=array(\"B\", \"A\", \"f\", \"C\");\n</code></p><p></p><p>声明一个方法来验证要排序的数组不是空数组。用 #[Validate] 注解来注解该方法。将注解应用于方法，可以使用反射API来发现该方法。</p><p></p><p><code lang=\"php\">#[Validate]\n    public function arrayEmpty()\n    {\n        if (count($this-&gt;arrayToSort) === 0) {\n            throw new RuntimeException(\"Array is empty; please provide a non-empty array\");\n        }\n    }\n</code></p><p></p><p>声明第二个方法来验证数组是否至少有两个元素，并对其应用 #[Validate] 注解。</p><p></p><p><code lang=\"php\">#[Validate]\n    public function arraySize()\n    {\n        if (sizeof($this-&gt;arrayToSort) &lt; 2) {\n            throw new RuntimeException(\"Please provide an array of size 2 or more\");\n        }\n    }\n</code></p><p></p><p>实现 sortArray 函数。根据 SortType 的值，进行升序/降序/随机排序。</p><p></p><p><code lang=\"php\">public function sortArray()\n    { \n        \n         if ($this-&gt;sortType == \"asc\") {\n            …\n        } elseif ($this-&gt;sortType == \"desc\") {\n            …\n        } else {\n              \n             …\n    }\n</code></p><p></p><p>添加一个名为 performSort(Sort $sort) 的函数来执行排序。在该函数中，在执行排序之前会先应用验证。</p><p></p><p>声明一个类并对其应用 #[SortType] 注解。由于该注解是可重复的，因此多次应用该注解以执行不同类型的排序。</p><p></p><p><code lang=\"php\">#[SortType(sortType: \"desc\")] \n#[SortType(sortType: \"shuffle\")]  \n#[SortType(sortType: \"asc\")]              \nclass QSort\n{\n}\n</code></p><p></p><p>最后，创建一个 SortImpl 类的实例。</p><p></p><p><code lang=\"php\">$sort = new SortImpl();\n</code></p><p></p><p>使用反射API获取类注解。</p><p></p><p><code lang=\"php\">$ref    =   new ReflectionClass(QSort::class);\n$attrs  =   $ref-&gt;getAttributes();  \n</code></p><p></p><p>遍历注解数组，并调用 performSort() 函数，对每种排序类型执行排序，并输出排序结果。</p><p></p><p><code lang=\"php\">foreach ($attrs as $attr) {\n…\n}\n</code></p><p></p><p><a href=\"https://github.com/Deepak-Vohra/infoq-php8/blob/main/sort.php\">GitHub</a>\"上提供了演示注解使用的完整 sort.php 脚本。将 sort.php 脚本复制到 scripts 文件夹，并在<a href=\"http://localhost:8000/scripts/sort.php\">http://localhost:8000</a>\"上运行并监听PHP内置服务器，使用url &nbsp;<a href=\"http://localhost:8000/scripts/sort.php\">http://localhost:8000/scripts/sort.php</a>\"在浏览器中调用 sort.php 脚本。使用不同排序类型的排序结果将显示在浏览器中，如图1所示。</p><p></p><p>图 1 使用注解排序的结果</p><p></p><p>因为shuffle排序是一种随机排序，所以每次运行脚本时，shuffle的结果可能不同，如图2所示。</p><p></p><p>图 2  Shuffle排序产生不同的结果</p><p></p><p>因为要排序的示例数组有4个元素，所以没有一个验证失败。如果示例数组为空，作为对比，使用相同脚本，仅更改示例数组，将会生成运行时异常消息： Uncaught RuntimeException: Array is empty; please provide a non-empty array 。类似地，如果示例数组只有1个元素，也会生成运行时异常，并显示消息： Uncaught RuntimeException: Please provide an array of size 2 or more 。</p><p></p><h2>增强的 new 运算符</h2><p></p><p>new 运算符用于创建类的实例。从PHP 8.1开始，new 运算符可以用于具有如下语法的任意表达式中，其中表达式必须用圆括号括起来。</p><p></p><p><code lang=\"php\">new (expression)(...$args)\n</code></p><p></p><p>new 运算符可用于参数默认值的初始化设置、静态变量的初始化设置、全局常量的初始化设置和注解参数，接下来将通过示例进行探讨。</p><p></p><h3>在函数的参数默认值中使用 new 运算符</h3><p></p><p>为了演示在函数的参数默认值中使用 new 运算符，我们将使用数组排序示例的变体。考虑一个名为 SortArray 的类，它声明了一个方法 sortArray($arrayToSort) 来按升序对数组进行排序。</p><p></p><p><code lang=\"php\">class SortArray {\n    public function sortArray($arrayToSort) {\n…\n}\n}\n</code></p><p></p><p>第二个类，名为 ReverseSortArray ，它声明了一个按降序排列数组的方法。</p><p></p><p><code lang=\"php\">class ReverseSortArray {\n    public function sortArray($arrayToSort) {\n…\n}\n}\n</code></p><p></p><p>现在声明一个可接受任意数组的函数以及一个数组排序器来对数组进行排序。可以使用 new 运算符来定义默认的数组排序器，以创建 SortArray 的实例。</p><p></p><p><code lang=\"php\">function sortAnyArray($arrayToSort, $arraySorter = new SortArray)\n{\n    return $arraySorter-&gt;sortArray($arrayToSort);\n}\n</code></p><p></p><p>完整的脚本可以在&nbsp;<a href=\"https://github.com/Deepak-Vohra/infoq-php8/blob/main/sample.php\">GitHub</a>\"上找到。使用url <a href=\"http://localhost:8000/scripts/sample.php\">http://localhost:8000/scripts/sample.php</a>\"在内置服务器上运行示例脚本。</p><p></p><p>输出如下所示：</p><p></p><p><code lang=\"php\">arrayToSort[0] = A arrayToSort[1] = B arrayToSort[2] = C arrayToSort[3] = f\narrayToSort[0] = f arrayToSort[1] = C arrayToSort[2] = B arrayToSort[3] = A\n</code></p><p></p><h3>在变量和常量初始化中使用 new 运算符</h3><p></p><p>new 运算符可用于静态变量的初始化设置和全局常量的初始化设置。但是，在静态和非静态类属性的初始化设置中，以及在类常量的初始化设置中，都不支持 new 运算符。下面的脚本演示了哪些变量和常量的初始化设置是受支持的，哪些是不受支持的。</p><p></p><p><code lang=\"php\"><!--?php\nclass A{ }\nclass B{\n//static $a = new A; //在此上下文中不支持new表达式\n//public $a = new A; //在此上下文中不支持new表达式\n//const C = new A; //在此上下文中不支持new表达式\n}\nstatic $a = new A;\n \nconst C = new A;\n</code--></code></p><p></p><h3><code lang=\"php\">在注解参数中使用 new 运算符</code></h3><p></p><p><code lang=\"php\">正如你所料， new 运算符也可以用于注解参数。我们将使用与演示注解功能相同的示例，但有一点不同。请记住，我们使用 #[SortType] 注解来注解 QSort 类，并将注解参数作为字符串传递给它。</code></p><p></p><p><code lang=\"php\"><code lang=\"php\">#[SortType(sortType: \"desc\")] \n#[SortType(sortType: \"shuffle\")]  \n#[SortType(sortType: \"asc\")]              \nclass QSort\n{\n}\n</code></code></p><p></p><p><code lang=\"php\">针对这种情况，声明一个名为 Str 的类，它接受一个字符串型的参数作为构造函数的参数。</code></p><p></p><p><code lang=\"php\"><code lang=\"php\">class Str{\n    function __construct($str){\n        $this-&gt;value = $str;\n    }\n    function __toString(){\n        return $this-&gt;value;\n    }\n     \n}\n</code></code></p><p></p><p><code lang=\"php\">在注解参数中使用 new 运算符，脚本如下所示。</code></p><p></p><p><code lang=\"php\"><code lang=\"php\">#[SortType(sortType: new Str(\"desc\"))] \n#[SortType(sortType: new Str(\"shuffle\"))]  \n#[SortType(sortType: new Str(\"asc\"))]              \nclass QSort\n{\n}\n</code></code></p><p></p><p><code lang=\"php\">在内置服务器中运行脚本，输出与之前相同，如图3所示。</code></p><p></p><p><code lang=\"php\">图 3 在注解参数中使用new的结果</code></p><p></p><h3><code lang=\"php\">在某些上下文中不允许使用 new 运算符</code></h3><p></p><p><code lang=\"php\">前面我们提到了一些不支持 new 运算符的上下文，即静态和非静态类属性的初始化设置，以及类常量的初始化设置。 此外，在以下的上下文中也不支持 new 运算符：</code></p><p></p><p><code lang=\"php\">非字符串动态类名常量表达式中的参数解包（Argument unpacking）常量表达式中的匿名类不受支持的常量表达式下面脚本中所注释掉的语句如果运行都会生成错误：</code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><!--?php\n $list = [4, 6];\nfunction fn1(\n    $a1 = new ('some_dynamic_class')(),\n   //  $a2 = new (some_dynamic_class)(), // 非字符串动态类名 -  不能在常量表达式中使用动态类名\n   //  $b = new  class {}, // 不能在常量表达式中使用匿名类\n   // $c = new C(...$list), // 不支持在常量表达式中解包参数\n   //   $d = new D($x), // 常量表达式包含无效操作\n) {}\n</code--></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\">新的 match 表达式</code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\">PHP 8引入了一个新的 match 表达式作为控制流结构，它使用身份比较（identity comparison）将给定的主题表达式与一个或多个可选分支相匹配，并返回匹配分支的结果值。match 表达式类似于 switch 语句，但区别如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">match 表达式使用身份运算符（ === ）进行比较，而switch 则使用相等运算符（ == ）。match 表达式返回一个值，而switch 不返回。返回值可以赋值给某个变量。在匹配其中某个分支后，match 表达式会自动终止match 。switch 的终止则需要使用 break; 声明。match 表达式不会像switch那样在没有声明break;  的情况下失败。match 表达式支持在同一个分支中用逗号 （，）分隔多个条件，而switch 不支持。match 表达式必须是穷尽的，这意味着它必须要处理主题表达式的所有值。接下来，我们通过一些示例来演示 match 表达式的使用。</code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\">输出返回值</code></code></h3><p></p><p><code lang=\"php\"><code lang=\"php\">先从一个简单的示例开始，下面脚本中的match 表达式将作为主题表达式的整数 1 与包含默认模式的多个条件表达式进行匹配。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\necho match (1) {\n    0 =--> 'A',\n    1 =&gt; 'B',\n    2 =&gt; 'C',\n    default =&gt; 'Default',\n};\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">在内置引擎中运行脚本，通过使用url <a href=\"http://localhost:8000/scripts/match.php.\">http://localhost:8000/scripts/match.php</a>\"在浏览器中调用脚本，输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">B</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">在下面的脚本中，主题表达式与任何非默认条件表达式都不匹配。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\necho match (3) {\n    0 =--> 'A',\n    1 =&gt; 'B',\n    2 =&gt; 'C',\n    default =&gt; 'Default',\n};\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">Default</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">default 条件不能与脚本中所示的其他条件组合：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\necho match (3) {\n    0 =--> 'A',\n    1 =&gt; 'B',\n    2, default =&gt; 'C',\n     \n};\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">当脚本运行时，它会生成如下错误：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">Parse error: syntax error, unexpected token \"default\", expecting \"=&gt;\"\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">一个相对复杂的示例，下面的脚本有一个通过 \\Ds\\Vector 类初始化的变量。主题表达式以数组表示法访问 vector 变量。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$vector = new \\Ds\\Vector();\n$vector--->push('a');\n$vector-&gt;push('b', 'c');\n$vector[] = 'd';\n \necho match ($vector[1]) {\n  'a' =&gt; \"a\",\n  'b' =&gt; \"b\",\n};\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">使用url <a href=\"http://localhost:8000/scripts/match.php\">http://localhost:8000/scripts/match.php</a>\" 在浏览器中调用脚本。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">结果是：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">b</code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\">将返回值赋给变量</code></code></h3><p></p><p><code lang=\"php\"><code lang=\"php\">返回值也可以赋值给某个变量，匹配条件可以是任意表达式。在下面的脚本中， match 表达式将布尔值 true 作为主题表达式与调用其他内置字符串函数的条件表达式进行匹配。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$text = 'A B C D';\n$result = match (true) {\n    str_word_count($text)==3 || str_word_count($text)==2 =--> '2 or 3',\n    str_word_count($text)==4 || str_word_count($text)==5 =&gt; '4 or 5',\n    \n};\nvar_dump($result);\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出是：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">string(6) \"4 or 5\"\n</code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\">没有强制类型转换</code></code></h3><p></p><p><code lang=\"php\"><code lang=\"php\">与 switch 语句进行松散比较不同， match 表达式进行严格比较，并且不进行类型强制转换。首先，看一个与 switch 语句进行松散比较的示例。下面的脚本会匹配第一个条件并输出值 a 。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$var = 0;\nswitch((string)$var) \n{\n    case  0  : echo 'a'; break; // 这将测试NULL或空字符串   \n    default : echo 'b'; break; // 其他的，包括零\n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">相比之下，下面脚本中的match 进行了严格比较，并匹配默认条件输出 Default 。</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$var = 0;\n \necho match ((string)$var) {\n    0 =--> 'a',\n    default =&gt; 'Default',\n};\n</code></code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\">即使是 NULL 值也可使用身份比较进行匹配</code></code></h3><p></p><p><code lang=\"php\"><code lang=\"php\">match 表达式使用身份运算符（ === ）进行身份比较，这意味着即使是 NULL 值也会匹配。由于 Ds\\Vector::push() 方法返回 NULL ，所以，下面的脚本中的match 表达式实际上与Ds\\Vector::push() 方法所返回的NULL 值相匹配。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$vector = new \\Ds\\Vector();\n$vector--->push('a'); \n \nmatch ($vector-&gt;push('b')) {\n  $vector-&gt;push('d') =&gt; $vector-&gt;push('b'),\n  $vector-&gt;pop() =&gt; $vector-&gt;pop(),\n};\nprint_r($vector);\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">匹配的是第一个条件，输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">Ds\\Vector Object ( [0] =&gt; a [1] =&gt; b [2] =&gt; d [3] =&gt; b )\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">身份比较（ === ）可以应用于任意值，即使没有返回值也是如此。  match 返回的  NULL 值可以赋值给某个变量。 下面的脚本匹配 NULL 值，并且匹配的是第一个条件。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$vector = new \\Ds\\Vector();\n$vector--->push('a'); \n \n$vector = match ($vector-&gt;push('b')) {\n  $vector-&gt;push('c') =&gt; $vector-&gt;push('b'),\n  $vector-&gt;pop() =&gt; $vector-&gt;pop(),\n};\nvar_dump($vector);\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">使用url <a href=\"http://localhost:8000/scripts/sample.php\">http://localhost:8000/scripts/sample.php</a>\" 调用脚本，输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">NULL</code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\">可以用逗号分隔多个条件</code></code></h3><p></p><p><code lang=\"php\"><code lang=\"php\">多个条件表达式可以用逗号分隔。首先看一个具有单个条件的示例，脚本如下所示。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$vector = new \\Ds\\Vector();\n$vector--->push('a'); \n \nmatch ('push') {\n  'push' =&gt; $vector-&gt;push('b'),\n  'pop' =&gt; $vector-&gt;pop(),\n};\nprint_r($vector);\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出是：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">Ds\\Vector Object ( [0] =&gt; a [1] =&gt; b )\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">以相同的示例为例，添加多个用逗号分隔的条件。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$vector = new \\Ds\\Vector();\n$vector--->push('a'); \n \nmatch ('puush') {\n  'push','puush' =&gt; $vector-&gt;push('b') \n   \n};\nprint_r($vector);\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">第一个条件表达式列表中所列出的第二个可选选项将与拼写错误的“puush”相匹配，输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">Ds\\Vector Object ( [0] =&gt; a [1] =&gt; b )\n</code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\">穷举</code></code></h3><p></p><p><code lang=\"php\"><code lang=\"php\">match 表达式必须是可穷举的。在下面的脚本中，主题表达式与任何条件都不匹配。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\n$vector = new \\Ds\\Vector();\n$vector--->push('a'); \n \nmatch ('set') {\n  'push' =&gt; $vector-&gt;push('b'),\n  'pop' =&gt; $vector-&gt;pop(),\n};\nprint_r($vector);\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">结果是输出一个错误：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">Uncaught UnhandledMatchError: Unhandled match case 'set'\n</code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\">instanceof 运算符支持任意表达式</code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\">另一个新特性是 instanceof 运算符可接受任意表达式。仅有的两个要求是：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">表达式必须用圆括号括起来，并且表达式的计算结果必须为字符串。为了演示示新的instanceof 运算符，请创建一个PHP脚本sample.php。声明三个不同类型的集合变量，类型如 \\Ds\\Vector 和 \\Ds\\Set 。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">$collection_a = new \\Ds\\Vector([1, 2, 3]);\n$collection_b = new \\Ds\\Vector();\n$collection_c = new \\Ds\\Set();\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">添加一个返回类的任意函数，如返回字符串形式的 \\Ds\\Vector::class 。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">function getSomeClass(): string\n{\n    return \\Ds\\Vector::class;\n}\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出对不同集合变量使用 instanceof 运算符后的结果。instanceof 运算符接受一个表达式，该表达式在每次调用中会被计算为字符串。sample.php的脚本如下所示。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$collection_a = new \\Ds\\Vector([1, 2, 3]);\n$collection_b = new \\Ds\\Vector();\n$collection_c = new \\Ds\\Set();\nfunction getSomeClass(): string\n{\n    return \\Ds\\Vector::class;\n}\nvar_dump($collection_a instanceof ('\\Ds'.'\\Vector'));\nvar_dump($collection_a instanceof ('\\Ds'.'\\Hashtable'));\nvar_dump($collection_b instanceof ('\\Ds'.'\\Vector'));\nvar_dump($collection_b instanceof ('\\Ds'.'\\Set'));\nvar_dump($collection_c instanceof ('\\Ds'.'\\Set'));\nvar_dump(new \\Ds\\Vector instanceof (getSomeClass()));\nvar_dump($collection_a instanceof ('\\Ds'.'\\Set'));\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">该脚本在PHP 8中能正常运行，并生成如下的输出：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">bool(true) \nbool(false)\nbool(true) \nbool(false) \nbool(true) \nbool(true) \nbool(false) \n</code></code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\">JIT（Just-In-Time）编译器</code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\">PHP 8引入了<a href=\"https://web.archive.org/web/20020901165532/http://foldoc.doc.ic.ac.uk/foldoc/foldoc.cgi?JIT\">即时（Just-in-time ，JIT）编译</a>\"，其目的如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">提高性能和可用性。使PHP适用于非Web的CPU密集型用例，在这些用例中可以获得显著的性能优势。创造使用PHP而不是C开发内置函数的潜力。PHP可能是一个更好的选择，因为它没有C语言那样的内存管理和溢出问题。引入了两个JIT编译引擎：跟踪JIT（Tracing JIT）和函数JIT（Function JIT）。函数JIT只优化单个函数范围内的代码，而跟踪JIT则能优化整个堆栈跟踪。在综合基准测试中，跟踪JIT可以提高3倍的性能，在长时间运行的查询上可提高1.5到2倍。在Mandelbrot基准测试中，跟踪JIT可以将性能提高4倍以上。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">在本文中，我们介绍了一些与PHP 8语法最相关的改进，包括注解（attributes）、 new 运算符、 match 表达式等。在下一篇文章中，我们将探讨类和构造函数的改进。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">作者介绍：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">Deepak Vohra是Oracle认证的Java程序员和Oracle认证的Web Component开发人员。Deepak已经出版了20多本书。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">原文链接：</code></code></p><p><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.com/articles/php8-attributes-match-new-operator/\">https://www.infoq.com/articles/php8-attributes-match-new-operator/</a>\"</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">相关阅读：</code></code></p><p><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.cn/article/YEImBIBZHJTT9BOXPvLJ\">为什么在 20 多年后，我仍然爱着 PHP 和 JavaScript</a>\"</code></code></p><p><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.cn/article/jIFtq9JcJd1w36DKg6Wa\">JetBrains 官宣：PHP 基金会成立</a>\"</code></code></p><p></p><p></p>",
    "publish_time": "2022-11-27 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "马斯克要求推特程序员写周报，具体到代码行数；刘强东称将末位淘汰部分京东高管；闰秒终于要被取消了！｜ Q资讯",
    "url": "https://www.infoq.cn/article/4rYaFlR88OC8PVbZiiEZ",
    "summary": "<p></p><blockquote>马斯克要求推特程序员写周报，具体到代码行数；刘强东称将末位淘汰部分京东高管；罗永浩AR公司完成融资，估值2 亿美元；游戏工委报告：未成年人沉迷游戏问题已经基本解决；谷歌酝酿减员万人，美股科技巨头“全军覆没”；谷歌神秘项目曝光：教AI完全自主写代码、改Bug；Ant Design 5.0正式发布；闰秒终于要被取消了……</blockquote><p></p><p>&nbsp;</p><p></p><h2>科技公司</h2><p></p><p>&nbsp;</p><p></p><h4>马斯克要求推特程序员写周报，具体到代码行数</h4><p></p><p>&nbsp;</p><p>11月24日，据 Business Insider 报道，推特内部邮件显示，该公司要求技术类员工必须每周发邮件给CEO埃隆·马斯克（Elon Musk），介绍自己本周的所有工作，以此实现“快速创新”。</p><p>&nbsp;</p><p>当地时间周一晚，马斯克及其领导团队使用的邮箱向推特程序员们发送邮件称，推特将采用一种新的方法来跟踪他们的工作进度。从本周开始，所有从事编程或技术工作的推特员工都要每周提交一份工作报告，介绍他们做过的工作、希望完成的工作以及编写的代码行数，还要包含“代码样本/本周编写的代码的Phabricator链接。”Phabricator是一套基于Web的软件开发协作工具，包括代码审查工具Differential，资源库浏览器Diffusion，变更监测工具Herald，Bug跟踪工具Maniphest等。对此，马斯克回复称：“也许了解工作进度并非不合理”。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/97/9740e08a825188aeef78bc466bb4a24b.png\" /></p><p></p><p>&nbsp;</p><p>上周，马斯克告诉员工，他想雇佣更多“擅长编写软件”的人。但从实际情况来看，马斯克的裁员仍在继续。感恩节前一天，约有50名推特工程师收到了解雇通知，因为他们在最近的Code review中表现不尽人意（code is not satisfactory），而且还有一些人收到了业绩警告（performance warning）。Gergely Orosz表示自己和这些员工的直系领导沟通后，认为警告是误触发的PIP，因为直系领导对此表示并不知情。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/eb/eb489925c373969a8da1493dd43b53f3.png\" /></p><p></p><p>&nbsp;</p><p>此次裁掉的还有<a href=\"https://twitter.com/nabokov7\">Ikuhiro Ihara</a>\"，一位备受尊敬的高级软件工程师，在他的推动下，推特将推文扩展到 280 个<a href=\"https://blog.twitter.com/en_us/topics/product/2017/Giving-you-more-characters-to-express-yourself\">字符</a>\"。Ihara声称他虽然是以“code is not satisfactory”为由被解雇，但推特实际上并没有进行任何代码审核。这其中还包括在<a href=\"https://mp.weixin.qq.com/s/96kJSH6INo_vI_zGUPWC7w\">解雇后被召回</a>\"，然后写完文档后再被开除的极端例子。如果这些裁员都是真的，那么推特绝对是所有科技公司中最“有毒”的工作场所。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/a8/a8265563c5abab249d96ec80b06e51c4.png\" /></p><p></p><p>&nbsp;</p><p>&nbsp;</p><p></p><h4>刘强东称将末位淘汰部分京东高管</h4><p></p><p>&nbsp;</p><p>据晚点报道，11月20日，在京东经营管理培训会上，身处香港的京东集团董事局主席刘强东在会议中视频接入，刘强东在高管会议上宣布，今年年底将对10%以上的高管进行末位淘汰。刘强东还批评了零售业务高管，称自己在听战略会时，“高管们谈花里胡哨的故事太多，但谈成本、效率、体验太少，如果对如此核心的战略都把握不够，那将很难带领团队长远走下去。”</p><p>&nbsp;</p><p>另外，11月22日，刘强东发布致京东全体兄弟们的一封信，提出要以高管降薪等多种方式提升员工待遇。信中提到，为了提高基层员工福利待遇，同时尽量减轻公司压力，集团决定自2023年1月1日起，京东集团副总监以上以及相对应的P/T序列以上全部高级管理人员，现金薪酬全部降低10%-20%不等，职位越高降得越多。除此之外，刘强东表示未来公司将投入数百亿为全体德邦员工在内的所有物流、客服等基层员工设立“住房保障金”，为基层员工提供购房无息贷款，同时“员工子女救助基金”的规模也会得到补充。</p><p>&nbsp;</p><p></p><h4>罗永浩AR公司完成融资，估值2 亿美元</h4><p></p><p>&nbsp;</p><p>罗永浩 AR 创业公司细红线科技宣布完成约 5000 万美元（约合人民币 3.58 亿元）天使轮融资，投后估值约为 2 亿美元（约合人民币 14 亿元）。本轮融资由美团龙珠领投，蓝驰创投、联想创投、经纬创投、大疆创新、ATM Capital 等投资机构，以及黎万强、吴泳铭等科技界知名人士跟投。据公开资料显示，细红线科技成立于 2022 年 6 月，致力于打造智能手机之后的下一代个人计算设备平台。从 6 月创立之初，细红线科技就开启了招聘计划，主要招聘对象为 AR 工程师和产品经理。近期该公司招聘了大量产品经理和程序员，其中一部分来自小米和黑鲨。</p><p>&nbsp;</p><p></p><h4>游戏工委报告：未成年人的沉迷游戏问题已经基本解决</h4><p></p><p>&nbsp;</p><p>据36氪消息，近日，中国音数协游戏工委、中国游戏产业研究院联合伽马数据共同发布了《2022中国游戏产业未成年人保护进展报告》。报告研究显示，超七成未成年人每周游戏时长在3小时以内，未成年人游戏沉迷问题已得到基本解决。2022年出现未成年人私自充值现象的家庭占比降至15.43%，较2021年有了明显下降。现存未成年游戏用户的家长中，35%以上允许孩子用自己身份证注册账号。</p><p>&nbsp;</p><p></p><h4>谷歌酝酿减员万人，美股科技巨头“全军覆没”</h4><p></p><p>&nbsp;</p><p>综合多家媒体报道，谷歌母公司Alphabet正计划裁掉约1万名“表现不佳”的员工。报道称，Alphabet最新的绩效管理系统可以帮助公司筛选员工，可用来当作削减员工福利、薪酬和股票分红的依据。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/82/82610de92b2b8f30dab1028eee9348f9.png\" /></p><p></p><p>&nbsp;</p><p>更多信息：</p><p><a href=\"https://mp.weixin.qq.com/s/zvpGkVZ2x75p-392xi2Phg\">谷歌计划裁员上万人：利用刚上线半年的新绩效系统解雇6%“排名垫底”员工</a>\"</p><p>&nbsp;</p><p></p><h2>IT业界</h2><p></p><p>&nbsp;</p><p></p><h4>谷歌神秘项目曝光：教AI完全自主写代码、改Bug</h4><p></p><p>&nbsp;</p><p>据外媒 Business Insider 11 月 23 日报道，谷歌正在开展一个秘密项目，该项目在谷歌内部的开发代号为“Pitchfork”。内部文件显示，Pitchfork 能够通过机器学习技术训练智能体编写代码、修复 Bug，以及代码更新。</p><p>&nbsp;</p><p>知情人士称，该项目最初成立于谷歌母公司Alphabet's的“X”研究部门，如今已走进谷歌实验室（Google Labs）。目前，Pitchfork隶属于“谷歌实验室”旗下的一个新部门“AI Developer Assistance”（人工智能开发者支持团队），由奥利维亚·哈塔尔斯基领导，后者曾负责谷歌眼镜和其他一些“登月项目”。</p><p>&nbsp;</p><p>谷歌发言人称，Pitchfork 的最初目标是构建一款工具，可以将谷歌的 Python 编程语言代码库更新到较新的版本。但随着时间的推移，该项目的目标转向了一个通用系统：可以减少人类开发者编写和更新代码的需要，同时又能保持代码质量。</p><p>&nbsp;</p><p></p><h4>Ant Design 5.0正式发布</h4><p></p><p>&nbsp;</p><p>Ant Design 5.0 已在上周正式发布。Ant Design 开发团队表示，同上一个大版本发布一样，他们将会把 v4 从主分支切换至 4.x-stable 分支进入维护状态。v4 将会继续维护 1 年时间，仍然会对 Bug 发布 Patch，但是此后不再接收新的 Feature Request。截止日期为 2023 年年底。原 v4 官网迁移至 <a href=\"https://4x.ant.design/\">https://4x.ant.design/</a>\"。</p><p>&nbsp;</p><p>了解更多：<a href=\"https://ant.design/changelog-cn\">https://ant.design/changelog-cn</a>\"</p><p>&nbsp;</p><p></p><h4>闰秒终于要被取消了！</h4><p></p><p>&nbsp;</p><p>11月20日消息，负责协调世界时的国际计量局（BIPM）表示，科学家和政府代表18日在法国举行的一次会议上投票决定到2035年取消闰秒。BIPM时间部门负责人帕特里齐亚·塔维拉表示，这项“历史性决定”将允许“秒数连续流动，而不会出现目前由不规则闰秒造成的不连续性。”</p><p>&nbsp;</p><p>更多阅读：</p><p><a href=\"https://mp.weixin.qq.com/s/GnD0EnAjmlPvyQrscWFJlQ\">让大厂抓狂的“额外一秒”：谷歌、微软、Meta 和亚马逊纷纷提议放弃</a>\"</p><p>&nbsp;</p><p></p><h4>Kotlin发布调查报告：近一半用户不满IDE性能</h4><p></p><p>&nbsp;</p><p>11月18日， Kotlin 团队公布了 首次 Kotlin 开发者调查结果。Kotlin 是 IDE 厂商 JetBrains 公司开发的编程语言，业内曾一度热议其未来是否会取代 Java。为了找出影响 Kotlin 用户满意度最大的痛点，今年Kotlin 团队开始组织开发者调查，根据报告显示，目前 Kotlin 的用户总体满意度为 86%，但 Kotlin Build Tools 的客户满意度为 62%，目前 Kotlin 用户的主要痛点是 IDE 和构建性能。</p><p>&nbsp;</p><p>了解更多：<a href=\"https://blog.jetbrains.com/kotlin/2022/11/how-kotlin-is-going-to-fix-your-pains-in-2023/\">https://blog.jetbrains.com/kotlin/2022/11/how-kotlin-is-going-to-fix-your-pains-in-2023/</a>\"</p>",
    "publish_time": "2022-11-27 12:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]