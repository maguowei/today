[
  {
    "title": "PHP 8——注解、match表达式及其他改进",
    "url": "https://www.infoq.cn/article/XkzLrAYhV1CWPDzu72N2",
    "summary": "<p>PHP 8是<a href=\"https://www.infoq.cn/article/Q5vwc4WSOj27bawTd2S4\">PHP</a>\"的一次重大更新，它引入了一些新特性和性能优化，包括注解（attributes）、 match 表达式、 instanceof 运算符、 new 运算符、全新的JIT编译器等等。</p><p></p><p>注解（attributes）提供了一种向类、方法、函数、参数、属性和类常量中添加元数据的方法。Attributes注解类似于其他一些语言所支持的annotations注解。new 运算符仅从PHP 8.1开始可用，可用于默认参数值、静态变量的初始化设置和属性参数。 match 表达式是一种新的控制结构，它使用身份运算符（identity operator）对带有多分支条件表达式的主题表达式进行匹配，并执行匹配的分支。 instanceof 运算符以前只能用于类对象，现在也可以用于任意表达式了。 JIT（Just-In-Time）编译器带来了性能和可用性提升。</p><p></p><p>其中一些示例所基于的数据结构需要<a href=\"https://pecl.php.net/package/ds\">从此处</a>\"下载并安装 php_ds 扩展。在Windows上，需要<a href=\"https://pecl.php.net/package/ds/1.4.0/windows\">从此处</a>\"下载8.1非线程安全（Non-Thread-Safe，NTS）x64的DLL，并将php_ds-1.4.0-8.1-NTS-vs16-x64.zip文件解压缩到某个目录下。解压后，将目录中的php_ds.dll复制到PHP 8.x安装根目录中的 .\\ext 目录中，例如 C:\\PHP-8.1.9-nts-Win32-vs16-x64\\ext 。并在php.ini配置文件中添加如下行：</p><p></p><p>extension=php_ds</p><p></p><p>如果PHP内置服务器已经在运行了，那么请重新启动它。</p><p></p><h2>注解（Attributes）</h2><p></p><p>注解（Attributes）是配置指令，用于使用结构化的和机器可读的元数据注释或修饰类、方法、函数、参数、属性和类常量。“结构化”意味着可以读取和解析元数据的信息，这使得注解不同于非结构化的文档注释，后者只是普通字符串。注解可用于提供仅在某些时候相关的配置和其他信息，因此它可以是嵌入式的，而不是硬编码到PHP脚本中。以下是使用注解的典型顺序：</p><p></p><p>声明注解类。注解类是一个常规的PHP类，其前面是一行单独使用的 #[Attribute] 。该类可以选择性地声明一个构造函数。注解由其类标识；当使用该注解时，类名就是注解名。在类、方法、函数、参数、属性和类常量声明上应用或使用该注解。例如，如果注解类名为 Validate ，则该注解用作 #[Validate] 。同一注解可以在不同的声明中多次使用。并且多个注解也可以应用于同一个声明。如果需要，可以在运行时中使用<a href=\"https://www.php.net/manual/en/book.reflection.php\">反射API</a>\"获取或读取注解。注解有多种用途，例如：</p><p></p><p>提供接口的替代方案，好处是实现接口的类需要实现接口中的所有方法，而注解可以仅在需要时使用，从而避免不必要的方法实现。更改编译、诊断、代码生成和运行时行为。分离PHP引擎和扩展。PHP核心和扩展可以在某些声明上具有某些注解。在声明中嵌入特定的配置信息。例如，方法上的注解可以指示该方法监听哪些事件。从文档块迁移到注解中。默认情况下，可以在任何或所有受支持的声明类型上使用注解。但是，注解的​​使用可能仅限于使用选定的位掩码标志 Attribute::TARGET_CLASS 、 Attribute::TARGET_FUNCTION 、 Attribute::TARGET_METHOD 、 Attribute::TARGET_PROPERTY 、 Attribute::TARGET_CLASS_CONSTANT 、 Attribute::TARGET_PARAMETER 、 Attribute::TARGET_ALL  的一种或多种类型的声明上。 Attribute::TARGET_ALL  标志是默认值。使用位掩码标志 Attribute::IS_REPEATABLE ，可以在单个声明中多次使用同一注解。</p><p></p><p>接下来，我们将通过一个示例来探讨注解的使用。假设你想使用一个或多个排序函数对数组进行排序，例如 sort() 用于升序排序， rsort() 用于降序排序， shuffle() 用于随机排序。你可能还需要验证一下输入的数组，以验证它不是空数组，或者它至少有两个元素以使排序相关。排序类型信息和验证信息可以以注解的形式提供。</p><p></p><p>首先，声明用于验证的注解类。</p><p></p><p><code lang=\"php\">#[Attribute]\nclass Validate {}\n</code></p><p></p><p>然后，为排序类型声明另一个注解类。位掩码标志 Attribute::TARGET_CLASS 和 Attribute::IS_REPEATABLE 表示该注解仅用于类声明，并且该注解是可重复的。</p><p></p><p><code lang=\"php\">#[Attribute(Attribute::TARGET_CLASS|Attribute::IS_REPEATABLE)]\nclass SortType {\nfunction __construct($sortType){\n        $this-&gt;sortType = $sortType;\n    }\n}\n</code></p><p></p><p>现在声明带有 sortArray() 方法的接口。</p><p></p><p><code lang=\"php\">interface Sort \n{   \n    public function sortArray();\n}\n</code></p><p></p><p>最后，声明Sort接口的实现类。</p><p></p><p><code lang=\"php\">class SortImpl implements Sort\n{\n…}\n</code></p><p></p><p>在类中，声明两个类属性，一个用于排序类型，另一个用于要排序的数组。</p><p></p><p><code lang=\"php\">public string $sortType=\"\";\npublic $arrayToSort=array(\"B\", \"A\", \"f\", \"C\");\n</code></p><p></p><p>声明一个方法来验证要排序的数组不是空数组。用 #[Validate] 注解来注解该方法。将注解应用于方法，可以使用反射API来发现该方法。</p><p></p><p><code lang=\"php\">#[Validate]\n    public function arrayEmpty()\n    {\n        if (count($this-&gt;arrayToSort) === 0) {\n            throw new RuntimeException(\"Array is empty; please provide a non-empty array\");\n        }\n    }\n</code></p><p></p><p>声明第二个方法来验证数组是否至少有两个元素，并对其应用 #[Validate] 注解。</p><p></p><p><code lang=\"php\">#[Validate]\n    public function arraySize()\n    {\n        if (sizeof($this-&gt;arrayToSort) &lt; 2) {\n            throw new RuntimeException(\"Please provide an array of size 2 or more\");\n        }\n    }\n</code></p><p></p><p>实现 sortArray 函数。根据 SortType 的值，进行升序/降序/随机排序。</p><p></p><p><code lang=\"php\">public function sortArray()\n    { \n        \n         if ($this-&gt;sortType == \"asc\") {\n            …\n        } elseif ($this-&gt;sortType == \"desc\") {\n            …\n        } else {\n              \n             …\n    }\n</code></p><p></p><p>添加一个名为 performSort(Sort $sort) 的函数来执行排序。在该函数中，在执行排序之前会先应用验证。</p><p></p><p>声明一个类并对其应用 #[SortType] 注解。由于该注解是可重复的，因此多次应用该注解以执行不同类型的排序。</p><p></p><p><code lang=\"php\">#[SortType(sortType: \"desc\")] \n#[SortType(sortType: \"shuffle\")]  \n#[SortType(sortType: \"asc\")]              \nclass QSort\n{\n}\n</code></p><p></p><p>最后，创建一个 SortImpl 类的实例。</p><p></p><p><code lang=\"php\">$sort = new SortImpl();\n</code></p><p></p><p>使用反射API获取类注解。</p><p></p><p><code lang=\"php\">$ref    =   new ReflectionClass(QSort::class);\n$attrs  =   $ref-&gt;getAttributes();  \n</code></p><p></p><p>遍历注解数组，并调用 performSort() 函数，对每种排序类型执行排序，并输出排序结果。</p><p></p><p><code lang=\"php\">foreach ($attrs as $attr) {\n…\n}\n</code></p><p></p><p><a href=\"https://github.com/Deepak-Vohra/infoq-php8/blob/main/sort.php\">GitHub</a>\"上提供了演示注解使用的完整 sort.php 脚本。将 sort.php 脚本复制到 scripts 文件夹，并在<a href=\"http://localhost:8000/scripts/sort.php\">http://localhost:8000</a>\"上运行并监听PHP内置服务器，使用url &nbsp;<a href=\"http://localhost:8000/scripts/sort.php\">http://localhost:8000/scripts/sort.php</a>\"在浏览器中调用 sort.php 脚本。使用不同排序类型的排序结果将显示在浏览器中，如图1所示。</p><p></p><p>图 1 使用注解排序的结果</p><p></p><p>因为shuffle排序是一种随机排序，所以每次运行脚本时，shuffle的结果可能不同，如图2所示。</p><p></p><p>图 2  Shuffle排序产生不同的结果</p><p></p><p>因为要排序的示例数组有4个元素，所以没有一个验证失败。如果示例数组为空，作为对比，使用相同脚本，仅更改示例数组，将会生成运行时异常消息： Uncaught RuntimeException: Array is empty; please provide a non-empty array 。类似地，如果示例数组只有1个元素，也会生成运行时异常，并显示消息： Uncaught RuntimeException: Please provide an array of size 2 or more 。</p><p></p><h2>增强的 new 运算符</h2><p></p><p>new 运算符用于创建类的实例。从PHP 8.1开始，new 运算符可以用于具有如下语法的任意表达式中，其中表达式必须用圆括号括起来。</p><p></p><p><code lang=\"php\">new (expression)(...$args)\n</code></p><p></p><p>new 运算符可用于参数默认值的初始化设置、静态变量的初始化设置、全局常量的初始化设置和注解参数，接下来将通过示例进行探讨。</p><p></p><h3>在函数的参数默认值中使用 new 运算符</h3><p></p><p>为了演示在函数的参数默认值中使用 new 运算符，我们将使用数组排序示例的变体。考虑一个名为 SortArray 的类，它声明了一个方法 sortArray($arrayToSort) 来按升序对数组进行排序。</p><p></p><p><code lang=\"php\">class SortArray {\n    public function sortArray($arrayToSort) {\n…\n}\n}\n</code></p><p></p><p>第二个类，名为 ReverseSortArray ，它声明了一个按降序排列数组的方法。</p><p></p><p><code lang=\"php\">class ReverseSortArray {\n    public function sortArray($arrayToSort) {\n…\n}\n}\n</code></p><p></p><p>现在声明一个可接受任意数组的函数以及一个数组排序器来对数组进行排序。可以使用 new 运算符来定义默认的数组排序器，以创建 SortArray 的实例。</p><p></p><p><code lang=\"php\">function sortAnyArray($arrayToSort, $arraySorter = new SortArray)\n{\n    return $arraySorter-&gt;sortArray($arrayToSort);\n}\n</code></p><p></p><p>完整的脚本可以在&nbsp;<a href=\"https://github.com/Deepak-Vohra/infoq-php8/blob/main/sample.php\">GitHub</a>\"上找到。使用url <a href=\"http://localhost:8000/scripts/sample.php\">http://localhost:8000/scripts/sample.php</a>\"在内置服务器上运行示例脚本。</p><p></p><p>输出如下所示：</p><p></p><p><code lang=\"php\">arrayToSort[0] = A arrayToSort[1] = B arrayToSort[2] = C arrayToSort[3] = f\narrayToSort[0] = f arrayToSort[1] = C arrayToSort[2] = B arrayToSort[3] = A\n</code></p><p></p><h3>在变量和常量初始化中使用 new 运算符</h3><p></p><p>new 运算符可用于静态变量的初始化设置和全局常量的初始化设置。但是，在静态和非静态类属性的初始化设置中，以及在类常量的初始化设置中，都不支持 new 运算符。下面的脚本演示了哪些变量和常量的初始化设置是受支持的，哪些是不受支持的。</p><p></p><p><code lang=\"php\"><!--?php\nclass A{ }\nclass B{\n//static $a = new A; //在此上下文中不支持new表达式\n//public $a = new A; //在此上下文中不支持new表达式\n//const C = new A; //在此上下文中不支持new表达式\n}\nstatic $a = new A;\n \nconst C = new A;\n</code--></code></p><p></p><h3><code lang=\"php\">在注解参数中使用 new 运算符</code></h3><p></p><p><code lang=\"php\">正如你所料， new 运算符也可以用于注解参数。我们将使用与演示注解功能相同的示例，但有一点不同。请记住，我们使用 #[SortType] 注解来注解 QSort 类，并将注解参数作为字符串传递给它。</code></p><p></p><p><code lang=\"php\"><code lang=\"php\">#[SortType(sortType: \"desc\")] \n#[SortType(sortType: \"shuffle\")]  \n#[SortType(sortType: \"asc\")]              \nclass QSort\n{\n}\n</code></code></p><p></p><p><code lang=\"php\">针对这种情况，声明一个名为 Str 的类，它接受一个字符串型的参数作为构造函数的参数。</code></p><p></p><p><code lang=\"php\"><code lang=\"php\">class Str{\n    function __construct($str){\n        $this-&gt;value = $str;\n    }\n    function __toString(){\n        return $this-&gt;value;\n    }\n     \n}\n</code></code></p><p></p><p><code lang=\"php\">在注解参数中使用 new 运算符，脚本如下所示。</code></p><p></p><p><code lang=\"php\"><code lang=\"php\">#[SortType(sortType: new Str(\"desc\"))] \n#[SortType(sortType: new Str(\"shuffle\"))]  \n#[SortType(sortType: new Str(\"asc\"))]              \nclass QSort\n{\n}\n</code></code></p><p></p><p><code lang=\"php\">在内置服务器中运行脚本，输出与之前相同，如图3所示。</code></p><p></p><p><code lang=\"php\">图 3 在注解参数中使用new的结果</code></p><p></p><h3><code lang=\"php\">在某些上下文中不允许使用 new 运算符</code></h3><p></p><p><code lang=\"php\">前面我们提到了一些不支持 new 运算符的上下文，即静态和非静态类属性的初始化设置，以及类常量的初始化设置。 此外，在以下的上下文中也不支持 new 运算符：</code></p><p></p><p><code lang=\"php\">非字符串动态类名常量表达式中的参数解包（Argument unpacking）常量表达式中的匿名类不受支持的常量表达式下面脚本中所注释掉的语句如果运行都会生成错误：</code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><!--?php\n $list = [4, 6];\nfunction fn1(\n    $a1 = new ('some_dynamic_class')(),\n   //  $a2 = new (some_dynamic_class)(), // 非字符串动态类名 -  不能在常量表达式中使用动态类名\n   //  $b = new  class {}, // 不能在常量表达式中使用匿名类\n   // $c = new C(...$list), // 不支持在常量表达式中解包参数\n   //   $d = new D($x), // 常量表达式包含无效操作\n) {}\n</code--></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\">新的 match 表达式</code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\">PHP 8引入了一个新的 match 表达式作为控制流结构，它使用身份比较（identity comparison）将给定的主题表达式与一个或多个可选分支相匹配，并返回匹配分支的结果值。match 表达式类似于 switch 语句，但区别如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">match 表达式使用身份运算符（ === ）进行比较，而switch 则使用相等运算符（ == ）。match 表达式返回一个值，而switch 不返回。返回值可以赋值给某个变量。在匹配其中某个分支后，match 表达式会自动终止match 。switch 的终止则需要使用 break; 声明。match 表达式不会像switch那样在没有声明break;  的情况下失败。match 表达式支持在同一个分支中用逗号 （，）分隔多个条件，而switch 不支持。match 表达式必须是穷尽的，这意味着它必须要处理主题表达式的所有值。接下来，我们通过一些示例来演示 match 表达式的使用。</code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\">输出返回值</code></code></h3><p></p><p><code lang=\"php\"><code lang=\"php\">先从一个简单的示例开始，下面脚本中的match 表达式将作为主题表达式的整数 1 与包含默认模式的多个条件表达式进行匹配。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\necho match (1) {\n    0 =--> 'A',\n    1 =&gt; 'B',\n    2 =&gt; 'C',\n    default =&gt; 'Default',\n};\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">在内置引擎中运行脚本，通过使用url <a href=\"http://localhost:8000/scripts/match.php.\">http://localhost:8000/scripts/match.php</a>\"在浏览器中调用脚本，输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">B</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">在下面的脚本中，主题表达式与任何非默认条件表达式都不匹配。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\necho match (3) {\n    0 =--> 'A',\n    1 =&gt; 'B',\n    2 =&gt; 'C',\n    default =&gt; 'Default',\n};\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">Default</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">default 条件不能与脚本中所示的其他条件组合：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\necho match (3) {\n    0 =--> 'A',\n    1 =&gt; 'B',\n    2, default =&gt; 'C',\n     \n};\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">当脚本运行时，它会生成如下错误：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">Parse error: syntax error, unexpected token \"default\", expecting \"=&gt;\"\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">一个相对复杂的示例，下面的脚本有一个通过 \\Ds\\Vector 类初始化的变量。主题表达式以数组表示法访问 vector 变量。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$vector = new \\Ds\\Vector();\n$vector--->push('a');\n$vector-&gt;push('b', 'c');\n$vector[] = 'd';\n \necho match ($vector[1]) {\n  'a' =&gt; \"a\",\n  'b' =&gt; \"b\",\n};\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">使用url <a href=\"http://localhost:8000/scripts/match.php\">http://localhost:8000/scripts/match.php</a>\" 在浏览器中调用脚本。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">结果是：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">b</code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\">将返回值赋给变量</code></code></h3><p></p><p><code lang=\"php\"><code lang=\"php\">返回值也可以赋值给某个变量，匹配条件可以是任意表达式。在下面的脚本中， match 表达式将布尔值 true 作为主题表达式与调用其他内置字符串函数的条件表达式进行匹配。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$text = 'A B C D';\n$result = match (true) {\n    str_word_count($text)==3 || str_word_count($text)==2 =--> '2 or 3',\n    str_word_count($text)==4 || str_word_count($text)==5 =&gt; '4 or 5',\n    \n};\nvar_dump($result);\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出是：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">string(6) \"4 or 5\"\n</code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\">没有强制类型转换</code></code></h3><p></p><p><code lang=\"php\"><code lang=\"php\">与 switch 语句进行松散比较不同， match 表达式进行严格比较，并且不进行类型强制转换。首先，看一个与 switch 语句进行松散比较的示例。下面的脚本会匹配第一个条件并输出值 a 。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$var = 0;\nswitch((string)$var) \n{\n    case  0  : echo 'a'; break; // 这将测试NULL或空字符串   \n    default : echo 'b'; break; // 其他的，包括零\n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">相比之下，下面脚本中的match 进行了严格比较，并匹配默认条件输出 Default 。</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$var = 0;\n \necho match ((string)$var) {\n    0 =--> 'a',\n    default =&gt; 'Default',\n};\n</code></code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\">即使是 NULL 值也可使用身份比较进行匹配</code></code></h3><p></p><p><code lang=\"php\"><code lang=\"php\">match 表达式使用身份运算符（ === ）进行身份比较，这意味着即使是 NULL 值也会匹配。由于 Ds\\Vector::push() 方法返回 NULL ，所以，下面的脚本中的match 表达式实际上与Ds\\Vector::push() 方法所返回的NULL 值相匹配。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$vector = new \\Ds\\Vector();\n$vector--->push('a'); \n \nmatch ($vector-&gt;push('b')) {\n  $vector-&gt;push('d') =&gt; $vector-&gt;push('b'),\n  $vector-&gt;pop() =&gt; $vector-&gt;pop(),\n};\nprint_r($vector);\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">匹配的是第一个条件，输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">Ds\\Vector Object ( [0] =&gt; a [1] =&gt; b [2] =&gt; d [3] =&gt; b )\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">身份比较（ === ）可以应用于任意值，即使没有返回值也是如此。  match 返回的  NULL 值可以赋值给某个变量。 下面的脚本匹配 NULL 值，并且匹配的是第一个条件。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$vector = new \\Ds\\Vector();\n$vector--->push('a'); \n \n$vector = match ($vector-&gt;push('b')) {\n  $vector-&gt;push('c') =&gt; $vector-&gt;push('b'),\n  $vector-&gt;pop() =&gt; $vector-&gt;pop(),\n};\nvar_dump($vector);\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">使用url <a href=\"http://localhost:8000/scripts/sample.php\">http://localhost:8000/scripts/sample.php</a>\" 调用脚本，输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">NULL</code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\">可以用逗号分隔多个条件</code></code></h3><p></p><p><code lang=\"php\"><code lang=\"php\">多个条件表达式可以用逗号分隔。首先看一个具有单个条件的示例，脚本如下所示。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$vector = new \\Ds\\Vector();\n$vector--->push('a'); \n \nmatch ('push') {\n  'push' =&gt; $vector-&gt;push('b'),\n  'pop' =&gt; $vector-&gt;pop(),\n};\nprint_r($vector);\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出是：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">Ds\\Vector Object ( [0] =&gt; a [1] =&gt; b )\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">以相同的示例为例，添加多个用逗号分隔的条件。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$vector = new \\Ds\\Vector();\n$vector--->push('a'); \n \nmatch ('puush') {\n  'push','puush' =&gt; $vector-&gt;push('b') \n   \n};\nprint_r($vector);\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">第一个条件表达式列表中所列出的第二个可选选项将与拼写错误的“puush”相匹配，输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">Ds\\Vector Object ( [0] =&gt; a [1] =&gt; b )\n</code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\">穷举</code></code></h3><p></p><p><code lang=\"php\"><code lang=\"php\">match 表达式必须是可穷举的。在下面的脚本中，主题表达式与任何条件都不匹配。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\n$vector = new \\Ds\\Vector();\n$vector--->push('a'); \n \nmatch ('set') {\n  'push' =&gt; $vector-&gt;push('b'),\n  'pop' =&gt; $vector-&gt;pop(),\n};\nprint_r($vector);\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">结果是输出一个错误：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">Uncaught UnhandledMatchError: Unhandled match case 'set'\n</code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\">instanceof 运算符支持任意表达式</code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\">另一个新特性是 instanceof 运算符可接受任意表达式。仅有的两个要求是：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">表达式必须用圆括号括起来，并且表达式的计算结果必须为字符串。为了演示示新的instanceof 运算符，请创建一个PHP脚本sample.php。声明三个不同类型的集合变量，类型如 \\Ds\\Vector 和 \\Ds\\Set 。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">$collection_a = new \\Ds\\Vector([1, 2, 3]);\n$collection_b = new \\Ds\\Vector();\n$collection_c = new \\Ds\\Set();\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">添加一个返回类的任意函数，如返回字符串形式的 \\Ds\\Vector::class 。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">function getSomeClass(): string\n{\n    return \\Ds\\Vector::class;\n}\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出对不同集合变量使用 instanceof 运算符后的结果。instanceof 运算符接受一个表达式，该表达式在每次调用中会被计算为字符串。sample.php的脚本如下所示。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$collection_a = new \\Ds\\Vector([1, 2, 3]);\n$collection_b = new \\Ds\\Vector();\n$collection_c = new \\Ds\\Set();\nfunction getSomeClass(): string\n{\n    return \\Ds\\Vector::class;\n}\nvar_dump($collection_a instanceof ('\\Ds'.'\\Vector'));\nvar_dump($collection_a instanceof ('\\Ds'.'\\Hashtable'));\nvar_dump($collection_b instanceof ('\\Ds'.'\\Vector'));\nvar_dump($collection_b instanceof ('\\Ds'.'\\Set'));\nvar_dump($collection_c instanceof ('\\Ds'.'\\Set'));\nvar_dump(new \\Ds\\Vector instanceof (getSomeClass()));\nvar_dump($collection_a instanceof ('\\Ds'.'\\Set'));\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">该脚本在PHP 8中能正常运行，并生成如下的输出：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">bool(true) \nbool(false)\nbool(true) \nbool(false) \nbool(true) \nbool(true) \nbool(false) \n</code></code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\">JIT（Just-In-Time）编译器</code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\">PHP 8引入了<a href=\"https://web.archive.org/web/20020901165532/http://foldoc.doc.ic.ac.uk/foldoc/foldoc.cgi?JIT\">即时（Just-in-time ，JIT）编译</a>\"，其目的如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">提高性能和可用性。使PHP适用于非Web的CPU密集型用例，在这些用例中可以获得显著的性能优势。创造使用PHP而不是C开发内置函数的潜力。PHP可能是一个更好的选择，因为它没有C语言那样的内存管理和溢出问题。引入了两个JIT编译引擎：跟踪JIT（Tracing JIT）和函数JIT（Function JIT）。函数JIT只优化单个函数范围内的代码，而跟踪JIT则能优化整个堆栈跟踪。在综合基准测试中，跟踪JIT可以提高3倍的性能，在长时间运行的查询上可提高1.5到2倍。在Mandelbrot基准测试中，跟踪JIT可以将性能提高4倍以上。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">在本文中，我们介绍了一些与PHP 8语法最相关的改进，包括注解（attributes）、 new 运算符、 match 表达式等。在下一篇文章中，我们将探讨类和构造函数的改进。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">作者介绍：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">Deepak Vohra是Oracle认证的Java程序员和Oracle认证的Web Component开发人员。Deepak已经出版了20多本书。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">原文链接：</code></code></p><p><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.com/articles/php8-attributes-match-new-operator/\">https://www.infoq.com/articles/php8-attributes-match-new-operator/</a>\"</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">相关阅读：</code></code></p><p><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.cn/article/YEImBIBZHJTT9BOXPvLJ\">为什么在 20 多年后，我仍然爱着 PHP 和 JavaScript</a>\"</code></code></p><p><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.cn/article/jIFtq9JcJd1w36DKg6Wa\">JetBrains 官宣：PHP 基金会成立</a>\"</code></code></p><p></p><p></p>",
    "publish_time": "2022-11-27 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]