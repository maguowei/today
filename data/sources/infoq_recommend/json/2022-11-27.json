[
  {
    "title": "PHP 8——注解、match表达式及其他改进",
    "url": "https://www.infoq.cn/article/XkzLrAYhV1CWPDzu72N2",
    "summary": "<p>PHP 8是<a href=\"https://www.infoq.cn/article/Q5vwc4WSOj27bawTd2S4\">PHP</a>\"的一次重大更新，它引入了一些新特性和性能优化，包括注解（attributes）、 match 表达式、 instanceof 运算符、 new 运算符、全新的JIT编译器等等。</p><p></p><p>注解（attributes）提供了一种向类、方法、函数、参数、属性和类常量中添加元数据的方法。Attributes注解类似于其他一些语言所支持的annotations注解。new 运算符仅从PHP 8.1开始可用，可用于默认参数值、静态变量的初始化设置和属性参数。 match 表达式是一种新的控制结构，它使用身份运算符（identity operator）对带有多分支条件表达式的主题表达式进行匹配，并执行匹配的分支。 instanceof 运算符以前只能用于类对象，现在也可以用于任意表达式了。 JIT（Just-In-Time）编译器带来了性能和可用性提升。</p><p></p><p>其中一些示例所基于的数据结构需要<a href=\"https://pecl.php.net/package/ds\">从此处</a>\"下载并安装 php_ds 扩展。在Windows上，需要<a href=\"https://pecl.php.net/package/ds/1.4.0/windows\">从此处</a>\"下载8.1非线程安全（Non-Thread-Safe，NTS）x64的DLL，并将php_ds-1.4.0-8.1-NTS-vs16-x64.zip文件解压缩到某个目录下。解压后，将目录中的php_ds.dll复制到PHP 8.x安装根目录中的 .\\ext 目录中，例如 C:\\PHP-8.1.9-nts-Win32-vs16-x64\\ext 。并在php.ini配置文件中添加如下行：</p><p></p><p>extension=php_ds</p><p></p><p>如果PHP内置服务器已经在运行了，那么请重新启动它。</p><p></p><h2>注解（Attributes）</h2><p></p><p>注解（Attributes）是配置指令，用于使用结构化的和机器可读的元数据注释或修饰类、方法、函数、参数、属性和类常量。“结构化”意味着可以读取和解析元数据的信息，这使得注解不同于非结构化的文档注释，后者只是普通字符串。注解可用于提供仅在某些时候相关的配置和其他信息，因此它可以是嵌入式的，而不是硬编码到PHP脚本中。以下是使用注解的典型顺序：</p><p></p><p>声明注解类。注解类是一个常规的PHP类，其前面是一行单独使用的 #[Attribute] 。该类可以选择性地声明一个构造函数。注解由其类标识；当使用该注解时，类名就是注解名。在类、方法、函数、参数、属性和类常量声明上应用或使用该注解。例如，如果注解类名为 Validate ，则该注解用作 #[Validate] 。同一注解可以在不同的声明中多次使用。并且多个注解也可以应用于同一个声明。如果需要，可以在运行时中使用<a href=\"https://www.php.net/manual/en/book.reflection.php\">反射API</a>\"获取或读取注解。注解有多种用途，例如：</p><p></p><p>提供接口的替代方案，好处是实现接口的类需要实现接口中的所有方法，而注解可以仅在需要时使用，从而避免不必要的方法实现。更改编译、诊断、代码生成和运行时行为。分离PHP引擎和扩展。PHP核心和扩展可以在某些声明上具有某些注解。在声明中嵌入特定的配置信息。例如，方法上的注解可以指示该方法监听哪些事件。从文档块迁移到注解中。默认情况下，可以在任何或所有受支持的声明类型上使用注解。但是，注解的​​使用可能仅限于使用选定的位掩码标志 Attribute::TARGET_CLASS 、 Attribute::TARGET_FUNCTION 、 Attribute::TARGET_METHOD 、 Attribute::TARGET_PROPERTY 、 Attribute::TARGET_CLASS_CONSTANT 、 Attribute::TARGET_PARAMETER 、 Attribute::TARGET_ALL  的一种或多种类型的声明上。 Attribute::TARGET_ALL  标志是默认值。使用位掩码标志 Attribute::IS_REPEATABLE ，可以在单个声明中多次使用同一注解。</p><p></p><p>接下来，我们将通过一个示例来探讨注解的使用。假设你想使用一个或多个排序函数对数组进行排序，例如 sort() 用于升序排序， rsort() 用于降序排序， shuffle() 用于随机排序。你可能还需要验证一下输入的数组，以验证它不是空数组，或者它至少有两个元素以使排序相关。排序类型信息和验证信息可以以注解的形式提供。</p><p></p><p>首先，声明用于验证的注解类。</p><p></p><p><code lang=\"php\">#[Attribute]\nclass Validate {}\n</code></p><p></p><p>然后，为排序类型声明另一个注解类。位掩码标志 Attribute::TARGET_CLASS 和 Attribute::IS_REPEATABLE 表示该注解仅用于类声明，并且该注解是可重复的。</p><p></p><p><code lang=\"php\">#[Attribute(Attribute::TARGET_CLASS|Attribute::IS_REPEATABLE)]\nclass SortType {\nfunction __construct($sortType){\n        $this-&gt;sortType = $sortType;\n    }\n}\n</code></p><p></p><p>现在声明带有 sortArray() 方法的接口。</p><p></p><p><code lang=\"php\">interface Sort \n{   \n    public function sortArray();\n}\n</code></p><p></p><p>最后，声明Sort接口的实现类。</p><p></p><p><code lang=\"php\">class SortImpl implements Sort\n{\n…}\n</code></p><p></p><p>在类中，声明两个类属性，一个用于排序类型，另一个用于要排序的数组。</p><p></p><p><code lang=\"php\">public string $sortType=\"\";\npublic $arrayToSort=array(\"B\", \"A\", \"f\", \"C\");\n</code></p><p></p><p>声明一个方法来验证要排序的数组不是空数组。用 #[Validate] 注解来注解该方法。将注解应用于方法，可以使用反射API来发现该方法。</p><p></p><p><code lang=\"php\">#[Validate]\n    public function arrayEmpty()\n    {\n        if (count($this-&gt;arrayToSort) === 0) {\n            throw new RuntimeException(\"Array is empty; please provide a non-empty array\");\n        }\n    }\n</code></p><p></p><p>声明第二个方法来验证数组是否至少有两个元素，并对其应用 #[Validate] 注解。</p><p></p><p><code lang=\"php\">#[Validate]\n    public function arraySize()\n    {\n        if (sizeof($this-&gt;arrayToSort) &lt; 2) {\n            throw new RuntimeException(\"Please provide an array of size 2 or more\");\n        }\n    }\n</code></p><p></p><p>实现 sortArray 函数。根据 SortType 的值，进行升序/降序/随机排序。</p><p></p><p><code lang=\"php\">public function sortArray()\n    { \n        \n         if ($this-&gt;sortType == \"asc\") {\n            …\n        } elseif ($this-&gt;sortType == \"desc\") {\n            …\n        } else {\n              \n             …\n    }\n</code></p><p></p><p>添加一个名为 performSort(Sort $sort) 的函数来执行排序。在该函数中，在执行排序之前会先应用验证。</p><p></p><p>声明一个类并对其应用 #[SortType] 注解。由于该注解是可重复的，因此多次应用该注解以执行不同类型的排序。</p><p></p><p><code lang=\"php\">#[SortType(sortType: \"desc\")] \n#[SortType(sortType: \"shuffle\")]  \n#[SortType(sortType: \"asc\")]              \nclass QSort\n{\n}\n</code></p><p></p><p>最后，创建一个 SortImpl 类的实例。</p><p></p><p><code lang=\"php\">$sort = new SortImpl();\n</code></p><p></p><p>使用反射API获取类注解。</p><p></p><p><code lang=\"php\">$ref    =   new ReflectionClass(QSort::class);\n$attrs  =   $ref-&gt;getAttributes();  \n</code></p><p></p><p>遍历注解数组，并调用 performSort() 函数，对每种排序类型执行排序，并输出排序结果。</p><p></p><p><code lang=\"php\">foreach ($attrs as $attr) {\n…\n}\n</code></p><p></p><p><a href=\"https://github.com/Deepak-Vohra/infoq-php8/blob/main/sort.php\">GitHub</a>\"上提供了演示注解使用的完整 sort.php 脚本。将 sort.php 脚本复制到 scripts 文件夹，并在<a href=\"http://localhost:8000/scripts/sort.php\">http://localhost:8000</a>\"上运行并监听PHP内置服务器，使用url &nbsp;<a href=\"http://localhost:8000/scripts/sort.php\">http://localhost:8000/scripts/sort.php</a>\"在浏览器中调用 sort.php 脚本。使用不同排序类型的排序结果将显示在浏览器中，如图1所示。</p><p></p><p>图 1 使用注解排序的结果</p><p></p><p>因为shuffle排序是一种随机排序，所以每次运行脚本时，shuffle的结果可能不同，如图2所示。</p><p></p><p>图 2  Shuffle排序产生不同的结果</p><p></p><p>因为要排序的示例数组有4个元素，所以没有一个验证失败。如果示例数组为空，作为对比，使用相同脚本，仅更改示例数组，将会生成运行时异常消息： Uncaught RuntimeException: Array is empty; please provide a non-empty array 。类似地，如果示例数组只有1个元素，也会生成运行时异常，并显示消息： Uncaught RuntimeException: Please provide an array of size 2 or more 。</p><p></p><h2>增强的 new 运算符</h2><p></p><p>new 运算符用于创建类的实例。从PHP 8.1开始，new 运算符可以用于具有如下语法的任意表达式中，其中表达式必须用圆括号括起来。</p><p></p><p><code lang=\"php\">new (expression)(...$args)\n</code></p><p></p><p>new 运算符可用于参数默认值的初始化设置、静态变量的初始化设置、全局常量的初始化设置和注解参数，接下来将通过示例进行探讨。</p><p></p><h3>在函数的参数默认值中使用 new 运算符</h3><p></p><p>为了演示在函数的参数默认值中使用 new 运算符，我们将使用数组排序示例的变体。考虑一个名为 SortArray 的类，它声明了一个方法 sortArray($arrayToSort) 来按升序对数组进行排序。</p><p></p><p><code lang=\"php\">class SortArray {\n    public function sortArray($arrayToSort) {\n…\n}\n}\n</code></p><p></p><p>第二个类，名为 ReverseSortArray ，它声明了一个按降序排列数组的方法。</p><p></p><p><code lang=\"php\">class ReverseSortArray {\n    public function sortArray($arrayToSort) {\n…\n}\n}\n</code></p><p></p><p>现在声明一个可接受任意数组的函数以及一个数组排序器来对数组进行排序。可以使用 new 运算符来定义默认的数组排序器，以创建 SortArray 的实例。</p><p></p><p><code lang=\"php\">function sortAnyArray($arrayToSort, $arraySorter = new SortArray)\n{\n    return $arraySorter-&gt;sortArray($arrayToSort);\n}\n</code></p><p></p><p>完整的脚本可以在&nbsp;<a href=\"https://github.com/Deepak-Vohra/infoq-php8/blob/main/sample.php\">GitHub</a>\"上找到。使用url <a href=\"http://localhost:8000/scripts/sample.php\">http://localhost:8000/scripts/sample.php</a>\"在内置服务器上运行示例脚本。</p><p></p><p>输出如下所示：</p><p></p><p><code lang=\"php\">arrayToSort[0] = A arrayToSort[1] = B arrayToSort[2] = C arrayToSort[3] = f\narrayToSort[0] = f arrayToSort[1] = C arrayToSort[2] = B arrayToSort[3] = A\n</code></p><p></p><h3>在变量和常量初始化中使用 new 运算符</h3><p></p><p>new 运算符可用于静态变量的初始化设置和全局常量的初始化设置。但是，在静态和非静态类属性的初始化设置中，以及在类常量的初始化设置中，都不支持 new 运算符。下面的脚本演示了哪些变量和常量的初始化设置是受支持的，哪些是不受支持的。</p><p></p><p><code lang=\"php\"><!--?php\nclass A{ }\nclass B{\n//static $a = new A; //在此上下文中不支持new表达式\n//public $a = new A; //在此上下文中不支持new表达式\n//const C = new A; //在此上下文中不支持new表达式\n}\nstatic $a = new A;\n \nconst C = new A;\n</code--></code></p><p></p><h3><code lang=\"php\">在注解参数中使用 new 运算符</code></h3><p></p><p><code lang=\"php\">正如你所料， new 运算符也可以用于注解参数。我们将使用与演示注解功能相同的示例，但有一点不同。请记住，我们使用 #[SortType] 注解来注解 QSort 类，并将注解参数作为字符串传递给它。</code></p><p></p><p><code lang=\"php\"><code lang=\"php\">#[SortType(sortType: \"desc\")] \n#[SortType(sortType: \"shuffle\")]  \n#[SortType(sortType: \"asc\")]              \nclass QSort\n{\n}\n</code></code></p><p></p><p><code lang=\"php\">针对这种情况，声明一个名为 Str 的类，它接受一个字符串型的参数作为构造函数的参数。</code></p><p></p><p><code lang=\"php\"><code lang=\"php\">class Str{\n    function __construct($str){\n        $this-&gt;value = $str;\n    }\n    function __toString(){\n        return $this-&gt;value;\n    }\n     \n}\n</code></code></p><p></p><p><code lang=\"php\">在注解参数中使用 new 运算符，脚本如下所示。</code></p><p></p><p><code lang=\"php\"><code lang=\"php\">#[SortType(sortType: new Str(\"desc\"))] \n#[SortType(sortType: new Str(\"shuffle\"))]  \n#[SortType(sortType: new Str(\"asc\"))]              \nclass QSort\n{\n}\n</code></code></p><p></p><p><code lang=\"php\">在内置服务器中运行脚本，输出与之前相同，如图3所示。</code></p><p></p><p><code lang=\"php\">图 3 在注解参数中使用new的结果</code></p><p></p><h3><code lang=\"php\">在某些上下文中不允许使用 new 运算符</code></h3><p></p><p><code lang=\"php\">前面我们提到了一些不支持 new 运算符的上下文，即静态和非静态类属性的初始化设置，以及类常量的初始化设置。 此外，在以下的上下文中也不支持 new 运算符：</code></p><p></p><p><code lang=\"php\">非字符串动态类名常量表达式中的参数解包（Argument unpacking）常量表达式中的匿名类不受支持的常量表达式下面脚本中所注释掉的语句如果运行都会生成错误：</code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><!--?php\n $list = [4, 6];\nfunction fn1(\n    $a1 = new ('some_dynamic_class')(),\n   //  $a2 = new (some_dynamic_class)(), // 非字符串动态类名 -  不能在常量表达式中使用动态类名\n   //  $b = new  class {}, // 不能在常量表达式中使用匿名类\n   // $c = new C(...$list), // 不支持在常量表达式中解包参数\n   //   $d = new D($x), // 常量表达式包含无效操作\n) {}\n</code--></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\">新的 match 表达式</code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\">PHP 8引入了一个新的 match 表达式作为控制流结构，它使用身份比较（identity comparison）将给定的主题表达式与一个或多个可选分支相匹配，并返回匹配分支的结果值。match 表达式类似于 switch 语句，但区别如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">match 表达式使用身份运算符（ === ）进行比较，而switch 则使用相等运算符（ == ）。match 表达式返回一个值，而switch 不返回。返回值可以赋值给某个变量。在匹配其中某个分支后，match 表达式会自动终止match 。switch 的终止则需要使用 break; 声明。match 表达式不会像switch那样在没有声明break;  的情况下失败。match 表达式支持在同一个分支中用逗号 （，）分隔多个条件，而switch 不支持。match 表达式必须是穷尽的，这意味着它必须要处理主题表达式的所有值。接下来，我们通过一些示例来演示 match 表达式的使用。</code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\">输出返回值</code></code></h3><p></p><p><code lang=\"php\"><code lang=\"php\">先从一个简单的示例开始，下面脚本中的match 表达式将作为主题表达式的整数 1 与包含默认模式的多个条件表达式进行匹配。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\necho match (1) {\n    0 =--> 'A',\n    1 =&gt; 'B',\n    2 =&gt; 'C',\n    default =&gt; 'Default',\n};\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">在内置引擎中运行脚本，通过使用url <a href=\"http://localhost:8000/scripts/match.php.\">http://localhost:8000/scripts/match.php</a>\"在浏览器中调用脚本，输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">B</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">在下面的脚本中，主题表达式与任何非默认条件表达式都不匹配。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\necho match (3) {\n    0 =--> 'A',\n    1 =&gt; 'B',\n    2 =&gt; 'C',\n    default =&gt; 'Default',\n};\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">Default</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">default 条件不能与脚本中所示的其他条件组合：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\necho match (3) {\n    0 =--> 'A',\n    1 =&gt; 'B',\n    2, default =&gt; 'C',\n     \n};\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">当脚本运行时，它会生成如下错误：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">Parse error: syntax error, unexpected token \"default\", expecting \"=&gt;\"\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">一个相对复杂的示例，下面的脚本有一个通过 \\Ds\\Vector 类初始化的变量。主题表达式以数组表示法访问 vector 变量。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$vector = new \\Ds\\Vector();\n$vector--->push('a');\n$vector-&gt;push('b', 'c');\n$vector[] = 'd';\n \necho match ($vector[1]) {\n  'a' =&gt; \"a\",\n  'b' =&gt; \"b\",\n};\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">使用url <a href=\"http://localhost:8000/scripts/match.php\">http://localhost:8000/scripts/match.php</a>\" 在浏览器中调用脚本。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">结果是：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">b</code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\">将返回值赋给变量</code></code></h3><p></p><p><code lang=\"php\"><code lang=\"php\">返回值也可以赋值给某个变量，匹配条件可以是任意表达式。在下面的脚本中， match 表达式将布尔值 true 作为主题表达式与调用其他内置字符串函数的条件表达式进行匹配。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$text = 'A B C D';\n$result = match (true) {\n    str_word_count($text)==3 || str_word_count($text)==2 =--> '2 or 3',\n    str_word_count($text)==4 || str_word_count($text)==5 =&gt; '4 or 5',\n    \n};\nvar_dump($result);\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出是：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">string(6) \"4 or 5\"\n</code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\">没有强制类型转换</code></code></h3><p></p><p><code lang=\"php\"><code lang=\"php\">与 switch 语句进行松散比较不同， match 表达式进行严格比较，并且不进行类型强制转换。首先，看一个与 switch 语句进行松散比较的示例。下面的脚本会匹配第一个条件并输出值 a 。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$var = 0;\nswitch((string)$var) \n{\n    case  0  : echo 'a'; break; // 这将测试NULL或空字符串   \n    default : echo 'b'; break; // 其他的，包括零\n}\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">相比之下，下面脚本中的match 进行了严格比较，并匹配默认条件输出 Default 。</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$var = 0;\n \necho match ((string)$var) {\n    0 =--> 'a',\n    default =&gt; 'Default',\n};\n</code></code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\">即使是 NULL 值也可使用身份比较进行匹配</code></code></h3><p></p><p><code lang=\"php\"><code lang=\"php\">match 表达式使用身份运算符（ === ）进行身份比较，这意味着即使是 NULL 值也会匹配。由于 Ds\\Vector::push() 方法返回 NULL ，所以，下面的脚本中的match 表达式实际上与Ds\\Vector::push() 方法所返回的NULL 值相匹配。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$vector = new \\Ds\\Vector();\n$vector--->push('a'); \n \nmatch ($vector-&gt;push('b')) {\n  $vector-&gt;push('d') =&gt; $vector-&gt;push('b'),\n  $vector-&gt;pop() =&gt; $vector-&gt;pop(),\n};\nprint_r($vector);\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">匹配的是第一个条件，输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">Ds\\Vector Object ( [0] =&gt; a [1] =&gt; b [2] =&gt; d [3] =&gt; b )\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">身份比较（ === ）可以应用于任意值，即使没有返回值也是如此。  match 返回的  NULL 值可以赋值给某个变量。 下面的脚本匹配 NULL 值，并且匹配的是第一个条件。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$vector = new \\Ds\\Vector();\n$vector--->push('a'); \n \n$vector = match ($vector-&gt;push('b')) {\n  $vector-&gt;push('c') =&gt; $vector-&gt;push('b'),\n  $vector-&gt;pop() =&gt; $vector-&gt;pop(),\n};\nvar_dump($vector);\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">使用url <a href=\"http://localhost:8000/scripts/sample.php\">http://localhost:8000/scripts/sample.php</a>\" 调用脚本，输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">NULL</code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\">可以用逗号分隔多个条件</code></code></h3><p></p><p><code lang=\"php\"><code lang=\"php\">多个条件表达式可以用逗号分隔。首先看一个具有单个条件的示例，脚本如下所示。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$vector = new \\Ds\\Vector();\n$vector--->push('a'); \n \nmatch ('push') {\n  'push' =&gt; $vector-&gt;push('b'),\n  'pop' =&gt; $vector-&gt;pop(),\n};\nprint_r($vector);\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出是：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">Ds\\Vector Object ( [0] =&gt; a [1] =&gt; b )\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">以相同的示例为例，添加多个用逗号分隔的条件。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$vector = new \\Ds\\Vector();\n$vector--->push('a'); \n \nmatch ('puush') {\n  'push','puush' =&gt; $vector-&gt;push('b') \n   \n};\nprint_r($vector);\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">第一个条件表达式列表中所列出的第二个可选选项将与拼写错误的“puush”相匹配，输出为：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">Ds\\Vector Object ( [0] =&gt; a [1] =&gt; b )\n</code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\">穷举</code></code></h3><p></p><p><code lang=\"php\"><code lang=\"php\">match 表达式必须是可穷举的。在下面的脚本中，主题表达式与任何条件都不匹配。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\n$vector = new \\Ds\\Vector();\n$vector--->push('a'); \n \nmatch ('set') {\n  'push' =&gt; $vector-&gt;push('b'),\n  'pop' =&gt; $vector-&gt;pop(),\n};\nprint_r($vector);\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">结果是输出一个错误：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">Uncaught UnhandledMatchError: Unhandled match case 'set'\n</code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\">instanceof 运算符支持任意表达式</code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\">另一个新特性是 instanceof 运算符可接受任意表达式。仅有的两个要求是：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">表达式必须用圆括号括起来，并且表达式的计算结果必须为字符串。为了演示示新的instanceof 运算符，请创建一个PHP脚本sample.php。声明三个不同类型的集合变量，类型如 \\Ds\\Vector 和 \\Ds\\Set 。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">$collection_a = new \\Ds\\Vector([1, 2, 3]);\n$collection_b = new \\Ds\\Vector();\n$collection_c = new \\Ds\\Set();\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">添加一个返回类的任意函数，如返回字符串形式的 \\Ds\\Vector::class 。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">function getSomeClass(): string\n{\n    return \\Ds\\Vector::class;\n}\n</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">输出对不同集合变量使用 instanceof 运算符后的结果。instanceof 运算符接受一个表达式，该表达式在每次调用中会被计算为字符串。sample.php的脚本如下所示。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$collection_a = new \\Ds\\Vector([1, 2, 3]);\n$collection_b = new \\Ds\\Vector();\n$collection_c = new \\Ds\\Set();\nfunction getSomeClass(): string\n{\n    return \\Ds\\Vector::class;\n}\nvar_dump($collection_a instanceof ('\\Ds'.'\\Vector'));\nvar_dump($collection_a instanceof ('\\Ds'.'\\Hashtable'));\nvar_dump($collection_b instanceof ('\\Ds'.'\\Vector'));\nvar_dump($collection_b instanceof ('\\Ds'.'\\Set'));\nvar_dump($collection_c instanceof ('\\Ds'.'\\Set'));\nvar_dump(new \\Ds\\Vector instanceof (getSomeClass()));\nvar_dump($collection_a instanceof ('\\Ds'.'\\Set'));\n</code--></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">该脚本在PHP 8中能正常运行，并生成如下的输出：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">bool(true) \nbool(false)\nbool(true) \nbool(false) \nbool(true) \nbool(true) \nbool(false) \n</code></code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\">JIT（Just-In-Time）编译器</code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\">PHP 8引入了<a href=\"https://web.archive.org/web/20020901165532/http://foldoc.doc.ic.ac.uk/foldoc/foldoc.cgi?JIT\">即时（Just-in-time ，JIT）编译</a>\"，其目的如下：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">提高性能和可用性。使PHP适用于非Web的CPU密集型用例，在这些用例中可以获得显著的性能优势。创造使用PHP而不是C开发内置函数的潜力。PHP可能是一个更好的选择，因为它没有C语言那样的内存管理和溢出问题。引入了两个JIT编译引擎：跟踪JIT（Tracing JIT）和函数JIT（Function JIT）。函数JIT只优化单个函数范围内的代码，而跟踪JIT则能优化整个堆栈跟踪。在综合基准测试中，跟踪JIT可以提高3倍的性能，在长时间运行的查询上可提高1.5到2倍。在Mandelbrot基准测试中，跟踪JIT可以将性能提高4倍以上。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">在本文中，我们介绍了一些与PHP 8语法最相关的改进，包括注解（attributes）、 new 运算符、 match 表达式等。在下一篇文章中，我们将探讨类和构造函数的改进。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">作者介绍：</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">Deepak Vohra是Oracle认证的Java程序员和Oracle认证的Web Component开发人员。Deepak已经出版了20多本书。</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">原文链接：</code></code></p><p><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.com/articles/php8-attributes-match-new-operator/\">https://www.infoq.com/articles/php8-attributes-match-new-operator/</a>\"</code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\">相关阅读：</code></code></p><p><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.cn/article/YEImBIBZHJTT9BOXPvLJ\">为什么在 20 多年后，我仍然爱着 PHP 和 JavaScript</a>\"</code></code></p><p><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.cn/article/jIFtq9JcJd1w36DKg6Wa\">JetBrains 官宣：PHP 基金会成立</a>\"</code></code></p><p></p><p></p>",
    "publish_time": "2022-11-27 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "马斯克要求推特程序员写周报，具体到代码行数；刘强东称将末位淘汰部分京东高管；闰秒终于要被取消了！｜ Q资讯",
    "url": "https://www.infoq.cn/article/4rYaFlR88OC8PVbZiiEZ",
    "summary": "<p></p><blockquote>马斯克要求推特程序员写周报，具体到代码行数；刘强东称将末位淘汰部分京东高管；罗永浩AR公司完成融资，估值2 亿美元；游戏工委报告：未成年人沉迷游戏问题已经基本解决；谷歌酝酿减员万人，美股科技巨头“全军覆没”；谷歌神秘项目曝光：教AI完全自主写代码、改Bug；Ant Design 5.0正式发布；闰秒终于要被取消了……</blockquote><p></p><p>&nbsp;</p><p></p><h2>科技公司</h2><p></p><p>&nbsp;</p><p></p><h4>马斯克要求推特程序员写周报，具体到代码行数</h4><p></p><p>&nbsp;</p><p>11月24日，据 Business Insider 报道，推特内部邮件显示，该公司要求技术类员工必须每周发邮件给CEO埃隆·马斯克（Elon Musk），介绍自己本周的所有工作，以此实现“快速创新”。</p><p>&nbsp;</p><p>当地时间周一晚，马斯克及其领导团队使用的邮箱向推特程序员们发送邮件称，推特将采用一种新的方法来跟踪他们的工作进度。从本周开始，所有从事编程或技术工作的推特员工都要每周提交一份工作报告，介绍他们做过的工作、希望完成的工作以及编写的代码行数，还要包含“代码样本/本周编写的代码的Phabricator链接。”Phabricator是一套基于Web的软件开发协作工具，包括代码审查工具Differential，资源库浏览器Diffusion，变更监测工具Herald，Bug跟踪工具Maniphest等。对此，马斯克回复称：“也许了解工作进度并非不合理”。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/97/9740e08a825188aeef78bc466bb4a24b.png\" /></p><p></p><p>&nbsp;</p><p>上周，马斯克告诉员工，他想雇佣更多“擅长编写软件”的人。但从实际情况来看，马斯克的裁员仍在继续。感恩节前一天，约有50名推特工程师收到了解雇通知，因为他们在最近的Code review中表现不尽人意（code is not satisfactory），而且还有一些人收到了业绩警告（performance warning）。Gergely Orosz表示自己和这些员工的直系领导沟通后，认为警告是误触发的PIP，因为直系领导对此表示并不知情。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/eb/eb489925c373969a8da1493dd43b53f3.png\" /></p><p></p><p>&nbsp;</p><p>此次裁掉的还有<a href=\"https://twitter.com/nabokov7\">Ikuhiro Ihara</a>\"，一位备受尊敬的高级软件工程师，在他的推动下，推特将推文扩展到 280 个<a href=\"https://blog.twitter.com/en_us/topics/product/2017/Giving-you-more-characters-to-express-yourself\">字符</a>\"。Ihara声称他虽然是以“code is not satisfactory”为由被解雇，但推特实际上并没有进行任何代码审核。这其中还包括在<a href=\"https://mp.weixin.qq.com/s/96kJSH6INo_vI_zGUPWC7w\">解雇后被召回</a>\"，然后写完文档后再被开除的极端例子。如果这些裁员都是真的，那么推特绝对是所有科技公司中最“有毒”的工作场所。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/a8/a8265563c5abab249d96ec80b06e51c4.png\" /></p><p></p><p>&nbsp;</p><p>&nbsp;</p><p></p><h4>刘强东称将末位淘汰部分京东高管</h4><p></p><p>&nbsp;</p><p>据晚点报道，11月20日，在京东经营管理培训会上，身处香港的京东集团董事局主席刘强东在会议中视频接入，刘强东在高管会议上宣布，今年年底将对10%以上的高管进行末位淘汰。刘强东还批评了零售业务高管，称自己在听战略会时，“高管们谈花里胡哨的故事太多，但谈成本、效率、体验太少，如果对如此核心的战略都把握不够，那将很难带领团队长远走下去。”</p><p>&nbsp;</p><p>另外，11月22日，刘强东发布致京东全体兄弟们的一封信，提出要以高管降薪等多种方式提升员工待遇。信中提到，为了提高基层员工福利待遇，同时尽量减轻公司压力，集团决定自2023年1月1日起，京东集团副总监以上以及相对应的P/T序列以上全部高级管理人员，现金薪酬全部降低10%-20%不等，职位越高降得越多。除此之外，刘强东表示未来公司将投入数百亿为全体德邦员工在内的所有物流、客服等基层员工设立“住房保障金”，为基层员工提供购房无息贷款，同时“员工子女救助基金”的规模也会得到补充。</p><p>&nbsp;</p><p></p><h4>罗永浩AR公司完成融资，估值2 亿美元</h4><p></p><p>&nbsp;</p><p>罗永浩 AR 创业公司细红线科技宣布完成约 5000 万美元（约合人民币 3.58 亿元）天使轮融资，投后估值约为 2 亿美元（约合人民币 14 亿元）。本轮融资由美团龙珠领投，蓝驰创投、联想创投、经纬创投、大疆创新、ATM Capital 等投资机构，以及黎万强、吴泳铭等科技界知名人士跟投。据公开资料显示，细红线科技成立于 2022 年 6 月，致力于打造智能手机之后的下一代个人计算设备平台。从 6 月创立之初，细红线科技就开启了招聘计划，主要招聘对象为 AR 工程师和产品经理。近期该公司招聘了大量产品经理和程序员，其中一部分来自小米和黑鲨。</p><p>&nbsp;</p><p></p><h4>游戏工委报告：未成年人的沉迷游戏问题已经基本解决</h4><p></p><p>&nbsp;</p><p>据36氪消息，近日，中国音数协游戏工委、中国游戏产业研究院联合伽马数据共同发布了《2022中国游戏产业未成年人保护进展报告》。报告研究显示，超七成未成年人每周游戏时长在3小时以内，未成年人游戏沉迷问题已得到基本解决。2022年出现未成年人私自充值现象的家庭占比降至15.43%，较2021年有了明显下降。现存未成年游戏用户的家长中，35%以上允许孩子用自己身份证注册账号。</p><p>&nbsp;</p><p></p><h4>谷歌酝酿减员万人，美股科技巨头“全军覆没”</h4><p></p><p>&nbsp;</p><p>综合多家媒体报道，谷歌母公司Alphabet正计划裁掉约1万名“表现不佳”的员工。报道称，Alphabet最新的绩效管理系统可以帮助公司筛选员工，可用来当作削减员工福利、薪酬和股票分红的依据。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/82/82610de92b2b8f30dab1028eee9348f9.png\" /></p><p></p><p>&nbsp;</p><p>更多信息：</p><p><a href=\"https://mp.weixin.qq.com/s/zvpGkVZ2x75p-392xi2Phg\">谷歌计划裁员上万人：利用刚上线半年的新绩效系统解雇6%“排名垫底”员工</a>\"</p><p>&nbsp;</p><p></p><h2>IT业界</h2><p></p><p>&nbsp;</p><p></p><h4>谷歌神秘项目曝光：教AI完全自主写代码、改Bug</h4><p></p><p>&nbsp;</p><p>据外媒 Business Insider 11 月 23 日报道，谷歌正在开展一个秘密项目，该项目在谷歌内部的开发代号为“Pitchfork”。内部文件显示，Pitchfork 能够通过机器学习技术训练智能体编写代码、修复 Bug，以及代码更新。</p><p>&nbsp;</p><p>知情人士称，该项目最初成立于谷歌母公司Alphabet's的“X”研究部门，如今已走进谷歌实验室（Google Labs）。目前，Pitchfork隶属于“谷歌实验室”旗下的一个新部门“AI Developer Assistance”（人工智能开发者支持团队），由奥利维亚·哈塔尔斯基领导，后者曾负责谷歌眼镜和其他一些“登月项目”。</p><p>&nbsp;</p><p>谷歌发言人称，Pitchfork 的最初目标是构建一款工具，可以将谷歌的 Python 编程语言代码库更新到较新的版本。但随着时间的推移，该项目的目标转向了一个通用系统：可以减少人类开发者编写和更新代码的需要，同时又能保持代码质量。</p><p>&nbsp;</p><p></p><h4>Ant Design 5.0正式发布</h4><p></p><p>&nbsp;</p><p>Ant Design 5.0 已在上周正式发布。Ant Design 开发团队表示，同上一个大版本发布一样，他们将会把 v4 从主分支切换至 4.x-stable 分支进入维护状态。v4 将会继续维护 1 年时间，仍然会对 Bug 发布 Patch，但是此后不再接收新的 Feature Request。截止日期为 2023 年年底。原 v4 官网迁移至 <a href=\"https://4x.ant.design/\">https://4x.ant.design/</a>\"。</p><p>&nbsp;</p><p>了解更多：<a href=\"https://ant.design/changelog-cn\">https://ant.design/changelog-cn</a>\"</p><p>&nbsp;</p><p></p><h4>闰秒终于要被取消了！</h4><p></p><p>&nbsp;</p><p>11月20日消息，负责协调世界时的国际计量局（BIPM）表示，科学家和政府代表18日在法国举行的一次会议上投票决定到2035年取消闰秒。BIPM时间部门负责人帕特里齐亚·塔维拉表示，这项“历史性决定”将允许“秒数连续流动，而不会出现目前由不规则闰秒造成的不连续性。”</p><p>&nbsp;</p><p>更多阅读：</p><p><a href=\"https://mp.weixin.qq.com/s/GnD0EnAjmlPvyQrscWFJlQ\">让大厂抓狂的“额外一秒”：谷歌、微软、Meta 和亚马逊纷纷提议放弃</a>\"</p><p>&nbsp;</p><p></p><h4>Kotlin发布调查报告：近一半用户不满IDE性能</h4><p></p><p>&nbsp;</p><p>11月18日， Kotlin 团队公布了 首次 Kotlin 开发者调查结果。Kotlin 是 IDE 厂商 JetBrains 公司开发的编程语言，业内曾一度热议其未来是否会取代 Java。为了找出影响 Kotlin 用户满意度最大的痛点，今年Kotlin 团队开始组织开发者调查，根据报告显示，目前 Kotlin 的用户总体满意度为 86%，但 Kotlin Build Tools 的客户满意度为 62%，目前 Kotlin 用户的主要痛点是 IDE 和构建性能。</p><p>&nbsp;</p><p>了解更多：<a href=\"https://blog.jetbrains.com/kotlin/2022/11/how-kotlin-is-going-to-fix-your-pains-in-2023/\">https://blog.jetbrains.com/kotlin/2022/11/how-kotlin-is-going-to-fix-your-pains-in-2023/</a>\"</p>",
    "publish_time": "2022-11-27 12:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "“后Hadoop时代”，大数据从业者如何应对新技术趋势带来的挑战?",
    "url": "https://www.infoq.cn/article/Y8ekYxIycZ5GCG4lymcK",
    "summary": "<p>作者 | 蔡芳芳</p><p>采访嘉宾 | 刘京娟、贾扬清、王峰</p><p>&nbsp;</p><p>作为开源大数据项目的发端，Hadoop兴起至今已经超过十五年。在过去这十数年里，开源大数据领域飞速发展，我们见证了多元化技术的兴起和变迁。</p><p>&nbsp;</p><p>为了从代码托管平台汇聚的海量数据里，通过数据处理和可视化的方式，深刻洞察开源大数据技术的过去、现在和未来，并为企业和开发者在开源大数据技术领域的应用、学习、选型和技术研发等方面提供有益参考，开放原子开源基金会、X-Lab 开放实验室、阿里巴巴开源委员会共同发起了<a href=\"https://www.infoq.cn/minibook/bKbCdRfqi0X9AQkQBPGl\">「2022 开源大数据热力报告」</a>\"项目。</p><p>&nbsp;</p><p>报告从Hadoop发展的第10年，即2015年起，收集相关公开数据进行关联分析，研究开源大数据进入新阶段后的技术趋势，以及开源社区的运作模式对技术走向的助推作用。</p><p>&nbsp;</p><p>经过对最活跃的 102 个开源大数据项目进行研究，报告发现：每隔 40 个月，开源项目热力值就会翻一倍，技术完成一轮更新迭代。在过去 8 年里，共发生了 5 次较大规模的技术热力跃迁，多元化、一体化、云原生成为当前开源大数据发展趋势的最显著特征。</p><p>&nbsp;</p><p>开放原子开源基金会副秘书长刘京娟表示，报告希望重点对如下人群有所帮助：</p><p>（1）从事大数据技术研发的企业和开发者。他们可以通过报告，了解大数据技术的发展趋势，从而指引学习方向并提升自身的技能，从技术活跃度的角度为应用开发的技术选型提供一定的参考。</p><p>（2）有志于为开源项目贡献代码的开发者。开源大数据细分领域众多、百花齐放，但也存在一些相对薄弱的环节，比如数据安全和数据管理等，开发者可以从多个细分领域切入，帮助这些领域更好地发展。</p><p>（3）开源大数据项目的运营者或者维护者。他们能够从优秀项目的热力发展趋势中，获取经验和规律，从而用更成熟的方式运营开源项目。</p><p>&nbsp;</p><p>对于大数据从业者们来说，开源大数据项目热力迁徙背后的技术发展逻辑是怎样的？大家应该如何应对新技术趋势带来的挑战？针对这些问题，近日InfoQ与阿里巴巴集团副总裁、阿里巴巴开源委员会主席、阿里云计算平台事业部负责人贾扬清，Apache Flink 中文社区发起人、阿里巴巴开源大数据平台负责人王峰（花名莫问）聊了聊。</p><p></p><h2>用户需求多样化推动技术多元化</h2><p></p><p>&nbsp;</p><p>以Hadoop为核心的开源大数据体系，从2015年开始转变为多元化技术并行发展。</p><p>&nbsp;</p><p>一方面，原有Hadoop体系的产品迭代趋于稳定。部分Hadoop生态项目（如HDFS）成为其他新兴技术的基础依赖，一些常见的开源大数据组件组合，比如Flink+Kafka、Spark+HDFS等，经过开源生态市场的检验，比较成熟也容易上手，已经成为相对固定的标准化选择。</p><p>&nbsp;</p><p>另一方面，开发者的热情分别涌向「搜索与分析」、「流处理」、「数据可视化」、「交互式分析」、「DataOps」、「数据湖」六大技术热点领域，每个热点领域集中解决某个特定场景问题。</p><p>&nbsp;</p><p>报告呈现出的热点领域热力跃迁（热力值大幅度跳变）情况与此相符：「数据可视化」在2016和2021年经历了两次热力跃迁，「搜索与分析」和「流处理」 在2019年热力跃迁， 「交互式分析」和 「DataOps」从2018年和2021年经历了两次热力跃迁、 「数据湖」在2020年热力跃迁。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/66/6618ae72563ebc2de0e74e39b00063a0.png\" /></p><p></p><p>这也呼应了大数据应用场景和规模变化的趋势：从上层数据可视化应用普及，到数据处理技术升级，再到数据存储和管理的结构性演变，最终，数据基础设施能力的提升又反过来推动上层应用技术革新。</p><p>&nbsp;</p><p>贾扬清认为，热力跃迁背后体现了技术发展是一个螺旋上升的过程，用户侧需求推进技术往前一步之后，就需要系统侧再往前一步，以实现更好的可扩展性、更低的成本和更高的灵活性；当系统侧达到了一个能够承载更大规模数据计算处理分析的状态，大家又会开始寻求是不是可以把用户侧或业务侧的数据分析、可视化等做得更好。比如，流行的开源大数据可视化工具Apache Superset，其背后的商业公司Preset最近就在BI方面做新的探索。</p><p>&nbsp;</p><p>相比已经趋于稳定的原Hadoop体系，新场景之下，如数据治理分析、流式计算+OLAP、数据湖等，开源大数据组件仍然在不断推陈出新，未来存在比较多变数。</p><p>&nbsp;</p><p>随着这些后起的大数据开源组件越来越庞杂，开发者们驾驭开源数据平台的难度也与日俱增。这其实给想要利用开源组件构建企业级大数据平台的企业带来了相当大的挑战。</p><p>&nbsp;</p><p>首先，大部分业务场景都需要多个大数据组件互相配合使用，这就要求技术团队同时掌握很多不同的大数据组件，并且要能融会贯通、知道如何将这些组件更好地组合到一起。但大部分中小公司或传统企业并没有足够的大数据基础人才。因此企业可能需要一个比较专业的大数据团队，为他们提供设计、咨询以及指导，让他们能够把开源大数据的组件串联在一起形成一整套解决方案。</p><p>&nbsp;</p><p>其次，当业务规模增大，企业对大数据平台的稳定性、安全性和高可用能力的要求也会随之提高，必然会增加构建大数据平台的复杂性。比如系统出现问题时，到底问题在哪里，怎么去诊断、分析、报警，做到实时可观测，这些配套能力都是开源大数据组件本身不具备的。这需要在开源生态上做出配套的工具或产品，帮助企业更好的发现问题、定位问题和解决问题。</p><p>&nbsp;</p><p>以上挑战，在贾扬清和王峰看来，都可以通过云上标准化产品在一定程度上解决掉。但从另一个角度来看，云本身其实也给大数据技术栈带来了一些新的挑战。</p><p>&nbsp;</p><p></p><h2>云原生带来的变化和挑战</h2><p></p><p>&nbsp;</p><p>报告显示，2015年后出现的新项目，无一例外均在云原生方向进行了积极的技术布局。Plusar、 DolphinScheduler、JuiceFS、Celeborn、Arctic等诞生于云原生时代的开源项目如雨后春笋般破土成长。这些新项目在2022年的热力值占比已经达到51%，其中，数据集成、数据存储、数据开发与管理等领域都发生了非常大的项目更迭，新项目热力值占比已经超过了80%。从2020年开始， Spark、 Kafka、Flink等主流项目也陆续正式支持 Kubernetes。</p><p>&nbsp;</p><p>云原生趋势下，开源大数据技术栈正处于重构之中。其中数据集成领域的重构相比其他细分领域走得更快一些。</p><p>&nbsp;</p><p>随着云端多样化数据收集需求的爆发，以及下游数据分析逻辑的变化，数据集成从“劳动密集型”ETL工具演进到灵活高效易用的“数据加工流水线”。传统数据集成工具Flume、 Camel处于平稳维护状态， Sqoop已于2021年从Apache基金会退役。与云原生结合更紧密的Airbyte、Flink CDC、 SeaTunnel、 InLong等项目飞速发展。</p><p>&nbsp;</p><p>在报告的热力趋势中可以看到，云原生数据集成在2018年超越了传统数据集成，从2019年开始，这一演进历程加速，热力值逐年翻倍。不少新孵化的项目热力值年均复合增长率超过100%，增长势头强劲。</p><p>&nbsp;</p><p>过去几年，数据源和数据存储逐步迁移到云端，更多元化的计算负载也运行到了云端。云底座实际上改变了开源大数据的很多前提，作为这场变革的亲历者，王峰感触颇深。</p><p>&nbsp;</p><p>十多年前，王峰就参与了基于Hadoop做大数据开发的工作，当时他还是比较初级的工程师，大部分工作还基于本地机器，需要考虑的问题包括选择什么机型、多大磁盘、磁盘大还是内存大等。</p><p>&nbsp;</p><p>如今，大数据的底座变成了云上的虚拟机、容器、对象存储、云存储，所有开源项目从一开始就要考虑弹性架构、要考虑如何具备很好的可观测性、要考虑怎么跟Kubernetes等云原生生态天然对接，等等，这些问题已经存在于大家的潜意识里，改变了很多开源项目在初始阶段的预期。</p><p>&nbsp;</p><p>同时在云上运行之后，数据架构也会发生变化。比如计算与存储分离已经成为大数据平台的标准架构，是现在大家默认一定要考虑的问题，因此不管是什么大数据组件（Flink、Hive、Presto等等），在做数据Shuffle的时候都要考虑到不能再依赖本机、不能假设会有本地磁盘，因为在云上机器是必定会迁移的。这就需要一个通用的shuffle服务来协助完成这项工作，把云上资源模型变化考虑进去做自适应地调度。前不久阿里捐献给Apache基金会的开源项目Celeborn，做的就是帮助计算引擎提升数据shuffle性能的工作。</p><p>&nbsp;</p><p>技术层面，云给原有的开源大数据体系带来的挑战不止于此。比如调度基础，以前大家都默认在Hadoop上做资源管理和调度，上云之后大家则都拥抱Kubernetes生态，基于Kubernetes来做编排和调度。但Kubernetes作为在线调度服务，调度大规模数据计算任务存在瓶颈，阿里内部本身对Kubernetes做了非常多改进。</p><p>&nbsp;</p><p>另外，比如云存储虽然优势多多，但也存在传输带宽、数据locality方面的缺陷。一些后起的开源项目如JuiceFS、Alluxio等，就是为了解决云存储加速的问题而生，阿里云EMR上的大数据存储加速服务JindoData也在做这方面的工作。王峰表示，开源大数据体系还在不断进化，仍需要走一段路，才能真正与云原生彻底结合。</p><p>&nbsp;</p><p></p><h2>大数据从业者如何面向未来发展？</h2><p></p><p>&nbsp;</p><p>作为技术创新的实验场，云原生带来了更灵活的资源弹性和更低的存储、运维成本，让很多企业可以更大胆地在云上做一些尝试，提升了大家试错、试新的意愿，自然也更有利于创新技术或软件的成功。贾扬清观察到，海外有很多新软件或新引擎会走“先吸引用户、然后把用户转化为客户”的路。在他看来，这将来在国内可能也会成为一个趋势，因为云确实提供了一个很好的资源以及软件分发环境。</p><p>&nbsp;</p><p>不过云只是给了大家一把很好的锤子，如果一个人能力不强，用的时候也可能会砸到自己的脚。比如，由于用户在云上获得资源更加容易，可能就会比较随意地进行数据存储和计算，进而造成浪费。因此从业务角度，云服务商与用户其实是一体的，云服务商在大规模开源数据体系之上，需要根据企业的需求做更多数据治理方面的工作，帮助用户用好云这把锤子，避免资源浪费。贾扬清表示，如何更有效地使用云平台、云资源已经成为企业越来越关注的需求，现在主要是企业级软件在做这方面的工作，将来可能会有更多开源工具出现。</p><p>&nbsp;</p><p>畅享未来的数据工程趋势，贾扬清认为有三个方向是大数据从业者可以重点关注的。首先是云化，即用云来解决系统架构的问题，涵盖了离线实时一体化、大数据AI一体化、流批一体化、湖仓一体化四个层面。现在不管是开源项目还是闭源产品其实都在朝着更加一体化的方向发展，Flink社区新的子项目TableStore也是在这个方向上做的一个探索，追根究底是为了在一定程度上降低大数据技术栈的复杂度，未来计算引擎可能也会更多地跟数据治理、数据编排工具结合成为一体化的数据解决方案。</p><p>&nbsp;</p><p>其次是上层数据应用会变得更加简单，从长远来看，对于最终用户，所有的数据都可以使用通用的SQL方式进行分析。最后，将来会有更多的生态发展起来，无论是阿里云的Flink、EMR还是海外的Databricks、Snowflake、Bigquery都还只是工具平台，在这些数据平台之上需要有更多类似于Saleforce的企业来做出更丰富的垂直解决方案，最终形成更加繁荣的数据生态，当然前提是数据平台先做好标准化。</p><p>&nbsp;</p><p>王峰同样很看好数据生态未来的发展，尤其对于开源大数据来说，生态更加关键。现在欧美很多数据领域的公司，虽然各有特色，但相互之间也能形成协同，这样大家就会处于一个良性的竞争状态。王峰认为，这有助于推进各厂商的产品走向标准化，能够给用户和客户带来很多好处。从整个应用市场的角度来说，形成标准化之后，各方能够比较低成本地去接入这个数据工程生态，反过来可以一起把整个市场蛋糕做大。</p><p>&nbsp;</p><p>身处快速发展的数据工程领域，大数据从业者如何面向未来发展？将来岗位角色、职责是否会发生变化？</p><p>&nbsp;</p><p>贾扬清认为，系统工程师、数据工程师、数据科学家这些角色未来会继续存在。但云已经解决了很多系统问题，所以越来越多工程师角色会开始往上层业务走。偏系统搭建的底层工作，即系统工程师角色，可能会更多聚集在提供标准化服务的云数据服务商、数据引擎服务商等，其他企业则会更加关注业务本身，把人力更多投入在偏数据科学以及上层业务里，不再需要那么多系统工程师。这是社会分工精细化的必然结果。</p><p>&nbsp;</p><p>对于数据科学家、数据工程师，他们的职责会更多地偏重于利用数据实现业务价值，包括根据业务需求做数据建模、数据治理等工作，不用再像以前一样去解底层系统和运维等问题，因为这些问题已经被系统工程师、被云解得很好了。</p>",
    "publish_time": "2022-11-27 16:40:07",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "存储和计算资源都节省30%，网易云音乐数据治理实践",
    "url": "https://www.infoq.cn/article/mBgvbc3bQWAbavwmBhXR",
    "summary": "<p></p><blockquote>本文来自于网易云音乐数仓团队，将分享他们近一年在数据治理上的实践，具体内容将从数据背景、治理思路，项目方案、治理实践、项目成果及未来展望几个方面展开。</blockquote><p></p><p></p><h2>数据背景</h2><p></p><p></p><h3>1.1 业务背景</h3><p></p><p></p><p>云音乐目前发布了 9 款独立的产品，国内产品有 6 款，除了云音乐本身之外、还有 5 款社交娱乐产品，分别为 look 直播、心遇、声波、音街和 mus；海外的社交娱乐产品有海外心遇 heatup，海外直播 kaya，游戏社交产品 ruffgo。</p><p></p><h3>1.2 数据现状</h3><p></p><p></p><p>规模上</p><p></p><p>承载了9款产品线上调度任务数有2万以上表数量在5W以上数据项目有12个目前数据服务的人群有，算法、分析师、数据产品、业务服务端、业务中台、客户端等，服务的对象在600以上数据成本方面，存储日费用合计有19w+，计算成本日费用在27w+</p><p></p><p>质量上</p><p></p><p>一方面任务稳定性较差，核心任务和报告不能稳定产出队列资源使用方面粒度比较粗、运维成本较大</p><p></p><p>效率方面</p><p></p><p>历史原因有大量任务仍然运行在hive引擎和spark2引擎上，这类任务耗资源、执行慢、小文件问题较多。下游引用比较随意，存在大量任务直接读取ods表的情况，特别是涉及到日志数据，小需求耗大资源。</p><p></p><p>环境方面</p><p></p><p>目前包含了国内环境和海外环境，国内环境目前有5个集群，海外环境当前包含了阿里云和aws。</p><p></p><p>总体来讲，针对目前的数据现状，治理面临的问题是 体量大、环境杂、缺规范、存在大量的资源浪费。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/2c/2ce326062f0790febf320a021d096a92.png\" /></p><p></p><h2>治理思路</h2><p></p><p></p><h3>2.1 找问题</h3><p></p><p></p><p>针对当前的数据现状，数据治理可以从哪些方面来找到治理方向呢？我们从技术视角对问题进行了分类。目前大数据环境下数据相关内容的分布情况如图中所示：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/61/61137f76209165c454fc7b31d7e71eef.png\" /></p><p></p><p>首先我们所有的数据都是存储在hadoop的hdfs文件系统之上的，在hdfs之上我们会建立一系列hive库和表用来管理数据；基于库表的管理，数据开发会在上面进行模型设计和数据分层设计；再往上则是数据处理方面的内容，包括任务调度、执行引擎等。</p><p></p><p>随着业务的快速发展，数仓的不断迭代， 每块内容可能或者必然存在着哪些问题呢？</p><p></p><p>先来看一下hdfs这个模块，此前的情况是hdfs文件缺乏有效的管理监控内容，无效文件无法探查和处理，这种无效文件越多必然影响hadoop集群的稳定性。库表方面，此前数据库扩展没有严格限制，滋生了非常多的数据库，迭代下来很多库的用途不详。建表方式也比较凌乱，有众多以用户名字命名的表，为之后的移交和管理工作带来了较大困扰。模型设计方面，早期设计比较粗暴混乱，众多任务直接依赖ods层数据，cdm层复用率较低，也存在大量闲置任务和表。引起资源的过度浪费，在数仓的改造重构过程中也制造了不少困难。任务调度执行引擎方面也有众多任务是跑在hive和spark2引擎上的，存储、计算、小文件问题都存在较大提升空间。</p><p></p><h3>2.2 问题解法</h3><p></p><p></p><p>针对以上存在的问题，如何来更有效的找到问题所在；</p><p></p><p>在hdfs文件上，我们把一直存在于集群中又脱离管控、不被使用却占用着资源的文件称之为“游离hdfs文件”。如何定位到这些文件，这里就需要获取到hdfs文件的元数据信息进行分析。库表的使用现状上，云音乐主集群的库有70多个，表的数量达到了5w以上，实际上常用的库表是非常有限的；库方面我们实际常用的库在20个左右，表方面我们也存在着大量的临时表和无效表，正规表的生命周期覆盖度也比较低。这方面我们需要用到库表元数据信息进行梳理和分析。模型设计的合理性衡量，我们引入了“三度”指标来衡量整个模型设计的健康情况，“三度”指标的计算需要用到数据血缘的信息。任务信息的执行调度情况，我们这里也缺乏一个宏观的视图进行分析。计算治理这块需要有一个比较全面的执行元信息进行分析和监控，更直观的看到可优化的空间。</p><p></p><p>以上这些问题的解决方案都指向了元数据信息，拥有了完整的元数据，我们才具备了放手去干的基础。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/69/69b5b423b3367cdf7688165f1cd6c167.png\" /></p><p></p><h2>项目方案</h2><p></p><p></p><h3>3.1 构建整个治理方案</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/a4/a4f80700a44d85a2ad86cd0590b019a2\" /></p><p></p><p>要解决问题找到问题，我们第一步就是获取完整的元数据内容</p><p></p><p>22年年初开始，从网易数帆大数据团队拿到了比较完备的元数据内容，涵盖了表粒度的元数据信息、任务粒度元数据信息、hdfs文件元数据信息等。</p><p></p><p>基于获取的元数据内容进行元数据建模。通过对元数据和云音乐内部数据的一系列的处理，产出了丰富的元数据cdm层的宽表和维表。通过模型产出的报告可实现从更多的视角观测数据现状和任务现状，可以分析的粒度有：整体平台数据，数据使用团队、数据业务域、个人、表。整个建模内容支撑了体系化的治理方案。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/8c/8ce2bae76e851746479a2805b86a2944\" /></p><p></p><h3>3.2 治理体系</h3><p></p><p></p><p>云音乐的整个数据治理体系中，我们遵循的原则是治理有依据、权责有归属、机制可持续、效果可回收、方法可沉淀。</p><p></p><p>治理的依据是元数据；权责有归属是定位谁的问题谁来治理；机制可持续是在治理的过程中沉淀出一套可推行的机制和原则；效果可回收是每一项都能拿到相应的结果；方法可沉淀整个治理方案可以进行横向复制推广。</p><p></p><p>治理的动作可归纳为建监控、定规范、搭工具、做治理。上面三个动作都是为了最后一个动作做铺垫的。在规范、监控、工具都做好了的前提下，治理的动作才能更有效的推进落地；做治理的过程中也可以逐步丰富规范内容，同时也可以进一步沉淀和落地监控及工具。</p><p></p><p>上面讲到的治理原则中，权责有归属和机制可持续是治理事项推进的两个基本点，所以在推进其他治理事项前要先落地这两项原则。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/aa/aa10e2045ed627c94a88a4b2e36428ae.png\" /></p><p></p><h2>治理实践</h2><p></p><p></p><h3>4.1 权责有归属</h3><p></p><p></p><p>所有要推进的治理项都是要人来治理的。所有的数据、任务、表都需要有责任人对其进行负责，云音乐的所有ods的dump任务是在云村平台上实现的，dump任务的配置都是由云村平台的开发统一配置的，表和任务的责任人都是归在配置任务的开发身上，n个业务几千个任务都是有平台开发来运维管控，表和任务的生命周期管理基本上是没有管制的。另外一些历史原因，存在大量的表归属在离职人员和项目账号下，这些表及相关的任务也是出于脱管的状态。针对这几种情况分别做了ods治理、离职人员表任务归属治理、项目账号表归属治理。</p><p></p><p>ods治理项，这里先是数仓按业务承接云村平台所有dump任务和表。第二是推动产品功能落地，用户按业务划分提交dump任务，数仓审批并负责相关的任务和表的管理。离职人员表任务归属，通过拉取离职人员组织关系、拉专项群对任务和表进行认领。项目账号表归属，通过定制表推荐归属规则，计算出表的推荐归属责任人。并实现表批量归属工具，实现批量表的归属。</p><p></p><h3>4.2 机制可持续</h3><p></p><p></p><p>在进行实际治理项目执行的过程中，每个治理事项所面临的问题、治理的内容和治理步骤都是差异且多元化的；治理项都面临着跨部门，多团队协作，在人力精力投入比较分散；在这些问题的背景下我们建立了统一的推进机制以及推进原则。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/ce/ce5cc0abeec6f264dc7fe3302144944b.png\" /></p><p></p><h3>4.3 hdfs 层面 - 游离 hdfs 文件治理</h3><p></p><p></p><p>在游离hdfs文件的治理，通过hdfs元数据和hive元数据的关联匹配逻辑和文件的访问情况，进一步计算出游离的hdfs文件；通过找到游离文件的生产方进一步确认文件是否还有存在的必要，并推进无效文件下线动作。现阶段通过这种方式梳理出来的游离文件有计算引擎遗留数据、未清理的临时目录数据、删表未删文件的数据，算法和工程任务的无效应用数据、实时任务无效归档数据等。通过对这些游离数据的清理，目前拿到的效果是非常显著的，释放了7p+以上的逻辑存储空间，清理掉了450w以上的文件和目录。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/6b/6bf4e3bea83432d2b2d1f9e5c1d2f86f.png\" /></p><p></p><h3>4.4 库表层面 - 数据库治理</h3><p></p><p></p><p>云音乐数据目前服务的角色比较广泛，除了数仓、分析师、算法、我们还服务了所有和技术挂钩的角色，包括客户端、业务服务端、安全中台、曲库业务、广告、业务中台等等。</p><p></p><p>由于之前对数据库申请的审核比较随意，云音乐主项目下已经存在了70多个库，其中大部分库的用途是不详的，有一些库映射的hdfs目录是非法的，在数据库的用法上也存在比较多不规范的地方。所以在这个背景下启动了对数据库的一波治理，整个治理流程是通过元数据，梳理库的使用现状，根据现状进一步定制数据库使用规范；确定出可下线库明细，制定下线方案，通过专项、数据迁移，公示下线等手段推进数据库的下线。并回收数据库的审批权限来规范库的使用。目前已经下线了27个无效库，数据库使用规范中明确了库的最终态，之后新增的数据都会归在目前的22个数据库中。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/56/56a3345deccf8a0e042f186d9f926935\" /></p><p></p><h3>4.5 库表层面 - 表治理</h3><p></p><p></p><p>表治理主要是针对表的存储治理的过程，这里介绍一下四个比较有代表的存储治理专项。</p><p></p><p>第一个是临时表治理，早期临时表面临着存量大，增速快的问题，经过一期的的治理解决了大量存量的问题，增速快的问题后面通过元数据建模产出的报表，推进线上任务改造的方式较好的解决了增速快的问题。</p><p></p><p>第二个是生命周期管理的推进，早期面临的问题是缺乏规范，生命周期覆盖低，设置随意。在出台了生命周期管理设置规范之后，生命周期覆盖上获得了较好的成果。</p><p></p><p>第三个是巨型表的治理，这里定义出日费用在100以上的表为巨型表，总共涉及163张表，存储占比却达到了80%，,单独把巨型表拉出来治理是居于二八原则，拉大头重点治理，获得的收益是显著的。</p><p></p><p>第四个是abtest专项治理，abtest任务的特点是实验数据量大，任务复杂耗资源。当前正在推进ab系统的升级改造，天秤系统将会代替掉老的ab系统，正好趁着这个机会把老的任务和存储进行下线。当前这个治理事项正在推进过程中，还有其他类似的这种产品换代的事项也会按专项进行推进。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/63/63549b6b3136071cfc93e1b81a27b9d8.png\" /></p><p></p><h3>4.6 模型设计层面 -“三度”指标治理</h3><p></p><p></p><p>22年我们在模型设计层面引入了“三度”指标的概念，通过一系列指标在进度 健康度 价值度上通过数值化来衡量我们模型建设的一个合理度。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/46/46b625db63387e779e601bcd3a7c8cba\" /></p><p></p><p>覆盖率和闲置率是针对ods表利用率的一个衡量。通过对ods层表的治理可以进一步提升覆盖率，降低闲置率。这个过程中我们可以下线大量的无效ods表以及相应的任务。</p><p></p><p>复用率和穿透率是用来反馈我们cdm层表引用健康度情况，目前通过一系列的治理。复用率已经又30%提升到了60%，穿透率由20%下降到了10%。</p><p></p><p>资产规范率和资产引用率是针对我们cdm层表的规范化情况的一个衡量，这两个指标我们是保持在85%以上，并且通过一系列的规范落地，指标会逐步提升。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/5e/5ee7c66c9e72b0c12fca471245bb9b03\" /></p><p></p><p>通过三度指标的一个治理，可以清理掉大量无效的任务和表，在存储资源和计算资源上可以减少不少成本。</p><p></p><h3>4.7 数据处理层面 - 计算治理</h3><p></p><p></p><p>计算治理当前阶段主要是针对计算引擎升级做治理。</p><p></p><p>云音乐集群是在21年年中上线了spark3执行引擎，经过大半年的使用，我们确实在spark3上体验到了非常棒的效果，网易数帆大数据团队的同学也在spark3上进一步做了大量的优化，例如AQE增强优化、zorder功能以及shuffle阶段采用zstd压缩算法。为了能够更好的兼容升级过程，大数据团队也在spark引擎上内置了大量优化参数。当前spark3引擎在计算资源、存储资源、小文件问题上获得了大幅的提升。在这个背景下我们在22年Q2阶段开始任务迁移至spark3的专项。涉及的迁移事项有</p><p></p><p>hive 迁移spark3spark2版本的sql任务迁移至spark3，核心任务和高成本任务的spark3+zorder+gzip升级。spark工程任务迁移spark3的专项。</p><p></p><p>每一项在节省资源上都获得了巨大的提升。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/48/48096ab5d70dc3c9e60f134ad6825552.png\" /></p><p></p><h2>项目成果</h2><p></p><p></p><h3>5.1 成本收益</h3><p></p><p></p><p>经过一系列的治理动作，我们在存储和计算方面获得了颇丰的收益。</p><p></p><p>存储上</p><p></p><p>累计下线的存储占整体存储的30%存储增量趋势放缓，由原来的日增170T，下降到日增55T</p><p></p><p>计算上</p><p></p><p>核心&amp;耗资源任务计算资源节省30%以上集群稳定性提升核心任务产出提前，基线保障由9点提前至5点30</p><p></p><h3>5.2 治理资产沉淀</h3><p></p><p></p><p>在整个治理过程中我们也将方法论和治理思路沉淀了一系列的可视化监控看板和治理跟进工具，确保整个治理事情是有序进行并且过程可控的。</p><p></p><p>可视化监控看板方面，</p><p></p><p>数据资产沙盘，可以在大盘的角度观察我们整体数据的变化情况。\"三度\"指标概览，可以从不同的粒度，反馈数仓整体建设健康度的情况。计存沙盘，可以看到不同数据使用方在存储成本和计算成本上的表现，也可以监测异动情况。治理效果看板，汇总了我们每一项专项治理过程中产生的收益情况。游离文件监控、任务监控等等…</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/ad/ade1312d83a5976e4231c6ec258c64a8.png\" /></p><p></p><p>针对每一项治理，我们都有产出相关的跟进工具，例如 个人指标治理报告、临时表治理监控报告、“三度”指标治理列表、推荐归属治理监控、下线治理报告、任务升级跟踪报告等等</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/91/91425f9709be152052012667f01f4462.png\" /></p><p></p><h3>5.3 规范沉淀</h3><p></p><p></p><p>治理过程中我们也逐步丰富了我们的数据开发规范数据库使用规范临时表建表规范节点命名规范队列使用规范任务上线规范数据治理下线流程规范…</p><p></p><h2>未来展望</h2><p></p><p></p><p>数据治理是一件长期并且持续要进行的事情，如何达到更好的治理效果？我们整个治理过程遵循理念是：从分散到集约、从被动到主动到自动、从经验到智能。在这个理念的基础上，我们的治理是按事前、事中、事后三个步骤管理治理事项。其中最为重点的是事前事项，事前的动作都是预防性的动作，预防做好、事后无忧。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/be/befacf3e360fea0644fb3c06b1e33957.png\" /></p><p></p><p>事前：我们在推进的动作有，推广数据开发规范，推广数仓资产白皮书的使用，推进猛犸产品优化功能迭代，控制好上线审核机制等等。</p><p></p><p>事中：针对事前没有遵循规范或者遗漏下来的问题，在事中我们会丰富各种治理监控指标工具，及时发现并反馈问题。</p><p></p><p>事后：事后我们也会产出各项治理指引报告，给出治理理由、治理方案，并同步提供更便捷有效的治理工具。</p><p></p><p>事中和事后的动作都是在为事前的规范事项提供思路，进一步推进治理的自动化和智能化。接下来我们会在自动化和智能化上发力，让我们整个数据能够在完善的系统化环境中发挥数据价值和业务价值。</p><p></p><p>结语：以上是对云音乐数据治理实践的分享，在这里感谢网易数帆大数据团队对我们的各种支持。</p><p></p>",
    "publish_time": "2022-11-27 16:52:05",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]