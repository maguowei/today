[
  {
    "title": "PHP 8：数组、变量、操作符、异常处理",
    "url": "https://www.infoq.cn/article/cctqEbwE08k1OuZJYvtV",
    "summary": "<p></p><blockquote>本文属于专题文章<a href=\"https://www.infoq.cn/theme/php8-article-series\">《深入浅出 PHP 8》</a>\"。根据<a href=\"https://w3techs.com/technologies/details/pl-phptps://feed.infoq.com/php8-article-series/\">w3tech</a>\"的数据，PHP 仍是互联网上使用最为广泛的脚本语言之一，77.3%的网站在服务器端均使用该编程语言。PHP 8 为我们带来了许多新功能与优化，具体将在本系列文章中分析。</blockquote><p></p><p></p><p>本篇介绍几个新特性以及与数组、变量、运算符、异常处理和trait等有关的改进。</p><p></p><h2>数组与字符串</h2><p></p><p></p><h3>弃用false值的Autovivification</h3><p></p><p><a href=\"https://en.wikipedia.org/wiki/Autovivification\">Autovivification</a>\"是指当引用数组中未定义的元素时自动创建新数组，例如：</p><p></p><p><code lang=\"plain\"><!--?php\n$arr['a'][1] = 'a';\nvar_dump($arr);\n</code--></code></p><p></p><p><code lang=\"plain\">新数组$arr是自动创建出来的，它在被引用之前并不存在。输出如下：</code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\">array(1) { [\"a\"]=&gt; array(1) { [1]=&gt; string(1) \"a\" } }\n</code></code></p><p></p><p><code lang=\"plain\">Autovivification允许开发人员引用结构化变量（如数组）及其子元素，而无需首先显式地创建该结构化变量。</code></p><p></p><p><code lang=\"plain\">PHP 8.0支持未定义变量、空值和false值的Autovivification 。下面的脚本演示了null值的Autovivification：</code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><!--?php\n$arr   = null;\n$arr[] = 1;\nvar_dump($arr);\n</code--></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\">输出如下：</code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"plain\">array(1) { [0]=&gt; int(1) }\n</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\">下面的脚本演示了未定义变量的Autovivification：</code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n$arr[]                     = 'undefined value';\n$arr['variableNotExist'][] = 1;\n\nvar_dump($arr);\n</code--></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\">上述脚本输出如下：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">array(2) { [0]=&gt; string(15) \"undefined value\" [\"variableNotExist\"]=&gt; array(1) { [0]=&gt; int(1) } }\n</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\">PHP 8.0甚至允许false的Autovivification。不过，PHP 8.0不支持标量值的Autovivification，如下面的脚本所示：</code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><!--?php\n$arr   = 1;\n$arr[] = 1;\nvar_dump($arr);\n</code--></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">上述脚本输出如下：</code></code></code></code></p><p></p><p></p><blockquote><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\">Uncaught Error: 不能将标量值作为数组来使用在PHP 8.1中，Autovivification只支持未定义的变量和null 值，已放弃支持false值的Autovivification。想证明这一点，可以运行以下脚本：</code></code></code></code></blockquote><p></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><!--?php\n \n$arr = false;\n$arr[] = 1;\n</code--></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">上述脚本输出如下：</code></code></code></code></p><p></p><p></p><blockquote><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">Deprecated: 从false到数组的自动转换已弃用</code></code></code></code></blockquote><p></p><p></p><h3><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">字符串键数组解包</code></code></code></code></h3><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">解包的使用语境是逐项列出数组元素，或使用解包运算符...取出数组元素。PHP 8.0不允许对数组中的字符串键进行解包，就像不允许对函数的参数进行解包一样。PHP 8.1通过引入命名参数提供了函数参数解包支持；命名参数可以在参数解包之后使用，条件是命名参数不能覆盖已解包的参数。“<a href=\"https://www.infoq.com/articles/php8-functions-methods\">PHP 8：函数和方法的新特性</a>\"”一文中有一个演示函数命名参数解包的示例。</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">此外，PHP 8.1还允许使用…运算符将字符串键解包到数组中，如下所示：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n\n$array1 = [\"one\" =--> 1];\n$array2 = [\"two\" =&gt; 2];\n$array1 = [\"one\" =&gt; \"one\"];\n$array2 = [\"two\" =&gt; \"two\"];\n$array = [\"one\" =&gt; 0, \"two\" =&gt; 10, ...$array1, ...$array2];\nvar_dump($array);\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">用…运算符解包$array1和array2，前一个数组的键被后一个数组的键所覆盖。输出结果如下：</code></code></code></code></p><p></p><p></p><blockquote><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">array(2) { [\"one\"]=&gt; string(3) \"one\" [\"two\"]=&gt; string(3) \"two\" }array_merge()函数用于在后台解包数组，因此，解包前面示例中的两个数组可以调用array_merge($array1，$array2)。</code></code></code></code></blockquote><p></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">新特性仅影响字符串键，而整数键将重新编号；原来的整数键不会保留。使用整数键的示例如下：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n\n$array1 = [1 =--> 1];\n$array2 = [2 =&gt; 2];\n$array1 = [1 =&gt; \"one\"];\n$array2 = [2 =&gt; \"two\"];\n$array = [1 =&gt; 0, 2 =&gt; 10, ...$array1, ...$array2];\nvar_dump($array); \n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">下面给出了解包字符串键数组的另一个示例，其中引号括起来的整数键实际上会被当作整数键。包含整数的字符串键会被强制转换为整数类型，例如：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"plain\"><!--?php  \n\n$array1 = [\"1\" =--> 1];\n$array2 = [\"2\" =&gt; 2];\n$array1 = [\"1\" =&gt; \"one\"];\n$array2 = [\"2\" =&gt; \"two\"];\n$array = [\"one\" =&gt; 0, \"two\" =&gt; 10, ...$array1, ...$array2];\nvar_dump($array);\n</code></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">输出如下：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"plain\">array(4) { [\"one\"]=&gt; int(0) [\"two\"]=&gt; int(10) [0]=&gt; string(3) \"one\" [1]=&gt; string(3) \"two\" }\n</code></code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">确定数组是否是列表的新函数</code></code></code></h3><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">数组类型支持字符串键和整数键。有时候，我们需要知道数组键的实际编号是否为0…count($array)-1。在这种情况下，我们将数组称为列表。新增函数array_is_list(array $array): bool就是为了完成这项工作。如果数组是一个列表，则该函数会返回一个bool值true，如果不是，则返回false。下面的例子演示了这个新函数：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n  \n$x = [1 =--> 'a', 0 =&gt; 'b', 2=&gt;'c'];\n\n$y = [0 =&gt; 'a', 1 =&gt; 'b', 2=&gt;'c'];\nvar_export(array_is_list($x));   \nvar_export(array_is_list($y));\n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">输出如下：</code></code></code></p><p></p><p></p><blockquote><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">falsetrue</code></code></code></blockquote><p></p><p></p><h3><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">数组排序变得稳定</code></code></code></h3><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">在PHP 7中，数组的排序操作是不稳定的。“不稳定”意味着在连续排序中，不能保证“相等”的元素顺序一致。PHP 8.0中排序变得稳定。如果输入数组中有多个元素相等，则它们在排序完成后总是邻接。换句话说，相等的元素会保持它们在原数组中的顺序。当按照复杂数据的特定属性进行排序时，这一特性特别有用。在这种情况下，如果排序不稳定，则可能会导致输出不一致。下面的脚本演示了稳定排序：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n \n$array = [\n    'd' =--> 'c',\n    'c' =&gt; 'c',\n    'b' =&gt; 'a',\n    'a' =&gt; 'a',\n]; \nasort($array);\n\nforeach ($array as $key =&gt; $val) {\n                echo \"array[\" . $key . \"] = \" . $val . \"\\n\";\n             }  \n</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">在稳定排序中，结果总是：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"plain\">array[b] = a array[a] = a array[d] = c array[c] = c\n</code></code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">弃用${}字符串插值</code></code></code></h3><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">在双引号（\"）中的字符串里嵌入变量可以有多种形式。PHP 8.2弃用了两种字符串插值形式：${var}和${expr}。${var}形式与其他两种形式(\"$var\")和(\"{$var}\")语法上存在重叠，并且功能不如其他形式强大。${expr}与(string) ${expr}等价，很少使用。</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">下面的例子展示了允许的字符串插值形式，以及不允许的形式${var}和${expr}：</code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n \n$str = 'hello';\n \nvar_dump(\"$str\");\nvar_dump(\"{$str}\");\nvar_dump(\"${str}\");\n\nvar_dump(\"${str}\"); \n \nvar_dump(\"${(str)}\");\n</code--></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\">上述脚本输出如下：</code></code></code></code></p><p></p><p></p><blockquote><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\">Deprecated: 字符串插值形式 var} 代替in /home/deepakvohra/php-src/scripts/php-info.php on line 8Deprecated: 字符串插值形式 var} 代替in /home/deepakvohra/php-src/scripts/php-info.php on line 10Deprecated: 字符串插值形式  {expr}} 代替in /home/deepakvohra/php-src/scripts/php-info.php on line 12string(5) \"hello\" string(5) \"hello\" string(5) \"hello\" string(5) \"hello\"Fatal error: Uncaught Error: 未定义常量 \"str\"</code></code></code></code></blockquote><p></p><p></p><h2><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\">异常处理</code></code></code></code></h2><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\">PHP 8.0引入了非捕获catch。以前，每个catch语句都必须为被捕获的异常声明一个变量。例如，下面的脚本在catch语句中声明了Exception类型的变量$exc：</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nfunction sortArray(array $arrayToSort)\n{\n    \n    try {\n        if (count($arrayToSort) === 0) {\n            throw new Exception(\"Array is empty; please provide a non-empty array\");\n        }\n        \n    }\n    catch (Exception $exc) {\n        echo $exc;\n    }\n}\n\n$arrayToSort = array();\n</code--></code></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">执行上述脚本会输出下面这条异常信息：</code></code></code></code></code></p><p></p><p></p><blockquote><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">Exception: 数组为空，请提供一个非空数组虽然前面的示例使用了$exc变量，但也不是一定要使用异常变量。对于非捕获catch，异常变量是可选的；不声明异常变量，因此也就不能使用，如下所示：</code></code></code></code></code></blockquote><p></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nfunction sortArray(array $arrayToSort)\n{\n    \n    try {\n        if (count($arrayToSort) === 0) {\n            throw new Exception(\"Array is empty; please provide a non-empty array\");\n        }\n        \n    }\n    catch (Exception) {\n    }\n}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">多捕获catch语句也可以是非捕获catch，如下所示：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass Exception1 extends Exception\n{\n}\n\nclass Exception2 extends Exception\n{\n}\n\nclass A\n{\n    public function fn1()\n    {\n        try {\n            throw new Exception1();\n        }\n        catch (Exception1 | Exception2) {\n            \n        }\n    }\n}\n</code--></code></code></code></code></code></code></p><p></p><h3><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">抛出异常</code></code></code></code></code></h3><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">throw语句以前不能在表达式中使用。PHP 8.0增加了在表达式中使用throw的支持。例如，在以下脚本中，match 表达式在default中使用了throw表达式。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\n$vector = new \\Ds\\Vector();\n\n$vector--->push('a');\n\ntry {\nmatch ('set') {\n  'push' =&gt; $vector-&gt;push('b'),\n  'pop' =&gt; $vector-&gt;pop(),\n   default =&gt; throw new Exception()\n};\n    \n}\ncatch (Exception $exc) {\n    echo $exc;\n}\nprint_r($vector); \n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">Exception in C:\\php-8.1.9-nts-Win32-vs16-x64\\scripts\\sample.php:11 Stack trace: #0 {main}Ds\\Vector Object ( [0] =&gt; a )\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">下面的例子将throw与空值合并运算符（??）一起使用：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \n$name = $_GET['name'] ?? throw new Exception(\"请提供请求参数'name'\");\n\necho \"Hello \" . htmlspecialchars($name).\"<br-->\";\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></code></code></p><p></p><p></p><blockquote><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">Uncaught Exception: 请提供请求参数'name'在下面的例子中，throw和三元运算符（?）一起使用：</code></code></code></code></blockquote><p></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\ntry {\n    function fn1(bool $param1)\n    {\n     $value = $param1 ? true: throw new InvalidArgumentException();\n    }\n    \n    fn1(true);\n    fn1(false);\n}\ncatch (Exception $exc) {\n    echo $exc;\n} \n</code--></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">InvalidArgumentException in C:\\php-8.1.9-nts-Win32-vs16-x64\\scripts\\sample.php:5 Stack trace: #0 C:\\php-8.1.9-nts-Win32-vs16-x64\\scripts\\sample.php(9): fn1(false) #1 {main}\n</code></code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">变量</code></code></code></code></code></h2><p></p><p></p><h3><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">整型字面量的显式八进制表示法</code></code></code></code></code></h3><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">字面量八进制表示法可能产生误导性结果，例如12 === 012的计算结果为false。PHP 8.1增加了对整型字面量显式八进制表示法0o/0O 的支持，类似于十六进制的0x/0x表示法和二进制的0b/0b表示法。下面的脚本演示了显式八进制表示法：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n   \nvar_export(0o12 === 10);   \nvar_export(0o26 === 22);\n\nvar_export(0O12 === 10);   \nvar_export(0O26 === 22);\n\n\n\nvar_export(012 === 0o12);   \nvar_export(012 === 0O12);\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">true\ntrue\ntrue\ntrue\ntrue\ntrue\n</code></code></code></code></code></code></p><p></p><h3><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">限制$GLOBALS的使用</code></code></code></code></code></h3><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">通过$GLOBALS变量可以直接访问内部符号表，新版本对它的使用增加了一些限制。从PHP 8.1开始，$GLOBALS只能使用$GLOBALS[$name] = $value语法来修改。为了证明这一点，可以运行下面这个直接访问$GLOBALS的脚本：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><!--?php\n$x=1;  \n$GLOBALS = 1;\n$GLOBALS += 1;\n$GLOBALS =& $x;\n$x =& $GLOBALS;\nunset($GLOBALS);\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">上述脚本会导致以下错误信息：</code></code></code></code></code></code></p><p></p><p></p><blockquote><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">GLOBALS[value语法来修改下面这种使用GLOBALS 的方法就没问题：</code></code></code></code></code></code></blockquote><p></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><!--?php\n$GLOBALS['a'] = 1;\n$GLOBALS['a']--;\nvar_dump($GLOBALS['a']);\n</code--></code></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">输出如下：</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"plain\">int(0)\n</code></code></code></code></code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">将命名空间名称视为单个标记</code></code></code></code></code></h3><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">为了使保留关键字可以出现在命名空间名称中，PHP 8.0将把命名空间名称视为单个标记。这降低了引入新的保留字时，因为现有命名空间名称已使用该保留字而导致向后不兼容的可能性。</code></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">为了说明这一点，下面的脚本在命名空间名称中使用了保留字fn。该脚本还使用了ReflectionClass来输出类的属性，比如它是否是一个命名空间、类名、命名空间和类方法：</code></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><!--?php\nnamespace  do\\while\\fn\\iter;\n\nfunction fn1()\n{\n}\nclass C\n{\n    static function fn2()\n    {\n    }\n}\n\n$class = new \\ReflectionClass('do\\while\\fn\\iter\\C');\n\nvar_dump($class--->inNamespace());\nvar_dump($class-&gt;getName());\nvar_dump($class-&gt;getNamespaceName());\n\n$methods = $class-&gt;getMethods();\nvar_dump($methods);\n</code></code></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">输出如下：</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\">bool(true) string(18) \n\"do\\while\\fn\\iter\\C\" string(16) \n\"do\\while\\fn\\iter\" \narray(1) { [0]=&gt; object(ReflectionMethod)#2 (2) { [\"name\"]=&gt; string(3) \"fn2\" [\"class\"]=&gt; string(18) \"do\\while\\fn\\iter\\C\" } }\n</code></code></code></code></code></p><p></p><h2><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">运算符</code></code></code></code></h2><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">PHP 8增加了许多与新运算符相关的特性。</code></code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">非严格字符串数字比较变得更加有用</code></code></code></code></h3><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">在PHP 8.0之前，非严格字符串数字比较都是假设字符串实际上是一个数字，并将字符串转换为数字后进行数字比较。PHP 8.0会在转换类型并进行数字比较之前确保字符串是一个数字。否则，它会将数字转换为字符串，并进行字符串比较。新特性不适用于严格比较运算符===和!==。这些运算符要求两个操作数具有相同的类型，并且不执行隐式类型转换。受影响的只有非严格比较运算符==、!=、&gt;、&gt;=、&lt;、&lt;=和⇔。下面的脚本演示了新的字符串数字比较：</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n \nvar_dump(1 == \"001\");         \nvar_dump(1 == \"1.0\");           \nvar_dump(1.0 == \"+1.0E0\");  \n\nvar_dump(1 == \"1  \"); \n\nvar_dump(1 == \"  1\");\n\n\n\nvar_dump(1 == \"  1   \"); \nvar_dump(\"one\" == \"1\");\n\nvar_dump(\"one\" != \"1\"); \n</code--></code></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\">输出如下：</code></code></code></code></code></p><p></p><p></p><blockquote><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\">bool(true) bool(true) bool(true) bool(true) bool(true) bool(true) bool(false) bool(true)</code></code></code></code></code></blockquote><p></p><p></p><h3><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\">空值安全运算符</code></code></code></code></code></h3><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\">你是不是经常调用方法或获取表达式结果的属性并假设结果非空？由于结果可能为空，所以最好首先确保它不是空的。你可以显式地使用if(result!=null)进行比较，但它可能涉及层次化的多重比较。下面的脚本使用传统的if比较，对整数值的加法进行空值安全的比较：</code></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \nclass Sum\n{\n    public int $i;\n\n    function __construct()\n    {\n        $this--->i = 0;\n    }\n    \n    function addA(Sum $sum,int $a):?Sum\n    { \n        $sum-&gt;i= $a+$sum-&gt;i;\n        return $sum;\n    }\n    \n    function addB(Sum $sum,int $b):?Sum\n    { \n        $sum-&gt;i= $b+$sum-&gt;i;\n        return $sum;\n    }\n    \n    function addC(Sum $sum,int $c):?Sum\n    {    \n        $sum-&gt;i= $c+$sum-&gt;i;\n        return $sum;\n    }\n\n    function getSum(Sum $sum):int\n    {    \n         \n        return $sum-&gt;i;\n    }\n\n     \n}\n\n\n\n$a = new Sum();\n\nif ($a-&gt;addA($a,1) !== null) {\n    if ($a-&gt;addB($a,2) !== null) {\n      if ($a-&gt;addC($a,3) !== null) {\n         echo $a-&gt;getSum($a);\n      }\n   }\n} \n</code></code></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\">上述脚本的结果是6。</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\">新运算符?-&gt;可用于链接调用以进行空值安全比较，当运算符的左操作数计算结果为null时，它将停止所有后续的比较。对于上述加法操作，以下脚本演示了链接操作数，使用新运算符?-&gt; 进行空值安全比较。</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"json\">echo $a-&gt;addA($a,1)?-&gt;addB($a,2)?-&gt;addC($a,3)?-&gt;getSum($a);\n</code></code></code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\">与语言环境无关的浮点数字符串转换</code></code></code></code></h3><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\">在PHP 8.0之前，浮点数到字符串类型的转换依赖于语言环境，也就是说，小数分隔符会因语言环境而异。这可能会导致一些不一致，例如将字符串解释为格式错误，或将字符串解释为数值。开发人员非常需要一致的浮点数字符串表示，而PHP 8.0 正好提供了这一点。下面的脚本演示了与本地语言环境无关的浮点数字符串转换。</code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n \nsetlocale(LC_ALL, \"de_DE\");\n$f = 1.23;\n \necho (string) $f;      \necho strval($f);\n</code--></code></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">输出结果如下：</code></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">1.23\n1.23\n</code></code></code></code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">对算术/位运算符进行更严格的类型检查</code></code></code></code></code></h3><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">算术/位运算符+、-、*、/、**、%、&lt;&lt;、&gt;&gt;、&amp;、|、^、~、++、-只能应用于支持这些运算符的操作数。这些运算符不能用于数组、资源或非重载对象操作数。PHP 8.0会进行严格的类型检查，如果操作数与算术/位运算符不兼容，则抛出TypeError。为了演示这一点，下面的脚本对数组使用了减法运算符（-）：</code></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><!--?php\n \n $arrayToSort = array(3, 1, 0, 2);\n var_dump($arrayToSort - [1]);\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">上述脚本会导致以下错误：</code></code></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">Uncaught TypeError: 不支持的操作数类型: array - array \n</code></code></code></code></code></code></code></p><p></p><h3><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">在常量表达式中使用-&gt;/?- &gt;运算符获取枚举属性</code></code></code></code></code></h3><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">枚举对象不允许出现在常量表达式中，如数组键，这样你就无法在常量表达式中获取枚举属性的名称和值。为了演示这一点，请使用8.1版本运行以下脚本：</code></code></code></code></code></p><p></p><p><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n\n \nenum Sort: string {\n    case ASC = 'ASC';\n    \n    const SortType = [self::ASC--->name =&gt; self::ASC-&gt;value];\n}\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">上述脚本会导致如下错误信息：</code></code></code></code></p><p></p><p></p><blockquote><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">常量表达式包含无效操作PHP 8.2允许在常量表达式中使用-&gt; ?-&gt;运算符获取枚举属性，如下所示：</code></code></code></code></blockquote><p></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n\nenum Sort: string {\n    case ASC = 'ASC';\n    \n    const SortType = [self::ASC--->name =&gt; self::ASC-&gt;value];\n}\nfunction get()\n{\n static $g = Sort::ASC-&gt;value;\n}\n\n#[Attr(Sort::ASC-&gt;name)]\nclass SortClass\n{\n}\n\nfunction set($s = Sort::ASC-&gt;value,)\n{\n}\n\nclass SortClass2\n{\n public string $n = Sort::ASC-&gt;name;\n}\n// The rhs of -&gt; allows other constant expressions\nconst DESC = 'DESC';\nclass SortClass3\n{\n const C = Sort::ASC-&gt;{DESC};\n}\n</code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">Trait</code></code></code></code></h2><p></p><p></p><h3><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">抽象trait方法验证</code></code></code></code></h3><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">PHP 8.0会在组合/使用类中验证抽象trait方法，以确保它们的签名匹配。实现方法必须与trait方法兼容，这里的兼容被定义为签名兼容：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">参数数量兼容：函数参数的数量必须相同逆变参数类型兼容协变返回类型兼容另外，静态方法必须保持静态。抽象trait方法可以是私有的。下面的脚本演示了抽象trait方法的一个准确实现：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n \ntrait HelloTrait {\n    abstract private function hello(): string;\n \n    public function getMsgLength() {\n        return strlen($this--->hello());\n    }\n}\n \nclass A {\n    use HelloTrait;\n \n  private function hello(): string {return \"Hello John\"; }\n}\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">为了演示不兼容的情况，将实现方法修改如下：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">private function hello(): stdClass { }\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">在这种情况下，会报以下错误信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">A::hello(): stdClass的声明必须与HelloTrait::hello(): string兼容\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">不能在类中将trait中的非静态方法变成静态。为了演示这一点，修改实现如下：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">private static function hello(): string { }\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">上述脚本会报以下错误信息：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"plain\">无法在类A中将非静态方法HelloTrait::hello()变成静态\n</code></code></code></code></code></p><p></p><h3><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">弃用在Trait上调用静态元素的特性</code></code></code></code></h3><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\">PHP 8.1.0放弃在trait上调用静态元素的支持，也就是说，不能直接在trait上调用静态方法或静态属性。只能通过使用trait的类访问trait的静态方法和属性。下面的脚本演示了这种情况：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><!--?php\n \ntrait HelloTrait {\n\n   public static $a = 'static property in trait';\n   public static function hello(): string {return \"Hello\";}\n     \n}\n \nclass A {\n    use HelloTrait;\n \n}\n\n echo A::$a;\n echo A::hello();\n\necho HelloTrait::$a;\necho HelloTrait::hello();\n</code--></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">输出如下：</code></code></code></code></code></p><p></p><p></p><blockquote><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">Deprecated: 不能直接访问静态trait属性HelloTrait::$a，只能通过使用该trait的类访问Deprecated: 不能直接访问静态trait方法HelloTrait::hello，只能通过使用该trait的类访问</code></code></code></code></code></blockquote><p></p><p></p><h3><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">Trait中的常量</code></code></code></code></code></h3><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">PHP 8.1不允许在trait中使用不变量（也称为常量）。PHP 8.2增加了对在trait中使用常量的支持。这些常量可以由trait的方法使用，也可以在组合类中使用。为了演示常量在trait中的用处，请看下面的示例。其中，组合类中声明了一个名为MAX_ARRAY_SIZE的常量：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\ntrait SortTrait\n{\n    public function sortArray(array $arrayToSort): void\n    {\n        if (count($arrayToSort) --> self::MAX_ARRAY_SIZE) {\n            throw new \\Exception(\"array size out of range\");\n        } else {\n            sort($arrayToSort);\n            foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n            }\n            echo \"<br />\";\n        }\n    }\n}\n\nclass SortClass\n{\n    private const MAX_ARRAY_SIZE = 10;\n    use SortTrait;\n}\n\n$arrayToSort = [\"B\", \"A\", \"f\", \"C\", 1, \"a\", \"F\", \"B\", \"b\", \"d\"];\n$obj = new SortClass();\n$obj-&gt;sortArray($arrayToSort);\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">运行上述脚本会生成以下输出：</code></code></code></code></p><p></p><p></p><blockquote><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">0 = 1 1 = A 2 = B 3 = B 4 = C 5 = F 6 = a 7 = b 8 = d 9 = f下面是同一脚本的8.2版本，在trait中声明了常量MAX_ARRAY_SIZE ：</code></code></code></code></blockquote><p></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\ntrait SortTrait\n{\n    public const MAX_ARRAY_SIZE = 10;\n\n    public function sortArray(array $arrayToSort): void\n    {\n        if (count($arrayToSort) --> self::MAX_ARRAY_SIZE) {\n            throw new \\Exception(\"array size out of range\");\n        } else {\n            sort($arrayToSort);\n            foreach ($arrayToSort as $key =&gt; $val) {\n                echo \"$key = $val \";\n            }\n            echo \"<br />\";\n        }\n    }\n}\n\nclass SortClass\n{\n    use SortTrait;\n}\n\n$arrayToSort = [\"B\", \"A\", \"f\", \"C\", 1, \"a\", \"F\", \"B\", \"b\", \"d\"];\n$obj = new SortClass();\n$obj-&gt;sortArray($arrayToSort);\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">输出相同：</code></code></code></code></p><p></p><p></p><blockquote><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">0 = 1 1 = A 2 = B 3 = B 4 = C 5 = F 6 = a 7 = b 8 = d 9 = f再看一个例子。下面的脚本在trait中声明了3个常量，并在trait中使用了它们：</code></code></code></code></blockquote><p></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\ntrait SortTrait\n{\n    public const SORT_TYPE_1 = \"ASC\";\n    public const SORT_TYPE_2 = \"DESC\";\n    public const SORT_TYPE_3 = \"SHUFFLE\";\n\n    public function getSortType(string $sortType): void\n    {\n        if (str_contains($sortType, self::SORT_TYPE_1)) {\n            echo \"Sort type is ASC\";\n        }\n        if (str_contains($sortType, self::SORT_TYPE_2)) {\n            echo \"Sort type is DESC\";\n        }\n        if (str_contains($sortType, self::SORT_TYPE_3)) {\n            echo \"Sort type is SHUFFLE\";\n        }\n    }\n}\n\nclass SortClass\n{\n    use SortTrait;\n}\n\n$obj = new SortClass();\n\n$obj--->getSortType(\"ASCending\");\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">输出如下：</code></code></code></code></p><p></p><p></p><blockquote><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">Sort type is ASCTrait常量无法通过TRAIT_NAME::CONSTANT 语法直接访问，就像下面的脚本这样：</code></code></code></code></blockquote><p></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\ntrait SortTrait\n{\n    public const SORT_TYPE_1 = \"ASC\";\n    public const SORT_TYPE_2 = \"DESC\";\n    public const SORT_TYPE_3 = \"SHUFFLE\";\n\n    public function getSortType(string $sortType): void\n    {\n        if (str_contains($sortType, SortTrait::SORT_TYPE_1)) {\n            echo \"Sort type is ASC\";\n        }\n        if (str_contains($sortType, self::SORT_TYPE_2)) {\n            echo \"Sort type is DESC\";\n        }\n        if (str_contains($sortType, self::SORT_TYPE_3)) {\n            echo \"Sort type is SHUFFLE\";\n        }\n    }\n}\n\nclass SortClass\n{\n    use SortTrait;\n}\n\n$obj = new SortClass();\n\n$obj--->getSortType(\"ASCending\");\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">执行上述脚本会输出以下错误信息：</code></code></code></code></p><p></p><p></p><blockquote><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">Uncaught Error: 不能直接访问trait常量SortTrait::SORT_TYPE_1使用$this就可以，如下所示：</code></code></code></code></blockquote><p></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">if (str_contains($sortType, $this::SORT_TYPE_1)) {\n            echo 'Sort type is ASC';\n        }\n</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">Trait常量可以声明为final类常量。适用于trait属性的兼容性限制也适用于它的常量。</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\">枚举可以使用包含常量的trait，和直接在枚举中定义它们一样，如下所示：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\ntrait SortTrait\n{\n    private const SortType = \"ASC\";\n}\n\nenum Enum1: int\n{\n    use SortTrait;\n\n    case CaseA = self::SortType;\n}\n</code--></code></code></code></code></code></p><p></p><h2><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">逐步淘汰Serializable</code></code></code></code></code></h2><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">PHP 7.4引入了自定义序列化机制，借助两个新的魔法方法：__serialize(): array和__unserialize(array $data): void。__serialize()方法返回一个包含对象所有必要状态的数组，__unserialize()方法从给定的数据数组中恢复对象状态。新的自定义序列化机制旨在逐步淘汰Serializable接口。如果一个非抽象类实现了Serializable，但没有实现__serialize()和__unserialize()， PHP 8.1就会生成一条弃用警告。这样的一个类被称为“only Serializable”。为了演示这一点，可以运行下面的脚本：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"php\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n class A implements Serializable {}\n</code--></code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">执行上述脚本会显示以下弃用信息：</code></code></code></code></code></p><p></p><p></p><blockquote><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">Deprecated: A实现了Serializable接口，该接口已弃用。如果需要支持旧的PHP版本，请实现__serialize()和__unserialize()Fatal error: 类A包含2个抽象方法，因此必须声明为抽象的，或者实现其余的方法 (Serializable::serialize, Serializable::unserialize)</code></code></code></code></code></blockquote><p></p><p></p><h2><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">弃用动态属性</code></code></code></code></code></h2><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">动态类属性是在声明之前被引用的属性。动态属性是自动创建的。PHP 8.2已弃用动态属性。这主要是为了避免这样一种情况：用户无意创建新属性，但却因为输入了错误的属性名称而创建了新属性。为了演示这一点，在PHP 8.2中运行下面的脚本创建一个动态属性：</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n\nclass A\n{\n    public $name;\n}\n\n$a = new A();\n\n// 给已声明的属性User::$name赋值\n$a--->name = \"John\";\n\n$a-&gt;firstname = \"John\";\n</code></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">执行上述脚本会输出以下弃用信息：</code></code></code></code></p><p></p><p></p><blockquote><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">Deprecated: 已弃用创建动态属性A::$firstname如果你仍然希望动态属性实现魔术方法__get/__set，或使用新属性#[AllowDynamicProperties]，则预打包类stdClass已经用#[AllowDynamicProperties]属性标记。</code></code></code></code></blockquote><p></p><p></p><h2><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">弃用向内置函数的非可空参数传递null值的特性</code></code></code></code></h2><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\">当强类型模式设置为(strict_types=1)时，用户定义函数不接受向非空参数传递null值。在PHP 8.1中，即使是内置函数也不会接受向非空参数传递null值，如下所示，它会生成弃用通知：</code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><!--?php\n$var=null; \nstrlen($var);\n</code--></code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">输出如下：</code></code></code></code></code></p><p></p><p></p><blockquote><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">Deprecated: strlen(): 向string类型的参数 #1 ($string)传递null的特性已弃用在PHP 9.0中，TypeError弃用通知将被替换为错误。</code></code></code></code></code></blockquote><p></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">在本文中，我们讨论了PHP 8中与数组、变量、运算符和异常处理相关的新特性。我们还讨论了一些与trait、类和函数相关的特性。</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">原文链接：</code></code></code></code></code></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.com/articles/php8-arrays-variables-operators/\">https://www.infoq.com/articles/php8-arrays-variables-operators/</a>\"</code></code></code></code></code></p><p></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\">相关阅读：</code></code></code></code></code></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.cn/article/XkzLrAYhV1CWPDzu72N2\">PHP 8：注解、match 表达式及其他改进</a>\"</code></code></code></code></code></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.cn/article/XkIrT3XLmZFW9XdoJS1F\">PHP 8：类和枚举</a>\"</code></code></code></code></code></p><p><code lang=\"plain\"><code lang=\"plain\"><code lang=\"php\"><code lang=\"php\"><code lang=\"php\"><a href=\"https://www.infoq.cn/article/5ztCCEZ39EfToyRNaPF3\">PHP 8：函数和方法</a>\"</code></code></code></code></code></p>",
    "publish_time": "2023-06-11 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]