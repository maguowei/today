[
  {
    "title": "GitLab发布2023年全球DevSecOps报告，AI和ML从“有”变成“必须有”",
    "url": "https://www.infoq.cn/article/fv25HvvTwYfkGdOVFGQ7",
    "summary": "<p>GitLab的<a href=\"https://about.gitlab.com/blog/2023/09/12/gitlab-global-devsecops-ai-report/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTU5Nzg5MDUsImZpbGVHVUlEIjoiOTEzSk01bTR4TGY3VzlBRSIsImlhdCI6MTY5NTk3ODYwNSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.mJDfWNDhrj6Y7jXDpF_5JSNoz_CNiIfPI6X1eKcPy9s\">2023年全球DevSecOps AI报告</a>\"已发布，其中一个关键发现是<a href=\"https://en.wikipedia.org/wiki/Artificial_intelligence?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTU5Nzg5MDUsImZpbGVHVUlEIjoiOTEzSk01bTR4TGY3VzlBRSIsImlhdCI6MTY5NTk3ODYwNSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.mJDfWNDhrj6Y7jXDpF_5JSNoz_CNiIfPI6X1eKcPy9s\">AI</a>\"和<a href=\"https://www.infoq.com/introduction-machine-learning/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTU5Nzg5MDUsImZpbGVHVUlEIjoiOTEzSk01bTR4TGY3VzlBRSIsImlhdCI6MTY5NTk3ODYwNSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.mJDfWNDhrj6Y7jXDpF_5JSNoz_CNiIfPI6X1eKcPy9s\">ML</a>\"的使用正在从“有”发展到“必须有”。</p><p></p><p>报告显示，23%的组织已经在软件开发中使用AI，其中60%的组织每天都在使用AI。此外，65%的受访者表示，他们现在或将在未来三年内在测试中使用AI和ML。</p><p></p><p>83%的受访者表示，为了避免落后，在软件开发中使用AI至关重要。然而，也有约67%的受访者担心AI/ML所带来的影响，原因是AI/ML比人类更具成本效益优势，这会导致人类可从事的工作变少，并可能引入给他们带来麻烦的错误。</p><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/7d/7dce13400a0b2380f6447c6bb01352bc.webp\" /></p><p></p><p>虽然AI能够帮助开发者写代码，但这只占开发者工作时间的四分之一，剩下的时间花在其他任务上，这意味着AI有机会被用在写代码以外的领域。62%的受访者使用AI在正式测试流程之外检查代码，53%的受访者使用机器人测试代码。这两个数字同比增长均超过10%。</p><p></p><p>报告还显示，除了AI和ML，自2022年以来，DevOps和DevSecOps方法的采用率正在上升，从47%上升到56%。此外，DevSecOps正在脱离孤立的状态——只有30%的受访者表示他们需要对安全完全负责——低于一年前的48%。38%的安全专业人员认为他们是跨职能安全团队的一员，这一比例在一年前为29%。但是，开发人员和安全专业人员在谁应该带头解决安全问题上仍然存在争议。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/97/97ed30248b89bb787ce40281796ab566.webp\" /></p><p></p><p>左移安全性检查的势头仍在，74%的受访者现在已经或计划在未来三年内在SDLC早期就进行测试，开发人员在编写代码阶段就发现漏洞（而不是在更后面）的情况显著增加。组织的首要投入重点仍然是云计算，但安全、治理和合规性现在是第二大关注点。</p><p></p><p>工具链复杂性仍然是一个问题，几乎三分之二的受访者希望简化他们使用的工具，因为大约一半的受访者所使用的工具链包含了六个或更多的工具。值得注意的是，这使得获得合规性和监控的整体视图，以及在工具链中获得洞见变得更加困难。</p><p></p><p>报告指出，提高开发者生产力、加快发布速度和提高业务敏捷性是扩展DevSecOps实践的关键原因。然而，只有15%的受访者认为去年的DevSecOps预算有所增加。DevSecOps平台继续受到关注，72%的受访者正在使用或将在明年使用，主要原因是为了提高效率、安全性和自动化。</p><p></p><p>GitLab的全球DevSecOps AI状态报告<a href=\"https://about.gitlab.com/developer-survey/#ai?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTU5Nzg5MDUsImZpbGVHVUlEIjoiOTEzSk01bTR4TGY3VzlBRSIsImlhdCI6MTY5NTk3ODYwNSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.mJDfWNDhrj6Y7jXDpF_5JSNoz_CNiIfPI6X1eKcPy9s\">可从其网站下载</a>\"。</p><p></p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/09/gitlab-global-devsecops-ai/\">https://www.infoq.com/news/2023/09/gitlab-global-devsecops-ai/</a>\"</p>",
    "publish_time": "2023-10-02 00:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "如何一步步优化你的负载均衡策略？",
    "url": "https://www.infoq.cn/article/BdK3Q9dAQPfTpFoX6RN9",
    "summary": "<p>发展到一定阶段后，Web应用程序就会增长到单服务器部署无法承受的地步。这时候企业要么提升可用性，要么提升可扩展性，甚至两者兼而有之。为此，他们会将应用程序部署在多台服务器上，并在服务器之前使用负载均衡器来分配传入的请求。大公司可能需要数千台运行其Web应用程序的服务器来处理负载。</p><p>&nbsp;</p><p>在这篇文章中，我们将重点关注单个负载均衡器将HTTP请求分发到一组服务器的各种可行方式。我们将从底层开始，逐步引出现代负载均衡算法。</p><p>&nbsp;</p><p></p><h2>问题可视化</h2><p></p><p>&nbsp;</p><p>我们先从头开始：单个负载均衡器将请求发送到单台服务器，请求以每秒1个请求（RPS）的速率发送，并且每个请求在服务器处理时都会逐渐缩小。对于很多网站来说，这种设置挺好用。现代服务器性能强大，可以处理大量请求。但是当它们的性能跟不上时会发生什么事情？</p><p>&nbsp;</p><p>从上面的模拟中我们可以看到，3RPS的速率导致一些请求被丢弃了。如果在处理一个请求时，另一个请求到达了服务器，服务器将丢弃后者。这将导致向用户显示的错误，这是我们要避免的事情。我们可以将另一台服务器添加到负载均衡器来解决这个问题。</p><p>&nbsp;</p><p>现在不再有丢弃的请求了！我们的负载均衡器在这里起到了作用，依次向每台服务器发送请求，这称为“循环法”负载均衡。它是最简单的负载均衡形式之一，当你的服务器都同样强大并且你的请求都同样昂贵时，这个机制很合适。</p><p>&nbsp;</p><p></p><h2>当循环法不好用的时候</h2><p></p><p>&nbsp;</p><p>在现实世界中，服务器同样强大而请求同样昂贵的情况很少见。即使你使用完全相同的服务器硬件，它们的性能也可能不同。应用程序可能必须为许多不同类型的请求提供服务，并且这些请求可能具有不同的性能特征。</p><p>&nbsp;</p><p>我们看看当我们改变请求成本时会发生什么事情。在以下模拟中，请求的成本并不相同。你可以看到一些请求比其他请求花费了更长的时间。</p><p>&nbsp;</p><p>虽然大多数请求都得到了成功处理，但我们确实放弃了其中一些请求。缓解这种情况的方法之一是引入一个“请求队列”。</p><p>&nbsp;</p><p>请求队列帮助我们应对不确定性，但这是一种权衡。我们将丢弃更少的请求，但代价是某些请求具有更高的延迟。如果你观看上面的模拟足够长的时间，你可能会注意到请求的颜色发生了微妙的变化。请求没有被送达的时间越长，它们的颜色变化的就越多。你还会注意到，由于请求成本差异，服务器开始表现出不均衡情况。队列会在运气不好的，必须连续服务多个昂贵请求的服务器上备份下来。如果队列已满，我们将丢弃请求。</p><p>&nbsp;</p><p>上述情况同样适用于性能不一样的服务器组。在下一个模拟中，我们还改变了每台服务器的性能，在视觉上用较深的灰色阴影表示。</p><p>&nbsp;</p><p>服务器被赋予一个随机的性能值，但很可能有些服务器的性能低于其他服务器，并且它们很快就会开始丢弃请求。与此同时，性能更强大的服务器大部分时间都处于闲置状态。这个场景展示了循环法的主要弱点：方差。</p><p>&nbsp;</p><p>然而，尽管存在缺陷，循环法仍然是nginx的默认HTTP负载均衡方法。</p><p>&nbsp;</p><p></p><h2>改进循环法</h2><p></p><p>&nbsp;</p><p>我们可以改进循环法来更好地应对方差。有一种称为“加权循环法”的算法，其中用一个权重来标记每台服务器，该权重决定了向每台服务器发送多少请求。</p><p>&nbsp;</p><p>在这个模拟中，我们使用每台服务器的已知性能值作为其权重，并在循环遍历它们时向更强大的服务器提供更多请求。</p><p>&nbsp;</p><p>虽然这种机制能比普通循环法更好地处理服务器性能的差异，但我们仍然需要应对请求方差。在实践中，让人类手动设定权重的做法很快就会失败的。将服务器性能用某个数字来表示是很难的事情，并且需要对真实工作负载进行仔细的负载测试。实践中很少这样做，因此加权循环法的另一种变体会使用一个代理指标动态计算权重：它就是延迟。</p><p>&nbsp;</p><p>按理说，如果一台服务器处理请求的性能是另一台服务器的3倍，那么它的速度可能就是另一台服务器的3倍，并且应该接收相当于另一台服务器3倍的请求数量。</p><p>&nbsp;</p><p>这次我向每台服务器添加了文本，显示最后3个请求的平均延迟。然后我们根据延迟的相对差异决定是否向每台服务器发送1、2或3个请求。结果与初始的加权循环模拟非常相似，但无需预先指定每台服务器的权重。该算法还能适应服务器性能随时间的变化。这称为“动态加权循环法”。</p><p>&nbsp;</p><p>我们来看看它如何处理服务器性能和请求成本都存在很大方差的复杂情况。以下模拟使用随机值，因此请随意刷新页面几次，查看它是否适应了新的情况。</p><p>&nbsp;</p><p></p><h2>循环法以外的选项</h2><p></p><p>&nbsp;</p><p>动态加权循环似乎能很好地处理服务器性能和请求成本的方差。但我们有没有更好、更简单的算法呢？答案是肯定的。</p><p>&nbsp;</p><p>这称为“最少连接”负载均衡法。</p><p>&nbsp;</p><p>因为负载均衡器位于服务器和用户之间，所以它可以准确地跟踪每台服务器有多少未完成的请求。然后当一个新的请求进来并且该确定将它发送到哪里时，负载均衡器已经知道哪些服务器要做的工作是最少的，并且会优先考虑这些服务器。</p><p>&nbsp;</p><p>无论存在多少方差，该算法都表现得非常好。它能准确掌握每台服务器正在做什么的信息，从而消除了不确定性。而且它的另一个好处是实施起来非常简单。由于这些原因，你会发现这个算法是AWS负载均衡器的默认HTTP负载均衡方法。它也是nginx中的一个选项，如果你从未更改过它的默认设置，这个算法非常值得一试。</p><p>&nbsp;</p><p>我们来看看这个算法在类似的复杂模拟中的实际效果。这里用的参数同上面为动态加权循环算法提供的参数是一样的。同样，这些参数在给定范围内是随机的，因此请刷新页面以查看新情况。</p><p>&nbsp;</p><p>虽然这个算法在简单性和性能之间取得了很好的均衡，但它无法避免丢弃请求的情况。但是你会注意到，这个算法只有在实际上没有更多可用队列空间的状况下才会丢弃请求。它能确保所有可用资源都被用上，这让它成为了大多数工作负载的绝佳默认选项。</p><p>&nbsp;</p><p></p><h2>延迟优化</h2><p></p><p>&nbsp;</p><p>到目前为止，我一直在回避讨论的一个关键部分：我们要优化什么指标。我之前一直把放弃请求当作是很糟糕的结果，并试图避免它们。这是一个不错的目标，但它并不是我们在HTTP负载均衡器中最想优化的指标。</p><p>&nbsp;</p><p>我们更关心的指标一般是延迟。这是从创建请求到处理请求的时间，以毫秒为单位。当我们讨论延迟时，通常会谈论不同的“百分位数”。例如，第50个百分位数（也称为“中位数”）定义为50%的请求低于该值（单位为毫秒），50%的请求高于该值。</p><p>&nbsp;</p><p>我用相同的参数运行了3次模拟，持续60秒，每秒都会进行各种测量。3次模拟的差异仅来源于所使用的负载均衡算法。我们来对比3个模拟的中值：</p><p><img src=\"https://uploader.shimo.im/f/ip6iAAU0xZqHEFX9.PNG!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTU4MDM4MjEsImZpbGVHVUlEIjoibG9xZU1wcGIxTElhSjhxbiIsImlhdCI6MTY5NTgwMzUyMSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjoyNDM2MDc5MH0.TwcgwujzewlzJ4lSO0a-i9wpwUT7fevVLGp3KAj6yrc\" /></p><p>你可能没想到的是，循环法的延迟中值是最好的。如果我们不看其他数据点，得出的结论就会有问题。我们来看看第95个和第99个百分位数。</p><p><img src=\"https://uploader.shimo.im/f/TTRgpK0dzKcxG3Up.PNG!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTU4MDM4MjEsImZpbGVHVUlEIjoibG9xZU1wcGIxTElhSjhxbiIsImlhdCI6MTY5NTgwMzUyMSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjoyNDM2MDc5MH0.TwcgwujzewlzJ4lSO0a-i9wpwUT7fevVLGp3KAj6yrc\" /></p><p>注意：每种负载均衡算法的不同百分位数之间没有颜色差异。更高的百分位数在图表上总是更高的。</p><p>&nbsp;</p><p>我们看到循环法在较高的百分位数中表现不佳。可是为什么循环法的中位数表现很好，但第95个和第99个百分位数很差呢？</p><p>&nbsp;</p><p>在循环法中不考虑每台服务器的状态，因此会有相当多的请求转到空闲服务器，于是第50个百分位的延迟就很低。另一方面，算法也很乐意将请求发送到过载的服务器上，因此第95和99个百分位数很差。</p><p>&nbsp;</p><p>我们可以看看直方图形式的完整数据：</p><p><img src=\"https://uploader.shimo.im/f/boAWP1iP5IrDLH8U.PNG!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTU4MDM4MjEsImZpbGVHVUlEIjoibG9xZU1wcGIxTElhSjhxbiIsImlhdCI6MTY5NTgwMzUyMSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjoyNDM2MDc5MH0.TwcgwujzewlzJ4lSO0a-i9wpwUT7fevVLGp3KAj6yrc\" /></p><p>我为这些模拟调整了参数以避免丢弃任何请求，这样3种算法的数据点数量就是一样的。我们再次运行模拟，这次增加RPS值，目的是将所有算法推到它们可以处理的范围之外。以下是丢弃请求随时间积累的图表。</p><p><img src=\"https://uploader.shimo.im/f/0aQrwDSpEjmfkuQK.PNG!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTU4MDM4MjEsImZpbGVHVUlEIjoibG9xZU1wcGIxTElhSjhxbiIsImlhdCI6MTY5NTgwMzUyMSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjoyNDM2MDc5MH0.TwcgwujzewlzJ4lSO0a-i9wpwUT7fevVLGp3KAj6yrc\" /></p><p>最少连接算法可以更好地处理过载，但这样做的代价是95%和99%的延迟略高。根据你的用例情况，这可能是一个值得接纳的权衡。</p><p>&nbsp;</p><p></p><h2>最后一个算法</h2><p></p><p>&nbsp;</p><p>如果我们真的想针对延迟做优化，我们需要一种将延迟考虑在内的算法。如果我们可以将动态加权循环算法与最少连接算法结合起来，那不是很好吗？我们可以得到加权循环法的延迟优势和最少连接法的弹性优势。</p><p>&nbsp;</p><p>事实证明，在我们之前就有人有了这样的想法。下面是对称为“峰值指数加权移动平均值”（或PEWMA）的算法的模拟。这是一个又长又复杂的名字，但坚持住，我稍后会详细解释它的工作原理。</p><p>&nbsp;</p><p>我为这个模拟设置了特定的参数，保证它表现出预期的行为。如果你仔细观察，你会注意到算法会在一段时间后停止向最左边的服务器发送请求。它这样做是因为它发现其他服务器都更快，并且不需要向最慢的服务器发送请求——这只会导致请求有更高的延迟。</p><p>&nbsp;</p><p>那么它是如何做到的呢？它将动态加权循环与最少连接法结合了起来，并加上了一点独创的魔法。</p><p>&nbsp;</p><p>对于每台服务器，该算法会跟踪最近N个请求的延迟。算法不是用这个数据来计算平均值，而是对值求和，但比例因子呈指数下降。这会产生一个值，其中延迟时间越长，它对总和的贡献就越小。最近的请求相比老的请求对计算的影响更大。</p><p>&nbsp;</p><p>然后将该值乘以服务器的开启连接数，我们用得出来的结果值来选择将下一个请求发送到哪台服务器上。这个值越低越好。</p><p>&nbsp;</p><p>那么它是如何做比较的呢？首先，我们来看一下第50、95和99个百分位数与之前的最少连接法数据的对比。</p><p>&nbsp;</p><p><img src=\"https://uploader.shimo.im/f/AyYg6RPU5Q7jMzWy.PNG!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTU4MDM4MjEsImZpbGVHVUlEIjoibG9xZU1wcGIxTElhSjhxbiIsImlhdCI6MTY5NTgwMzUyMSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjoyNDM2MDc5MH0.TwcgwujzewlzJ4lSO0a-i9wpwUT7fevVLGp3KAj6yrc\" /></p><p>我们看到结果有了全方位的显著改善！新算法在较高的百分位数上优势更为明显，但中位数也一直有优势。下面我们来看直方图形式的相同数据。</p><p><img src=\"https://uploader.shimo.im/f/sjViCfSuWoj7765X.PNG!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTU4MDM4MjEsImZpbGVHVUlEIjoibG9xZU1wcGIxTElhSjhxbiIsImlhdCI6MTY5NTgwMzUyMSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjoyNDM2MDc5MH0.TwcgwujzewlzJ4lSO0a-i9wpwUT7fevVLGp3KAj6yrc\" /></p><p>请求丢弃的情况如何？</p><p><img src=\"https://uploader.shimo.im/f/014k184cu2fHd3mw.PNG!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTU4MDM4MjEsImZpbGVHVUlEIjoibG9xZU1wcGIxTElhSjhxbiIsImlhdCI6MTY5NTgwMzUyMSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjoyNDM2MDc5MH0.TwcgwujzewlzJ4lSO0a-i9wpwUT7fevVLGp3KAj6yrc\" /></p><p>它开始表现得更好，但随着时间的推移开始差于最少连接法，这是有道理的。PEWMA是机会主义的，因为它试图获得最佳延迟，这意味着它有时可能会让服务器负载不足。</p><p>&nbsp;</p><p>我想在这里补充一点，PEWMA有很多可以调整的参数。我为这篇文章编写的实现使用的配置似乎比较适合我的测试场景，但进一步调整参数可以获得比最少连接法更好的结果。这是PEWMA与最少连接法相比的一项劣势：额外的复杂性。</p><p>&nbsp;</p><p></p><h2>总结</h2><p></p><p>&nbsp;</p><p>我在这篇文章上花了很长时间。我们很难在现实主义与简单易懂之间取得平衡，但我对最终成文还是很满意的。我希望读者能够通过本文理解这些复杂系统在理想和不太理想的情况下，实践的行为方式，这样可以帮助大家直观地了解它们在什么情况下最适用于你的工作负载。</p><p>&nbsp;</p><p>免责声明：你一定要牢记自己的负载才是永远的基准，不要把网上看来的建议视为福音。我在这里的模拟忽略了一些现实场景中的限制（服务器启动慢、网络延迟之类），而且为了展示每个算法的特定属性做了参数调整。它们并不是反映现实情况的基准测试。</p><p>&nbsp;</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://samwho.dev/load-balancing/\">https://samwho.dev/load-balancing/</a>\"</p>",
    "publish_time": "2023-10-02 07:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Meta AI是如何在 Facebook 和 Instagram 上增强用户体验的？",
    "url": "https://www.infoq.cn/article/3CYMzjRwkdHv0jLcyGuK",
    "summary": "<p></p><blockquote>为了帮助用户更好地理解人工智能在 Instagram 和 Facebook 许多核心功能中的作用，今天我们将分享有关我们的人工智能系统运作方式的详细信息。</blockquote><p></p><p>&nbsp;</p><p>我们利用人工智能来帮助每天使用我们服务的数十亿用户发现他们可能会觉得有用和有趣的内容，无论是在 Instagram 上关注新的创作者，还是在 Facebook 上可能喜欢的帖子。</p><p>&nbsp;</p><p>我们建立这些系统的目标是确保人们看到的内容能够与他们相关并且有价值。在 Facebook 和 Instagram 上，并没有一个单一的人工智能系统来决定用户所看到的一切。相反，许多独立的人工智能系统会分别工作，有时也会共同合作，在幕后以极短的时间内无缝地提供这些体验。更深入地了解，每个人工智能系统都有多个模型，用于识别内容并预测一个人对其感兴趣或与之互动的可能性有多大。</p><p>&nbsp;</p><p>作为 Meta 对透明度的承诺的一部分，今天我们分享了 22 张系统卡，其中包含了信息和可行性见解，每个人都可以使用这些信息来理解和定制他们在我们产品中特定的人工智能驱动体验。我们发布这些卡片是为了帮助人们更好地了解人工智能在 Instagram 和 Facebook 的许多功能中的作用，并解释人们的选择和行为如何通过我们的排名和推荐系统影响他们所看到的内容，比如新的视频或他们可能想要关注的创作者。系统卡现在在我们的<a href=\"https://transparency.fb.com/features/explaining-ranking\">透明中心</a>\"（Transparency Center）提供了 22 种语言的版本。</p><p>&nbsp;</p><p>对于使用 Facebook 和 Instagram 的人来说，能够<a href=\"https://ai.facebook.com/blog/responsible-ai-progress-meta-2022/\">获得</a>\"关于支持他们体验的技术的信息非常重要。这些信息也必须以一种非专家和专家都能理解的方式提供和解释。</p><p></p><h2>Meta AI 的系统卡</h2><p></p><p>&nbsp;</p><p>我们分享了 22 张系统卡，解释了人工智能驱动的推荐系统在 Facebook 和 Instagram 上的工作方式。其中包括 14 张关于 Facebook 的系统卡，包括 Facebook Feed、Feed 推荐、Feed 排名评论、Reels、Stories、视频、通知、市场、群组 Feed、单个群组 Feed、建议的群组、搜索、可能认识的人和可能喜欢的页面。另外还有 8 张关于 Instagram 的系统卡，包括 Instagram Feed、Feed 推荐、Stories、探索、Reels 串联、搜索、建议的账号和通知。</p><p></p><p>每个人工智能系统卡都包含四个部分：</p><p>&nbsp;</p><p>人工智能系统的概述；解释人工智能系统如何工作的部分，包括创建 Facebook 和 Instagram 体验的步骤概述；描述如何定制显示的内容的部分。包括系统控制的描述和每个人如何控制和定制他们的体验的说明；解释人工智能如何提供内容的部分，包括解释一些重要的预测模型如何影响整体人工智能系统并产生产品体验的说明。</p><p></p><p>人工智能系统的预测模型可能会使用一些信息，例如帖子的特征和一个人与类似帖子的互动历史，来预测兴趣水平。在 Facebook 和 Instagram 上有成千上万个这样的信号被使用。</p><p>&nbsp;</p><p>例如，当预测一个人是否会与一篇帖子互动时，人工智能系统会考虑以下信号：</p><p>&nbsp;</p><p>帖子或视频获得的赞数、评论数和观看次数；一个人观看视频或查看帖子的频率或时间长度；一个人与某个作者的互动情况，比如他们以前见过和喜欢过该作者的类似帖子的次数。</p><p>&nbsp;</p><p>重要的是，我们的系统卡还描述了每个人工智能系统的控制选项，人们可以使用这些选项来定制他们的体验。例如，如果有人想要看到某种类型的帖子更少，他们可以取消关注该作者，暂时隐藏内容，或在 Facebook 上点击 “Show less”（显示更少），在 Instagram 上点击 “Not interested”（不感兴趣），以临时降低类似内容的排名分数。</p><p></p><h2>我们创建系统卡的方法</h2><p></p><p>&nbsp;</p><p>在创建这些系统卡时，我们面临的最大挑战之一是找到以一种每个人都能理解的方式解释高度技术性信息的最佳方法。由于目前没有行业标准的方法，因此我们在 Meta 公司内部创建了一个<a href=\"https://ai.facebook.com/research/publications/system-level-transparency-of-machine-learning\">统一的方法</a>\"来解释这些系统。通过倾听我们的服务用户的意见，并与设计和开发过程中的多元化专家群体进行交流，我们获得了有助于确定如何以有意义的方式呈现这些信息的见解。我们听到人们希望能够更透明地了解和控制他们所看到的内容，因此我们在每个系统卡中添加了一个定制部分。我们还了解到，给人们过多的技术细节有时会模糊透明度，这就是为什么我们只呈现了最重要的十个预测模型，而不是系统中的全部内容。</p><p>&nbsp;</p><p>为了保持我们的方法一致，我们选择了一套术语词汇，用于讨论人工智能。在解释可能不熟悉的术语时，我们会包含一个工具提示，提醒人们我们所说的 “相关内容” 和 “人工智能系统” 的含义。通过采用一致的语言方法，我们使人们能够比较和对比多个系统卡。</p><p>&nbsp;</p><p>为了保持系统卡中解释我们的人工智能系统如何工作和提供内容的各个部分的一致性，我们开发了内部工具来分析构成人工智能系统的模型的影响。在我们工程师的帮助下，我们将这些信息从信号转化为文字，以帮助解释每个人工智能系统如何进行预测。值得注意的是，这些模型和信号是动态的，随着系统的学习而改变，并且随着时间的推移会经常发生变化。</p><p></p><h2>人工智能系统卡的未来</h2><p></p><p>&nbsp;</p><p>随着行业的发展和对系统文档和透明度的讨论的继续，我们将进一步识别机会，随着时间的推移对我们的方法进行迭代，以便反映产品的变化、不断发展的行业标准以及对人工智能透明度的期望。</p><p>&nbsp;</p><p>我们将继续整合来自多样化受众的反馈，改进我们的产品并赋予使用者更多权力。在我们的研究中，我们了解到人们希望在提供的信息与他们相关时，以文字和视觉的结合方式来探索系统卡，因此我们正在不断改进系统卡。</p><p>&nbsp;</p><p>人们可以通过访问我们的<a href=\"https://transparency.fb.com/features/explaining-ranking\">透明中心</a>\"找到我们的系统卡。我们希望这一努力能鼓励人们更多地了解 AI 如何支持他们的体验。我们相信，系统卡将使人们能够学习有关人工智能的知识，并控制和定制他们在使用我们产品时的体验。</p><p>&nbsp;</p><p>原文链接：</p><p>&nbsp;</p><p>https://ai.meta.com/blog/how-ai-powers-experiences-facebook-instagram-system-cards/</p>",
    "publish_time": "2023-10-02 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "JVM语言比较研究：Java、Kotlin 和Scala的利与弊",
    "url": "https://www.infoq.cn/article/ThrjTB6kHMdXmjIPeaEv",
    "summary": "<p>在编程世界中，下划线（ '_ '）是一个用途广泛的字符。它通常被称为语法糖，因为它简化了代码，使其更加简洁。</p><p>&nbsp;</p><p>本文将探讨下划线在三种流行编程语言中的使用：Java、Kotlin和Scala。</p><p>&nbsp;</p><p></p><h2>Java：使用JEP443的未命名模式和变量</h2><p></p><p>&nbsp;</p><p>随着JEP443的引入，不断发展的Java语言在增强代码可读性和可维护性方面又迈出了重要的一步。这个名为“未命名模式和变量（预览版本）”的提案已经从JDK21的Targeted状态提成到Completed状态。</p><p>&nbsp;</p><p>该JEP旨在通过未命名的模式和未命名的变量来增强语言，未命名模式匹配记录组件而无需声明组件的名称或类型，未命名的变量可以被初始化但不使用。</p><p>&nbsp;</p><p>这两者都是用下划线字符表示的，如 r instanceof _(int x, int y) and r instanceof _ 。</p><p>&nbsp;</p><p></p><h3>未命名模式</h3><p></p><p>未命名模式旨在简化数据处理，尤其是在处理记录类时。它们允许开发人员在模式匹配中省略记录组件的类型和名称，这可以显著地提高代码的可读性。</p><p>&nbsp;</p><p>考虑如下的代码片段：</p><p>&nbsp;</p><p><code lang=\"null\">if (r instanceof ColoredPoint(Point p, Color c)) {\n    // ...\n}</code></p><p>&nbsp;</p><p>如果 if 块中不需要 Color c 组件，则将其包含在模式中可能会很徒劳并且也不清楚。使用JEP 443，开发人员可以简单地省略不必要的组件，从而生成更干净、更可读的代码：</p><p>&nbsp;</p><p><code lang=\"null\">if (r instanceof ColoredPoint(Point p, _)) {\n    // ...\n}</code></p><p>&nbsp;</p><p>在只需记录类的某些组件的嵌套模式匹配场景中，这一特性特别有用。例如，考虑一个包含 Point 和 Color 的记录类 ColoredPoint 。如果只需要点的 x 坐标，可以使用未命名模式来省略 y 和 Color 组件：</p><p>&nbsp;</p><p><code lang=\"null\">if (r instanceof ColoredPoint(Point(int x, _), _)) {\n    // ...\n}</code></p><p>&nbsp;</p><p></p><h3>未命名变量</h3><p></p><p>当必须声明变量，但又不使用其值时，未命名变量会非常有用。这在循环、try-with-resources语句、catch块和lambda表达式中很常见。</p><p>&nbsp;</p><p>例如，考虑以下的循环：</p><p>&nbsp;</p><p><code lang=\"null\">for (Order order : orders) {\n    if (total &lt; limit) total++;\n}</code></p><p>&nbsp;</p><p>在本例中，在循环中没有使用 order 变量。使用JEP 443，开发人员可以用下划线替换未使用的变量，使代码更加简洁明了：</p><p>&nbsp;</p><p><code lang=\"null\">for (_ : orders) {\n    if (total &lt; limit) total++;\n}</code></p><p>&nbsp;</p><p>在 switch 语句中，未命名变量也很有用，在这种语句中，对多种情况执行相同的操作，并且不使用变量。例如：</p><p>&nbsp;</p><p><code lang=\"null\">switch (b) {\n    case Box(RedBall _), Box(BlueBall _) -&gt; processBox(b);\n    case Box(GreenBall _) -&gt; stopProcessing();\n    case Box(_) -&gt; pickAnotherBox();\n}</code></p><p>&nbsp;</p><p>在本例中，前两中情况使用未命名的模式变量，因为它们的右侧没有使用Box的组件。第三种情况使用未命名模式来匹配具有空（null）的Box组件。</p><p>&nbsp;</p><p></p><h3>启用预览特性</h3><p></p><p>&nbsp;</p><p>未命名模式和变量是预览特性，默认情况下处于禁用状态。要使用它，开发人员必须启用预览特性来编译代码才行，命令如下所示：</p><p>&nbsp;</p><p><code lang=\"null\">javac --release 21 --enable-preview Main.java</code></p><p>&nbsp;</p><p>运行程序也需要相同的标志：</p><p>&nbsp;</p><p><code lang=\"null\">java --enable-preview Main</code></p><p>&nbsp;</p><p>但是，可以使用源代码启动器直接运行该程序。在这种情况下，命令行如下：</p><p>&nbsp;</p><p><code lang=\"null\">java --source 21 --enable-preview Main.java</code></p><p>&nbsp;</p><p>jshell 选项也是可用的，但它也需要启用预览特性：</p><p>&nbsp;</p><p><code lang=\"null\">jshell --enable-preview</code></p><p>&nbsp;</p><p></p><h2>Kotlin：下划线表示未使用的参数</h2><p></p><p>在Kotlin中，下划线字符（ _ ）用于表示函数、lambda或析构函数声明中未使用的参数。此特性允许开发人员省略此类参数的名称，从而生成更干净、更简洁的代码。</p><p>&nbsp;</p><p>在Kotlin中，如果lambda的参数未使用，开发人员可以使用下划线来代替其名称。这在处理带有多个参数但只需其中某些参数的lambda函数时特别有用。</p><p>&nbsp;</p><p>考虑如下的Kotlin代码片段：</p><p>&nbsp;</p><p><code lang=\"null\">mapOf(1 to \"one\", 2 to \"two\", 3 to \"three\")\n   .forEach { (_, value) -&gt; println(\"$value!\") }</code></p><p>&nbsp;</p><p>在本例中， forEach 函数需要一个lambda，它接受两个参数：一个 key 和一个 value 。但是，我们只对 value 感兴趣，所以我们将 key 参数替换为下划线。</p><p>&nbsp;</p><p>让我们考虑另一个代码片段：</p><p>&nbsp;</p><p><code lang=\"null\">var name: String by Delegates.observable(\"no name\") {\n    kProperty, oldValue, newValue -&gt; println(\"$oldValue\")\n}</code></p><p>&nbsp;</p><p>在这种情况下，如果在lambda中不使用 kProperty 和 newValue 参数，那么将它们包括在内可能会徒劳且不清楚。使用下划线特性，开发人员可以简单地用下划线替换未使用的参数：</p><p>&nbsp;</p><p><code lang=\"null\">var name: String by Delegates.observable(\"no name\") {\n    _, oldValue, _ -&gt; println(\"$oldValue\")\n}</code></p><p>&nbsp;</p><p>该特性在想要跳过某些组件的析构函数声明中也很有用：</p><p>&nbsp;</p><p><code lang=\"null\">val (w, x, y, z) = listOf(1, 2, 3, 4)\nprint(x + z) // 'w'和'y'未被使用</code></p><p>&nbsp;</p><p>使用下划线特性，开发人员可以用下划线替换未使用的组件：</p><p>&nbsp;</p><p><code lang=\"null\">val (_, x, _, z) = listOf(1, 2, 3, 4)\nprint(x + z)</code></p><p>&nbsp;</p><p>该特性并非Kotlin所独有。Haskell等其他语言在模式匹配中使用下划线字符作为通配符。对于C#来说，lambdas中的“ _ ”只是一个习语，在语言中没有特殊处理。在Java的未来版本中可能也会应用相同的语义。</p><p>&nbsp;</p><p></p><h2>Scala：下划线的多功能性</h2><p></p><p>在Scala中，下划线（ _ ）是一个用途广泛的通用字符。然而，这有时会导致混乱，并增加Scala新人的学习曲线。在本节中，我们将探讨Scala中下划线的不同用法和最常见的用法。</p><p>&nbsp;</p><p></p><h3>模式匹配和通配符</h3><p></p><p>下划线被广泛用作通配符，用于匹配未知模式。这可能是Scala开发人员遇到的首个下划线用法。</p><p>&nbsp;</p><p></p><h3>模块导入</h3><p></p><p>在导入包时，我们使用下划线来指示应该导入模块的所有或部分成员：</p><p>&nbsp;</p><p><code lang=\"null\">//导入包junit的所有成员。（相当于java中使用通配符*的导入）\nimport org.junit._\n\n\n// 导入junit中除Before之外的所有成员。\nimport org.junit.{Before =&gt; _, _}\n\n\n// 导入junit的所有成员，但将Before重命名为B4。\nimport org.junit.{Before =&gt; B4, _}</code></p><p>&nbsp;</p><p></p><h3>存在类型（Existential Type）</h3><p></p><p>下划线还用作通配符，用于匹配类型创建器中的所有类型，如List、Array、Seq、Option或Vector。</p><p>&nbsp;</p><p><code lang=\"null\">// 在List中使用下划线\nval list: List[_] = List(1, \"two\", true)\nprintln(list)\n\n\n// 在Array中使用下划线\nval array: Array[_] = Array(1, \"two\", true)\nprintln(array.mkString(\"Array(\", \", \", \")\"))\n\n\n// 在Seq中使用下划线\nval seq: Seq[_] = Seq(1, \"two\", true)\nprintln(seq)\n\n\n// 在Option中使用下划线\nval opt: Option[_] = Some(\"Hello\")\nprintln(opt)\n\n\n// 在Vector中使用下划线\nval vector: Vector[_] = Vector(1, \"two\", true)\nprintln(vector)</code></p><p>&nbsp;</p><p>使用_ ，我们允许所有类型的元素进入内链表。</p><p>&nbsp;</p><p></p><h3>匹配</h3><p></p><p>&nbsp;</p><p>使用match关键字，开发人员可以使用下划线来捕获任何已定义的用例无法处理的所有可能情况。例如，给定一个商品的价格，购买或出售该商品的决定是基于某些特殊价格做出的。如果价格是130，该商品就可以购买，但如果价格是150，该商品就要出售。除上述价格外，其他价格都需要获得批准：</p><p>&nbsp;</p><p><code lang=\"null\">def itemTransaction(price: Double): String = {\n price match {\n   case 130 =&gt; \"Buy\"\n   case 150 =&gt; \"Sell\"\n\n\n   // 如果价格不是130和150中的任何一个，则执行这一情况\n   case _ =&gt; \"Need approval\"\n }\n}\n\n\nprintln(itemTransaction(130)) // 购买\nprintln(itemTransaction(150)) // 出售\nprintln(itemTransaction(70))  // 需要批准\nprintln(itemTransaction(400)) // 需要批准</code></p><p>&nbsp;</p><p></p><h3>忽略事物</h3><p></p><p>下划线可以忽略代码中未使用的变量和类型。</p><p>&nbsp;</p><p>忽略参数</p><p>&nbsp;</p><p>例如，在函数执行中，开发人员可以使用下划线来隐藏未使用的参数：</p><p>&nbsp;</p><p><code lang=\"null\">val ints = (1 to 4).map(_ =&gt; \"Hello\")\nprintln(ints) // Vector(Hello, Hello, Hello, Hello)</code></p><p>&nbsp;</p><p>开发人员还可以使用下划线来访问嵌套集合：</p><p>&nbsp;</p><p><code lang=\"null\">val books = Seq((\"Moby Dick\", \"Melville\", 1851), (\"The Great Gatsby\", \"Fitzgerald\", 1925), (\"1984\", \"Orwell\", 1949), (\"Brave New World\", \"Huxley\", 1932))\n\n\nval recentBooks = books\n .filter(_._3 &gt; 1900)  // 只筛选1900年以后出版的书\n .filter(_._2.startsWith(\"F\"))  // 只筛选作者名字以“F”开头的书。\n// 只返回元组的第一个元素；书名\n\n\nprintln(recentBooks) // List(The Great Gatsby)</code></p><p>&nbsp;</p><p>在本例中，下划线用于引用列表中元组的元素。 filter 函数只筛选满足给定条件的图书，然后 map 函数将元组转换为它们的第一个元素（书名）。结果是一个包含符合标准书名的序列。</p><p>&nbsp;</p><p>忽略变量</p><p>&nbsp;</p><p>当开发人员遇到不必要或不相关的细节时，他们可以使用下划线来忽略它们。</p><p>&nbsp;</p><p>例如，开发人员只想要拆分字符串中的第一个元素：</p><p>&nbsp;</p><p><code lang=\"null\">val text = \"a,b\"\nval Array(a, _) = text.split(\",\")\nprintln(a)</code></p><p>&nbsp;</p><p>如果开发人员只想考虑构造中的第二个元素，那么同样的原则也适用。</p><p>&nbsp;</p><p><code lang=\"null\">val Array(_, b) = text.split(\",\")\nprintln(b)</code></p><p>&nbsp;</p><p>这一原则实际上可以扩展到两个以上的条目。例如，考虑下面的示例：</p><p>&nbsp;</p><p><code lang=\"null\">val text = \"a,b,c,d,e\"\nval Array(a, _*) = text.split(\",\")\nprintln(a)</code></p><p>&nbsp;</p><p>在本例中，开发人员将文本拆分成一个元素数组。然而，他们只对第一个元素 a 感兴趣。带星号的下划线（ _* ）会忽略数组中的其余条目，只关注所需的元素。</p><p>&nbsp;</p><p>为了忽略第一个条目之后的其余条目，我们将下划线与 “* ”一起使用。</p><p>&nbsp;</p><p>下划线也可以用于随机忽略：</p><p>&nbsp;</p><p><code lang=\"null\">val text = \"a,b,c,d,e\"\nval Array(a, b, _, d, e) = text.split(\",\")\nprintln(a)\nprintln(b)\nprintln(d)\nprintln(e)</code></p><p>&nbsp;</p><p>初始化为变量的默认值</p><p>&nbsp;</p><p>当变量的初始值不是必需的时候，则可以使用下划线来作为默认值：</p><p>&nbsp;</p><p><code lang=\"null\">var x: String = _\nx = \"real value\"\nprintln(x) // 真实值</code></p><p>&nbsp;</p><p>然而，这并不适用于局部变量；局部变量必须要初始化。</p><p>&nbsp;</p><p></p><h3>转换</h3><p></p><p>可以通过多种方式在转换中使用下划线。</p><p>&nbsp;</p><p>函数重新分配（Eta扩展）</p><p>&nbsp;</p><p>使用下划线，可以将方法转换为函数。这对于将函数作为首选值来传递非常有用。</p><p>&nbsp;</p><p><code lang=\"null\">def greet(prefix: String, name: String): String = s\"$prefix $name\"\n\n\n// Eta扩展，将greet变成一个函数\nval greeting = greet _\n\n\nprintln(greeting(\"Hello\", \"John\"))</code></p><p>&nbsp;</p><p>可变参数序列</p><p>&nbsp;</p><p>序列可以使用 seqName:_* （类型归属的特殊实例）转换为可变参数。</p><p>&nbsp;</p><p><code lang=\"null\">def multiply(numbers: Int*): Int = {\n numbers.reduce(_ * _)\n}\n\n\nval factors = Seq(2, 3, 4)\nval product = multiply(factors: _*)\n//使用factors: _*将Seq元素转换为变量\n\n\nprintln(product) // 应该打印：24</code></p><p>&nbsp;</p><p>部分应用函数</p><p>&nbsp;</p><p>通过在函数中只提供所需参数的一部分，并将其余部分留待稍后传递，开发人员可以创建所谓的部分应用函数（Partially-Applied Function）。用下划线替代尚未提供的参数。</p><p>&nbsp;</p><p><code lang=\"null\">def sum(x: Int, y: Int): Int = x + y\nval sumToTen = sum(10, _: Int)\nval sumFiveAndTen = sumToTen(5)\n\n\nprintln(sumFiveAndTen, 15)</code></p><p>&nbsp;</p><p>在部分应用函数中使用下划线也可以被归类为忽略事物。开发人员可以忽略具有多个参数组的函数中的整组参数，从而创建一种特殊类型的部分应用函数：</p><p>&nbsp;</p><p><code lang=\"null\">def bar(x: Int, y: Int)(z: String, a: String)(b: Float, c: Float): Int = x\nval foo = bar(1, 2) _\n\n\nprintln(foo(\"Some string\", \"Another string\")(3 / 5, 6 / 5), 1)</code></p><p>&nbsp;</p><p>赋值运算符（Setter重写）</p><p>&nbsp;</p><p>可以认为重写默认的setter是一种使用下划线的转换：</p><p>&nbsp;</p><p><code lang=\"null\">class User {\n private var pass = \"\"\n def password = pass\n def password_=(str: String): Unit = {\n   require(str.nonEmpty, \"Password cannot be empty\")\n   require(str.length &gt;= 6, \"Password length must be at least 6 characters\")\n   pass = str\n }\n}\n\n\nval user = new User\nuser.password = \"Secr3tC0de\"\nprintln(user.password) // 应该打印：\"Secr3tC0de\"\n\n\ntry {\n user.password = \"123\" //将会失败，应为它少于6个字符\n println(\"Password should be at least 6 characters\")\n} catch {\n case _: IllegalArgumentException =&gt; println(\"Invalid password\")\n}</code></p><p>&nbsp;</p><p></p><h3>高阶类型（Higher-Kinded Type）</h3><p></p><p>高阶类型（Higher-Kinded Type）是对某种类型进行抽象，而这种类型又对另一种类型进行抽象。通过这种方式，Scala可以跨类型构造函数进行泛化。它与存在类型（Existential Type）非常相似。可以使用下划线定义高阶类型：</p><p>&nbsp;</p><p><code lang=\"null\">trait Wrapper[F[_]] {\n def wrap[A](value: A): F[A]\n}\n\n\nobject OptionWrapper extends Wrapper[Option] {\n override def wrap[A](value: A): Option[A] = Option(value)\n}\n\n\nval wrappedInt = OptionWrapper.wrap(5)\nprintln(wrappedInt)\n\n\nval wrappedString = OptionWrapper.wrap(\"Hello\")\nprintln(wrappedString)</code></p><p>&nbsp;</p><p>在上面的例子中， Wrapper 是一个具有高阶类型参数 F[_] 的trait。它提供了一个方法 wrap ，用于将值包装到给定的类型中。 OptionWrapper 是为 Option 类型扩展此trait的对象。 F[_] 中的下划线表示任何类型，使 Wrapper 在所有 Option 类型中都是通用的。</p><p>&nbsp;</p><p>这些例子都说明了Scala是一个强大的工具，它可以通过各种方式来简化和提高代码的可读性。这一特性非常符合Scala的理念，即成为一种简洁而富有表现力的语言，促进代码的可读性和可维护性。</p><p>&nbsp;</p><p></p><h2>结论</h2><p></p><p>通过JEP 443在Java中引入未命名的模式和变量，标志着该语言发展的一个重要里程碑。该特性允许开发人员通过省略不必要的组件并替换未使用的变量来简化代码，使Java更接近Kotlin和Scala等语言的表达力和多功能性。</p><p>&nbsp;</p><p>然而，需要注意的是，尽管这是向前迈出的重要一步，但Java在这一领域的历程仍然不完整。Kotlin和Scala等语言长期以来一直采用类似的概念，并以各种方式使用它们来增强代码的可读性、可维护性和简洁性。这些语言已经证明了这些概念在使代码更高效、更容易理解方面的力量。</p><p>&nbsp;</p><p>相比之下，Java目前对未命名模式和变量的使用虽然有益，但仍有一定的局限性。Java进一步利用这些概念的潜力巨大。该语言的未来更新可能会包含更多对未命名模式和变量的高级使用，从Kotlin和Scala等语言中汲取如何使用这些概念的灵感。</p><p>&nbsp;</p><p>尽管如此，在Java中采用未命名的模式和变量是提高语言表达性和可读性的重要一步。随着Java的不断发展和壮大，我们希望看到这些概念的进一步创新使用，从而产生更高效和更可维护的代码。这段旅程还在继续，成为Java社区的一员是一个激动人心的时刻。</p><p>&nbsp;</p><p>编码快乐！</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/comparative-study-java-kotlin-scala/\">https://www.infoq.com/articles/comparative-study-java-kotlin-scala/</a>\"</p>",
    "publish_time": "2023-10-02 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]