[
  {
    "title": "字节开源基于 Rust 打包工具 Rspack，比 Webpack 快了10倍",
    "url": "https://www.infoq.cn/article/quSeDMzURbsu8eysjKPZ",
    "summary": "<p>字节跳动近期与 <a href=\"https://valor-software.com/\">Valor 软件</a>\"开源了 <a href=\"https://valor-software.com/press-release/rs-pack-rust-based-web-bundler\">Rspack</a>\"，这是一款由 Rust 编写的&nbsp;Web 捆绑，意在用更快、更直接的方式取代 Webpack。部分早期基准测试表明，Rspack 的冷启动时间有十倍的提升。字节跳动对其的开发主要为缓解 Rspack 在部分场景下生产构建时间长达十分钟至半小时，冷启动时间可超数分钟的问题。为降低迁移成本并维持 Webpack 配置机制所提供的灵活性和生产优化，Rspack 的<a href=\"https://github.com/web-infra-dev/rspack\">功能</a>\"设计如下：</p><p>&nbsp;</p><p></p><blockquote>快速启动：基于 Rust 的飞快构建速度，为你带来极致的开发体验。&nbsp;模块热替换 (HMR)：内置增量编译机制让 HMR 速度飞快的同时 ，也完全能胜任大型应用的开发&nbsp;与 Webpack 的互操作性：与 Webpack 架构和生态系统相兼容，无需重新建立生态系统&nbsp;内含电池：开箱即用的 TypeScript、JSX、CSS、CSS Modules、Sass 等支持&nbsp;生产优化：内置多项默认优化策略，如摇树优化、最小化等等&nbsp;框架无关：不受限于任何前端框架，确保足够的灵活性</blockquote><p></p><p>&nbsp;</p><p>速度的观测结果取决于设备、项目结构及规模。字节跳动是通过公开可用的 <a href=\"https://webpack.github.io/benchmark/\">Webpack 基准测试工具</a>\"，于<a href=\"https://github.com/web-infra-dev/bundler-benchmark\">自定义代码库</a>\"中进行的基准测试。基准测试结果显示 Rspack 冷启动时间经过开发优化，相较使用 Babel 的 Webpack <a href=\"https://www.rspack.dev/misc/benchmark.html#data\">提升了十倍有余</a>\"，增量构建时间<a href=\"https://www.rspack.dev/misc/benchmark.html#data-1\">提升三倍</a>\"。Nx 在其他代码库中也<a href=\"https://www.youtube.com/watch?v=jGTE7xAcg24\">展示了类似的结果</a>\"：</p><p>&nbsp;</p><p></p><blockquote>我们自行进行了初步的统计，也看到了一些很赞的改善。对大型组件而言，Rspack 的部署时间比 Webpack 快四倍，开发服务器的启动速度比目前 Webpack 的实现快五倍，总体生产构建的速度有了四倍的提升。</blockquote><p></p><p>&nbsp;</p><p>Rspack 虽然只在近期才开源，但其开发时长已有一年了。但不管怎么说，该项目仍处于早期阶段，缺乏许多 Webpack 的功能。Rspack 团队强调他们计划进一步加强对 Webpack 生态系统的支持：</p><p>&nbsp;</p><p></p><blockquote>Rspack 与 Webpack 的配置模式和 Loader 架构，人们可无缝使用熟悉的 Loader，如babel-loader、less-loader、sass-loader 等等。我们的长期目标是为完全支持最为常用的 Loader，包括更为复杂的 vue-loader 等情况。但要想实现 Webpack 的全部功能，我们还任重而道远。我们会基于社区反馈排列优先级，所以请告诉我们您的需求！</blockquote><p></p><p>&nbsp;</p><p>Rspack 最初是由字节跳动内部开发团队发起，<a href=\"https://internaldeveloperplatform.org/what-is-an-internal-developer-platform/#:~:text=An%20Internal%20Developer%20Platform%20%28IDP%29%20is%20built%20by%20a%20platform,away%20context%20and%20underlying%20technologies.\">内部开发者平台</a>\"或一般平台工程团队正逐渐成为企业 DevOps 实践的一部分。</p><p>&nbsp;</p><p>越来越多的 Web 工具链开始使用 Rust 来大幅提升其性能。热门的 Parcel 捆绑于<a href=\"https://parceljs.org/blog/parcel-css/\">去年宣发</a>\"了一款使用 Rust 编写的新 CSS 解析器、编译器、粉碎器（比基于 JavaScript 的 CSSNano 快百倍，比基于 Go 的 ESBuild 快三倍）。两年前，Parcel 2 便已经<a href=\"https://www.infoq.com/news/2021/09/parcel-2-rust-faster-javascript/\">用 Rust 对其 JavaScript 编译器进行了重写</a>\"（构建性能提升十倍）前端工具链 Rome 于几个月前<a href=\"https://www.infoq.com/news/2022/11/rome-v10-stable-release-linter/\">发布了一款基于 Rust 的新代码质量规则和格式化器</a>\"，相比&nbsp;<a href=\"https://eslint.org/\">ESLint</a>\"&nbsp;和 <a href=\"https://prettier.io/\">Prettier</a>\" 有一至二个数量级的提升。<a href=\"https://github.com/rolldown-rs/rolldown\">Rolldown</a>\" 是另一项进行中的项目，可提供与 Rollup 相兼容的 API。</p><p>&nbsp;</p><p><a href=\"https://webpack.js.org/\">Webpack</a>\"、<a href=\"https://parceljs.org/\">Parcel</a>\"、<a href=\"https://rollupjs.org/\">Rollup</a>\"，这些均是用于构建 Web 应用程序的最热门捆绑器。Rspack 是在 MIT 许可下发布的开源软件，欢迎反馈，但也应遵守<a href=\"https://github.com/web-infra-dev/rspack/blob/main/CONTRIBUTING.md\">贡献指南</a>\"和<a href=\"https://github.com/web-infra-dev/rspack/blob/main/CODE_OF_CONDUCT.md\">行为准则</a>\"。</p><p>&nbsp;</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/04/rust-rspack-webpack-compatible/\">New Rust-Based Web Bundler Rspack Touts up to 10X Speed Improvement over Webpack</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/KJRrxY9aTGfM33L2XSGx\">Vite 4 发布，用更快的 SWC 替换了 Babel</a>\"</p><p><a href=\"https://www.infoq.cn/article/iKecr1k4eQMMpCaaXEDr\">Webpack 创始人推出比 Webpack“快 700 倍”的 Turbopack，基于 Rust 编写</a>\"</p><p></p>",
    "publish_time": "2023-04-14 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Web框架Astro 2.0发布，在静态和动态渲染之外提供了混合渲染能力",
    "url": "https://www.infoq.cn/article/YMYGqq5x3i5P6klPGRkf",
    "summary": "<p>Web框架Astro最近发布了<a href=\"https://astro.build/blog/astro-2/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODE0NTI0NzIsImZpbGVHVUlEIjoic2QyejVUd0FLSGdpVFdBayIsImlhdCI6MTY4MTQ1MjE3MiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NjM1Mzc3OX0.BuctF_SltTxXOIKfhgJ9AV3fJnNLrdxVAh4W8W-8_LE\">2.0版本</a>\"，在原先的静态和动态服务器渲染功能之上提供了新的混合渲染功能。混合渲染可用于渲染特定页面，以此来获得更高的渲染性能。</p><p></p><p>Astro Web框架旨在普及一种叫作“<a href=\"https://docs.astro.build/en/concepts/islands/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODE0NTI0NzIsImZpbGVHVUlEIjoic2QyejVUd0FLSGdpVFdBayIsImlhdCI6MTY4MTQ1MjE3MiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NjM1Mzc3OX0.BuctF_SltTxXOIKfhgJ9AV3fJnNLrdxVAh4W8W-8_LE\">组件岛</a>\"”的前端架构，这也是Astro推出混合渲染的动机：</p><p></p><p></p><blockquote>在将近一年的时间里，Astro都只允许用户在静态（SSG）和服务器（SSR）渲染之间二选一。静态网站提供了令人难以置信的性能，但缺少为不同请求按需生成HTML的能力。Astro 2.0的混合渲染把这两种渲染能力结合在了一起。将静态和动态内容混合在一起可以带来新的可能性：1. 提高热度页面的渲染性能；2. 提高大型站点的构建性能；3. 向已有的静态站点中加入API。</blockquote><p></p><p></p><p>在之前的版本中，使用Astro的开发人员必须在静态渲染（针对静态的、内容主导的网站）或服务器端渲染之间做出选择。有了混合渲染，开发人员可以在构建时预渲染特定的页面或服务器端点，无需放弃已部署的服务器。</p><p></p><p>大型网站通常有适合使用预渲染技术生成内容的部分，也有需要在请求时生成内容的部分。例如，电子商务网站会预先渲染主页和各种以营销为重点的内容，而产品、价格或折扣页面则使用服务器端渲染，以呈现最新可用的数据。这种混合方法可能会降低渲染网页所需的计算资源量和相关的成本。</p><p></p><p>对于使用<a href=\"https://jamstack.org/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODE0NTI0NzIsImZpbGVHVUlEIjoic2QyejVUd0FLSGdpVFdBayIsImlhdCI6MTY4MTQ1MjE3MiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NjM1Mzc3OX0.BuctF_SltTxXOIKfhgJ9AV3fJnNLrdxVAh4W8W-8_LE\">Jamstack</a>\"的大型站点，比较有价值的是<a href=\"https://www.smashingmagazine.com/2021/04/incremental-static-regeneration-nextjs/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODE0NTI0NzIsImZpbGVHVUlEIjoic2QyejVUd0FLSGdpVFdBayIsImlhdCI6MTY4MTQ1MjE3MiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NjM1Mzc3OX0.BuctF_SltTxXOIKfhgJ9AV3fJnNLrdxVAh4W8W-8_LE\">增量静态生成</a>\"，这是由应用程序框架Next.js推广的一种渲染方式。</p><p></p><p>Astro新版本还提供了重新设计的错误叠加，改进了对开发阶段模块热加载的支持，并使用了<a href=\"https://www.infoq.com/news/2022/12/vite-4-faster-swc?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODE0NTI0NzIsImZpbGVHVUlEIjoic2QyejVUd0FLSGdpVFdBayIsImlhdCI6MTY4MTQ1MjE3MiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NjM1Mzc3OX0.BuctF_SltTxXOIKfhgJ9AV3fJnNLrdxVAh4W8W-8_LE\">新发布的Vite 4.0</a>\"来构建内容。</p><p></p><p>Astro是一个旨在为以内容为中心的网站提升用户体验的Web框架。为此，Astro尽可能少向客户端发送JavaScript，确保页面的交互性是可用的。对于完全静态的页面，根本不发送JavaScript。Astro为此提出了“组件岛”架构。Web页面被划分为静态HTML内容，其中穿插着称为Astro岛的交互式UI组件。组件岛是独立渲染的，可以使用任意的UI框架（例如，React、Preact、Svelte、Vue、Solid、Lit）。</p><p></p><p>Astro宣称自己是“专为速度而设计的一体化Web框架”。其基准测试（基于<a href=\"https://developer.chrome.com/docs/crux/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODE0NTI0NzIsImZpbGVHVUlEIjoic2QyejVUd0FLSGdpVFdBayIsImlhdCI6MTY4MTQ1MjE3MiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NjM1Mzc3OX0.BuctF_SltTxXOIKfhgJ9AV3fJnNLrdxVAh4W8W-8_LE\">Chrome用户体验报告[CrUX]</a>\"、<a href=\"https://httparchive.org/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODE0NTI0NzIsImZpbGVHVUlEIjoic2QyejVUd0FLSGdpVFdBayIsImlhdCI6MTY4MTQ1MjE3MiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NjM1Mzc3OX0.BuctF_SltTxXOIKfhgJ9AV3fJnNLrdxVAh4W8W-8_LE\">The HTTP Archive</a>\"和<a href=\"https://discuss.httparchive.org/t/new-dashboard-the-core-web-vitals-technology-report/2178?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODE0NTI0NzIsImZpbGVHVUlEIjoic2QyejVUd0FLSGdpVFdBayIsImlhdCI6MTY4MTQ1MjE3MiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NjM1Mzc3OX0.BuctF_SltTxXOIKfhgJ9AV3fJnNLrdxVAh4W8W-8_LE\">核心Web重要技术报告</a>\"）报告显示，Astro的性能优于其他Web框架（Sveltekit、Gatsby、Remix、WordPress、Next、Nuxt）。</p><p></p><p>Astro是一个采用了MIT许可的<a href=\"https://github.com/withastro/astro?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODE0NTI0NzIsImZpbGVHVUlEIjoic2QyejVUd0FLSGdpVFdBayIsImlhdCI6MTY4MTQ1MjE3MiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NjM1Mzc3OX0.BuctF_SltTxXOIKfhgJ9AV3fJnNLrdxVAh4W8W-8_LE\">开源项目</a>\"。欢迎开发者参与<a href=\"https://github.com/withastro/astro/blob/main/CONTRIBUTING.md?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODE0NTI0NzIsImZpbGVHVUlEIjoic2QyejVUd0FLSGdpVFdBayIsImlhdCI6MTY4MTQ1MjE3MiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NjM1Mzc3OX0.BuctF_SltTxXOIKfhgJ9AV3fJnNLrdxVAh4W8W-8_LE\">贡献和反馈</a>\"。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/04/astro-2-hybrid-rendering/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODE0NTI0NzIsImZpbGVHVUlEIjoic2QyejVUd0FLSGdpVFdBayIsImlhdCI6MTY4MTQ1MjE3MiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NjM1Mzc3OX0.BuctF_SltTxXOIKfhgJ9AV3fJnNLrdxVAh4W8W-8_LE\">https://www.infoq.com/news/2023/04/astro-2-hybrid-rendering/</a>\"</p><p></p><p></p><h5>相关阅读：</h5><p></p><p><a href=\"https://xie.infoq.cn/article/65c7f0e0e3d4a90e8d80bae35\">Web 前端开发最好用的几个 WebGL 框架</a>\"</p><p><a href=\"https://xie.infoq.cn/article/f7361f9f4afc55b8f99727c3d\">Web、移动端、桌面端自动化测试工具或框架推荐</a>\"</p><p><a href=\"https://xie.infoq.cn/article/170673a775bec8d1e407bb035\">Web 前端设计开发工具集（JS 框架、CSS 预处理）</a>\"</p><p><a href=\"https://xie.infoq.cn/article/3e869b0b353cd3d810f493e27\">传统 Web 框架部署与迁移</a>\"</p>",
    "publish_time": "2023-04-14 14:10:09",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "如何检查 Docker 镜像是否存在漏洞",
    "url": "https://www.infoq.cn/article/Z8128Ope7MVzfAgLNH9F",
    "summary": "<p></p><blockquote>定期检查管道中的漏洞是非常重要的。执行步骤之一是对你的 Docker 镜像进行漏洞扫描。在本文中，你将学习如何执行漏洞扫描，如何修复漏洞，以及如何将其添加到你的 Jenkins 管道中。</blockquote><p></p><p>&nbsp;</p><p>在几年前的一篇<a href=\"https://mydeveloperplanet.com/2019/02/13/check-docker-images-for-vulnerabilities-with-anchore-engine/\">博文</a>\"中，描述了如何扫描 Docker 镜像的漏洞。<a href=\"https://mydeveloperplanet.com/2019/02/27/anchore-container-image-scanner-jenkins-plugin/\">后续的博文</a>\"展示了如何将扫描添加到 Jenkins 管道中。然而，之前博文中使用的 Anchore Engine 已经<a href=\"https://anchore.com/blog/announcing-anchore-engine-1-0/\">不被支持</a>\"了，我认为另一个解决方案是使用由 Anchore 提供的 <a href=\"https://github.com/anchore/grype\">grype</a>\"。</p><p>&nbsp;</p><p>如今，我们必须保持最新的安全修复措施。许多安全漏洞是<a href=\"https://cve.mitre.org/\">公开</a>\"的，可以很容易地被利用。因此，为尽量减少被攻击，尽快修复安全漏洞是必须的。但如何跟上这个步伐呢？你主要关注的是业务，不希望有一个全职工作来修复安全漏洞。这就是为什么自动扫描你的应用程序和你的 Docker 镜像很重要。Grype 可以帮助扫描 Docker 镜像、检查操作系统的漏洞，也会检查特定语言的包，如 Java JAR 文件的漏洞，并会报告它们。它还可以扫描文件和目录，因此可以用来扫描你的源代码。</p><p>&nbsp;</p><p>在本文中，我创建了一个包含 Spring Boot 应用程序的有漏洞的 Docker 镜像，并将安装和使用 grype，以便扫描镜像并修复漏洞。本文中使用的资源可以在 <a href=\"https://github.com/mydeveloperplanet/mygrypeplanet\">GitHub</a>\" 上找到。</p><p>&nbsp;</p><p>了解本文，所需的前提条件是：</p><p>&nbsp;</p><p>基本的 Linux 知识基本的 Docker 知识基本的 Java 和 Spring Boot 知识</p><p>&nbsp;</p><p></p><h2>易受攻击的应用程序</h2><p></p><p>&nbsp;</p><p>打开 <a href=\"https://start.spring.io/\">Spring Initializr</a>\"，选择 Maven 构建、Java 17、Spring Boot 2.7.6，以及 Spring Web 依赖。这不会是一个非常脆弱的应用程序，因为 Spring 已经确保你使用最新的 Spring Boot 版本。因此，将 Spring Boot 的版本改为 2.7.0。可以用以下命令构建 Spring Boot 应用程序，它将为你创建 jar 文件：</p><p>&nbsp;</p><p><code lang=\"null\">$ mvn clean verify</code></p><p>&nbsp;</p><p>你要扫描一个 Docker 镜像，因此需要创建一个 Dockerfile。你将使用一个非常基本的 Dockerfile，它只包含创建镜像所需的最低指令。如果你想创建生产就绪的 Docker 镜像，请阅读《<a href=\"https://mydeveloperplanet.com/2022/11/30/docker-best-practices/\">Docker 最佳实践</a>\"》（Docker Best Practices）和《<a href=\"https://mydeveloperplanet.com/2022/12/14/spring-boot-docker-best-practices/\">Spring Boot Docker 最佳实践</a>\"》（Spring Boot Docker Best Practices）。</p><p>&nbsp;</p><p><code lang=\"null\">FROM eclipse-temurin:17.0.1_12-jre-alpine\nWORKDIR /opt/app\nARG JAR_FILE\nCOPY target/${JAR_FILE} app.jar\nENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]</code></p><p>&nbsp;</p><p>在撰写本文时，Java 17 的最新 eclipse-temurin 基础镜像是 17.0.5_8 版本。同样，使用较旧的才能使其易受攻击。</p><p>&nbsp;</p><p>为了构建 Docker 镜像，将使用 Spotify 的 dockerfile-maven-plugin 的分支。因此，将下面的代码片段添加到 pom 文件中。</p><p>&nbsp;</p><p><code lang=\"null\">\n  com.xenoamess.docker\n  dockerfile-maven-plugin\n  1.4.25\n  \n    mydeveloperplanet/mygrypeplanet\n    ${project.version}\n    \n      ${project.build.finalName}.jar\n    \n  \n</code></p><p>&nbsp;</p><p>使用该插件的好处是，你可以轻松地重复使用配置。创建 Docker 镜像只需一条 Maven 命令即可完成。</p><p>&nbsp;</p><p>可以通过调用以下命令来构建 Docker 镜像：</p><p>&nbsp;</p><p><code lang=\"null\">mvn dockerfile:build</code></p><p>&nbsp;</p><p>现在，你已经准备好开始使用 grype 了。</p><p>&nbsp;</p><p></p><h2>安装</h2><p></p><p>&nbsp;</p><p>可以通过执行以下脚本来安装 grype：</p><p>&nbsp;</p><p><code lang=\"null\">$ curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin</code></p><p>&nbsp;</p><p>通过执行以下命令验证安装：</p><p>&nbsp;</p><p><code lang=\"null\">$ grype version\nApplication:          grype\nVersion:              0.54.0\nSyft Version:         v0.63.0\nBuildDate:            2022-12-13T15:02:51Z\nGitCommit:            93499eec7e3ce2704755e9f51457181b06b519c5\nGitDescription:       v0.54.0\nPlatform:             linux/amd64\nGoVersion:            go1.18.8\nCompiler:             gc\nSupported DB Schema:  5</code></p><p>&nbsp;</p><p></p><h2>扫描镜像</h2><p></p><p>&nbsp;</p><p>扫描 Docker 镜像的方法是调用 grype，然后是 docker:，表示你想从 Docker 守护程序、镜像和标签中扫描一个镜像。</p><p>&nbsp;</p><p><code lang=\"null\">$ grype docker:mydeveloperplanet/mygrypeplanet:0.0.1-SNAPSHOT\nApplication:          grype\nVersion:              0.54.0\nSyft Version:         v0.63.0\n Vulnerability DB        [updated]\n Loaded image            \n Parsed image            \n Cataloged packages      [50 packages]\n Scanned image           [42 vulnerabilities]\nNAME              INSTALLED  FIXED-IN   TYPE          VULNERABILITY        SEVERITY \nbusybox           1.34.1-r3  1.34.1-r5  apk           CVE-2022-28391       High      \njackson-databind  2.13.3                java-archive  CVE-2022-42003       High      \njackson-databind  2.13.3                java-archive  CVE-2022-42004       High      \njackson-databind  2.13.3     2.13.4     java-archive  GHSA-rgv9-q543-rqg4  High      \njackson-databind  2.13.3     2.13.4.1   java-archive  GHSA-jjjh-jjxp-wpff  High      \njava              17.0.1+12             binary        CVE-2022-21248       Low       \njava              17.0.1+12             binary        CVE-2022-21277       Medium    \njava              17.0.1+12             binary        CVE-2022-21282       Medium    \njava              17.0.1+12             binary        CVE-2022-21283       Medium    \njava              17.0.1+12             binary        CVE-2022-21291       Medium    \njava              17.0.1+12             binary        CVE-2022-21293       Medium    \njava              17.0.1+12             binary        CVE-2022-21294       Medium    \njava              17.0.1+12             binary        CVE-2022-21296       Medium    \njava              17.0.1+12             binary        CVE-2022-21299       Medium    \njava              17.0.1+12             binary        CVE-2022-21305       Medium    \njava              17.0.1+12             binary        CVE-2022-21340       Medium    \njava              17.0.1+12             binary        CVE-2022-21341       Medium    \njava              17.0.1+12             binary        CVE-2022-21360       Medium    \njava              17.0.1+12             binary        CVE-2022-21365       Medium    \njava              17.0.1+12             binary        CVE-2022-21366       Medium    \nlibcrypto1.1      1.1.1l-r7             apk           CVE-2021-4160        Medium    \nlibcrypto1.1      1.1.1l-r7  1.1.1n-r0  apk           CVE-2022-0778        High      \nlibcrypto1.1      1.1.1l-r7  1.1.1q-r0  apk           CVE-2022-2097        Medium    \nlibretls          3.3.4-r2   3.3.4-r3   apk           CVE-2022-0778        High      \nlibssl1.1         1.1.1l-r7             apk           CVE-2021-4160        Medium    \nlibssl1.1         1.1.1l-r7  1.1.1n-r0  apk           CVE-2022-0778        High      \nlibssl1.1         1.1.1l-r7  1.1.1q-r0  apk           CVE-2022-2097        Medium    \nsnakeyaml         1.30                  java-archive  GHSA-mjmj-j48q-9wg2  High      \nsnakeyaml         1.30       1.31       java-archive  GHSA-3mc7-4q67-w48m  High      \nsnakeyaml         1.30       1.31       java-archive  GHSA-98wm-3w3q-mw94  Medium    \nsnakeyaml         1.30       1.31       java-archive  GHSA-c4r9-r8fh-9vj2  Medium    \nsnakeyaml         1.30       1.31       java-archive  GHSA-hhhw-99gj-p3c3  Medium    \nsnakeyaml         1.30       1.32       java-archive  GHSA-9w3m-gqgf-c4p9  Medium    \nsnakeyaml         1.30       1.32       java-archive  GHSA-w37g-rhq8-7m4j  Medium    \nspring-core       5.3.20                java-archive  CVE-2016-1000027     Critical  \nssl_client        1.34.1-r3  1.34.1-r5  apk           CVE-2022-28391       High      \nzlib              1.2.11-r3  1.2.12-r0  apk           CVE-2018-25032       High      \nzlib              1.2.11-r3  1.2.12-r2  apk           CVE-2022-37434       Critical </code></p><p>&nbsp;</p><p>这个输出告诉你什么？</p><p>&nbsp;</p><p>NAME：易受攻击的包的名称INSTALLED：安装的是哪个版本FIXED-IN：在哪个版本中修复了漏洞TYPE：依赖项的类型，例如 JDK 的二进制等VULNERABILITY：漏洞的标识符；通过此标识符，你可以获得有关 CVE 数据库中漏洞的更多信息SEVERITY：不言自明，可以是可忽略、低、中、高或严重</p><p>&nbsp;</p><p>当你仔细观察输出结果时，你会发现并非每个漏洞都有确认的修复方法。那么，在这种情况下，你该怎么办呢？Grype 提供了一个选项，以便只显示已经确认修复的漏洞。添加--only-fixed 标志就可以了。</p><p>&nbsp;</p><p><code lang=\"null\">$ grype docker:mydeveloperplanet/mygrypeplanet:0.0.1-SNAPSHOT --only-fixed\n Vulnerability DB        [no update available]\n Loaded image            \n Parsed image            \n Cataloged packages      [50 packages]\n Scanned image           [42 vulnerabilities]\n \nNAME              INSTALLED  FIXED-IN   TYPE          VULNERABILITY        SEVERITY \nbusybox           1.34.1-r3  1.34.1-r5  apk           CVE-2022-28391       High      \njackson-databind  2.13.3     2.13.4     java-archive  GHSA-rgv9-q543-rqg4  High      \njackson-databind  2.13.3     2.13.4.1   java-archive  GHSA-jjjh-jjxp-wpff  High      \nlibcrypto1.1      1.1.1l-r7  1.1.1n-r0  apk           CVE-2022-0778        High      \nlibcrypto1.1      1.1.1l-r7  1.1.1q-r0  apk           CVE-2022-2097        Medium    \nlibretls          3.3.4-r2   3.3.4-r3   apk           CVE-2022-0778        High      \nlibssl1.1         1.1.1l-r7  1.1.1n-r0  apk           CVE-2022-0778        High      \nlibssl1.1         1.1.1l-r7  1.1.1q-r0  apk           CVE-2022-2097        Medium    \nsnakeyaml         1.30       1.31       java-archive  GHSA-3mc7-4q67-w48m  High      \nsnakeyaml         1.30       1.31       java-archive  GHSA-98wm-3w3q-mw94  Medium    \nsnakeyaml         1.30       1.31       java-archive  GHSA-c4r9-r8fh-9vj2  Medium    \nsnakeyaml         1.30       1.31       java-archive  GHSA-hhhw-99gj-p3c3  Medium    \nsnakeyaml         1.30       1.32       java-archive  GHSA-9w3m-gqgf-c4p9  Medium    \nsnakeyaml         1.30       1.32       java-archive  GHSA-w37g-rhq8-7m4j  Medium    \nssl_client        1.34.1-r3  1.34.1-r5  apk           CVE-2022-28391       High      \nzlib              1.2.11-r3  1.2.12-r0  apk           CVE-2018-25032       High      \nzlib              1.2.11-r3  1.2.12-r2  apk           CVE-2022-37434       Critical </code></p><p>&nbsp;</p><p>请注意，Java JDK 的漏洞已经消失，尽管 Java 17 JDK 存在一个较新的更新。然而，这可能不是一个大问题，因为其他（非 java-archive）的漏洞显示基础镜像已经过时了。</p><p>&nbsp;</p><p></p><h2>修复漏洞</h2><p></p><p>&nbsp;</p><p>在这种情况下，修复漏洞是很容易的。首先，你需要更新 Docker 基础镜像。改变 Docker 镜像中的第一行：</p><p>&nbsp;</p><p><code lang=\"null\">FROM eclipse-temurin:17.0.1_12-jre-alpine</code></p><p>&nbsp;</p><p>改成：</p><p>&nbsp;</p><p><code lang=\"null\">FROM eclipse-temurin:17.0.5_8-jre-alpine</code></p><p>&nbsp;</p><p>构建镜像并再次运行扫描：</p><p>&nbsp;</p><p><code lang=\"null\">$ mvn dockerfile:build\n...\n$ grype docker:mydeveloperplanet/mygrypeplanet:0.0.1-SNAPSHOT --only-fixed\n Vulnerability DB        [no update available]\n Loaded image            \n Parsed image            \n Cataloged packages      [62 packages]\n Scanned image           [14 vulnerabilities]\nNAME              INSTALLED  FIXED-IN  TYPE          VULNERABILITY        SEVERITY \njackson-databind  2.13.3     2.13.4    java-archive  GHSA-rgv9-q543-rqg4  High      \njackson-databind  2.13.3     2.13.4.1  java-archive  GHSA-jjjh-jjxp-wpff  High      \nsnakeyaml         1.30       1.31      java-archive  GHSA-3mc7-4q67-w48m  High      \nsnakeyaml         1.30       1.31      java-archive  GHSA-98wm-3w3q-mw94  Medium    \nsnakeyaml         1.30       1.31      java-archive  GHSA-c4r9-r8fh-9vj2  Medium    \nsnakeyaml         1.30       1.31      java-archive  GHSA-hhhw-99gj-p3c3  Medium    \nsnakeyaml         1.30       1.32      java-archive  GHSA-9w3m-gqgf-c4p9  Medium    \nsnakeyaml         1.30       1.32      java-archive  GHSA-w37g-rhq8-7m4j  Medium </code></p><p>&nbsp;</p><p>正如你在输出中所看到的，只有 java-archive 的漏洞仍然存在。其他漏洞已经被解决了。</p><p>&nbsp;</p><p>接下来，修复 Spring Boot 依赖性漏洞，在 POM 中将 Spring Boot 的版本从 2.7.0 更改为 2.7.6。</p><p>&nbsp;</p><p><code lang=\"null\">\n  org.springframework.boot\n  spring-boot-starter-parent\n  2.7.6\n   <!-- lookup parent from repository -->\n</code></p><p>&nbsp;</p><p>构建 JAR 文件，构建 Docker 镜像，然后再次运行扫描：</p><p>&nbsp;</p><p><code lang=\"null\">$ mvn clean verify\n...\n$ mvn dockerfile:build\n...\n$ grype docker:mydeveloperplanet/mygrypeplanet:0.0.1-SNAPSHOT --only-fixed\n Vulnerability DB        [no update available]\n Loaded image            \n Parsed image            \n Cataloged packages      [62 packages]\n Scanned image           [10 vulnerabilities]\nNAME       INSTALLED  FIXED-IN  TYPE          VULNERABILITY        SEVERITY \nsnakeyaml  1.30       1.31      java-archive  GHSA-3mc7-4q67-w48m  High      \nsnakeyaml  1.30       1.31      java-archive  GHSA-98wm-3w3q-mw94  Medium    \nsnakeyaml  1.30       1.31      java-archive  GHSA-c4r9-r8fh-9vj2  Medium    \nsnakeyaml  1.30       1.31      java-archive  GHSA-hhhw-99gj-p3c3  Medium    \nsnakeyaml  1.30       1.32      java-archive  GHSA-9w3m-gqgf-c4p9  Medium    \nsnakeyaml  1.30       1.32      java-archive  GHSA-w37g-rhq8-7m4j  Medium </code></p><p>&nbsp;</p><p>所以，你修复了 jackson-databind 的漏洞，但没有修复 snakeyaml 的漏洞。那么，snakeyaml 1.30 是在哪个依赖中被使用的？你可以通过 Maven 的 dependency:tree 命令来了解。为简洁起见，这里只显示部分输出：</p><p>&nbsp;</p><p><code lang=\"null\">$ mvnd dependency:tree\n...\n com.mydeveloperplanet:mygrypeplanet:jar:0.0.1-SNAPSHOT\n[INFO] +- org.springframework.boot:spring-boot-starter-web:jar:2.7.6:compile\n[INFO] |  +- org.springframework.boot:spring-boot-starter:jar:2.7.6:compile\n[INFO] |  |  +- org.springframework.boot:spring-boot:jar:2.7.6:compile\n[INFO] |  |  +- org.springframework.boot:spring-boot-autoconfigure:jar:2.7.6:compile\n[INFO] |  |  +- org.springframework.boot:spring-boot-starter-logging:jar:2.7.6:compile\n[INFO] |  |  |  +- ch.qos.logback:logback-classic:jar:1.2.11:compile\n[INFO] |  |  |  |  \\- ch.qos.logback:logback-core:jar:1.2.11:compile\n[INFO] |  |  |  +- org.apache.logging.log4j:log4j-to-slf4j:jar:2.17.2:compile\n[INFO] |  |  |  |  \\- org.apache.logging.log4j:log4j-api:jar:2.17.2:compile\n[INFO] |  |  |  \\- org.slf4j:jul-to-slf4j:jar:1.7.36:compile\n[INFO] |  |  +- jakarta.annotation:jakarta.annotation-api:jar:1.3.5:compile\n[INFO] |  |  \\- org.yaml:snakeyaml:jar:1.30:compile\n...</code></p><p>&nbsp;</p><p>输出显示，这个依赖是 spring-boot-starter-web 依赖的一部分。那么，你如何解决这个问题呢？严格来说，Spring 必须要解决这个问题。但如果你不想等待解决方案，你可以自己解决。</p><p>&nbsp;</p><p>解决方案 1: 不需要依赖项。这是最简单的解决方案，风险也低。只需在 pom 中从 spring-boot-starter-web 依赖项中排除该依赖项即可。</p><p>&nbsp;</p><p><code lang=\"null\">\n  org.springframework.boot\n  spring-boot-starter-web\n  \n    \n      org.yaml\n      snakeyaml\n    \n  \n</code></p><p>&nbsp;</p><p>构建 JAR 文件，构建 Docker 镜像，然后再次运行扫描：</p><p>&nbsp;</p><p><code lang=\"null\">$ mvn clean verify\n...\n$ mvn dockerfile:build\n...\n$ grype docker:mydeveloperplanet/mygrypeplanet:0.0.1-SNAPSHOT --only-fixed\n Vulnerability DB        [no update available]\n Loaded image            \n Parsed image            \n Cataloged packages      [61 packages]\n Scanned image           [3 vulnerabilities]\nNo vulnerabilities found</code></p><p>&nbsp;</p><p>再也没发现任何漏洞了。</p><p>&nbsp;</p><p>解决方案 2：你确实需要这个依赖关系。你可以通过 pom 中的 dependencyManagement 来替换这个过渡性依赖。这就有点麻烦了，因为更新后的横向依赖没有经过 spring-boot-starter-web 依赖的测试。你要不要这样做，需要权衡一下。在 pom 中添加以下部分。</p><p>&nbsp;</p><p><code lang=\"null\">\n  \n    \n      org.yaml\n      snakeyaml\n      1.32\n    \n  \n</code></p><p>&nbsp;</p><p>构建 JAR 文件，构建 Docker 镜像，然后再次运行扫描：</p><p>&nbsp;</p><p><code lang=\"null\">$ mvn clean verify\n...\n$ mvn dockerfile:build\n...\n$ grype docker:mydeveloperplanet/mygrypeplanet:0.0.1-SNAPSHOT --only-fixed\n Vulnerability DB        [no update available]\n Loaded image            \n Parsed image            \n Cataloged packages      [62 packages]\n Scanned image           [3 vulnerabilities]\nNo vulnerabilities found</code></p><p>&nbsp;</p><p>同样，再也没发现漏洞了。</p><p>&nbsp;</p><p>解决方案 3：这是在你不想做任何事情或是否有误报通知时的解决方案。创建一个 .grype.yaml 文件，在其中排除高严重性的漏洞，然后用 --config 标志执行扫描，后面是包含排除项的 .grype.yaml 文件。</p><p>&nbsp;</p><p>.grype.yaml 文件如下所示：</p><p>&nbsp;</p><p><code lang=\"null\">ignore:\n  - vulnerability: GHSA-3mc7-4q67-w48m</code></p><p>&nbsp;</p><p>再次运行扫描：</p><p>&nbsp;</p><p><code lang=\"null\">$ grype docker:mydeveloperplanet/mygrypeplanet:0.0.1-SNAPSHOT --only-fixed\n Vulnerability DB        [no update available]\n Loaded image            \n Parsed image            \n Cataloged packages      [62 packages]\n Scanned image           [10 vulnerabilities]\nNAME       INSTALLED  FIXED-IN  TYPE          VULNERABILITY        SEVERITY \nsnakeyaml  1.30       1.31      java-archive  GHSA-98wm-3w3q-mw94  Medium    \nsnakeyaml  1.30       1.31      java-archive  GHSA-c4r9-r8fh-9vj2  Medium    \nsnakeyaml  1.30       1.31      java-archive  GHSA-hhhw-99gj-p3c3  Medium    \nsnakeyaml  1.30       1.32      java-archive  GHSA-9w3m-gqgf-c4p9  Medium    \nsnakeyaml  1.30       1.32      java-archive  GHSA-w37g-rhq8-7m4j  Medium </code></p><p>&nbsp;</p><p>High 漏洞就不再显示了。</p><p>&nbsp;</p><p></p><h2> 持续集成</h2><p></p><p>&nbsp;</p><p>现在你知道如何手动扫描你的 Docker 镜像了。然而，你可能想把扫描镜像作为持续集成管道的一部分。在本节中，将提供一个使用 Jenkins 作为 CI 平台时的解决方案。</p><p>&nbsp;</p><p>要回答的第一个问题是，当发现漏洞时，你将如何得到通知。到现在为止，你只能通过查看标准输出来注意到这些漏洞。这不是一个 CI 管道的解决方案。你想得到通知，这可以通过失败的构建来实现。Grype 有 --fail-on 标志来达到这个目的。你可能不想在发现严重程度为 negligible 的漏洞时让管道失败。</p><p>&nbsp;</p><p>让我们看看当你手动执行这个时，会发生什么。首先，在 Spring Boot 应用程序和 Docker 镜像中再次引入漏洞。</p><p>&nbsp;</p><p>构建 JAR 文件，构建 Docker 镜像，用标志 --fail-on 运行扫描。</p><p>&nbsp;</p><p><code lang=\"null\">$ mvn clean verify\n...\n$ mvn dockerfile:build\n...\n$ grype docker:mydeveloperplanet/mygrypeplanet:0.0.1-SNAPSHOT --only-fixed --fail-on high\n...\n1 error occurred:\n        * discovered vulnerabilities at or above the severity threshold</code></p><p>&nbsp;</p><p>这里没有显示所有的输出，只显示了重要的部分。而且，正如你所看到的，在输出的最后，显示了一条信息，表明扫描产生了一个错误。这将导致你的 Jenkins 管道失败，因此，开发人员会被通知出了问题。</p><p>&nbsp;</p><p>为了将其添加到您的 Jenkins 管道中，有几个选项。这里选择创建 Docker 镜像，并从 Maven 中执行 grype Docker 扫描。grype 没有单独的 Maven 插件，但你可以使用 exec-maven-plugin 来实现这一目的。在 POM 的 build-plugins 部分添加以下内容。</p><p>&nbsp;</p><p><code lang=\"null\">\n  \n    \n      org.codehaus.mojo\n      exec-maven-plugin\n      3.1.0\n      \n        grype\n          \n            docker:mydeveloperplanet/mygrypeplanet:${project.version}\n            --scope\n            all-layers\n            --fail-on\n            high\n            --only-fixed\n            -q\n          \n      \n    \n  \n</code></p><p>&nbsp;</p><p>这里添加了两个额外的标志：</p><p>&nbsp;</p><p>--scope all-layers。这将扫描 Docker 镜像中涉及的所有层。--q：这将使用安静的日志，只显示漏洞和可能出现的故障。</p><p>&nbsp;</p><p>你可以用下面的命令来调用它：</p><p>&nbsp;</p><p><code lang=\"null\">$ mvnd exec:exec</code></p><p>&nbsp;</p><p>你可以把它添加到你的 Jenkinsfile 中的 withMaven 包装器中：</p><p>&nbsp;</p><p><code lang=\"null\">withMaven() {\n  sh 'mvn dockerfile:build dockerfile:push exec:exec'\n}</code></p><p></p><h2>结论</h2><p></p><p>&nbsp;</p><p>在本文中，你了解了如何通过 grype 来扫描你的 Docker 镜像。Grype 有一些有趣的、用户友好的特性，允许你有效地将它们添加到你的 Jenkins 管道中，另外安装 grype 也很容易。与 Anchor Engine 相比，Grype 绝对是一个很大的改进。</p><p>&nbsp;</p><p>作者简介：</p><p>&nbsp;</p><p>Gunter Rotsaert，系统工程师，居住在荷兰的比利时人。</p><p>&nbsp;</p><p>原文链接：</p><p>https://mydeveloperplanet.com/2023/01/18/how-to-check-docker-images-for-vulnerabilities/</p>",
    "publish_time": "2023-04-14 14:22:24",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]