[
  {
    "title": "Meta将百万行代码从Java移植到Kotlin",
    "url": "https://www.infoq.cn/article/aTY2ysTOjaEwUv9Hzls6",
    "summary": "<p>Meta一直在<a href=\"https://engineering.fb.com/2022/10/24/android/android-java-kotlin-migration/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjkxNjY4MzYsImZpbGVHVUlEIjoiOHFPMXJXMFVWNU1GYVI4aCIsImlhdCI6MTY2OTE2NjUzNiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.sCjTb5aVi_x1cnjBZ1jc4QWKIEUXgqkG1gYhh1RUxgE\">将他们的Android代码库从Java移植到Kotlin</a>\"。Meta的工程师Omer Strulovich解释说，在这个过程中，他们学到了许多有趣的经验教训，并积累了一些有用的方法。</p><p></p><p>Meta之所以决定采用Kotlin开发Android应用，是因为他们看到了<a href=\"https://www.infoq.cn/article/qt51vqATE7jf_bpw5ggJ\">Kotlin</a>\"相对于Java的优势，包括可空性和函数式编程支持、更简短的代码，以及创建特定领域语言的可能性。Kotlin工程师还清楚地知道，他们必须将尽可能多的Java代码库移植到Kotlin，以防止Java空指针问题潜入Kotlin代码库，并减少需要维护的Java代码。这不是一件容易的事，从一开始就需要做相当多的调研工作。</p><p></p><p>Meta工程师必须克服的第一个障碍是，Meta使用的几个内部优化工具无法与Kotlin正常兼容。例如，Meta必须更新<a href=\"https://github.com/facebook/redex?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjkxNjY4MzYsImZpbGVHVUlEIjoiOHFPMXJXMFVWNU1GYVI4aCIsImlhdCI6MTY2OTE2NjUzNiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.sCjTb5aVi_x1cnjBZ1jc4QWKIEUXgqkG1gYhh1RUxgE\">ReDex Android字节码优化器</a>\"和语法高亮显示工具Pygments的<a href=\"https://github.com/pygments/pygments/pull/1699?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjkxNjY4MzYsImZpbGVHVUlEIjoiOHFPMXJXMFVWNU1GYVI4aCIsImlhdCI6MTY2OTE2NjUzNiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.sCjTb5aVi_x1cnjBZ1jc4QWKIEUXgqkG1gYhh1RUxgE\">词法分析器组件</a>\"，并构建一个<a href=\"https://github.com/google/ksp?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjkxNjY4MzYsImZpbGVHVUlEIjoiOHFPMXJXMFVWNU1GYVI4aCIsImlhdCI6MTY2OTE2NjUzNiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.sCjTb5aVi_x1cnjBZ1jc4QWKIEUXgqkG1gYhh1RUxgE\">Kotlin符号处理（KSP）API</a>\"，用于创建Kotlin编译器插件。</p><p></p><p>在代码转换方面，Meta工程师选择使用Kotlin官方转换器J2K，它可以作为编译器插件使用。除了一些特定的框架（包括JUnit）之外，这种方法工作得非常好。但对于特定的框架，这个工具缺乏足够的知识，无法进行正确的转换。</p><p></p><p></p><blockquote>我们已经遇到了很多需要进行小修复的情况。有些很容易做到（比如替换isEmpty），有些需要做一些研究工作才能搞清楚（与JUnit规则的情况一样），还有一些是针对J2K本身的bug的变通方法，这些bug可能会导致出现任何问题——从构建时错误到运行时行为。</blockquote><p></p><p></p><p>处理这种情况的正确方法包括三个步骤：首先是准备好Java代码，然后在headless模式的Android Studio实例中自动运行J2K，最后对生成的文件进行后续处理，进行所有所需的重构和修复。Meta已经<a href=\"https://github.com/fbsamples/kotlin_ast_tools?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjkxNjY4MzYsImZpbGVHVUlEIjoiOHFPMXJXMFVWNU1GYVI4aCIsImlhdCI6MTY2OTE2NjUzNiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.sCjTb5aVi_x1cnjBZ1jc4QWKIEUXgqkG1gYhh1RUxgE\">开源</a>\"了许多重构工具，以帮助其他开发人员完成相同的任务。</p><p></p><p></p><blockquote>这些自动化转换过程并不能解决所有的问题，但我们能够优先解决最常见的问题。我们针对模块运行转换脚本（我们贴切地称之为Kotlinator），优先考虑活跃和简单的模块。然后我们观察生成的代码：它们可以通过编译吗？它们是否可以顺利通过我们的持续集成管道？如果可以，我们就提交它们。如果不可以，我们就研究问题，并设计新的自动重构过程来修复它们。</blockquote><p></p><p></p><p>Meta已经通过这种方式移植了超过1000万行Kotlin代码，让大多数的Meta Android工程师切换到<a href=\"https://www.infoq.cn/article/TaUjgp7HuFEXBcAu_rw8\">Kotlin</a>\"来完成他们的日常工作。这个过程也验证了许多预期的结果，包括更短的生成代码和不变的执行速度。但是，从消极的方面来看，Kotlin编译器比Java编译器慢得多。使用KSP来处理注解，改进Java存根生成和编译时间，这为优化带来了新的可能性，不过仍然需要持续的努力。</p><p></p><p>如果你对完整的细节感兴趣，请不要错过Meta的这篇关于迁移到Kotlin的文章。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2022/11/meta-port-java-kotlin/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjkxNjY4MzYsImZpbGVHVUlEIjoiOHFPMXJXMFVWNU1GYVI4aCIsImlhdCI6MTY2OTE2NjUzNiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.sCjTb5aVi_x1cnjBZ1jc4QWKIEUXgqkG1gYhh1RUxgE\">https://www.infoq.com/news/2022/11/meta-port-java-kotlin/</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/lOCkY3lV2ADRvXcsZEb2\">Kotlin&nbsp;Multiplatform Mobile 进入 Beta 测试</a>\"</p>",
    "publish_time": "2022-11-24 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "如何管理云原生应用程序的依赖关系",
    "url": "https://www.infoq.cn/article/1TvgZix4z6HlMubu061X",
    "summary": "<p></p><p>许多企业正在将他们的业务转移到云端，这使得他们能够更灵活、更迅速地响应市场的变化，并且更易于拓展自己的业务。但由于要进行大量的规划和实施，所以向云端迁移可能也是一项非常艰巨的任务。术语“云原生”是一种利用云计算交付范式的优势进行开发和运行应用程序的方式。</p><p></p><h2>“云原生”意味着什么？</h2><p></p><p></p><p>应用程序在哪里被托管并不重要，重要的是如何开发和部署它们。云原生开发既可以使用公共云，也可以使用私有云。任何云存储都具有存储功能并支持来自全球任意一个公共网关的访问，而无需考虑实际地理位置。它们能够为软件开发者提供按需访问的处理能力以及最新的数据和应用服务。<a href=\"https://www.mend.io/resources/blog/a-brief-guide-to-cloud-native-applications-technology-and-security/\">云原生应用</a>\"是使用微服务开发的，而微服务是小型、独立的服务，它们共同组成了一个更大的应用程序。</p><p></p><p>微服务是一种能够让开发者更轻松地构建和维护大型应用程序的软件架构。在微服务架构中，将一个应用分成几个独立的小块，即为服务。每一个服务都可以独立开发和部署，整个过程具有更大的灵活性和可扩展性。</p><p></p><p>微服务可以在几个方面使云基础设施受益。首先，它们允许对应用程序的各个部分进行更细化地控制，云中的应用程序可以轻松地进行部署和管理。其次，微服务使应用程序扩展变得更加容易。当一个应用程序需要扩展或缩减规模时，只对需要改变的服务进行更新即可。最后，微服务可以通过允许滚动更新和部署来提高可用性。当某个服务发生故障时，其他服务会持续运行，从而提高整个系统的弹性。</p><p></p><p>当一个数据请求被提交后，它会被路由到一些不同的 Docker 容器，每个容器都在运行一套单独的微服务，为消费者提供服务。创建它们的目的是提供被广泛认可的业务价值，比如快速纳入用户反馈以实现持续改进的能力。每个容器负责操作一个针对服务客户的单一服务，这些容器能够为用户提供可扩展性和足够的保护水平。</p><p></p><h2>依赖关系如何适应？</h2><p></p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/0b/2b/0b70defa10bcdfde70f5bf8072edc42b.png\" /></p><p></p><p>依赖关系是一段代码和另一段代码之间的隐性或显性关系，可以认为是为了正确运行，一段代码对另一段代码的要求。</p><p></p><p>有两种主要类型的依赖关系：硬依赖和软依赖。硬依赖是指不破坏依赖于它们的代码就无法更改的依赖关系，软依赖关系则可以在不破坏依赖代码的情况下就能被更改。</p><p></p><p>依赖关系可以是内部的，也可以是外部的。内部依赖是指同一软件系统中两段代码之间的依赖关系，外部依赖是指位于不同软件系统中的两段代码之间的依赖关系。</p><p></p><p>在云原生应用中，每个微服务都有自己的依赖关系，这些依赖关系由运行微服务的容器来管理，容器负责确保使用正确版本的依赖关系，并使其保持最新。</p><p></p><p>由于从头开始开发这些特性需要大量的时间，并且设计颇具复杂性，因此使用现有的解决方案要高效得多。既然需要这么多的依赖，也就需要管理这些依赖的解决方案，因此就有了 Maven 或 NPM 这样的包管理器。例如，NPM 要求在部署前将各种依赖关系加载到容器中。许多依赖关系是开源的，各种研究人员都能接触并发现其中的漏洞，这也是它们持续更新的原因之一。</p><p></p><p>依赖关系是开发者非常关心的问题，一旦被忽视，就会演变为安全问题。开发者如果不够谨慎，便会通过依赖存在已知漏洞的代码，很容易将漏洞引入它们的代码库中。这就是为什么在安装第三方依赖关系之前需要对它们进行扫描，并在它们可用时应用安全补丁是很重要的。</p><p></p><p>举个例子，<a href=\"https://nodejs.org/en/\">NodeJS</a>\" 通常每月更新一次，每次更新都会修复几个漏洞。因此，必须定期更新这些系统，以确保可以尽可能多地避免与依赖有关的漏洞。</p><p></p><h2>依赖关系管理的最佳实践</h2><p></p><p>当谈论<a href=\"https://www.mend.io/free-developer-tools/blog/dependency-management/\">依赖关系管理</a>\"时，我们会谈论很多不同的策略和考虑事项，例如使用自动依赖关系管理工具或软件包管理器。为了确保依赖关系得到有效管理，以下是一些可以利用的最佳实践。</p><p></p><h3>检测所有未使用的依赖关系</h3><p></p><p>你可以使用 <a href=\"https://github.com/depcheck/depcheck\">depcheck</a>\" 来检查是否存在任何没有被使用的依赖关系。需要使用以下命令来安装 depcheck。</p><p></p><p><code lang=\"bash\">npm install depcheck -g</code></p><p></p><p>安装完毕后，你可以运行下面的命令来检查是否存在未使用的依赖关系。</p><p></p><p><code lang=\"plain\">depcheck</code></p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/ac/2d/ac83597aec73fd85958fd38c155b432d.png\" /></p><p></p><p></p><h3>检测所有过期的依赖关系</h3><p></p><p>大多数依赖关系是开源的，通常在安全研究人员发现漏洞或增加新的特性时，会在一段时间内更新一次。因此，你的依赖关系可能存在过期的风险。因此，验证和更新<a href=\"https://docs.npmjs.com/cli/v6/commands/npm-outdated\">过期的依赖关系</a>\"非常关键。</p><p></p><p>要检查过时的依赖关系，你可以通过导航到 NPM 文件夹打开终端，运行以下命令：</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/96/a3/96a4dd973b9450f1601babbf616112a3.png\" /></p><p></p><p>你也可以使用一个简单的依赖关系检查脚本，它将检查一个 repo 或软件包的所有依赖关系。</p><p></p><p><code lang=\"bash\">#!/bin/bash\nDIRNAME=${1:-.}\ncd $DIRNAME\n\nFILES=$(mktemp)\nPACKAGES=$(mktemp)\n\nfind . \\\n    -path ./node_modules -prune -or \\\n    -path ./build -prune -or \\\n    \\( -name \"*.ts\" -or -name \"*.js\" -or -name \"*.json\" \\) -print &gt; $FILES\n\nfunction check {\n    cat package.json \\\n        | jq \"{} + .$1 | keys\" \\\n        | sed -n 's/.*\"\\(.*\\)\".*/\\1/p' &gt; $PACKAGES\n\n    echo \"--------------------------\"\n    echo \"Checking $1...\"\n    while read PACKAGE\n    do\n        RES=$(cat $FILES | xargs -I {} egrep -i \"(import|require).*['\\\\\"]$PACKAGE[\\\\\"']\" '{}' | wc -l)\n        if [ $RES = 0 ]\n        then\n            echo -e \"UNUSED\\t\\t $PACKAGE\"\n        else\n            echo -e \"USED ($RES)\\\\t $PACKAGE\"\n        fi\n    done &lt; $PACKAGES\n}\n\ncheck \"dependencies\"\ncheck \"devDependencies\"\ncheck \"peerDependencies\"\n</code></p><p></p><h3>保持所需的依赖关系更新</h3><p></p><p></p><p>由于所使用的依赖关系种类繁多，因此有必要确保所需的依赖关系始终保持最新，以确保最佳性能。手动检查和升级这些依赖关系通常需要大量的时间。因此，各种各样的组织利用自动化的依赖关系管理工具，以确保他们的依赖关系在一致的基础上及时地保持更新。NPM 应用程序中的依赖关系是在仓库的 package.json 文件中定义的。这些文件具有以下类型的内容：</p><p></p><p><code lang=\"json\">{\n  \"name\": \"herodevs-packages\",\n  \"version\": \"0.0.0\",\n  \"scripts\": {\n    \"ng\": \"ng\",\n    \"precommit\": \"lint-staged\",\n    \"start\": \"ng serve\",\n    \"build\": \"ng build\",\n    \"test\": \"ng test\",\n    \"lint\": \"ng lint\",\n    \"e2e\": \"ng e2e\",\n    \"build-lazy\": \"ng build lazy\",\n    \"build-dynamic\": \"ng build dynamicService\",\n    \"npm-pack-lazy\": \"cd dist/loader &amp;&amp; npm pack\",\n    \"npm-pack-dynamic\": \"cd dist/dynamic &amp;&amp; npm pack\",\n    \"package-lazy\": \"npm run build-lazy &amp;&amp; npm run npm-pack-lazy\",\n    \"package-dynamic\": \"npm run build-dynamic &amp;&amp; npm run npm-pack-dynamic\",\n    \"package\": \"rm -rf dist/ &amp;&amp; npm run package-dynamic &amp;&amp; npm run package-lazy\"\n  },\n  \"private\": false,\n  \"dependencies\": {\n    \"@angular/animations\": \"^8.0.0\",\n    \"@angular/common\": \"^8.0.0\",\n    \"@angular/compiler\": \"^8.0.0\",\n    \"@angular/core\": \"^8.0.0\",\n    \"@angular/forms\": \"^8.0.0\",\n    \"@angular/platform-browser\": \"^8.0.0\",\n    \"@angular/platform-browser-dynamic\": \"^8.0.0\",\n    \"@angular/router\": \"^8.0.0\",\n    \"core-js\": \"^2.5.4\",\n    \"rxjs\": \"~6.5.2\",\n    \"zone.js\": \"~0.9.1\"\n  },\n  \"devDependencies\": {\n    \"@angular-devkit/build-angular\": \"~0.800.0\",\n    \"@angular-devkit/build-ng-packagr\": \"~0.800.0\",\n    \"@angular/cli\": \"~8.0.2\",\n    \"@angular/compiler-cli\": \"^8.0.0\",\n    \"@angular/language-service\": \"^8.0.0\",\n    \"@types/jasmine\": \"~2.8.8\",\n    \"@types/jasminewd2\": \"~2.0.3\",\n    \"@types/node\": \"~8.9.4\",\n    \"codelyzer\": \"^5.0.1\",\n    \"husky\": \"1.3.1\",\n    \"jasmine-core\": \"~2.99.1\",\n    \"jasmine-spec-reporter\": \"~4.2.1\",\n    \"karma\": \"~3.0.0\",\n    \"karma-chrome-launcher\": \"~2.2.0\",\n    \"karma-coverage-istanbul-reporter\": \"~2.0.1\",\n    \"karma-jasmine\": \"~1.1.2\",\n    \"karma-jasmine-html-reporter\": \"^0.2.2\",\n    \"lint-staged\": \"8.1.0\",\n    \"ng-packagr\": \"^5.1.0\",\n    \"prettier\": \"1.16.1\",\n    \"protractor\": \"~5.4.0\",\n    \"ts-node\": \"~7.0.0\",\n    \"tsickle\": \"^0.35.0\",\n    \"tslib\": \"^1.9.0\",\n    \"tslint\": \"~5.11.0\",\n    \"typescript\": \"~3.4.5\"\n  },\n  \"lint-staged\": {\n    \"*.{ts,tsx}\": [\n      \"prettier --parser typescript --writeprettier --parser typescript --write\",\n      \"git add\"\n    ]\n  }\n}\nFooter\n© 2022 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\n</code></p><p></p><h3>使用自动化依赖关系管理工具</h3><p></p><p>依赖关系管理的自动化有助于以下几个方面。它不仅可以加快你的开发过程，而且还可以确保你的团队中的每个人都在使用相同版本的依赖关系。自动化工具的工作原理是查看你在代码中声明的依赖关系，并将它们与可用的版本进行比较。如果有一个较新的版本可用，该工具将更新你的项目以使用它。</p><p></p><p>与依赖关系相关的更新日志通常包括在拉取请求中。在配置依赖关系管理工具时，你有很多不同的选项可以选择，比如更新时间，哪个依赖关系必须被更新，如果拉取请求需要自动合并，需要满足什么条件，以及其他许多事项。</p><p></p><p><a href=\"https://github.com/marketplace/renovate\">Mend Renovate</a>\" 就是一个例子，它是一个开源工具，为所有类型的<a href=\"https://www.mend.io/free-developer-tools/blog/why-and-how-you-should-automate-dependency-updates/\">依赖关系更新</a>\"自动创建拉取请求。Renovate 与其他依赖关系更新工具不同，因为它是完全可配置的，可以设置为定期自动更新依赖关系，或者只在有新的安全更新时自动更新。它提供的功能包括：完全自动化地拉取请求创建和合并，基于软件包流行度和测试数据的依赖关系选择，支持多个软件包管理器，包括 npm、yarn、composer，以及为每个仓库定制的更新规则。</p><p></p><h2>结语</h2><p></p><p></p><p>在云原生世界中，一个典型的环境是由各种各样的依赖关系支持的。全面地测试这些依赖关系对任何云原生应用的成功都至关重要。然而，手动更新所有的依赖关系可能很困难，也很耗时。自动化的依赖管理工具可以帮助减少花在管理依赖关系上的时间，也可以提高代码的质量。</p><p></p><p>作者简介：</p><p></p><p>Guy Bar-Gil，一位经验丰富的产品驱动增长（Product-Led Growth，PLG）主管，在 Mend 公司领导产品驱动增长。在加入 Mend 公司之前，曾在研发团队中任职，并在以色列国防军中担任过战斗操作员。</p><p></p><p>原文链接：</p><p></p><p>https://www.mend.io/free-developer-tools/blog/cloud-native-applications-and-managing-their-dependencies/</p>",
    "publish_time": "2022-11-24 09:09:06",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "不确定的时代下，技术人如何平稳成长与进阶？｜InfoQ大会早班车第28期",
    "url": "https://www.infoq.cn/article/c6Q7M7MRjWxyrWjc36I1",
    "summary": "<p>疫情下，不确定性都在增加，企业“降薪”“优化”纷纷来袭，如何管理好自己的身心健康，平稳过度与成长，是我们所关注的话题，本次大会早班车邀请到国家二级心理咨询师王宇、字节跳动商业化技术架构负责人王衎，携手为技术人健康成长加码。</p>",
    "publish_time": "2022-11-24 10:10:38",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]