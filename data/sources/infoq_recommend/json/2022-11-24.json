[
  {
    "title": "Meta将百万行代码从Java移植到Kotlin",
    "url": "https://www.infoq.cn/article/aTY2ysTOjaEwUv9Hzls6",
    "summary": "<p>Meta一直在<a href=\"https://engineering.fb.com/2022/10/24/android/android-java-kotlin-migration/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjkxNjY4MzYsImZpbGVHVUlEIjoiOHFPMXJXMFVWNU1GYVI4aCIsImlhdCI6MTY2OTE2NjUzNiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.sCjTb5aVi_x1cnjBZ1jc4QWKIEUXgqkG1gYhh1RUxgE\">将他们的Android代码库从Java移植到Kotlin</a>\"。Meta的工程师Omer Strulovich解释说，在这个过程中，他们学到了许多有趣的经验教训，并积累了一些有用的方法。</p><p></p><p>Meta之所以决定采用Kotlin开发Android应用，是因为他们看到了<a href=\"https://www.infoq.cn/article/qt51vqATE7jf_bpw5ggJ\">Kotlin</a>\"相对于Java的优势，包括可空性和函数式编程支持、更简短的代码，以及创建特定领域语言的可能性。Kotlin工程师还清楚地知道，他们必须将尽可能多的Java代码库移植到Kotlin，以防止Java空指针问题潜入Kotlin代码库，并减少需要维护的Java代码。这不是一件容易的事，从一开始就需要做相当多的调研工作。</p><p></p><p>Meta工程师必须克服的第一个障碍是，Meta使用的几个内部优化工具无法与Kotlin正常兼容。例如，Meta必须更新<a href=\"https://github.com/facebook/redex?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjkxNjY4MzYsImZpbGVHVUlEIjoiOHFPMXJXMFVWNU1GYVI4aCIsImlhdCI6MTY2OTE2NjUzNiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.sCjTb5aVi_x1cnjBZ1jc4QWKIEUXgqkG1gYhh1RUxgE\">ReDex Android字节码优化器</a>\"和语法高亮显示工具Pygments的<a href=\"https://github.com/pygments/pygments/pull/1699?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjkxNjY4MzYsImZpbGVHVUlEIjoiOHFPMXJXMFVWNU1GYVI4aCIsImlhdCI6MTY2OTE2NjUzNiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.sCjTb5aVi_x1cnjBZ1jc4QWKIEUXgqkG1gYhh1RUxgE\">词法分析器组件</a>\"，并构建一个<a href=\"https://github.com/google/ksp?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjkxNjY4MzYsImZpbGVHVUlEIjoiOHFPMXJXMFVWNU1GYVI4aCIsImlhdCI6MTY2OTE2NjUzNiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.sCjTb5aVi_x1cnjBZ1jc4QWKIEUXgqkG1gYhh1RUxgE\">Kotlin符号处理（KSP）API</a>\"，用于创建Kotlin编译器插件。</p><p></p><p>在代码转换方面，Meta工程师选择使用Kotlin官方转换器J2K，它可以作为编译器插件使用。除了一些特定的框架（包括JUnit）之外，这种方法工作得非常好。但对于特定的框架，这个工具缺乏足够的知识，无法进行正确的转换。</p><p></p><p></p><blockquote>我们已经遇到了很多需要进行小修复的情况。有些很容易做到（比如替换isEmpty），有些需要做一些研究工作才能搞清楚（与JUnit规则的情况一样），还有一些是针对J2K本身的bug的变通方法，这些bug可能会导致出现任何问题——从构建时错误到运行时行为。</blockquote><p></p><p></p><p>处理这种情况的正确方法包括三个步骤：首先是准备好Java代码，然后在headless模式的Android Studio实例中自动运行J2K，最后对生成的文件进行后续处理，进行所有所需的重构和修复。Meta已经<a href=\"https://github.com/fbsamples/kotlin_ast_tools?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjkxNjY4MzYsImZpbGVHVUlEIjoiOHFPMXJXMFVWNU1GYVI4aCIsImlhdCI6MTY2OTE2NjUzNiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.sCjTb5aVi_x1cnjBZ1jc4QWKIEUXgqkG1gYhh1RUxgE\">开源</a>\"了许多重构工具，以帮助其他开发人员完成相同的任务。</p><p></p><p></p><blockquote>这些自动化转换过程并不能解决所有的问题，但我们能够优先解决最常见的问题。我们针对模块运行转换脚本（我们贴切地称之为Kotlinator），优先考虑活跃和简单的模块。然后我们观察生成的代码：它们可以通过编译吗？它们是否可以顺利通过我们的持续集成管道？如果可以，我们就提交它们。如果不可以，我们就研究问题，并设计新的自动重构过程来修复它们。</blockquote><p></p><p></p><p>Meta已经通过这种方式移植了超过1000万行Kotlin代码，让大多数的Meta Android工程师切换到<a href=\"https://www.infoq.cn/article/TaUjgp7HuFEXBcAu_rw8\">Kotlin</a>\"来完成他们的日常工作。这个过程也验证了许多预期的结果，包括更短的生成代码和不变的执行速度。但是，从消极的方面来看，Kotlin编译器比Java编译器慢得多。使用KSP来处理注解，改进Java存根生成和编译时间，这为优化带来了新的可能性，不过仍然需要持续的努力。</p><p></p><p>如果你对完整的细节感兴趣，请不要错过Meta的这篇关于迁移到Kotlin的文章。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2022/11/meta-port-java-kotlin/?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjkxNjY4MzYsImZpbGVHVUlEIjoiOHFPMXJXMFVWNU1GYVI4aCIsImlhdCI6MTY2OTE2NjUzNiwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo2MjMyOH0.sCjTb5aVi_x1cnjBZ1jc4QWKIEUXgqkG1gYhh1RUxgE\">https://www.infoq.com/news/2022/11/meta-port-java-kotlin/</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/lOCkY3lV2ADRvXcsZEb2\">Kotlin&nbsp;Multiplatform Mobile 进入 Beta 测试</a>\"</p>",
    "publish_time": "2022-11-24 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "如何管理云原生应用程序的依赖关系",
    "url": "https://www.infoq.cn/article/1TvgZix4z6HlMubu061X",
    "summary": "<p></p><p>许多企业正在将他们的业务转移到云端，这使得他们能够更灵活、更迅速地响应市场的变化，并且更易于拓展自己的业务。但由于要进行大量的规划和实施，所以向云端迁移可能也是一项非常艰巨的任务。术语“云原生”是一种利用云计算交付范式的优势进行开发和运行应用程序的方式。</p><p></p><h2>“云原生”意味着什么？</h2><p></p><p></p><p>应用程序在哪里被托管并不重要，重要的是如何开发和部署它们。云原生开发既可以使用公共云，也可以使用私有云。任何云存储都具有存储功能并支持来自全球任意一个公共网关的访问，而无需考虑实际地理位置。它们能够为软件开发者提供按需访问的处理能力以及最新的数据和应用服务。<a href=\"https://www.mend.io/resources/blog/a-brief-guide-to-cloud-native-applications-technology-and-security/\">云原生应用</a>\"是使用微服务开发的，而微服务是小型、独立的服务，它们共同组成了一个更大的应用程序。</p><p></p><p>微服务是一种能够让开发者更轻松地构建和维护大型应用程序的软件架构。在微服务架构中，将一个应用分成几个独立的小块，即为服务。每一个服务都可以独立开发和部署，整个过程具有更大的灵活性和可扩展性。</p><p></p><p>微服务可以在几个方面使云基础设施受益。首先，它们允许对应用程序的各个部分进行更细化地控制，云中的应用程序可以轻松地进行部署和管理。其次，微服务使应用程序扩展变得更加容易。当一个应用程序需要扩展或缩减规模时，只对需要改变的服务进行更新即可。最后，微服务可以通过允许滚动更新和部署来提高可用性。当某个服务发生故障时，其他服务会持续运行，从而提高整个系统的弹性。</p><p></p><p>当一个数据请求被提交后，它会被路由到一些不同的 Docker 容器，每个容器都在运行一套单独的微服务，为消费者提供服务。创建它们的目的是提供被广泛认可的业务价值，比如快速纳入用户反馈以实现持续改进的能力。每个容器负责操作一个针对服务客户的单一服务，这些容器能够为用户提供可扩展性和足够的保护水平。</p><p></p><h2>依赖关系如何适应？</h2><p></p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/0b/2b/0b70defa10bcdfde70f5bf8072edc42b.png\" /></p><p></p><p>依赖关系是一段代码和另一段代码之间的隐性或显性关系，可以认为是为了正确运行，一段代码对另一段代码的要求。</p><p></p><p>有两种主要类型的依赖关系：硬依赖和软依赖。硬依赖是指不破坏依赖于它们的代码就无法更改的依赖关系，软依赖关系则可以在不破坏依赖代码的情况下就能被更改。</p><p></p><p>依赖关系可以是内部的，也可以是外部的。内部依赖是指同一软件系统中两段代码之间的依赖关系，外部依赖是指位于不同软件系统中的两段代码之间的依赖关系。</p><p></p><p>在云原生应用中，每个微服务都有自己的依赖关系，这些依赖关系由运行微服务的容器来管理，容器负责确保使用正确版本的依赖关系，并使其保持最新。</p><p></p><p>由于从头开始开发这些特性需要大量的时间，并且设计颇具复杂性，因此使用现有的解决方案要高效得多。既然需要这么多的依赖，也就需要管理这些依赖的解决方案，因此就有了 Maven 或 NPM 这样的包管理器。例如，NPM 要求在部署前将各种依赖关系加载到容器中。许多依赖关系是开源的，各种研究人员都能接触并发现其中的漏洞，这也是它们持续更新的原因之一。</p><p></p><p>依赖关系是开发者非常关心的问题，一旦被忽视，就会演变为安全问题。开发者如果不够谨慎，便会通过依赖存在已知漏洞的代码，很容易将漏洞引入它们的代码库中。这就是为什么在安装第三方依赖关系之前需要对它们进行扫描，并在它们可用时应用安全补丁是很重要的。</p><p></p><p>举个例子，<a href=\"https://nodejs.org/en/\">NodeJS</a>\" 通常每月更新一次，每次更新都会修复几个漏洞。因此，必须定期更新这些系统，以确保可以尽可能多地避免与依赖有关的漏洞。</p><p></p><h2>依赖关系管理的最佳实践</h2><p></p><p>当谈论<a href=\"https://www.mend.io/free-developer-tools/blog/dependency-management/\">依赖关系管理</a>\"时，我们会谈论很多不同的策略和考虑事项，例如使用自动依赖关系管理工具或软件包管理器。为了确保依赖关系得到有效管理，以下是一些可以利用的最佳实践。</p><p></p><h3>检测所有未使用的依赖关系</h3><p></p><p>你可以使用 <a href=\"https://github.com/depcheck/depcheck\">depcheck</a>\" 来检查是否存在任何没有被使用的依赖关系。需要使用以下命令来安装 depcheck。</p><p></p><p><code lang=\"bash\">npm install depcheck -g</code></p><p></p><p>安装完毕后，你可以运行下面的命令来检查是否存在未使用的依赖关系。</p><p></p><p><code lang=\"plain\">depcheck</code></p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/ac/2d/ac83597aec73fd85958fd38c155b432d.png\" /></p><p></p><p></p><h3>检测所有过期的依赖关系</h3><p></p><p>大多数依赖关系是开源的，通常在安全研究人员发现漏洞或增加新的特性时，会在一段时间内更新一次。因此，你的依赖关系可能存在过期的风险。因此，验证和更新<a href=\"https://docs.npmjs.com/cli/v6/commands/npm-outdated\">过期的依赖关系</a>\"非常关键。</p><p></p><p>要检查过时的依赖关系，你可以通过导航到 NPM 文件夹打开终端，运行以下命令：</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/96/a3/96a4dd973b9450f1601babbf616112a3.png\" /></p><p></p><p>你也可以使用一个简单的依赖关系检查脚本，它将检查一个 repo 或软件包的所有依赖关系。</p><p></p><p><code lang=\"bash\">#!/bin/bash\nDIRNAME=${1:-.}\ncd $DIRNAME\n\nFILES=$(mktemp)\nPACKAGES=$(mktemp)\n\nfind . \\\n    -path ./node_modules -prune -or \\\n    -path ./build -prune -or \\\n    \\( -name \"*.ts\" -or -name \"*.js\" -or -name \"*.json\" \\) -print &gt; $FILES\n\nfunction check {\n    cat package.json \\\n        | jq \"{} + .$1 | keys\" \\\n        | sed -n 's/.*\"\\(.*\\)\".*/\\1/p' &gt; $PACKAGES\n\n    echo \"--------------------------\"\n    echo \"Checking $1...\"\n    while read PACKAGE\n    do\n        RES=$(cat $FILES | xargs -I {} egrep -i \"(import|require).*['\\\\\"]$PACKAGE[\\\\\"']\" '{}' | wc -l)\n        if [ $RES = 0 ]\n        then\n            echo -e \"UNUSED\\t\\t $PACKAGE\"\n        else\n            echo -e \"USED ($RES)\\\\t $PACKAGE\"\n        fi\n    done &lt; $PACKAGES\n}\n\ncheck \"dependencies\"\ncheck \"devDependencies\"\ncheck \"peerDependencies\"\n</code></p><p></p><h3>保持所需的依赖关系更新</h3><p></p><p></p><p>由于所使用的依赖关系种类繁多，因此有必要确保所需的依赖关系始终保持最新，以确保最佳性能。手动检查和升级这些依赖关系通常需要大量的时间。因此，各种各样的组织利用自动化的依赖关系管理工具，以确保他们的依赖关系在一致的基础上及时地保持更新。NPM 应用程序中的依赖关系是在仓库的 package.json 文件中定义的。这些文件具有以下类型的内容：</p><p></p><p><code lang=\"json\">{\n  \"name\": \"herodevs-packages\",\n  \"version\": \"0.0.0\",\n  \"scripts\": {\n    \"ng\": \"ng\",\n    \"precommit\": \"lint-staged\",\n    \"start\": \"ng serve\",\n    \"build\": \"ng build\",\n    \"test\": \"ng test\",\n    \"lint\": \"ng lint\",\n    \"e2e\": \"ng e2e\",\n    \"build-lazy\": \"ng build lazy\",\n    \"build-dynamic\": \"ng build dynamicService\",\n    \"npm-pack-lazy\": \"cd dist/loader &amp;&amp; npm pack\",\n    \"npm-pack-dynamic\": \"cd dist/dynamic &amp;&amp; npm pack\",\n    \"package-lazy\": \"npm run build-lazy &amp;&amp; npm run npm-pack-lazy\",\n    \"package-dynamic\": \"npm run build-dynamic &amp;&amp; npm run npm-pack-dynamic\",\n    \"package\": \"rm -rf dist/ &amp;&amp; npm run package-dynamic &amp;&amp; npm run package-lazy\"\n  },\n  \"private\": false,\n  \"dependencies\": {\n    \"@angular/animations\": \"^8.0.0\",\n    \"@angular/common\": \"^8.0.0\",\n    \"@angular/compiler\": \"^8.0.0\",\n    \"@angular/core\": \"^8.0.0\",\n    \"@angular/forms\": \"^8.0.0\",\n    \"@angular/platform-browser\": \"^8.0.0\",\n    \"@angular/platform-browser-dynamic\": \"^8.0.0\",\n    \"@angular/router\": \"^8.0.0\",\n    \"core-js\": \"^2.5.4\",\n    \"rxjs\": \"~6.5.2\",\n    \"zone.js\": \"~0.9.1\"\n  },\n  \"devDependencies\": {\n    \"@angular-devkit/build-angular\": \"~0.800.0\",\n    \"@angular-devkit/build-ng-packagr\": \"~0.800.0\",\n    \"@angular/cli\": \"~8.0.2\",\n    \"@angular/compiler-cli\": \"^8.0.0\",\n    \"@angular/language-service\": \"^8.0.0\",\n    \"@types/jasmine\": \"~2.8.8\",\n    \"@types/jasminewd2\": \"~2.0.3\",\n    \"@types/node\": \"~8.9.4\",\n    \"codelyzer\": \"^5.0.1\",\n    \"husky\": \"1.3.1\",\n    \"jasmine-core\": \"~2.99.1\",\n    \"jasmine-spec-reporter\": \"~4.2.1\",\n    \"karma\": \"~3.0.0\",\n    \"karma-chrome-launcher\": \"~2.2.0\",\n    \"karma-coverage-istanbul-reporter\": \"~2.0.1\",\n    \"karma-jasmine\": \"~1.1.2\",\n    \"karma-jasmine-html-reporter\": \"^0.2.2\",\n    \"lint-staged\": \"8.1.0\",\n    \"ng-packagr\": \"^5.1.0\",\n    \"prettier\": \"1.16.1\",\n    \"protractor\": \"~5.4.0\",\n    \"ts-node\": \"~7.0.0\",\n    \"tsickle\": \"^0.35.0\",\n    \"tslib\": \"^1.9.0\",\n    \"tslint\": \"~5.11.0\",\n    \"typescript\": \"~3.4.5\"\n  },\n  \"lint-staged\": {\n    \"*.{ts,tsx}\": [\n      \"prettier --parser typescript --writeprettier --parser typescript --write\",\n      \"git add\"\n    ]\n  }\n}\nFooter\n© 2022 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\n</code></p><p></p><h3>使用自动化依赖关系管理工具</h3><p></p><p>依赖关系管理的自动化有助于以下几个方面。它不仅可以加快你的开发过程，而且还可以确保你的团队中的每个人都在使用相同版本的依赖关系。自动化工具的工作原理是查看你在代码中声明的依赖关系，并将它们与可用的版本进行比较。如果有一个较新的版本可用，该工具将更新你的项目以使用它。</p><p></p><p>与依赖关系相关的更新日志通常包括在拉取请求中。在配置依赖关系管理工具时，你有很多不同的选项可以选择，比如更新时间，哪个依赖关系必须被更新，如果拉取请求需要自动合并，需要满足什么条件，以及其他许多事项。</p><p></p><p><a href=\"https://github.com/marketplace/renovate\">Mend Renovate</a>\" 就是一个例子，它是一个开源工具，为所有类型的<a href=\"https://www.mend.io/free-developer-tools/blog/why-and-how-you-should-automate-dependency-updates/\">依赖关系更新</a>\"自动创建拉取请求。Renovate 与其他依赖关系更新工具不同，因为它是完全可配置的，可以设置为定期自动更新依赖关系，或者只在有新的安全更新时自动更新。它提供的功能包括：完全自动化地拉取请求创建和合并，基于软件包流行度和测试数据的依赖关系选择，支持多个软件包管理器，包括 npm、yarn、composer，以及为每个仓库定制的更新规则。</p><p></p><h2>结语</h2><p></p><p></p><p>在云原生世界中，一个典型的环境是由各种各样的依赖关系支持的。全面地测试这些依赖关系对任何云原生应用的成功都至关重要。然而，手动更新所有的依赖关系可能很困难，也很耗时。自动化的依赖管理工具可以帮助减少花在管理依赖关系上的时间，也可以提高代码的质量。</p><p></p><p>作者简介：</p><p></p><p>Guy Bar-Gil，一位经验丰富的产品驱动增长（Product-Led Growth，PLG）主管，在 Mend 公司领导产品驱动增长。在加入 Mend 公司之前，曾在研发团队中任职，并在以色列国防军中担任过战斗操作员。</p><p></p><p>原文链接：</p><p></p><p>https://www.mend.io/free-developer-tools/blog/cloud-native-applications-and-managing-their-dependencies/</p>",
    "publish_time": "2022-11-24 09:09:06",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "不确定的时代下，技术人如何平稳成长与进阶？｜InfoQ大会早班车第28期",
    "url": "https://www.infoq.cn/article/c6Q7M7MRjWxyrWjc36I1",
    "summary": "<p>疫情下，不确定性都在增加，企业“降薪”“优化”纷纷来袭，如何管理好自己的身心健康，平稳过度与成长，是我们所关注的话题，本次大会早班车邀请到国家二级心理咨询师王宇、字节跳动商业化技术架构负责人王衎，携手为技术人健康成长加码。</p>",
    "publish_time": "2022-11-24 10:10:38",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "怎么用数字化技术建一座“智慧金矿”",
    "url": "https://www.infoq.cn/article/3dePZg9FS9v3ms7WVwXo",
    "summary": "<p>矿山一线作业现场，尤其是地下开采作业，环境复杂，安全管理难度大，危险系数高，这些都是导致各种安全隐患发生的主要原因。而众所周知的是，解决这种极端的复杂问题恰恰是<a href=\"https://www.infoq.cn/article/Dx3Jov25cFcUKvPL0sjv\">AI</a>\"技术的强项。</p><p></p><p>在理想状态下，可以让机器人、智能装备替代人工，深入矿区一线现场开展采掘作业活动，然后通过物联网、云计算、边缘计算等技术把现场环境数据、作业数据实时传输到地面的控制中心，经过AI进行处理、分析，实现对矿山现场作业的全面感知、实时互联、地上地下协同、危险动态预测等等，从而实现现场<a href=\"https://www.infoq.cn/article/UlxmUYElHHjTsU55rFUP\">无人化</a>\"作业。</p><p></p><p>近几年，越来越多的矿山企业正在矿山开采场景使用数字化技术革新生产力，<a href=\"https://www.zhaojin.com.cn/about/index.htm\">招金矿业</a>\"股份有限公司（以下简称“招金矿业”）便是其中之一。作为一家集勘探、开采、选矿及冶炼于一体的综合性黄金生产和黄金冶炼企业，为了应对上述矿山行业面临的普遍问题，招金矿业打造了一套“黄金智慧矿山数据决策平台”。平台对矿山中3000多个关键数据点位进行了实时监测和深度分析，结合现场采、掘、提、运、风、水、电、选、充等业务动态管理梳理了近200个数据场景，成为招金矿业构建智慧矿山的基础。</p><p></p><p>不过，注意我们前面描述的是某种“理想状态”，技术的确可以在矿山开采和管理过程中发挥很大的作用，但是据《麦肯锡研究报告》有关数据显示，由于庞大运营规模、高度复杂性，因变化而产生高额成本，传统采矿业在新技术应用，特别是数字化方面显得速度缓慢，矿业公司设备数据利用率不足1%——这是“现实情况”。</p><p></p><p>围绕这些具体实践过程中到问题，InfoQ采访了山东金软科技部分有限公司总工程师桑锦国博士，深入了解了招金矿业实现数字化技术与现代矿山开采技术融合的挑战与经验，以及AI技术在金矿开采场景的实际价值。</p><p></p><h2>深层资源开采需求大，招工难度高，急需技术补齐产能</h2><p></p><p></p><p>过去，矿山行业普遍存在现场不透明、传递不及时、数据缺分析等问题。桑锦国告诉InfoQ，其背后主要涉及三方面的原因：</p><p></p><p>首先，从技术角度来看，矿山生产环境不仅复杂而且恶劣，导致现场<a href=\"https://www.infoq.cn/article/1q20RyHVsgS7xi4k1yVc\">数据</a>\"的获取难度比较大，这是天然存在的挑战；其次，从管理角度来看，过去矿山的管理模式比较粗放，不同矿区企业的管理水平参差不齐，对数据的规划工作不到位；其三，负责矿区生产的人员水平不一，对数据的重视不足，或者专业数据团队缺乏，导致很多具体的工作无法开展，比如自动设备采集的数据未及时报送，获取数据的时间滞后等等。</p><p></p><p>因此，给矿山“插上科技的翅膀”并不是一件容易的事，要改变这样的现状必须有足够的动力。对于招金矿业来说，这种动力来自于内外部的双向叠加。</p><p></p><p>“随着社会的发展对资源的消耗，地面浅层的资源逐渐耗尽，这时摆在整个矿山行业面前的挑战是，必须往更深、条件更恶劣的井下进行开采，而越往下，温度、地压等条件越差，危险性也越高。与此同时，人口红利正在消失，矿山现场的<a href=\"https://www.infoq.cn/article/c5sK6pGM4B66Afoux54a\">招工难</a>\"度越来越大，基础作业人员大量减少，技术型工种培养难，环境成本、能源成本及合规性成本也越来越高。”桑锦国表示。</p><p></p><p>据他介绍，除了这些来自行业的客观挑战，招金矿业自身还面临另一个诉求：按照政策要求，过去井下生产外包的模式不再适用，这意味着公司层面必须要组建自己的产业化队伍。但是，迫于招工压力，招金矿业不得不考虑通过技术的升级，用<a href=\"https://www.infoq.cn/news/VitTKb0zLljDj4QTPMpw\">智能化</a>\"手段替代部分人工投入，提高生产效率，确保安全生产。</p><p></p><p>具体来说，招金矿业把自身的数字化建设思路拆解为三个阶段：</p><p></p><p>第一阶段，实现智慧矿山管理、技术应用、数据架构和能力建设。在原有的数字化技术应用基础上，建设一体化集成控制系统、全流程数字化选矿厂、智能充填、综合调度、采矿专业调度、安全智能管控、工程项目管理、地测采协同、数据平台。基本实现智慧矿山生产域信息化运行，实现数字化转型的业务、数据横向到边，纵向到端。</p><p></p><p>第二阶段，提升采掘机械化水平，提升业务管理协同能力，实现安全生产一体化。在第一阶段系统建设基础上加强集成，打通生产域的全流程，实现业务管理横向集成到边，实现安全生产一体化集成管控；初步建成工艺模型、控制模型、经济模型、决策模型、安全模型、<a href=\"https://www.infoq.cn/article/iqfk6OvNdQmV1xxTWO03\">知识图谱</a>\"，并赋能业务生产；智慧矿山整体构建完成，数字化转型生产域建成。</p><p></p><p>第三阶段，实现数据赋能，夯实智慧矿山建设成果。建设数据图谱、工艺库、模型库、方案库、知识库等知识类应用，形成经验沉淀，用于业务的持续优化与改进。最终实现智慧矿山建成并发挥整体作用，数字化转型生产域与其他域实现集成，实现流程化、标准化管理，形成招金特色的智慧矿山模式和数字化文化。</p><p></p><h2>采集地下数据，需要完善矿山现场的基础设施建设</h2><p></p><p></p><p>在具体的实践落地过程中，招金矿业很快明确了“数据”是基础中的基础。而要把数据从状况复杂的地下环境中采集出来，则需要矿山现场具有比较完善的基础设施。</p><p></p><p>“第一，是机械化设备向智能化进行改造；第二，是井下网络基础的建设和优化；第三，是设备控制系统，以及通风、排水、配电等辅助系统的自动化改造。初步目标是实现现场的无人化和远程控制。”桑锦国指出，“除此之外，还有一些前沿技术的应用，包括空间信息技术，能够在井下通过三维建模，对矿山进行三维可视化呈现；同时，还涉及物联网、边缘计算、大数据平台、AI等多学科、多专业交叉的<a href=\"https://www.infoq.cn/article/YPbD1WQVSdrX9XiBVjcT\">综合能力</a>\"建设。”</p><p></p><p>以招金矿业着重打造的“黄金智慧矿山数据决策平台”为例：平台从PLC、传感器、智能仪表等各类物联网终端实时直采数据，通过局域网、工业环网，以及WIFI6、5G等无线通信技术，可以实现数据云端传输和接入，人、机、料、环信息互联互通。</p><p></p><p>据了解，该平台覆盖了招金矿业矿山中3000多个数据点位，面对这些海量数据，通过“数据场景”方法，把它们梳理成近200个直观、多维的<a href=\"https://xie.infoq.cn/article/5e966e601cbec18579608a5df\">数据场景</a>\"。并且，构建了围绕产量、效率、设备及能源四个方面的管理指标监控体系，通过多维图形化展示，使得数据真正发挥价值，为企业识别产能提升瓶颈、评估生产效率、掌握设备运行趋势及合理压缩能源消耗提供量化的数据支撑。</p><p></p><p>“人力成本和能耗成本是矿山行业的两大可变成本，所以，追求降本，我们的核心出发点就是通过全面掌握生产各个环节的实时状态，及时发现和响应过程中的异常预警，从而降低能耗、减少设备故障、维修，减少人员投入。从增效的角度来说，主要是减少信息流通环节的时间，加强人与人、人与设备、组织与组织、业务与管理的高效协同。”桑锦国强调。</p><p></p><p>在他看来，“人”是决定这些技术能否顺利落地、发挥价值的关键所在。“不同矿山的规模大小不同，信息化、自动化、智能化水平不同，人员意识差距也比较大。但往往技术的问题是可以克服的，人员的意识如果跟不上，就会变成项目推进过程中的阻力。”</p><p></p><p>正因如此，招金矿业并不是把数据决策平台的建设作为一个简单的信息化项目，而是从思想意识、组织架构、人员配齐等方面进行了全方位的布局。</p><p></p><p>首先，在思想意识层面，招金矿业的一系列规划都是自上而下推行，目的就是让内部员工从意识上先行对齐；其次，在<a href=\"https://www.infoq.cn/article/organization-arch-influence-technology-arch\">组织架构</a>\"层面，招金矿业信息中心整体负责组织公司的信息化规划和建设，从网络建设、硬件配置、软件系统管理上做到一定程度规范，此外在下属矿山企业也设置了大数据（四化）建设办公室，与公司总部信息中心对接；同时，在人员配齐方面，招金矿业还在2019年收购了智能矿山设计、研发、建设、运维公司山东金软科技股份有限公司，为数据管理、数据应用的工作开展提供了充足的人员保障。</p><p></p><h2>用可见的效益，潜移默化影响人的转型意识</h2><p></p><p></p><p>当然，无论是自上而下的体系化规划，还是组织架构的重新调整，都是由外而内的推力。桑锦国认为，只有从根本上改变人的思想意识，才能让数字化项目由内而外形成正向循环。但用他的话说，“这是需要时间的。”</p><p></p><p>“智慧矿山的建设，不是说技术先进性达到了它就完成了，从管理层到一线生产工人都要逐渐达到自觉意识，这件事才有可能做好。但是，这是一个潜移默化的过程，需要循序渐进，我们的办法，是让大家看到这些数字化手段给他们的工作带来实实在在的效益。”</p><p></p><p>也正是基于这一初衷，“黄金智慧矿山数据决策平台”的建设优先选择了“破碎”、“排水”、“提升”等系统作为试点。“从技术成熟度角度来说，这三个场景是目前比较容易做的；而从效益角度来看，它们也是在日常运行中存在明显问题的场景，具有可提升的空间，所以更容易产生效果。”桑锦国向InfoQ记者介绍。</p><p></p><p>拿破碎系统来说，通过工艺分析和历史数据建模，在不改变现有工艺、不增加硬件投入的情况下，破碎效率提高了15%左右；再比如排水系统，通过构建水仓液位和水泵能力模型，根据实时的液位数据，预测水仓的液位变化，并基于水仓的安全上下限，以及峰平谷时段的分布，合理给出水泵的启停建议，能实际节约7%的能耗电费；对于提升系统，通过建立提升机运行速度与运行电流的数据模型，可以根据不同数据表现，建议调速调频，还可以判断罐笼配重异常，建议及时检查等，提高了提升机的安全运行效率。</p><p></p><p>必须强调的是，无论在哪一个场景下，要让这些AI<a href=\"https://xie.infoq.cn/article/c78637e0d3db5513ac232d71c\">算法模型</a>\"奏效，至少需要两个前提——第一，用于分析的数据是准确的；第二，模型的参数配置是合理的。而桑锦国表示，要满足这两个前提条件，要求技术和业务<a href=\"https://b.geekbang.org/?utm_source=geektimeWeb&amp;utm_medium=menu&amp;utm_campaign=entranceplatform&amp;gk_source=2021090101_geektimeweb_menu\">充分融合</a>\"。</p><p></p><p>招金矿业解决这个问题的办法，依旧是从“人”出发。比如，基于“黄金智慧矿山数据决策平台”，会由金软科技业务顾问、数据分析员、工程师与矿山的班组人员、工艺工程师、设备维护人员等一线人员一起组建“数字先锋”小组，每一个数据场景都有一个来自一线“数字先锋”负责，对数据场景持续的使用、深化、优化、创新不断提出建议，同时与小组其他专家一起，利用平台提供的工具工具，快速进行数据试验、原型验证、模型测试、深度分析。</p><p></p><p>“我们会定期把矿山的一些一线领导请到金软科技，针对技术和业务的交流融合给出他们的建议，这也是为了确保我们构建的算法模型能够真正契合于现场，贴合业务需求，能够真正指导现场。”桑锦国强调。</p><p></p><p>可见，虽然数字化注定是一块难啃的“骨头”，但是众企业各有各的招。按照既定计划，招金矿业“智慧矿山”的建造正在稳步推进中。“黄金智慧矿山数据决策平台”的成功上线应用，既为这座“智慧矿山”打下坚实的地基，同时也成为国内黄金矿山的智能化升级改造的典型范例。在非煤矿山行业数字化演进过程一直落后于煤炭行业的背景下，填补了目前国内非煤矿山安全生产大数据深化应用方面的空白，迈出了招金矿业“数字赋能”的关键一步，也必将成为行业发展的一个关键里程碑。</p>",
    "publish_time": "2022-11-24 13:02:08",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]