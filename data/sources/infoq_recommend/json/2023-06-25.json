[
  {
    "title": "数据库内核杂谈（三十四）- 向量数据库（2）深入浅出聊存储",
    "url": "https://www.infoq.cn/article/2u1E9oftIt2NlAksybMi",
    "summary": "<p>欢迎阅读新一期的内核杂谈。上一期杂谈关于vector database开了个头，介绍了什么是vector embedding，以及vector embedding对于大模型，人工智能的作用。这一期，咱们开始深入学习vector database的存储。</p><p></p><p></p><h2>相似度（similarity metrics）介绍</h2><p></p><p></p><p>在介绍具体的存储格式之前，咱们还需要复习一个前置知识点：similarity metrics。上期聊了用vector embedding来描述一个对象。并且介绍了绝大部分应用都是通过计算不同VE的相似度（similarity metrics）来完成查询，比如找到非常相似的对象来做推荐。咱们也介绍了一种具体的相似度metric：cosine similarity（余弦相似度），用来做情感分析。</p><p></p><p>余弦相似度的数学定义：两个向量之间角度的余弦值。即，它是向量的点积除以它们的长度的乘积。根据计算公式可得出，余弦相似度不依赖于向量的大小，而只依赖于它们的角度。余弦相似度的值总是属于区间[-1, 1]。当两个向量方向相同时（夹角为0度），值是1，两个向量正交（垂直，夹角为90度）时是0，方向相反时值是-1（夹角为180度）。下图是计算向量a和向量b的余弦相似度的公式：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/7f/7f4a0c9d44e9fef8eb7bcf038b74b0d9.png\" /></p><p></p><p>除了余弦相似度，另外两类常见的相似度是Euclidian distance和Manhattan distance。网上和wiki上有大量介绍相似度的文章，请允许我copy-paste一下。</p><p></p><p>Euclidian distance（欧几里得距离）:两个向量点在多维空间下的直线距离。下图清晰地展示了什么是Euclidian distance。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/46/466aa8c3ace37abb1557424d5842def6.png\" /></p><p></p><p>计算公式也很直观：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/54/54486c30a4a34caedf54689fef82c29a.png\" /></p><p></p><p></p><p>Manhattan distance（曼哈顿距离，又称之为城市区块距离）：对两个向量在每个维度上的差值的绝对值进行求和。下面这张图就能非常直观地展示Manhattan distance，以及为它被称为Manhattan distance（因为在曼哈顿，block都是规整的一个方块一个方块。在曼哈顿，从一个点到另一个点必须走横竖马路）。</p><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/bf/bfba9ed3abd3b9db68192fc64cbf15ab.png\" /></p><p></p><p>（红黄蓝线都是Manhanttan distance，而绿线是euclidian distance）</p><p></p><p>计算公式如下：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/38/38dbeb7282a0c66cd57719331c118956.png\" /></p><p></p><p>欧几里得距离和曼哈顿距离又是名可夫斯基距离的L2、L1的范式的推广（这个不懂也没关系）。</p><p></p><p>介绍了这些不同的距离定义，那么在VE中，应该用哪种距离呢？这又有点玄学了。比如，余弦相似度只比较两个VE的角度，和长度无关。对于文本的VE比较时，两个文本的长短就不会影响余弦相似度的值。因此，情感分析就更适合用余弦相似度（唠唠叨叨的长篇抱怨和一句“难吃”都能表达出负面情绪）。一般原则就是，使用与训练VE的模型相同的相似度metrics。在不确定的情况下，应该尝试使用各种不同的相似度metrics来做计算并且训练模型，以查看是否可以获得更好的结果。</p><p></p><p>为什么要介绍不同的similarity metrics呢？因为，这和我们后面要介绍的存储相关。在向量数据库里，计算不同的similarity metrics对应的底层存储数据结构是不同的。向量数据库需要知道业务是如何计算similarity metrics来决定如何存储VE。下图是Pinecone数据库创建新instance时的配置参数：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d1/d1208c8bb04543d86af6d0da0db115a4.png\" /></p><p></p><p>万事俱备，终于可以开始介绍具体的存储了。在网上搜索向量数据库的存储，你可能会得到k-d tree, ball tree, Hierarchical Navigable Small World（HNSW），product quantization，ANNOY等等劝退的专业名词。内核杂谈尽量遵循深入浅出的方式，来一步一步介绍技术的演进。</p><p></p><p></p><h2>Brute-force：linear storage</h2><p></p><p></p><p>假设，你在参与一个系统设计面试。面试官的题目就是，你需要设计一个存储方式来存储大量的vectors；然后，给定一个目标vector，能够支持某种similarity metrics的查询。你会怎么做？</p><p></p><p>首先，尝试用最暴力，最简单（brute-force）的方式：每个vector，就作为一个array单独存储（我们可以用一些常见的存储array的优化方法，如delta encoding, sparce representation等，来提升存储每一个array的效率）。这被称为linear storage。</p><p></p><p>给定一个目标vector，要查询的相似的vector的计算逻辑也非常直观：遍历每一个存储的vector，和目标vector来做similarity metrics的计算，返回最接近的值（或者最接近的k个值）。算法的时间复杂度是O(n)。</p><p></p><p>既然是brute force的方法，先来讨论一下这个方法的缺点：计算的时间复杂度太高。每次查询的时间复杂度正比于存储的vector的数量。假设有1 billion的vector，每次查询要做1个billion次的比较（且还是高维向量的计算）。</p><p></p><p>那这个方法的优点呢？其实还蛮多的。1）算法简单，直观。实现起来也非常容易。2）这个存储方法和similarity metrics的计算方式是解耦的。反正每次查询都是拿目标vector和存储的vector做独立的计算。因此，可以支持不同类型的similarity metrics的查询（这和我们后面介绍的一些原生的向量存储格式不同，后者通常只针对某类similarity metrics）3）和现有的关系型数据库更容易结合，无论是row-store还是columnar-store，都不违和。可以快速地给关系型数据库加入向量数据库的功能。4）结合GPU计算资源，SIMD（single-instruction multi-data）指令或者分布式资源，在数据量没有那么海量的情况下，速度也还是可以接受的。</p><p></p><p>结合上面介绍的优点，虽然linear storage是最brute force的方法，但这是一个industry-applicable的方法。肯定有关系型数据库用这个方法来补完向量数据库的功能。</p><p></p><p></p><h2>Tree-based approach: k-d tree</h2><p></p><p></p><p>延续刚才的系统设计面试。面试官说，OK！这个方法work，但缺点就是计算时间复杂度太高。你能提出一个改进方案吗？</p><p></p><p>要改进时间复杂度，思路就是要提高搜索的效率。Brute force方法是遍历所有的vector，提效的思路就是，怎么能减少搜索空间，只进行少量的比较就能查找到相似的vector呢。在上面这些铺垫下，我们大致可以想到，二叉树这种数据结构，是不是就能拿来做优化呢。普通的二叉树可以用来存储scalar数值（标量），通过构建二叉树来对一个list的数据进行排序，在搜索的过程中能够快速查找到相似的数值（时间复杂度是O(log(n))）。</p><p></p><p>如何用二叉树来支持向量存储呢，这就是下面要介绍的k-d tree（k-dimension tree）。k-d tree是一类特殊的二叉树，用来存储k维度的向量，并支持范围搜索和近邻搜索（即，找到相似的vector）。k-d tree的构造方式是一个递归过程，通过不断地根据某个dimension，找到median point，并将整search space一分为二，直到叶节点只有一个向量（当然也可以设置其他的stop condition，比如当树的深度到达多少为止）。下面是k-d tree构造的算法描述：</p><p></p><p>0）初始化：给定k维空间中的一组点。这些点可以代表任何东西，但通常它们是描述某种数据集的特征向量。</p><p>1）创建根节点：通过选择一个维度并选择该维度上的中位数点作为根来创建根节点。维度的选择通常是轮流进行的，从第一个维度开始。</p><p>2）划分数据：所选择的中位数点将点集分成两半。在所选维度上具有较小值的点进入根的左子节点，具有较大值的点进入右子节点。</p><p>3）创建子节点：对于两半中的每一半，沿着下一个维度选择中位数点以创建子节点。再次选择的维度通常是轮流进行的。</p><p>4）递归划分：对每个子节点递归重复步骤2）和3），将每个节点处的数据划分为两个较小的子集，并创建新的子节点。</p><p>5）停止条件：递归继续，直到满足停止条件。停止条件可以是只剩下一个向量。</p><p></p><p>上面的算法描述非常直观。事实上，实现起来也一点都不复杂。下面是我让ChatGPT生成的Python代码块（非常直观的递归实现方式）：</p><p><code lang=\"text\">class KDTreeNode:\n    def __init__(self, point, split_dim=None, left=None, right=None):\n        self.point = point\n        self.split_dim = split_dim\n        self.left = left\n        self.right = right\n\n\ndef build_kdtree(points, depth=0):\n    n = len(points)\n\n    if n == 0:\n        return None\n\n    k = len(points[0])  # Dimensionality of the points\n    \n    # Select the splitting dimension\n    split_dim = depth % k\n    \n    # Sort points along the selected dimension\n    points.sort(key=lambda point: point[split_dim])\n    \n    # Choose the median point\n    median = n // 2\n    \n    # Create the node and recursively build the left and right subtrees\n    return KDTreeNode(\n        point=points[median],\n        split_dim=split_dim,\n        left=build_kdtree(points[:median], depth + 1),\n        right=build_kdtree(points[median + 1:], depth + 1)\n    )\n\n\n# Example usage:\npoints = [(2, 3), (5, 4), (9, 6), (4, 7), (8, 1), (7, 2)]\ntree = build_kdtree(points)\n</code></p><p></p><p>给定一个k-d tree，要搜索相似与目标vector的方法类似于在binary search tree上做二分查找。在数据结构上还可以做一些优化来快速找到k近邻（比如记录这个节点的子节点的数量）。计算复杂度是O(log(n))。但k-d tree只支持Euclidian distance和Manhattan distance这类距离相似度的查询，并不支持cosine similarity这类角度相似度的查询。具体的代码实现，可以留给大家作为课后作业。</p><p></p><p>k-d tree的缺点：相比较linear storage，k-d tree在搜索的复杂度上提效了。那k-d tree有什么缺点呢？1）k-d tree的构造并不是一棵完全的平衡二叉树（左右子树不平衡，搜索效率不是最优的）。按照上面的算法，虽然每次都是根据某个dimension的剩余的点的median point来做二分，但这个方式没考虑到其他dimension上的数据分布，因此，这个二分是一个local的二分法。当向量在某些dimension上分布不均匀时，就会导致二分不均匀，进而降低了查询效率。2）如果业务中需要往现有的向量列表里面加入新的向量来搜索，k-d tree并不能非常高效的支持。k-d tree可以像普通的二分查找树支持插入新数值一样去插入新向量，但这可能会导致k-d tree进一步变得愈发不平衡，从而降低查找效率。并且，k-d tree很难像自平衡的二分查找树（红黑树或AVL树）那样去做自动平衡。原因也是每一层只代表了一个dimension，很难去做到所有dimension的平衡。</p><p></p><p></p><h2>总结</h2><p></p><p></p><p>本期，咱们介绍了如何存储向量。首先介绍了常见的向量相似度的metrics：cosine similarity、Euclidian distance和Manhattan distance。然后带着大家去思考最简单、最暴力的brute force存储方式：linear storage，且分析了它的优缺点。并进一步，引导大家思考，如何提供一个改进linear storage缺点的存储方式：k-d tree。下一期的杂谈，会进一步沿着如何改进k-d tree的缺点，讨论更多的存储方式。感谢阅读！</p>",
    "publish_time": "2023-06-25 11:18:23",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "《英特尔®️至强®️实战课》视频处理系统的“三个精细化”演进",
    "url": "https://www.infoq.cn/article/5vVQpFN0IGSdkT5J0GLl",
    "summary": "<p>英特尔与行业领先技术媒体共同打造的《英特尔®️&nbsp;至强®️&nbsp;实战课》现已上线！本系列课程为互联网、医疗、金融、制造等行业提供有启发、可借鉴的实战案例，并分享基于第四代英特尔®️&nbsp;至强®️&nbsp;及英特尔数据中心产品组合成功落地实践的经验，为IT决策者、架构师和相关从业者输出最前沿的技术干货内容。</p><p></p><p>超视频时代，用户对视频体验的需求日新月异，视频应用朝着高清化、交互性、沉浸式等方向演进。与此同时，视频云也不断加速对传统行业的延伸与渗透，在工业、教育、医疗等领域涌现出更多元的落地场景。千行百业“融视频”，为视频云市场带来了全新机遇与挑战：如何通过技术创新提供更深层次体验，满足不同场景的需要，实现体验和成本的最优化变得至关重要。</p><p></p><p>《英特尔®️&nbsp;至强®️&nbsp;实战课》首期邀请火山引擎点播多媒体平台技术负责人张清源、英特尔云计算资深架构师陆扬，聚焦《视频处理系统的“三个精细化”》，以字节跳动的一线实践为例，为您分享行业发展趋势，网罗前沿技术干货，详细讲解英特尔视频云解决方案，助您瞄准业务增长决胜点！</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/2d/a5/2dbe43071249f375640b272bec8f94a5.jpg\" /></p><p></p><p></p><h1>课程内容：</h1><p></p><p></p><p>视频处理系统的“三个精细化”</p><p>主讲人：张清源 - 火山引擎点播多媒体平台技术负责人</p><p></p><p>英特尔视频云解决方案</p><p>主讲人：陆扬 - 英特尔云计算资深架构师</p><p></p><p>圆桌讨论</p><p>赵钰莹 - InfoQ极客传媒主编</p><p>张清源 - 火山引擎点播多媒体平台技术负责人</p><p>陆扬 - 英特尔云计算资深架构师</p><p></p><p><a href=\"https://s2.uao.so/8hBMxAg8\">点击观看完整视频</a>\" https://s2.uao.so/8hBMxAg8</p>",
    "publish_time": "2023-06-25 11:47:53",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "JDK 21中的结构化并发：并发编程的一次飞跃",
    "url": "https://www.infoq.cn/article/1NdPKQpZJGmKxm2v6SP2",
    "summary": "<p>JEP 453，<a href=\"https://openjdk.org/jeps/453\">结构化并发（预览）</a>\"已经从JDK 21的Targeted状态变更为Integrated状态。这个最初的预览特性来源于一个孵化API，它根据前两轮的孵化纳入了一些改进，这两轮孵化分别是JDK 19交付的<a href=\"https://openjdk.org/jeps/428\">JEP 428，结构化并发（孵化）</a>\"和JDK 20交付的<a href=\"https://openjdk.org/jeps/437\">JEP 437，结构化并发（第二轮孵化）</a>\"。在当前提案中，唯一的显著变化是<a href=\"https://cr.openjdk.org/~alanb/sc/api/java.base/java/util/concurrent/StructuredTaskScope.html#fork%28java.util.concurrent.Callable%29\">StructuredTaskScope::fork(...)</a>\"方法返回一个[<a href=\"https://cr.openjdk.org/~alanb/sc/api/java.base/java/util/concurrent/StructuredTaskScope.Subtask.html\">Subtask</a>\"]，而不是<a href=\"https://cr.openjdk.org/~alanb/sc/api/java.base/java/util/concurrent/Future.html\">Future</a>\"。这是一个<a href=\"https://openjdk.java.net/jeps/12\">预览特性</a>\"。</p><p></p><p>JDK 21中的结构化并发致力于引入结构化并发的API来简化并发编程。这种方法将在不同线程中运行的相关任务组视为一个工作单元，从而简化了错误处理和取消，提高了可靠性，并增强了可观测性。我们看一个样例：</p><p></p><p><code lang=\"java\">Response handle() throws ExecutionException, InterruptedException {\n     try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n          Supplier  user  = scope.fork(() -&gt;  findUser());\n          Supplier order = scope.fork(() -&gt;  fetchOrder());\n          scope.join()            // Join both subtasks\n                .throwIfFailed();  // ... and propagate errors\n          // Here, both subtasks have succeeded, so compose their results\n          return new Response(user.get(), order.get());\n    }\n    //...\n}</code></p><p></p><p>这段代码创建了一个新的<a href=\"https://download.java.net/java/early_access/loom/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/StructuredTaskScope.html\">StructuredTaskScope</a>\"，并使用它来创建了两个分支子任务，其中一个执行findUser()，另一个执行fetchOrder()。当这两个子任务均完成时，它会使用这两个子任务的结果创建一个新的Response。</p><p></p><p>结构化并发是一个预览API，默认是禁用的。要使用StructuredTaskScope&nbsp;API，开发人员必须启用预览API来编译该代码，如下面的命令所示：</p><p></p><p><code lang=\"java\">javac --release 21 --enable-preview Main.java</code></p><p></p><p>运行该程序也需要相同的标记：</p><p></p><p><code lang=\"java\">java --enable-preview Main</code></p><p></p><p>但是，我们可以使用<a href=\"https://openjdk.java.net/jeps/330\">源码启动器（source code launcher）</a>\"来直接运行它。在这种情况下，命令行如下所示：</p><p></p><p><code lang=\"java\">java --source 21 --enable-preview Main.java</code></p><p></p><p>使用<a href=\"https://docs.oracle.com/javase/9/jshell/introduction-jshell.htm#JSHEL-GUID-630F27C8-1195-4989-9F6B-2C51D46F52C8\">jshell</a>\"方案也是可以的，不过依然需要启用预览特性：</p><p></p><p><code lang=\"java\"> jshell --enable-preview</code></p><p></p><p>在实践中，使用StructuredTaskScope时，大多数情况下都不会直接使用StructuredTaskScope类，而是使用两个子类中的某一个，这两个子类均实现了关闭策略。这两个子类，即ShutdownOnFailure和ShutdownOnSuccess，分别支持在第一个子任务失败或成功时关闭作用域的模式。</p><p></p><p>结构化并发将在不同线程中运行的相关任务视为一个工作单元。这种方式简化了错误处理和取消，提高了可靠性，并增强了可观测性。开发者<a href=\"https://twitter.com/pressron?lang=en\">Ron Pressler</a>\"是甲骨文公司技术员工的咨询成员，并且是OpenJDK的<a href=\"https://openjdk.org/projects/loom/\">Loom项目</a>\"的技术负责人，<a href=\"https://inside.java/u/AlanBateman/\">Alan Bateman</a>\"是甲骨文公司Java平台组的工程师，他们意图消除与并发编程相关的常见风险，如线程泄露和取消延迟，并增强并发代码的可观测性。</p><p></p><p>这个新特性的目的并不是要取代<a href=\"https://cr.openjdk.org/~alanb/sc/api/java.base/java/util/concurrent/package-summary.html\">java.util.concurrent</a>\"包中的任何并发结构，如<a href=\"https://cr.openjdk.org/~alanb/sc/api/java.base/java/util/concurrent/ExecutorService.html\">ExecutorService</a>\"和<a href=\"https://cr.openjdk.org/~alanb/sc/api/java.base/java/util/concurrent/Future.html\">Future</a>\"。它的目的也不是为Java平台定义明确的结构化并发API，或在线程间共享数据流的方法。</p><p>当前的并发编程模型，如ExecutorService&nbsp;API，由于其不受限制的并发模式，引入了复杂性和风险。这些模型不会强制要求或跟踪任务和子任务之间的关系，使得并发任务的管理和可观测性很具挑战性。</p><p></p><p>结构化并发提出，任务结构应该反映代码结构。在单线程代码中，执行过程总是会强制保证任务和子任务的层次结构，每个子任务相对于其他子任务的生命周期是由代码的语法块结构来管理的。</p><p></p><p>新的StructuredTaskScope为ExecutorService提供了一个更简单、更安全地替代方案。这个API封装了一组应该一起完成的相关任务，任何子任务的失败都会导致其余子任务的取消。</p><p></p><p>有关这些变更的更多细节，包括代码示例和对该功能背后动机的全面讨论，请参阅<a href=\"https://openjdk.org/jeps/453\">OpenJDK</a>\"的网站。</p><p>这个新的API是使并发编程更容易、更可靠和更具可观测性的重要一步。预计它对构建可维护的、可靠的和可观测的服务器应用尤为有利。对深入了解结构化并发感兴趣，或愿意学习其相关背景的开发人员可以收听<a href=\"https://www.infoq.com/podcasts/java-project-loom/\">InfoQ Podcast</a>\"、Ron Pressler的<a href=\"https://www.youtube.com/watch?v=i1MgOVf-hIQ&amp;t=434s\">YouTube</a>\"课程和<a href=\"https://inside.java/tag/loom\">Inside Java</a>\"的文章。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/06/structured-concurrency-jdk-21/\">Structured Concurrency in JDK 21: A Leap Forward in Concurrent Programming</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/XfkxxI24jvuR3e2AhPmr\">Java 近期新闻：JDK 21 进入 Rampdown 阶段、JEP 404、JDK 22 专家组、Jakarta EE 11 升级</a>\"</p><p><a href=\"https://www.infoq.cn/article/R8sh9XHuojBsX9DpGYvJ\">快速实现不打折扣的云原生 Java 应用</a>\"</p><p><a href=\"https://www.infoq.cn/article/wxcjbFtvT7Twva0eeXTj\">JEP 444：JDK 21 中出现虚拟线程，开创并发新纪元</a>\"</p>",
    "publish_time": "2023-06-25 12:57:58",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]