[
  {
    "title": "Kotlin Multiplatform Mobile进入Beta测试",
    "url": "https://www.infoq.cn/article/lOCkY3lV2ADRvXcsZEb2",
    "summary": "<p><a href=\"https://www.infoq.cn/topic/kotlin\">Kotlin</a>\" Multiplatform Mobile由JetBrains创建，支持使用Kotlin从单个代码库创建具有原生UI的iOS和Android应用。Kotlin Multiplatform Mobile已经退出<a href=\"https://www.infoq.com/articles/kotlin-multiplatform-ios-developers/\">实验阶段</a>\"，<a href=\"https://blog.jetbrains.com/kotlin/2022/10/kmm-beta/\">进入Beta测试</a>\"。</p><p></p><p></p><blockquote>Kotlin Multiplatform Mobile是一个用于iOS和Android应用开发的SDK，它让你可以将网络、数据存储和分析以及Android和iOS应用的其他逻辑保存在一个共享代码库中。</blockquote><p></p><p>&nbsp;</p><p>在实验阶段，JetBrains尝试了多种内存管理、库和项目配置方法，进一步平衡了跨平台特性，包括网络、数据存储和分析，以及对原生SDK的访问。</p><p>&nbsp;</p><p>具体来说，Kotlin Multiplatform Mobile Beta版实现了一个原生的自动内存管理器，旨在通过提供无锁并发编程原语简化线程之间的对象共享。</p><p>&nbsp;</p><p>按照JetBrains的说法，Beta版本已经足够稳定，开发人员提可以开始采用Kotlin Multiplatform Mobile了。作为采用就绪的信号，JetBrains特别强调了其不断增长的多平台库生态系统、社区支持，尤其是一些<a href=\"https://kotlinlang.org/lp/mobile/case-studies/\">早期采用者的案例研究</a>\"，包括Autodesk、VMware、Netflix等。</p><p>&nbsp;</p><p>此外，许多流行的库已经采用了Kotlin Multiplatform，包括异步事件处理框架<a href=\"https://ktor.io/\">Ktor</a>\"、类型安全的SQL API生成器<a href=\"https://cashapp.github.io/sqldelight/\">SQLDelight</a>\"、GraphQL客户端<a href=\"https://www.apollographql.com/docs/kotlin/\">Apollo</a>\"和依赖注入框架<a href=\"https://insert-koin.io/docs/quickstart/kotlin/\">Koin</a>\"。</p><p>&nbsp;</p><p>Kotlin Multiplatform已集成到Android Studio中，Android开发者可以利用他们所熟悉的工具和生态系统，而iOS开发者的学习曲线肯定就不那么平缓了。虽然Android Studio是Kotlin Multiplatform开发的主要IDE，但构建iOS应用并提交到应用商店时仍然需要Xcode。</p><p>&nbsp;</p><p>在本文写作的时候，<a href=\"https://kotlinlang.org/docs/multiplatform-mobile-plugin-releases.html\">Kotlin Multiplatform Mobile插件</a>\"还处于<a href=\"https://kotlinlang.org/docs/components-stability.html#current-stability-of-kotlin-components\">Alpha阶段</a>\"。它提供了<a href=\"https://kotlinlang.org/docs/multiplatform-dsl-reference.html#top-level-blocks\">一组在Gradle文件中使用的指令</a>\"，包括新的targets （支持iOS、watchOS和tvOS平台）、sourceSet、compilation 等。</p><p>&nbsp;</p><p>如果你喜欢不同的方法，也可以使用Kotlin Multiplatform<a href=\"https://kotlinlang.org/docs/multiplatform-library.html\">创建跨平台库</a>\"，然后在独立的iOS和Android项目中使用这些库。</p><p>&nbsp;</p><p><a href=\"https://kotlinlang.org/docs/multiplatform-mobile-samples.html\">这里</a>\"有一个精心整理的Kotlin Multiplatform Mobile样例的列表，感兴趣的读者可以看一下。</p><p>&nbsp;</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2022/10/kotlin-multiplatform-mobile-beta/\">https://www.infoq.com/news/2022/10/kotlin-multiplatform-mobile-beta/</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/xmsdwMtlJIDd3u5RG6z8\">Kotlin 异步框架 Ktor 2.0 发布，提供新的插件特性</a>\"</p>",
    "publish_time": "2022-10-21 09:42:03",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "下一代 NLP 模型将走向何方？| InfoQ《极客有约》",
    "url": "https://www.infoq.cn/article/C0IXAd7dDLXDy2dV1F0V",
    "summary": "<p>现在是 NLP 的黄金时代吗？为什么预训练大模型这么火？本期 InfoQ《极客有约》，鹏城实验室网络智能部云计算所副所长相洋为你解读 NLP 技术的整体发展，以及下一代 NLP 模型将走向何方。</p>",
    "publish_time": "2022-10-21 10:53:14",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "WebAssembly的核心语言特性与未来发展",
    "url": "https://www.infoq.cn/article/jds0wDTz7DSUGzpc81hs",
    "summary": "<p><a href=\"https://dive.infoq.cn/2022/beijing\">https://dive.infoq.cn/2022/beijing\n</a>\" (简称Wasm)是目前备受关注的一门新的计算机语言，本演讲从计算机语言技术的角度解析WebAssembly的语言特性，以及WebAssembly为应用提供安全沙箱机制的原理。我们将介绍WebAssembly在浏览器以外的主要应用场景和其带来的价值，以及目前W3C正在定义中的一些主要特性及其对未来的影响。</p><p></p><p>本文整理自<a href=\"https://dive.infoq.cn/2022/beijing/presentation/4006\">英特尔中国有限公司高级技术经理王鑫</a>\"在<a href=\"https://dive.infoq.cn/2022/beijing/presentation/4006\">DIVE全球基础软件创新大会 2022</a>\"的演讲分享，主题为“<a href=\"https://dive.infoq.cn/2022/beijing/presentation/4006\">WebAssembly的核心语言特性与未来发展</a>\"”。</p><p></p><p>分享主要分为七个部分展开：第一部分是WebAssembly的标准发展；第二部分和第三部分会分别介绍语言特性、字节码与内存模型；接下来第四部分则是程序的控制流与函数调用；第五部分会带大家了解类型系统与内存垃圾回收；第六部分会讲解模块的组件模型；最后一部分会介绍WASI与字节码联盟的情况。</p><p></p><p>以下是分享实录：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/be/be77fe679941c6a59071a455f78fac7d.png\" /></p><p></p><h3>WebAssembly标准发展</h3><p></p><p></p><p>在2015年，WebAssembly第一次被对外公布。2017年MVP&nbsp;(Minimal Viable Product)规范完成，并在Chrome、Edge、Firefox和Safari等四个主流的浏览器上得到支持。到了2018年，<a href=\"https://www.w3.org/\">W3C</a>\"工作组发布了三个公开的Drafts，包含WebAssembly的Core Specification、<a href=\"https://www.infoq.cn/topic/JavaScript\">JavaScript</a>\" Interface和Web API。在2019年，WebAssembly spec 1.0正式发布。同年10月份左右，Bytecode Alliance (BA)由Intel、 Mozilla、Fastly、Redhat四家公司成立，主要的目标是构建与推广基于WebAssembly以及WebAssembly System Interface的安全软件栈。到2021年，BA正式成为非盈利性的组织，微软也加入成为协作会员，到目前已经有大概30多家的会员，发展情况非常良好。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/78/78a3506639ab9bf077657c8f97af0217.png\" /></p><p></p><p>我们看下两个基于 WebAssembly 经典的使用案例。左边是 AutoCAD在浏览器上运行，能把 30 年积累的桌面应用代码移植到到了浏览器上面，这主要归功于把大量的 C/C++ 代码转换成 WebAssembly。2021年另外一个标志性的事件就是 Adobe也把它的经典的软件Photoshop 搬移到了浏览器上面。据相关技术分析，Photoshop的 Web版应用主要也是基于WebAssembly，当运行应用的时候，可能会有高达 1G 左右的本地磁盘的缓存，只需下载10多兆的网络资源，启动时间大概3秒钟左右。整个应用充分地利用了WebAssembly和多核的技术，在运行一些操作的时候，最热的20个函数里面，SIMD向量化计算的占有率约为40%左右，这说明通过类似于向量化计算的能力，WebAssembly已经具备了支持开发强计算应用的能力。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/a5/a5b5d295eef3bb2bc9b6fcee33db6e80.png\" /></p><p></p><p></p><h3>WebAssembly语言特性</h3><p></p><p></p><p>我们这里首先对Wasm语言的特性做一个总结。它包含了二进制和文本的两种格式，它的执行模式是基于Stack的一种执行模式。它定义了四种基本的数据类型，就是32位、64位的整数，32位和64位的浮点精度。</p><p></p><p>Wasm的内存设计也很有特色，包含了托管的内存和非托管内存类型。非托管内存也叫线性内存，一个Wasm实例可以有多块的线性内存。目前线性内存的布局是由编译器来定的。为什么要了解这个呢？因为现在WebAssembly是支持多种前端语言的编译，在每个编译器有自己的内存布局的时候，会导致不同语言模块之间静态链接的技术挑战。</p><p></p><p>Wasm的流控是一个结构性的流控。它的函数调用需要使用函数表(Function table)。如果和基于C语言编译的机器指令相比，机器指令里可以直接跳到目标的物理地址，这里是一个间接地址。Wasm的函数调用操作码后面都跟着一个索引号，这个索引就是目标函数在Function table里面的索引值。如果是间接调用函数，则需要做函数类型检查。</p><p></p><p>Wasm支持一系列关键组成元素的Import and Export，一个WebAssembly程序会定义需要外部导入什么样的元素，也可以定义哪些元素可以暴露给外部来访问，为它的宿主环境，例如浏览器的JavaScript，或者在独立Wasm引擎的调用者，提供了一个可以通过编程的方式，来控制和访问目标的WebAssembly应用对象的能力。</p><p></p><p>另外一个特性是对硬件向量化计算SIMD的支持，像刚才介绍到的，Photoshop里面大量用到SIMD这种能力。</p><p></p><p>最后，它是个强类型的Type system，它也定义了GC和组件的模型。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/93/939256653c36d15d4df9eea2f7c6e99e.png\" /></p><p></p><p></p><h3>字节码与内存模型</h3><p></p><p></p><p>我们使用一个例子来介绍Wasm的字节码和内存模型。在最左边是一段C语言的源码，这段代码会被编译到屏幕中间WebAssembly的字节码，右边展示在运行态的内存布局。左边的源码定义了一个全局变量count，一个函数add，add会把输入参数x再加上count，把结果更新到count。</p><p></p><p>在main入口函数里，调用add(3)，然后打印count值。中间这一段就是编译C程序后生成的WebAssembly编码。一开始包含几个函数的类型（type）定义，0和1是type的索引值，你可以把它可以看成一个表，表里面有索引来标识了每一个类型。对应到所有引用到的函数，像代码中的add、main、printf函数。</p><p></p><p>下一行表示要import一个printf函数，这个函数在字节码里面本身没有提供实现，需要宿主环境来提供。接着定义了一个Memory,线性内存空间。再下面定义了三个Global，Global是WebAssembly定义的可以作用于全域的变量，不一定对应到源码里边的全局变量，这里可以看到源码里面的全局变量count并不是被映射到WebAssembly的Global里面的。每个Global也是有编号的，同时包含其原型的定义以及初始化的值，像9232、1040都是它的初始化的值。</p><p></p><p>接着Export它的Memory对象，通过这样宿主环境可以拿到Wasm程序的Memory对象进行访问。这个Wasm代码导出(Export)了三个对象，第一个function #2，就是暴露给宿主环境的main函数。它还导出两个Global，一个是data_end，一个是heap_base。</p><p></p><p>接下来的数据(data)表示Wasm程序的静态数据，每个数据有一个编号和线性地址位置，编号0就是printf打印的字符串的内容。第二个2是代表count的初始值，count在C源码中是一个全局变量，它实际上是在线性内存的data区。</p><p></p><p>下面索引号为1的函数是由C源码add函数编译过来，包含了函数类型说明，和上面函数type #1是对应的。下面另外一个函数(索引#2)对应到main函数，type&nbsp;#0是它的类型的定义。</p><p></p><p>右边上部是一个线性内存，支持Wasm编程来任意访问其中的任何一个位置。线性内存的读写访问需要通过字节码iload和istore。iload把线性空间中的数据移动到操作栈，其具体过程首先将偏移量设到栈里边，调这个指令之后它会从栈里面取偏移量，从线性空间的偏移量去访问拿到值，再把值压回到栈里面。istore指令则是执行一套反向的流程。</p><p></p><p>LLVM编译WebAssembly的时候，有一个约定的内存布局，首先一开始是个数据（Data）区，主要是存放源码的全局数据和静态数据。Wasm代码里面访问这些变量的时候，是通过使用静态的偏移量调用iload、istore来完成。中间的Aux Stack是Wasm程序运行中做辅助栈使用的，它与数据区的边界是有一个Wasm Global来指向的，叫data_end。data_end是个Global，前面我们已经看到将它Export出去了。Wasm程序调用malloc时从其自己的Heap里面分配数据，heap区的起始位置是通过一个叫做heap_base的Global来指定的，它的初始值是编译器在编译时候已经计算好了，回到上面可以看到Wasm文件里包含其初始化的值。</p><p></p><p>线性内存之外的其余Wasm内存是受管内存(Managed Memory)，这些对象的目标地址不是用户完全来控制的。第一种是Globals，可以把它看成一个一维的数组，这里data_end是索引值为1的Global，heap_base是第二个Global，还会有其他的一些变量按顺序依次排下去。它的访问有专门的字节码，叫做global.get，或者global.set，这些字节码后面会跟随目标Global的索引值。</p><p></p><p>还有一种受管内存叫做Locals，Locals对应的字节码叫做local.get、local.set，以及tee。Locals它是以当前的栈为基准的，在执行指令的时候，缺省就是当前的栈作为基础来进行访问和定位的。源码中基本类型的函数局部变量，可以使用Locals来映射，其他类型局部变量则会使用线性内存中Aux Stack来管理。和线性内存操作相比，Global和Local操作目标的索引值是固定在Wasm文件中，说明其在编译时刻决定。而线性内存的访问地址是由Wasm程序逻辑本身在运行时来决定。</p><p></p><p>最后还有一种叫做操作栈(Operation Stack)，Wasm许多操作码里边隐含操作栈访问，但没有任何操作码可以显式控制操作栈。比如说前面看到的add操作，它会自动在栈里面取两个数，把计算的结果再返回到栈里面去。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/10/10d22122428a40ad3d8b822b56c55934.png\" /></p><p></p><p></p><h3>控制流与函数调用</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/eb/eb50a54b0be5ff3c1cf5bf8ec6b8de17.png\" /></p><p></p><p>下面介绍一下WebAssembly程序的控制流，以及函数调用。</p><p></p><p>WebAssembly设计一种结构化的控制流，它定义了几类相关操作码，第一类就是定义一个Label，比如block是定义一个块，loop定义一个循环块。第二类包含if、else和end三种操作指令，这种方式就更接近于源码的语义了，而非像C语言编译生成的条件跳转目标指令。第三类指令表示跳转，这种指令比较接近编译后的跳转机器指令。另外一类指令是Branch，如函数的call、call_indirect和return返回。</p><p></p><p>在屏幕右边是一个Wasm文本方式表示的简单例子，它是一个循环，循环有个标识为my_loop，对应到Wasm二进制里边是个索引号。代码中压一个常数0到栈里边，作为后面比较的条件。if操作码后面跟随一组满足条件下执行的操作码，之后可能会跟随else操作码，else后面会有一系列指令，else结束后会有个叫end的指令。代码后面有一个br操作码，执行跳转到my_loop。</p><p></p><p>Wasm结构化跳转机制有几个特点，首先它的Labels是类型化的，它具有输入和输出的参数。所以在右边进if之前会压栈，进入这种Labels之后，会有它的一个独立的操作栈，它可以保证在里面有pop类的操作，不会把上级的栈破坏掉，而且退出栈的时候，它很容易回溯到上级栈的位置。</p><p></p><p>另外它的栈的跳转不能像C语言跳到一个任意的Label，它只能向上返回跳转，它通过一个Index向上返回一级或者若干级，这种方式它很有效地避免了Buffer Overflow的可能性。</p><p></p><p>函数调用操作码后面带的是一个索引值，索引代表函数在Table里边的位置，Table会真正指向函数它的物理位置。indirect call会像C语言定义的函数指针的调用，它的索引不跟随在指令码里面，而是从栈里面取，这样可以通过压栈，相当于把函数指针传进来，再调用它。</p><p></p><p></p><h3>系统类型与内存垃圾回收</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/75/75fd5ed1cc036e89cff2479c1895fc4b.png\" /></p><p></p><p>刚才在字节码里面已经看到类型信息，它所有的函数都是有一个类型的定义，而且类型是有从0开始的索引编号。垃圾回收特性(GC)目前进入了文本可用的提案2的阶段，它包含着一系列的所依赖的Spec，如引用类型Reference Type，还有就是类型化函数引用Typed Function Reference，类型导入这些提案等。</p><p></p><p>WASM GC同时又引入了一些新的类型结构，在右下角可以看到，引入了类似于像函数和数组的类型结构。Wasm的类型体系的特点是，它主要目标是描述低级的数据布局，并不有源码层面的信息，它的子类型，比如说A是B的子类型，它主要是指内存布局有覆盖关系，而不是类似于C、C++或者是Java里语言层面的显式继承的定义。在语言层面可以没有任何的继承的描述，只要它符合子类型的条件，它类型就会类似一个父子关系。在生成的目标的指令里面，操作码后面会带操作对象的类型索引号。</p><p></p><p>如果大家熟悉C的编译的话，就知道C的生成目标里面是没有类型的，所有的类型都是在编译的时候，编译器知道所有的类型信息，但是不会在生成目标的机器码里提供类型信息。WebAssembly把类型信息放到目标文件中，因为它要提供一种中间层，接近于底层的机器但是又不是真正机器底层的这么一种技术。</p><p></p><p>我们认为Wasm这么设计的确是有一些好处的。把类型信息直接传送到发行的模块里，这样有利于脱离编译器语言的依赖来实现模块的连接，即便都是从C语言源码编译过来，不同的编译器对于类型的定义有可能是不一样的，但是类似于结构还有数组，各自的理解或者约定是不一样的，更别提不同的语言它们之间的约定，语言层面也很难保证一致。所以我们都把目标的类型放到二进制的模块里面，这样不同的语言、不同的编译器它们之间的连接就会更加容易一些。</p><p></p><p>这样也会减少运行时刻对隐式类型的依赖，很多的类型都显式地告诉了Runtime，Runtime不再需要去做水面以下的部分。另外它会有利于在加载时刻（Loading Time）的类型验证，因为类型信息已经在字节码里边了，它很容易去做类型的推导和验证，看压栈或者是传参是不是符合它的目标类型，这样的话可以尽可能减少在运行刻的类型的验证，因为在运行刻做类型验证是非常耗CPU的，这样可以让它的执行效率大量的提升。</p><p></p><p>下面介绍在GC特性中引入的一些新的一些元素，首先是结构。结构的成员变量还是用索引号来访问的，比如说你new一个对象之后，get或者set一个成员变量，成员变量通过index来访问。数组就是同样类型的多个元素的聚合，每个数组也是透过一个索引来进行访问的。另外函数就引入了一个类型化函数指针，叫ref.func和ref.call_ref，可以让你直接传函数指针，而不是传一个索引。它的好处就是能够极大地加快函数指针调用的速度，对比目前因为要做大量的Type Check，所以通过indirect效能不是很好。运行刻的类型引用，它可以从一个Type去生成一个Type的引用，Type引用可以通过变量或者传参来进行传递。另外还有未装箱的标量，还有类型的测试和等价，子类型化，还有运行刻的类型强转等等这些元素。（注：最新的GC提案在此基础上有进一步改动，请读者以w3c的官方提案文本为准）</p><p></p><p>右边是一个关于结构的例子，首先下面它定义了time、point结构，time包含一个32位整型和64位的精度的浮点成员。point包含3个64位的浮点组成的xyz成员。下面是一个函数，它的传参是point结构的对象，因为p是它的传入的参数，get $p就是把p它的指针放到栈里面，按它的point类型取x字段，x最后是一个索引号，取到之后，把它放到栈里边。把x值从栈里面取出来，再赋到y field里边，这就是这个函数做的事情。再下面使用struct.new来对结构进行分配，struct.new后面跟的是一个类型，后面会跟着每一个成员初始化的值，它会返回一个结构的引用对象。</p><p></p><p>WebAssembly并没有真正定义GC本身实现，而是定义了完善的GC系统所需要的工具，它更想定义了一个工具箱，每个Runtime可以通过使用这个工具箱去实现自己的GC。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/8c/8c727924534a5c8d6d5ec11480652cd1.png\" /></p><p></p><p></p><h3>模块的组件模型</h3><p></p><p></p><p>模块链接与组件模型，目前这块的规范也在制定之中。首先需要标准化模块之间的链接，module-linking的spec定义了一些典型的链接的模式。屏幕右边是两种比较典型的链接模式，上面这种叫Link-time Virtualization，描述了所有WASM模块之间的静态依赖，比如说parent，它也会去访问WASI文件系统，child也会访问文件系统，virtualize模块也会访问。我们并不想用child能够真的去访问物理的内存，可以引入Virtualization模块，它会向child提供WASI Interface，所以child说需要去访问WASI Interface，实际上是让Virtualization去给它导出一个让它使用，Virtualization模块中间会做一些转换或者一些检查，它会去实际访问真正的File System模块，这样对于child instance它所看到是个虚拟化的接口，这叫Link-time Virtualization。</p><p></p><p>还有一种模式叫Shared-Everything C-family Dynamic Linking，可以在动态的过程中，由不同的模块组成不同的实例。比如说zipper，它也引用了libc，它可以构建一个单独的一个实例，img它可能也引入了一系列，包括libc、libzip，但是它们可以组织成一个instance，它有它自己的内存空间和一个实例所需要的元素，既具有很好的隔离性，又具有很好的灵活性。</p><p></p><p>组件模型一个组件会包含一系列的模块，它现在定义了一个组件有若干个组成的部分，一个是它的模块数的定义，主要就是静态的模块，它的实例定义。它会定义好有哪些实例，实例需要导入的是什么东西。然后是类型的定义，类型定义包括静态的类型定义，还有实例化时刻的类型的定义，实例化时刻的类型定义有点像如果用Linux系统的链接器，当你编译的时候，你只需要知道链接对象的引入符号就可以了，它引入什么你并不关心。但是当你实际加载，开始运行链接的时候，每一个被链接的链接库文件，它所依赖的这些符号也需要被解决，它要像一个链式一样去找它所有被链接的符号，最终程序才能跑起来，这个时候就引入了很多的不确定性。在这把后面那部分链接的过程，把整个链接链条都会定义到这个组件里面去。这样在实例化的时候，在定义的时候，就把部分在将来做的事前置。函数的定义目前主要还是基于一个线性内存的新的ABI，但是它已经有一部分可配置的能力。目前还有一个叫InterfaceType，这样给程序提供了更多的自定义这种接口的能力，</p><p></p><p>以上就是GC现在的一些大概情况。从上述的信息来看，基于Wasm的强的类型系统它有很大的灵活性，它就像一个积木式的系统，可以从不同的语言搭建出很多的模块，这些模块又可以搭建很多的组件，这样，在未来它会有非常好的潜力，去构建一个跨越语言的应用生态系统。如果一切像预期一样发展，我们可以预见在未来，也许WebAssembly是一个远远比现在要更加广泛的一种语言生态。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/13/13395c53ae0b67f3854069e6e633a7d2.png\" /></p><p></p><p></p><h3>WASI与字节码联盟</h3><p></p><p></p><p><a href=\"https://bytecodealliance.org/\">字节码联盟</a>\"是一个以WebAssembly技术为中心的开源实现的非盈利组织，目前有非常多的程序员加入进来，而且加入的速度也是非常快的。目前在组织里面主要在做包含开源的Runtime项目，还有WebAssembly System Interface&nbsp;(WASI)，以及一些工具和组件生态的方案。最近字节码联盟TSC的章程发布了，本人作为技术委员会创始的成员参与了全程的章程的定义，这个章程兼顾了多方面的考虑。大概花了接近两个季度的时间才完成，也参考了很多目前比较成熟的社区的一些章程，大家有兴趣可以去看看。</p><p></p><p>字节码联盟目前Runtime开源项目主要有两个，一个是WASMTIME，另外一个是WebAssembly Micro Runtime，WebAssembly Micro Runtime最早是由Intel开发的，在2019年贡献给字节码联盟了。目前除了Intel持续在上面开发之外，有很多企业如亚马逊、索尼、蚂蚁、小米、阿里巴巴在上面也贡献了很多特性和功能。</p><p></p><p>WASI是什么？WASI是标准化WASM的模块和Native宿主环境之间的一个调用接口，这个接口和上层的编程语言是无关的。其中的wasi-libc提供了libc的支持，把原来的像底层和Kernel对接syscall调用接口换成了WASI的Interface，这样大家可以在WebAssembly里面继续调用类似于FileOpen这样的系统调用，可以在所有的Runtime上运行，达到一个很好的跨平台特性。</p><p></p><p>另外它定义了一个Capability-based Security，很简单的说，启动一个实例的时候，可以给它指定一个目录，在实例里面Wasm应用无论怎么访问目录，它看到的根目录就是你指定的物理的目录，所以所有的一切操作都是在本机一个子目录里面运作，这样它就没有能力去访问整个磁盘上的其他的一些它不应该访问的文件系统。WASI目前的发展是非常好的，有很多标准都在进行之中，大家有兴趣可以在W3C的网站上了解一下。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/00/009f635cbee862d6fd0b6a9668273c9c.png\" /></p><p></p><p>最后给大家快速介绍一下WebAssembly Micro Runtime&nbsp;(WAMR)开源项目，因为这个项目是我们团队从头到现在一直在参与的，也希望大家能更多了解。WAMR是基于C语言实现的，它有两个解释器的实现，一个叫Fast，一个Classic，Fast比Classic要快一倍左右。关于它的一些实现，我们之前也输出过一些文章，大家有兴趣可以去了解一下。</p><p></p><p>WAMR支持JIT和AoT，JIT和AoT目前是基于LLVM框架来实现的，整个Runtime的特点就是说它的VMCore很小，在100K以内，但同时它的性能又非常好。一方面借助LLVM这个非常好的编译框架，它的性能和GCC相比，根据不同的Workload，从60%、70%、80%、90%，甚至还有快过GCC原生编译的。另外它的AoT也是个很特色的设计，因为它有个完全自定义的AoT的加载机制，不依赖于系统的Loader，它可以在很多的平台上都可以用，像Linux或者SGX环境，甚至像一些MCU上的嵌入式操作系统，也可以使用AoT的Loader。另外它支持向量化计算，对于Intel SGX和TDX这种安全的执行环境有非常良好的支持。它还支持多线程、pthread、Reference type和Multi-modules等丰富的特性，欢迎大家能花点时间了解体验下。</p>",
    "publish_time": "2022-10-21 15:47:14",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "如何构建直面消费者的汽车供应链？Salesforce 发布了“汽车云”",
    "url": "https://www.infoq.cn/article/C44BsTWxez34dGFmvDWs",
    "summary": "<p>在<a href=\"https://www.infoq.cn/topic/1160\">数字时代</a>\"，汽车行业正在经历前所未有的转型。汽车制造商也在重新考虑如何处理面对面的客户关系、本地库存的经销商以及中间商的关系，新的销售和服务模式脱颖而出。</p><p></p><p>最近，Salesforce&nbsp;发布了Automotive&nbsp;Cloud（汽车云），旨在通过一个符合<a href=\"https://xie.infoq.cn/article/ebb792a2d643bd42da354f577\">数据交换</a>\"行业标准的汽车行业专用平台，帮助汽车制造商、经销商、汽车金融公司，在每次客户互动中提供更优质的服务和体验，通过更好的潜在客户转化和协作来增加收入，并利用行业特定的自动化、智能和实时分析来提高生产力和节省成本&nbsp;。</p><p>&nbsp;</p><p>之前，很少有消费者愿意花数万美元购买他们从未见过或接触过的汽车。但是，随着互联网产品时代的到来，用户消费习惯的改变，使得在线汽车销售和非接触式变得可行。</p><p>&nbsp;</p><p>Gartner&nbsp;副总裁兼汽车分析师&nbsp;Michael&nbsp;Ramsey&nbsp;表示，“汽车云”为<a href=\"https://xie.infoq.cn/article/01b2006c5af6018c8e6f4f2c6\">汽车制造商</a>\"提供了一种重新控制其品牌的方式。</p><p>&nbsp;</p><p>“从基本层面来说，Salesforce&nbsp;建立了汽车制造商和用户的连接点，因为汽车制造商需要切实提供客户体验，而不是仅仅依赖经销商的反馈。”他说。</p><p>&nbsp;</p><p>Salesforce&nbsp;公司的制造与汽车高级副总裁总经理&nbsp;Achyut&nbsp;Jajoo&nbsp;表示：“如今，越来越多的车企正在直接面向消费者，加上电动汽车时代的到来，汽车行业面临着新的<a href=\"https://www.infoq.cn/article/mfcsP6wws312tLTcrPCl\">数字化需求</a>\"，机遇和挑战并存，利用汽车云等技术，加速进入数字化阶段的公司可以获得更大的竞争优势，同时让他们的业务面向未来。”&nbsp;</p><p></p><p>据他介绍，目前福特已经在采取一系列措施，将一种新的工作方式传递给经销商。“汽车制造商希望经销商变得更有经验。实际上，未来的汽车经销商看起来更像是一家&nbsp;Apple&nbsp;Store。”他说。</p><p>&nbsp;</p><p>Jajoo&nbsp;表示，“汽车云”旨在帮助汽车制造商更贴近客户，不仅可以分析个人和车辆的数据，还可以在一个屏幕上分析他们整个家庭以及与经销商的所有互动。</p><p>&nbsp;</p><p>“我们有这些数据就可以向经销商推荐下一步要采取的最佳行动，”他说道，“我们创建了数据工具，可以通过更加精准、直接的方式去采取行动，而不是简单自定义决策。”&nbsp;这些工具包括了规则引擎，可以及时查看数据并发出警报或者建议。</p><p>&nbsp;</p><p>Jajoo&nbsp;说，汽车制造商通过各地区的经销商收集数据，可以更好地了解市场。举例来说，借助&nbsp;Automotive&nbsp;Cloud，营销团队可以设置参数以自动对合格的潜在客户进行排序，从而直接与客户的当地经销商分享接触度最高的潜在客户；经销商经理则可以查看一段时间内的采购协议，以跟踪库存绩效并找出哪些经销商符合他们的预测和销售协议，从而更好地管理库存和车辆分配；服务团队可以设置预警，在客户的租约即将到期时进行通知，或者当他们的里程表达到某个数值时，自动提醒客户进行保养。并且，在整个过程中，IT&nbsp;团队只需要做简单的单击操作，就可以创建自定义流程，自动提醒拥有特定车型的每位客户其车辆已被召回。</p><p>&nbsp;</p><p>“此外，你可以进行优质的性能分析：销售哪种车型，由哪里生产什么型号，何种年份的汽车型号，在哪个地区、哪个经销商表现得更好——所有这些类型的信息，汽车制造商都可以通过数据得到答案。”Jajoo&nbsp;表示。</p><p>&nbsp;</p><p>另一方面，让数据可以游刃于各企业内部与周边的关键点，是要遵守共同的标准。</p><p>&nbsp;</p><p>大约&nbsp;20&nbsp;年前，美国汽车零售业在意识到了这点，并共同创建了非营利性公司汽车零售技术标准。STAR&nbsp;的成员包括全国汽车经销商协会&nbsp;(NADA)；福特、通用、宝马、丰田等汽车制造商；和&nbsp;IT&nbsp;供应商，例如&nbsp;Microsoft、Nuspire&nbsp;和&nbsp;Tech&nbsp;Mahindra。</p><p>&nbsp;</p><p>STAR&nbsp;很久以前就弃用了其原始的平面文件交换格式，现在已经发布了超过&nbsp;200&nbsp;种用于业务对象文档&nbsp;(BOD)&nbsp;的&nbsp;XML&nbsp;消息格式，涵盖从交换销售线索到安排信贷、销售车辆、维修车辆以及订购维修零件到转售方方面面的内容。</p><p>&nbsp;</p><p>目前，Salesforce&nbsp;推出的“汽车云”遵守&nbsp;STAR&nbsp;的标准，确保其平台中所有必要的字段都可用，Jajoo&nbsp;说：“Salesforce&nbsp;Automotive&nbsp;Cloud&nbsp;作为一个平台首先是&nbsp;API，因此我们可以轻松地在各方之间交换信息。”</p><p>&nbsp;</p><p>Salesforce&nbsp;还创建了模板来促进数据交换。“这是一场生态系统游戏，我们可以将这些数据扩展到汽车制造厂商的合作伙伴身上，无论他们是经销商、代理商还是其他第三方。”他说道。</p><p>&nbsp;</p><p>这意味着采用“汽车云”的公司能够继续与其他使用&nbsp;STAR&nbsp;标准兼容平台的公司进行数据交换。</p><p>&nbsp;</p><p>Gartner&nbsp;的&nbsp;Ramsey&nbsp;表示：“对于传统汽车公司而言，批量采用该平台将是一个巨大的飞跃，因为大多数公司已经拥有了一个非常强大的&nbsp;Customer&nbsp;360&nbsp;型数据库（Salesforce&nbsp;Customer&nbsp;360&nbsp;是一个集成的CRM&nbsp;平台）。”</p><p>&nbsp;</p><p>不过，需要强调的是，对于已经在&nbsp;Salesforce&nbsp;平台上构建过汽车&nbsp;<a href=\"https://xie.infoq.cn/article/b48d496fabace814875c6851f\">CRM&nbsp;系统</a>\"的企业来说，未来将会有更多的工作要做，因为他们首先必须摆脱多年的定制化 CRM 系统，才能真正采用“汽车云”。</p><p>&nbsp;</p><p>参考链接：</p><p><a href=\"https://www.cio.com/article/409909/salesforce-seeks-to-unify-automobile-supply-chain-with-automotive-cloud.html\">https://www.cio.com/article/409909/salesforce-seeks-to-unify-automobile-supply-chain-with-automotive-cloud.html</a>\"</p><p><a href=\"https://venturebeat.com/data-infrastructure/salesforce-automotive-cloud-creates-single-source-of-truth-for-auto-industry/\">https://venturebeat.com/data-infrastructure/salesforce-automotive-cloud-creates-single-source-of-truth-for-auto-industry/</a>\"</p><p><a href=\"https://www.salesforce.com/news/stories/salesforce-announces-automotive-cloud-driver360/\">https://www.salesforce.com/news/stories/salesforce-announces-automotive-cloud-driver360/</a>\"</p>",
    "publish_time": "2022-10-21 15:54:02",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Docker 又涨价了",
    "url": "https://www.infoq.cn/article/g286WV9eCQ2LgfUwryQV",
    "summary": "<p>近日，<a href=\"https://devclass.com/2022/10/20/docker-quietly-raises-prices-limits-team-accounts/?td=rt-3a\">Docker 宣布</a>\"，从 2022 年 10 月 27 日起，Docker Team 价格将提高约 28%，Docker Business 价格提高约 14%，并且还将 Team 帐户的规模限制为 100 个用户，超过该将规模的组织推向了成本提升近三倍的商业订阅，但可享受 30% 的折扣。</p><p>&nbsp;</p><p>对此，官方给出了一个模糊的解释：价格上涨将使我们能够继续投资 Docker。</p><p>&nbsp;</p><p>“是的，这件事正在发生在我们身上。最重要的是，由于业务仅通过年度发票提供，我们还必须像我们一直在做的那样通过信用卡预付 1 年而不是每月支付。但为了让我们感觉好一些，他们为受影响的公司提供了 30% 的折扣（在第一年）。这太疯狂了，我不指望我们明年会续订。骗我一次就够了，真丢人，骗我两次......”有用户<a href=\"https://news.ycombinator.com/item?id=33268282\">在网上吐槽</a>\"。</p><p>&nbsp;</p><p>2021年，Docker 将产品订阅划分为个人、专业、团队和商业不同版本，其中个人版本免费，其主要面向社区，其他版本有不同程度的收费。同时，大型企业（定义为超过 250 名员工或年收入超过 1000 万美元）如果需要 Docker Desktop，必须使用付费订阅。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/2c/2c2c7ce98a9dd3ef5501c9bc11b72a56.png\" /></p><p></p><p>&nbsp;对于去年的调整，Docker 首席执行官 Scott Johnston 表示，Docker 已经成为一个企业标准，但软件供应链存在安全挑战，公司希望解决这个问题。</p><p>&nbsp;</p><p>“我们继续看到开发者市场的增长。我们最新的统计预估数字是，到 2030 年，全球将有 4500 万开发者，而现在只有 1800 多万......这要求我们有一个可持续扩展的业务。”Johnston 表示，大多数 Docker 用户都是免费使用的，他希望这些调整将增加付费订阅数量。“我们估计，现在有两倍的用户可能会觉得有必要注册订阅，但这仍然不到 Docker 总体使用率的10%”。</p><p>&nbsp;</p><p>Docker Desktop 是一款 Docker 容器集成开发环境（IDE），包含了 Docker Engine、Docker CLI 客户端、Docker Compose、Docker Content Trust、Kubernetes 和 Credential Helper 等功能支持。</p><p>&nbsp;</p><p>5 月 10 日，Docker 宣布 Docker Desktop 可<a href=\"https://www.infoq.cn/article/uSiOw4DmUuwiEXNJjiM3\">在 Linux 上使用</a>\"。使用 Linux 桌面的开发者可以拥有在 macOS、Windows 上完全相同的 Docker Desktop 体验，这也让无数开发者为之振奋。</p>",
    "publish_time": "2022-10-21 16:22:04",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "蚂蚁规模化平台工程实践两年多，我们学到了什么",
    "url": "https://www.infoq.cn/article/fL9fHtbagvxXdPxUopgk",
    "summary": "<p></p><p>本文基于 <a href=\"https://xie.infoq.cn/article/f7f6470dc9a54bcde9a640161\">KusionStack </a>\"技术栈在蚂蚁平台工程及自动化中的实践，尝试从平台工程、专用语言、分治、建模、自动化和协同文化等几个角度，阐述规模化平台工程实践中的收益和挑战。希望通过把我们平台工程的理念和实践分享给更多企业和团队的方式，大家一起让一些有意思的变化发生。</p><p></p><h2>平台工程要解决什么</h2><p></p><p></p><p>DevOps 理念在 10 多年前被提出，从 KVM 到容器再到云原生时代，大量企业投入 DevOps 运动以期望解决内部规模化运维效率和平台建设效率的困境。其中大部分公司陷入过某种基于对 DevOps 朴素认知的 Anti-Pattern，同时也有部分公司探索出自己的路径。</p><p></p><p>我经历过如下图简示的 Anti-Patterns，Dev 与 Ops 团队各行其是，或者简单的强制 Dev 团队独立完成 Ops 工作。在<a href=\"https://web.devopstopologies.com/#anti-types\">这里</a>\"可以找到更多更典型分类。</p><p><img src=\"https://static001.geekbang.org/wechat/images/03/03f45dc4a8b6badd7c0eb0c9172da872.png\" /></p><p></p><p>企业内规模化 DevOps 难以推行的原因多种多样，特别是在企业内自持基础设施、同时采用云上技术平台的公司阻力最大。其中以这几种情况尤为常见：</p><p></p><p>研发团队和运维团队由于部门墙、领导者缺少洞察等原因各自为政，难以达成一致意见；研发团队低估了基础设施技术、运维、稳定性工作的专业性、复杂性和快速变化，以朴素的 DevOps 理解强制应用研发者成为专家；领导者建立了专职的 DevOps 团队，但沦为中间的执行者，没能让 Dev 和 Ops 团队各自向前一步、紧密协同；平台研发团队对规模化带来的业务复杂性以及技术演进带来的技术复杂性应对不足，无法为应用研发者提供有效的技术支撑；</p><p></p><p>不同于面向云上托管基础设施服务和 DevOps-as-a-Service 产品工作的小型团队，中大型企业往往需要根据自身团队架构和文化建立适当的 DevOps 体系。</p><p></p><p>从成功案例看，无论是 Meta 公司由 Dev 完全承担 Ops 职能，还是 Google 公司引入 SRE 团队作为中间层，<a href=\"https://www.infoq.cn/article/7porVp7qVF03BVc2tDd6\">平台工程（Platform Engineering）</a>\"都扮演了非常重要的角色。平台工程旨在帮助企业构建面向应用研发者的自服务运维体系，尝试通过工程化的技术手段和工作流程解决以下关键问题：</p><p></p><p>设计合理的抽象层次，帮助应用研发者降低对 Infra、platform 等技术以及运维、稳定性工作的认知负担；为应用研发者提供统一的工作界面和空间，避免用户陷入割裂的平台产品界面和复杂的工作流中；帮助研发者通过有效的工作流程和推荐路径，能够基于内部工程平台快速开展工作；帮助研发者通过配套的 CI、CD、CDRA 等产品自服务管理应用生命周期；帮助平台产品研发团队简单、高效、一致地开放其平台基础能力；通过培训、布道、运营等手段，营造协同工作和分享的文化。</p><p></p><p>事实上，不是所有人都应该或者能够成为这个领域的专家，这非常困难！平台技术团队的专家通常也仅擅长自己的专业领域而已。</p><p></p><p>特别是在云原生理念和技术广泛应用的今天，面向大量高度开放、可配置的平台技术，带来了成百上千的应用配置，对 PaaS 领域的业务复杂性、高稳定性和统一治理提出更高的要求。平台工程的目的正是为了让应用研发者尽可能简单、无痛地参与到这种规模化的 DevOps 工作中。</p><p></p><p>在蚂蚁的实践中，我们更趋向于以下这种合作状态，团队架构和工作模式更靠近 Google 的最佳实践：平台研发者及 SRE 成为 “Enabler” ，支持应用研发者自服务的完成研发及交付运维，同时应用研发者使其应用可交付运维的工作结果也成为运维人员可以接手应用运维工作的基础。最终，SRE、应用研发及运维人员把工作过程中的问题和痛点反馈给平台研发者形成正向循环。</p><p><img src=\"https://static001.geekbang.org/wechat/images/83/8399bf9cf5596f7aa1773ffe3a8d2bdd.png\" /></p><p></p><p></p><h2>专用语言：工程化方式的一极</h2><p></p><p></p><p>有什么比一种专用语言更适合开放、自服务、面向领域业务的问题定义，同时需要满足自动化、低安全风险、低噪音、易治理的企业内部要求吗？正如记录音乐有五线谱、存储时间序列数据有时序数据库一样，在平台工程的特定问题域内有一批配置和策略语言用于编写和管理规模化复杂配置及策略。</p><p></p><p>不同于混合编写范式、混合工程能力的高级通用语言，这类专用语言的核心逻辑是以收敛的有限的语法、语义集合来解决领域问题近乎无限的变化和复杂，将规模化复杂配置、策略编写思路和方式沉淀到语言特性中。</p><p></p><p>在蚂蚁的平台工程实践中，我们强化了客户端的工作方式，将围绕应用运维生命周期的模型、编排、约束和策略稳定、可扩展性，通过专用语言 <a href=\"https://github.com/KusionStack/KCLVM\">KCL </a>\"编写维护在共享仓库 <a href=\"https://github.com/KusionStack/konfig\">Konfig</a>\" 中。</p><p></p><p>KCL 是一种面向有编程能力的应用研发者的静态强类型语言，提供现代高级语言的编写体验和围绕领域目的有限功能。在平台工程实践中 KCL 不是一种仅用于编写 K-V 对的语言，而是一种面向平台工程领域的专用语言。应用研发者、SRE、平台研发者面向 Konfig 协同研发，通过 KCL 原生功能编写应用配置，以及在 PaaS 领域更为高频和复杂的模型抽象、功能函数和约束规则，编写稳定、可扩展的业务模型、业务逻辑、防错约束和环境规则。Konfig 仓库则成为统一的编程界面，工作空间和业务层载体，而基于 KCL 的安全、低噪音、低副作用、一致的编写范式更有利于长期管理和治理。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/2b/2b3ca7e20117fecd80b8e722938ea0b4.png\" /></p><p></p><h2>分治：解构规模化问题</h2><p></p><p></p><p>分治思路是解决规模化问题的钥匙，从 MapReduce 到 Kubernetes，无不体现其功效。</p><p></p><p>在规模化交付运维领域，经典运维平台试图在统一的黑盒平台产品中，以内置的统一模型、编排、provision 技术来应对全量业务场景。这样可以快速启动，并在小范围内奏效，但随着不同业务主体采用率的提升会引入差异化需求，并随着持续变化的平台技术逐渐进入疲态。</p><p><img src=\"https://static001.geekbang.org/wechat/images/5d/5d3a4249f343aa3c61fb8b812c91dbec.png\" /></p><p></p><p>在蚂蚁的实践中，Konfig monorepo 是内部工程平台向研发者开放的编程界面和工作空间，帮助应用研发者以统一的编程界面编写围绕应用运维生命周期的配置和策略，从而编排和使用存量和新增的平台基础设施，按需创建管理云原生环境以及基于 RBAC 的权限，并通过 GitOps 方式管理交付过程。Konfig monorepo 为不同场景、项目、应用提供了独立的白盒的编程空间，其内生的扩展性来源于：</p><p></p><p>灵活、可扩展、独立的客户端的工程结构设计；独立配置块自动合并技术支持任意分块、可扩展的配置块组织；静态类型系统技术提供现代编程语言可复用、可扩展的类型化建模和约束功能；项目粒度的GitOps CI 工作流程定义支持；基于Kusion&nbsp;引擎的 provision 技术选择。</p><p></p><p>Konfig monorepo 提供了分治的、可组合的工程结构设计、代码组织、建模方式、工作流程定义和 provision 技术选择支持，同时又以一致的研发模式和工作流承载了可扩展的业务需求。这样客户端的工作方式在保证灵活性、可扩展性、可移植性的同时也降低了对服务端扩展机制，如 Kubernetes API Machinery，持续增长的压力。</p><p></p><p>下图示意了一种 Konfig monorepo 中，GitOps 方式的典型的自动化工作流程，从面向应用的代码变更开始，通过可配置的 CI、CD 过程触达运行时，这样的机制相比中心化的黑盒产品方式更加开放、可定制、可扩展，也免去了针对不同业务场景、不同项目、应用设计笨拙的配置文件管理 portal 的必要。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/1f/1ff1a9718cd60d8e78f3071903f0c984.png\" /></p><p></p><h2>建模：边际收益和长尾问题</h2><p></p><p></p><p>有了分治的白盒化的工程结构设计、代码组织方式、建模方式、工作流程定义和 provision 技术选择，以怎么的策略面向平台 API 工作是另一个需要考虑的问题。</p><p></p><p>在企业内，典型的争议在于直面平台细节还是设计一种抽象，甚至会上升到显式（explicit）和隐式（implict）理念的争议。</p><p></p><p>抽象的、隐式的方式是运维平台工程师们面向非专家型终端用户的普遍选择，他们希望能设计出易于理解和使用的应用模型或 Spec 抽象，能与具体的平台技术细节隔离，降低用户认知负担，并通过降低细节感知防错。</p><p></p><p>但大部分运维平台的研发者倾向于设计一种强大的、统一的应用模型或 Spec 抽象，这在实践中往往会遇到以下阻碍：</p><p></p><p>随着企业内不同业务主体采用率的提升，统一建模难以落地。在蚂蚁内部，最典型的案例是 Infra 基础技术类组件和 SaaS 应用间存在巨大的差异：SaaS 应用便于统一，而 Infra 应用往往需要单独设计。面向企业内大量的平台技术，统一模型自身难以稳定，特别是应对持续变化的业务需求和平台技术驱动的需求增长。在蚂蚁的实践中，交付运维受多种因素影响有较强的不稳定性，同时围绕应用的 deliverable、runtime、security、instrumentation 的业务需求也在增长。以 instrumentation 为例，近两年对应用运行时可观察性、SLO 定义的需求快速增长直接驱动了终端用户使用的变化。抽象模型的共性问题是需要面向用户设计出合理的模型，面向平台 API 细节保持同步。</p><p></p><p>面向终端用户即应用研发者，我们在实践中采用了抽象模型的方式，通过如下思路解决几个关键问题：</p><p></p><p>面向典型应用场景（如蚂蚁的 Sofa 应用）建模，这些模型由平台研发者、平台 SRE 主导开发，与应用研发者共同维护，以此达到用户体验、成本和标准兼容的平衡。在蚂蚁的实践中，抽象模型的信息熵收敛比约为 1：5，通过广泛的高频使用保证建模投入的边际收益。对于非典型用户场景或应用，由平台研发者、平台 SRE 支持应用研发者完成针对应用的模型设计。KCL&nbsp;<a href=\"https://kusionstack.io/docs/reference/lang/lang/tour/#schema\">schema</a>\"&nbsp;和&nbsp;<a href=\"https://kusionstack.io/docs/reference/lang/lang/tour#protocol--mixin\">mixin</a>\"等机制帮助用户建模、抽象、继承、组合、复用，减少重复代码，事实上这样的建模设计工作也是应用 PaaS 领域的重点之一，但这样的场景需要更合理的分工。最终，大量 “非标” 平台技术在蚂蚁内部首次以一致的方式被纳管，有效解决了长尾问题。在典型协同模式下，平台研发者、平台 SRE 编写平台能力基础组件成为 “Enabler”，帮助应用研发者使用平台能力基础组件快速“搭积木”，完成其应用模型的研发工作。&nbsp;面向平台技术，我们提供了平台 API Spec 到 KCL 类型代码的生成技术，并通过组合编译技术原生支持对不同 Kubernetes API 版本的编译时选择，在内部实践中解决了应用抽象模型面向不同版本 Kubernetes 集群工作的灵活需求。同时，KCL 支持 in-schema 约束和独立环境规则的编写。此外，KCL 还提供了 deprecated 装饰器支持对已下线模型或模型属性的标注。通过在客户端健壮、完备的模型和约束机制，在编译时暴露如配置错误、类型漂移等常见问题。相对于运行时左移的发现问题，避免推进到集群时发生运行时错误或故障，这也是企业内，特别是高风险等级企业，对生产环境稳定性的必须要求。</p><p></p><p>对于基础平台技术的专家型用户，他们通常非常熟悉特定的技术领域，更希望以直面平台细节的显式的方式工作，语言提供必要的动态性和模块化支持，通过类型和约束机制保证稳定性。</p><p></p><p>但这种显式的方式无法解决专家用户不熟悉跨领域平台技术使用细节的问题，也不能解决面向平台技术的扩展性和复杂性叠加的问题。在蚂蚁内部小范围基于 YAML 的显式的工程实践中，面向大量高度开放、可配置的平台技术，复杂性随着平台技术使用率持续叠加，最终陷入难以阅读、编写、约束、测试及维护的僵化状态。</p><p></p><h2>自动化：新的挑战</h2><p></p><p></p><p>运维自动化是基础设施运维领域的经典技术范畴，随着云原生理念及技术的推波助澜，可以被自动化集成已成为企业运维实践的基本要求，开源开放、高度可配置的 CI、CD 技术逐步被企业采纳，黑盒的、无法被集成的 “产品” 方式逐步被灵活的可编排方式弱化并替代。</p><p></p><p>这种实践的主要优势在于其强大的自定义编排和链接能力，高度可扩展性和良好的可移植性。特别是在 Kubernetes 生态，GitOps 方式有更高的采用率，与可配置的 CI、CD 技术有天然的亲和性。这样的变化也在推进以工单和运维产品为中心的工作流逐步转变为以工程效率平台为中心的自服务工作流，而生产环境的运维能力则成为了工作流中面向生产自动运维的一个重要环节。在开源社区，面向不同研发效率平台的抽象层技术创新也在活跃进行中，平台侧研发者希望通过最短的认知和实践路径打通应用到云环境的 CI、CD 过程。</p><p></p><p>在蚂蚁的工程实践中，工程效率平台深度参与了 Konfig monorepo 的开放自动化实践，我们的实践方向也与工程效率平台技术演进方向高度一致。</p><p></p><p>在从几人到几十人再到几百人的协同工作中，面向运维场景的工作流设计、高频的代码提交和 pipelines 执行、实时自动化测试和部署过程，这些对服务于单库的工程效率平台造成了很多的挑战。特别是 monorepo 中多样化的业务，需要独立且强大的工作流自定义和操作支持，也需要高实时性、强 SLO 保障的并行的工作流执行能力，这些需求与单库模式的需求有巨大的差异，也给我们制造了很多麻烦。</p><p></p><p>目前，我们的大部分配置语言是解释型语言，而 KCL 被设计为一种编译型语言，由 Rust、C、LLVM 优化器实现，以达到对规模化 KCL 文件提供高性能编译和运行时执行的目标，同时支持编译到本地码和 wasm 以满足不同运行时的执行要求。</p><p></p><p>另外，Git 的存储及架构设计不同于 Citc/Piper 架构，不适用于规模化代码的 monorepo，所幸今天我们的代码量还没有遇到很大的问题。我们正在一起努力解决这些问题，希望随着实践的深入逐步解决它们。</p><p></p><h2>协同和文化：更重要的事</h2><p></p><p></p><p>以上的技术、工具、机制都非常重要，但我必须要说，对于工程化、Devops 而言，更重要的是团体与团队的协同、合作和分享的文化，因为这是一种由人组成的工作，人和文化是其中的关键。</p><p></p><p>在企业内，如果部门墙、团队壁垒丛生，流行封闭糟糕的工程文化，我们通常会看到大量私有的代码库和私有文档、小群体的判断和工作方式，本该紧密合作的团队以各自目标为导向，各行其是。在这样的文化下，我认为一切规模化工作都会非常困难。</p><p></p><p>所以，如果你所在的公司或团队想采纳规模化 Devops，我认为最重要的是做好广泛的沟通并开始文化的建设，因为这绝对不只是几个人的事，并且这很有难度且不可控。</p><p></p><p>蚂蚁实践初期，也总有各种各样的困难，大家对自服务机制和协同文化的担心尤为突出。例如， “我居然要写代码？” “我的代码居然跟其他团队在一个仓库里？” “我负责的工作可不简单，这种方式行不通” ，都是很典型的担忧。</p><p></p><p>所幸我们最终建立了一个面向共同目标的虚拟组织，合作方和领导者给予了充分的支持，我们在理念和工作方式上达成一致并协同工作。</p><p></p><p>在实践过程中，大多数工程师并不是障碍，当然他们会吐槽技术、流程和机制还不够完善，希望获得更好的体验，这无可厚非。</p><p></p><p>真正的障碍首先来自运维平台研发团队自身。我看到一些公司的 Devops 理想最终回归到运维平台团队替代应用研发者做掉所有工作，甚至不让用户接触到代码和工具链这些生产工具，急于隐藏已有的 GUI 产品界面，我认为这跑偏了，也低估了用户自身的能力和创造力。</p><p></p><p>另外，障碍也来自部分平台技术团队的技术负责人，他们很难放下持续多年的已有工作，难以接受转向到新的用户服务模式。可行的办法是让他们明白这项工作的意义和远景，逐步、分阶段地影响他们。</p><p></p><h2>小结</h2><p></p><p></p><p>经过一年多的实践，有 400+ 研发者直接研发参与了 Konfig monorepo 的代码贡献，管理了超过 1500 个 projects，其中平台研发者及平台 SRE 与应用研发者比例不到 1：9，这些应用研发者有些是应用 owner 本人，有些是应用研发团队的代表，这由应用团队自己决定。</p><p></p><p>通过持续的自动化能力搭建，基于 Konfig monorepo 每天发生 200-300 次 commits，其中大部分是自动化的代码修改，以及大约 1k pipeline 任务执行和近 10k KCL 编译执行。在今天，如果将 Konfig 中全量代码编译一次并输出，会产生 300W+ 行 YAML 文本，事实上一次发布运维过程中需要多次不同参数组合的编译过程。通过轻量化，便于移植的代码库和工具链，我们完成了一次意义重大的外部专有云交付，免去了改造、移植输出一系列老旧运维平台的痛苦。在蚂蚁内部，我们服务了几种不同的运维场景，目前正在扩大应用规模并探索更多的可能性。</p><p></p><p>最后我想说说我们的下一步计划。我们的技术和工具在易用性和体验上还有很大的提升空间，需要更多的用户反馈和持续改进，用户体验工作没有快速路径。在测试方面，我们提供了简单的集成测试手段，起到了冒烟测试的作用，但这还不够，我们正在尝试基于约束、规则而非测试的方式保证正确性。在工作界面方面，我们希望构建基于 IDE 的线下工作空间，持续规约、优化内部线上产品体验和工作流程，同时我们希望持续提升覆盖范围和技术能力。另外，我们也希望将实践方式更广泛地应用在 CI 构建、自动化运维等场景，缩短终端用户的信息感知和端到端工作流程。</p><p></p><p>目前，KusionStack 还处于刚刚开源的非常早期阶段，未来还有大量的工作要做。最重要的是，我们希望把我们平台工程的理念和实践分享给更多企业和团队，一起推动并见证一些有意思的变化发生。</p><p></p><p>作者简介：</p><p></p><p>朵晓东，蚂蚁集团可信原生技术部资深技术专家，长期工作在基础技术、云原生技术领域，专注云原生网络、运维，编程语言等技术工作，KusionStack 项目发起人。云原生网络代理 MOSN 发起人，PMC。Apache Kylin 创始工程师，Emeritus PMC。</p><p></p><p>引用链接：</p><p></p><p><a href=\"https://kusionstack.io/docs/user_docs/intro/kusion-intro\">https://kusionstack.io/docs/user_docs/intro/kusion-intro</a>\"</p><p></p><p><a href=\"https://platformengineering.org/blog/what-is-platform-engineering\">https://platformengineering.org/blog/what-is-platform-engineering</a>\"</p><p></p><p><a href=\"https://internaldeveloperplatform.org/what-is-an-internal-developer-platform/\">https://internaldeveloperplatform.org/what-is-an-internal-developer-platform/</a>\"</p><p></p><p><a href=\"https://web.devopstopologies.com/#anti-types\">https://web.devopstopologies.com/#anti-types</a>\"</p><p></p><p><a href=\"https://github.com/KusionStack/kusion\">https://github.com/KusionStack/kusion</a>\"</p><p></p><p><a href=\"https://github.com/KusionStack/KCLVM\">https://github.com/KusionStack/KCLVM</a>\"</p><p></p><p><a href=\"https://kusionstack.io/docs/reference/lang/lang/tour\">https://kusionstack.io/docs/reference/lang/lang/tour</a>\"</p><p></p><p><a href=\"https://kusionstack.io/docs/user_docs/concepts/konfig\">https://kusionstack.io/docs/user_docs/concepts/konfig</a>\"</p><p></p><p><a href=\"https://kusionstack.io/blog/2022-declarative-config-overview#35-performance\">https://kusionstack.io/blog/2022-declarative-config-overview#35-performance</a>\"</p><p></p><p><a href=\"https://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/fulltext\">https://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/fulltext</a>\"</p><p></p>",
    "publish_time": "2022-10-21 16:31:53",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "雪花啤酒数字化转型框架的制定逻辑｜第四期完整版（中）",
    "url": "https://www.infoq.cn/article/X4F32D6uCstZHtSWXwMe",
    "summary": "<p>《行知数字中国》第四期，InfoQ 邀请到华润雪花数字化负责人郭华，在本期访谈中，他首次对外界深入分享雪花啤酒数字化转型背后的战略部署和相关思考。</p>\n<p>本视频为第四期完整版的（中）集。</p>",
    "publish_time": "2022-10-21 16:43:14",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "可能是最严重的云存储数据外泄事故之一：微软承认服务器错误配置导致全球客户数据泄露",
    "url": "https://www.infoq.cn/article/URgelsO6yMlOzUczfkb0",
    "summary": "<p>微软安全响应中心在当地时间10月20日<a href=\"https://msrc-blog.microsoft.com/2022/10/19/investigation-regarding-misconfigured-microsoft-storage-location-2/\">发布公告</a>\"，针对19日网络安全供应商SOCRadar通报的数据泄露事件的<a href=\"https://socradar.io/sensitive-data-of-65000-entities-in-111-countries-leaked-due-to-a-single-misconfigured-data-bucket/\">调查报告</a>\"，微软承认了关键事实——即由于公有云服务器端点配置错误，可能导致未经身份认证的访问行为，继而泄漏微软和客户之间的某些业务交易数据以及客户的客人信息。但微软同时反驳称，SOCRadar报告中的数字被刻意夸大。</p><p></p><h2>可能涉及 111 个国家/地区，6.5万个实体</h2><p></p><p>SOCRadar 表示，它在搜寻和监控公共云存储桶的过程中，发现了六个由微软管理的大型公共存储桶，其中暴露了覆盖 123 个国家/地区超过15万家公司的信息。SOCRadar 将这次的数据泄漏统称为 BlueBleed。</p><p></p><p>根据 SOCRadar 的报告，2022年9月24日，该公司的内置云安全模块检测到微软维护的Azure Blob存储配置错误（来自最大的公共存储桶之一，被 SOCRadar 称为 BlueBleed 第 1 部分），其中包含来自知名云提供商的敏感数据。</p><p></p><p>SOCRadar 对配置错误的服务器、SQLServer 数据库和其他文件进行了调查，发现暴露的数据总计 2.4 TB ，文件时间横跨2017年到2022年8月，时间跨度达5年之久，涉及111个国家/地区的6.5万多个实体，有超过33.5万封电子邮件、13.3万个项目和54.8万名用户暴露。</p><p></p><p>泄露的文件包括执行证明（PoE） 、工作说明文档、发票、产品订单/报价、项目详情、已签署的客户文件、POC工程、客户电子邮件、客户产品价目表和客户库存、客户内部意见、营销策略、客户资产文档以及合作伙伴生态系统详细信息等。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/1c/1cb85a3ae0a199d589c507ded221844c.png\" /></p><p></p><p>SOCRadar 警告称，访问过上述存储桶的人可能会利用这些数据和信息进行勒索、钓鱼，或将其放到暗网上拍卖。</p><p></p><p>“当然，这肯定不是第一次因配置错误的服务器而暴露敏感信息，也不会是最后一次，” SOCRadar 的研究人员、BlueBleed 的主要调查员 Can Yoleri 说道。“然而，由于涉及数万个实体的重要泄露数据，BlueBleed 是近年来B2B领域最大规模的数据泄露事件之一。”</p><p></p><h2>微软争论其客户数据泄露的规模有多大</h2><p></p><p>微软承认了数据泄露，并对SOCRadar关于这一事件的告知和分析表示感谢，但同时指出，SOCRadar的博文夸大了这个问题的范围。</p><p></p><p>微软辩称，目前没有任何迹象表明客户帐户或系统已经被入侵，在接到错误配置的通知后，该端点迅速得到了保护，现在只有通过必要的认证才能访问，并已将情况通知给受影响的客户。此外，通过对数据集的深入调查和分析，发现有很多重复的数据，多次引用相同的电子邮件、项目和用户。</p><p></p><p>但微软没有透露在此次数据泄漏中可能涉及的公司数量或涉及的数据量等细节。其强调，此次泄漏不涉及任何漏洞，完全是由服务器配置错误引起的。“我们正在努力改进流程，以进一步防止此类错误配置，并执行额外的尽职调查以并确保所有微软端点的安全。 &nbsp;”</p><p></p><p>微软还表示，对SOCRadar在此事件中发布的数据泄露搜索工具“感到失望”，因为这不符合确保客户隐私或安全的最佳利益，并可能使客户面临不必要的安全风险。SOCRadar 表示，它提供了一项免费服务，企业可以使用它来搜索公司名称，以确定他们是否受到任何 BlueBleed 泄漏的影响。</p><p></p><p>对于任何想要提供类似工具的安全公司，微软建议要遵循基本措施来实现数据保护和隐私：</p><p></p><p>实施合理的验证系统，以确保用户与其声称的身份相符；遵循数据最小化原则，将交付的结果范围限定为仅与经核实的用户有关的信息；如果该公司无法以合理的保真度确定哪些客户的数据受到影响，则不向特定用户提供可能属于其他客户的信息（包括元数据/文件名）。</p><p></p><h2>云存储数据外泄成网络攻击主要路径</h2><p></p><p>SOCRadar 研究人员表示，服务器配置错误已是数据泄露的主要原因之一。而根据网络安全研究机构 SANS 最新发布的<a href=\"https://www.sans.org/white-papers/sans-2022-top-new-attacks-threat-report/\">网络攻击和威胁报告</a>\"，云存储数据外泄已成为 2022 年最常见的攻击路径之一。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e6/e66f0b07d8bdb4df2c0787e1c1326831.png\" /></p><p></p><p>研究人员写道：“威胁参与者是会不断扫描公共存储桶中的敏感数据。” “他们拥有使用高级工具自动扫描的资源和手段。而企业应使用自动安全工具主动监控此类网络风险。”</p><p></p><p>网络安全公司 KnowBe4 的安全意识倡导者 Erich Kron&nbsp;在接受媒体采访时<a href=\"https://www.theregister.com/2022/10/20/microsoft_data_leak_socradar/\">表示</a>\"，一些暴露的数据可能看起来微不足道，但如果 SOCRadar 的信息是正确的，“它可能包括一些关于潜在客户的基础设施和网络配置的敏感信息。这些信息对可能对在这些组织的网络中寻找漏洞的潜在攻击者很有价值。”</p><p></p><p>Kron 还表示，像 BlueBleed 这样的事件表明，与本地系统的类似问题相比，云存储的这种错误配置很可能会暴露更多组织和个人的信息。</p><p></p><p>参考链接：</p><p><a href=\"https://socradar.io/sensitive-data-of-65000-entities-in-111-countries-leaked-due-to-a-single-misconfigured-data-bucket/\">https://socradar.io/sensitive-data-of-65000-entities-in-111-countries-leaked-due-to-a-single-misconfigured-data-bucket/</a>\"</p><p><a href=\"https://msrc-blog.microsoft.com/2022/10/19/investigation-regarding-misconfigured-microsoft-storage-location-2/\">https://msrc-blog.microsoft.com/2022/10/19/investigation-regarding-misconfigured-microsoft-storage-location-2/</a>\"</p><p><a href=\"https://www.theregister.com/2022/10/20/microsoft_data_leak_socradar/\">https://www.theregister.com/2022/10/20/microsoft_data_leak_socradar/</a>\"</p>",
    "publish_time": "2022-10-21 17:10:16",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]