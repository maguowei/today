[
  {
    "title": "日均写7行代码，月薪3万程序员因代码量极少且差，试用期不合格被辞退",
    "url": "https://www.infoq.cn/article/e3AlIJAvAGbCbEFlGqhY",
    "summary": "<p></p><p>代码写得少又烂，离职少不了？</p><p></p><h3>程序员每天写7行代码被开除</h3><p></p><p>“代码写得少，离职少不了”。近期，一则有关程序员代码量的案件引起关注。</p><p></p><p>据中国裁判文书网显示，李某某与中科尚易健康科技（北京）有限公司产生了劳动争议。</p><p></p><p>判决书显示，李某某，男，1979年1月9日出生，于2020年11月2日入职中科尚易公司，岗位为机器视觉算法工程师，双方签订了劳动合同，期限为2020年11月2日至2023年11月1日，试用期为三个月，试用期工资为36000元／月。李某某离职前月平均工资为36000元。</p><p></p><p>2021年1月12日，中科尚易公司以李某某与其岗位不匹配、试用期不合格为由，明确告知李某某公司单方解除劳动合同的决定，并向李某某出示了《解除劳动合同通知书》。</p><p></p><p>2021年1月15日，李某某到开发区劳仲委申请劳动仲裁，要求：</p><p></p><p>1．中科尚易公司支付李某某2020年11月2日至2021年1月12日期间5天休息日加班工资16551．72元；</p><p></p><p>2．中科尚易公司支付李某某2021年1月1日至12日期间工资13241．37元；</p><p></p><p>3．中科尚易公司支付李某某违法解除劳动合同赔偿金36000元。</p><p></p><p>庭审中，中科尚易公司提交《新员工评价表》《李某某试用期工作量及工作质量评估》《人事管理制度》予以证明。</p><p></p><p>《新员工评价表》显示：被评价员工为李某某，评价日期为2021年1月11日，评价项目分为五大项目，包括：知识技能（本岗位相关）、职业素养、业绩表现、团队合作、沟通理解，每个大项目下分为3至5个小项，每个小项均分为四个评分等级，公司给李某某的评分极大部分为最低分，得出的综合评价意见为：</p><p></p><p>李某某试用期被证明不符合录用条件，具体体现在：</p><p></p><p>1．编程语言能力不足，两个多月唯一编写的机械臂控制代码质量极差，最后由其他同事代为重写；</p><p></p><p>2．试用期间提交的算法代码量很少，可交接的代码极少；</p><p></p><p>3．模型训练经验不足，对采集样本的影响因素分析不到位，总纠结于“开关灯”等不重要方面；对扩充样本也是过分着力在“裁剪”等不重要的细节上，造成很多反复浪费；</p><p></p><p>4．不服从小组工作安排，讲条件、推责任；</p><p></p><p>5．反复越级投诉，严重影响同事协作氛围；</p><p></p><p>6．个人工作不达标，延迟公司整体项目产品开发计划。</p><p></p><p>双方签订的《劳动合同书》中约定李某某任职研发部机器视觉算法工程师职务，其具体工作内容为：</p><p></p><p>1．参与医疗机器人项目的研发工作；</p><p></p><p>2．负责人体3D点云数据的实时运动跟踪编程及3D点云处理算法研究、选择和优化；</p><p></p><p>3．负责基于深度学习的人体姿态识别相关算法的研发与优化；</p><p></p><p>4．负责多个摄像头联合识别算法的研发；</p><p></p><p>5．负责基于深度学习的样本制作与训练；</p><p></p><p>6．负责将算法相关代码写成规范的软件并文档化；</p><p></p><p>7．参与产品项目的集成、调试、测试、验证等相关工作；</p><p></p><p>8．领导交办的其他工作。</p><p></p><p>《李某某试用期工作量及工作质量评估》显示：基于李某某上述岗位职责的要求，对试用期员工李某某的工作量及工作质量评估如下（综合评估见试用期员工评估表）：</p><p></p><p>一般工程师每天完成的代码量是100-200行，李某某作为公司聘用的富有经验的软件算法工程师，起码应该达到中位水平，即150行／天，2020年11月2日至2021年1月11日期间李某某完成3D点云处理算法0行；深度学习识别算法总计422行（其中包含70行因质量太差废弃不用的代码）；多摄像头联合识别算法0行；样本制作合计参与拍照时间约2天；样本训练参与工作量折合月7天；软件文档0个；集成、调试、测试、验证相关工作约3天。</p><p></p><p>也就是说，李某某在职72天，只完成了422行代码的编写，除去参与样本训练、集成、调试等相关工作占用的9天时间，在剩下的63天里，平均每天只写7行代码。</p><p></p><p>李某某对《新员工评价表》及《李某某试用期工作量及工作质量评估》的真实性均不认可，称其在职期间未见过该表，对评估结果不认可，工作质量评估的内容也未告知过其本人，不认可公司的解除理由。李某某对上述证据的真实性及证明目的不予认可。</p><p></p><p>关于是否违法解除劳动合同的问题，结合相关证据以及庭审笔录，一审法院认定中科尚易公司于2021年1月12日单方与李某某解除劳动合同，且不再为李某某提供办公设备，双方劳动合同于当日解除，解除理由为李某某试用期考核不合格、其与工作岗位不匹配。对于中科尚易公司关于以李某某存在1月13日至17日持续旷工、严重违反公司规定之情形与其解除劳动合同以及双方于2021年1月17日解除劳动合同的主张，无事实依据，一审法院不予支持。</p><p></p><p>因用人单位作出的开除、除名、辞退、解除劳动合同、减少劳动报酬、计算劳动者工作年限等决定而发生的劳动争议，用人单位负举证责任。</p><p></p><p>本案中，结合《劳动合同》，双方并未明确约定李某某试用期具体的考核标准，中科尚易公司在招聘时也未明确向李某某告知过试用期间的工作量及工作完成质量应达到的具体标准，故一审法院认定中科尚易公司对李某某并未设定具体的试用期录用标准。中科尚易公司提供的《新员工评价表》及《李某某试用期工作量及工作质量评估》均为公司单方制作，并未提交相关证据证明评定表、评估打分结果的具体依据，且表中评价意见未经李某某本人确认，属于主观评定，故一审法院对《新员工评价表》及《李某某试用期工作量及工作质量评估》评测内容不予采信。</p><p></p><p>中科尚易公司亦未提交其他证据证明李某某存在其他法定解除事由之情形，中科尚易公司以李某某试用期不符合录用条件为由与其单方解除劳动合同，无事实及法律依据，系违法解除劳动合同。李某某离职前月平均工资为36000元，且其在中科尚易公司工作年限不满六个月，经计算，中科尚易公司需支付李某某违法解除劳动合同赔偿金36000元。关于中科尚易公司主张无需支付李某某违法解除劳动合同赔偿金的主张，一审法院不予支持。</p><p></p><p>2021年2月24日，一审判决：一、中科尚易公司支付李某某违法解除劳动合同赔偿金36000元；二、中科尚易公司支付李某某2021年1月1日至12日期间工资13241．37元；三、驳回李某某其他申请请求。</p><p></p><p>上诉人中科尚易公司不服判决提起上诉，上诉请求：撤销一审判决第一项，改判中科尚易公司无需支付李某某违法解除劳动合同赔偿金36000元。</p><p></p><p>最终，二审判决，中科尚易公司的上诉请求不能成立，应予驳回；一审判决认定事实清楚，适用法律正确，应予维持。最终判决：驳回上诉，维持原判。</p><p></p><h3>程序员一天写多少代码算合格？</h3><p></p><p>在这个案件中，双方劳动争议的焦点在于，用人单位认为李某某在任职期间的工作表现其岗位不匹配、不合格。主要表现在代码量极少、代码质量差，编程能力差等方面，此外李某某本人还存在工作态度、价值观上的问题。李某某的综合表现导致其公司作出了与其解除劳动关系的决定。</p><p></p><p>由该案件也可以看出，对于程序员来说，代码量和代码质量非常重要。在业界也常常有关于</p><p></p><p>“程序员一天写多少代码才算<a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651005558&amp;idx=1&amp;sn=843bf88d88a7326eb8904b7dd84b376d&amp;chksm=bdbeda258ac9533310e471cc5239f975346aad1f223a50eb7bde5fe300ac87e60971415f94d6&amp;scene=27#wechat_redirect\">合格</a>\"？”这样的讨论。</p><p></p><p>此前，在Quora上有这样一个问题 —— Google的工程师们每天写多少行代码？对此，Google的AdMob全栈工程师评论称，“我的同事最近和我分享了一组调查研究数据，一名高效的工程师每天能写100-150行代码，我嘲笑了他，表示这项预估值绝对要比实际值低”。</p><p></p><p>Raymond Farias为了证明上述估计值的错误，决定以他在谷歌工作效率最高的一个月为例，并使用了Google的一个内部工具来查看每天的代码增量，包括增删改查的代码行数。最后他将一个月的数据汇总然后平均到工作日得出最后结论是150，随后对他的其他同事进行了检测，最后得出的数据基本一致。</p><p></p><p>有一些数据显示，在国内公司，一些熟练程序员正常的生产率为每天100行代码左右。当然，这也因人而异。</p><p></p><p>事实上，代码量与“合格”、“优秀”这样的关键词没有直接的因果关系。我们不应当用代码量来评价一个程序员的好坏。就好比，一个作家并不能因为写作字数多而获得诺贝尔文学奖。</p><p></p><p>要想让代码量增多很简单，有很多方法可以实现。但这样多出来的代码有多少是真正有效的代码呢？本来 10 行代码可以实现的功能，非得用 100 行去实现，有什么意义呢？真正理想的代码应当是又好、又快、又精简的。</p><p></p><p>对于应届生以及初入职场的程序员来说，要求代码量无可厚非，因为，代码量在一定程度上是编程基础和熟练程度的体现。而对于有一定工作年限的程序员来说，再以代码量作为硬性指标和考核标准则显得有些机械，最核心关注的指标应该是代码质量，而非代码行数。</p><p></p><p>但是，编码是程序员的本职工作，如果代码量极少且质量又差，这显然是不负责任的。一个优秀的程序员不一定每时每刻都在编码，但应当以具备独立、深入思考，高效代码等能力时刻要求自己。</p><p></p><p>参考链接：</p><p></p><p><a href=\"https://wenshu.court.gov.cn/website/wenshu/181107ANFZ0BXSK4/index.html?docId=8bfa168edbc74c25aca03a56e3ac29b2\">https://wenshu.court.gov.cn/website/wenshu/181107ANFZ0BXSK4/index.html?docId=8bfa168edbc74c25aca03a56e3ac29b2</a>\"</p><p></p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651005558&amp;idx=1&amp;sn=843bf88d88a7326eb8904b7dd84b376d&amp;chksm=bdbeda258ac9533310e471cc5239f975346aad1f223a50eb7bde5fe300ac87e60971415f94d6&amp;scene=27#wechat_redirect\">https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651005558&amp;idx=1&amp;sn=843bf88d88a7326eb8904b7dd84b376d&amp;chksm=bdbeda258ac9533310e471cc5239f975346aad1f223a50eb7bde5fe300ac87e60971415f94d6&amp;scene=27#wechat_redirect</a>\"</p><p></p>",
    "publish_time": "2022-09-04 10:16:01",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "我庆幸果断放弃了SwiftUI：它还不够成熟",
    "url": "https://www.infoq.cn/article/V8U4t2ubMVrEBzyzl8ed",
    "summary": "<p></p><p></p><blockquote>SwiftUI很好，但是苹果对它投资不足。</blockquote><p></p><p></p><p>在2019年的 WWDC大会上，苹果推出了一个全新的 SwiftUI 框架，这是一个现代化的 UI 界面编码结构，它是基于 Swift从头开始构建的。新框架使用声明性范例，让开发者用更少的代码编写相同的 UI。</p><p></p><p>SwiftUI 的愿景是降低开发 iOS 门槛，吸引更多开发者、丰富 iOS 的业态。并且SwiftUI 可以“实现一次编码，可适应五端 Apple 产品平台”， 包括watchOS、tvOS、macOS 等，以此统一苹果平台的 UI 框架。</p><p></p><p>苹果传递出来的消息就像是说：“SwiftUI 是一个了不起的用户界面框架，而且 100% 绝对会成为苹果平台上应用开发的未来。”</p><p></p><p>这些年，也有一些用 SwiftUI 重写 UIKit 应用程序的案例，去年奈飞新版 iOS App 的登录界面也完全由 SwiftUI 重构。</p><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/10/104d6dd708d46479fabd8690af4d1172.png\" /></p><p></p><p>本文的作者chsxf，是一家独立游戏工作室的首席开发，也是15年的苹果用户，他想尝试将SwiftUI放到自己的项目中，但是最终失败了。他发表了一篇博客，总结了尝试并放弃SwiftUI的过程，这篇文章在Hacker News上引发了开发者们的大量讨论：</p><p></p><p>“恕我直言，SwiftUI 是一个很好的机会，但苹果公司对它投资不足。这是一项很好的技术，响应式方法非常适合许多典型的基于视图的需求，但对如何处理边缘情况，文档中非常缺乏相关的说明。”</p><p></p><p>“这是个好主意，但SwiftUI的主要问题是完全不成熟。”“它具有复杂的行为，不适用于需要大容量或复杂UI的App。”</p><p></p><p>“而且SwiftUI改进太慢了。”......</p><p></p><p></p><h2>chsxf的博客原文翻译：</h2><p></p><p></p><p>最近，我手头正好有个“The Untitled Project”（名字还没想好）项目需要完成。考虑到配套创作工具CiderKit在发展成熟的过程中也变得愈发复杂，再加上创建各种窗口和UI元素的实际需求，我决定尝试用用SwiftUI。这是个宝贵的机会，能让我认真体验一把SwiftUI并探索其内部工作原理。</p><p></p><p>起初项目工作良好，我对SwiftUI的表现可以说非常满意，我甚至创建了自己的修改器，以便更轻松地显示警报消息。但美好的甜蜜期很快过去，接下来我就要说道说道SwiftUI的那些“坏毛病”了。</p><p></p><p></p><h3>实时检查器不好用</h3><p></p><p></p><p>接下来，我开始了SwiftUI探索之旅的第二站——为地图编辑器创建实时检查器。跟其他创作工具一样，这款检查器的功能就是选定一个对象，并把可检查的对应属性显示在一个临时的用户界面元素当中。过程当中，Swift协议和它处理泛型的方式也给我带来了不少麻烦，但这里我们就不过多展开了。</p><p></p><p>我还遇到了其他问题，因为SwiftUI高度依赖于View协议的实现结构，但View协议又有关联的类型，所以只能把它当成约束来用。好在配合some关键字和opaque类型等设计，我最终还是为可选对象找到了一种实现方法，让每个对象都能提供自身特定的UI元素。</p><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/79/7956d6e023d355d63d3ad532266894b8.png\" /></p><p></p><p>之所以下决心选择SwiftUI，就是因为初步测试时效果不错。如上图所示，地图编辑器位于左侧，检查器位于右侧。起初，我测试了一个UI元素，那是个用于开灯和关灯的勾选框。它运行良好，所以我根本想象不到后续会出什么大乱子。</p><p></p><p>但在开始实现更复杂的检查器视图时，特别是涉及带有/不带步进器或颜色选择器的多个文本字段时，整个运行速度开始剧烈下降。SpriteKit视图一般都能以每秒60帧的完美速率呈现（只要用的不是英特尔孱弱的iGPU）。但每当SwiftUI更新检查器视图时（这种更新可能出现在移动过程中，甚至是在输入文本字段的时候），渲染速率都会下降到每秒10到15帧，而且相当不稳定。这显然让人无法容忍。</p><p></p><p>我认真做了一番分析，并发现了几个问题。首先，由可选对象提供的视图在每次重绘时都是在完全重新创建。我虽然通过缓存稍稍提升了性能表现，但实际体验仍然非常糟糕。事实证明，SwiftUI检查器视图就是没法提供合理的重绘速度。我在网上查找了解决方案，最后编写了一个延迟版本的ObservableObject，由它来强制每秒只发布一次更改（参见以下代码）。</p><p></p><p>import Combine</p><p>import Foundation</p><p></p><p>extension ObservableObject {\n    func delayed(_ delay: TimeInterval = 1.0) -&gt; DelayedObservableObject {\n        return .init(object: self, delay: delay)\n    }\n}</p><p></p><p>@dynamicMemberLookup</p><p>class DelayedObservableObject: ObservableObject where Object: ObservableObject {<p></p><p>    private var original: Object</p><p>    private var subscription: AnyCancellable?</p><p></p><p>fileprivate init(object: Object, delay: TimeInterval) {</p><p>        self.original = object</p><p>        subscription = object.objectWillChange</p><p>            .throttle(for: RunLoop.SchedulerTimeType.Stride(delay), scheduler: RunLoop.main, latest: true)</p><p>            .sink { [weak self] _ in self?.objectWillChange.send() }</p><p>    }</p><p></p><p>subscript(dynamicMember keyPath: WritableKeyPath) -&gt; Subject {</p><p>        get { original[keyPath: keyPath] }</p><p>        set { original[keyPath: keyPath] = newValue }</p><p>    }</p><p>}</p><p></p><p>随着重绘频率的降低，终于能比较顺畅地操作地图上的对象了，每秒的帧率浮动一般就只有个位数。但这会导致检查器中的值出现延迟，因此在地图编辑器的交互过程中（比如使用移动工具时）结果不准确，所以效果还是称不上完美。</p><p></p><p>但我觉得这可能只是个独立问题，并不能因此把SwiftUI一棒子打死。所以，我打算继续探索。</p><p></p><p></p><h3>越来越慢</h3><p></p><p></p><p>在实现了第一个检查器之后，我开始研究另一个主题：Sprite资产编辑器。利用这款工具，我可以用多个sprite拼接成复杂的资产，再最终为它们制作动画。它的显示效果就是主窗口中的一张表，出于学习的目的，我当然还是想继续用SwiftUI喽。毕竟初次尝试肯定会有种种问题，应该再给它一次机会。</p><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d3/d3e33ba0a7a6f71d36812e4018377b6a.png\" /></p><p></p><p>如大家所见，这是个复杂的窗口，包含多种不同上下文（上方的「Sprite资产数据库」列表，左侧的特定「Sprite资产数据库」内容，以及其他与选定Sprite资产对应的编辑器元素）。我需要为每个上下文创建一个视图，这些视图同时又是其他视图的「子视图」，然后把需要的数据传递给特定视图。</p><p></p><p>但上图展示的效果其实是在AppKit中完成的，因为我在SwiftUI一直实现不了预期的功能。大家应该注意到了，中间的SpriteKit视图上有三个按钮（分别是+、200%和-）。这些按钮只跟管理SpriteKit视图缩放的@State相关联。尽管几乎不涉及任何其他数据，在界面更新前单击这些按钮，也会产生将近一秒钟的巨大延迟。我刚开始以为是因为地图编辑器的SpriteKit主视图仍在后台渲染。所以我尝试在工作表显示出来后禁用渲染，但结果没有任何改变。</p><p></p><p>变更从一种环境传播至另一环境时，我也遇到了类似的延迟问题。这可以说是压死骆驼的最后一根稻草了，我决定放弃SwiftUI，继续用AppKit。</p><p></p><p></p><h3>总结</h3><p></p><p></p><p>其实没能在项目中用到SwiftUI，会让我感觉有点遗憾。我仍然觉得它是一项很棒的技术，只是可能不适合我的这个特定用例。但我真的不确定是不是自己的用法有问题。我打算在Nihongo no Kana的更新版本中再用用SwiftUI，毕竟那款iOS/iPadOS应用的重绘频率低得多，所以应该不会有太大问题。</p><p></p><p>也许SwiftUI还没做好全面替代AppKit的准备。The Untitled Project的CiderKit创作工具并不是作为Catalyst应用构建的，也不依赖于UIKit。但继续使用AppKit的最大优点，就是没有任何延迟而且一切功能完全符合预期。当然，整个构建过程更繁琐，而且自动布局功能也不怎么好用。但我至少可以更好地控制应用程序的行为，而且根据需求随意调整各种元素。</p><p></p><p>总之，经历了这么一番波折，我还是很庆幸自己果断放弃了SwiftUI。这可能是我在这个项目上做过的最明智的选择。</p><p></p><p>参考链接：</p><p>https://chsxf.dev/2022/08/28/5-tup-why-i-quit-using-swiftui.html</p><p>https://news.ycombinator.com/item?id=32630389</p><p>https://xie.infoq.cn/article/28af907f31baa7e7283a31ed4</p></p>",
    "publish_time": "2022-09-04 12:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]