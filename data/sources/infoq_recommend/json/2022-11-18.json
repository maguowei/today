[
  {
    "title": "容器编排器生态：Swarm、Kubernetes、Nomad 并非仅有产品，但是最有生命力三个",
    "url": "https://www.infoq.cn/article/MeAAslt9z7vHWhNy4YyS",
    "summary": "<p></p><blockquote>尽管复杂，Kubernetes仍然是目前最流行的编排器，但 HashiCorp 在 Nomad 上的成功也表明，Kubernetes的替代方案还有发展空间。&nbsp;有些用户仍然热衷于Docker Swarm的简单性，但它的未来存在不确定性，其他替代方案看上去已经基本被放弃了。现在的生态似乎主要围绕着Swarm、Kubernetes 和 Nomad 这三个玩家，但容器编排仍然是一个相对不那么成熟的领域。十年前，这种技术几乎还不存在，现在仍在快速发展。容器编排领域可能还会出现许多令人兴奋的新想法和新发展。</blockquote><p></p><p>&nbsp;</p><p>本文最初发布于LWN.net。</p><p>&nbsp;</p><p><a href=\"https://lwn.net/Articles/902049/\">Docker及其他容器引擎</a>\"可以从许多方面简化服务端应用程序的部署，但许多应用程序不只包含一个容器。随着部署的应用程序和服务增加，管理一组容器的难度越来越大，一类名为容器编排器的工具由此发展了起来，截至目前最著名的是<a href=\"https://kubernetes.io/\">Kubernetes</a>\"，容器编排的历史以它为界也分成了前后两段。</p><p>&nbsp;</p><p>在享受容器带来的便利的同时，我们也要做好一些权衡取舍。如果一个人严格遵守Docker“<a href=\"https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#decouple-applications\">每个服务都应有自己的容器</a>\"”的理念，那么最终他将运行海量的容器。即使是一个访问数据库的简单Web界面也可能需要为数据库服务器和应用程序运行单独的容器，它可能还包括一个单独的Web服务器容器用于提供静态文件服务、一个单独的代理服务器容器用于终止SSL/TLS连接、一个键/值存储容器充当缓存，或者一个辅助应用程序容器用于处理后台作业及计划任务。</p><p>&nbsp;</p><p>一位管理员如果负责了数个这样的系统，很快就会发现需要一个工具来简化自己的工作，这就是容器编排器的用途所在了。</p><p>&nbsp;</p><p>容器编排器是一个工具，它可以将一组容器当成一个单元来管理。编排器让你可以将多台服务器合并成一个集群，并自动在集群节点之间分配容器工作负载，而不是单独在一台服务器操作。</p><p></p><p></p><h2>Docker Compose 和 Swarm</h2><p></p><p>&nbsp;</p><p><a href=\"https://github.com/docker/compose\">Docker Compose</a>\" 称不上是一个不完全的编排器，但这是Docker第一次尝试创建一个工具来简化多容器应用程序的管理。Compose读取一个YAML文件，通常命名为docker-compose.yml，并使用 Docker API创建文件中声明的资源；Compose还会为所有资源添加标签，以便在创建完成后把它们当成一个组来管理。实际上，它是Docker命令行接口（CLI，可操作容器组）的一个替代方案。Compose文件可以定义三类资源：</p><p>&nbsp;</p><p>服务（services)：声明要启动的容器，其中每一条都相当于一个docker&nbsp;run命令。网络（networks）：声明可以附加到容器（Compose文件中定义的）的网络，其中每一条相当于一个docker&nbsp;network&nbsp;create命令。卷（volumes）：&nbsp;定义可以附加到容器的命名卷。在Docker术语中，卷是可以挂在到容器的持久存储。命名卷由Docker daemon管理。其中每一条相当于一个docker&nbsp;volume&nbsp;create命令。</p><p>&nbsp;</p><p>网络和卷可以直接连接到Docker所在主机的网络和文件系统，也可以通过<a href=\"https://docs.docker.com/engine/extend/legacy_plugins/\">插件</a>\"提供。网络插件可以帮我们实现像将容器连接到VPN这样的事情；卷插件可以帮我们将卷存储在一台NFS服务器或一个对象存储服务上。</p><p>&nbsp;</p><p>在管理多容器应用程序方面，Compose提供了一种方便许多的方式，但在最初的版本中，它只能工作在单台主机上，创建的所有容器也运行在相同的机器上。为了让它能够覆盖多台主机，Docker在2016年推出了Swarm mode。实际上，这是Docker第二个带有“Swarm”字样的产品——2014年的一款产品实现了一种完全不同的、跨多台主机运行容器的方式，但Docker已经不再维护，它被 SwarmKit 所取代，后者是Docker Swarm当前版本的基础。</p><p>&nbsp;</p><p>Swarm mode包含在Docker中，无需安装其他软件。创建集群很简单，只需在初始节点上运行docker swarm init，然后在每个要添加的节点上运行docker swarm join。Swarm集群包含两种类型的节点。管理节点提供了一个API，用于启动集群中的容器，并使用基于<a href=\"https://raft.github.io/\">Raft一致性算法</a>\"的协议互相通信，在所有管理节点间同步集群状态。工作节点完成运行容器的具体工作。这些集群可以到多大我们并不是很确定，Docker的文档说一个集群的管理节点不应超过7个，但并没有说明工作节点的数量限制。跨节点桥接容器网络功能是自带的，但跨节点共享存储不是，需要借助第三方卷插件来提供跨节点的共享持久存储。</p><p>&nbsp;</p><p>服务使用Compose文件部署到Swarm上。Swarm扩展了Compose模式，为每个服务添加了一个deploy键，用于指定该服务应该运行多少实例以及应该在哪些节点上运行。遗憾的是，这导致了Compose和Swarm的分化，进而导致了一些混乱，因为对于像CPU和内存配额这样的选项，它们提供了不同的指定方式。</p><p>&nbsp;</p><p>在这段时期内，为了避免歧义，用于Swarm的文件被称作“栈文件”，而不是Compose文件；所幸，在Swarm和Compose的当前版本中，这些差异似乎已经被抹平。如果引用的栈文件和Compose文件截然不同，那多半是从网上搜来的。现在，Compose格式已经有了一个开放的规范，并且它自己的GitHub社区也提供了参考实现。</p><p>&nbsp;</p><p>Swarm的未来还存在一定的不确定性。它曾是Docker Cloud服务的基础，但<a href=\"https://web.archive.org/web/20200611102535/http://success.docker.com/article/cloud-migration\">该服务2018年突然关闭了</a>\"；它也曾被认为是Docker企业版的关键特性，但那个产品自此卖给了另外一家公司，它现在的名称为Mirantis&nbsp;Kubernetes&nbsp;Engine。与此同时，Compose的最新版本已经具备向亚马逊和微软托管服务部署容器的能力。一直没有弃用声明，但记忆中也没有任何其他类型的公告。在Docker的网站上搜索“Swarm”这个词，也只能够搜到过去一些曾提及它的信息。</p><p>&nbsp;</p><p></p><h2>Kubernetes</h2><p></p><p>&nbsp;</p><p>Kubernetes （有时候称为k8s）项目的灵感来自谷歌内部的一个工具<a href=\"https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes/\">Borg</a>\"。Kubernetes可以在多达数千个节点的集群上管理资源并协调工作负载的运行；它在容器编排领域的统治地位就像谷歌在搜索领域的地位一样。2014年，谷歌希望与Docker合作开发Kubernetes，但Docker决定走自己的路，继续开发Swarm。然而，Kubernetes在<a href=\"https://www.cncf.io/certification\">云原生计算基金会</a>\"（CNCF）的主持下发展壮大。截至2017年，Kubernetes已经变得如此流行，以至于Docker也宣布将其集成到自己的产品中。</p><p>&nbsp;</p><p>除了受欢迎之外，Kubernetes主要以其复杂性而闻名。手动配置一个新集群是一项非常复杂的任务，除了Kubernetes之外，管理员还需要选择并配置多个第三方组件。和Linux内核需要结合额外的软件形成完整的操作系统一样，Kubernetes只是一个编排器，它需要结合其他的软件才能组成一个完整的集群。它需要一个容器引擎来运行容器；它还需要网络插件以及持久卷插件。</p><p>&nbsp;</p><p><a href=\"https://containerjournal.com/topics/container-ecosystems/kubernetes-distribution-what-it-is-and-what-it-isnt/\">Kubernetes发行版</a>\"的存在填补了这一空白。和Linux发行版一样，Kubernetes发行版也将Kubernetes与安装程序以及精心挑选的第三方组件捆绑在一起。不同发行版的存在是为了满足不同的细分市场；似乎每个具有一定规模的公司都有自己的发行版和/或托管服务，以迎合企业的需求。minikube项目让开发人员可以轻松地在本地搭建一个试验环境。和Linux发行版不同，Kubernetes发行版经过了CNCF的一致性认证；为了得到认证，每个发行版都必须实现基本的功能，这样它们才能使用“Certified Kubernetes”标识。</p><p>&nbsp;</p><p>一个Kubernetes集群包含多个软件组件。集群中的每个节点都运行着一个名为kubelet的代理，用于维护集群的成员关系并从它接收工作。它还运行着一个容器引擎和kube-proxy，后者负责与在其他节点上运行的容器进行网络通信。</p><p>&nbsp;</p><p>维护集群状态的组件以及决定资源分配的组件合称为控制平面——这包括一个名为<a href=\"https://etcd.io/\">etcd</a>\"的分布式键值存储，一个给集群节点分配工作的调度器，一个或多个响应集群状态变化的控制器进程，负责触发所需的操作，使集群的状态符合预期。用户和集群节点通过Kubernetes&nbsp;API Server与控制平面交互。要实现修改，用户会通过API Server设定期望的集群状态，而kubelet会向控制器进程报告每个集群节点的实际状态。</p><p>&nbsp;</p><p>Kubernetes在一个名为pod的抽象中运行容器，其中可以包含一个或多个容器，不过，并不建议在一个pod中运行多个服务的容器。相反，一个pod通常只有一个提供服务的主容器，可能会有一个或多个“边”容器负责从运行服务的主容器中收集指标或日志。一个pod中的所有容器都将调度到同一台机器上，共享同一个网络命名空间——在同一pod中运行的容器可以通过loopback接口相互通信。每个pod在集群中都有自己独一无二的IP地址。运行在不同pod中的容器可以使用它们的集群IP地址相互通信。</p><p>&nbsp;</p><p>Pod指定一组要运行的容器，但pod的定义并没有说明在哪里运行这些容器，或者是运行多长时间——没有这些信息，Kubernetes就会在集群上的随便什么地方启动容器，但不会在它们退出时重启，而且，如果控制平面判断其他工作负载需要它们占用的资源，Kubernetes可能会终止它们。为此，pod很少单独使用；取而代之，pod的定义通常是封装在用于定义持久服务的Deployment对象中。和Compose及Swarm一样，由Kubernetes管理的对象是在YAML中声明的；对于Kubernetes，YAML声明是通过 kubectl 工具提交到集群的。</p><p>&nbsp;</p><p>除了pod和Deployment之外，Kubernetes还可以管理许多其他类型的对象，如负载均衡器和授权策略。它支持的API清单还在不断增长，根据Kubernetes的版本以及集群运行的哪个发行版会有所不同。<a href=\"https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/\">自定义资源</a>\"可以用于向集群添加API，用于管理额外的对象类型。例如，<a href=\"https://kubevirt.io/\">KubeVirt</a>\"添加的API使Kubernetes可以运行虚拟机。可以通过<a href=\"https://jamesdefabia.github.io/docs/user-guide/kubectl/kubectl_api-versions/\">kubectl&nbsp;api-versions</a>\"命令查看特定集群支持的完整API清单。</p><p>&nbsp;</p><p>和Compose不同，这些对象中的每一种都是在单独的YAML文档中声明的，虽然多个YAML文档可以内联到一个文件中，并用“---”隔开（参加<a href=\"https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#organizing-resource-configurations\">Kubernetes文档</a>\"）。一个复杂的应用程序可能包含许多对象，它们的定义分散在多个文件中；在维护这样一个应用程序时，保持所有这些定义彼此同步会非常繁琐。为了简化这项工作，有些Kubernetes管理员转而采用像<a href=\"https://jsonnet.org/articles/kubernetes.html\">Jsonnet</a>\"这样的模板工具。</p><p>&nbsp;</p><p><a href=\"https://helm.sh/\">Helm</a>\"让模板工具更上一层楼。和Kubernetes类似，Helm也是在CNCF的主持下开发的；它号称是“Kubernetes包管理器”。Helm从一套名为chart的模板和变量声明生成Kubernetes的YAML配置。它使用的模板语言不同于Ansible使用的<a href=\"https://jinja.palletsprojects.com/en/3.1.x/\">Jinja</a>\"模板，但看上去非常相似；熟悉<a href=\"https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html\">Ansible Roles</a>\"的人看到Helm Charts也会感觉很熟悉。</p><p>&nbsp;</p><p>Helm Charts集可以发布到<a href=\"https://helm.sh/docs/topics/chart_repository/\">Helm存储库</a>\"；<a href=\"https://artifacthub.io/\">Artifact Hub</a>\"提供了一个很大的公共Helm存储库目录。管理员可以将这些存储库添加到他们的Helm配置中，使用已经编制好的Heml chart将流行应用的预打包版本部署到集群上。Helm的最新版本还支持向容器注册中心推送或从注册中心拉取chart，为管理员提供了一个选型，让他们可以将chart和容器镜像存储在一起。</p><p>&nbsp;</p><p>Kubernetes的增长势头还没有任何减缓的趋势。按照设计，它可以管理任何类型的资源；这种灵活性（已为KubeVirt虚拟机控制器所证明）使得，即使容器化工作负载最终不再流行，Kubernetes仍然有继续存在的价值。开发有序进行，新的主版本定期发布。版本支持周期为1年；似乎没有长期支持版本。集群可以升级，但有人喜欢新建一个集群，并将服务迁移过去。</p><p>&nbsp;</p><p></p><h2>Nomad</h2><p></p><p>&nbsp;</p><p><a href=\"https://www.hashicorp.com/products/nomad\">Nomad</a>\"是HashiCorp推出的一个编排器，号称是一个比Kubernetes更简单的替代方案。和Docker及Kubernetes类似，Nomad是一个开源项目。它包含一个名为nomad的二进制文件，可以用于启动一个名为代理的守护进程。它还提供了一个CLI，用于和代理通信。根据配置方式不同，代理进程可以在两种模式下运行。在服务器模式下运行的代理可以接受作业，并为它们分配集群资源。在客户端模式下运行的代理会接收作业，运行它们，并将作业状态报告给服务器。代理还可以在开发模式下运行，同时承担客户端和服务器的角色，成为一个用于测试目的的单节点集群。</p><p>&nbsp;</p><p>创建Nomad集群相当简单。在Nomad最基本的操作模式中，必须启动初始服务器代理，然后使用nomad&nbsp;server&nbsp;join命令向集群添加额外的节点。HashiCorp还提供了Consul，这是一个通用的服务网格和发现工具。虽然Nomad可以单独使用，但最好是和Consul搭配使用。Nomad代理可以使用Consul自动发现并加入一个集群，它还可以执行健康检查，提供DNS记录，并为集群上运行的服务提供HTTPS代理。</p><p>&nbsp;</p><p>Nomad支持复杂的集群拓扑。每个集群被划分成一个或多个“数据中心”。和Swarm类似，同一数据中心中的服务器代理使用一种基于Raft的协议相互通信；这种协议有严格的延迟要求，但多个数据中心可以用gossip协议连接起来，从而使信息可以在集群中传播，而又不需要每个服务器与其他服务器保持直接连接。从用户的角度来看，以这种方式连接起来的数据中心就和一个集群一样。这种架构让Nomad在扩展到大量集群时颇有优势。按照官方说法，Kubernetes最多支持5000个节点和3万个容器，而Nomad的文档中提到了一个有1万多节点的集群示例和一个有20万容器的集群示例。</p><p>&nbsp;</p><p>和Kubernetes类似，Nomad并没有包含一个容器引擎或运行时，它使用任务驱动器来运行作业。它包含使用Docker和Podman来运行容器的任务驱动器；社区提供了面向其他容器引擎的驱动器。Nomad的野心也不限于容器，这点也和Kubernetes类似。它还提供了面向其他工作负载类型的任务驱动器，包括在主机上运行命令的fork/exec驱动器，运行虚拟机的QEMU驱动器，启动Java应用程序的Java驱动器。社区支持的任务驱动器可以将Nomad连接到其他类型的工作负载。</p><p>&nbsp;</p><p>与Docker或Kubernetes不同，Nomad不使用YAML，而是使用<a href=\"https://github.com/hashicorp/hcl\">HashiCorp配置语言</a>\"（HCL）。HCL最初是为HashiCorp的另一个项目创建的，用于配置名为<a href=\"https://www.terraform.io/\">Terraform</a>\"的云资源。虽然在其他地方的应用有限，但HashiCorp的整个产品线都在使用HCL。用HCL编写的文档很容易转换成JSON，但它的目标是提供一种比JSON更便捷、比YAML更不容易出错的语法。</p><p>&nbsp;</p><p>HashiCorp提供的相当于Helm的产品是Nomad Pack。和Helm类似，Nomad Pack会处理一个满是模板和变量声明的目录，生成作业配置。Nomad还有一个预打包应用程序的社区注册中心，但其选择空间比Helm的Artifact Hub要小很多。</p><p>&nbsp;</p><p>Nomad不像Kubernetes那么受欢迎。和Swarm一样，它的开发似乎主要是由其创建者推动的；尽管有许多大公司部署了HashiCorp，但HashiCorp仍然是Nomad相关社区的中心。目前看来，该项目似乎不太可能获得足够的发展势头，进而从母公司独立出来。对用户来说，与Docker在Swarm上做的工作相比，HashiCorp对Nomad的开发和推广或许更有保证。</p><p></p><h2>小结</h2><p></p><p>&nbsp;</p><p>Swarm、Kubernetes和Nomad并不是仅有的容器编排器，但它们是其中最有生命力的三个。<a href=\"https://mesos.apache.org/\">Apache Mesos</a>\"也可以用来运行容器，但它在2021年就几乎被封存了；<a href=\"https://dcos.io/\">DC/OS</a>\"基于Mesos，但很像Docker企业版，支持其开发的公司现在也专注于Kubernetes。其他大多数容器编排项目，如OpenShift和Rancher，实际上只是增强（和认证）的Kubernetes发行版，即使它们的名字中没有 Kubernetes。</p><p>&nbsp;</p><p>尽管 Kubernetes 非常复杂，它仍然是目前最流行的编排器，但HashiCorp在Nomad上的成功表明，替代方案也还有它的发展空间。有些用户仍然热衷于Docker Swarm的简单性，但它的未来存在不确定性。至此，其他替代方案看上去已经基本被放弃了。现在的生态似乎主要围绕着这三个玩家，但容器编排仍然是一个相对不那么成熟的领域。十年前，这种技术几乎还不存在，而它现在仍在快速发展。容器编排领域可能还会出现许多令人兴奋的新想法和新发展。</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://lwn.net/SubscriberLink/905164/e1f4d4c1ce35f8b9/\">The container orchestrator landscape</a>\"</p>",
    "publish_time": "2022-11-18 07:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "Tensorflow新一轮迭代路线图：更好的XLA编译和分布式计算",
    "url": "https://www.infoq.cn/article/0LoWyKuYdXlCdWkNEyPV",
    "summary": "<p>谷歌<a href=\"https://blog.tensorflow.org/2022/10/building-the-future-of-tensorflow.html\">宣布</a>\"TensorFlow开发的下一轮迭代。TensorFlow是由谷歌开发并在七年前<a href=\"https://github.com/tensorflow\">开源</a>\"的机器学习平台，现在是GitHub上star数量最多的项目之一。另外一个方案是<a href=\"https://pytorch.org/\">Pytorch</a>\"，它是由Facebook开发和开源的ML平台。未来几个<a href=\"https://www.infoq.cn/topic/TensorFlow\">TensorFlow</a>\"发布版本的开发路线图将基于四个支柱，分别是快捷与扩展性、机器学习应用、部署就绪和简单性。</p><p></p><p>对于快捷和可扩展的支柱来说，开发工作将主要关注XLA编译，因为谷歌认为XLA将成为深度学习编译器的行业标准。其目标是使模型训练和推理工作流程在CPU和GPU上更快地执行。开发也将关注分布式计算方面：借助<a href=\"https://www.tensorflow.org/guide/dtensor_overview\">DTensor</a>\"，模型将能够在多个设备上进行训练，以解锁未来超大型模型的训练和部署。此外，性能也很重要，所以谷歌将对算法性能的优化进行投资，如<a href=\"https://en.wikipedia.org/wiki/Mixed-precision_arithmetic\">mixed-precision</a>\"和<a href=\"https://www.rambus.com/blogs/reduced-precision-computation-for-neural-network-training/\">reduced-precision</a>\"计算，以提高在GPU和TPU上的速度。</p><p></p><p>对于机器学习应用支柱，谷歌将投资<a href=\"https://github.com/keras-team/keras-cv\">KerasCV</a>\"和<a href=\"https://github.com/keras-team/keras-nlp\">KerasNLP</a>\"包，这些包是为应用CV和NLP使用场景设计的，包括大量的预训练模型。该支柱也将以开发者资源为基础：对于流行的和可应用的机器学习场景添加更多的代码样例、指南和文档，以降低机器学习的进入门槛。</p><p></p><p>对于部署就绪支柱，努力的方向主要在于更便利地将模型导出到移动端、边缘端、服务后端以及JavaScript中。尤其是，将模型导出到<a href=\"https://www.tensorflow.org/lite\">TFLite</a>\"和<a href=\"https://www.tensorflow.org/js\">TF.js</a>\"将会更易于调用。C++原生API正处于开发阶段，它会更易于部署使用<a href=\"https://github.com/google/jax\">JAX</a>\"和TensorFlow Serving开发的模型，并使用TFlite和TF.js部署到移动端和web中。</p><p></p><p><a href=\"https://numpy.org/\">NumPy</a>\"&nbsp;API和更便利的调试体验将是第四个支柱的核心特征，即简单性。Tensorflow将采用NumPy API的数值标准，以使其更加一致和易于理解。Tensorflow还会实现更好的调试器功能，以最大限度地减少开发人员解决问题的时间。</p><p></p><p>谷歌承诺，新的Tensorflow版本将100%向后兼容，这样，工程师可以立即采用最新的版本，而不用担心现有的代码库会出现问题。</p><p></p><p>Tensorflow新功能的预览版计划在2023年第二季度推出，生产版本计划在同一年推出。关于路线图和相关更新的更多信息可以参阅<a href=\"https://blog.tensorflow.org/\">官方博客</a>\"。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2022/10/google-tensorflow-roadmap/\">Google’s Tensorflow Roadmap Includes Better XLA Compilation and Distributed Computing</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/8OADODV0EZZ72TMrDvTz\">使用&nbsp;TensorFlow.NET 构建神经网络</a>\"</p>",
    "publish_time": "2022-11-18 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]