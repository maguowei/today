[
  {
    "title": "构建重启后依然可用的Windows服务",
    "url": "https://www.infoq.cn/article/sj95UdY5Vqp9Hcxd5XlZ",
    "summary": "<p>当使用C++为Windows编程时，使用Windows服务（Windows Services）几乎是难以避免的。在微软Windows操作系统中，Windows服务发挥着重要的作用，它们能够创建和管理长时间运行的进程，这些进程能够在睡眠、休眠、重启和关机的过程中幸存下来。但是，如果无法做到这一点会怎样呢？在选中<a href=\"https://www.howtogeek.com/243901/the-pros-and-cons-of-windows-10s-fast-startup-mode/\">快速启动（Fast Startup）</a>\"时，关闭计算机会导致服务无法重启，这会给程序带来灾难性的后果。微软在Windows Vista中引入的<a href=\"https://msrc-blog.microsoft.com/2008/10/13/service-isolation-explanation/\">Service Isolation</a>\"可能会导致这类灾难性的后果，在本文中将会阐述如何解决它。</p><p></p><h2>感谢Windows服务</h2><p></p><p></p><p>多年以来，我们一直在使用Windows服务，但是不管我们觉得有多么了解服务，或者有多么自信能够处理它，却始终会遇到更多的问题、挑战和麻烦。其中有些问题根本是没有文档的，或者我们“幸运”一点的话，会有一点糟糕的文档。</p><p></p><p>自从微软引入<a href=\"https://msrc-blog.microsoft.com/2008/10/13/service-isolation-explanation/\">服务隔离</a>\"之后，我们遇到的最令人恼火的问题之一就是当<a href=\"https://www.howtogeek.com/243901/the-pros-and-cons-of-windows-10s-fast-startup-mode/\">快速启动</a>\"选中时，计算机关闭后，无法重启服务。鉴于我们没有找到现成的解决方案，所以我们决定自动动手实现一个，这促成了持久化服务的开发。</p><p></p><p>但是，在深入研究和解释我们的解决方案之前，我们首先从基础知识开始，解释什么是服务，以及为什么要使用Windows服务。</p><p></p><p>NT服务（也叫做Windows服务）指的是由NT内核的服务控制管理器（Service Control Manager）加载的特殊进程，它会在Windows启动（在用户登录前）立即在后台运行。我们使用服务来执行核心和底层的操作系统任务，比如Web服务、事件日志、文件服务、帮助和支持、打印、加密和错误报告。</p><p></p><p>此外，服务使我们能够创建可执行的、长时间运行的应用程序。原因在于服务会在自己的Windows会话环境中运行，所以它不会干扰应用程序的其他组件或会话。显然，我们期望服务会在计算机启动后也自动启动，我们马上就会讨论该问题。</p><p></p><p>进一步来讲，这里显然有一个问题：我们为什么需要持久化的服务？答案很明显，服务应该能够：</p><p></p><p>持续在后台运行。在已登录用户的会话中，调用自身。作为一个看门狗（watchdog），确保给定的应用程序一直在运行。</p><p></p><p>Windows服务需要能够在睡眠、休眠、重启和关机时依然能够存活。但是，正如前文所述，当选中“<a href=\"http://www.howtogeek.com/243901/the-pros-and-cons-of-windows-10s-fast-startup-mode/\">快速启动</a>\"”时，计算机关机再启动的话，会出现一些特定的危险问题。在大多数场景中，服务无法重新启动。</p><p></p><p>因为我们正在开发的是一个反病毒软件，它应该在重启或关机后重新启动，这种情况造成了一个严重的问题，我们迫切需要解决它。</p><p></p><h2>实现良好的服务</h2><p></p><p></p><p>为了创建近乎完美的持久化Windows服务，我们必须首先解决几个底层的问题。</p><p></p><p>其中一个问题与服务隔离有关，被隔离的服务无法访问与任何特定用户相关的上下文。我们某个软件产品将数据存储到了c:\\users\\\\appdata\\local\\中，但是当它从我们的服务中运行的话，这个路径就是无效的，因为服务是在Session 0中运行的。除此之外，在重启后，服务会在所有用户登录之前启动，这形成了解决方案的第一部分：等待用户登录。</p><p></p><p>为了弄清如何做到这一点，我们<a href=\"https://www.codeproject.com/Questions/5061695/Running-a-windows-service-process-on-windows-serve\">在这里</a>\"发布了遇到的问题。</p><p></p><p>事实证明，这是一个没有完美解决方案的问题，但是，本文附带的代码已经得到了应用，并且经过了全面的测试，没有任何的问题。</p><p></p><h2>基础知识</h2><p></p><p></p><p>我们的代码结构和流程可能看起来很复杂，但是这是有一定原因的。在过去的十年间，服务已经与其他进程隔离。从那时开始，Windows服务会在SYSTEM用户账号下运行，而不是其他的用户账号，并且是<a href=\"https://msrc-blog.microsoft.com/2008/10/13/service-isolation-explanation/\">隔离运行的</a>\"。</p><p></p><p>隔离运行的原因在于，服务的功能很强大，可能是潜在的安全风险。正因为如此，微软引入了服务隔离。在这个变化之前，所有的服务会与应用一起在Session 0中运行。</p><p></p><p>但是，在引入了隔离之后（这是在Windows Vista中引入的），情况发生了变化。我们的代码背后的想法是通过调用<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasusera\">CreateProcessAsUserW</a>\"，让Windows服务以某个用户的身份启动自己，这一点将在后文详细阐述。我们的服务叫做SG_RevealerService，它有多个命令，当使用如下的命令行参数调用时，它们会采取相应的行为。</p><p></p><p><code lang=\"cpp\">#define SERVICE_COMMAND_INSTALL L\"Install\"             // The command line argument\n                                                       // for installing the service\n\n#define SERVICE_COMMAND_LAUNCHER L\"ServiceIsLauncher\"  // Launcher command for\n                                                       // NT service\n</code></p><p></p><p>当调用SG_RevealerService时，有三个选项：</p><p></p><p>选项1：不带有任何命令行参数进行调用。在这种情况下什么都不会发生。</p><p></p><p>选项2：带有Install命令行参数进行调用。在这种情况下，服务将自行安装，如果在哈希分隔符（#）添加了有效的可执行路径，服务将会启动，Windows看门狗会保持其一直运行。</p><p></p><p>然后，Service会使用<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasusera\">CreateProcessAsUserW()</a>\"运行自身，新的进程会在用户账号下运行。这给了Service访问上下文的能力，因为Service Isolation，调用实例是无法访问该上下文的。</p><p></p><p>选项3：使用ServiceIsLauncher命令行参数进行调用。服务客户端主应用将会启动。此时，入口函数表明服务已经以当前用户的权限启动了自身。现在，在Task Manager中，我们会看到SG_RevealerService的两个实例，其中一个在SYSTEM用户下，另一个在当前登录用户下。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/windows-services-reliable-restart/en/resources/1figure-1-task-manager-1671630831799.jpg\" /></p><p></p><p><code lang=\"cpp\">/*\nRunHost\n*/\n\nBOOL RunHost(LPWSTR HostExePath,LPWSTR CommandLineArguments)\n{\n    WriteToLog(L\"RunHost '%s'\",HostExePath);\n\n    STARTUPINFO startupInfo = {};\n    startupInfo.cb = sizeof(STARTUPINFO);\n    startupInfo.lpDesktop = (LPTSTR)_T(\"winsta0\\\\default\");\n\n    HANDLE hToken = 0;\n    BOOL bRes = FALSE;\n\n    LPVOID pEnv = NULL;\n    CreateEnvironmentBlock(&amp;pEnv, hToken, TRUE);\n\n    PROCESS_INFORMATION processInfoAgent = {};\n    PROCESS_INFORMATION processInfoHideProcess = {};\n    PROCESS_INFORMATION processInfoHideProcess32 = {};\n\n    if (PathFileExists(HostExePath))\n    {\n        std::wstring commandLine;\n        commandLine.reserve(1024);\n\n        commandLine += L\"\\\"\";\n        commandLine += HostExePath;\n        commandLine += L\"\\\" \\\"\";\n        commandLine += CommandLineArguments;\n        commandLine += L\"\\\"\";\n\n        WriteToLog(L\"launch host with CreateProcessAsUser ...  %s\",\n                     commandLine.c_str());\n\n        bRes = CreateProcessAsUserW(hToken, NULL, &amp;commandLine[0],\n               NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS |\n               CREATE_UNICODE_ENVIRONMENT | CREATE_NEW_CONSOLE |\n               CREATE_DEFAULT_ERROR_MODE, pEnv,\n            NULL, &amp;startupInfo, &amp;processInfoAgent);\n        if (bRes == FALSE)\n        {\n            DWORD   dwLastError = ::GetLastError();\n            TCHAR   lpBuffer[256] = _T(\"?\");\n            if (dwLastError != 0)    // Don't want to see an\n                                     // \"operation done successfully\" error ;-)\n            {\n                ::FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,    // It's a system error\n                    NULL,                                      // No string to be\n                                                               // formatted needed\n                    dwLastError,                               // Hey Windows: Please\n                                                               // explain this error!\n                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Do it in the standard\n                                                               // language\n                    lpBuffer,              // Put the message here\n                    255,                   // Number of bytes to store the message\n                    NULL);\n            }\n            WriteToLog(L\"CreateProcessAsUser failed - Command Line = %s Error : %s\",\n                         commandLine, lpBuffer);\n        }\n        else\n        {\n            if (!writeStringInRegistry(HKEY_LOCAL_MACHINE,\n               (PWCHAR)SERVICE_REG_KEY, (PWCHAR)SERVICE_KEY_NAME, HostExePath))\n            {\n                WriteToLog(L\"Failed to write registry\");\n            }\n        }\n    }\n    else\n    {\n        WriteToLog(L\"RunHost failed because path '%s' does not exists\", HostExePath);\n    }\n    hPrevAppProcess = processInfoAgent.hProcess;\n    \n    CloseHandle(hToken);\n    WriteToLog(L\"Run host end!\");\n\n    return bRes;\n}\n</code></p><p></p><h2>探测用户登录</h2><p></p><p></p><p>第一个挑战是仅在用户登录时，才启动一些动作。为了探测用户的登录，我们首先定义一个全局变量。</p><p></p><p><code lang=\"cpp\">bool g_bLoggedIn = false;\n</code></p><p></p><p>当用户登录时，它的值应该被设置为true 。</p><p></p><h3>订阅登录事件</h3><p></p><p></p><p>我们定义了如下的<a href=\"https://cplusplus.com/doc/tutorial/preprocessor/\">Preprocesor Directives</a>\"：</p><p></p><p><code lang=\"cpp\">#define EVENT_SUBSCRIBE_PATH    L\"Security\"\n#define EVENT_SUBSCRIBE_QUERY    L\"Event/System[EventID=4624]\"\n</code></p><p></p><p>当Service启动后，我们<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/winevt/nf-winevt-evtsubscribe\">订阅登录事件</a>\"，所以当用户登录时，我们会通过设置的回调函数得到一个告警，然后我们就可以继续后面的操作了。为了实现这一点，我们需要一个类来处理订阅的创建并等待事件回调。</p><p></p><p><code lang=\"cpp\">class UserLoginListner\n{\n    HANDLE hWait = NULL;\n    HANDLE hSubscription = NULL;\n\npublic:\n    ~UserLoginListner()\n    {\n        CloseHandle(hWait);\n        EvtClose(hSubscription);\n    }\n\n    UserLoginListner()\n    {\n        const wchar_t* pwsPath = EVENT_SUBSCRIBE_PATH;\n        const wchar_t* pwsQuery = EVENT_SUBSCRIBE_QUERY;\n\n        hWait = CreateEvent(NULL, FALSE, FALSE, NULL);\n\n        hSubscription = EvtSubscribe(NULL, NULL,\n            pwsPath, pwsQuery,\n            NULL,\n            hWait,\n            (EVT_SUBSCRIBE_CALLBACK)UserLoginListner::SubscriptionCallback,\n            EvtSubscribeToFutureEvents);\n        if (hSubscription == NULL)\n        {\n            DWORD status = GetLastError();\n\n            if (ERROR_EVT_CHANNEL_NOT_FOUND == status)\n                WriteToLog(L\"Channel %s was not found.\\n\", pwsPath);\n            else if (ERROR_EVT_INVALID_QUERY == status)\n                WriteToLog(L\"The query \\\"%s\\\" is not valid.\\n\", pwsQuery);\n            else\n                WriteToLog(L\"EvtSubscribe failed with %lu.\\n\", status);\n\n            CloseHandle(hWait);\n        }\n    }\n</code></p><p></p><p>然后，我们需要一个函数实现等待：</p><p></p><p><code lang=\"cpp\">void WaitForUserToLogIn()\n{\n    WriteToLog(L\"Waiting for a user to log in...\");\n    WaitForSingleObject(hWait, INFINITE);\n    WriteToLog(L\"Received a Logon event - a user has logged in\");\n}\n</code></p><p></p><p>我们还需要一个回调函数：</p><p></p><p><code lang=\"cpp\">static DWORD WINAPI SubscriptionCallback(EVT_SUBSCRIBE_NOTIFY_ACTION action, PVOID\n       pContext, EVT_HANDLE hEvent)\n{\n    if (action == EvtSubscribeActionDeliver)\n    {\n        WriteToLog(L\"SubscriptionCallback invoked.\");\n        HANDLE Handle = (HANDLE)(LONG_PTR)pContext;\n        SetEvent(Handle);\n    }\n\n    return ERROR_SUCCESS;\n}\n</code></p><p></p><p>接下来，需要做的就是添加具有如下内容的代码块：</p><p></p><p><code lang=\"cpp\">WriteToLog(L\"Launch client\\n\"); // launch client ...\n{\n    UserLoginListner WaitTillAUserLogins;\n    WaitTillAUserLogins.WaitForUserToLogIn();\n}\n</code></p><p></p><p>到达代码块的底部时，我们就可以确信一个用户已经登录了。</p><p></p><p>在本文后面的内容中，我们将会介绍如何检索登录用户的账号/用户名，以及如何使用GetLoggedInUser()函数。</p><p></p><h2>冒充用户</h2><p></p><p></p><p>当确定一个用户已经登录时，我们需要冒充他们。</p><p></p><p>如下的函数完成了这项工作。它不仅冒充了用户，还调用了<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasuserw\">CreateProcessAsUserW()</a>\"，以该用户的身份运行自己。通过这种方式，我们能够让服务访问用户的上下文，包括文档、桌面等，并允许服务使用用户界面，这对于从Session 0运行服务来讲是无法实现的。</p><p></p><p><a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasuserw\">CreateProcessAsUserW</a>\"创建了一个新的进程及其主线程，它会在给定用户的上下文中运行。</p><p></p><p><code lang=\"cpp\">//Function to run a process as active user from Windows service\nvoid ImpersonateActiveUserAndRun()\n{\n    DWORD session_id = -1;\n    DWORD session_count = 0;\n    WTS_SESSION_INFOW *pSession = NULL;\n\n    if (WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE, 0, 1, &amp;pSession, &amp;session_count))\n    {\n        WriteToLog(L\"WTSEnumerateSessions - success\");\n    }\n    else\n    {\n        WriteToLog(L\"WTSEnumerateSessions - failed. Error %d\",GetLastError());\n        return;\n    }\n    TCHAR szCurModule[MAX_PATH] = { 0 };\n\n    GetModuleFileName(NULL, szCurModule, MAX_PATH);\n\n\n    for (size_t i = 0; i &lt; session_count; i++)\n    {\n        session_id = pSession[i].SessionId;\n        WTS_CONNECTSTATE_CLASS wts_connect_state = WTSDisconnected;\n        WTS_CONNECTSTATE_CLASS* ptr_wts_connect_state = NULL;\n        DWORD bytes_returned = 0;\n        if (::WTSQuerySessionInformation(\n            WTS_CURRENT_SERVER_HANDLE,\n            session_id,\n            WTSConnectState,\n            reinterpret_cast(&amp;ptr_wts_connect_state),\n            &amp;bytes_returned))\n        {\n            wts_connect_state = *ptr_wts_connect_state;\n            ::WTSFreeMemory(ptr_wts_connect_state);\n            if (wts_connect_state != WTSActive) continue;\n        }\n        else\n        {\n            continue;\n        }\n\n        HANDLE hImpersonationToken;\n        if (!WTSQueryUserToken(session_id, &amp;hImpersonationToken))\n        {\n            continue;\n        }\n\n        //Get the actual token from impersonation one\n        DWORD neededSize1 = 0;\n        HANDLE *realToken = new HANDLE;\n        if (GetTokenInformation(hImpersonationToken, (::TOKEN_INFORMATION_CLASS) TokenLinkedToken, realToken, sizeof(HANDLE), &amp;neededSize1))\n        {\n            CloseHandle(hImpersonationToken);\n            hImpersonationToken = *realToken;\n        }\n        else\n        {\n            continue;\n        }\n        HANDLE hUserToken;\n        if (!DuplicateTokenEx(hImpersonationToken,\n            TOKEN_ASSIGN_PRIMARY | TOKEN_ALL_ACCESS | MAXIMUM_ALLOWED,\n            NULL,\n            SecurityImpersonation,\n            TokenPrimary,\n            &amp;hUserToken))\n        {\n            continue;\n        }\n\n\n        // Get user name of this process\n        WCHAR* pUserName;\n        DWORD user_name_len = 0;\n        if (WTSQuerySessionInformationW(WTS_CURRENT_SERVER_HANDLE, session_id, WTSUserName, &amp;pUserName, &amp;user_name_len))\n        {\n            //Now we got the user name stored in pUserName\n        }\n        // Free allocated memory                         \n        if (pUserName) WTSFreeMemory(pUserName);\n        ImpersonateLoggedOnUser(hUserToken);\n        STARTUPINFOW StartupInfo;\n        GetStartupInfoW(&amp;StartupInfo);\n        StartupInfo.cb = sizeof(STARTUPINFOW);\n        PROCESS_INFORMATION processInfo;\n        SECURITY_ATTRIBUTES Security1;\n        Security1.nLength = sizeof SECURITY_ATTRIBUTES;\n        SECURITY_ATTRIBUTES Security2;\n        Security2.nLength = sizeof SECURITY_ATTRIBUTES;\n        void* lpEnvironment = NULL;\n\n        // Obtain all needed necessary environment variables of the logged in user.\n        // They will then be passed to the new process we create.\n\n        BOOL resultEnv = CreateEnvironmentBlock(&amp;lpEnvironment, hUserToken, FALSE);\n        if (!resultEnv)\n        {\n            WriteToLog(L\"CreateEnvironmentBlock - failed. Error %d\",GetLastError());\n            continue;\n        }\n        std::wstring commandLine;\n        commandLine.reserve(1024);\n        commandLine += L\"\\\"\";\n        commandLine += szCurModule;\n        commandLine += L\"\\\" \\\"\";\n        commandLine += SERVICE_COMMAND_Launcher;\n        commandLine += L\"\\\"\";\n        WCHAR PP[1024]; //path and parameters\n        ZeroMemory(PP, 1024 * sizeof WCHAR);\n        wcscpy_s(PP, commandLine.c_str());\n\n        // Next we impersonate - by starting the process as if the current logged in user, has started it\n        BOOL result = CreateProcessAsUserW(hUserToken,\n            NULL,\n            PP,\n            NULL,\n            NULL,\n            FALSE,\n            NORMAL_PRIORITY_CLASS | CREATE_NEW_CONSOLE,\n            NULL,\n            NULL,\n            &amp;StartupInfo,\n            &amp;processInfo);\n\n        if (!result)\n        {\n            WriteToLog(L\"CreateProcessAsUser - failed. Error %d\",GetLastError());\n        }\n        else\n        {\n            WriteToLog(L\"CreateProcessAsUser - success\");\n        }\n        DestroyEnvironmentBlock(lpEnvironment);\n        CloseHandle(hImpersonationToken);\n        CloseHandle(hUserToken);\n        CloseHandle(realToken);\n        RevertToSelf();\n    }\n    WTSFreeMemory(pSession);\n}\n</code></p><p></p><h2>寻找已登录的用户</h2><p></p><p></p><p>为了寻找已登录用户的账号名，我们会使用如下的函数：</p><p></p><p><code lang=\"cpp\">std::wstring GetLoggedInUser()\n{\n    std::wstring user{L\"\"};\n    WTS_SESSION_INFO *SessionInfo;\n    unsigned long SessionCount;\n    unsigned long ActiveSessionId = -1;\n\n    if(WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE,\n                            0, 1, &amp;SessionInfo, &amp;SessionCount))\n    {\n        for (size_t i = 0; i &lt; SessionCount; i++)\n        {\n            if (SessionInfo[i].State == WTSActive ||\n                SessionInfo[i].State == WTSConnected)\n            {\n                ActiveSessionId = SessionInfo[i].SessionId;\n                break;\n            }\n        }\n\n        wchar_t *UserName;\n        if (ActiveSessionId != -1)\n        {\n            unsigned long BytesReturned;\n            if (WTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE,\n                ActiveSessionId, WTSUserName, &amp;UserName, &amp;BytesReturned))\n            {\n                user = UserName;        // Now we have the logged in user name\n                WTSFreeMemory(UserName);    \n            }\n        }\n        WTSFreeMemory(SessionInfo);\n    }\n    return user;\n}\n</code></p><p></p><p>在服务启动后不久，我们就要使用该函数。只要没有用户登录，这个函数就会返回一个空字符串，如果这样的话，我们就知道应该继续等待。</p><p></p><h2>看门狗是Service的好朋友</h2><p></p><p></p><p>Service与看门狗机制协同使用是很理想的方案。</p><p></p><p>这种机制将确保一个给定应用始终处于运行状态，如果它异常关闭的话，看门狗会重新启动它。我们要始终记住，如果用户通过Quit退出的话，我们不希望重启进程。但是，如果进程是通过Task Manager或其他方式被停掉的，我们会希望重启它。一个很好的例子是反病毒程序。我们想要确保恶意软件不能终止本应检测它的反病毒程序。</p><p></p><p>为了实现这一点，我们需要该Service为使用它的程序提供某种API，当该程序的用户选择“Quit”，程序会告知Service，程序的工作已经完成了，Service可以卸载自己了。</p><p></p><h2>一些构建基块</h2><p></p><p></p><p>接下来，我们介绍一些构建基块，要理解本文的代码，它们是必备的。</p><p></p><h3>GetExePath</h3><p></p><p></p><p>为了获取我们的Service或其他可执行文件的路径，如下的函数是非常便利的。</p><p></p><p><code lang=\"cpp\">/**\n * GetExePath() - returns the full path of the current executable.\n *\n * @param values - none.\n * @return a std::wstring containing the full path of the current executable.\n */\nstd::wstring GetExePath()\n{\n    wchar_t buffer[65536];\n    GetModuleFileName(NULL, buffer, sizeof(buffer) / sizeof(*buffer));\n    int pos = -1;\n    int index = 0;\n    while (buffer[index])\n    {\n        if (buffer[index] == L'\\\\' || buffer[index] == L'/')\n        {\n            pos = index;\n        }\n        index++;\n    }\n    buffer[pos + 1] = 0;\n    return buffer;\n}\n</code></p><p></p><h3>WriteLogFile</h3><p></p><p></p><p>当开发Windows Service时（以及其他任何软件），拥有一个日志机制都是很重要的。我们有一个非常复杂的日志机制，但是就本文而言，我添加了一个最小的日志函数，名为WriteToLog。它的运行机制类似于printf ，但是所有发送给它的内容不仅会被格式化，还会存储在一个日志文件中，以备日后检查。这个日志文件的大小会不断增长，因为会有新的日志条目追加到上面。</p><p></p><p>日志文件的路径，通常会位于Service的EXE的路径，但是，由于Service Isolation，在重启计算机后的一小段时间内，这个路径会<a href=\"https://serverfault.com/questions/114238/windows-service-can-i-configure-the-current-working-directory\">变成</a>\" <a href=\"https://serverfault.com/questions/114238/windows-service-can-i-configure-the-current-working-directory\">c:\\Windows\\System32</a>\"，我们并不希望如此。所以，我们的日志函数会检查exe的路径，并且不会假设<a href=\"https://learn.microsoft.com/en-us/windows/win32/fileio/changing-the-current-directory\">Current Directory</a>\"在Service的生命周期内会保持不变。</p><p></p><p><code lang=\"cpp\">/**\n * WriteToLog() - writes formatted text into a log file, and on screen (console)\n *\n * @param values - formatted text, such as L\"The result is %d\",result.\n * @return - none\n */\nvoid WriteToLog(LPCTSTR lpText, ...)\n{\n    FILE *fp;\n    wchar_t log_file[MAX_PATH]{L\"\"};\n    if(wcscmp(log_file,L\"\") == NULL)\n    {\n        wcscpy(log_file,GetExePath().c_str());\n        wcscat(log_file,L\"log.txt\");\n    }\n    // find gmt time, and store in buf_time\n    time_t rawtime;\n    struct tm* ptm;\n    wchar_t buf_time[DATETIME_BUFFER_SIZE];\n    time(&amp;rawtime);\n    ptm = gmtime(&amp;rawtime);\n    wcsftime(buf_time, sizeof(buf_time) / sizeof(*buf_time), L\"%d.%m.%Y %H:%M\", ptm);\n\n    // store passed messsage (lpText) to buffer_in\n    wchar_t buffer_in[BUFFER_SIZE];\n\n    va_list ptr;\n    va_start(ptr, lpText);\n\n    vswprintf(buffer_in, BUFFER_SIZE, lpText, ptr);\n    va_end(ptr);\n\n    // store output message to buffer_out - enabled multiple parameters in swprintf\n    wchar_t buffer_out[BUFFER_SIZE];\n\n    swprintf(buffer_out, BUFFER_SIZE, L\"%s %s\\n\", buf_time, buffer_in);\n\n    _wfopen_s(&amp;fp, log_file, L\"a,ccs=UTF-8\");\n    if (fp)\n    {\n        fwprintf(fp, L\"%s\\n\", buffer_out);\n        fclose(fp);\n    }\n    wcscat(buffer_out,L\"\\n\");HANDLE stdOut = GetStdHandle(STD_OUTPUT_HANDLE);\n    if (stdOut != NULL &amp;&amp; stdOut != INVALID_HANDLE_VALUE)\n    {\n        DWORD written = 0;\n        WriteConsole(stdOut, buffer_out, wcslen(buffer_out), &amp;written, NULL);\n    }\n}\n</code></p><p></p><h2>更多的构建基块：注册表相关的内容</h2><p></p><p></p><p>下面是一些我们用来存储看门狗可执行文件路径的函数，所以当计算机重启后，Service重新启动时，就能使用该路径。</p><p></p><p><code lang=\"cpp\">BOOL CreateRegistryKey(HKEY hKeyParent, PWCHAR subkey)\n{\n    DWORD dwDisposition; //Verify new key is created or open existing key\n    HKEY  hKey;\n    DWORD Ret;\n    Ret =\n        RegCreateKeyEx(\n            hKeyParent,\n            subkey,\n            0,\n            NULL,\n            REG_OPTION_NON_VOLATILE,\n            KEY_ALL_ACCESS,\n            NULL,\n            &amp;hKey,\n            &amp;dwDisposition);\n    if (Ret != ERROR_SUCCESS)\n    {\n        WriteToLog(L\"Error opening or creating new key\\n\");\n        return FALSE;\n    }\n    RegCloseKey(hKey); //close the key\n    return TRUE;\n}\n\nBOOL writeStringInRegistry(HKEY hKeyParent, PWCHAR subkey,\n                           PWCHAR valueName, PWCHAR strData)\n{\n    DWORD Ret;\n    HKEY hKey;\n    //Check if the registry exists\n    Ret = RegOpenKeyEx(\n        hKeyParent,\n        subkey,\n        0,\n        KEY_WRITE,\n        &amp;hKey\n    );\n    if (Ret == ERROR_SUCCESS)\n    {\n        if (ERROR_SUCCESS !=\n            RegSetValueEx(\n                hKey,\n                valueName,\n                0,\n                REG_SZ,\n                (LPBYTE)(strData),\n                ((((DWORD)lstrlen(strData) + 1)) * 2)))\n        {\n            RegCloseKey(hKey);\n            return FALSE;\n        }\n        RegCloseKey(hKey);\n        return TRUE;\n    }\n    return FALSE;\n}\n\nLONG GetStringRegKey(HKEY hKey, const std::wstring &amp;strValueName,\n                     std::wstring &amp;strValue, const std::wstring &amp;strDefaultValue)\n{\n    strValue = strDefaultValue;\n    TCHAR szBuffer[MAX_PATH];\n    DWORD dwBufferSize = sizeof(szBuffer);\n    ULONG nError;\n    nError = RegQueryValueEx(hKey, strValueName.c_str(), 0, NULL,\n             (LPBYTE)szBuffer, &amp;dwBufferSize);\n    if (nError == ERROR_SUCCESS)\n    {\n        strValue = szBuffer;\n        if (strValue.front() == _T('\"') &amp;&amp; strValue.back() == _T('\"'))\n        {\n            strValue.erase(0, 1); // erase the first character\n            strValue.erase(strValue.size() - 1); // erase the last character\n        }\n    }\n    return nError;\n}\n\nBOOL readStringFromRegistry(HKEY hKeyParent, PWCHAR subkey,\n                            PWCHAR valueName, std::wstring&amp; readData)\n{\n    HKEY hKey;\n    DWORD len = 1024;\n    DWORD readDataLen = len;\n    PWCHAR readBuffer = (PWCHAR)malloc(sizeof(PWCHAR) * len);\n    if (readBuffer == NULL)\n        return FALSE;\n    //Check if the registry exists\n    DWORD Ret = RegOpenKeyEx(\n        hKeyParent,\n        subkey,\n        0,\n        KEY_READ,\n        &amp;hKey\n    );\n    if (Ret == ERROR_SUCCESS)\n    {\n        Ret = RegQueryValueEx(\n            hKey,\n            valueName,\n            NULL,\n            NULL,\n            (BYTE*)readBuffer,\n            &amp;readDataLen\n        );\n        while (Ret == ERROR_MORE_DATA)\n        {\n            // Get a buffer that is big enough.\n            len += 1024;\n            readBuffer = (PWCHAR)realloc(readBuffer, len);\n            readDataLen = len;\n            Ret = RegQueryValueEx(\n                hKey,\n                valueName,\n                NULL,\n                NULL,\n                (BYTE*)readBuffer,\n                &amp;readDataLen\n            );\n        }\n        if (Ret != ERROR_SUCCESS)\n        {\n            RegCloseKey(hKey);\n            return false;;\n        }\n        readData = readBuffer;\n        RegCloseKey(hKey);\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n</code></p><p></p><h2>检查宿主（Host）是否在运行</h2><p></p><p></p><p>本文中的程序有一项核心能力，那就是保护我们的SampleApp（我们将其称为宿主），当它未运行时，就重新启动它（所以叫做看门狗）。在真实场景中，我们会检查宿主是被用户终止的（这是允许的），还是被恶意软件终止的（这是不允许的），在后一种情况下，我们将会重启它（否则，如果用户选择Quit，但应用程序将继续“骚扰”系统并反复执行）。</p><p></p><p>如下是它如何实现的：</p><p></p><p>我们创建了一个Timer事件，每隔一定的时间（不应该过于频繁），我们会检查宿主的进程是否在运行，如果没有的话，我们就启动它。我们使用了一个静态布尔型标记（is_running），用来表明我们已经处于该代码块中了，所以在处理过程中时，能够避免再次调用。这是在WM_TIMER代码块中始终要做的事情，因为当定时器设置的频率过高的话，代码块在调用时，前一个WM_TIMER事件的代码依然在执行。</p><p></p><p>我们还通过检查g_bLoggedIn布尔标记来判断是否有用户登录。</p><p></p><p><code lang=\"cpp\">  case WM_TIMER:\n        {\n            if (is_running) break;\n            WriteToLog(L\"Timer event\");\n            is_running = true;\n            HANDLE hProcessSnap;\n            PROCESSENTRY32 pe32;\n            bool found{ false };\n\n            WriteToLog(L\"Enumerating all processess...\");\n            // Take a snapshot of all processes in the system.\n            hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n            if (hProcessSnap == INVALID_HANDLE_VALUE)\n            {\n                WriteToLog(L\"Failed to call CreateToolhelp32Snapshot(). Error code %d\",GetLastError());\n                is_running = false;\n                return 1;\n            }\n\n            // Set the size of the structure before using it.\n            pe32.dwSize = sizeof(PROCESSENTRY32);\n\n            // Retrieve information about the first process,\n            // and exit if unsuccessful\n            if (!Process32First(hProcessSnap, &amp;pe32))\n            {\n                WriteToLog(L\"Failed to call Process32First(). Error code %d\",GetLastError());\n                CloseHandle(hProcessSnap);          // clean the snapshot object\n                is_running=false;\n                break;\n            }\n\n            // Now walk the snapshot of processes, and\n            // display information about each process in turn\n            DWORD svchost_parent_pid = 0;\n            DWORD dllhost_parent_pid = 0;\n            std::wstring szPath = L\"\";\n\n            if (readStringFromRegistry(HKEY_LOCAL_MACHINE, (PWCHAR)SERVICE_REG_KEY, (PWCHAR)SERVICE_KEY_NAME, szPath))\n            {\n                m_szExeToFind = szPath.substr(szPath.find_last_of(L\"/\\\\\") + 1);    // The process name is the executable name only\n                m_szExeToRun = szPath;                                            // The executable to run is the full path\n            }\n            else\n            {\n                WriteToLog(L\"Error reading ExeToFind from the Registry\");\n            }\n\n            do\n            {\n                if (wcsstr( m_szExeToFind.c_str(), pe32.szExeFile))\n                {\n                    WriteToLog(L\"%s is running\",m_szExeToFind.c_str());\n                    found = true;\n                    is_running=false;\n                    break;\n                }\n                if (!g_bLoggedIn)\n                {\n                    WriteToLog(L\"WatchDog isn't starting '%s' because user isn't logged in\",m_szExeToFind.c_str());\n                    return 1;\n                }\n            }\n            while (Process32Next(hProcessSnap, &amp;pe32));\n            if (!found)\n            {\n                WriteToLog(L\"'%s' is not running. Need to start it\",m_szExeToFind.c_str());\n                if (!m_szExeToRun.empty())    // watchdog start the host app\n                {\n                    if (!g_bLoggedIn)\n                    {\n                        WriteToLog(L\"WatchDog isn't starting '%s' because user isn't logged in\",m_szExeToFind.c_str());\n                        return 1;\n                    }\n                    ImpersonateActiveUserAndRun();\n\n                    RunHost((LPWSTR)m_szExeToRun.c_str(), (LPWSTR)L\"\");\n\n                }\n                else\n                {\n                    WriteToLog(L\"m_szExeToRun is empty\");\n                }\n            }\n            CloseHandle(hProcessSnap);\n        }\n        is_running=false;\n        break;\n</code></p><p></p><h2>如何测试Service</h2><p></p><p></p><p>当我们想要测试这个解决方案时，我们雇佣了20个资深的和协作的测试人员。在整个工作过程中，越来多的测试均成功了。在某些时候，它在我们自己的Surface Pro笔记本电脑上运行地非常完美，但是，我们的一位员工报告说，在他的计算机上，在关闭之后，服务没有再次启动，或者在<a href=\"https://en.wikipedia.org/wiki/Protection_ring\">Ring 3</a>\"下没有启动自身。这是一个好消息，因为在开发过程中，当你怀疑某个地方存在缺陷的时候，最糟糕的事情就是无法找到它，也无法重现它。总而言之，10%的测试者报告了问题。因此，这里发布的版本在我们员工的电脑上运行完美，然而2%的测试者仍然不时报告问题。换句话说，SampleApp在关闭计算机并打开后无法启动。</p><p></p><p>如下是对测试服务和看门狗的说明。</p><p></p><h3>SampleApp</h3><p></p><p></p><p>我们包含了一个由Visual Studio Wizard生成的样例应用，作为“宿主”应用，它会被看门狗确保一直运行。你可以单独运行它，外观如下面的图片所示。该应用没有做太多的事情。实际上，它一无是处……</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/windows-services-reliable-restart/en/resources/1figure-2-sample-app-1671630831799.jpg\" /></p><p></p><p>在后面的内容中，我们将提供测试服务和看门狗的指南。你可以在<a href=\"https://github.com/securedglobe/PersistantService\">GitHub</a>\"下载源码。</p><p></p><h3>从CMD中运行</h3><p></p><p>以管理员身份打开CMD。将当前目录变更至Service的EXE所在的路径并输入：</p><p></p><p>SG_RevealerService.exe Install#SampleApp.exe</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/windows-services-reliable-restart/en/resources/1figure-3-command-prompt-1671630831799.jpg\" /></p><p></p><p>你可以看到，我们有两个元素：</p><p></p><p>command元素，这里是Installargument元素，通过哈希分隔符(#)连接至命令元素，应该是我们希望看门狗观察的可执行文件。</p><p></p><p>Service首先会启动SampleApp，从此之后，如果你尝试终止或杀死SampleApp的话，看门狗会在几秒钟后重启它。如果重启，关掉计算机并再次启动，你会发现Service会再次出现并启动SampleApp。这就是我们的Service的目标和功能。</p><p></p><h3>卸载</h3><p></p><p></p><p>最后，如果要停止和卸载服务，我们包含了一个uninstall.bat脚本，它如下所示：</p><p></p><p><code lang=\"cpp\">sc stop sg_revealerservice\nsc delete sg_revealerservice\ntaskkill /f /im sampleapp.exe\ntaskkill /f /im sg_revealerservice.exe\n</code></p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/windows-services-reliable-restart/en/resources/1figure-4-delete-service-1671630831799.jpg\" /></p><p></p><h3>结论</h3><p></p><p></p><p>Windows Service在微软Windows操作系统中起着关键作用，它支持创建和管理长期运行的进程。在有些场景下，如果勾选了“快速启动”，在正常关闭并重启计算机后，服务往往无法重启。本文的目的是创建一个持久化的服务，在Windows重新启动或关机后，能够始终运行并重新启动。其中一个主要的问题与Service Isolation有关。隔离本身（在Windows Vista版本中引入）是很重要和强大的，然而，当我们需要与用户空间交互时，这会产生一些限制。当服务重新启动时，我们希望它能与用户空间进行交互，然而它不能发生地太早（在任何用户登录之前）。不过，你可以通过订阅登录事件来解决这个问题。Service与看门狗机制协同使用是很理想的方案。这种机制能够确保给定的应用一直在运行，并且在异常关闭时，它将重新启动。我们在前面描述的方法的基础上，成功地开发了这个机制，这使得它可以一直运行，在用户登录时得到提醒，并且能够与用户空间进行交互。定时器事件能够用来监控被观察进程的运行。在开发过程中，好的日志机制始终是非常有用的，我们可以使用简单的日志工具，并在需要的时候，使用更为复杂的工具。最终的解决方案必须要进行测试。代码被确认并验证可以运行后，多达2%的测试人员依然可能会报告错误，这是有一定原因的。</p><p></p><p>作者简介：</p><p>Michael Haephrati是Secured Globe, Inc.的联合创始人和首席执行官，该公司于2008年与他的妻子Ruth Haephrati一起创建。Michael是一位音乐作曲家、发明家，也是一位专门从事软件开发和信息安全的专家。凭借30多年的经验，Michael形成了独特的视角，将技术和创新结合起来，并强调终端用户的体验。多年来，Michael领导了各种客户的创新项目和技术。他是“Learning C++”（https://www.manning.com/books/learning-c-plus-plus）的作者，该书由Manning Publications出版。</p><p></p><p>Ruth Haephrati是Secured Globe, Inc.的联合创始人和首席执行官，该公司于2008年与她的丈夫Michael Haephrati一起创建。Ruth是一位作家、演讲者、企业家、网络安全和网络取证专家。在过去的25年里，Ruth与微软和IBM等领先公司合作，担任顾问和C++实践专家。她最近参与了为一个国际客户开发的最先进的反恶意软件技术。在业余时间，Ruth是一位插画家、画家、野生动物摄影师和世界旅行者。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/windows-services-reliable-restart/\">The Service and the Beast: Building a Windows Service that Does Not Fail to Restart</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/3IX18md3WG2kjiM43Kgv\">Windows 11发布重大更新：ChatGPT版Bing集成到任务栏中，可快速访问AI聊天功能</a>\"</p><p><a href=\"https://www.infoq.cn/article/97LDs46oamxHYLAhp5uK\">Kubernetes 1.26 版本正式发布：改进 Windows 支持，加强网络安全和管理功能</a>\"</p>",
    "publish_time": "2023-03-09 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "在Java中我们该如何应对阻塞调用",
    "url": "https://www.infoq.cn/article/Tda86qL5beKOIkIRoYBU",
    "summary": "<p></p><blockquote>本文最初发表于<a href=\"https://www.javaadvent.com/2022/12/a-tale-of-two-cities-how-blocking-calls-are-treated.html\">Java Advent网站</a>\"，经原作者<a href=\"https://foojay.io/today/author/bazlur-rahman/\">A N M Bazlur Rahman</a>\"授权，由InfoQ中文站翻译分享。</blockquote><p></p><p></p><p>Java已经有20多年的历史了，它一直是软件开发领域的主导力量，这种情况应该还会继续下去。然而，它之所以表现如此优异，是有多种原因的，其中之一就是并发。Java通过引入一个内置的线程模型开始了它的并发旅程。</p><p></p><p>在本文中，我将会讨论关于线程模型的一些历史知识，阐述它们是如何帮助我们形成使用Java进行编程时的理解和实践的，以及我们目前处于何处和它的一个特殊问题。</p><p></p><p>这篇文章会有点长，但是我相信你会喜欢它的。</p><p></p><p>让我们开始这段旅程吧！</p><p></p><h2>Java是由线程组成的</h2><p></p><p></p><p>从诞生之初，Java就引入了线程。线程是Java中的基本执行单元。这意味着我们要运行的所有Java代码都需要由线程来执行。线程是Java平台上执行环境的独立单元。</p><p></p><p>由此我们可以看出，如果一个程序有更多的线程，那它就有更多可以执行代码的地方。这意味着可以同时做更多的事情，从而给我们带来很多收益。一个特别的收益就是，通过利用机器上所有可用的资源，这能够提高应用的吞吐量。借助这种方式，我们能够从程序中获得更多的效益。</p><p></p><p>线程广泛存在于Java平台的各个层面中。</p><p></p><p>线程不仅能够执行代码，它还会在其栈中跟踪方法的调用。所以，如果Java程序在执行过程中遇到问题的话，我们会抛出异常。异常中会包含栈跟踪信息，基于此我们可以判断出错误的原因。由此，我们可以说线程是获取栈跟踪信息的一种方式。</p><p></p><p>此处，如果需要通过IDE调试程序的话，我们也会用到线程。如果需要对程序或程序的一部分进行剖析（profile）的话，我们也会用到线程。Java垃圾收集器会运行在一个单独的线程中。所有的这一切都证明，并发或者”线程“是编程平台的一个重要组成部分。</p><p></p><p></p><h2>但是，线程是昂贵的</h2><p></p><p></p><p>在现代Java web应用中，吞吐量是通过使用并发连接实现的。通常情况下，客户端的每个请求都会有一个专门的线程。现代操作系统可以处理上百万的并发连接。这表明，如果我们有更多的并发连接，就能实现更高的吞吐量。</p><p></p><p>这个结论似乎是合理的，但现实情况远非如此。原因在于，我们无法创建尽可能多的线程来实现这一点。</p><p></p><p>线程是数量有限的昂贵资源。创建一个线程需要在堆外占用2 MiB的内存。需要记住的另外一件事情是，按照传统的做法，Java线程仅仅对操作系统线程做个一层很薄的封装。我们只能创建数量有限的线程。即便我们有了大量的线程，也无法始终保证应用整体的性能。上下文的内容切换会有相关的成本。</p><p></p><p>你可以通过运行如下的样例看一下能够创建多少个线程。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/3f/3f7025ce4fb501729f27baf39a8be3f8.png\" /></p><p></p><p>到目前为止，我们已经讨论了Java线程的重要性以及它们的一些限制。那么，我们再进一步深入讨论一下。</p><p></p><p></p><h2>我们现在遇到了什么问题</h2><p></p><p></p><p>现代软件应用开发需要处理大量的数据，而且应用的使用率也会很高。这就带来了相关的成本问题。如果我们不留意的话，云计算的成本会迅速累积。</p><p></p><p>我们已经确认，创建线程的成本并不低，而且它们的数量是有限制的，所以我们不能浪费任何线程，而是要充分利用它们的能力。但实际上，情况并非如此。在传统的编程模型中，当我们调用一些需要时间才能获取响应的逻辑时，它会阻塞当前线程。例如，如果我们进行一个网络调用（可能是微服务或数据库调用）的话，用来进行调用的线程会被阻塞，直到得到结果为止。在等待结果的过程中，线程什么事情都不会做，基本上就是处于空闲状态，浪费了宝贵的资源，从而导致云账单的无谓增长。</p><p></p><p>因此，基于上述假设，可以得出结论，阻塞调用对我们并不是什么好事儿。</p><p></p><p>我们可以看一个样例。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/99/990dcc77434fc94fabe1a5d6a1708087.png\" /></p><p></p><p>在上述的代码中，我们进行了五个方法的调用。假设所有的方法均需要一些时间来进行处理。为了简单起见，我们假设它们都需要200毫秒的时间来处理。</p><p></p><p>由于我们是一个接一个地进行所有的调用，这将需要至少200*5=1000毫秒来完成该方法。因此，开始所有这些调用的线程必须等待它们全部完成。</p><p></p><p>在这个场景中，我们可以看到，调用calculateCreditForPerson()方法的线程在大部分时间内都是阻塞的，因为它在等待后续方法的完成。当阻塞的时候，它没有做任何事情。基本上来讲，它的资源因为不能做任何事情而被浪费了。</p><p></p><p>问题是，我们该如何才能改善它呢？</p><p></p><p>目前，业界已经有很多方案尝试来改善这种情况，使线程在这种情况下不会被阻塞。我将从Java历史的最开始说起。</p><p></p><p></p><h2>经典的实现方式</h2><p></p><p></p><p>上述样例中，在方法内部的各个方法调用并不都是互相依赖的。所以，第二个、第三个和第四个调用可以并行进行。如果这三个方法并行执行的话，我们就可以做一些改进。这样，调用者线程将花费更少的时间，这意味着更少的阻塞时间。这将是一个巨大的改进。在这里，我们没有解决阻塞的问题，但是负责调用该方法的主线程处于阻塞状态的时间会大幅减少。它将有更多的时间去做其他的事情。</p><p></p><p>那么，我们该如何实现这一经典的方式呢？</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/27/2773717c71082b3dcdcd3511c5028767.png\" /></p><p></p><p>最终的代码将类似于如上所示。我们将临时创建一个新的线程，并将结果存储在一个AtomicReference中。</p><p></p><p>这种方式很不错，但是我们无法控制要创建多少个线程。如果持续地创建临时线程，我们最终可能会创建过多的线程，这对应用是有害的。此外，如果试图创建过多线程的话，应用可能会抛出java.lang.OutOfMemoryError异常。</p><p></p><p>所以，我们需要进一步地改进。</p><p></p><p></p><h2>Executor框架</h2><p></p><p></p><p>Java 5引入了Executor框架，以及Future和Callable/Runnable。它允许我们控制要创建多少个线程，并对它们进行池化管理。</p><p></p><p>基于此，我们可以按照如下方式改善上述代码：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/09/090c76126aca39d1d9540aa6f526d24e.png\" /></p><p></p><p>对于代码编写来讲，这是一个相当大的改进，但是我们尚未达到目的。Future的机制依然非常复杂。对它的get()调用依然是一个阻塞式的调用。尽管我们进行的是异步调用，但最终还是需要一个阻塞式调用以便于从Future中获取值。</p><p></p><p>另外一个问题在于，它有可能会导致缓存受损（cache corruption，作者在这里指的应该是需要跨CPU内核存取数据，从而导致CPU级别的缓存失效——译者注）。例如，如果主线程向线程池提交任务的话，该任务将会由池中的某个线程来执行。主线程需要数据，但是这些数据却在另外一个线程中。这两个线程可能会位于不同的内核上，从而导致缓存受损。除此之外，在不同核心的上下文之间进行切换也是代价高昂的操作。</p><p></p><p>它还需要使用组合操作。所以，代码更多是命令式的。命令式的代码本身没有什么问题，不过函数式和声明式代码也很有意思。所以，至少我们在这里还可以进行一些改进。</p><p></p><p></p><h2>Fork/Join池</h2><p></p><p></p><p>Java引入了Fork/Join池，它是Java 5所引入的ExecutorService的实现，也是Executor框架的实现。它解决了我们在旧的Executor框架中遇到的很多问题，如缓存受损的问题。除此之外，它的运行理念是，刚刚创建的一批任务很可能会需要更紧密的缓存。这意味着，新创建的任务应该在同一个CPU上运行，而旧的任务可能需要在另外一个CPU上运行。与其他线程池实现相比，Fork/Join池中的每个线程都有自己的队列。此外，Fork/Join 池的实现采用了工作窃取（work-stealing）算法。如果池中的某个线程完成了自己的任务，它可以从另外一个线程的队尾窃取任务。所有的这些都能帮助我们实现更好的性能。</p><p></p><p></p><h2>将这一切组合在一起</h2><p></p><p></p><p>Java 8基于Fork/Join池引入了CompletableFuture。它包含了我们非常喜欢的组合特性。有了它，我们可以将上述代码改写成如下所示的样子：</p><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/10/10abf64040999afbc6fedc1904009df1.png\" /></p><p></p><p></p><h2>反应式Java</h2><p></p><p></p><p>非常不错，我们已经得到了自己想要的一切，也就是通过可组合性实现性能的提升。但是，市场上还有其他的替代方案。像RxJava、Akka、Eclipse Vert.x、Spring WebFlux、Slick这样的反应式框架，也能够为我们带来性能和可组合性的收益。我们来看看WebFlux的样例。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/cf/cf4537824efcb5dd2d9de1d62f1f03af.png\" /></p><p></p><p>但是，这种方式也有一些弊端，比如：</p><p></p><p>这种框架的学习曲线比较陡峭。有些模式对初学者来说可能会很难理解。与之相关的认知体验要求很高，这会损害代码的阅读体验。出现任何问题都很难调试。因为我们不知道特定的代码会在哪个线程上运行，完成任务的路径可能是各种各样的。这就是为何即便有线程转储文件也没有太大的用处的原因。</p><p></p><p>那么，解决方案是什么呢？</p><p></p><p>如果我们能够同时使用最初的命令式代码，又能实现简单的异步功能，那就太完美了。这就是Loom项目的用武之地了。</p><p></p><p></p><h2>Loom项目</h2><p></p><p></p><p>Loom项目允许我们临时创建任意数量的线程，而不必承担前文所述的各种负担。我们甚至不用关心到底要创建多少个线程，事实上，我们可以创建上百万个线程，而且它们的成本很低廉。</p><p></p><p>此处之外，我们还可以继续使用命令式和阻塞代码。所以，根本不用担心阻塞式的代码。</p><p></p><p>Java 19引入了虚拟线程，有了它之后，我们可以拥有任意数量的阻塞代码。</p><p></p><p>如果想要使用虚拟线程的话，我们可以使用如下的Executor：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/35/359ca3fc7ae53cde97d1f3076b551c05.png\" /></p><p></p><p>我们之前为Executor编写的代码不需要做任何改变，只需要传入newVirtualThreadPerTaskExecutor Executor服务即可。</p><p></p><p>虚拟线程会在原始线程之上运行，这些原始线程被称为平台线程。平台线程基本上也就是Fork/Join池中的线程。因此，通过运行虚拟线程，我们可以获得Fork/Join池带来的所有好处。</p><p></p><p>简而言之，虚拟线程的做法是，当它们看到阻塞调用时，就会让出它所占用的平台线程。然后，平台线程就能继续执行其他的虚拟线程。阻塞调用通常会在我们调用睡眠或网络操作时发生，当这些操作完成时，虚拟线程可以重新在平台线程中恢复，以完成其余的任务。</p><p></p><p>通过这种方式，我们没有因为空闲浪费任何的线程时间，它们一直处于繁忙状态。另一方面，虚拟线程是一个Java结构，它可以暂停，并在随后恢复，而不会消耗额外的CPU。</p><p></p><p>这使我们的编程变得非常简单。</p><p></p><p></p><h2>结论</h2><p></p><p></p><p>综上所述，对我们来讲，阻塞调用长期以来都是一个敌人。为了解决它，我们发明了很多方案。最后，基于所有的发明，我们提出了一个新的范式，那就是虚拟线程，有了它，我们不再需要把阻塞调用当作敌人了。</p><p></p><p>基于此，我们可以放心地调用任何阻塞操作，想调用多少就调用多少。</p><p></p><p>这就是我们对待阻塞操作和线程的历史。业界有很多连接二者的方式，都能使我们的开发工作更加轻松。</p><p></p><p>原文链接：</p><p><a href=\"https://www.javaadvent.com/2022/12/a-tale-of-two-cities-how-blocking-calls-are-treated.html\">https://www.javaadvent.com/2022/12/a-tale-of-two-cities-how-blocking-calls-are-treated.html</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/txS9hHTfxasv2uHBATgL\">Java近期新闻：Gradle 8.0、Maven、Payara平台、Piranha、Spring Framework、MyFaces和Piranha</a>\"</p><p><a href=\"https://www.infoq.cn/article/sLiRwa72fHzWvzC2HmKf\">深入OpenTelemetry源代码：Java探针的实现和二次开发</a>\"</p><p><a href=\"https://www.infoq.cn/article/YaBqqD7fd6kX97GbhkGm\">虚拟线程：大规模Java应用的新基石</a>\"</p>",
    "publish_time": "2023-03-09 08:51:49",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "企业全球化出海技术体系建设实录【专题合集】",
    "url": "https://www.infoq.cn/article/7326f30ef47ccf76f3ebaa100",
    "summary": "<p>近日，阿里Q3财报发布，国际零售收入增长26%。</p><p></p><p>不仅阿里的海外电商业务增长迅速，越来越多的中国企业也开始走向海外。但是在国际政经环境复杂变幻的形势之下，企业出海既要应对不同国家的基础设施差异化、要兼顾不同地区的数据合规，还要关注成本和效率……面对上述挑战，拥有稳定高效的全球化技术能力非常关键。</p><p></p><p>从2016年起，阿里陆续收购 Lazada、Daraz、Trendyol 等海外公司，阿里全球化业务布局初步形成，自此正式将全球化技术作为集团重要的技术战略方向来投入。经过多年的演进，逐渐发展成为阿里集团内相对独立的技术体系。</p><p></p><p>近期，我们邀约内部技术团队，首次系统性地沉淀展示阿里全球化的技术能力，包括基础设施、全球化安全生产&amp;质量保障体系、全球化商品域建设、全球化商家平台、用户增长、商品推荐等多个领域的技术演进和能力建设，希望为行业同行者提供一些参考和借鉴。</p><p></p><p></p><h3><a href=\"https://xie.infoq.cn/article/b28db5e9146eb87daf5598a5d\">1. 总览：全球化趋势下，如何建设稳定高效的技术能力？</a>\"</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/c9/c97ee7c458985d8ccf29db8fd5a0d965.png\" /></p><p></p><p>在全球化业务布局的过程中，中国企业面对着语言、文化、地域、监管四个维度的差异和挑战。电商交易的跨语言沟通需要企业在语言翻译领域进行大量投入；文化和用户习惯差异，需要针对不同国家和地区做商品的差异化透出；地区间基础设施的不平衡、数据合规、技术进出口合规都是一个个需要攻克的难题......</p><p></p><p>如何建设稳定高效的全球化技术能力？针对本对本和跨境两种业务模式，该如何选择和部署架构……阿里集团全球化业务平台团队负责人李伟杰从整体角度介绍了全球化技术体系的建设和演进过程。</p><p></p><p>&gt;&gt;&gt; <a href=\"https://xie.infoq.cn/article/b28db5e9146eb87daf5598a5d\">点击查阅文章详情</a>\"</p><p></p><p></p><h3><a href=\"https://xie.infoq.cn/article/25b927989dd715e0c0a267b8f\">2. 基础设施篇 | 6年技术迭代，阿里全球化出海&amp;合规的挑战和探索</a>\"</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/90/90af67461eb1e14fed092d6ffd142922.png\" /></p><p></p><p>海外电商服务的对象大部分场景是跨国家的，而海外不同国家的网络性能和基础硬件设施和国内相比有很多差异，这对业务的稳定性和体验的流畅度提出了很多挑战。</p><p></p><p>举例来说，用户从发起请求到接收到响应的延时越短，代表技术体系的性能越好。而全球互联网服务在延时上有天然的挑战，即物理距离更长，但1 秒钟的延迟也会造成转化率下降，甚至是用户流失。</p><p></p><p>如何保障基础设施的稳定性、解决合规风险问题？本文将首先重点讲解全球化基础设施层的挑战和技术实践。</p><p></p><p>&gt;&gt;&gt; <a href=\"https://xie.infoq.cn/article/25b927989dd715e0c0a267b8f\">点击查阅文章详情</a>\"</p><p></p><p></p><h3><a href=\"https://xie.infoq.cn/article/a7d4a78023afb75f21cf17fe3\">3. 全球化安全生产 &amp; 质量保障体系建设探索</a>\"</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/1e/1e0e97b590baea9a93870dd3107fc715.png\" /></p><p></p><p>全球化电商中的业务、技术及架构和国内技术都有一定差异，从安全生产保障和质量保障角度，这些差异带来了更多的挑战。</p><p></p><p>在业务上，全球化电商主要有本对本和跨境两种最基本的类型。而针对本对本和跨境两种业务模式的选择，背后对应不同的技术架构选型。在组织一场全球化大促时，如何快速发现、定义、解决问题，保障大促安全平稳进行？</p><p></p><p>本文针对全球化安全生产和质量保障体系的一些关键问题进行了解答。</p><p></p><p>&gt;&gt;&gt; <a href=\"https://xie.infoq.cn/article/a7d4a78023afb75f21cf17fe3\">点击查阅文章详情</a>\"</p><p></p><p></p><h3><a href=\"https://xie.infoq.cn/article/2c782c73fe048c2caea02e5b2\">4. 全球化商家平台技术探索与演进</a>\"</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/09/09194dcdcab1290ddb4d2b6d1f2873c2.png\" /></p><p></p><p>全球化环境下，商家产品覆盖面广、产品服务的业务角色多、不同角色业务差异性大......整个产品能力设计会非常复杂。如何差异化支撑全局业务的高效迭代？如何轻量化支撑创新业务的快速建站？成为全球化各个核心平台必须回答的命题。如何进行平衡和取舍？</p><p></p><p>结合全球化商家产品的特性以及前台和中台的组织协同方式，阿里定义出了商家平台服务业务的三种架构模式。本文聚焦全球化商家平台技术架构演进过程以及背后的技术思考。</p><p></p><p>&gt;&gt;&gt; <a href=\"https://xie.infoq.cn/article/2c782c73fe048c2caea02e5b2\">点击查阅文章详情</a>\"</p><p></p><p></p><h3><a href=\"https://xie.infoq.cn/article/36f048c4d0cfd8146e55752e3\">5. 用户卖家平台三方螺旋成长 如何让商品推荐更智能</a>\"</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/53/53d7174ee6e41cb7b04981d93a3bcd8b.png\" /></p><p></p><p>Lazada作为阿里在东南亚的重要电商板块，近年来发展迅速。一方面用户体量不断增长，另一方面业务和供给快速变化。平台每天都有大量商品发布，但参差不齐的商品质量容易为用户带来困惑，此外，商品的转化率还会受到销量评论以及卖家和平台运营动作的影响。如何在动态变化的环境中准确捕捉到高质量的商品，提升用户的购买体验？</p><p></p><p>Lazada将商品演变抽象成一个单独命题，致力于在用户卖家平台三方螺旋成长过程中，让商品推荐更智能。本文将为大家分享阿里在与商品的演变成长性和商品的购买体验相关的三个环节中探索实践的经验。</p><p></p><p>&gt;&gt;&gt; <a href=\"https://xie.infoq.cn/article/36f048c4d0cfd8146e55752e3\">点击查阅文章详情</a>\"</p><p></p><p></p><h3><a href=\"https://xie.infoq.cn/article/20f2150ae4e4b6b14b32040b3\">6. 从混沌到清晰，阿里全球商品类目域建设思考</a>\"</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/1d/1d276f8d4fcecd35d052c64b0728a0eb.png\" /></p><p></p><p>商品是电商产品体系核心之一，类目则是商品模型核心之一，类目系统提供的基础业务数据贯穿了整个电商体系。</p><p></p><p>由于不同地区的文化和操作习惯不尽相同，全球化类目系统需要根据当地业务来进行调整。在知识储备较低、人员流动性大的地区，对类目运营产品依赖性更高。因此，类目域建设在全球化业务中至关重要。本文介绍了商品类目域国内到国际的差异，以及在全球化过程中的建设与思考。</p><p></p><p>&gt;&gt;&gt; <a href=\"https://xie.infoq.cn/article/20f2150ae4e4b6b14b32040b3\">点击查阅文章详情</a>\"</p><p></p><p></p><h3><a href=\"https://xie.infoq.cn/article/219a6c519ea9a1bdb2c0713a4\">7. 阿里国际站用户增长技术探索与实践</a>\"</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/69/692cb4d79179c90574ef2de7d8e8cd55.png\" /></p><p></p><p>和众多传统行业一样，跨境贸易产业近年来也经历了数字化的转型创新，而首先参与进模式创新的地方主要集中于信息展示和业务撮合领域。跨境B类用户与C类买家有着诸多不同，存在着用户结构复杂、行为数据稀疏；目标人群规模小，流量引入的精准性要求高；B类买家留存率低，C类增长策略不可复制三大挑战。本文将为大家分享阿里国际站在用户增长技术体系建设上的探索与实践。</p><p></p><p>&gt;&gt;&gt; <a href=\"https://xie.infoq.cn/article/219a6c519ea9a1bdb2c0713a4\">点击查阅文章详情</a>\"</p><p></p><p></p><h3><a href=\"https://xie.infoq.cn/article/d439b2e90dae2511e9fe50047\">8. 阿里国际站-唤端技术的探索与演进</a>\"</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/26/2614542f65bcb288b4a952058cb92077.png\" /></p><p></p><p>近几年用户增长领域APP推广发展迅猛，而唤端就是其中的重要技术。通过唤端拉新/促活不仅能能够将三方流量规模做大，同时二方流量也能有效利用，给网站不断带来商机。但因场景和目标差异在策略及演进上有所不同，海外业务和国内业务的唤端体系建设有着不同特点。与国内相比，海外业务类型差异大、方向不同，二方互相拉活的优势难以在海外被利用。因此，阿里国际站对海外唤端技术进行了改进和打磨。本文将为大家详细介绍阿里国际站在唤端技术的探索与演进。</p><p></p><p>&gt;&gt;&gt; <a href=\"https://xie.infoq.cn/article/d439b2e90dae2511e9fe50047\">点击查阅文章详情</a>\"</p><p></p><p>欢迎点击关注订阅，一键收藏阿里巴巴全球化系列，未来持续查阅最新文章。</p>",
    "publish_time": "2023-03-09 11:36:57",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "又一大佬冲向ChatGPT风口！美团创始人王兴宣布投资王慧文创业项目，共同打造“中国 OpenAI”",
    "url": "https://www.infoq.cn/article/x8Q7ghQ0CmFeuKUPRZiA",
    "summary": "<p>3月8日，美团创始人王兴在朋友圈中表示，将以个人身份参与王慧文创业公司“光年之外”的A轮投资，并出任董事。</p><p>&nbsp;</p><p>“AI大模型让我既兴奋于即将创造出来的巨大生产力，又忧虑它未来对整个世界的冲击。老王和我在创业路上同行近二十年，既然他决心拥抱这次大浪潮，那我必须支持。”王兴表示。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/52/520f087003fba5d6719d1e6b9146e9aa.png\" /></p><p></p><p>自去年年底发布以来，<a href=\"https://www.infoq.cn/article/YYqCPSdRmtkdSl2hhb9Y\">ChatGPT</a>\" 彻底点燃了科技界，并火速：出圈“，仅用 2 个月时间就收获了 1 亿用户。比尔盖茨评价称，ChatGPT 的技术将“改变我们的世界”。马斯克也在感叹“很多人疯狂地陷入了 ChatGPT 循环中”，“ChatGPT 好得吓人，我们离强大到危险的人工智能不远了”。</p><p>&nbsp;</p><p>ChatGPT 的爆火也掀起了<a href=\"https://www.infoq.cn/theme/173\">应用开发热潮</a>\"。据澎湃新闻报道，最近几个月，在旧金山和硅谷，生成式人工智能聚会、联合办公空间和各种会议中弥漫着兴奋情绪，让人感觉像是回到了移动互联网的创业热潮中。年轻的科技创始人给旧金山社区海斯谷起了个绰号“脑谷（Cerebral Valley）”。</p><p>&nbsp;</p><p>国内对 ChatGPT 感兴趣的企业、个人亦不在少数。</p><p>&nbsp;</p><p>稍早前，原美团联合创始人<a href=\"https://www.infoq.cn/article/7T0i680uu5Elrk3VKbNu\">王慧文</a>\"曾在社交平台发文宣布进军人工智能领域，称将打造“中国的 OpenAI”。</p><p>&nbsp;</p><p>其在文中透露，将成立北京光年之外科技有限公司，王慧文出资 5000 万美元，估值 2 亿美元（约 13.62 亿元人民币），并表示，他个人不占股份，资金占股 25%，75% 的股份用于邀请顶级研发人才，下轮融资已有顶级 VC 认购 2.3 亿美元（约 15.66 亿元人民币）。</p><p>&nbsp;</p><p>天眼查 App 显示，北京光年之外科技有限公司成立于 2018 年 7 月，法定代表人为王慧文，注册资本 100 万人民币，经营范围包括销售自行开发的产品；计算机系统服务等，由王慧文全资持股。</p><p>&nbsp;</p><p>据悉，王兴和王慧文是清华大学室友，近二十年间，两人数次携手创业，联手打造出了校内网、美团等多个案例。2020年，王慧文宣布从美团退休时，王兴曾在公开信中表示，“老王和我是有共同志趣的同学和室友，是携手创业的搭档和并肩战斗的战友，更是可以思想碰撞、灵魂对话的一生挚友”。</p><p>&nbsp;</p><p>此次二人继续联手创业，组队打造中国OpenAI，期待可以给用户带来更多的惊喜。</p>",
    "publish_time": "2023-03-09 11:42:42",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "谷歌发布史上最大AI模型 PaLM-E：5620 亿参数，无需特殊训练可操纵机器人",
    "url": "https://www.infoq.cn/article/GNkCpSlCJ8hQ5v4Of4ft",
    "summary": "<p>本周一，来自谷歌和柏林工业大学的 AI 研究团队推出了<a href=\"https://palm-e.github.io/\"> PaLM-E</a>\"，这是一种多模态视觉语言模型（VLM），具有 5620 亿个参数，集成了可控制机器人的视觉和语言能力。据称这是有史以来规模最大的视觉语言模型，能够执行各种任务且无需重新训练，这套与 ChatGPT 有几分相似的 AI 模型新增视觉功能。</p><p></p><p>根据谷歌的介绍，只要给出一条高级命令，比如“把抽屉里的脆片拿给我”，<a href=\"https://palm-e.github.io/\">PaLM-E</a>\" 就能为机械手臂平台（由 Google Robotics 开发）生成相应的操纵指令。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/1c/1c11bc05f748481a81e283d2043cdbae.png\" /></p><p></p><p>在演示视频中，由 PaLM-E 控制的机械臂正伸手取一袋薯片。</p><p></p><p>PaLM-E 的基本工作原理，是分析机器人摄像头采集到的数据，且无需对场景表示做任何预处理。该模型消除了对数据预处理和标注的需求，有望将机器人的自主水平提升至新的层次。</p><p></p><p><a href=\"https://www.infoq.cn/article/7oYfCjaI0rbbpGsBSYWk\">谷歌</a>\"称，该模型还具有一定弹性，能够对周边环境做出反应。例如，PaLM-E 模型能够引导机器人从厨房中取出袋装薯片，并通过将 PaLM-E 集成至控制回路当中，能够应对执行期间可能发生的意外状况。此外，同一套 PaLM-E 模型能成功通过复杂的指令序列实现了对机器人的自主控制，以往这类任务只能由人类引导完成。</p><p></p><p>谷歌在<a href=\"https://the-decoder.com/google-palm-e-combines-language-vision-and-robotics/\">研究论文</a>\"中解释了 PaLM-E 如何将指令转化为行动：我们展示了 PaLM-E 面对具有挑战性的多样移动操作中，表现出的实际性能。我们主要参考 Ahn 等人的设置方案（2022 年），机器人需要根据人类的指令规划一系列导航与操作动作。例如，给出指令“我把饮料弄洒了，能给我拿东西清理一下吗？”，机器人就会规划一连串“1. 找清洁棉；2. 捡起清洁棉；3. 递给用户；4. 放下清洁棉”的行动。受任务启发，我们设计出三个用例来测试 PaLM-E 的具身推理能力，具体包括可供性预测、故障检测和长期规划。低级策略来自 RT-1（Brohan 等人，2022 年），这是一套采用 RGB 图像加自然语言指令、能够向末端执行器输出控制命令的 transformer 模型。</p><p></p><h2>PaLM-E 到底是个啥？</h2><p></p><p></p><p>PaLM-E 是一款下一令牌预测器，取名“PaLM-E”是因为其基于谷歌的 PaLM 大语言模型（LLM，与 ChatGPT 的底层技术相似）。谷歌进一步向其中添加了感官信息和机器人控制功能，帮助 PaLM 实现了“具身化”。</p><p></p><p>由于基于语言模型，PaLM-E 会进行连续观察，例如接收图像或传感器数据，并将其编码为一系列与语言令牌大小相同的向量。如此一来，模型就能继续以处理语言的方式“理解”感官信息。</p><p></p><p>除了 RT-1 机器人 transformer 之外，PaLM-E 还借鉴了谷歌之前在 ViT-22B 上的经验积累——今年 2 月发布的视觉 transformer 模型。ViT-22B 已经接受过各种视觉任务训练，包括图像分类、对象检测、语义分割和图像描述。</p><p></p><p>Google Robotics 并不是唯一尝试使用神经网络进行机器人控制的研究小组。这项特殊工作与<a href=\"https://www.infoq.cn/article/9wzrGiMTl8XClRgSfL9A\">微软</a>\"最近发布的《ChatGPT for Robotics》论文有相通之处，该文章也尝试以类似方式将视觉数据同大语言模型相结合，探索对机器人进行控制。</p><p></p><p>除了机器人技术之外，<a href=\"https://www.infoq.cn/article/FB6BxlokIrMQgNLl3Vzt\">谷歌研究人员</a>\"还观察到其他一些有趣的效果，其明显来自 PaLM-E 的大语言模型核心。首先，它表现出了“正迁移”，又称助长式迁移，意味着它能把一项任务中学到的知识和技能迁移至另一项任务，而且与单任务机器人模型相比具有“明显更高的性能水平”。</p><p></p><h2>谷歌称正在探索 PaLM-E&nbsp;模型更多应用场景</h2><p></p><p></p><p>此外，研究人员还观察到模型规模有越来越大的趋势：“语言模型越大，在视觉语言和机器人任务训练时就越能保持住这种语言能力。从数量上讲，5620 亿参数的 PaLM-E 模型几乎保留了全部的语言能力。”</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/c8/c82483af15661cba5442d58431e5af15.png\" /></p><p></p><p>在另一不同领域，同一套 PaLM-E 模型能够实时控制机器人。在此之前，机器人还需要人工引导才能完成很长的操作任务（interactive-language.github.io），但现在 PaLM-E 已经能够自主学习这些任务。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/3f/3f7d86d255ad12357948b15c0adee82b.png\" /></p><p></p><p>谷歌称，“PaLM-E 是迄今为止已公开的最大视觉语言模型。我们观察到，尽管只接受了单图像提示训练，但 PaLM-E 仍然掌握了多模态思维推理和多图像推理等新能力。虽然不是我们的工作重点，PaLM-E 在 OK-VQA 基准测试上创下新的同类最佳性能”。</p><p></p><p>研究人员宣称，PaLM-E 还展现出随机应变的能力，例如尽管只接受过单图像提示训练，仍可实现多模态思维链推理（允许模型对包含语言和视觉信息在内的一系列输入进行分析）和多图像推理（同时使用多张输入图像进行推理或预测）。从这个角度看，随着深度学习模型变得越来越复杂，PaLM-E 似乎正带给我们更多惊喜。</p><p></p><p>谷歌研究人员还计划探索 PaLM-E 模型在现实场景中的更多应用，例如家庭自动化或工业机器人。他们希望 PaLM-E 能够启发出更多关于多模态推理和具身化 AI 的研究。</p><p></p><p>如今“多模态”已经成为新的流行语。相信随着企业着力研发具备类人常规任务执行能力的人工通用智能（AGI），多模态的大名也将越来越多为人们所听闻。</p><p></p><p>参考链接：</p><p>https://arstechnica.com/information-technology/2023/03/embodied-ai-googles-palm-e-allows-robot-control-with-natural-commands/</p>",
    "publish_time": "2023-03-09 12:59:33",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "2023第一家倒下的自动驾驶公司：七年没开展实际业务，百亿估值靠吹出来，上市16个月破产了",
    "url": "https://www.infoq.cn/article/VEAmqNAPRjMud9ypeuNV",
    "summary": "<p>近日，据外媒报道，自主卡车新贵Embark宣布破产，结束运营并解雇了大部分员工。</p><p></p><h2>从估值50亿到破产仅16个月</h2><p></p><p>&nbsp;</p><p>自主货运初创公司Embark&nbsp;Trucks曾经创造出了最激动人心的财富故事，但如今的它已宣布结束运营并解雇大部分员工。</p><p>&nbsp;</p><p>在上周五给员工的电子邮件中，公司CEO兼联合创始人Alex Rodrigues写道，“在全面评估了所有潜在方案之后，我们确信已无法按当前形式继续维持业务。”</p><p>&nbsp;</p><p>这个时候，距离<a href=\"https://www.infoq.cn/article/F7Ho0RJ8IHGkO9YwXSyB\">Embark</a>\"这家诞生于旧金山的<a href=\"https://www.infoq.cn/article/fFpp7ZQIMSUclk8ckwsz\">自动驾驶</a>\"卡车新贵完成SPAC（海外借壳上市）、拿下51.6亿美元估值才仅仅过去16个月。</p><p>&nbsp;</p><p>即使是考虑到当时“虚火过旺”的市场状况，还没开始赚钱的<a href=\"https://www.infoq.cn/article/F7Ho0RJ8IHGkO9YwXSyB\">Embark</a>\"能豪取50亿估值还是有些夸张了。但这并不妨碍支持者们奋力吹捧其“精致的自主驾驶软件”，宣称Embark打造的长途卡车将彻底颠覆整个货运行业。</p><p>&nbsp;</p><p>SPAC的赞助方们也为Embark贡献了约6.14亿美元：Northern Genesis Acquisition Corp.&nbsp;II豪掷4.14亿美元，CPP Investments及卡车运输公司Knight-Swift Transportation、Mubadala Capital、Secooia Capital、Sedooia Capital和Tiger Global Management共计拿出2亿美元。</p><p>&nbsp;</p><p>在2021年11月11日首登纳斯达克时，Embark正好赶上了技术股的峰值周期，其股价在接下来几个月内都始终维持在目标估值水平。但随着市场遇冷，投资者的态度也逐渐消极。到2022年1月，Embark的股价迅速缩水一半，六个月后，其股价已经不足上市之初的十分之一。</p><p></p><h2>Embark 的起伏史</h2><p></p><p>&nbsp;</p><p>Embark成立于 2016 年，总部位于旧金山，由 Alex Rodrigues 和 Brandon Moak 共同创立。</p><p>&nbsp;</p><p>据了解，Rodrigues 在 11 岁时就开始制造<a href=\"https://archsummit.infoq.cn/202303/beijing/track/1454\">机器人</a>\"，他在加拿大滑铁卢大学学习机电一体化工程时遇到了 Moak，两人在大学期间曾一同在车库中造出了加拿大第一辆自动驾驶汽车—— 一辆名为“Marvin”的自动驾驶高尔夫球车。</p><p>&nbsp;</p><p>2016 年，Rodrigues 和 Moak 正式创立 Embark，并加入了美国著名创业孵化器 Y Combinator 的孵化计划。据了解，Embark 公司最初的计划是构建用于大学校园的自动驾驶班车。不久后，团队开始转向应用于高速公路的<a href=\"https://www.infoq.cn/article/QtGA7QPzlFc1l2wORpgP\">自动驾驶</a>\"卡车。</p><p>&nbsp;</p><p>自动驾驶卡车市场前景广阔，Embark 也迅速得到了风投的青睐。在 2016 年至 2019 年期间，Embark 筹集到的资金包括：由 Maven Ventures 领投的 200 万美元种子轮融资，由 DCVC 领投的 1500 万美元 A 轮融资，由红杉资本领投的 3000 万美元 B 轮融资，以及由 Tiger Global 领投的 7000 万美元 C 轮融资。</p><p>&nbsp;</p><p>拿到巨额融资后的 Embark 野心勃勃。《华尔街日报》曾在几年前的一篇文章中提到，Embark 的首席执行官 Rodrigues 计划在五年内初步部署一辆全自动驾驶卡车。该公司的长期愿景是：在城市行驶时，由人类卡车司机掌握方向盘，在高速公路上则由计算机控制。</p><p>&nbsp;</p><p>2021 年，Embark 开始谋求上市。2021 年 6 月，Embark 宣布将与空白支票公司 Northern Genesis Acquisition Corp. II 合并在纳斯达克上市。在交易报告中，Embark 表示，他们计划从 2024 年开始在美国南部工业区实现自动驾驶卡车的运营。</p><p>&nbsp;</p><p>2021 年 11 月，Embark 成功上市，市值约 50 亿美元。通过此次上市，Embark 筹集了约 6.14 亿美元的现金总收入。</p><p>&nbsp;</p><p>但自上市开始，Embark 的股价几乎一直在跌，市场也开始质疑 Embark 的能力。</p><p>&nbsp;</p><p>2022 年 1 月，The Bear Cave 发布了一份题为“Embark 科技公司的问题”的报告，让情况变得更加糟糕。这份报告认为，“Embark 公司目前的估值似乎是基于吹嘘而非实际的内容。”报告警告说，Embark 公司“没有专利，只有十几辆测试卡车，而且可能是虚张声势”。</p><p>&nbsp;</p><p>随后，Embark 股东开始集体诉讼，指控 Embark 夸大了其运营和技术能力。在季度申报中，Embark 承认了自己在合并证券集体诉讼中的被告角色，并斥责那些指控“缺乏法律依据”。</p><p>&nbsp;</p><p>公共市场也没有对 Embark 提供支持。2022 年 8 月，为了避免因股价持续低于 1 美元而退市，Embark 公司宣布进行一项 20 比 1 的反向股票分割。此举提升了个股价格，但却并没有提升公司的估值。</p><p>&nbsp;</p><p>自那时起，Embark 的股价开始进一步大幅下跌。与起初的 50 亿美元市值相比，上市仅一年多Embark 的市值几乎跌没了。&nbsp;</p><p></p><h2>运营七年没真正开展业务，只靠外部“输血”难以为继</h2><p></p><p>&nbsp;</p><p>通过对Embark曲折上市之路的跟踪观察，我们发现分析师其实已经预见到了这位自动驾驶卡车新贵的后续遭遇。</p><p>&nbsp;</p><p>这家运营7年的企业自始至终都没能真正开展业务，更不用说创造收入或者实现盈利了。相反，高达几十亿美元的估值完全来自投资市场对Embark<a href=\"https://archsummit.infoq.cn/202303/beijing/track/1477\">技术潜力</a>\"的乐观预期。</p><p>&nbsp;</p><p>但时代已经变了。</p><p>&nbsp;</p><p>正如Rodrigues在上周五的邮件中所言，“资本市场开始对无法创造收入的企业说不，如同无法按时完成商业计划的制造企业被迫推迟业务扩展一样。”</p><p>&nbsp;</p><p>在“全面评估所有的潜在方案之后”，Embark表示将裁掉70%的员工，并关闭位于南加州和休斯顿的办公室。Rodrigues写道，其余30%员工将负责关闭日常运营，最后“感谢各位支持我们的同事”。</p><p>&nbsp;</p><p>别的不讲，最初，Embark确实拥有着勃勃野心。</p><p>&nbsp;</p><p>当时《华尔街日报》曾在报道中引用CEO Rodrigues的原话，预计<a href=\"https://archsummit.infoq.cn/202303/beijing/track/1454\">完全自主驾驶</a>\"卡车在未来五年内即可初步部署。该公司的长期愿景是在市区驾驶时由人类司机接管，到高速公路场景则由计算机控制。</p><p></p><h2>寒冬之下，自动驾驶卡车迎来「倒闭潮」</h2><p></p><p>&nbsp;</p><p>Embark只是投身自主驾驶卡车市场的多家初创公司之一，而其他各位同仁也纷纷在艰难时刻倒闭破产，具体包括：</p><p>&nbsp;</p><p>总部位于旧金山的Otto。作为较早的创业公司之一，Otto专注于自主驾驶卡车，并于2016年以6.8亿美元接受Uber的收购。约两年之后，<a href=\"https://www.infoq.cn/article/fo4Co3jrmbo11GkUt0uD\">Uber</a>\"关闭了自主驾驶卡车部门，并表示将战略重点放在自主驾驶汽车上。</p><p>&nbsp;</p><p>Starsky Robotics，一家由风险投资支持的旧金山自主驾驶货运公司，在B轮融资失败后于2020年倒闭。自2015年成立以来，这家公司共筹集到超2000万美元资金。</p><p></p><p>Peloton Technology，一家位于硅谷的自主驾驶技术初创公司。在2021年倒闭之前，已知融资总额超过7800万美元。</p><p>&nbsp;</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&amp;mid=2247578431&amp;idx=1&amp;sn=4ade672ebe86e1377555e61f5a3fd2c0&amp;chksm=fbeb0af0cc9c83e612131e18142c60fa6818d8a4c5125d6c7cd5ba08ada8289bd49994f57dff&amp;scene=27#wechat_redirect\">TuSimple</a>\"，来自圣迭戈的机器人卡车技术开发商，于2022年4月进行了IPO。初上市时估值高达85亿美元，但目前市值已经缩水至约4.6亿美元。</p><p>&nbsp;</p><p>来自匹兹堡的Aurora于2021年夏季宣布将通过SPAC的方式上市，最初市值约130亿美元（含约25亿美元现金）。但如今，其股价同样下跌至峰值时期的不足十分之一。</p><p>&nbsp;</p><p>参考链接：</p><p><a href=\"https://news.crunchbase.com/transportation/embark-trucks-closes-autonomous-vehicles/\">https://news.crunchbase.com/transportation/embark-trucks-closes-autonomous-vehicles/</a>\"</p>",
    "publish_time": "2023-03-09 13:52:52",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "和谷歌一样，Mozilla也在期待苹果终结Webkit规则",
    "url": "https://www.infoq.cn/article/N6crECI9NBxwui3GmduK",
    "summary": "<p>根据最新消息，考虑到苹果准备取消对竞争对手在 iOS 中使用 WebKit 浏览器引擎的限制，Mozilla 已经开始为这一天的到来提前做准备了。</p><p></p><p>Mozilla 几年前就做过了类似的实验，但是结果在当时并没有公开出来。时过境迁，2022 年 10 月 Mozilla 在存放 Firefox iOS 版代码的 GitHub 存储库中发布了一个问题，其中包含了一条对 GeckoView 的引用，而 GeckoView 是 Firefox 的 Gecko 渲染引擎的包装器。</p><p></p><p>根据当前的苹果 AppStore 指南，iOS 上的第三方浏览器应用程序必须使用苹果自己的 WebKit 浏览器引擎。因此，Mozilla 目前是无法通过 iOS 的 AppStore 发布使用 Gecko，而非 WebKit 引擎的 Firefox 版本的。</p><p></p><p>媒体之前也报道，Mozilla 并不是唯一一家期待 iOS 平台 AppStore 商店可以带来更利于浏览器市场竞争的规则的企业。除了 Mozilla 之外，谷歌已经开始为 iOS 平台开发基于其 Blink 引擎的 Chrome 版本。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/f4/f44b52659a005070a891a2962af3291f.png\" /></p><p></p><p>主要的浏览器制造商——<a href=\"https://www.infoq.cn/article/RCJHtVcEeVjad2kGJD5s\">苹果</a>\"、谷歌和 <a href=\"https://www.infoq.cn/article/dxf9lY8Elt5BtbtEUG0z\">Mozilla</a>\"——都有自己的浏览器渲染引擎。苹果的 Safari 基于 WebKit；<a href=\"https://www.infoq.cn/article/GGzRSK9sVKRrDD7xH97t\">谷歌的 Chrome </a>\"及其开源 Chromium 基金会基于 Blink（该引擎十年前从 WebKit 分叉而来）；Mozilla 的 <a href=\"https://www.infoq.cn/article/hHClLTq2A5lrfz9DusWe\">Firefox</a>\" 基于 Gecko。</p><p></p><p>微软在当年的 Internet Explorer 中使用了自己开发的 Trident 渲染引擎，并在旧版 Edge 中开发了一个名为 EdgeHTML 的 Trident 分支。但自从这家公司将其 Edge 浏览器改为基于 Chromium 代码开发以来，Edge 一直依赖于 Blink 引擎。</p><p></p><p>浏览器渲染引擎负责在屏幕上渲染文本和图像。当浏览器工程师添加新功能或支持新的 API 时，他们通常通过添加渲染引擎代码来实现目的，这从各种 Blink 的增强特性也可以看出来。</p><p></p><p>有时苹果、谷歌和 Firefox 会就新功能达成一致并共同努力解决问题，例如弹出菜单这一特性就是个例子。其他时候，三大浏览器制造商会产生分歧，结果各自的代码库走上不同的路线。</p><p></p><p><a href=\"https://www.infoq.cn/article/TdS104Q68yk3oLONlk9x\">Safari </a>\"的特性开发一直落后于 Chrome 和 Firefox。然而，苹果似乎意识到了监管机构带来的风险，并向 WebKit 团队增加了更多员工以缩小浏览器的能力差距。</p><p></p><p>如果苹果确实允许其他厂商在 iOS 生态系统中使用其他浏览器引擎，谷歌和 Mozilla 将能够通过这些浏览器的桌面版本中积累的显著技术优势来与 Safari 竞争。</p><p></p><p>开发者游说团体 Open Web Advocacy 去年发布了一份报告 Bringing Competition to Walled Gardens，详细阐述了苹果的 WebKit 限制所带来的后果。它将苹果的限制描述为反竞争的自我偏好。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/22/22de3ac765dd8d851dfad269cc4e0cdc.png\" /></p><p></p><p>Web 平台测试仪表盘显示在各个浏览器中的失败数量</p><p></p><p>“苹果正在阻止可互操作的、基于通行标准的 Web 技术成为苹果和谷歌提供的原生私有生态系统的可行替代方案，”该组织的报告给出了这样的结论。</p><p></p><p>“在缺乏竞争的情况下，苹果自己的浏览器对 Web 应用的糟糕支持状态会把开发者和用户推向 AppStore 的封闭生态系统。”</p><p></p><p>虽然前述 GitHub 问题中提到的，用于切换到 GeckoView 的 Firefox for iOS 设置页面可能只是用于 Mozilla 内部的浏览器测试用途，但 Mozilla 的脚步似乎不止于此。对这个 GitHub 问题的简短公开讨论表明，Mozilla 已经预料到苹果的规则可能会发生变化——这是 Mozilla 和其他公司通过持续的监管游说寻求的结果。</p><p></p><p>早在去年12月12 日，一位开源贡献者询问这是什么版本，Mozilla 的高级软件开发人员 Laurie Marceau 回答说这是“针对不在这个代码库中的一个次要项目”。</p><p></p><p>这位开源贡献者随后回复道，“谢谢，希望欧盟赶快落地相关法规，这样我们就可以在 iOS 上拥有好用的 Gecko Firefox 了。”</p><p></p><p>Marceau 的回应是一个竖起大拇指的表情符号。Marceau 对媒体的进一步说明请求没有回应。Mozilla 对媒体的询问没有立即回应，但表示他们稍后可能有话要说。</p><p></p><p>去年12月13日，有报道称苹果正准备在 iOS 17 中允许第三方应用商店上线——该版本预计在 2023 年第三季度发布——从而遵守欧洲数字市场法案的要求。欧盟的这些规则——以及其他监管机构提出的相关担忧——看起来可能会迫使苹果放弃其对 iOS 平台上 WebKit 的相关限制要求。</p><p></p><p>然而，苹果并未就此做出公开承诺，也未回应媒体的置评请求。</p><p></p><p>这不是 Mozilla 第一次为 iOS 准备基于 Gecko 引擎的 Firefox 版本了。Mozilla 前平台工程师 Ted Mielczarek 在 Twitter 上指出，他曾在 2010 年和 2015 年两次参与 Gecko 引擎到 iOS 平台的移植工作。</p><p></p><p>Mozilla 从未要求法院强制苹果在 iOS 上分发基于 Gecko 引擎的 Firefox 版本——这会是一场代价高昂的法律战争，而且它可能并不会赢。但最近，它在 2022 年 9 月的一份题为“五大技术花园围墙：为什么浏览器对互联网至关重要，以及操作系统如何阻碍它们的发展”的报告中表达了公众对苹果 WebKit 规则的反竞争后果的担忧。</p><p></p><p>如果欧盟数字市场法案产生预期的效果，到今年年底这种技术花园围墙将会减少一些。但根据过去的经验，我们也不能太早开香槟。</p><p></p><p>在一封电子邮件声明中，Mozilla 发言人说：“我们遵守苹果的 iOS 应用商店政策，只是在做一些探索性工作，以了解如果这些政策发生变化，iOS 上基于 Gecko 引擎的浏览器将会面临的技术挑战。我们希望人们可以自由使用他们所选择的浏览器，可以自由选择浏览器背后所使用的引擎，我们希望这样的一天能尽早到来。”</p><p></p><p>原文链接：</p><p><a href=\"https://www.theregister.com/2023/02/07/mozilla_google_apple_webkit\">https://www.theregister.com/2023/02/07/mozilla_google_apple_webkit</a>\"</p>",
    "publish_time": "2023-03-09 14:22:37",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "软件持续交付速度提升 40%！DevOps 制品管理有何魔力？",
    "url": "https://www.infoq.cn/article/9OuaokzYV9WfWvv8IXRO",
    "summary": "<p>近年来，混合云、多云正逐步成为企业用云的主流模式。据 IBM 的调查报告显示，仅截至 2021 年，采用混合云、多云战略的企业就已经接近 80%。混合云、多云战略的确能够增加企业资源配置的灵活性，但也给持续交付带来了更大的挑战。在软件发布频率持续增长趋势下，如何将版本快速分发到多个环境中去，成为令不少开发者头疼的问题。</p><p></p><p>近日，亚马逊云科技联合 JFrog 举行 《DevOps 实践：混合云模式下软件单一可信源的建设方法》为主题的 Tech Talk，<a href=\"https://www.infoq.cn/article/CAZFSFzSRfZevqzm8K0V\">JFrog </a>\"（中国）技术总监王青与大家分享了解决该问题的独特思路。</p><p></p><p></p><h2>现有的制品库正在阻碍你的快速发布</h2><p></p><p></p><p>IDC 研究报告显示，到 2024 年全球 APP 数量将达到 520M；2025 年后，超过 60% 的企业每天都将进行版本发布，甚至更快。在如此之快的版本构建需求下，现有的统一代码库、统一持续集成再进行不同环境分发的制品管理方式往往存在一定的局限性。</p><p></p><p>研发团队面临着 Nexus 开源版私服宕机无人维护、开源组件漏洞被引入等问题；测试团队无法清晰地了解版本质量信息，同时测试报告也无法准确进行关联；运维团队在面临宕机问题时候缺乏商业技术支持，缺乏高可用和容灾；在此管理模式下，一旦发生问题，安全团队很难快速发现漏洞、对问题进行定位，从而及时响应。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e3/e3dbc4323e0a29487b97910c8f8c590b.png\" /></p><p></p><p>面对诸多问题，王青提出，建立软件单一可信源对于企业来说是至关重要的。单一可信源是指企业内部单一的，合规地存放所有软件的仓库，包括 war 包，<a href=\"https://www.infoq.cn/article/wbcoOqPAwr9Ij6fL5sDd\">Docker 镜像</a>\"，zip 包等，以及第三方开源组件或者商业软件的授权版本和软件物料清单 (SBOM)。</p><p></p><p></p><h2>为什么要建立软件单一可信源</h2><p></p><p></p><p>建立唯一可信源的制品管理流程后，只需要不断将版本从开发流水线的 CI 服务器里建立晋级，一路晋级到生产环境的制品库，再由生产环境的制品库推送到多云环境中去。对于大型企业来说，通常会有多种云的技术栈，多种语言包都需要构建。通过制品库统一构建，把版本统一上传到 DEV 本地仓库做本地的集成测试，当开发者测试没有问题后，版本会晋级到 Test 仓库供测试来测，此后版本会进入性能和稳定性检测的环境，最终进入到生产环境的仓库中。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/bc/bc24a8c9f54589a3ee0557b2d7021f81.png\" /></p><p></p><p>按照这种制品的晋级流程去建设会大大提高软件交付的效率。JFrog Artifactory 遵循的正是这样一套流程。它是支持 29 种语言包的制品仓库，Maven 包、NPM 包、Docker 镜像、ZIP 文件等多种通用文件都可以进行存储。据王青介绍，JFrog 曾有一个国内大型手机制造商客户，每天单集群数据增长 20TB 左右，共有 10 多个集群。JFrog 和他们一起在研发测试区搭建了本地 Artifactory 集群，支持高并发的上传和下载，通过 5-6 个 Artifactory 节点来作为高可用集群提供服务。</p><p></p><p>这种方案相比传统的需要搭建一个 Nexus 开源版作为 Docker 镜像，再搭建一个 Nexus 开源版作为 Maven 仓库，Maven 仓库可能还要管 NPM 的技术方案，投入人力成本更低且能够提供更高的可用性。对于有多套环境的大型企业来说，软件单一可信源建设的优势就更加明显了，因为多套环境维护成本会线性增长。</p><p></p><p></p><h2>混合云模式下单一可信源的建设方法</h2><p></p><p></p><p>软件单一可信源的建设有助于企业降本增效，提升软件制品的构建速度，那么，该如何构建软件单一可信源呢？王青谈到了一种区别于传统开源方案的独特方式。</p><p></p><p>他说，在公司建设软件仓库的单一可信源时，最基本的是要保证它的高可用性。高可用有两层含义，一是零宕机，二是能够支持高并发的负载。Artifactory 对于生产环境的部署，天然的支持私有云和公有云的一键部署，并且提供实时推送功能。相比较来说，Nexus 开源版是没有推送功能的，因此，也就没办法实现将本地构建的版本推送到多个私有云或者多个公有云上去。</p><p></p><p>假设公司的制品数量级已经达到百万级甚至是千万级，该如何应对这种大规模的读取和写入呢？JFrog 引入了两个概念，一个是读缓存层，一个是写缓存层。这是区别于开源方案的一个很重要的产品功能设计点。Nexus 开源版是没有缓存这个概念的，拉取的时候会去本地查询文件存在与否，这样的问题是，当服务读取操作系统文件的时候，操作系统文件是要耗时的，如果文件块在物理上存储的力度比较分散，实际查询效率会很低。</p><p></p><p>JFrog 在 Artifactory 服务器上添加了一个叫 SSD 的缓存层，通过这个缓存层能够快速读取一些热数据返回给用户。这个设计遵循的是 LRU 的算法，会保持 500G 左右的热数据。除了读缓存，JFrog 还引入了写缓存。因为在将文件上传到服务器上的时候，是先上传到服务器的某一个目录，再通过一个进程写到存储里，有了这个设计，只要把文件成功上传到目录即可创建成功，大大减少了客户端返回的请求时间, 而后端只需建立一个异步任务，把文件存储进去，再把存储目录删掉即可。为了减少存储的压力，JFrog 还设计了冗余同步，能够让用户去配置冗余数量，如上传一个文件时用户要冗余两份，Artifactory 就会把文件从 a 冗余到 b 去，通过轮询拿到热数据返回，从而提高效率。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/3e/3e3ce331fea9a63719e86148a45941cc.png\" /></p><p></p><p>综上所述，高可用性是建立软件单一可信源的基石。尤其是当客户的数据量超过几千万时，如果都保存在存储中，查找的效率就会非常低。在存储方面，JFrog 也进行了优化。GIT 文件存储是按照 checksum 的前两位，以目录的方式去存储每一个文件，所以 GIT 能高效地存储代码仓库里面上百万、上千万的文件，依托的是文件索引的设计。当用户寻找某一个文件的时候，它会先以索引的方式定位到文件在哪个目录，在目录里面再去辨别。相当于建立了树状的结构，因此查询效率会更高。当数据量增大后要提升效率肯定还是需要依赖数据结构，通过每种场景应用不同的数据结构提升效率。</p><p></p><p>完整的高可用服务能够保证制品库建设单一可信源，可信性该如何保证呢？让制品库变得可信就涉及到安全相关的问题。王青说，尤其在面对海外用户时候，面临的最大挑战不是软件发布效率瓶颈，而是安全问题，特别是部署到公有云上的时候。他很形象地比喻，在整个程序的冰山上，代码就是冰山一角，底层有很大的 API 接口、依赖包，还有底层的基础镜像，下面会存在很多开源组件，其中客户提到最多的就是漏洞爆发之后哪些应用将受到什么样的影响，应该修复到哪个版本？</p><p></p><p>对于上述问题，王青认为，现在开源软件比较多，但真正用起来会存在很多问题。如恶意依赖注入、注入恶意二进制或者代码实现勒索等。为此，JFrog 的产品中特别增加了漏洞扫描的功能。当发现漏洞时 ，JFrog 是如何快速定位，然后下线这些服务的升级版本的呢？这需要精准定位的能力。</p><p></p><p>传统的扫描会扫出很多漏洞，缺乏跨语言的依赖，比如无法定位到哪一个 Docker 镜像被 Log4j 污染。JFrog 通过 SCA（software component analysis）来进行漏洞扫描，此外还对某些语言包如 Docker 镜像进行密钥探测，包括上下文分析。扫描出漏洞之后，传统的厂商只会告诉用户有哪几个漏洞，而 JFrog 则会告诉你每个漏洞的评分分别是什么以及该漏洞的影响范围。</p><p></p><p>单一可信源建设要做的不仅仅是扫描，还有治理，对于扫描出的漏洞进行跟踪并精细化管理。安全部门要做的是定义规则，定义策略。公司内部一般有两个概念，一个是漏洞，一个是违规，漏洞是事实，而违规是公司策略。安全部门要定义哪些级别的版本属于违规，而开发者只需要去修复违规就可以了，不用管所有的漏洞。因此，Artifactory 设计了两个维度的管理，一个是根据团队或者软件版本进行扫描，定位到某一个团队。另一个是按照部门去修复，不同部门的安全策略可能是不一样的，所以可以根据不同部门创建 Project 进行扫描和漏洞修复，从而实现有效的漏洞治理。</p><p></p><p>以上介绍的是在单一私有云或者公有云环境下的处理方式，如果要把私有云的制品同步到公有云上，JFrog 是如何做的呢？王青说，这就涉及到 JFrog 另一个功能——制品的双向同步。通过双向同步能力，能借助于亚马逊云科技的 PrivateLink 开设私有网络。只要开了 Link 之后，私有云的制品仓库就能直接推到云上的 VPC 上去，自动复制到不同的 Region，实现制品液体般的流动。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/fc/fce3884687017f8e5e11960f09eb972f.png\" /></p><p></p><p>除制品的双向同步之外，JFrog 还提供统一认证的功能，使云上云下保持一致。通常来说，云上的用户和云下的用户的账号是不能复用的，比如云上用账号 a 登录，云下就要用账号 b，这样用户就需要维护两套账号，导致用的人越多，账号维护的成本就越高。但是，Artifactory 实现了联合身份认证。只要在集群 a 创建用户，它会自动把用户信息同步到集群的每一个节点，用户在云下怎么登录，在云上按照同样的方式登录即可。这个功能特别适合多云环境进行软件制品的传输，能够极大节省公网带宽，提高发布速度，降低成本。</p><p></p><p></p><h2>轻松建立可信发布流程的实践案例</h2><p></p><p></p><p>某大型跨国银行，需要进行云迁移，实现应用上云。他们采用的方案是本地的关键数据库加上存储，到云上直接使用云数据库加上 Amazon S3 云存储，应用直接迁移到 Amazon EKS，Amazon EKS 的使用极大的降低了运维成本。在整个数据迁移的过程中，JFrog 有专门的工具把本地的 Artifactory 制品通过一个脚本直接传到云上的 Artifactory，这种持续的传输实现了业务的零中断，并能将构建速度提升了 30-40%。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/48/4838c78da9cd4f737122f2bb9b0b9ff9.png\" /></p><p></p><p>软件制品从本地推到云端会用到一个 VPC 叫 Internal Gateway。此外，亚马逊云科技在 2022 年 re:Invent 上还最新发布了一款名为 <a href=\"https://www.infoq.cn/article/wYhCKfgNMY0UXt4cUWlf\">Amazon CodeCatalyst</a>\" 的 DevOps 端到端工具，包含需求设计、issue 管理、构建等一系列功能，用户可以通过 &nbsp;Amazon CodeCatalyst 进行构建，构建完成后把版本上传到某个 Amazon ECS , 并且能够和 Artifactory 制品库进行集成。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b3/b3aafdf6f96a9c6076e26608c56a6254.png\" /></p><p></p><p>集成方式如上图所示，用户的代码 Commit 后到 GIT 仓库就能触发 Amazon CodeCatalyst 构建，构建时，通过 JFrog 的 CLI 命令行工具连接到 Artifactory 做远程依赖 PublicRepo 的下载，下载时会触发漏洞扫描，扫描完成后进行晋级，分发到多种云，用 IoT 设备进行更新。整个编排过程由 Amazon CodeCatalyst 进行负责的，并能够和 Artifactory 无缝集成，从而实现轻松地规划、开发、写作、构建和交付应用程序。</p><p></p><p>王青在分享中多次强调，对亚马逊云科技技术和服务感兴趣的开发者可参与亚马逊云科技的培训认证活动，亚马逊云科技的整个培训体系建设非常完善、可进入<a href=\"https://dev.amazoncloud.cn/activity/activityDetail?id=63e3861a6b109935d3b7725d\">亚马逊云科技开发者社区</a>\"。</p>",
    "publish_time": "2023-03-09 14:39:04",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "向云原生要数据：日均万亿级数据安全保障和小时级风险应对实践",
    "url": "https://www.infoq.cn/article/lkKt5uvHAqwj0f3F2Mb3",
    "summary": "<p>近年来，大数据、人工智能的发展给数据的自由流动带来了便利。但风险也随之产生，数据安全问题成为了关注的核心，因此，《数据安全法》、《个人信息保护法》应运而生，为数据隐私保护法律法规的实施对数据的应用做出了规范和要求。另一边，各大型互联网企业纷纷响应，对内进行大刀阔斧的技术改造，进而保护数据生产要素及其合规应用。在过去的 3、4 年中，蚂蚁集团将云原生、大数据、人工智能三者结合，实现了数据安全合规技术的新突破，解决了日均数万亿数据流动风险检测问题，将数据安全风险响应时效提升到小时级。近日，蚂蚁集团资深技术专家<a href=\"https://qcon.infoq.cn/202302/beijing/presentation/4512%E3%80%82\">夏巨鹏（真谛）</a>\"在 QCon 全球软件开发大会（北京站）中分享了以上经验，包括数据安全合规趋势、挑战，大型互联网企业数据安全治理模式、技术架构，以及安全领域智能化体系及演进方向，本文据此整理，<a href=\"https://qcon.infoq.cn/202302/beijing/presentation/4512%E3%80%82\">点击下载完整幻灯片</a>\"。</p><p></p><p></p><p></p><p>今天我要和大家探讨的是《数据安全在云原生下的探索与实践》，聊一聊云原生给数据安全带来的变化，以及我们是否可以利用云原生来助力数据安全。在此基础上，再分享蚂蚁数据安全过去 3、4 年中的落地实践与思考。</p><p></p><p>今天的分享分为四个部分，第一是数据安全合规的趋势与挑战；第二是蚂蚁集团在数据安全实践的探索，这部分会详细介绍介绍数据安全在云原生之下构建数据体系的方式方法；第三则是数据安全到网络安全及体系的延伸，智能防控体系的技术介绍；第四是分享我对于数据安全领域的未来方向思考，最后会简单做一个总结。</p><p></p><h1>数据安全合规趋势与挑战</h1><p></p><p></p><p>当前，国内外各项法规已经给数据安全奠定了良好的法律基础。近年来，我国在法律、法规层面的建设中，给数据安全行业以及数据安全相关的数字经济、相关行业指明了方向。例如《数据安全法》《个人信息保护法》等，详细阐述了数据安全及立法原则，对参与到数字经济建设的各个主体有较大的指导作用。从技术工程师的角度来看，我们通常会通过权利主体、义务主体和责权量化三个维度来解读法律条文，企业在其中的责任与义务，与之相对应的连带责任是有明确和强化的。数据安全在法律的指引下抽象出了多种数据和场景，我们认为要做好数据安全相关工作必须了解当前场景中每个值，或者说每一个数据。于是，我们提出了要建立数据分布与流动的概念，并把建立数据分布与流动的上帝视角定义为数据安全数字化的核心问题。但在大型互联网企业中，场景复杂度高，数据规模大，其基础设施演进的阶段并不统一，业务的快速迭代又加剧了数据的流动，以上种种原因给数据分布与流动的数字化体系的建立增加了难度。</p><p></p><h1>数据安全在蚂蚁集团的落地实践</h1><p></p><p></p><p>为应对上述挑战，做好数据安全建设，蚂蚁集团从数字经济安全角度出发，区分出数字经济的各个分层场景，同时将其背后的安全体系划分为业务安全、数据安全、网络安全和底层基础设施建设等四个层级。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/6a/6a00790da7af6e07255572b3fba9fca1.png\" /></p><p></p><p>首先，业务安全是离业务场景最近的。其次，是离基础设施最近的网络安全。第三则是数据安全，数据安全的元年是 2021 年，介于业务安全和网络安全之间。一方面数据安全最重要的特点是明确了各主体的法律责任，另一方面数据安全既要向上关联业务场景，也要向下对网络安全和基础设施提出新要求，起到了承上启下的作用。举个例子，我们在购买保险或电商产品时，需要向售卖方提供相关数据信息的维度不一样，这和其场景直接相关，同时这些数据合规与否也与场景紧密关联。</p><p></p><p>2021 年底，蚂蚁集团发布了《数据安全复合治理》白皮书，提出了四个关键点。分别是战略要位、实战牵引、全员参与和技术创新。下面的内容将回到白皮书中的技术创新，对其他内容感兴趣可以参考白皮书。</p><p></p><p>以数据为中心的技术体系，围绕数据驱动和合规保障两个方面。数据驱动和场景强相关，数据分为静态分布的数据和流动的数据，数据流动具有可达性和事实性，一方面数据可以通过某个链路传播到相应位置，另一方面数据分布在存储中始终是其本来的样子。这其中，如何复用传统的安全能力，如何运用云原生时代下的新技术，改变数据安全科技格局就成了关注的重点。</p><p></p><h2>智能防控体系技术介绍</h2><p></p><p></p><p>数据安全智能防控体系建立在数据流动的上帝视角基础上。它包含三个核心技术。第一，ERB 数据模型，即设计简洁、直观的领域模型，从而能够直接地描述数据流动途径、跨实体流动的可达性和事实行为；第二，从云原生基础设施采集数据流动行为，即基于 ERB 模型构建出的完整数据流动链路；第三，在 ERB 数据体系基础之上，利用大数据、机器智能技术红利，建立智能化防控体系的过程。</p><p></p><h2>ERB 数据模型</h2><p></p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/f5/f56ef705b077bca2344adca79f3ddc09.png\" /></p><p></p><p>那么，什么是 ERB 数据模型？我们在刻画数据流动的时候，一个关键问题是如何度量场景当中的每个值。假如有 A、B 两个节点，A 到 B 之间有一条路径 P1，A、B 节点有自己的 ID，由此构成一个非常初始的模型，表达数据从 A 到 B 的流动。如果有另一种数据也会从 A 流动到 B，我们可以用 A、B 间的新增一条路径 P2 来表示，如果数据会流经其它节点，可以增加新的节点来表示。</p><p></p><p>以此类推叠加，一个非常简洁的 ERB 模型就出现了。它可以帮助我们看清楚数据流动的节点和路径，从而建立数据流动的上帝视角。模型中，节点表示数据途径的实体，具备一个 ID 及多个属性；边表示数据流动的可达性，具备一个 ID 及多种数据类型；行为 Behavior 则表达数据流动的事实行为。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/ca/ca41431ba4326c1f3e2db78d3d81fadb.png\" /></p><p></p><p>那么，各个模型都有什么特点呢？</p><p></p><p>首先，E 这个维度具备粒度的可调试性。我们可以把 E 缩小到一个比较小的应用粒度，比如用 E1 和 E2 表示两个不同的应用，也可以把 E 放大到到架构域的粒度。如果进一步将粒度放大，甚至还能把 E1 和 E2 扩大到同一集团下的两个独立子公司的粒度。</p><p></p><p>通过简单分析，我们会发现这个 ERB 模型在描述数据流动时，具有同构性质，这也是第二个模型的特点。在算法设计中，同构性带来的是算法的递归性。我们可以用同样的算法，去求解数据安全中存在的风险。</p><p></p><h2>向云原生要数据</h2><p></p><p></p><p>在云原生架构下，如何获取构建 ERB 模型所需的数据？</p><p></p><p>云原生链路具备一个特点：应用跟应用之间，需要通过中间件 sidecar 来进行 RPC 的调用传递。S 代表是数据采样的 sample 节点，在云当中发挥调度采集的作用。而后， APP Call 和 API Call 会各自通过 Ingress 进入到整个体系当中来。由此，应用之间完成了整体数据流动的串接。在外部商业生态主体进行交换的场景下，会走 Ingress 跟外部云或者是生态里面的主体，以 API Call 的方式发生数据调用数据交换，产生数据流动。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/81/8168fcda57575b3ee7fb2f6965b179d5.png\" /></p><p></p><p>下面来看怎么样定义 R。我们把 RPC 抽象成一个 table，R 是这个 table 的 schema，参数对应的值就是 table 里面具体 row 的值。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/ca/ca582a93b5b653ccaaedca5a49de69cb.png\" /></p><p></p><p>进入 R 的内部视角，在边界上通过 RPC 观测 schema 是远远不够的，还需要关注参数值的影响，比如宽接口里面 arg1 和 arg2 值的范围可能影响后面的路径。此外还有一些具备枚举特性的值，比如取值是 case1、case2、case3，对应的整个路径是不一样的。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/53/53962c9dc60dd54f327b5e7c326a2df2.png\" /></p><p></p><p>此外，我们通过使用 traceID 以 R 串联数据流动的全链路。通过在 Ingress 里写入一个 traceID，使得 sidecar 跟应用传递下去，从而获得从边界到内部一个完整的流动链路。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/5d/5d1cd3db07e05abbc8882e5dda6ab8b8.png\" /></p><p></p><p>当前，蚂蚁的日均量级已经达到了十万亿级别。如果直接执行全量数据的链路计算，过程中的成本和计算量将会非常可观。因此，必须在其中增加一个环节——链路采样，用最简单的采样算法对 traceID 末位取模。在 Ingress 边缘以及 sidecar 近缘，通过增设链路采集控制器来控制采样策略，实现采集功能。</p><p></p><p>蚂蚁有百万量级的节点，如果让链路采集控制器控制所有 sidecar 和 Ingress，其复杂性、稳定性以及性能均存在着极大的挑战。于是，我们进一步优化，从 traceID 边缘生成入手，在 traceID 编码里面带入是否要采样的信息，使得 sidecar 成为状态节点，直接信任 traceID 的编码以决定是否采样。通过这样的方式，百万级的节点即可降低至千级别，使得整体体系可以根据数据量级和后面传递一系列的情况参数做调优。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/82/82fafa0978cca2920548347b0b34d5a5.png\" /></p><p></p><p>通过将多种采样策略融入采集控制器，我们实现了对链路构建进行调优。举个例子，当链路每天涉及百万量级，我们可以将采样策略设在 10 点到 12 点间，每分钟采 10 秒，随机采样十分钟；当每天量级只有 1000，取消采样限制进行全量采集；当某个链路每天涉及 10 亿量级，可以在 17 点到 18 点间进行百万分之一的采样。基于采样策略的优化，可以实现以非常小的成本来完成上帝视角下的数据流动链路刻画。</p><p></p><p>综上，我们通过建立一个 ERB 数据流动链路刻画，实现了以较低的成本获得整个集团“上帝视角”下的线上数据流动。</p><p></p><h2>智能防控体系</h2><p></p><p></p><p>接下来介绍智能防控体系。底层是云原生和基础设施，其中包含了近缘边缘的采样逻辑计算以及安全管控。再上层是 ERB 数据体系，包括数据静态分布刻画、安全主体刻画（本次分享中不做涉及）以及数据流动链路刻画。再往上一层，是数据驱动的检测、响应和防护环节。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/bb/bb2c33ec27d1fb685f0d4a74df668353.png\" /></p><p></p><p>检测环节：检测环节核心解决两方面问题。第一，风险覆盖率，能否发现体系里面所有的问题，同时匹配蓝军攻击演练，以校验监测风险覆盖。第二，风险准确性，匹配安全事件，校验发现问题的准确率。检测环节通过后进入响应环节，再将发现的可疑事件推给响应平台。</p><p></p><p>响应环节：自动化响应是响应平台智能化的一个关键要素。事件经过与数据体系的衔接，在检测识别定位后，通过响应环节完成人工分拣以及人工制定策略下的自动分解，事件从可疑状态到确定状态完成定性转换。</p><p></p><p>防护环节：在防护模块，结合编排方式搭建多层分级的防护能力。分级体系中包括身份相关的账户层面、EDR/DLP/ 零信任网络代理等相关的办公终端层面、对外 API 网络层面、物理主机层面、具备计算和拦截能力的应用层面、涉及包括脱敏、数据加解密、数据水印、数据染色以及保障数据可用不可见的差分隐私与多方安全计算等等一系列防护能力在内的数据层面。六大层面有机结合，形成一整套完整、分级的安全防护体系。</p><p></p><p>态势感知：整个体系再往顶层延伸，到达态势感知。通过了解自身水位以及外部风险，整体牵引智能防控体系向前发展。态势感知测量基于模块自身特性的独立增长曲线，在检测响应的覆盖率与准确率、响应自动化、防护灵活可靠性以及性能成本各层面有机结合、升级迭代，推进智能防控体系的全局发展。</p><p></p><p>在整个防护体系中，智能化是手段，而不是目的。第一，智能化实现了更智能、超出自然人能力的风险挖掘；第二，更智能的风险对抗与自动化处理过程能够通过充分释放工程师的人力，将更多安全专家精力投入到复杂事件的对抗研究中。</p><p></p><h1>数据安全未来发展趋势</h1><p></p><p></p><p>与此同时，我们看到了几个数据安全的未来发展趋势。</p><p></p><p>趋势一：数据安全与云原生、大数据、机器智能技术的结合愈发紧密。</p><p></p><p>趋势二：数据保护技术将成为数据要素时代关键技术。 第一层，数据要素与自然资源要素具有强相似性。对有价值的“数据矿产”而言，定位哪些数据具有什么价值是关键。第二层，数据要素关键技术突破。关键技术突破直接决定了数据要素时代何时到来、能走多远、效率多高，如隐私计算技术。第三层，制度层面。当数据交易发生，商业价值的衡量与量化定价需要通过制度来保证。</p><p></p><p>趋势三：数据安全合规科技将成为企业持续发展的核心竞争力。 当我们具备数据流动的上帝视角，就具备了业务在数据使用过程中使用效率的检测能力，从而能够在合规层面判断业务的发展进程，使得企业评估数据使用情况成为可能。一方面，企业能够根据当前数据使用判断是否接近或超越红线，规避业务风险避免触礁；另一方面，通过判断数据价值是否实现充分挖掘，指引业务挖掘数据潜力，助力企业发展取得新的突破。</p><p></p><p>总&nbsp; &nbsp;结</p><p></p><p>最后对今天的分享内容进行总结。</p><p></p><p>第一，2021 年作为数据安全元年，大型互联网企业面临巨大挑战。蚂蚁集团的建设思路是通过构建数据流动的所谓“上帝视角”，完成从侧重数据边界到关注数据流动的过渡。</p><p></p><p>第二，大数据、云原生、机器智能等技术的突破，正在给安全行业带来更多新机遇。</p><p></p><p>第三，以数据安全中的数据链路刻画为关键问题，给出 ERB 数据模型应用的探索与实践。</p><p></p><p>第四，智能防控体系，介绍如何以数据体系为核心，将智能化深入防控的方方面面。</p><p></p><p>最后，基础设施与数据应用能力当前仍处于快速演进的阶段。数据安全技术发展加速的同时，也在不断突破自身领域的核心问题。未来发展空间非常乐观。</p><p></p><h3>作者简介</h3><p></p><p></p><p>夏巨鹏（真谛），蚂蚁集团大安全技术资深安全专家，毕业于哈工大计算机学院，在安全与风控领域有十余年的一线研发经历，拥有 10 余项专利授权。在 PKI 体系、终端安全和数据安全等领域拥有丰富的实操经验。现致力于大规模复杂数据企业中流动数据的透视和安全复合治理的技术突破和创新。5 月 26-27 日，QCon 全球软件开发大会即将落地广州，从下一代软件架构、研发效能提升、现代编程语言、AIGC、现代数据架构、金融分布式核心系统、新型数据库、出海的思考、大前端架构等角度与你探讨，点击了解详情。</p>",
    "publish_time": "2023-03-09 15:41:30",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "物理界限日益模糊，制造业数据安全怎么办？",
    "url": "https://www.infoq.cn/article/FhaP7UHEg9B343zbMUb0",
    "summary": "<p>最近，“数据要素”这个词的“出场率”有点高。</p><p></p><p>日前发布的《<a href=\"https://www.infoq.cn/article/LBC3Rujd6xFoYfS2duGf\">数字中国建设整体布局规划</a>\"》指出，数字中国建设的两大基础包括数字基础设施大动脉以及数据资源大循环的打通，并且强调了“释放商业数据价值潜能，加快建立数据产权制度，开展数据资产计价研究，建立数据要素按价值贡献参与分配机制”。</p><p></p><p>而根据国务院关于提请审议国务院机构改革方案的议案，我国将组建<a href=\"https://www.infoq.cn/article/CUzrDiwNemwvhoVNCQ1V\">国家数据局</a>\"，主要职责包括统筹推进数字经济发展、组织实施国家大数据战略、推进数据要素基础制度建设、推进数字基础设施布局建设等职责。</p><p></p><p>数据要素的价值被反复提及，但与此同时，这背后还折射出另一个问题——数据要素的采集、传输、处理、应用等一系列过程，如果缺乏安全屏障，可能对企业经营甚至经济和社会安全造成隐患。</p><p></p><p>对于制造业而言，在加速数字化转型的过程中，同样面临着全新的风险和挑战。&nbsp;举例来说，<a href=\"https://www.infoq.cn/theme/150\">制造业</a>\"数字化强调OT、IT、CT和&nbsp;DT的融合，这意味着，背后的设备、控制、网络和平台将变得越来越开放，传统的物理界限将越来越模糊，这必然导致攻击点的增多、风险可控性的降低等等，过去单点的安全防护措施已然无法满足企业需求。</p><p></p><p>那么，面对这一系列全新挑战，制造企业如何建立全面化、体系化的网络安全防护屏障？关于这一问题，在日前由WRE&nbsp;DIGITAL主办，中国能源研究会信息通信专委会、上海市航空学会、上海市汽车工程学会等单位支持的“第四届高端制造业CIO上海论坛”上，InfoQ采访了天威诚信解决方案中心高级总监罗贇。</p><p></p><p>以下为采访实录（经编辑整理）：</p><p></p><h5>InfoQ：在制造业数智化转型的大背景下，制造企业面临哪些新的安全威胁？</h5><p></p><p></p><p>罗贇：如今大家都在讲制造业数智化转型，关键是要把生产、库存、物流等产业链条，通过信息化、数智化的方式来实现，这其中有几个核心点，首先是平台加数据，而一旦有了数据，就意味着<a href=\"https://xie.infoq.cn/article/2bb6f89c6d7dc6dfa6410ef09\">数据安全</a>\"问题变得越来越重要。</p><p></p><p>更重要的是，数据不仅仅是一个企业的生成经营要素，甚至还会影响到国家安全。制造业作为国民经济的主体，必须重视网络数据安全，一旦出现数据泄露，影响的就绝不仅仅是社会发展。</p><p></p><p>虽然在过去的信息化阶段，各个企业也在上系统，系统上也有大量数据，但是它们之间大多是割裂的，安全防护需求都是从各个业务部门自身的角度出发提出的；现在，随着数字化的推进和平台化的建设，数据的流转越来越多，就必须从整体战略规划角度来看安全问题。</p><p></p><h5>InfoQ：面对这些新的挑战，您觉得企业该如何防范？</h5><p></p><p></p><p>罗贇：随着信息系统的一体化建设，企业已不能再局限于某一个业务层面的安全，而是站在整个数智化转型这样更高的角度去做整体的规划。这里面包括很多维度，比如要考虑政策合规，要考虑技术团队建设，要打通各环节数据等等。</p><p></p><p>首先，企业需要从战略规划方面进行充分考虑，近两年国家层面相继出台了很多法律法规，比如《中华人民共和国网络安全法》、《中华人民共和国密码法》，以及《个人信息保护法》等，在这样的大环境下，就要符合各种合规要求；</p><p></p><p>其次，企业必须建安全团队，建安全制度，然后设置底层的基座，再设计相应的标准，这是一套完整的动作，不是买一个产品或者解决方案那么简单。就像建房子，我们需要设计图纸，需要施工队，需要验收，然后还要打地基，这样的话，才能把整个数字化转型和数字安全两条线同步进行了。</p><p></p><p>其实网络安全风险无处不在，网络安全的范畴很大，包括很多应用层面，比如说通讯安全以及网络交互中的各类场景，它的核心底层采用的都是密码技术。从这一点来说，密码作为一个互联网基础设施，在任何行业都有很广泛很深入的应用。其核心就是为了保证企业关键数据不泄露、不被篡改，为企业的数智化转型提供安全基石，筑起可信安全防线。</p><p></p><h5>InfoQ：过去，企业每套系统可能都有自己的密码管理方案，现在系统打通之后，如何进行密码的统一管理？</h5><p></p><p></p><p>罗贇：首先，要把密码服务平台底座建立起来，包括对密码设备或密码资产进行盘点，哪些要保留，哪些要舍弃，哪些要采购等等。未来，国家慢慢会推广国产密码算法，这意味着企业中有些设备会陆陆续续被淘。</p><p></p><p>在底座建立之后，还要进行统一密码服务能力的对外输出。对此，天威诚信就是提供一个整体的密码服务管理解决方案，通过统一的密码服务管理，保障企业数智化转型和数据安全两条线同步进行。</p><p></p><p>比如，涉及物流业务需要用到电子签章服务，IT部门需要做一些身份认证，运维部门或大数据部门需要做数据加密，都可以通过我们的密码服务管理平台来做统一调度，而且对各自的业务数据不产生任何影响，平台会做数据的隔离，保障各自业务层的安全。</p><p></p><h5>InfoQ：在工业互联网领域里面，涉及产业供应链的很多上下游企业，这种情况下安全问题怎么解决？</h5><p></p><p></p><p>罗贇：一个从供应链的上下游最先考虑的是身份认证问题，密码技术就是解决网络世界中身份认证的可靠手段。另外，在供应链中会产生很多订单和数据流转，涉及公章管理、合同签订、资金交易、物流管理等等，这些都可以是智能化的。</p><p></p><p>试想，如果订单数据出现了篡改或偏差，就会对生产环节带来极大的风险，生产出来的产品就会出现质量问题，所以在<a href=\"https://xie.infoq.cn/article/8f6cdf96ec510cc0552e7aeb7\">工业互联网</a>\"领域，保证上下游的全局性和数据的完整性是十分重要的。</p><p></p><p>要保障供应链上下游的网络和数据安全，就需要密码技术做支撑，基于密码技术和平台化管理，会对供应链中的订单做一个电子签名，签名中包含了一套公钥信息，可以对电子签名进行加密和验证，以达到防篡改的目的，当然这套技术是有国家标准的，只有符合国家标准和行业规范的密码产品才能拿到国家许可资质，才能提供商业密码的建设和保障能力，目前，天威诚信已经拥有《电子认证服务许可证》《电子认证服务使用密码许可证》的可信电子认证。</p><p></p><h5>InfoQ：您觉得制造业跟其他的行业相比，对于网络安全或者说密码管理的需求会有什么差异吗？</h5><p></p><p></p><p>罗贇：从密码技术在各个领域的应用来看，电子政务永远是第一梯队，其次是金融、教育、医疗、能源等领域，但随着数智化转型进程的加快，制造业对网络安全和密码管理的需求在逐步上升。</p><p></p><p>首先是有国家政策的指引，其次有行业发展的需求，国内很多制造企业对数据安全的重视度很高，他们一直在探求生产数据、经营数据的保护之道，比如企业的设计图纸、研究成果、资金和客户管理系统等，一旦数据泄露，后果将非常严重。</p><p></p><p>针对这些需求，我们通过密码技术赋能制造企业的生产、管理等各环节，例如在内部系统访问，提供基于密码KPI的可信身份认证登录；在外部互联网访问中，基于服务器证书提供数据传输安全；在内外部访问中提供数据防篡改、数据可信凭证等。通过密码管理与服务构建一个可信的生态系统，从而加速推进行业的数智化进程，同时逐步进行国产化适配和替代，通过我们的国产适配能力，在构建系统底层安全的基础上来做国产化的识别和对接，保证企业生产、经营数据防泄漏，实现整体的自主安全可控。</p><p></p><p>作为互联网发展安全基石，密码已广泛应用融入到全面的社会和生活当中，成为当代社会信任机制的底层支撑技术。随着全行业数智化转型进程的不断加快，密码技术也迎来了多场景应用新机遇，5G、工业互联网、物联网、车联网领域的创新应用，都需要密码对新技术、新场景提供支持。</p><p></p><p>作为密码领域的重要角色，天威诚信这样的密码技术服务商任重道远，我们期望，在各密码技术服务商的共同努力下，密码技术能能更好更快地与各业务场景相融合，不断强化技术、场景、服务等全方位应用，展现更大的安全价值。</p>",
    "publish_time": "2023-03-09 15:45:08",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "元年科技李彤：企业数字化切入点有三，单业务场景创新、技术平台重建或数据能力建设",
    "url": "https://www.infoq.cn/article/SvZImNmazpgcSjqh9t1p",
    "summary": "<p>2023年3月3日，中国信通院高质量数字化转型创新发展大会暨中国信通院“<a href=\"https://www.infoq.cn/news/ayoRDx1sfgLSTt4pGaDl\">铸基计划</a>\"”年度大会顺利召开。</p><p></p><p>本次大会是由中国信息通信研究院主办的通信领域重要会议，大会深度展示了中国信通院在数字化领域的工作成果，并全面展望了2023年行业的数字化发展趋势。大会发布了中国信通院“铸基计划”在金融、体育、电信、双碳等领域数字化转型的研究成果，邀请了500余名来自全行业的商界领袖和专家学者，共同聚焦数字化转型高质量发展，对2023年数字化转型发展趋势进行深刻探讨，为产业发展提供参考。</p><p></p><p>元年科技董事、执行总裁李彤在会上发表主题演讲，带来了题为《企业数字化转型技术发展趋势研究》的主题演讲并接受记者采访。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/6c/a0/6cb5d0216f316d2df011d87bc8f708a0.jpg\" /></p><p></p><p>李彤认为，<a href=\"https://www.infoq.cn/article/CUzrDiwNemwvhoVNCQ1V\">数字化转型</a>\"已经不是“要不要”的问题，而是必须应对的社会化潮流，企业必须从产品形态、商业模式、组织模式、管理模式和运营模式等维度进行全方位的改变。相较于信息化阶段对历史数据的记录，数字化更强调在线实时对高质量、海量数据的掌握，并基于数据和算法，提升企业运营效率及跨空间的指数级增长。这意味着，技术的应用将成为企业未来发展的核心竞争力。</p><p></p><p>那么，企业究竟如何开展数字化转型实践？李彤表示，企业数字化必须从顶层设计，从企业愿景、战略到目标切入，从而定位转型的核心方向。在此基础上，进行整体规划、分步实施，从单点应用场景切入，带动线到面到体的完整数字化实践路径。</p><p></p><p>“我们认为，企业架构方法论对数字化转型仍然非常有效。首先，必须厘清企业的业务架构，在新的技术环境下，新的生产要素增加的情况下，企业的经营、产品形态、组织模式会发生什么变化。其中会有两个输出，一是对于我们的组织架构和组织模式以及业务流程的改变，因为新的模式下面，如果组织和流程不变，肯定无法有效应用这样的变革；第二，必须通过信息技术的架构去支撑业务架构的转型。这里边包括新的应用架构设计，新的数据架构的设计以及支撑这两个架构的技术架构设计。”</p><p></p><p>李彤强调，企业做数字化转型有三个主要的切入点：要么从单一的业务场景切入，要么从技术平台的重新构建的视角切入，要么从数据的视角构建数据平台的视角切入，最终形成数据驱动和数据智能的能力。</p><p></p><p>此外，李彤还在接受包括InfoQ在内的媒体记者采访时介绍了<a href=\"https://www.infoq.cn/article/ct6oJpRUKpNUmROobVFz\">元年科技</a>\"的基本发展。作为一家有20年历史，从管理会计领域起步的公司，元年科技在发展过程中持续深耕财务领域，并在近年进行了战略升级。2020年以来，元年科技基于原先在财务领域的经验积累，大力投入数字化技术，帮助企业进行财务系统的数字化转型升级。</p><p> </p><p>李彤表示，元年科技在数字化建设上有两大优势。一个是元年科技对于财务数据理解和运用上的深厚基础，元年科技吸收国外技术并自主创新研发的内存多维数据库是企业数字化决策领域一项强有力的技术产品，将庞大而精细的数据从上到下赋能企业的高层、中层和基层，帮助他们进行决策、管理、业务处理，这在大体量的用户群上得到了验证；第二个优势是元年科技在PaaS构建领域的优势，元年在2017年重构原有的技术平台建立方舟PaaS平台，用微服务引擎化组建的方式解耦化，提供了十大引擎对数字化转型支撑。这两个优势结合元年科技的咨询背景构成了数字化转型领域的独特优势。</p><p></p><p>对于中国企业数字化转型的现状，李彤认为要分类看待。对于有互联网基因的数字原生企业，他们在业务端数字化水平较高，但在决策端和管理端相对偏弱，尤其是管理会计的应用还处在初级方面。而对于大量传统行业的企业，数字化转型仍处在局部探索，在部分节点上思考如何用数字化技术解决市场营销领域问题的阶段，离企业整体的在线化还有很大差距。传统行业的大型企业会对管理会计领域比较重视，但相关数字化应用水平也处在初级阶段。对此，李彤表示在未来中国数字化转型市场上，企业发展的空间是非常巨大的，同时对服务商的能力要求和服务需求也是巨大的。</p><p> </p><p>展望2023年，李彤认为在疫情趋缓的大背景下，一季度市场快速启动，企业端需求非常旺盛。元年科技今年除了继续做好传统核心业务外，也会积极响应国家的国产替代化、金税四期等等需求，将产品体系做得更加全面，同时加大新一代ERP应用端的产品研发和生态建设，赋能企业实现完整的数字化转型。</p><p> </p><p>元年科技深度参与了中国信通院企业数字化转型的研究工作，李彤高度评价了中国信通院“铸基计划”。他认为“铸基计划”作为一个平台，有效地将整个产业在研究上的思考、在行业内的服务能力、服务商资源整合在一起，把市场上的需求也整合起来。这样一个平台可以全方位不断推进数字化转型，元年科技希望持续加强与中国信通院的合作，在“铸基计划”中扮演更加重要的角色，也希望“铸基计划”形成多方协同的平台，把中国企业的数字化转型推上更成熟的状态。</p>",
    "publish_time": "2023-03-09 15:54:44",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "国内首例社区双栈Istio方案落地经验，实现代码已开源",
    "url": "https://www.infoq.cn/article/iyuaBJ1GmJ3xwk8uJQLf",
    "summary": "<p>本文整理自中国移动云能力中心高级软件工程师、Istio 社区 Member 张海文和 Intel 云原生开发工程师、Istio 的维护者和 Linkerd 的开发者张怀龙老师在 QCon 全球软件开发大会（北京站）的演讲《移动云服务网格双栈技术的实践之路》，<a href=\"https://qcon.infoq.cn/202302/beijing/presentation/4898\">点此下载完整幻灯片。</a>\"</p><p></p><h1>背景介绍</h1><p></p><p></p><p>众所周知，由于 IPv4 地址的消耗殆尽，且在未来 5G 和物联网等行业趋势的推动下，IPv6 地址的普遍运用是大势所趋。然而网络中主要服务提供商在网络及其应用全部升级到 IPv6 协议之前，通信兼容是必须要解决的问题，而双协议栈技术在其中必将扮演着举足轻重的角色。</p><p></p><p>所谓双栈是双协议栈 (Dual Stack) 技术的简称，即是指在一台设备上同时启用 IPv4 和 IPv6 两套协议栈。因此该设备既能和 IPv4 网络端点通信，又能和 IPv6 网络端点通信。网络端点一般是指通信端节点，包括主机和路由器等设备。尽管有其他技术（比如网络隧道和 NAT-TP 技术等）可以使得 IPv6 结点保持与纯 IPv4 节点的通信兼容，但双栈技术始终是最直接的方式。</p><p></p><h2>移动云双栈需求</h2><p></p><p></p><p>随着使用 IPv6 成为大势所趋，2020 年工信部发布了《工业和信息化部关于开展 2020 年 IPv6 端到端贯通能力提升专项行动的通知》(工信部通信函〔2020〕57 号)【1】，其中提到一项重点工作任务为大幅提升包括移动云在内的多个云服务平台 IPv6 业务承载能力，2021 年工信部和网信办又发布了《两部门关于印发《IPv6 流量提升三年专项行动计划（2021-2023 年）》的通知》（工信部联通信〔2021〕84 号）【2】, 为了全面落实国家部门关于 IPv6 提升的专项行动计划，移动云将通过双栈方式实现公有云产品 IPv4/6 访问作为 2022 年重点工作。</p><p></p><p>移动云绝大部分公有云产品都实现了云原生化，Istio 作为云原生服务网格领域主流技术，在移动云上获得了广泛的使用，目前将近 50 款产品通过 Istio 及生态组件进行灰度发布、流量治理及服务可观测，为移动云产品快速迭代、线上稳定提供了有力支撑。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/12/12228e6a72ba706e7513809cae46f8f7.png\" /></p><p></p><p>图一：移动云服务网格架构图</p><p></p><p>但由于 Istio 在双栈技术上的缺失，移动云产品面临双栈访问需求和 Istio 使用需求的矛盾，急需 Istio 在双栈技术方面的实现方案解决这个问题。</p><p></p><h2>云原生领域 IPv4/6 双栈介绍</h2><p></p><p></p><p>随着云计算及云原生相关标准和技术的普遍运用落地，Kubernetes 容器编排系统和服务网格（Service Mesh）等基础技术得到行业的深度应用。其中，Kubernetes 的双栈支持作为测试特性早在 Kubernetes v1.16（alpha）就已经存在，并在进行了全面测试以后，双栈特性作为功能完备的特性被集成在 Kubernetes v1.21 之中，自从 Kubernetes v1.22 开始，Kubernetes 双栈技术的支持已经被作为稳定的特性而存在，并于 Kubernetes v1.23 版本中进入正式发布（GA）阶段【3】。同时越来越多的云服务提供商也为双栈 Kubernetes 集群提供了支持。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/7d/7dc138929ba33eeb6c8d4ce100859e80.png\" /></p><p></p><p>图二：Kubernetes 双栈技术发展时间线</p><p></p><p>尽管如此，在业界广泛应用的服务网格项目（以大家所熟知且应用最为广泛的 Istio 和 Linkerd 为例）中，双栈技术的支持依然是缺失的。</p><p></p><p>为了更好的实现服务网格与 Kubernetes 在双栈支持上的协同工作，满足移动云等用户在 Istio 双栈方面的需求，本文主要介绍了服务网格的代表项目 Istio 在双栈技术中的实现方案以及该方案在移动云的落地实现场景。</p><p></p><h1>Istio 双栈解决方案</h1><p></p><p></p><p>本文对 Istio 的双栈支持的实现方案主要参考社区提议（Proposal）【4】。根据其设计思路并基于 Istio v1.14-dev 的版本进行代码改造。同时，目前的实现代码已经放到社区的 Istio repository 中一个名为 experimental-dual-stack 的分支【5】。</p><p></p><h2>双栈方案实现</h2><p></p><p></p><p>根据目前从社区以及各个厂家的实践情况来看，双栈技术方案主要有如下三个：开启 IPv4 协议栈兼容的方案（IPv4-Compat 方案）基于生成重复协议栈的方案（Istio Dual Stack Proposal）基于方案二的优化 – 消除重复配置并提升可扩展性（Istio Dual Stack Optimization Proposal）下面我们基于上述的三个方案分别展开评估。</p><p></p><p>方案一：开启 IPv4 协议栈兼容的方案（IPv4-Compat 方案）</p><p></p><p>优点：</p><p></p><p>修改代码最少，且无需修改过多核心代码可以实现网格内部 service 最基本的双栈需求</p><p></p><p>缺点：</p><p></p><p>依赖数据面的 flag（ipv4_compat）控制协议兼容对于单集群服务网格中引入非网格内的服务时，会导致服务不可用的情况（网格内服务访问普通 K8s service 失败）对多集群服务网格之间的服务访问也存在上面两点问题</p><p></p><p>方案二：基于生成重复协议栈的方案（Istio Dual Stack Proposal）</p><p></p><p>如果用户的 Istio 启用了双栈特性（通过引入环境变量 ISTIO_DUAL_STACK 来启用），那么 Istio 控制面会为用户的边车代理同时创建基于 IPv4 和 IPv6 协议栈所需的各类 xDS 配置资源，这些由 Istio 控制面下发的核心配置资源包括 LDS，RDS，CDS 和 EDS。如图三所示。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/71/7131dd7940131d1a858d606a2e34791e.png\" /></p><p></p><p>图三：Istio 实验分支双栈支持示意图</p><p></p><p>优点：</p><p></p><p>能够完整的实现双栈支持，并且与 Kubernetes 的双栈无缝结合对于单集群的外部服务引入以及多集群之间的服务访问都能很好支持没有相关依赖，在 Istio CNI 和 Calico IPVS 开启时都能正常工作</p><p></p><p>缺点：</p><p></p><p>需要改动大量 Istio 核心代码对于任意双栈 service 会生成几乎重复的服务网格配置，造成数据面的资源损耗</p><p></p><p>方案三：基于方案二的优化 – 消除重复配置并提升可扩展性（Istio Dual Stack Optimization Proposal）</p><p></p><p>本方案需要服务网格的控制面和数据面一起进行修改，目前依然在继续努力中，但是在社区已经取得相应的进展，并将于即将发布的 Istio 1.17 中实现基本的双栈特性支持。具体的实现思路如图 4 所示。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/c3/c3dfd018993f9511fa67edef73f7e497.png\" /></p><p></p><p>图四：Istio 主干分支双栈支持示意图</p><p></p><p>优点：</p><p></p><p>拥有方案二中的所有优点消除了方案二中存在的重复配置，降低了资源损耗</p><p></p><p>缺点：</p><p></p><p>需要同时改动控制面和数据面的代码</p><p></p><p>最终选型落地方案</p><p></p><p>根据上述三个方案的对比分析，方案一首先被排除，其次由于方案三的实现时间不可控，于是果断选取了方案二的实现方式，同时等待方案三合并到主干分支以后再循序渐进的切换。</p><p></p><p>图五展示了 Istio 双栈支持在社区中的支持时间线：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/80/804f62596b54f5c0031db9b97927d7c3.png\" /></p><p></p><p>图五：Istio 双栈技术发展时间线</p><p></p><p>除此以外，方案中对 Istio 双栈实现的软件组件有如下基本要求：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/c3/c3c4b3e4d8ff955d8a9760b75376e3ee.png\" /></p><p></p><p>表一：Istio 双栈软件组件基本要求</p><p></p><h1>落地场景</h1><p></p><p></p><p>基于对 IPV4/IPV6 双栈的市场 / 客户需求, 英特尔携手移动云梳理了 Istio 在移动云上的落地场景，抽象出对应的模型 Demo 进行测试验证（目前 Istio 经典 Demo bookinfo 部分微服务不支持双栈，不能使用 bookinfo 进行验证）, 共同排查遇到问题并将解决代码贡献给社区，最终双栈方案通过了所有测试。</p><p></p><p>测试环境为 3 台物理机构成的一套 Kubernetes 集群。</p><p></p><p>物理机硬件配置如下：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/cc/cc2a487fba10c8a7e1dc4700b47b6f1f.png\" /></p><p></p><p>表二：Istio 双栈实现硬件配置表</p><p></p><p>软件组件相关信息如下：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/d3/d34fc11d65b3047fbc3e27f7c75b70a3.png\" /></p><p></p><p>表三：Istio 双栈实现软件组件配置表</p><p></p><h2>灰度发布</h2><p></p><p></p><p>Istio 在移动云中应用最广泛的场景是灰度发布，灰度发布细分场景较多，按照产品在 Kubernetes 集群中的部署方式，可以分为单租户和多租户场景下的灰度发布，按照灰度发布范围，可以分为入口微服务灰度发布、内部微服务灰度发布、全链路微服务灰度发布。</p><p></p><p>我们进行了单租户和多租户场景下的灰度发布测试，在单租户场景中又按灰度发布范围进行了细分场景测试，以下是我们的测试验证介绍。</p><p></p><h3>单租户</h3><p></p><p></p><p>单租户场景即 Istio 部署模型中的 Single Cluster 模型【6】在移动云中的应用，指一款产品独占一套 Kubernetes 集群，并部署在一个 namespace 中，通过一套 Istio 管理该 Kubernetes 集群，这是最简单部署场景。</p><p></p><h4>入口微服务灰度发布</h4><p></p><p></p><p>入口微服务灰度发布指对产品入口处微服务进行灰度发布的场景，该场景需要 Istio Ingress Gateway 结合入口微服务进行灰度发布。我们的验证模型架构图如下：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/3a/3a86411bda05a8c187a4cb3178696190.png\" /></p><p></p><p>图六：入口微服务灰度发布模型</p><p></p><p>数据面流量通过 Istio Ingress Gateway，转到微服务 foo，正常请求访问 v0.0.1 版本 foo 服务，通过 HTTP 请求 Header 中设置 key-value 对，key 为 version，value 为 v0-0-2，流量流转到 v0.0.2 版本的 foo 服务。</p><p></p><h4>内部微服务灰度发布</h4><p></p><p></p><p>内部微服务灰度发布指对产品内部的微服务进行灰度发布的场景，我们的验证模型架构图如下：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/1d/1d2c30fb9dee23426ea30ef27d605522.png\" /></p><p></p><p>图七：内部微服务灰度发布模型</p><p></p><p>上游访问 client 服务，client 服务再请求 provider 服务, provider 提供两个版本的服务：v0.0.1 和 v0.0.2，正常情况下访问 v0.0.1 的服务，当 Header 中设置 key-value 对，key 为 version，value 为 v0-0-2 时，流量流转到 v0.0.2 版本的 provider 服务。</p><p></p><h4>全链路微服务灰度发布</h4><p></p><p></p><p>全链路微服务灰度发布指在产品微服务链路中，对多个微服务进行灰度发布及验证的场景。我们的验证模型架构图如下：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/eb/eb4d18eb7e5acda9046e125783b40eff.png\" /></p><p></p><p>图八：全链路微服务灰度发布模型</p><p></p><p>用户通过 Istio Ingress Gateway 访问 client 服务，client 服务再请求 provider 服务。client 提供两个版本的服务：v0.0.1 和 v0.0.2，正常情况下访问 v0.0.1 的服务，当用户通过 Gateway 访问 client 服务时，Header 中设置 key-value 对，key 为 clientVersion，value 为 v0-0-2 时，流量流转到 v0.0.2 版本的 client 服务。provider 也提供两个版本的服务：v0.0.1 和 v0.0.2，正常情况下访问 v0.0.1 的服务，当用户通过 Gateway 访问 client 服务时，Header 中设置 key-value 对，key 为 providerVersion，value 为 v0-0-2 时，流量流转到 v0.0.2 版本的 provider 服务。</p><p></p><h3>多租户</h3><p></p><p></p><p>多租户场景即 Istio 部署模型中的 Namespace Tenancy 模型【7】在移动云中的应用，指多款产品共享一套 Kubernetes 集群，每款产品部署在单独的 namespace 中，通过探索的多租户场景部署方案【8】，实现多款产品共享控制面，独占数据面的场景。</p><p></p><p>我们在多租户场景下进行了入口微服务灰度发布细分场景的测试验证，验证模型架构图如下：</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/c8/c89517bc765bca50e78fb97f4bfc9ff4.png\" /></p><p></p><p>图九：多租户入口微服务灰度发布模型</p><p></p><p>foo 和 bar 两款产品共享一套 Kubernetes 集群，foo 和 bar namespace 下分别部署 foo、foo 独占的 Istio Ingress Gateway 及 bar、bar 独占的 Istio Ingress Gateway。</p><p></p><p>产品 foo 的访问流量通过 foo namespace 的 Istio Ingress Gateway，转到微服务 foo，正常请求访问 v0.0.1 版本 foo 服务，通过 HTTP 请求 Header 中设置 key-value 对，key 为 version，value 为 v0-0-2，流量流转到 v0.0.2 版本的 foo 服务。产品 bar 同理。</p><p></p><h3>流量治理</h3><p></p><p></p><p>我们选择移动云产品广泛使用的限流功能进行了流量治理相关的验证测试。我们对入口微服务灰度发布场景中 foo 服务应用限流规则，通过 fortio 向 Istio Ingress Gateway + foo 应用发起 IPv4 和 IPv6 协议的并发请求，请求结果符合限流预期。</p><p></p><h3>可观测性</h3><p></p><p></p><p>我们按照 Istio 官方的运维组件集成文档【9】，在双栈环境中集成部署了 Prometheus、Kiali、Jaeger 等可观测性组件。通过双栈方式请求 Istio 纳管的验证 Demo，查看 Kiali 和 Jaeger 系统功能，均符合预期。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/6d/6dc6b5873c7e0a5ca7a952eda3c4753b.png\" /></p><p></p><p>图十：Kiali 服务拓扑图</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/cb/cb97abcaee210f799a403f5806ca4d1e.png\" /></p><p></p><p>图十一：Jaeger 链路追踪图</p><p></p><h1>总结与展望</h1><p></p><p></p><p></p><h2>移动云双栈落地总结与展望</h2><p></p><p></p><p>Istio 双栈方案通过验证后，我们第一时间将方案落地，把双栈版 Istio 集成到移动云云原生平台产品中并进行了充分测试，使其成为了国内首款为客户提供在双栈环境下通过 Istio 进行灰度发布、流量治理、服务拓扑、链路追踪等能力的产品【10】；同时我们和多款移动云产品进行试点对接并完成上线，未来会有更多移动云产品通过 Istio 实现双栈访问、灰度发布、流量治理及服务观测。</p><p></p><h2>社区双栈特性总结与展望</h2><p></p><p></p><p>事实上，社区是非常欢迎 Istio 双栈特性能够被支持的，并且有许多企业级的用户正在想办法完成他们自己的双栈实现，正因为如此才有 Istio 双栈特性在独立的分支上持续演进。</p><p></p><p>基于当前的实现虽然能够满足双栈的支持，但是其最大的问题在于 Istio 的控制面分别为 IPv4 和 IPv6 家族地址生成了重复的边车代理配置信息，这会带来更多的资源损耗。因此，最终的方案是消除这些重复的配置信息，并将双栈特性的最终实现推进到 Istio 的主干分支中。</p><p></p><p>目前为了实现这个目标，Intel 和 Aspen Mesh 等企业正积极的在 Istio 和 Envoy 社区合作，并推进这项工作。而且目前也取得了很多实质性的进展。相信在不远的未来，Istio 的双栈特性的支持将会变得越来越好，而 Istio 也将会成为更多用户首选的服务网格产品。</p><p></p><p>另外值得一提的是，当前的实现方案由于是实验性的分支，因此并没有完善单元测试和集成测试，但是一些企业级用户已经基于当前的代码实现完成了数百个测试用例的校验，因此对于基本通用的用户场景的校验已经是完成了的。同时需要补充一点，根据当前的实现版本，Istio CNI 和 Calico IPVS 等特性都已经做过验证。我们欢迎并鼓励更多有双栈需求的用户在非生产环境上去体验 Istio 的双栈支持，同时如果有任何问题需要交流，也请踊跃加入我们 Istio 社区的 slack channel: #dual-stack-support 。</p><p></p><p>[1]:&nbsp;<a href=\"http://www.gov.cn/zhengce/zhengceku/2020-03/23/content_5494661.htm\">http://www.gov.cn/zhengce/zhengceku/2020-03/23/content_5494661.htm</a>\"</p><p></p><p>[2]:&nbsp;<a href=\"https://www.miit.gov.cn/zwgk/zcwj/wjfb/txy/art/2021/art_3c42d01d124b426e98b4400830da8fd8.html\">https://www.miit.gov.cn/zwgk/zcwj/wjfb/txy/art/2021/art_3c42d01d124b426e98b4400830da8fd8.html</a>\"</p><p></p><p>[3]: <a href=\"https://kubernetes.io/zh-cn/blog/2021/12/08/dual-stack-networking-ga/\">https://kubernetes.io/zh-cn/blog/2021/12/08/dual-stack-networking-ga/</a>\"</p><p></p><p>[4]: <a href=\"https://docs.google.com/document/d/1oT6pmRhOw7AtsldU0-HbfA0zA26j9LYiBD_eepeErsQ/\">https://docs.google.com/document/d/1oT6pmRhOw7AtsldU0-HbfA0zA26j9LYiBD_eepeErsQ/</a>\"</p><p></p><p>[5]: <a href=\"https://github.com/istio/istio/tree/experimental-dual-stack\">https://github.com/istio/istio/tree/experimental-dual-stack</a>\"</p><p></p><p>[6]: <a href=\"https://istio.io/latest/docs/ops/deployment/deployment-models/#single-cluster\">https://istio.io/latest/docs/ops/deployment/deployment-models/#single-cluster</a>\"</p><p></p><p>[7]: <a href=\"https://istio.io/latest/docs/ops/deployment/deployment-models/#namespace-tenancy\">https://istio.io/latest/docs/ops/deployment/deployment-models/#namespace-tenancy</a>\"</p><p></p><p>[8]: <a href=\"https://cloudnative.to/blog/istio-multi-tenancy-exploration/\">https://cloudnative.to/blog/istio-multi-tenancy-exploration/</a>\"</p><p></p><p>[9]: <a href=\"https://istio.io/latest/docs/ops/integrations/\">https://istio.io/latest/docs/ops/integrations/</a>\"</p><p></p><p>[10]: <a href=\"https://ecloud.10086.cn/home/support/cloudnative\">https://ecloud.10086.cn/home/support/cloudnative</a>\"</p><p></p><p></p><h3>作者简介</h3><p></p><p></p><p>张怀龙，Intel 云原生开发工程师，拥有丰富的云计算开发经验，曾参与百度运维部运维 PaaS 平台的研发工作，通过开源和企业级项目开发 IBM 公有云 PaaS 监控解决方案 Marmot，之后通过运用开源及企业级应用，比如 Prometheus、Sysdig、NewRelic、InfluxDB、Grafana 等技术实现 IBM 公有云新一代 PaaS 平台监控系统的迁移方案。现就职于英特尔开源技术中心，参与云原生项目服务网格相关的研发工作。并担任 Istio 的维护者和 Linkerd 的开发者。Github ID: zhlsunshine</p><p></p><p>张海文，中国移动云能力中心高级软件工程师、Istio 社区 Member。拥有丰富的互联网及云原生开发经验，先后在京东，百度等互联网公司从事搜索广告系统开发，现就职于中国移动云能力中心，专注于云原生和服务网格相关产品的研发，目前为公司服务网格负责人，先后实现近 50 款移动云产品服务网格落地实践。</p><p></p><p>今年 5 月，<a href=\"https://qcon.infoq.cn/2023/guangzhou/track\">QCon全球软件开发大会</a>\"即将落地广州，从下一代软件架构、金融分布式核心系统、现代编程语言、AIGC、现代数据架构、新型数据库、业务出海的思考、大前端变革等角度与你探讨。</p><p></p>",
    "publish_time": "2023-03-09 16:29:01",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]