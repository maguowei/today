[
  {
    "title": "构建重启后依然可用的Windows服务",
    "url": "https://www.infoq.cn/article/sj95UdY5Vqp9Hcxd5XlZ",
    "summary": "<p>当使用C++为Windows编程时，使用Windows服务（Windows Services）几乎是难以避免的。在微软Windows操作系统中，Windows服务发挥着重要的作用，它们能够创建和管理长时间运行的进程，这些进程能够在睡眠、休眠、重启和关机的过程中幸存下来。但是，如果无法做到这一点会怎样呢？在选中<a href=\"https://www.howtogeek.com/243901/the-pros-and-cons-of-windows-10s-fast-startup-mode/\">快速启动（Fast Startup）</a>\"时，关闭计算机会导致服务无法重启，这会给程序带来灾难性的后果。微软在Windows Vista中引入的<a href=\"https://msrc-blog.microsoft.com/2008/10/13/service-isolation-explanation/\">Service Isolation</a>\"可能会导致这类灾难性的后果，在本文中将会阐述如何解决它。</p><p></p><h2>感谢Windows服务</h2><p></p><p></p><p>多年以来，我们一直在使用Windows服务，但是不管我们觉得有多么了解服务，或者有多么自信能够处理它，却始终会遇到更多的问题、挑战和麻烦。其中有些问题根本是没有文档的，或者我们“幸运”一点的话，会有一点糟糕的文档。</p><p></p><p>自从微软引入<a href=\"https://msrc-blog.microsoft.com/2008/10/13/service-isolation-explanation/\">服务隔离</a>\"之后，我们遇到的最令人恼火的问题之一就是当<a href=\"https://www.howtogeek.com/243901/the-pros-and-cons-of-windows-10s-fast-startup-mode/\">快速启动</a>\"选中时，计算机关闭后，无法重启服务。鉴于我们没有找到现成的解决方案，所以我们决定自动动手实现一个，这促成了持久化服务的开发。</p><p></p><p>但是，在深入研究和解释我们的解决方案之前，我们首先从基础知识开始，解释什么是服务，以及为什么要使用Windows服务。</p><p></p><p>NT服务（也叫做Windows服务）指的是由NT内核的服务控制管理器（Service Control Manager）加载的特殊进程，它会在Windows启动（在用户登录前）立即在后台运行。我们使用服务来执行核心和底层的操作系统任务，比如Web服务、事件日志、文件服务、帮助和支持、打印、加密和错误报告。</p><p></p><p>此外，服务使我们能够创建可执行的、长时间运行的应用程序。原因在于服务会在自己的Windows会话环境中运行，所以它不会干扰应用程序的其他组件或会话。显然，我们期望服务会在计算机启动后也自动启动，我们马上就会讨论该问题。</p><p></p><p>进一步来讲，这里显然有一个问题：我们为什么需要持久化的服务？答案很明显，服务应该能够：</p><p></p><p>持续在后台运行。在已登录用户的会话中，调用自身。作为一个看门狗（watchdog），确保给定的应用程序一直在运行。</p><p></p><p>Windows服务需要能够在睡眠、休眠、重启和关机时依然能够存活。但是，正如前文所述，当选中“<a href=\"http://www.howtogeek.com/243901/the-pros-and-cons-of-windows-10s-fast-startup-mode/\">快速启动</a>\"”时，计算机关机再启动的话，会出现一些特定的危险问题。在大多数场景中，服务无法重新启动。</p><p></p><p>因为我们正在开发的是一个反病毒软件，它应该在重启或关机后重新启动，这种情况造成了一个严重的问题，我们迫切需要解决它。</p><p></p><h2>实现良好的服务</h2><p></p><p></p><p>为了创建近乎完美的持久化Windows服务，我们必须首先解决几个底层的问题。</p><p></p><p>其中一个问题与服务隔离有关，被隔离的服务无法访问与任何特定用户相关的上下文。我们某个软件产品将数据存储到了c:\\users\\\\appdata\\local\\中，但是当它从我们的服务中运行的话，这个路径就是无效的，因为服务是在Session 0中运行的。除此之外，在重启后，服务会在所有用户登录之前启动，这形成了解决方案的第一部分：等待用户登录。</p><p></p><p>为了弄清如何做到这一点，我们<a href=\"https://www.codeproject.com/Questions/5061695/Running-a-windows-service-process-on-windows-serve\">在这里</a>\"发布了遇到的问题。</p><p></p><p>事实证明，这是一个没有完美解决方案的问题，但是，本文附带的代码已经得到了应用，并且经过了全面的测试，没有任何的问题。</p><p></p><h2>基础知识</h2><p></p><p></p><p>我们的代码结构和流程可能看起来很复杂，但是这是有一定原因的。在过去的十年间，服务已经与其他进程隔离。从那时开始，Windows服务会在SYSTEM用户账号下运行，而不是其他的用户账号，并且是<a href=\"https://msrc-blog.microsoft.com/2008/10/13/service-isolation-explanation/\">隔离运行的</a>\"。</p><p></p><p>隔离运行的原因在于，服务的功能很强大，可能是潜在的安全风险。正因为如此，微软引入了服务隔离。在这个变化之前，所有的服务会与应用一起在Session 0中运行。</p><p></p><p>但是，在引入了隔离之后（这是在Windows Vista中引入的），情况发生了变化。我们的代码背后的想法是通过调用<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasusera\">CreateProcessAsUserW</a>\"，让Windows服务以某个用户的身份启动自己，这一点将在后文详细阐述。我们的服务叫做SG_RevealerService，它有多个命令，当使用如下的命令行参数调用时，它们会采取相应的行为。</p><p></p><p><code lang=\"cpp\">#define SERVICE_COMMAND_INSTALL L\"Install\"             // The command line argument\n                                                       // for installing the service\n\n#define SERVICE_COMMAND_LAUNCHER L\"ServiceIsLauncher\"  // Launcher command for\n                                                       // NT service\n</code></p><p></p><p>当调用SG_RevealerService时，有三个选项：</p><p></p><p>选项1：不带有任何命令行参数进行调用。在这种情况下什么都不会发生。</p><p></p><p>选项2：带有Install命令行参数进行调用。在这种情况下，服务将自行安装，如果在哈希分隔符（#）添加了有效的可执行路径，服务将会启动，Windows看门狗会保持其一直运行。</p><p></p><p>然后，Service会使用<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasusera\">CreateProcessAsUserW()</a>\"运行自身，新的进程会在用户账号下运行。这给了Service访问上下文的能力，因为Service Isolation，调用实例是无法访问该上下文的。</p><p></p><p>选项3：使用ServiceIsLauncher命令行参数进行调用。服务客户端主应用将会启动。此时，入口函数表明服务已经以当前用户的权限启动了自身。现在，在Task Manager中，我们会看到SG_RevealerService的两个实例，其中一个在SYSTEM用户下，另一个在当前登录用户下。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/windows-services-reliable-restart/en/resources/1figure-1-task-manager-1671630831799.jpg\" /></p><p></p><p><code lang=\"cpp\">/*\nRunHost\n*/\n\nBOOL RunHost(LPWSTR HostExePath,LPWSTR CommandLineArguments)\n{\n    WriteToLog(L\"RunHost '%s'\",HostExePath);\n\n    STARTUPINFO startupInfo = {};\n    startupInfo.cb = sizeof(STARTUPINFO);\n    startupInfo.lpDesktop = (LPTSTR)_T(\"winsta0\\\\default\");\n\n    HANDLE hToken = 0;\n    BOOL bRes = FALSE;\n\n    LPVOID pEnv = NULL;\n    CreateEnvironmentBlock(&amp;pEnv, hToken, TRUE);\n\n    PROCESS_INFORMATION processInfoAgent = {};\n    PROCESS_INFORMATION processInfoHideProcess = {};\n    PROCESS_INFORMATION processInfoHideProcess32 = {};\n\n    if (PathFileExists(HostExePath))\n    {\n        std::wstring commandLine;\n        commandLine.reserve(1024);\n\n        commandLine += L\"\\\"\";\n        commandLine += HostExePath;\n        commandLine += L\"\\\" \\\"\";\n        commandLine += CommandLineArguments;\n        commandLine += L\"\\\"\";\n\n        WriteToLog(L\"launch host with CreateProcessAsUser ...  %s\",\n                     commandLine.c_str());\n\n        bRes = CreateProcessAsUserW(hToken, NULL, &amp;commandLine[0],\n               NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS |\n               CREATE_UNICODE_ENVIRONMENT | CREATE_NEW_CONSOLE |\n               CREATE_DEFAULT_ERROR_MODE, pEnv,\n            NULL, &amp;startupInfo, &amp;processInfoAgent);\n        if (bRes == FALSE)\n        {\n            DWORD   dwLastError = ::GetLastError();\n            TCHAR   lpBuffer[256] = _T(\"?\");\n            if (dwLastError != 0)    // Don't want to see an\n                                     // \"operation done successfully\" error ;-)\n            {\n                ::FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,    // It's a system error\n                    NULL,                                      // No string to be\n                                                               // formatted needed\n                    dwLastError,                               // Hey Windows: Please\n                                                               // explain this error!\n                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Do it in the standard\n                                                               // language\n                    lpBuffer,              // Put the message here\n                    255,                   // Number of bytes to store the message\n                    NULL);\n            }\n            WriteToLog(L\"CreateProcessAsUser failed - Command Line = %s Error : %s\",\n                         commandLine, lpBuffer);\n        }\n        else\n        {\n            if (!writeStringInRegistry(HKEY_LOCAL_MACHINE,\n               (PWCHAR)SERVICE_REG_KEY, (PWCHAR)SERVICE_KEY_NAME, HostExePath))\n            {\n                WriteToLog(L\"Failed to write registry\");\n            }\n        }\n    }\n    else\n    {\n        WriteToLog(L\"RunHost failed because path '%s' does not exists\", HostExePath);\n    }\n    hPrevAppProcess = processInfoAgent.hProcess;\n    \n    CloseHandle(hToken);\n    WriteToLog(L\"Run host end!\");\n\n    return bRes;\n}\n</code></p><p></p><h2>探测用户登录</h2><p></p><p></p><p>第一个挑战是仅在用户登录时，才启动一些动作。为了探测用户的登录，我们首先定义一个全局变量。</p><p></p><p><code lang=\"cpp\">bool g_bLoggedIn = false;\n</code></p><p></p><p>当用户登录时，它的值应该被设置为true 。</p><p></p><h3>订阅登录事件</h3><p></p><p></p><p>我们定义了如下的<a href=\"https://cplusplus.com/doc/tutorial/preprocessor/\">Preprocesor Directives</a>\"：</p><p></p><p><code lang=\"cpp\">#define EVENT_SUBSCRIBE_PATH    L\"Security\"\n#define EVENT_SUBSCRIBE_QUERY    L\"Event/System[EventID=4624]\"\n</code></p><p></p><p>当Service启动后，我们<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/winevt/nf-winevt-evtsubscribe\">订阅登录事件</a>\"，所以当用户登录时，我们会通过设置的回调函数得到一个告警，然后我们就可以继续后面的操作了。为了实现这一点，我们需要一个类来处理订阅的创建并等待事件回调。</p><p></p><p><code lang=\"cpp\">class UserLoginListner\n{\n    HANDLE hWait = NULL;\n    HANDLE hSubscription = NULL;\n\npublic:\n    ~UserLoginListner()\n    {\n        CloseHandle(hWait);\n        EvtClose(hSubscription);\n    }\n\n    UserLoginListner()\n    {\n        const wchar_t* pwsPath = EVENT_SUBSCRIBE_PATH;\n        const wchar_t* pwsQuery = EVENT_SUBSCRIBE_QUERY;\n\n        hWait = CreateEvent(NULL, FALSE, FALSE, NULL);\n\n        hSubscription = EvtSubscribe(NULL, NULL,\n            pwsPath, pwsQuery,\n            NULL,\n            hWait,\n            (EVT_SUBSCRIBE_CALLBACK)UserLoginListner::SubscriptionCallback,\n            EvtSubscribeToFutureEvents);\n        if (hSubscription == NULL)\n        {\n            DWORD status = GetLastError();\n\n            if (ERROR_EVT_CHANNEL_NOT_FOUND == status)\n                WriteToLog(L\"Channel %s was not found.\\n\", pwsPath);\n            else if (ERROR_EVT_INVALID_QUERY == status)\n                WriteToLog(L\"The query \\\"%s\\\" is not valid.\\n\", pwsQuery);\n            else\n                WriteToLog(L\"EvtSubscribe failed with %lu.\\n\", status);\n\n            CloseHandle(hWait);\n        }\n    }\n</code></p><p></p><p>然后，我们需要一个函数实现等待：</p><p></p><p><code lang=\"cpp\">void WaitForUserToLogIn()\n{\n    WriteToLog(L\"Waiting for a user to log in...\");\n    WaitForSingleObject(hWait, INFINITE);\n    WriteToLog(L\"Received a Logon event - a user has logged in\");\n}\n</code></p><p></p><p>我们还需要一个回调函数：</p><p></p><p><code lang=\"cpp\">static DWORD WINAPI SubscriptionCallback(EVT_SUBSCRIBE_NOTIFY_ACTION action, PVOID\n       pContext, EVT_HANDLE hEvent)\n{\n    if (action == EvtSubscribeActionDeliver)\n    {\n        WriteToLog(L\"SubscriptionCallback invoked.\");\n        HANDLE Handle = (HANDLE)(LONG_PTR)pContext;\n        SetEvent(Handle);\n    }\n\n    return ERROR_SUCCESS;\n}\n</code></p><p></p><p>接下来，需要做的就是添加具有如下内容的代码块：</p><p></p><p><code lang=\"cpp\">WriteToLog(L\"Launch client\\n\"); // launch client ...\n{\n    UserLoginListner WaitTillAUserLogins;\n    WaitTillAUserLogins.WaitForUserToLogIn();\n}\n</code></p><p></p><p>到达代码块的底部时，我们就可以确信一个用户已经登录了。</p><p></p><p>在本文后面的内容中，我们将会介绍如何检索登录用户的账号/用户名，以及如何使用GetLoggedInUser()函数。</p><p></p><h2>冒充用户</h2><p></p><p></p><p>当确定一个用户已经登录时，我们需要冒充他们。</p><p></p><p>如下的函数完成了这项工作。它不仅冒充了用户，还调用了<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasuserw\">CreateProcessAsUserW()</a>\"，以该用户的身份运行自己。通过这种方式，我们能够让服务访问用户的上下文，包括文档、桌面等，并允许服务使用用户界面，这对于从Session 0运行服务来讲是无法实现的。</p><p></p><p><a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasuserw\">CreateProcessAsUserW</a>\"创建了一个新的进程及其主线程，它会在给定用户的上下文中运行。</p><p></p><p><code lang=\"cpp\">//Function to run a process as active user from Windows service\nvoid ImpersonateActiveUserAndRun()\n{\n    DWORD session_id = -1;\n    DWORD session_count = 0;\n    WTS_SESSION_INFOW *pSession = NULL;\n\n    if (WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE, 0, 1, &amp;pSession, &amp;session_count))\n    {\n        WriteToLog(L\"WTSEnumerateSessions - success\");\n    }\n    else\n    {\n        WriteToLog(L\"WTSEnumerateSessions - failed. Error %d\",GetLastError());\n        return;\n    }\n    TCHAR szCurModule[MAX_PATH] = { 0 };\n\n    GetModuleFileName(NULL, szCurModule, MAX_PATH);\n\n\n    for (size_t i = 0; i &lt; session_count; i++)\n    {\n        session_id = pSession[i].SessionId;\n        WTS_CONNECTSTATE_CLASS wts_connect_state = WTSDisconnected;\n        WTS_CONNECTSTATE_CLASS* ptr_wts_connect_state = NULL;\n        DWORD bytes_returned = 0;\n        if (::WTSQuerySessionInformation(\n            WTS_CURRENT_SERVER_HANDLE,\n            session_id,\n            WTSConnectState,\n            reinterpret_cast(&amp;ptr_wts_connect_state),\n            &amp;bytes_returned))\n        {\n            wts_connect_state = *ptr_wts_connect_state;\n            ::WTSFreeMemory(ptr_wts_connect_state);\n            if (wts_connect_state != WTSActive) continue;\n        }\n        else\n        {\n            continue;\n        }\n\n        HANDLE hImpersonationToken;\n        if (!WTSQueryUserToken(session_id, &amp;hImpersonationToken))\n        {\n            continue;\n        }\n\n        //Get the actual token from impersonation one\n        DWORD neededSize1 = 0;\n        HANDLE *realToken = new HANDLE;\n        if (GetTokenInformation(hImpersonationToken, (::TOKEN_INFORMATION_CLASS) TokenLinkedToken, realToken, sizeof(HANDLE), &amp;neededSize1))\n        {\n            CloseHandle(hImpersonationToken);\n            hImpersonationToken = *realToken;\n        }\n        else\n        {\n            continue;\n        }\n        HANDLE hUserToken;\n        if (!DuplicateTokenEx(hImpersonationToken,\n            TOKEN_ASSIGN_PRIMARY | TOKEN_ALL_ACCESS | MAXIMUM_ALLOWED,\n            NULL,\n            SecurityImpersonation,\n            TokenPrimary,\n            &amp;hUserToken))\n        {\n            continue;\n        }\n\n\n        // Get user name of this process\n        WCHAR* pUserName;\n        DWORD user_name_len = 0;\n        if (WTSQuerySessionInformationW(WTS_CURRENT_SERVER_HANDLE, session_id, WTSUserName, &amp;pUserName, &amp;user_name_len))\n        {\n            //Now we got the user name stored in pUserName\n        }\n        // Free allocated memory                         \n        if (pUserName) WTSFreeMemory(pUserName);\n        ImpersonateLoggedOnUser(hUserToken);\n        STARTUPINFOW StartupInfo;\n        GetStartupInfoW(&amp;StartupInfo);\n        StartupInfo.cb = sizeof(STARTUPINFOW);\n        PROCESS_INFORMATION processInfo;\n        SECURITY_ATTRIBUTES Security1;\n        Security1.nLength = sizeof SECURITY_ATTRIBUTES;\n        SECURITY_ATTRIBUTES Security2;\n        Security2.nLength = sizeof SECURITY_ATTRIBUTES;\n        void* lpEnvironment = NULL;\n\n        // Obtain all needed necessary environment variables of the logged in user.\n        // They will then be passed to the new process we create.\n\n        BOOL resultEnv = CreateEnvironmentBlock(&amp;lpEnvironment, hUserToken, FALSE);\n        if (!resultEnv)\n        {\n            WriteToLog(L\"CreateEnvironmentBlock - failed. Error %d\",GetLastError());\n            continue;\n        }\n        std::wstring commandLine;\n        commandLine.reserve(1024);\n        commandLine += L\"\\\"\";\n        commandLine += szCurModule;\n        commandLine += L\"\\\" \\\"\";\n        commandLine += SERVICE_COMMAND_Launcher;\n        commandLine += L\"\\\"\";\n        WCHAR PP[1024]; //path and parameters\n        ZeroMemory(PP, 1024 * sizeof WCHAR);\n        wcscpy_s(PP, commandLine.c_str());\n\n        // Next we impersonate - by starting the process as if the current logged in user, has started it\n        BOOL result = CreateProcessAsUserW(hUserToken,\n            NULL,\n            PP,\n            NULL,\n            NULL,\n            FALSE,\n            NORMAL_PRIORITY_CLASS | CREATE_NEW_CONSOLE,\n            NULL,\n            NULL,\n            &amp;StartupInfo,\n            &amp;processInfo);\n\n        if (!result)\n        {\n            WriteToLog(L\"CreateProcessAsUser - failed. Error %d\",GetLastError());\n        }\n        else\n        {\n            WriteToLog(L\"CreateProcessAsUser - success\");\n        }\n        DestroyEnvironmentBlock(lpEnvironment);\n        CloseHandle(hImpersonationToken);\n        CloseHandle(hUserToken);\n        CloseHandle(realToken);\n        RevertToSelf();\n    }\n    WTSFreeMemory(pSession);\n}\n</code></p><p></p><h2>寻找已登录的用户</h2><p></p><p></p><p>为了寻找已登录用户的账号名，我们会使用如下的函数：</p><p></p><p><code lang=\"cpp\">std::wstring GetLoggedInUser()\n{\n    std::wstring user{L\"\"};\n    WTS_SESSION_INFO *SessionInfo;\n    unsigned long SessionCount;\n    unsigned long ActiveSessionId = -1;\n\n    if(WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE,\n                            0, 1, &amp;SessionInfo, &amp;SessionCount))\n    {\n        for (size_t i = 0; i &lt; SessionCount; i++)\n        {\n            if (SessionInfo[i].State == WTSActive ||\n                SessionInfo[i].State == WTSConnected)\n            {\n                ActiveSessionId = SessionInfo[i].SessionId;\n                break;\n            }\n        }\n\n        wchar_t *UserName;\n        if (ActiveSessionId != -1)\n        {\n            unsigned long BytesReturned;\n            if (WTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE,\n                ActiveSessionId, WTSUserName, &amp;UserName, &amp;BytesReturned))\n            {\n                user = UserName;        // Now we have the logged in user name\n                WTSFreeMemory(UserName);    \n            }\n        }\n        WTSFreeMemory(SessionInfo);\n    }\n    return user;\n}\n</code></p><p></p><p>在服务启动后不久，我们就要使用该函数。只要没有用户登录，这个函数就会返回一个空字符串，如果这样的话，我们就知道应该继续等待。</p><p></p><h2>看门狗是Service的好朋友</h2><p></p><p></p><p>Service与看门狗机制协同使用是很理想的方案。</p><p></p><p>这种机制将确保一个给定应用始终处于运行状态，如果它异常关闭的话，看门狗会重新启动它。我们要始终记住，如果用户通过Quit退出的话，我们不希望重启进程。但是，如果进程是通过Task Manager或其他方式被停掉的，我们会希望重启它。一个很好的例子是反病毒程序。我们想要确保恶意软件不能终止本应检测它的反病毒程序。</p><p></p><p>为了实现这一点，我们需要该Service为使用它的程序提供某种API，当该程序的用户选择“Quit”，程序会告知Service，程序的工作已经完成了，Service可以卸载自己了。</p><p></p><h2>一些构建基块</h2><p></p><p></p><p>接下来，我们介绍一些构建基块，要理解本文的代码，它们是必备的。</p><p></p><h3>GetExePath</h3><p></p><p></p><p>为了获取我们的Service或其他可执行文件的路径，如下的函数是非常便利的。</p><p></p><p><code lang=\"cpp\">/**\n * GetExePath() - returns the full path of the current executable.\n *\n * @param values - none.\n * @return a std::wstring containing the full path of the current executable.\n */\nstd::wstring GetExePath()\n{\n    wchar_t buffer[65536];\n    GetModuleFileName(NULL, buffer, sizeof(buffer) / sizeof(*buffer));\n    int pos = -1;\n    int index = 0;\n    while (buffer[index])\n    {\n        if (buffer[index] == L'\\\\' || buffer[index] == L'/')\n        {\n            pos = index;\n        }\n        index++;\n    }\n    buffer[pos + 1] = 0;\n    return buffer;\n}\n</code></p><p></p><h3>WriteLogFile</h3><p></p><p></p><p>当开发Windows Service时（以及其他任何软件），拥有一个日志机制都是很重要的。我们有一个非常复杂的日志机制，但是就本文而言，我添加了一个最小的日志函数，名为WriteToLog。它的运行机制类似于printf ，但是所有发送给它的内容不仅会被格式化，还会存储在一个日志文件中，以备日后检查。这个日志文件的大小会不断增长，因为会有新的日志条目追加到上面。</p><p></p><p>日志文件的路径，通常会位于Service的EXE的路径，但是，由于Service Isolation，在重启计算机后的一小段时间内，这个路径会<a href=\"https://serverfault.com/questions/114238/windows-service-can-i-configure-the-current-working-directory\">变成</a>\" <a href=\"https://serverfault.com/questions/114238/windows-service-can-i-configure-the-current-working-directory\">c:\\Windows\\System32</a>\"，我们并不希望如此。所以，我们的日志函数会检查exe的路径，并且不会假设<a href=\"https://learn.microsoft.com/en-us/windows/win32/fileio/changing-the-current-directory\">Current Directory</a>\"在Service的生命周期内会保持不变。</p><p></p><p><code lang=\"cpp\">/**\n * WriteToLog() - writes formatted text into a log file, and on screen (console)\n *\n * @param values - formatted text, such as L\"The result is %d\",result.\n * @return - none\n */\nvoid WriteToLog(LPCTSTR lpText, ...)\n{\n    FILE *fp;\n    wchar_t log_file[MAX_PATH]{L\"\"};\n    if(wcscmp(log_file,L\"\") == NULL)\n    {\n        wcscpy(log_file,GetExePath().c_str());\n        wcscat(log_file,L\"log.txt\");\n    }\n    // find gmt time, and store in buf_time\n    time_t rawtime;\n    struct tm* ptm;\n    wchar_t buf_time[DATETIME_BUFFER_SIZE];\n    time(&amp;rawtime);\n    ptm = gmtime(&amp;rawtime);\n    wcsftime(buf_time, sizeof(buf_time) / sizeof(*buf_time), L\"%d.%m.%Y %H:%M\", ptm);\n\n    // store passed messsage (lpText) to buffer_in\n    wchar_t buffer_in[BUFFER_SIZE];\n\n    va_list ptr;\n    va_start(ptr, lpText);\n\n    vswprintf(buffer_in, BUFFER_SIZE, lpText, ptr);\n    va_end(ptr);\n\n    // store output message to buffer_out - enabled multiple parameters in swprintf\n    wchar_t buffer_out[BUFFER_SIZE];\n\n    swprintf(buffer_out, BUFFER_SIZE, L\"%s %s\\n\", buf_time, buffer_in);\n\n    _wfopen_s(&amp;fp, log_file, L\"a,ccs=UTF-8\");\n    if (fp)\n    {\n        fwprintf(fp, L\"%s\\n\", buffer_out);\n        fclose(fp);\n    }\n    wcscat(buffer_out,L\"\\n\");HANDLE stdOut = GetStdHandle(STD_OUTPUT_HANDLE);\n    if (stdOut != NULL &amp;&amp; stdOut != INVALID_HANDLE_VALUE)\n    {\n        DWORD written = 0;\n        WriteConsole(stdOut, buffer_out, wcslen(buffer_out), &amp;written, NULL);\n    }\n}\n</code></p><p></p><h2>更多的构建基块：注册表相关的内容</h2><p></p><p></p><p>下面是一些我们用来存储看门狗可执行文件路径的函数，所以当计算机重启后，Service重新启动时，就能使用该路径。</p><p></p><p><code lang=\"cpp\">BOOL CreateRegistryKey(HKEY hKeyParent, PWCHAR subkey)\n{\n    DWORD dwDisposition; //Verify new key is created or open existing key\n    HKEY  hKey;\n    DWORD Ret;\n    Ret =\n        RegCreateKeyEx(\n            hKeyParent,\n            subkey,\n            0,\n            NULL,\n            REG_OPTION_NON_VOLATILE,\n            KEY_ALL_ACCESS,\n            NULL,\n            &amp;hKey,\n            &amp;dwDisposition);\n    if (Ret != ERROR_SUCCESS)\n    {\n        WriteToLog(L\"Error opening or creating new key\\n\");\n        return FALSE;\n    }\n    RegCloseKey(hKey); //close the key\n    return TRUE;\n}\n\nBOOL writeStringInRegistry(HKEY hKeyParent, PWCHAR subkey,\n                           PWCHAR valueName, PWCHAR strData)\n{\n    DWORD Ret;\n    HKEY hKey;\n    //Check if the registry exists\n    Ret = RegOpenKeyEx(\n        hKeyParent,\n        subkey,\n        0,\n        KEY_WRITE,\n        &amp;hKey\n    );\n    if (Ret == ERROR_SUCCESS)\n    {\n        if (ERROR_SUCCESS !=\n            RegSetValueEx(\n                hKey,\n                valueName,\n                0,\n                REG_SZ,\n                (LPBYTE)(strData),\n                ((((DWORD)lstrlen(strData) + 1)) * 2)))\n        {\n            RegCloseKey(hKey);\n            return FALSE;\n        }\n        RegCloseKey(hKey);\n        return TRUE;\n    }\n    return FALSE;\n}\n\nLONG GetStringRegKey(HKEY hKey, const std::wstring &amp;strValueName,\n                     std::wstring &amp;strValue, const std::wstring &amp;strDefaultValue)\n{\n    strValue = strDefaultValue;\n    TCHAR szBuffer[MAX_PATH];\n    DWORD dwBufferSize = sizeof(szBuffer);\n    ULONG nError;\n    nError = RegQueryValueEx(hKey, strValueName.c_str(), 0, NULL,\n             (LPBYTE)szBuffer, &amp;dwBufferSize);\n    if (nError == ERROR_SUCCESS)\n    {\n        strValue = szBuffer;\n        if (strValue.front() == _T('\"') &amp;&amp; strValue.back() == _T('\"'))\n        {\n            strValue.erase(0, 1); // erase the first character\n            strValue.erase(strValue.size() - 1); // erase the last character\n        }\n    }\n    return nError;\n}\n\nBOOL readStringFromRegistry(HKEY hKeyParent, PWCHAR subkey,\n                            PWCHAR valueName, std::wstring&amp; readData)\n{\n    HKEY hKey;\n    DWORD len = 1024;\n    DWORD readDataLen = len;\n    PWCHAR readBuffer = (PWCHAR)malloc(sizeof(PWCHAR) * len);\n    if (readBuffer == NULL)\n        return FALSE;\n    //Check if the registry exists\n    DWORD Ret = RegOpenKeyEx(\n        hKeyParent,\n        subkey,\n        0,\n        KEY_READ,\n        &amp;hKey\n    );\n    if (Ret == ERROR_SUCCESS)\n    {\n        Ret = RegQueryValueEx(\n            hKey,\n            valueName,\n            NULL,\n            NULL,\n            (BYTE*)readBuffer,\n            &amp;readDataLen\n        );\n        while (Ret == ERROR_MORE_DATA)\n        {\n            // Get a buffer that is big enough.\n            len += 1024;\n            readBuffer = (PWCHAR)realloc(readBuffer, len);\n            readDataLen = len;\n            Ret = RegQueryValueEx(\n                hKey,\n                valueName,\n                NULL,\n                NULL,\n                (BYTE*)readBuffer,\n                &amp;readDataLen\n            );\n        }\n        if (Ret != ERROR_SUCCESS)\n        {\n            RegCloseKey(hKey);\n            return false;;\n        }\n        readData = readBuffer;\n        RegCloseKey(hKey);\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n</code></p><p></p><h2>检查宿主（Host）是否在运行</h2><p></p><p></p><p>本文中的程序有一项核心能力，那就是保护我们的SampleApp（我们将其称为宿主），当它未运行时，就重新启动它（所以叫做看门狗）。在真实场景中，我们会检查宿主是被用户终止的（这是允许的），还是被恶意软件终止的（这是不允许的），在后一种情况下，我们将会重启它（否则，如果用户选择Quit，但应用程序将继续“骚扰”系统并反复执行）。</p><p></p><p>如下是它如何实现的：</p><p></p><p>我们创建了一个Timer事件，每隔一定的时间（不应该过于频繁），我们会检查宿主的进程是否在运行，如果没有的话，我们就启动它。我们使用了一个静态布尔型标记（is_running），用来表明我们已经处于该代码块中了，所以在处理过程中时，能够避免再次调用。这是在WM_TIMER代码块中始终要做的事情，因为当定时器设置的频率过高的话，代码块在调用时，前一个WM_TIMER事件的代码依然在执行。</p><p></p><p>我们还通过检查g_bLoggedIn布尔标记来判断是否有用户登录。</p><p></p><p><code lang=\"cpp\">  case WM_TIMER:\n        {\n            if (is_running) break;\n            WriteToLog(L\"Timer event\");\n            is_running = true;\n            HANDLE hProcessSnap;\n            PROCESSENTRY32 pe32;\n            bool found{ false };\n\n            WriteToLog(L\"Enumerating all processess...\");\n            // Take a snapshot of all processes in the system.\n            hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n            if (hProcessSnap == INVALID_HANDLE_VALUE)\n            {\n                WriteToLog(L\"Failed to call CreateToolhelp32Snapshot(). Error code %d\",GetLastError());\n                is_running = false;\n                return 1;\n            }\n\n            // Set the size of the structure before using it.\n            pe32.dwSize = sizeof(PROCESSENTRY32);\n\n            // Retrieve information about the first process,\n            // and exit if unsuccessful\n            if (!Process32First(hProcessSnap, &amp;pe32))\n            {\n                WriteToLog(L\"Failed to call Process32First(). Error code %d\",GetLastError());\n                CloseHandle(hProcessSnap);          // clean the snapshot object\n                is_running=false;\n                break;\n            }\n\n            // Now walk the snapshot of processes, and\n            // display information about each process in turn\n            DWORD svchost_parent_pid = 0;\n            DWORD dllhost_parent_pid = 0;\n            std::wstring szPath = L\"\";\n\n            if (readStringFromRegistry(HKEY_LOCAL_MACHINE, (PWCHAR)SERVICE_REG_KEY, (PWCHAR)SERVICE_KEY_NAME, szPath))\n            {\n                m_szExeToFind = szPath.substr(szPath.find_last_of(L\"/\\\\\") + 1);    // The process name is the executable name only\n                m_szExeToRun = szPath;                                            // The executable to run is the full path\n            }\n            else\n            {\n                WriteToLog(L\"Error reading ExeToFind from the Registry\");\n            }\n\n            do\n            {\n                if (wcsstr( m_szExeToFind.c_str(), pe32.szExeFile))\n                {\n                    WriteToLog(L\"%s is running\",m_szExeToFind.c_str());\n                    found = true;\n                    is_running=false;\n                    break;\n                }\n                if (!g_bLoggedIn)\n                {\n                    WriteToLog(L\"WatchDog isn't starting '%s' because user isn't logged in\",m_szExeToFind.c_str());\n                    return 1;\n                }\n            }\n            while (Process32Next(hProcessSnap, &amp;pe32));\n            if (!found)\n            {\n                WriteToLog(L\"'%s' is not running. Need to start it\",m_szExeToFind.c_str());\n                if (!m_szExeToRun.empty())    // watchdog start the host app\n                {\n                    if (!g_bLoggedIn)\n                    {\n                        WriteToLog(L\"WatchDog isn't starting '%s' because user isn't logged in\",m_szExeToFind.c_str());\n                        return 1;\n                    }\n                    ImpersonateActiveUserAndRun();\n\n                    RunHost((LPWSTR)m_szExeToRun.c_str(), (LPWSTR)L\"\");\n\n                }\n                else\n                {\n                    WriteToLog(L\"m_szExeToRun is empty\");\n                }\n            }\n            CloseHandle(hProcessSnap);\n        }\n        is_running=false;\n        break;\n</code></p><p></p><h2>如何测试Service</h2><p></p><p></p><p>当我们想要测试这个解决方案时，我们雇佣了20个资深的和协作的测试人员。在整个工作过程中，越来多的测试均成功了。在某些时候，它在我们自己的Surface Pro笔记本电脑上运行地非常完美，但是，我们的一位员工报告说，在他的计算机上，在关闭之后，服务没有再次启动，或者在<a href=\"https://en.wikipedia.org/wiki/Protection_ring\">Ring 3</a>\"下没有启动自身。这是一个好消息，因为在开发过程中，当你怀疑某个地方存在缺陷的时候，最糟糕的事情就是无法找到它，也无法重现它。总而言之，10%的测试者报告了问题。因此，这里发布的版本在我们员工的电脑上运行完美，然而2%的测试者仍然不时报告问题。换句话说，SampleApp在关闭计算机并打开后无法启动。</p><p></p><p>如下是对测试服务和看门狗的说明。</p><p></p><h3>SampleApp</h3><p></p><p></p><p>我们包含了一个由Visual Studio Wizard生成的样例应用，作为“宿主”应用，它会被看门狗确保一直运行。你可以单独运行它，外观如下面的图片所示。该应用没有做太多的事情。实际上，它一无是处……</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/windows-services-reliable-restart/en/resources/1figure-2-sample-app-1671630831799.jpg\" /></p><p></p><p>在后面的内容中，我们将提供测试服务和看门狗的指南。你可以在<a href=\"https://github.com/securedglobe/PersistantService\">GitHub</a>\"下载源码。</p><p></p><h3>从CMD中运行</h3><p></p><p>以管理员身份打开CMD。将当前目录变更至Service的EXE所在的路径并输入：</p><p></p><p>SG_RevealerService.exe Install#SampleApp.exe</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/windows-services-reliable-restart/en/resources/1figure-3-command-prompt-1671630831799.jpg\" /></p><p></p><p>你可以看到，我们有两个元素：</p><p></p><p>command元素，这里是Installargument元素，通过哈希分隔符(#)连接至命令元素，应该是我们希望看门狗观察的可执行文件。</p><p></p><p>Service首先会启动SampleApp，从此之后，如果你尝试终止或杀死SampleApp的话，看门狗会在几秒钟后重启它。如果重启，关掉计算机并再次启动，你会发现Service会再次出现并启动SampleApp。这就是我们的Service的目标和功能。</p><p></p><h3>卸载</h3><p></p><p></p><p>最后，如果要停止和卸载服务，我们包含了一个uninstall.bat脚本，它如下所示：</p><p></p><p><code lang=\"cpp\">sc stop sg_revealerservice\nsc delete sg_revealerservice\ntaskkill /f /im sampleapp.exe\ntaskkill /f /im sg_revealerservice.exe\n</code></p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/windows-services-reliable-restart/en/resources/1figure-4-delete-service-1671630831799.jpg\" /></p><p></p><h3>结论</h3><p></p><p></p><p>Windows Service在微软Windows操作系统中起着关键作用，它支持创建和管理长期运行的进程。在有些场景下，如果勾选了“快速启动”，在正常关闭并重启计算机后，服务往往无法重启。本文的目的是创建一个持久化的服务，在Windows重新启动或关机后，能够始终运行并重新启动。其中一个主要的问题与Service Isolation有关。隔离本身（在Windows Vista版本中引入）是很重要和强大的，然而，当我们需要与用户空间交互时，这会产生一些限制。当服务重新启动时，我们希望它能与用户空间进行交互，然而它不能发生地太早（在任何用户登录之前）。不过，你可以通过订阅登录事件来解决这个问题。Service与看门狗机制协同使用是很理想的方案。这种机制能够确保给定的应用一直在运行，并且在异常关闭时，它将重新启动。我们在前面描述的方法的基础上，成功地开发了这个机制，这使得它可以一直运行，在用户登录时得到提醒，并且能够与用户空间进行交互。定时器事件能够用来监控被观察进程的运行。在开发过程中，好的日志机制始终是非常有用的，我们可以使用简单的日志工具，并在需要的时候，使用更为复杂的工具。最终的解决方案必须要进行测试。代码被确认并验证可以运行后，多达2%的测试人员依然可能会报告错误，这是有一定原因的。</p><p></p><p>作者简介：</p><p>Michael Haephrati是Secured Globe, Inc.的联合创始人和首席执行官，该公司于2008年与他的妻子Ruth Haephrati一起创建。Michael是一位音乐作曲家、发明家，也是一位专门从事软件开发和信息安全的专家。凭借30多年的经验，Michael形成了独特的视角，将技术和创新结合起来，并强调终端用户的体验。多年来，Michael领导了各种客户的创新项目和技术。他是“Learning C++”（https://www.manning.com/books/learning-c-plus-plus）的作者，该书由Manning Publications出版。</p><p></p><p>Ruth Haephrati是Secured Globe, Inc.的联合创始人和首席执行官，该公司于2008年与她的丈夫Michael Haephrati一起创建。Ruth是一位作家、演讲者、企业家、网络安全和网络取证专家。在过去的25年里，Ruth与微软和IBM等领先公司合作，担任顾问和C++实践专家。她最近参与了为一个国际客户开发的最先进的反恶意软件技术。在业余时间，Ruth是一位插画家、画家、野生动物摄影师和世界旅行者。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/windows-services-reliable-restart/\">The Service and the Beast: Building a Windows Service that Does Not Fail to Restart</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/3IX18md3WG2kjiM43Kgv\">Windows 11发布重大更新：ChatGPT版Bing集成到任务栏中，可快速访问AI聊天功能</a>\"</p><p><a href=\"https://www.infoq.cn/article/97LDs46oamxHYLAhp5uK\">Kubernetes 1.26 版本正式发布：改进 Windows 支持，加强网络安全和管理功能</a>\"</p>",
    "publish_time": "2023-03-09 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "在Java中我们该如何应对阻塞调用",
    "url": "https://www.infoq.cn/article/Tda86qL5beKOIkIRoYBU",
    "summary": "<p></p><blockquote>本文最初发表于<a href=\"https://www.javaadvent.com/2022/12/a-tale-of-two-cities-how-blocking-calls-are-treated.html\">Java Advent网站</a>\"，经原作者<a href=\"https://foojay.io/today/author/bazlur-rahman/\">A N M Bazlur Rahman</a>\"授权，由InfoQ中文站翻译分享。</blockquote><p></p><p></p><p>Java已经有20多年的历史了，它一直是软件开发领域的主导力量，这种情况应该还会继续下去。然而，它之所以表现如此优异，是有多种原因的，其中之一就是并发。Java通过引入一个内置的线程模型开始了它的并发旅程。</p><p></p><p>在本文中，我将会讨论关于线程模型的一些历史知识，阐述它们是如何帮助我们形成使用Java进行编程时的理解和实践的，以及我们目前处于何处和它的一个特殊问题。</p><p></p><p>这篇文章会有点长，但是我相信你会喜欢它的。</p><p></p><p>让我们开始这段旅程吧！</p><p></p><h2>Java是由线程组成的</h2><p></p><p></p><p>从诞生之初，Java就引入了线程。线程是Java中的基本执行单元。这意味着我们要运行的所有Java代码都需要由线程来执行。线程是Java平台上执行环境的独立单元。</p><p></p><p>由此我们可以看出，如果一个程序有更多的线程，那它就有更多可以执行代码的地方。这意味着可以同时做更多的事情，从而给我们带来很多收益。一个特别的收益就是，通过利用机器上所有可用的资源，这能够提高应用的吞吐量。借助这种方式，我们能够从程序中获得更多的效益。</p><p></p><p>线程广泛存在于Java平台的各个层面中。</p><p></p><p>线程不仅能够执行代码，它还会在其栈中跟踪方法的调用。所以，如果Java程序在执行过程中遇到问题的话，我们会抛出异常。异常中会包含栈跟踪信息，基于此我们可以判断出错误的原因。由此，我们可以说线程是获取栈跟踪信息的一种方式。</p><p></p><p>此处，如果需要通过IDE调试程序的话，我们也会用到线程。如果需要对程序或程序的一部分进行剖析（profile）的话，我们也会用到线程。Java垃圾收集器会运行在一个单独的线程中。所有的这一切都证明，并发或者”线程“是编程平台的一个重要组成部分。</p><p></p><p></p><h2>但是，线程是昂贵的</h2><p></p><p></p><p>在现代Java web应用中，吞吐量是通过使用并发连接实现的。通常情况下，客户端的每个请求都会有一个专门的线程。现代操作系统可以处理上百万的并发连接。这表明，如果我们有更多的并发连接，就能实现更高的吞吐量。</p><p></p><p>这个结论似乎是合理的，但现实情况远非如此。原因在于，我们无法创建尽可能多的线程来实现这一点。</p><p></p><p>线程是数量有限的昂贵资源。创建一个线程需要在堆外占用2 MiB的内存。需要记住的另外一件事情是，按照传统的做法，Java线程仅仅对操作系统线程做个一层很薄的封装。我们只能创建数量有限的线程。即便我们有了大量的线程，也无法始终保证应用整体的性能。上下文的内容切换会有相关的成本。</p><p></p><p>你可以通过运行如下的样例看一下能够创建多少个线程。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/3f/3f7025ce4fb501729f27baf39a8be3f8.png\" /></p><p></p><p>到目前为止，我们已经讨论了Java线程的重要性以及它们的一些限制。那么，我们再进一步深入讨论一下。</p><p></p><p></p><h2>我们现在遇到了什么问题</h2><p></p><p></p><p>现代软件应用开发需要处理大量的数据，而且应用的使用率也会很高。这就带来了相关的成本问题。如果我们不留意的话，云计算的成本会迅速累积。</p><p></p><p>我们已经确认，创建线程的成本并不低，而且它们的数量是有限制的，所以我们不能浪费任何线程，而是要充分利用它们的能力。但实际上，情况并非如此。在传统的编程模型中，当我们调用一些需要时间才能获取响应的逻辑时，它会阻塞当前线程。例如，如果我们进行一个网络调用（可能是微服务或数据库调用）的话，用来进行调用的线程会被阻塞，直到得到结果为止。在等待结果的过程中，线程什么事情都不会做，基本上就是处于空闲状态，浪费了宝贵的资源，从而导致云账单的无谓增长。</p><p></p><p>因此，基于上述假设，可以得出结论，阻塞调用对我们并不是什么好事儿。</p><p></p><p>我们可以看一个样例。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/99/990dcc77434fc94fabe1a5d6a1708087.png\" /></p><p></p><p>在上述的代码中，我们进行了五个方法的调用。假设所有的方法均需要一些时间来进行处理。为了简单起见，我们假设它们都需要200毫秒的时间来处理。</p><p></p><p>由于我们是一个接一个地进行所有的调用，这将需要至少200*5=1000毫秒来完成该方法。因此，开始所有这些调用的线程必须等待它们全部完成。</p><p></p><p>在这个场景中，我们可以看到，调用calculateCreditForPerson()方法的线程在大部分时间内都是阻塞的，因为它在等待后续方法的完成。当阻塞的时候，它没有做任何事情。基本上来讲，它的资源因为不能做任何事情而被浪费了。</p><p></p><p>问题是，我们该如何才能改善它呢？</p><p></p><p>目前，业界已经有很多方案尝试来改善这种情况，使线程在这种情况下不会被阻塞。我将从Java历史的最开始说起。</p><p></p><p></p><h2>经典的实现方式</h2><p></p><p></p><p>上述样例中，在方法内部的各个方法调用并不都是互相依赖的。所以，第二个、第三个和第四个调用可以并行进行。如果这三个方法并行执行的话，我们就可以做一些改进。这样，调用者线程将花费更少的时间，这意味着更少的阻塞时间。这将是一个巨大的改进。在这里，我们没有解决阻塞的问题，但是负责调用该方法的主线程处于阻塞状态的时间会大幅减少。它将有更多的时间去做其他的事情。</p><p></p><p>那么，我们该如何实现这一经典的方式呢？</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/27/2773717c71082b3dcdcd3511c5028767.png\" /></p><p></p><p>最终的代码将类似于如上所示。我们将临时创建一个新的线程，并将结果存储在一个AtomicReference中。</p><p></p><p>这种方式很不错，但是我们无法控制要创建多少个线程。如果持续地创建临时线程，我们最终可能会创建过多的线程，这对应用是有害的。此外，如果试图创建过多线程的话，应用可能会抛出java.lang.OutOfMemoryError异常。</p><p></p><p>所以，我们需要进一步地改进。</p><p></p><p></p><h2>Executor框架</h2><p></p><p></p><p>Java 5引入了Executor框架，以及Future和Callable/Runnable。它允许我们控制要创建多少个线程，并对它们进行池化管理。</p><p></p><p>基于此，我们可以按照如下方式改善上述代码：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/09/090c76126aca39d1d9540aa6f526d24e.png\" /></p><p></p><p>对于代码编写来讲，这是一个相当大的改进，但是我们尚未达到目的。Future的机制依然非常复杂。对它的get()调用依然是一个阻塞式的调用。尽管我们进行的是异步调用，但最终还是需要一个阻塞式调用以便于从Future中获取值。</p><p></p><p>另外一个问题在于，它有可能会导致缓存受损（cache corruption，作者在这里指的应该是需要跨CPU内核存取数据，从而导致CPU级别的缓存失效——译者注）。例如，如果主线程向线程池提交任务的话，该任务将会由池中的某个线程来执行。主线程需要数据，但是这些数据却在另外一个线程中。这两个线程可能会位于不同的内核上，从而导致缓存受损。除此之外，在不同核心的上下文之间进行切换也是代价高昂的操作。</p><p></p><p>它还需要使用组合操作。所以，代码更多是命令式的。命令式的代码本身没有什么问题，不过函数式和声明式代码也很有意思。所以，至少我们在这里还可以进行一些改进。</p><p></p><p></p><h2>Fork/Join池</h2><p></p><p></p><p>Java引入了Fork/Join池，它是Java 5所引入的ExecutorService的实现，也是Executor框架的实现。它解决了我们在旧的Executor框架中遇到的很多问题，如缓存受损的问题。除此之外，它的运行理念是，刚刚创建的一批任务很可能会需要更紧密的缓存。这意味着，新创建的任务应该在同一个CPU上运行，而旧的任务可能需要在另外一个CPU上运行。与其他线程池实现相比，Fork/Join池中的每个线程都有自己的队列。此外，Fork/Join 池的实现采用了工作窃取（work-stealing）算法。如果池中的某个线程完成了自己的任务，它可以从另外一个线程的队尾窃取任务。所有的这些都能帮助我们实现更好的性能。</p><p></p><p></p><h2>将这一切组合在一起</h2><p></p><p></p><p>Java 8基于Fork/Join池引入了CompletableFuture。它包含了我们非常喜欢的组合特性。有了它，我们可以将上述代码改写成如下所示的样子：</p><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/10/10abf64040999afbc6fedc1904009df1.png\" /></p><p></p><p></p><h2>反应式Java</h2><p></p><p></p><p>非常不错，我们已经得到了自己想要的一切，也就是通过可组合性实现性能的提升。但是，市场上还有其他的替代方案。像RxJava、Akka、Eclipse Vert.x、Spring WebFlux、Slick这样的反应式框架，也能够为我们带来性能和可组合性的收益。我们来看看WebFlux的样例。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/cf/cf4537824efcb5dd2d9de1d62f1f03af.png\" /></p><p></p><p>但是，这种方式也有一些弊端，比如：</p><p></p><p>这种框架的学习曲线比较陡峭。有些模式对初学者来说可能会很难理解。与之相关的认知体验要求很高，这会损害代码的阅读体验。出现任何问题都很难调试。因为我们不知道特定的代码会在哪个线程上运行，完成任务的路径可能是各种各样的。这就是为何即便有线程转储文件也没有太大的用处的原因。</p><p></p><p>那么，解决方案是什么呢？</p><p></p><p>如果我们能够同时使用最初的命令式代码，又能实现简单的异步功能，那就太完美了。这就是Loom项目的用武之地了。</p><p></p><p></p><h2>Loom项目</h2><p></p><p></p><p>Loom项目允许我们临时创建任意数量的线程，而不必承担前文所述的各种负担。我们甚至不用关心到底要创建多少个线程，事实上，我们可以创建上百万个线程，而且它们的成本很低廉。</p><p></p><p>此处之外，我们还可以继续使用命令式和阻塞代码。所以，根本不用担心阻塞式的代码。</p><p></p><p>Java 19引入了虚拟线程，有了它之后，我们可以拥有任意数量的阻塞代码。</p><p></p><p>如果想要使用虚拟线程的话，我们可以使用如下的Executor：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/35/359ca3fc7ae53cde97d1f3076b551c05.png\" /></p><p></p><p>我们之前为Executor编写的代码不需要做任何改变，只需要传入newVirtualThreadPerTaskExecutor Executor服务即可。</p><p></p><p>虚拟线程会在原始线程之上运行，这些原始线程被称为平台线程。平台线程基本上也就是Fork/Join池中的线程。因此，通过运行虚拟线程，我们可以获得Fork/Join池带来的所有好处。</p><p></p><p>简而言之，虚拟线程的做法是，当它们看到阻塞调用时，就会让出它所占用的平台线程。然后，平台线程就能继续执行其他的虚拟线程。阻塞调用通常会在我们调用睡眠或网络操作时发生，当这些操作完成时，虚拟线程可以重新在平台线程中恢复，以完成其余的任务。</p><p></p><p>通过这种方式，我们没有因为空闲浪费任何的线程时间，它们一直处于繁忙状态。另一方面，虚拟线程是一个Java结构，它可以暂停，并在随后恢复，而不会消耗额外的CPU。</p><p></p><p>这使我们的编程变得非常简单。</p><p></p><p></p><h2>结论</h2><p></p><p></p><p>综上所述，对我们来讲，阻塞调用长期以来都是一个敌人。为了解决它，我们发明了很多方案。最后，基于所有的发明，我们提出了一个新的范式，那就是虚拟线程，有了它，我们不再需要把阻塞调用当作敌人了。</p><p></p><p>基于此，我们可以放心地调用任何阻塞操作，想调用多少就调用多少。</p><p></p><p>这就是我们对待阻塞操作和线程的历史。业界有很多连接二者的方式，都能使我们的开发工作更加轻松。</p><p></p><p>原文链接：</p><p><a href=\"https://www.javaadvent.com/2022/12/a-tale-of-two-cities-how-blocking-calls-are-treated.html\">https://www.javaadvent.com/2022/12/a-tale-of-two-cities-how-blocking-calls-are-treated.html</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/txS9hHTfxasv2uHBATgL\">Java近期新闻：Gradle 8.0、Maven、Payara平台、Piranha、Spring Framework、MyFaces和Piranha</a>\"</p><p><a href=\"https://www.infoq.cn/article/sLiRwa72fHzWvzC2HmKf\">深入OpenTelemetry源代码：Java探针的实现和二次开发</a>\"</p><p><a href=\"https://www.infoq.cn/article/YaBqqD7fd6kX97GbhkGm\">虚拟线程：大规模Java应用的新基石</a>\"</p>",
    "publish_time": "2023-03-09 08:51:49",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]