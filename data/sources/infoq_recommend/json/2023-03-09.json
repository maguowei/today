[
  {
    "title": "构建重启后依然可用的Windows服务",
    "url": "https://www.infoq.cn/article/sj95UdY5Vqp9Hcxd5XlZ",
    "summary": "<p>当使用C++为Windows编程时，使用Windows服务（Windows Services）几乎是难以避免的。在微软Windows操作系统中，Windows服务发挥着重要的作用，它们能够创建和管理长时间运行的进程，这些进程能够在睡眠、休眠、重启和关机的过程中幸存下来。但是，如果无法做到这一点会怎样呢？在选中<a href=\"https://www.howtogeek.com/243901/the-pros-and-cons-of-windows-10s-fast-startup-mode/\">快速启动（Fast Startup）</a>\"时，关闭计算机会导致服务无法重启，这会给程序带来灾难性的后果。微软在Windows Vista中引入的<a href=\"https://msrc-blog.microsoft.com/2008/10/13/service-isolation-explanation/\">Service Isolation</a>\"可能会导致这类灾难性的后果，在本文中将会阐述如何解决它。</p><p></p><h2>感谢Windows服务</h2><p></p><p></p><p>多年以来，我们一直在使用Windows服务，但是不管我们觉得有多么了解服务，或者有多么自信能够处理它，却始终会遇到更多的问题、挑战和麻烦。其中有些问题根本是没有文档的，或者我们“幸运”一点的话，会有一点糟糕的文档。</p><p></p><p>自从微软引入<a href=\"https://msrc-blog.microsoft.com/2008/10/13/service-isolation-explanation/\">服务隔离</a>\"之后，我们遇到的最令人恼火的问题之一就是当<a href=\"https://www.howtogeek.com/243901/the-pros-and-cons-of-windows-10s-fast-startup-mode/\">快速启动</a>\"选中时，计算机关闭后，无法重启服务。鉴于我们没有找到现成的解决方案，所以我们决定自动动手实现一个，这促成了持久化服务的开发。</p><p></p><p>但是，在深入研究和解释我们的解决方案之前，我们首先从基础知识开始，解释什么是服务，以及为什么要使用Windows服务。</p><p></p><p>NT服务（也叫做Windows服务）指的是由NT内核的服务控制管理器（Service Control Manager）加载的特殊进程，它会在Windows启动（在用户登录前）立即在后台运行。我们使用服务来执行核心和底层的操作系统任务，比如Web服务、事件日志、文件服务、帮助和支持、打印、加密和错误报告。</p><p></p><p>此外，服务使我们能够创建可执行的、长时间运行的应用程序。原因在于服务会在自己的Windows会话环境中运行，所以它不会干扰应用程序的其他组件或会话。显然，我们期望服务会在计算机启动后也自动启动，我们马上就会讨论该问题。</p><p></p><p>进一步来讲，这里显然有一个问题：我们为什么需要持久化的服务？答案很明显，服务应该能够：</p><p></p><p>持续在后台运行。在已登录用户的会话中，调用自身。作为一个看门狗（watchdog），确保给定的应用程序一直在运行。</p><p></p><p>Windows服务需要能够在睡眠、休眠、重启和关机时依然能够存活。但是，正如前文所述，当选中“<a href=\"http://www.howtogeek.com/243901/the-pros-and-cons-of-windows-10s-fast-startup-mode/\">快速启动</a>\"”时，计算机关机再启动的话，会出现一些特定的危险问题。在大多数场景中，服务无法重新启动。</p><p></p><p>因为我们正在开发的是一个反病毒软件，它应该在重启或关机后重新启动，这种情况造成了一个严重的问题，我们迫切需要解决它。</p><p></p><h2>实现良好的服务</h2><p></p><p></p><p>为了创建近乎完美的持久化Windows服务，我们必须首先解决几个底层的问题。</p><p></p><p>其中一个问题与服务隔离有关，被隔离的服务无法访问与任何特定用户相关的上下文。我们某个软件产品将数据存储到了c:\\users\\\\appdata\\local\\中，但是当它从我们的服务中运行的话，这个路径就是无效的，因为服务是在Session 0中运行的。除此之外，在重启后，服务会在所有用户登录之前启动，这形成了解决方案的第一部分：等待用户登录。</p><p></p><p>为了弄清如何做到这一点，我们<a href=\"https://www.codeproject.com/Questions/5061695/Running-a-windows-service-process-on-windows-serve\">在这里</a>\"发布了遇到的问题。</p><p></p><p>事实证明，这是一个没有完美解决方案的问题，但是，本文附带的代码已经得到了应用，并且经过了全面的测试，没有任何的问题。</p><p></p><h2>基础知识</h2><p></p><p></p><p>我们的代码结构和流程可能看起来很复杂，但是这是有一定原因的。在过去的十年间，服务已经与其他进程隔离。从那时开始，Windows服务会在SYSTEM用户账号下运行，而不是其他的用户账号，并且是<a href=\"https://msrc-blog.microsoft.com/2008/10/13/service-isolation-explanation/\">隔离运行的</a>\"。</p><p></p><p>隔离运行的原因在于，服务的功能很强大，可能是潜在的安全风险。正因为如此，微软引入了服务隔离。在这个变化之前，所有的服务会与应用一起在Session 0中运行。</p><p></p><p>但是，在引入了隔离之后（这是在Windows Vista中引入的），情况发生了变化。我们的代码背后的想法是通过调用<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasusera\">CreateProcessAsUserW</a>\"，让Windows服务以某个用户的身份启动自己，这一点将在后文详细阐述。我们的服务叫做SG_RevealerService，它有多个命令，当使用如下的命令行参数调用时，它们会采取相应的行为。</p><p></p><p><code lang=\"cpp\">#define SERVICE_COMMAND_INSTALL L\"Install\"             // The command line argument\n                                                       // for installing the service\n\n#define SERVICE_COMMAND_LAUNCHER L\"ServiceIsLauncher\"  // Launcher command for\n                                                       // NT service\n</code></p><p></p><p>当调用SG_RevealerService时，有三个选项：</p><p></p><p>选项1：不带有任何命令行参数进行调用。在这种情况下什么都不会发生。</p><p></p><p>选项2：带有Install命令行参数进行调用。在这种情况下，服务将自行安装，如果在哈希分隔符（#）添加了有效的可执行路径，服务将会启动，Windows看门狗会保持其一直运行。</p><p></p><p>然后，Service会使用<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasusera\">CreateProcessAsUserW()</a>\"运行自身，新的进程会在用户账号下运行。这给了Service访问上下文的能力，因为Service Isolation，调用实例是无法访问该上下文的。</p><p></p><p>选项3：使用ServiceIsLauncher命令行参数进行调用。服务客户端主应用将会启动。此时，入口函数表明服务已经以当前用户的权限启动了自身。现在，在Task Manager中，我们会看到SG_RevealerService的两个实例，其中一个在SYSTEM用户下，另一个在当前登录用户下。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/windows-services-reliable-restart/en/resources/1figure-1-task-manager-1671630831799.jpg\" /></p><p></p><p><code lang=\"cpp\">/*\nRunHost\n*/\n\nBOOL RunHost(LPWSTR HostExePath,LPWSTR CommandLineArguments)\n{\n    WriteToLog(L\"RunHost '%s'\",HostExePath);\n\n    STARTUPINFO startupInfo = {};\n    startupInfo.cb = sizeof(STARTUPINFO);\n    startupInfo.lpDesktop = (LPTSTR)_T(\"winsta0\\\\default\");\n\n    HANDLE hToken = 0;\n    BOOL bRes = FALSE;\n\n    LPVOID pEnv = NULL;\n    CreateEnvironmentBlock(&amp;pEnv, hToken, TRUE);\n\n    PROCESS_INFORMATION processInfoAgent = {};\n    PROCESS_INFORMATION processInfoHideProcess = {};\n    PROCESS_INFORMATION processInfoHideProcess32 = {};\n\n    if (PathFileExists(HostExePath))\n    {\n        std::wstring commandLine;\n        commandLine.reserve(1024);\n\n        commandLine += L\"\\\"\";\n        commandLine += HostExePath;\n        commandLine += L\"\\\" \\\"\";\n        commandLine += CommandLineArguments;\n        commandLine += L\"\\\"\";\n\n        WriteToLog(L\"launch host with CreateProcessAsUser ...  %s\",\n                     commandLine.c_str());\n\n        bRes = CreateProcessAsUserW(hToken, NULL, &amp;commandLine[0],\n               NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS |\n               CREATE_UNICODE_ENVIRONMENT | CREATE_NEW_CONSOLE |\n               CREATE_DEFAULT_ERROR_MODE, pEnv,\n            NULL, &amp;startupInfo, &amp;processInfoAgent);\n        if (bRes == FALSE)\n        {\n            DWORD   dwLastError = ::GetLastError();\n            TCHAR   lpBuffer[256] = _T(\"?\");\n            if (dwLastError != 0)    // Don't want to see an\n                                     // \"operation done successfully\" error ;-)\n            {\n                ::FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,    // It's a system error\n                    NULL,                                      // No string to be\n                                                               // formatted needed\n                    dwLastError,                               // Hey Windows: Please\n                                                               // explain this error!\n                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Do it in the standard\n                                                               // language\n                    lpBuffer,              // Put the message here\n                    255,                   // Number of bytes to store the message\n                    NULL);\n            }\n            WriteToLog(L\"CreateProcessAsUser failed - Command Line = %s Error : %s\",\n                         commandLine, lpBuffer);\n        }\n        else\n        {\n            if (!writeStringInRegistry(HKEY_LOCAL_MACHINE,\n               (PWCHAR)SERVICE_REG_KEY, (PWCHAR)SERVICE_KEY_NAME, HostExePath))\n            {\n                WriteToLog(L\"Failed to write registry\");\n            }\n        }\n    }\n    else\n    {\n        WriteToLog(L\"RunHost failed because path '%s' does not exists\", HostExePath);\n    }\n    hPrevAppProcess = processInfoAgent.hProcess;\n    \n    CloseHandle(hToken);\n    WriteToLog(L\"Run host end!\");\n\n    return bRes;\n}\n</code></p><p></p><h2>探测用户登录</h2><p></p><p></p><p>第一个挑战是仅在用户登录时，才启动一些动作。为了探测用户的登录，我们首先定义一个全局变量。</p><p></p><p><code lang=\"cpp\">bool g_bLoggedIn = false;\n</code></p><p></p><p>当用户登录时，它的值应该被设置为true 。</p><p></p><h3>订阅登录事件</h3><p></p><p></p><p>我们定义了如下的<a href=\"https://cplusplus.com/doc/tutorial/preprocessor/\">Preprocesor Directives</a>\"：</p><p></p><p><code lang=\"cpp\">#define EVENT_SUBSCRIBE_PATH    L\"Security\"\n#define EVENT_SUBSCRIBE_QUERY    L\"Event/System[EventID=4624]\"\n</code></p><p></p><p>当Service启动后，我们<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/winevt/nf-winevt-evtsubscribe\">订阅登录事件</a>\"，所以当用户登录时，我们会通过设置的回调函数得到一个告警，然后我们就可以继续后面的操作了。为了实现这一点，我们需要一个类来处理订阅的创建并等待事件回调。</p><p></p><p><code lang=\"cpp\">class UserLoginListner\n{\n    HANDLE hWait = NULL;\n    HANDLE hSubscription = NULL;\n\npublic:\n    ~UserLoginListner()\n    {\n        CloseHandle(hWait);\n        EvtClose(hSubscription);\n    }\n\n    UserLoginListner()\n    {\n        const wchar_t* pwsPath = EVENT_SUBSCRIBE_PATH;\n        const wchar_t* pwsQuery = EVENT_SUBSCRIBE_QUERY;\n\n        hWait = CreateEvent(NULL, FALSE, FALSE, NULL);\n\n        hSubscription = EvtSubscribe(NULL, NULL,\n            pwsPath, pwsQuery,\n            NULL,\n            hWait,\n            (EVT_SUBSCRIBE_CALLBACK)UserLoginListner::SubscriptionCallback,\n            EvtSubscribeToFutureEvents);\n        if (hSubscription == NULL)\n        {\n            DWORD status = GetLastError();\n\n            if (ERROR_EVT_CHANNEL_NOT_FOUND == status)\n                WriteToLog(L\"Channel %s was not found.\\n\", pwsPath);\n            else if (ERROR_EVT_INVALID_QUERY == status)\n                WriteToLog(L\"The query \\\"%s\\\" is not valid.\\n\", pwsQuery);\n            else\n                WriteToLog(L\"EvtSubscribe failed with %lu.\\n\", status);\n\n            CloseHandle(hWait);\n        }\n    }\n</code></p><p></p><p>然后，我们需要一个函数实现等待：</p><p></p><p><code lang=\"cpp\">void WaitForUserToLogIn()\n{\n    WriteToLog(L\"Waiting for a user to log in...\");\n    WaitForSingleObject(hWait, INFINITE);\n    WriteToLog(L\"Received a Logon event - a user has logged in\");\n}\n</code></p><p></p><p>我们还需要一个回调函数：</p><p></p><p><code lang=\"cpp\">static DWORD WINAPI SubscriptionCallback(EVT_SUBSCRIBE_NOTIFY_ACTION action, PVOID\n       pContext, EVT_HANDLE hEvent)\n{\n    if (action == EvtSubscribeActionDeliver)\n    {\n        WriteToLog(L\"SubscriptionCallback invoked.\");\n        HANDLE Handle = (HANDLE)(LONG_PTR)pContext;\n        SetEvent(Handle);\n    }\n\n    return ERROR_SUCCESS;\n}\n</code></p><p></p><p>接下来，需要做的就是添加具有如下内容的代码块：</p><p></p><p><code lang=\"cpp\">WriteToLog(L\"Launch client\\n\"); // launch client ...\n{\n    UserLoginListner WaitTillAUserLogins;\n    WaitTillAUserLogins.WaitForUserToLogIn();\n}\n</code></p><p></p><p>到达代码块的底部时，我们就可以确信一个用户已经登录了。</p><p></p><p>在本文后面的内容中，我们将会介绍如何检索登录用户的账号/用户名，以及如何使用GetLoggedInUser()函数。</p><p></p><h2>冒充用户</h2><p></p><p></p><p>当确定一个用户已经登录时，我们需要冒充他们。</p><p></p><p>如下的函数完成了这项工作。它不仅冒充了用户，还调用了<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasuserw\">CreateProcessAsUserW()</a>\"，以该用户的身份运行自己。通过这种方式，我们能够让服务访问用户的上下文，包括文档、桌面等，并允许服务使用用户界面，这对于从Session 0运行服务来讲是无法实现的。</p><p></p><p><a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasuserw\">CreateProcessAsUserW</a>\"创建了一个新的进程及其主线程，它会在给定用户的上下文中运行。</p><p></p><p><code lang=\"cpp\">//Function to run a process as active user from Windows service\nvoid ImpersonateActiveUserAndRun()\n{\n    DWORD session_id = -1;\n    DWORD session_count = 0;\n    WTS_SESSION_INFOW *pSession = NULL;\n\n    if (WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE, 0, 1, &amp;pSession, &amp;session_count))\n    {\n        WriteToLog(L\"WTSEnumerateSessions - success\");\n    }\n    else\n    {\n        WriteToLog(L\"WTSEnumerateSessions - failed. Error %d\",GetLastError());\n        return;\n    }\n    TCHAR szCurModule[MAX_PATH] = { 0 };\n\n    GetModuleFileName(NULL, szCurModule, MAX_PATH);\n\n\n    for (size_t i = 0; i &lt; session_count; i++)\n    {\n        session_id = pSession[i].SessionId;\n        WTS_CONNECTSTATE_CLASS wts_connect_state = WTSDisconnected;\n        WTS_CONNECTSTATE_CLASS* ptr_wts_connect_state = NULL;\n        DWORD bytes_returned = 0;\n        if (::WTSQuerySessionInformation(\n            WTS_CURRENT_SERVER_HANDLE,\n            session_id,\n            WTSConnectState,\n            reinterpret_cast(&amp;ptr_wts_connect_state),\n            &amp;bytes_returned))\n        {\n            wts_connect_state = *ptr_wts_connect_state;\n            ::WTSFreeMemory(ptr_wts_connect_state);\n            if (wts_connect_state != WTSActive) continue;\n        }\n        else\n        {\n            continue;\n        }\n\n        HANDLE hImpersonationToken;\n        if (!WTSQueryUserToken(session_id, &amp;hImpersonationToken))\n        {\n            continue;\n        }\n\n        //Get the actual token from impersonation one\n        DWORD neededSize1 = 0;\n        HANDLE *realToken = new HANDLE;\n        if (GetTokenInformation(hImpersonationToken, (::TOKEN_INFORMATION_CLASS) TokenLinkedToken, realToken, sizeof(HANDLE), &amp;neededSize1))\n        {\n            CloseHandle(hImpersonationToken);\n            hImpersonationToken = *realToken;\n        }\n        else\n        {\n            continue;\n        }\n        HANDLE hUserToken;\n        if (!DuplicateTokenEx(hImpersonationToken,\n            TOKEN_ASSIGN_PRIMARY | TOKEN_ALL_ACCESS | MAXIMUM_ALLOWED,\n            NULL,\n            SecurityImpersonation,\n            TokenPrimary,\n            &amp;hUserToken))\n        {\n            continue;\n        }\n\n\n        // Get user name of this process\n        WCHAR* pUserName;\n        DWORD user_name_len = 0;\n        if (WTSQuerySessionInformationW(WTS_CURRENT_SERVER_HANDLE, session_id, WTSUserName, &amp;pUserName, &amp;user_name_len))\n        {\n            //Now we got the user name stored in pUserName\n        }\n        // Free allocated memory                         \n        if (pUserName) WTSFreeMemory(pUserName);\n        ImpersonateLoggedOnUser(hUserToken);\n        STARTUPINFOW StartupInfo;\n        GetStartupInfoW(&amp;StartupInfo);\n        StartupInfo.cb = sizeof(STARTUPINFOW);\n        PROCESS_INFORMATION processInfo;\n        SECURITY_ATTRIBUTES Security1;\n        Security1.nLength = sizeof SECURITY_ATTRIBUTES;\n        SECURITY_ATTRIBUTES Security2;\n        Security2.nLength = sizeof SECURITY_ATTRIBUTES;\n        void* lpEnvironment = NULL;\n\n        // Obtain all needed necessary environment variables of the logged in user.\n        // They will then be passed to the new process we create.\n\n        BOOL resultEnv = CreateEnvironmentBlock(&amp;lpEnvironment, hUserToken, FALSE);\n        if (!resultEnv)\n        {\n            WriteToLog(L\"CreateEnvironmentBlock - failed. Error %d\",GetLastError());\n            continue;\n        }\n        std::wstring commandLine;\n        commandLine.reserve(1024);\n        commandLine += L\"\\\"\";\n        commandLine += szCurModule;\n        commandLine += L\"\\\" \\\"\";\n        commandLine += SERVICE_COMMAND_Launcher;\n        commandLine += L\"\\\"\";\n        WCHAR PP[1024]; //path and parameters\n        ZeroMemory(PP, 1024 * sizeof WCHAR);\n        wcscpy_s(PP, commandLine.c_str());\n\n        // Next we impersonate - by starting the process as if the current logged in user, has started it\n        BOOL result = CreateProcessAsUserW(hUserToken,\n            NULL,\n            PP,\n            NULL,\n            NULL,\n            FALSE,\n            NORMAL_PRIORITY_CLASS | CREATE_NEW_CONSOLE,\n            NULL,\n            NULL,\n            &amp;StartupInfo,\n            &amp;processInfo);\n\n        if (!result)\n        {\n            WriteToLog(L\"CreateProcessAsUser - failed. Error %d\",GetLastError());\n        }\n        else\n        {\n            WriteToLog(L\"CreateProcessAsUser - success\");\n        }\n        DestroyEnvironmentBlock(lpEnvironment);\n        CloseHandle(hImpersonationToken);\n        CloseHandle(hUserToken);\n        CloseHandle(realToken);\n        RevertToSelf();\n    }\n    WTSFreeMemory(pSession);\n}\n</code></p><p></p><h2>寻找已登录的用户</h2><p></p><p></p><p>为了寻找已登录用户的账号名，我们会使用如下的函数：</p><p></p><p><code lang=\"cpp\">std::wstring GetLoggedInUser()\n{\n    std::wstring user{L\"\"};\n    WTS_SESSION_INFO *SessionInfo;\n    unsigned long SessionCount;\n    unsigned long ActiveSessionId = -1;\n\n    if(WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE,\n                            0, 1, &amp;SessionInfo, &amp;SessionCount))\n    {\n        for (size_t i = 0; i &lt; SessionCount; i++)\n        {\n            if (SessionInfo[i].State == WTSActive ||\n                SessionInfo[i].State == WTSConnected)\n            {\n                ActiveSessionId = SessionInfo[i].SessionId;\n                break;\n            }\n        }\n\n        wchar_t *UserName;\n        if (ActiveSessionId != -1)\n        {\n            unsigned long BytesReturned;\n            if (WTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE,\n                ActiveSessionId, WTSUserName, &amp;UserName, &amp;BytesReturned))\n            {\n                user = UserName;        // Now we have the logged in user name\n                WTSFreeMemory(UserName);    \n            }\n        }\n        WTSFreeMemory(SessionInfo);\n    }\n    return user;\n}\n</code></p><p></p><p>在服务启动后不久，我们就要使用该函数。只要没有用户登录，这个函数就会返回一个空字符串，如果这样的话，我们就知道应该继续等待。</p><p></p><h2>看门狗是Service的好朋友</h2><p></p><p></p><p>Service与看门狗机制协同使用是很理想的方案。</p><p></p><p>这种机制将确保一个给定应用始终处于运行状态，如果它异常关闭的话，看门狗会重新启动它。我们要始终记住，如果用户通过Quit退出的话，我们不希望重启进程。但是，如果进程是通过Task Manager或其他方式被停掉的，我们会希望重启它。一个很好的例子是反病毒程序。我们想要确保恶意软件不能终止本应检测它的反病毒程序。</p><p></p><p>为了实现这一点，我们需要该Service为使用它的程序提供某种API，当该程序的用户选择“Quit”，程序会告知Service，程序的工作已经完成了，Service可以卸载自己了。</p><p></p><h2>一些构建基块</h2><p></p><p></p><p>接下来，我们介绍一些构建基块，要理解本文的代码，它们是必备的。</p><p></p><h3>GetExePath</h3><p></p><p></p><p>为了获取我们的Service或其他可执行文件的路径，如下的函数是非常便利的。</p><p></p><p><code lang=\"cpp\">/**\n * GetExePath() - returns the full path of the current executable.\n *\n * @param values - none.\n * @return a std::wstring containing the full path of the current executable.\n */\nstd::wstring GetExePath()\n{\n    wchar_t buffer[65536];\n    GetModuleFileName(NULL, buffer, sizeof(buffer) / sizeof(*buffer));\n    int pos = -1;\n    int index = 0;\n    while (buffer[index])\n    {\n        if (buffer[index] == L'\\\\' || buffer[index] == L'/')\n        {\n            pos = index;\n        }\n        index++;\n    }\n    buffer[pos + 1] = 0;\n    return buffer;\n}\n</code></p><p></p><h3>WriteLogFile</h3><p></p><p></p><p>当开发Windows Service时（以及其他任何软件），拥有一个日志机制都是很重要的。我们有一个非常复杂的日志机制，但是就本文而言，我添加了一个最小的日志函数，名为WriteToLog。它的运行机制类似于printf ，但是所有发送给它的内容不仅会被格式化，还会存储在一个日志文件中，以备日后检查。这个日志文件的大小会不断增长，因为会有新的日志条目追加到上面。</p><p></p><p>日志文件的路径，通常会位于Service的EXE的路径，但是，由于Service Isolation，在重启计算机后的一小段时间内，这个路径会<a href=\"https://serverfault.com/questions/114238/windows-service-can-i-configure-the-current-working-directory\">变成</a>\" <a href=\"https://serverfault.com/questions/114238/windows-service-can-i-configure-the-current-working-directory\">c:\\Windows\\System32</a>\"，我们并不希望如此。所以，我们的日志函数会检查exe的路径，并且不会假设<a href=\"https://learn.microsoft.com/en-us/windows/win32/fileio/changing-the-current-directory\">Current Directory</a>\"在Service的生命周期内会保持不变。</p><p></p><p><code lang=\"cpp\">/**\n * WriteToLog() - writes formatted text into a log file, and on screen (console)\n *\n * @param values - formatted text, such as L\"The result is %d\",result.\n * @return - none\n */\nvoid WriteToLog(LPCTSTR lpText, ...)\n{\n    FILE *fp;\n    wchar_t log_file[MAX_PATH]{L\"\"};\n    if(wcscmp(log_file,L\"\") == NULL)\n    {\n        wcscpy(log_file,GetExePath().c_str());\n        wcscat(log_file,L\"log.txt\");\n    }\n    // find gmt time, and store in buf_time\n    time_t rawtime;\n    struct tm* ptm;\n    wchar_t buf_time[DATETIME_BUFFER_SIZE];\n    time(&amp;rawtime);\n    ptm = gmtime(&amp;rawtime);\n    wcsftime(buf_time, sizeof(buf_time) / sizeof(*buf_time), L\"%d.%m.%Y %H:%M\", ptm);\n\n    // store passed messsage (lpText) to buffer_in\n    wchar_t buffer_in[BUFFER_SIZE];\n\n    va_list ptr;\n    va_start(ptr, lpText);\n\n    vswprintf(buffer_in, BUFFER_SIZE, lpText, ptr);\n    va_end(ptr);\n\n    // store output message to buffer_out - enabled multiple parameters in swprintf\n    wchar_t buffer_out[BUFFER_SIZE];\n\n    swprintf(buffer_out, BUFFER_SIZE, L\"%s %s\\n\", buf_time, buffer_in);\n\n    _wfopen_s(&amp;fp, log_file, L\"a,ccs=UTF-8\");\n    if (fp)\n    {\n        fwprintf(fp, L\"%s\\n\", buffer_out);\n        fclose(fp);\n    }\n    wcscat(buffer_out,L\"\\n\");HANDLE stdOut = GetStdHandle(STD_OUTPUT_HANDLE);\n    if (stdOut != NULL &amp;&amp; stdOut != INVALID_HANDLE_VALUE)\n    {\n        DWORD written = 0;\n        WriteConsole(stdOut, buffer_out, wcslen(buffer_out), &amp;written, NULL);\n    }\n}\n</code></p><p></p><h2>更多的构建基块：注册表相关的内容</h2><p></p><p></p><p>下面是一些我们用来存储看门狗可执行文件路径的函数，所以当计算机重启后，Service重新启动时，就能使用该路径。</p><p></p><p><code lang=\"cpp\">BOOL CreateRegistryKey(HKEY hKeyParent, PWCHAR subkey)\n{\n    DWORD dwDisposition; //Verify new key is created or open existing key\n    HKEY  hKey;\n    DWORD Ret;\n    Ret =\n        RegCreateKeyEx(\n            hKeyParent,\n            subkey,\n            0,\n            NULL,\n            REG_OPTION_NON_VOLATILE,\n            KEY_ALL_ACCESS,\n            NULL,\n            &amp;hKey,\n            &amp;dwDisposition);\n    if (Ret != ERROR_SUCCESS)\n    {\n        WriteToLog(L\"Error opening or creating new key\\n\");\n        return FALSE;\n    }\n    RegCloseKey(hKey); //close the key\n    return TRUE;\n}\n\nBOOL writeStringInRegistry(HKEY hKeyParent, PWCHAR subkey,\n                           PWCHAR valueName, PWCHAR strData)\n{\n    DWORD Ret;\n    HKEY hKey;\n    //Check if the registry exists\n    Ret = RegOpenKeyEx(\n        hKeyParent,\n        subkey,\n        0,\n        KEY_WRITE,\n        &amp;hKey\n    );\n    if (Ret == ERROR_SUCCESS)\n    {\n        if (ERROR_SUCCESS !=\n            RegSetValueEx(\n                hKey,\n                valueName,\n                0,\n                REG_SZ,\n                (LPBYTE)(strData),\n                ((((DWORD)lstrlen(strData) + 1)) * 2)))\n        {\n            RegCloseKey(hKey);\n            return FALSE;\n        }\n        RegCloseKey(hKey);\n        return TRUE;\n    }\n    return FALSE;\n}\n\nLONG GetStringRegKey(HKEY hKey, const std::wstring &amp;strValueName,\n                     std::wstring &amp;strValue, const std::wstring &amp;strDefaultValue)\n{\n    strValue = strDefaultValue;\n    TCHAR szBuffer[MAX_PATH];\n    DWORD dwBufferSize = sizeof(szBuffer);\n    ULONG nError;\n    nError = RegQueryValueEx(hKey, strValueName.c_str(), 0, NULL,\n             (LPBYTE)szBuffer, &amp;dwBufferSize);\n    if (nError == ERROR_SUCCESS)\n    {\n        strValue = szBuffer;\n        if (strValue.front() == _T('\"') &amp;&amp; strValue.back() == _T('\"'))\n        {\n            strValue.erase(0, 1); // erase the first character\n            strValue.erase(strValue.size() - 1); // erase the last character\n        }\n    }\n    return nError;\n}\n\nBOOL readStringFromRegistry(HKEY hKeyParent, PWCHAR subkey,\n                            PWCHAR valueName, std::wstring&amp; readData)\n{\n    HKEY hKey;\n    DWORD len = 1024;\n    DWORD readDataLen = len;\n    PWCHAR readBuffer = (PWCHAR)malloc(sizeof(PWCHAR) * len);\n    if (readBuffer == NULL)\n        return FALSE;\n    //Check if the registry exists\n    DWORD Ret = RegOpenKeyEx(\n        hKeyParent,\n        subkey,\n        0,\n        KEY_READ,\n        &amp;hKey\n    );\n    if (Ret == ERROR_SUCCESS)\n    {\n        Ret = RegQueryValueEx(\n            hKey,\n            valueName,\n            NULL,\n            NULL,\n            (BYTE*)readBuffer,\n            &amp;readDataLen\n        );\n        while (Ret == ERROR_MORE_DATA)\n        {\n            // Get a buffer that is big enough.\n            len += 1024;\n            readBuffer = (PWCHAR)realloc(readBuffer, len);\n            readDataLen = len;\n            Ret = RegQueryValueEx(\n                hKey,\n                valueName,\n                NULL,\n                NULL,\n                (BYTE*)readBuffer,\n                &amp;readDataLen\n            );\n        }\n        if (Ret != ERROR_SUCCESS)\n        {\n            RegCloseKey(hKey);\n            return false;;\n        }\n        readData = readBuffer;\n        RegCloseKey(hKey);\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n</code></p><p></p><h2>检查宿主（Host）是否在运行</h2><p></p><p></p><p>本文中的程序有一项核心能力，那就是保护我们的SampleApp（我们将其称为宿主），当它未运行时，就重新启动它（所以叫做看门狗）。在真实场景中，我们会检查宿主是被用户终止的（这是允许的），还是被恶意软件终止的（这是不允许的），在后一种情况下，我们将会重启它（否则，如果用户选择Quit，但应用程序将继续“骚扰”系统并反复执行）。</p><p></p><p>如下是它如何实现的：</p><p></p><p>我们创建了一个Timer事件，每隔一定的时间（不应该过于频繁），我们会检查宿主的进程是否在运行，如果没有的话，我们就启动它。我们使用了一个静态布尔型标记（is_running），用来表明我们已经处于该代码块中了，所以在处理过程中时，能够避免再次调用。这是在WM_TIMER代码块中始终要做的事情，因为当定时器设置的频率过高的话，代码块在调用时，前一个WM_TIMER事件的代码依然在执行。</p><p></p><p>我们还通过检查g_bLoggedIn布尔标记来判断是否有用户登录。</p><p></p><p><code lang=\"cpp\">  case WM_TIMER:\n        {\n            if (is_running) break;\n            WriteToLog(L\"Timer event\");\n            is_running = true;\n            HANDLE hProcessSnap;\n            PROCESSENTRY32 pe32;\n            bool found{ false };\n\n            WriteToLog(L\"Enumerating all processess...\");\n            // Take a snapshot of all processes in the system.\n            hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n            if (hProcessSnap == INVALID_HANDLE_VALUE)\n            {\n                WriteToLog(L\"Failed to call CreateToolhelp32Snapshot(). Error code %d\",GetLastError());\n                is_running = false;\n                return 1;\n            }\n\n            // Set the size of the structure before using it.\n            pe32.dwSize = sizeof(PROCESSENTRY32);\n\n            // Retrieve information about the first process,\n            // and exit if unsuccessful\n            if (!Process32First(hProcessSnap, &amp;pe32))\n            {\n                WriteToLog(L\"Failed to call Process32First(). Error code %d\",GetLastError());\n                CloseHandle(hProcessSnap);          // clean the snapshot object\n                is_running=false;\n                break;\n            }\n\n            // Now walk the snapshot of processes, and\n            // display information about each process in turn\n            DWORD svchost_parent_pid = 0;\n            DWORD dllhost_parent_pid = 0;\n            std::wstring szPath = L\"\";\n\n            if (readStringFromRegistry(HKEY_LOCAL_MACHINE, (PWCHAR)SERVICE_REG_KEY, (PWCHAR)SERVICE_KEY_NAME, szPath))\n            {\n                m_szExeToFind = szPath.substr(szPath.find_last_of(L\"/\\\\\") + 1);    // The process name is the executable name only\n                m_szExeToRun = szPath;                                            // The executable to run is the full path\n            }\n            else\n            {\n                WriteToLog(L\"Error reading ExeToFind from the Registry\");\n            }\n\n            do\n            {\n                if (wcsstr( m_szExeToFind.c_str(), pe32.szExeFile))\n                {\n                    WriteToLog(L\"%s is running\",m_szExeToFind.c_str());\n                    found = true;\n                    is_running=false;\n                    break;\n                }\n                if (!g_bLoggedIn)\n                {\n                    WriteToLog(L\"WatchDog isn't starting '%s' because user isn't logged in\",m_szExeToFind.c_str());\n                    return 1;\n                }\n            }\n            while (Process32Next(hProcessSnap, &amp;pe32));\n            if (!found)\n            {\n                WriteToLog(L\"'%s' is not running. Need to start it\",m_szExeToFind.c_str());\n                if (!m_szExeToRun.empty())    // watchdog start the host app\n                {\n                    if (!g_bLoggedIn)\n                    {\n                        WriteToLog(L\"WatchDog isn't starting '%s' because user isn't logged in\",m_szExeToFind.c_str());\n                        return 1;\n                    }\n                    ImpersonateActiveUserAndRun();\n\n                    RunHost((LPWSTR)m_szExeToRun.c_str(), (LPWSTR)L\"\");\n\n                }\n                else\n                {\n                    WriteToLog(L\"m_szExeToRun is empty\");\n                }\n            }\n            CloseHandle(hProcessSnap);\n        }\n        is_running=false;\n        break;\n</code></p><p></p><h2>如何测试Service</h2><p></p><p></p><p>当我们想要测试这个解决方案时，我们雇佣了20个资深的和协作的测试人员。在整个工作过程中，越来多的测试均成功了。在某些时候，它在我们自己的Surface Pro笔记本电脑上运行地非常完美，但是，我们的一位员工报告说，在他的计算机上，在关闭之后，服务没有再次启动，或者在<a href=\"https://en.wikipedia.org/wiki/Protection_ring\">Ring 3</a>\"下没有启动自身。这是一个好消息，因为在开发过程中，当你怀疑某个地方存在缺陷的时候，最糟糕的事情就是无法找到它，也无法重现它。总而言之，10%的测试者报告了问题。因此，这里发布的版本在我们员工的电脑上运行完美，然而2%的测试者仍然不时报告问题。换句话说，SampleApp在关闭计算机并打开后无法启动。</p><p></p><p>如下是对测试服务和看门狗的说明。</p><p></p><h3>SampleApp</h3><p></p><p></p><p>我们包含了一个由Visual Studio Wizard生成的样例应用，作为“宿主”应用，它会被看门狗确保一直运行。你可以单独运行它，外观如下面的图片所示。该应用没有做太多的事情。实际上，它一无是处……</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/windows-services-reliable-restart/en/resources/1figure-2-sample-app-1671630831799.jpg\" /></p><p></p><p>在后面的内容中，我们将提供测试服务和看门狗的指南。你可以在<a href=\"https://github.com/securedglobe/PersistantService\">GitHub</a>\"下载源码。</p><p></p><h3>从CMD中运行</h3><p></p><p>以管理员身份打开CMD。将当前目录变更至Service的EXE所在的路径并输入：</p><p></p><p>SG_RevealerService.exe Install#SampleApp.exe</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/windows-services-reliable-restart/en/resources/1figure-3-command-prompt-1671630831799.jpg\" /></p><p></p><p>你可以看到，我们有两个元素：</p><p></p><p>command元素，这里是Installargument元素，通过哈希分隔符(#)连接至命令元素，应该是我们希望看门狗观察的可执行文件。</p><p></p><p>Service首先会启动SampleApp，从此之后，如果你尝试终止或杀死SampleApp的话，看门狗会在几秒钟后重启它。如果重启，关掉计算机并再次启动，你会发现Service会再次出现并启动SampleApp。这就是我们的Service的目标和功能。</p><p></p><h3>卸载</h3><p></p><p></p><p>最后，如果要停止和卸载服务，我们包含了一个uninstall.bat脚本，它如下所示：</p><p></p><p><code lang=\"cpp\">sc stop sg_revealerservice\nsc delete sg_revealerservice\ntaskkill /f /im sampleapp.exe\ntaskkill /f /im sg_revealerservice.exe\n</code></p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/windows-services-reliable-restart/en/resources/1figure-4-delete-service-1671630831799.jpg\" /></p><p></p><h3>结论</h3><p></p><p></p><p>Windows Service在微软Windows操作系统中起着关键作用，它支持创建和管理长期运行的进程。在有些场景下，如果勾选了“快速启动”，在正常关闭并重启计算机后，服务往往无法重启。本文的目的是创建一个持久化的服务，在Windows重新启动或关机后，能够始终运行并重新启动。其中一个主要的问题与Service Isolation有关。隔离本身（在Windows Vista版本中引入）是很重要和强大的，然而，当我们需要与用户空间交互时，这会产生一些限制。当服务重新启动时，我们希望它能与用户空间进行交互，然而它不能发生地太早（在任何用户登录之前）。不过，你可以通过订阅登录事件来解决这个问题。Service与看门狗机制协同使用是很理想的方案。这种机制能够确保给定的应用一直在运行，并且在异常关闭时，它将重新启动。我们在前面描述的方法的基础上，成功地开发了这个机制，这使得它可以一直运行，在用户登录时得到提醒，并且能够与用户空间进行交互。定时器事件能够用来监控被观察进程的运行。在开发过程中，好的日志机制始终是非常有用的，我们可以使用简单的日志工具，并在需要的时候，使用更为复杂的工具。最终的解决方案必须要进行测试。代码被确认并验证可以运行后，多达2%的测试人员依然可能会报告错误，这是有一定原因的。</p><p></p><p>作者简介：</p><p>Michael Haephrati是Secured Globe, Inc.的联合创始人和首席执行官，该公司于2008年与他的妻子Ruth Haephrati一起创建。Michael是一位音乐作曲家、发明家，也是一位专门从事软件开发和信息安全的专家。凭借30多年的经验，Michael形成了独特的视角，将技术和创新结合起来，并强调终端用户的体验。多年来，Michael领导了各种客户的创新项目和技术。他是“Learning C++”（https://www.manning.com/books/learning-c-plus-plus）的作者，该书由Manning Publications出版。</p><p></p><p>Ruth Haephrati是Secured Globe, Inc.的联合创始人和首席执行官，该公司于2008年与她的丈夫Michael Haephrati一起创建。Ruth是一位作家、演讲者、企业家、网络安全和网络取证专家。在过去的25年里，Ruth与微软和IBM等领先公司合作，担任顾问和C++实践专家。她最近参与了为一个国际客户开发的最先进的反恶意软件技术。在业余时间，Ruth是一位插画家、画家、野生动物摄影师和世界旅行者。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/windows-services-reliable-restart/\">The Service and the Beast: Building a Windows Service that Does Not Fail to Restart</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/3IX18md3WG2kjiM43Kgv\">Windows 11发布重大更新：ChatGPT版Bing集成到任务栏中，可快速访问AI聊天功能</a>\"</p><p><a href=\"https://www.infoq.cn/article/97LDs46oamxHYLAhp5uK\">Kubernetes 1.26 版本正式发布：改进 Windows 支持，加强网络安全和管理功能</a>\"</p>",
    "publish_time": "2023-03-09 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]