[
  {
    "title": "构建重启后依然可用的Windows服务",
    "url": "https://www.infoq.cn/article/sj95UdY5Vqp9Hcxd5XlZ",
    "summary": "<p>当使用C++为Windows编程时，使用Windows服务（Windows Services）几乎是难以避免的。在微软Windows操作系统中，Windows服务发挥着重要的作用，它们能够创建和管理长时间运行的进程，这些进程能够在睡眠、休眠、重启和关机的过程中幸存下来。但是，如果无法做到这一点会怎样呢？在选中<a href=\"https://www.howtogeek.com/243901/the-pros-and-cons-of-windows-10s-fast-startup-mode/\">快速启动（Fast Startup）</a>\"时，关闭计算机会导致服务无法重启，这会给程序带来灾难性的后果。微软在Windows Vista中引入的<a href=\"https://msrc-blog.microsoft.com/2008/10/13/service-isolation-explanation/\">Service Isolation</a>\"可能会导致这类灾难性的后果，在本文中将会阐述如何解决它。</p><p></p><h2>感谢Windows服务</h2><p></p><p></p><p>多年以来，我们一直在使用Windows服务，但是不管我们觉得有多么了解服务，或者有多么自信能够处理它，却始终会遇到更多的问题、挑战和麻烦。其中有些问题根本是没有文档的，或者我们“幸运”一点的话，会有一点糟糕的文档。</p><p></p><p>自从微软引入<a href=\"https://msrc-blog.microsoft.com/2008/10/13/service-isolation-explanation/\">服务隔离</a>\"之后，我们遇到的最令人恼火的问题之一就是当<a href=\"https://www.howtogeek.com/243901/the-pros-and-cons-of-windows-10s-fast-startup-mode/\">快速启动</a>\"选中时，计算机关闭后，无法重启服务。鉴于我们没有找到现成的解决方案，所以我们决定自动动手实现一个，这促成了持久化服务的开发。</p><p></p><p>但是，在深入研究和解释我们的解决方案之前，我们首先从基础知识开始，解释什么是服务，以及为什么要使用Windows服务。</p><p></p><p>NT服务（也叫做Windows服务）指的是由NT内核的服务控制管理器（Service Control Manager）加载的特殊进程，它会在Windows启动（在用户登录前）立即在后台运行。我们使用服务来执行核心和底层的操作系统任务，比如Web服务、事件日志、文件服务、帮助和支持、打印、加密和错误报告。</p><p></p><p>此外，服务使我们能够创建可执行的、长时间运行的应用程序。原因在于服务会在自己的Windows会话环境中运行，所以它不会干扰应用程序的其他组件或会话。显然，我们期望服务会在计算机启动后也自动启动，我们马上就会讨论该问题。</p><p></p><p>进一步来讲，这里显然有一个问题：我们为什么需要持久化的服务？答案很明显，服务应该能够：</p><p></p><p>持续在后台运行。在已登录用户的会话中，调用自身。作为一个看门狗（watchdog），确保给定的应用程序一直在运行。</p><p></p><p>Windows服务需要能够在睡眠、休眠、重启和关机时依然能够存活。但是，正如前文所述，当选中“<a href=\"http://www.howtogeek.com/243901/the-pros-and-cons-of-windows-10s-fast-startup-mode/\">快速启动</a>\"”时，计算机关机再启动的话，会出现一些特定的危险问题。在大多数场景中，服务无法重新启动。</p><p></p><p>因为我们正在开发的是一个反病毒软件，它应该在重启或关机后重新启动，这种情况造成了一个严重的问题，我们迫切需要解决它。</p><p></p><h2>实现良好的服务</h2><p></p><p></p><p>为了创建近乎完美的持久化Windows服务，我们必须首先解决几个底层的问题。</p><p></p><p>其中一个问题与服务隔离有关，被隔离的服务无法访问与任何特定用户相关的上下文。我们某个软件产品将数据存储到了c:\\users\\\\appdata\\local\\中，但是当它从我们的服务中运行的话，这个路径就是无效的，因为服务是在Session 0中运行的。除此之外，在重启后，服务会在所有用户登录之前启动，这形成了解决方案的第一部分：等待用户登录。</p><p></p><p>为了弄清如何做到这一点，我们<a href=\"https://www.codeproject.com/Questions/5061695/Running-a-windows-service-process-on-windows-serve\">在这里</a>\"发布了遇到的问题。</p><p></p><p>事实证明，这是一个没有完美解决方案的问题，但是，本文附带的代码已经得到了应用，并且经过了全面的测试，没有任何的问题。</p><p></p><h2>基础知识</h2><p></p><p></p><p>我们的代码结构和流程可能看起来很复杂，但是这是有一定原因的。在过去的十年间，服务已经与其他进程隔离。从那时开始，Windows服务会在SYSTEM用户账号下运行，而不是其他的用户账号，并且是<a href=\"https://msrc-blog.microsoft.com/2008/10/13/service-isolation-explanation/\">隔离运行的</a>\"。</p><p></p><p>隔离运行的原因在于，服务的功能很强大，可能是潜在的安全风险。正因为如此，微软引入了服务隔离。在这个变化之前，所有的服务会与应用一起在Session 0中运行。</p><p></p><p>但是，在引入了隔离之后（这是在Windows Vista中引入的），情况发生了变化。我们的代码背后的想法是通过调用<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasusera\">CreateProcessAsUserW</a>\"，让Windows服务以某个用户的身份启动自己，这一点将在后文详细阐述。我们的服务叫做SG_RevealerService，它有多个命令，当使用如下的命令行参数调用时，它们会采取相应的行为。</p><p></p><p><code lang=\"cpp\">#define SERVICE_COMMAND_INSTALL L\"Install\"             // The command line argument\n                                                       // for installing the service\n\n#define SERVICE_COMMAND_LAUNCHER L\"ServiceIsLauncher\"  // Launcher command for\n                                                       // NT service\n</code></p><p></p><p>当调用SG_RevealerService时，有三个选项：</p><p></p><p>选项1：不带有任何命令行参数进行调用。在这种情况下什么都不会发生。</p><p></p><p>选项2：带有Install命令行参数进行调用。在这种情况下，服务将自行安装，如果在哈希分隔符（#）添加了有效的可执行路径，服务将会启动，Windows看门狗会保持其一直运行。</p><p></p><p>然后，Service会使用<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasusera\">CreateProcessAsUserW()</a>\"运行自身，新的进程会在用户账号下运行。这给了Service访问上下文的能力，因为Service Isolation，调用实例是无法访问该上下文的。</p><p></p><p>选项3：使用ServiceIsLauncher命令行参数进行调用。服务客户端主应用将会启动。此时，入口函数表明服务已经以当前用户的权限启动了自身。现在，在Task Manager中，我们会看到SG_RevealerService的两个实例，其中一个在SYSTEM用户下，另一个在当前登录用户下。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/windows-services-reliable-restart/en/resources/1figure-1-task-manager-1671630831799.jpg\" /></p><p></p><p><code lang=\"cpp\">/*\nRunHost\n*/\n\nBOOL RunHost(LPWSTR HostExePath,LPWSTR CommandLineArguments)\n{\n    WriteToLog(L\"RunHost '%s'\",HostExePath);\n\n    STARTUPINFO startupInfo = {};\n    startupInfo.cb = sizeof(STARTUPINFO);\n    startupInfo.lpDesktop = (LPTSTR)_T(\"winsta0\\\\default\");\n\n    HANDLE hToken = 0;\n    BOOL bRes = FALSE;\n\n    LPVOID pEnv = NULL;\n    CreateEnvironmentBlock(&amp;pEnv, hToken, TRUE);\n\n    PROCESS_INFORMATION processInfoAgent = {};\n    PROCESS_INFORMATION processInfoHideProcess = {};\n    PROCESS_INFORMATION processInfoHideProcess32 = {};\n\n    if (PathFileExists(HostExePath))\n    {\n        std::wstring commandLine;\n        commandLine.reserve(1024);\n\n        commandLine += L\"\\\"\";\n        commandLine += HostExePath;\n        commandLine += L\"\\\" \\\"\";\n        commandLine += CommandLineArguments;\n        commandLine += L\"\\\"\";\n\n        WriteToLog(L\"launch host with CreateProcessAsUser ...  %s\",\n                     commandLine.c_str());\n\n        bRes = CreateProcessAsUserW(hToken, NULL, &amp;commandLine[0],\n               NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS |\n               CREATE_UNICODE_ENVIRONMENT | CREATE_NEW_CONSOLE |\n               CREATE_DEFAULT_ERROR_MODE, pEnv,\n            NULL, &amp;startupInfo, &amp;processInfoAgent);\n        if (bRes == FALSE)\n        {\n            DWORD   dwLastError = ::GetLastError();\n            TCHAR   lpBuffer[256] = _T(\"?\");\n            if (dwLastError != 0)    // Don't want to see an\n                                     // \"operation done successfully\" error ;-)\n            {\n                ::FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,    // It's a system error\n                    NULL,                                      // No string to be\n                                                               // formatted needed\n                    dwLastError,                               // Hey Windows: Please\n                                                               // explain this error!\n                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Do it in the standard\n                                                               // language\n                    lpBuffer,              // Put the message here\n                    255,                   // Number of bytes to store the message\n                    NULL);\n            }\n            WriteToLog(L\"CreateProcessAsUser failed - Command Line = %s Error : %s\",\n                         commandLine, lpBuffer);\n        }\n        else\n        {\n            if (!writeStringInRegistry(HKEY_LOCAL_MACHINE,\n               (PWCHAR)SERVICE_REG_KEY, (PWCHAR)SERVICE_KEY_NAME, HostExePath))\n            {\n                WriteToLog(L\"Failed to write registry\");\n            }\n        }\n    }\n    else\n    {\n        WriteToLog(L\"RunHost failed because path '%s' does not exists\", HostExePath);\n    }\n    hPrevAppProcess = processInfoAgent.hProcess;\n    \n    CloseHandle(hToken);\n    WriteToLog(L\"Run host end!\");\n\n    return bRes;\n}\n</code></p><p></p><h2>探测用户登录</h2><p></p><p></p><p>第一个挑战是仅在用户登录时，才启动一些动作。为了探测用户的登录，我们首先定义一个全局变量。</p><p></p><p><code lang=\"cpp\">bool g_bLoggedIn = false;\n</code></p><p></p><p>当用户登录时，它的值应该被设置为true 。</p><p></p><h3>订阅登录事件</h3><p></p><p></p><p>我们定义了如下的<a href=\"https://cplusplus.com/doc/tutorial/preprocessor/\">Preprocesor Directives</a>\"：</p><p></p><p><code lang=\"cpp\">#define EVENT_SUBSCRIBE_PATH    L\"Security\"\n#define EVENT_SUBSCRIBE_QUERY    L\"Event/System[EventID=4624]\"\n</code></p><p></p><p>当Service启动后，我们<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/winevt/nf-winevt-evtsubscribe\">订阅登录事件</a>\"，所以当用户登录时，我们会通过设置的回调函数得到一个告警，然后我们就可以继续后面的操作了。为了实现这一点，我们需要一个类来处理订阅的创建并等待事件回调。</p><p></p><p><code lang=\"cpp\">class UserLoginListner\n{\n    HANDLE hWait = NULL;\n    HANDLE hSubscription = NULL;\n\npublic:\n    ~UserLoginListner()\n    {\n        CloseHandle(hWait);\n        EvtClose(hSubscription);\n    }\n\n    UserLoginListner()\n    {\n        const wchar_t* pwsPath = EVENT_SUBSCRIBE_PATH;\n        const wchar_t* pwsQuery = EVENT_SUBSCRIBE_QUERY;\n\n        hWait = CreateEvent(NULL, FALSE, FALSE, NULL);\n\n        hSubscription = EvtSubscribe(NULL, NULL,\n            pwsPath, pwsQuery,\n            NULL,\n            hWait,\n            (EVT_SUBSCRIBE_CALLBACK)UserLoginListner::SubscriptionCallback,\n            EvtSubscribeToFutureEvents);\n        if (hSubscription == NULL)\n        {\n            DWORD status = GetLastError();\n\n            if (ERROR_EVT_CHANNEL_NOT_FOUND == status)\n                WriteToLog(L\"Channel %s was not found.\\n\", pwsPath);\n            else if (ERROR_EVT_INVALID_QUERY == status)\n                WriteToLog(L\"The query \\\"%s\\\" is not valid.\\n\", pwsQuery);\n            else\n                WriteToLog(L\"EvtSubscribe failed with %lu.\\n\", status);\n\n            CloseHandle(hWait);\n        }\n    }\n</code></p><p></p><p>然后，我们需要一个函数实现等待：</p><p></p><p><code lang=\"cpp\">void WaitForUserToLogIn()\n{\n    WriteToLog(L\"Waiting for a user to log in...\");\n    WaitForSingleObject(hWait, INFINITE);\n    WriteToLog(L\"Received a Logon event - a user has logged in\");\n}\n</code></p><p></p><p>我们还需要一个回调函数：</p><p></p><p><code lang=\"cpp\">static DWORD WINAPI SubscriptionCallback(EVT_SUBSCRIBE_NOTIFY_ACTION action, PVOID\n       pContext, EVT_HANDLE hEvent)\n{\n    if (action == EvtSubscribeActionDeliver)\n    {\n        WriteToLog(L\"SubscriptionCallback invoked.\");\n        HANDLE Handle = (HANDLE)(LONG_PTR)pContext;\n        SetEvent(Handle);\n    }\n\n    return ERROR_SUCCESS;\n}\n</code></p><p></p><p>接下来，需要做的就是添加具有如下内容的代码块：</p><p></p><p><code lang=\"cpp\">WriteToLog(L\"Launch client\\n\"); // launch client ...\n{\n    UserLoginListner WaitTillAUserLogins;\n    WaitTillAUserLogins.WaitForUserToLogIn();\n}\n</code></p><p></p><p>到达代码块的底部时，我们就可以确信一个用户已经登录了。</p><p></p><p>在本文后面的内容中，我们将会介绍如何检索登录用户的账号/用户名，以及如何使用GetLoggedInUser()函数。</p><p></p><h2>冒充用户</h2><p></p><p></p><p>当确定一个用户已经登录时，我们需要冒充他们。</p><p></p><p>如下的函数完成了这项工作。它不仅冒充了用户，还调用了<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasuserw\">CreateProcessAsUserW()</a>\"，以该用户的身份运行自己。通过这种方式，我们能够让服务访问用户的上下文，包括文档、桌面等，并允许服务使用用户界面，这对于从Session 0运行服务来讲是无法实现的。</p><p></p><p><a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasuserw\">CreateProcessAsUserW</a>\"创建了一个新的进程及其主线程，它会在给定用户的上下文中运行。</p><p></p><p><code lang=\"cpp\">//Function to run a process as active user from Windows service\nvoid ImpersonateActiveUserAndRun()\n{\n    DWORD session_id = -1;\n    DWORD session_count = 0;\n    WTS_SESSION_INFOW *pSession = NULL;\n\n    if (WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE, 0, 1, &amp;pSession, &amp;session_count))\n    {\n        WriteToLog(L\"WTSEnumerateSessions - success\");\n    }\n    else\n    {\n        WriteToLog(L\"WTSEnumerateSessions - failed. Error %d\",GetLastError());\n        return;\n    }\n    TCHAR szCurModule[MAX_PATH] = { 0 };\n\n    GetModuleFileName(NULL, szCurModule, MAX_PATH);\n\n\n    for (size_t i = 0; i &lt; session_count; i++)\n    {\n        session_id = pSession[i].SessionId;\n        WTS_CONNECTSTATE_CLASS wts_connect_state = WTSDisconnected;\n        WTS_CONNECTSTATE_CLASS* ptr_wts_connect_state = NULL;\n        DWORD bytes_returned = 0;\n        if (::WTSQuerySessionInformation(\n            WTS_CURRENT_SERVER_HANDLE,\n            session_id,\n            WTSConnectState,\n            reinterpret_cast(&amp;ptr_wts_connect_state),\n            &amp;bytes_returned))\n        {\n            wts_connect_state = *ptr_wts_connect_state;\n            ::WTSFreeMemory(ptr_wts_connect_state);\n            if (wts_connect_state != WTSActive) continue;\n        }\n        else\n        {\n            continue;\n        }\n\n        HANDLE hImpersonationToken;\n        if (!WTSQueryUserToken(session_id, &amp;hImpersonationToken))\n        {\n            continue;\n        }\n\n        //Get the actual token from impersonation one\n        DWORD neededSize1 = 0;\n        HANDLE *realToken = new HANDLE;\n        if (GetTokenInformation(hImpersonationToken, (::TOKEN_INFORMATION_CLASS) TokenLinkedToken, realToken, sizeof(HANDLE), &amp;neededSize1))\n        {\n            CloseHandle(hImpersonationToken);\n            hImpersonationToken = *realToken;\n        }\n        else\n        {\n            continue;\n        }\n        HANDLE hUserToken;\n        if (!DuplicateTokenEx(hImpersonationToken,\n            TOKEN_ASSIGN_PRIMARY | TOKEN_ALL_ACCESS | MAXIMUM_ALLOWED,\n            NULL,\n            SecurityImpersonation,\n            TokenPrimary,\n            &amp;hUserToken))\n        {\n            continue;\n        }\n\n\n        // Get user name of this process\n        WCHAR* pUserName;\n        DWORD user_name_len = 0;\n        if (WTSQuerySessionInformationW(WTS_CURRENT_SERVER_HANDLE, session_id, WTSUserName, &amp;pUserName, &amp;user_name_len))\n        {\n            //Now we got the user name stored in pUserName\n        }\n        // Free allocated memory                         \n        if (pUserName) WTSFreeMemory(pUserName);\n        ImpersonateLoggedOnUser(hUserToken);\n        STARTUPINFOW StartupInfo;\n        GetStartupInfoW(&amp;StartupInfo);\n        StartupInfo.cb = sizeof(STARTUPINFOW);\n        PROCESS_INFORMATION processInfo;\n        SECURITY_ATTRIBUTES Security1;\n        Security1.nLength = sizeof SECURITY_ATTRIBUTES;\n        SECURITY_ATTRIBUTES Security2;\n        Security2.nLength = sizeof SECURITY_ATTRIBUTES;\n        void* lpEnvironment = NULL;\n\n        // Obtain all needed necessary environment variables of the logged in user.\n        // They will then be passed to the new process we create.\n\n        BOOL resultEnv = CreateEnvironmentBlock(&amp;lpEnvironment, hUserToken, FALSE);\n        if (!resultEnv)\n        {\n            WriteToLog(L\"CreateEnvironmentBlock - failed. Error %d\",GetLastError());\n            continue;\n        }\n        std::wstring commandLine;\n        commandLine.reserve(1024);\n        commandLine += L\"\\\"\";\n        commandLine += szCurModule;\n        commandLine += L\"\\\" \\\"\";\n        commandLine += SERVICE_COMMAND_Launcher;\n        commandLine += L\"\\\"\";\n        WCHAR PP[1024]; //path and parameters\n        ZeroMemory(PP, 1024 * sizeof WCHAR);\n        wcscpy_s(PP, commandLine.c_str());\n\n        // Next we impersonate - by starting the process as if the current logged in user, has started it\n        BOOL result = CreateProcessAsUserW(hUserToken,\n            NULL,\n            PP,\n            NULL,\n            NULL,\n            FALSE,\n            NORMAL_PRIORITY_CLASS | CREATE_NEW_CONSOLE,\n            NULL,\n            NULL,\n            &amp;StartupInfo,\n            &amp;processInfo);\n\n        if (!result)\n        {\n            WriteToLog(L\"CreateProcessAsUser - failed. Error %d\",GetLastError());\n        }\n        else\n        {\n            WriteToLog(L\"CreateProcessAsUser - success\");\n        }\n        DestroyEnvironmentBlock(lpEnvironment);\n        CloseHandle(hImpersonationToken);\n        CloseHandle(hUserToken);\n        CloseHandle(realToken);\n        RevertToSelf();\n    }\n    WTSFreeMemory(pSession);\n}\n</code></p><p></p><h2>寻找已登录的用户</h2><p></p><p></p><p>为了寻找已登录用户的账号名，我们会使用如下的函数：</p><p></p><p><code lang=\"cpp\">std::wstring GetLoggedInUser()\n{\n    std::wstring user{L\"\"};\n    WTS_SESSION_INFO *SessionInfo;\n    unsigned long SessionCount;\n    unsigned long ActiveSessionId = -1;\n\n    if(WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE,\n                            0, 1, &amp;SessionInfo, &amp;SessionCount))\n    {\n        for (size_t i = 0; i &lt; SessionCount; i++)\n        {\n            if (SessionInfo[i].State == WTSActive ||\n                SessionInfo[i].State == WTSConnected)\n            {\n                ActiveSessionId = SessionInfo[i].SessionId;\n                break;\n            }\n        }\n\n        wchar_t *UserName;\n        if (ActiveSessionId != -1)\n        {\n            unsigned long BytesReturned;\n            if (WTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE,\n                ActiveSessionId, WTSUserName, &amp;UserName, &amp;BytesReturned))\n            {\n                user = UserName;        // Now we have the logged in user name\n                WTSFreeMemory(UserName);    \n            }\n        }\n        WTSFreeMemory(SessionInfo);\n    }\n    return user;\n}\n</code></p><p></p><p>在服务启动后不久，我们就要使用该函数。只要没有用户登录，这个函数就会返回一个空字符串，如果这样的话，我们就知道应该继续等待。</p><p></p><h2>看门狗是Service的好朋友</h2><p></p><p></p><p>Service与看门狗机制协同使用是很理想的方案。</p><p></p><p>这种机制将确保一个给定应用始终处于运行状态，如果它异常关闭的话，看门狗会重新启动它。我们要始终记住，如果用户通过Quit退出的话，我们不希望重启进程。但是，如果进程是通过Task Manager或其他方式被停掉的，我们会希望重启它。一个很好的例子是反病毒程序。我们想要确保恶意软件不能终止本应检测它的反病毒程序。</p><p></p><p>为了实现这一点，我们需要该Service为使用它的程序提供某种API，当该程序的用户选择“Quit”，程序会告知Service，程序的工作已经完成了，Service可以卸载自己了。</p><p></p><h2>一些构建基块</h2><p></p><p></p><p>接下来，我们介绍一些构建基块，要理解本文的代码，它们是必备的。</p><p></p><h3>GetExePath</h3><p></p><p></p><p>为了获取我们的Service或其他可执行文件的路径，如下的函数是非常便利的。</p><p></p><p><code lang=\"cpp\">/**\n * GetExePath() - returns the full path of the current executable.\n *\n * @param values - none.\n * @return a std::wstring containing the full path of the current executable.\n */\nstd::wstring GetExePath()\n{\n    wchar_t buffer[65536];\n    GetModuleFileName(NULL, buffer, sizeof(buffer) / sizeof(*buffer));\n    int pos = -1;\n    int index = 0;\n    while (buffer[index])\n    {\n        if (buffer[index] == L'\\\\' || buffer[index] == L'/')\n        {\n            pos = index;\n        }\n        index++;\n    }\n    buffer[pos + 1] = 0;\n    return buffer;\n}\n</code></p><p></p><h3>WriteLogFile</h3><p></p><p></p><p>当开发Windows Service时（以及其他任何软件），拥有一个日志机制都是很重要的。我们有一个非常复杂的日志机制，但是就本文而言，我添加了一个最小的日志函数，名为WriteToLog。它的运行机制类似于printf ，但是所有发送给它的内容不仅会被格式化，还会存储在一个日志文件中，以备日后检查。这个日志文件的大小会不断增长，因为会有新的日志条目追加到上面。</p><p></p><p>日志文件的路径，通常会位于Service的EXE的路径，但是，由于Service Isolation，在重启计算机后的一小段时间内，这个路径会<a href=\"https://serverfault.com/questions/114238/windows-service-can-i-configure-the-current-working-directory\">变成</a>\" <a href=\"https://serverfault.com/questions/114238/windows-service-can-i-configure-the-current-working-directory\">c:\\Windows\\System32</a>\"，我们并不希望如此。所以，我们的日志函数会检查exe的路径，并且不会假设<a href=\"https://learn.microsoft.com/en-us/windows/win32/fileio/changing-the-current-directory\">Current Directory</a>\"在Service的生命周期内会保持不变。</p><p></p><p><code lang=\"cpp\">/**\n * WriteToLog() - writes formatted text into a log file, and on screen (console)\n *\n * @param values - formatted text, such as L\"The result is %d\",result.\n * @return - none\n */\nvoid WriteToLog(LPCTSTR lpText, ...)\n{\n    FILE *fp;\n    wchar_t log_file[MAX_PATH]{L\"\"};\n    if(wcscmp(log_file,L\"\") == NULL)\n    {\n        wcscpy(log_file,GetExePath().c_str());\n        wcscat(log_file,L\"log.txt\");\n    }\n    // find gmt time, and store in buf_time\n    time_t rawtime;\n    struct tm* ptm;\n    wchar_t buf_time[DATETIME_BUFFER_SIZE];\n    time(&amp;rawtime);\n    ptm = gmtime(&amp;rawtime);\n    wcsftime(buf_time, sizeof(buf_time) / sizeof(*buf_time), L\"%d.%m.%Y %H:%M\", ptm);\n\n    // store passed messsage (lpText) to buffer_in\n    wchar_t buffer_in[BUFFER_SIZE];\n\n    va_list ptr;\n    va_start(ptr, lpText);\n\n    vswprintf(buffer_in, BUFFER_SIZE, lpText, ptr);\n    va_end(ptr);\n\n    // store output message to buffer_out - enabled multiple parameters in swprintf\n    wchar_t buffer_out[BUFFER_SIZE];\n\n    swprintf(buffer_out, BUFFER_SIZE, L\"%s %s\\n\", buf_time, buffer_in);\n\n    _wfopen_s(&amp;fp, log_file, L\"a,ccs=UTF-8\");\n    if (fp)\n    {\n        fwprintf(fp, L\"%s\\n\", buffer_out);\n        fclose(fp);\n    }\n    wcscat(buffer_out,L\"\\n\");HANDLE stdOut = GetStdHandle(STD_OUTPUT_HANDLE);\n    if (stdOut != NULL &amp;&amp; stdOut != INVALID_HANDLE_VALUE)\n    {\n        DWORD written = 0;\n        WriteConsole(stdOut, buffer_out, wcslen(buffer_out), &amp;written, NULL);\n    }\n}\n</code></p><p></p><h2>更多的构建基块：注册表相关的内容</h2><p></p><p></p><p>下面是一些我们用来存储看门狗可执行文件路径的函数，所以当计算机重启后，Service重新启动时，就能使用该路径。</p><p></p><p><code lang=\"cpp\">BOOL CreateRegistryKey(HKEY hKeyParent, PWCHAR subkey)\n{\n    DWORD dwDisposition; //Verify new key is created or open existing key\n    HKEY  hKey;\n    DWORD Ret;\n    Ret =\n        RegCreateKeyEx(\n            hKeyParent,\n            subkey,\n            0,\n            NULL,\n            REG_OPTION_NON_VOLATILE,\n            KEY_ALL_ACCESS,\n            NULL,\n            &amp;hKey,\n            &amp;dwDisposition);\n    if (Ret != ERROR_SUCCESS)\n    {\n        WriteToLog(L\"Error opening or creating new key\\n\");\n        return FALSE;\n    }\n    RegCloseKey(hKey); //close the key\n    return TRUE;\n}\n\nBOOL writeStringInRegistry(HKEY hKeyParent, PWCHAR subkey,\n                           PWCHAR valueName, PWCHAR strData)\n{\n    DWORD Ret;\n    HKEY hKey;\n    //Check if the registry exists\n    Ret = RegOpenKeyEx(\n        hKeyParent,\n        subkey,\n        0,\n        KEY_WRITE,\n        &amp;hKey\n    );\n    if (Ret == ERROR_SUCCESS)\n    {\n        if (ERROR_SUCCESS !=\n            RegSetValueEx(\n                hKey,\n                valueName,\n                0,\n                REG_SZ,\n                (LPBYTE)(strData),\n                ((((DWORD)lstrlen(strData) + 1)) * 2)))\n        {\n            RegCloseKey(hKey);\n            return FALSE;\n        }\n        RegCloseKey(hKey);\n        return TRUE;\n    }\n    return FALSE;\n}\n\nLONG GetStringRegKey(HKEY hKey, const std::wstring &amp;strValueName,\n                     std::wstring &amp;strValue, const std::wstring &amp;strDefaultValue)\n{\n    strValue = strDefaultValue;\n    TCHAR szBuffer[MAX_PATH];\n    DWORD dwBufferSize = sizeof(szBuffer);\n    ULONG nError;\n    nError = RegQueryValueEx(hKey, strValueName.c_str(), 0, NULL,\n             (LPBYTE)szBuffer, &amp;dwBufferSize);\n    if (nError == ERROR_SUCCESS)\n    {\n        strValue = szBuffer;\n        if (strValue.front() == _T('\"') &amp;&amp; strValue.back() == _T('\"'))\n        {\n            strValue.erase(0, 1); // erase the first character\n            strValue.erase(strValue.size() - 1); // erase the last character\n        }\n    }\n    return nError;\n}\n\nBOOL readStringFromRegistry(HKEY hKeyParent, PWCHAR subkey,\n                            PWCHAR valueName, std::wstring&amp; readData)\n{\n    HKEY hKey;\n    DWORD len = 1024;\n    DWORD readDataLen = len;\n    PWCHAR readBuffer = (PWCHAR)malloc(sizeof(PWCHAR) * len);\n    if (readBuffer == NULL)\n        return FALSE;\n    //Check if the registry exists\n    DWORD Ret = RegOpenKeyEx(\n        hKeyParent,\n        subkey,\n        0,\n        KEY_READ,\n        &amp;hKey\n    );\n    if (Ret == ERROR_SUCCESS)\n    {\n        Ret = RegQueryValueEx(\n            hKey,\n            valueName,\n            NULL,\n            NULL,\n            (BYTE*)readBuffer,\n            &amp;readDataLen\n        );\n        while (Ret == ERROR_MORE_DATA)\n        {\n            // Get a buffer that is big enough.\n            len += 1024;\n            readBuffer = (PWCHAR)realloc(readBuffer, len);\n            readDataLen = len;\n            Ret = RegQueryValueEx(\n                hKey,\n                valueName,\n                NULL,\n                NULL,\n                (BYTE*)readBuffer,\n                &amp;readDataLen\n            );\n        }\n        if (Ret != ERROR_SUCCESS)\n        {\n            RegCloseKey(hKey);\n            return false;;\n        }\n        readData = readBuffer;\n        RegCloseKey(hKey);\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n</code></p><p></p><h2>检查宿主（Host）是否在运行</h2><p></p><p></p><p>本文中的程序有一项核心能力，那就是保护我们的SampleApp（我们将其称为宿主），当它未运行时，就重新启动它（所以叫做看门狗）。在真实场景中，我们会检查宿主是被用户终止的（这是允许的），还是被恶意软件终止的（这是不允许的），在后一种情况下，我们将会重启它（否则，如果用户选择Quit，但应用程序将继续“骚扰”系统并反复执行）。</p><p></p><p>如下是它如何实现的：</p><p></p><p>我们创建了一个Timer事件，每隔一定的时间（不应该过于频繁），我们会检查宿主的进程是否在运行，如果没有的话，我们就启动它。我们使用了一个静态布尔型标记（is_running），用来表明我们已经处于该代码块中了，所以在处理过程中时，能够避免再次调用。这是在WM_TIMER代码块中始终要做的事情，因为当定时器设置的频率过高的话，代码块在调用时，前一个WM_TIMER事件的代码依然在执行。</p><p></p><p>我们还通过检查g_bLoggedIn布尔标记来判断是否有用户登录。</p><p></p><p><code lang=\"cpp\">  case WM_TIMER:\n        {\n            if (is_running) break;\n            WriteToLog(L\"Timer event\");\n            is_running = true;\n            HANDLE hProcessSnap;\n            PROCESSENTRY32 pe32;\n            bool found{ false };\n\n            WriteToLog(L\"Enumerating all processess...\");\n            // Take a snapshot of all processes in the system.\n            hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n            if (hProcessSnap == INVALID_HANDLE_VALUE)\n            {\n                WriteToLog(L\"Failed to call CreateToolhelp32Snapshot(). Error code %d\",GetLastError());\n                is_running = false;\n                return 1;\n            }\n\n            // Set the size of the structure before using it.\n            pe32.dwSize = sizeof(PROCESSENTRY32);\n\n            // Retrieve information about the first process,\n            // and exit if unsuccessful\n            if (!Process32First(hProcessSnap, &amp;pe32))\n            {\n                WriteToLog(L\"Failed to call Process32First(). Error code %d\",GetLastError());\n                CloseHandle(hProcessSnap);          // clean the snapshot object\n                is_running=false;\n                break;\n            }\n\n            // Now walk the snapshot of processes, and\n            // display information about each process in turn\n            DWORD svchost_parent_pid = 0;\n            DWORD dllhost_parent_pid = 0;\n            std::wstring szPath = L\"\";\n\n            if (readStringFromRegistry(HKEY_LOCAL_MACHINE, (PWCHAR)SERVICE_REG_KEY, (PWCHAR)SERVICE_KEY_NAME, szPath))\n            {\n                m_szExeToFind = szPath.substr(szPath.find_last_of(L\"/\\\\\") + 1);    // The process name is the executable name only\n                m_szExeToRun = szPath;                                            // The executable to run is the full path\n            }\n            else\n            {\n                WriteToLog(L\"Error reading ExeToFind from the Registry\");\n            }\n\n            do\n            {\n                if (wcsstr( m_szExeToFind.c_str(), pe32.szExeFile))\n                {\n                    WriteToLog(L\"%s is running\",m_szExeToFind.c_str());\n                    found = true;\n                    is_running=false;\n                    break;\n                }\n                if (!g_bLoggedIn)\n                {\n                    WriteToLog(L\"WatchDog isn't starting '%s' because user isn't logged in\",m_szExeToFind.c_str());\n                    return 1;\n                }\n            }\n            while (Process32Next(hProcessSnap, &amp;pe32));\n            if (!found)\n            {\n                WriteToLog(L\"'%s' is not running. Need to start it\",m_szExeToFind.c_str());\n                if (!m_szExeToRun.empty())    // watchdog start the host app\n                {\n                    if (!g_bLoggedIn)\n                    {\n                        WriteToLog(L\"WatchDog isn't starting '%s' because user isn't logged in\",m_szExeToFind.c_str());\n                        return 1;\n                    }\n                    ImpersonateActiveUserAndRun();\n\n                    RunHost((LPWSTR)m_szExeToRun.c_str(), (LPWSTR)L\"\");\n\n                }\n                else\n                {\n                    WriteToLog(L\"m_szExeToRun is empty\");\n                }\n            }\n            CloseHandle(hProcessSnap);\n        }\n        is_running=false;\n        break;\n</code></p><p></p><h2>如何测试Service</h2><p></p><p></p><p>当我们想要测试这个解决方案时，我们雇佣了20个资深的和协作的测试人员。在整个工作过程中，越来多的测试均成功了。在某些时候，它在我们自己的Surface Pro笔记本电脑上运行地非常完美，但是，我们的一位员工报告说，在他的计算机上，在关闭之后，服务没有再次启动，或者在<a href=\"https://en.wikipedia.org/wiki/Protection_ring\">Ring 3</a>\"下没有启动自身。这是一个好消息，因为在开发过程中，当你怀疑某个地方存在缺陷的时候，最糟糕的事情就是无法找到它，也无法重现它。总而言之，10%的测试者报告了问题。因此，这里发布的版本在我们员工的电脑上运行完美，然而2%的测试者仍然不时报告问题。换句话说，SampleApp在关闭计算机并打开后无法启动。</p><p></p><p>如下是对测试服务和看门狗的说明。</p><p></p><h3>SampleApp</h3><p></p><p></p><p>我们包含了一个由Visual Studio Wizard生成的样例应用，作为“宿主”应用，它会被看门狗确保一直运行。你可以单独运行它，外观如下面的图片所示。该应用没有做太多的事情。实际上，它一无是处……</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/windows-services-reliable-restart/en/resources/1figure-2-sample-app-1671630831799.jpg\" /></p><p></p><p>在后面的内容中，我们将提供测试服务和看门狗的指南。你可以在<a href=\"https://github.com/securedglobe/PersistantService\">GitHub</a>\"下载源码。</p><p></p><h3>从CMD中运行</h3><p></p><p>以管理员身份打开CMD。将当前目录变更至Service的EXE所在的路径并输入：</p><p></p><p>SG_RevealerService.exe Install#SampleApp.exe</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/windows-services-reliable-restart/en/resources/1figure-3-command-prompt-1671630831799.jpg\" /></p><p></p><p>你可以看到，我们有两个元素：</p><p></p><p>command元素，这里是Installargument元素，通过哈希分隔符(#)连接至命令元素，应该是我们希望看门狗观察的可执行文件。</p><p></p><p>Service首先会启动SampleApp，从此之后，如果你尝试终止或杀死SampleApp的话，看门狗会在几秒钟后重启它。如果重启，关掉计算机并再次启动，你会发现Service会再次出现并启动SampleApp。这就是我们的Service的目标和功能。</p><p></p><h3>卸载</h3><p></p><p></p><p>最后，如果要停止和卸载服务，我们包含了一个uninstall.bat脚本，它如下所示：</p><p></p><p><code lang=\"cpp\">sc stop sg_revealerservice\nsc delete sg_revealerservice\ntaskkill /f /im sampleapp.exe\ntaskkill /f /im sg_revealerservice.exe\n</code></p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/windows-services-reliable-restart/en/resources/1figure-4-delete-service-1671630831799.jpg\" /></p><p></p><h3>结论</h3><p></p><p></p><p>Windows Service在微软Windows操作系统中起着关键作用，它支持创建和管理长期运行的进程。在有些场景下，如果勾选了“快速启动”，在正常关闭并重启计算机后，服务往往无法重启。本文的目的是创建一个持久化的服务，在Windows重新启动或关机后，能够始终运行并重新启动。其中一个主要的问题与Service Isolation有关。隔离本身（在Windows Vista版本中引入）是很重要和强大的，然而，当我们需要与用户空间交互时，这会产生一些限制。当服务重新启动时，我们希望它能与用户空间进行交互，然而它不能发生地太早（在任何用户登录之前）。不过，你可以通过订阅登录事件来解决这个问题。Service与看门狗机制协同使用是很理想的方案。这种机制能够确保给定的应用一直在运行，并且在异常关闭时，它将重新启动。我们在前面描述的方法的基础上，成功地开发了这个机制，这使得它可以一直运行，在用户登录时得到提醒，并且能够与用户空间进行交互。定时器事件能够用来监控被观察进程的运行。在开发过程中，好的日志机制始终是非常有用的，我们可以使用简单的日志工具，并在需要的时候，使用更为复杂的工具。最终的解决方案必须要进行测试。代码被确认并验证可以运行后，多达2%的测试人员依然可能会报告错误，这是有一定原因的。</p><p></p><p>作者简介：</p><p>Michael Haephrati是Secured Globe, Inc.的联合创始人和首席执行官，该公司于2008年与他的妻子Ruth Haephrati一起创建。Michael是一位音乐作曲家、发明家，也是一位专门从事软件开发和信息安全的专家。凭借30多年的经验，Michael形成了独特的视角，将技术和创新结合起来，并强调终端用户的体验。多年来，Michael领导了各种客户的创新项目和技术。他是“Learning C++”（https://www.manning.com/books/learning-c-plus-plus）的作者，该书由Manning Publications出版。</p><p></p><p>Ruth Haephrati是Secured Globe, Inc.的联合创始人和首席执行官，该公司于2008年与她的丈夫Michael Haephrati一起创建。Ruth是一位作家、演讲者、企业家、网络安全和网络取证专家。在过去的25年里，Ruth与微软和IBM等领先公司合作，担任顾问和C++实践专家。她最近参与了为一个国际客户开发的最先进的反恶意软件技术。在业余时间，Ruth是一位插画家、画家、野生动物摄影师和世界旅行者。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/windows-services-reliable-restart/\">The Service and the Beast: Building a Windows Service that Does Not Fail to Restart</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/3IX18md3WG2kjiM43Kgv\">Windows 11发布重大更新：ChatGPT版Bing集成到任务栏中，可快速访问AI聊天功能</a>\"</p><p><a href=\"https://www.infoq.cn/article/97LDs46oamxHYLAhp5uK\">Kubernetes 1.26 版本正式发布：改进 Windows 支持，加强网络安全和管理功能</a>\"</p>",
    "publish_time": "2023-03-09 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "在Java中我们该如何应对阻塞调用",
    "url": "https://www.infoq.cn/article/Tda86qL5beKOIkIRoYBU",
    "summary": "<p></p><blockquote>本文最初发表于<a href=\"https://www.javaadvent.com/2022/12/a-tale-of-two-cities-how-blocking-calls-are-treated.html\">Java Advent网站</a>\"，经原作者<a href=\"https://foojay.io/today/author/bazlur-rahman/\">A N M Bazlur Rahman</a>\"授权，由InfoQ中文站翻译分享。</blockquote><p></p><p></p><p>Java已经有20多年的历史了，它一直是软件开发领域的主导力量，这种情况应该还会继续下去。然而，它之所以表现如此优异，是有多种原因的，其中之一就是并发。Java通过引入一个内置的线程模型开始了它的并发旅程。</p><p></p><p>在本文中，我将会讨论关于线程模型的一些历史知识，阐述它们是如何帮助我们形成使用Java进行编程时的理解和实践的，以及我们目前处于何处和它的一个特殊问题。</p><p></p><p>这篇文章会有点长，但是我相信你会喜欢它的。</p><p></p><p>让我们开始这段旅程吧！</p><p></p><h2>Java是由线程组成的</h2><p></p><p></p><p>从诞生之初，Java就引入了线程。线程是Java中的基本执行单元。这意味着我们要运行的所有Java代码都需要由线程来执行。线程是Java平台上执行环境的独立单元。</p><p></p><p>由此我们可以看出，如果一个程序有更多的线程，那它就有更多可以执行代码的地方。这意味着可以同时做更多的事情，从而给我们带来很多收益。一个特别的收益就是，通过利用机器上所有可用的资源，这能够提高应用的吞吐量。借助这种方式，我们能够从程序中获得更多的效益。</p><p></p><p>线程广泛存在于Java平台的各个层面中。</p><p></p><p>线程不仅能够执行代码，它还会在其栈中跟踪方法的调用。所以，如果Java程序在执行过程中遇到问题的话，我们会抛出异常。异常中会包含栈跟踪信息，基于此我们可以判断出错误的原因。由此，我们可以说线程是获取栈跟踪信息的一种方式。</p><p></p><p>此处，如果需要通过IDE调试程序的话，我们也会用到线程。如果需要对程序或程序的一部分进行剖析（profile）的话，我们也会用到线程。Java垃圾收集器会运行在一个单独的线程中。所有的这一切都证明，并发或者”线程“是编程平台的一个重要组成部分。</p><p></p><p></p><h2>但是，线程是昂贵的</h2><p></p><p></p><p>在现代Java web应用中，吞吐量是通过使用并发连接实现的。通常情况下，客户端的每个请求都会有一个专门的线程。现代操作系统可以处理上百万的并发连接。这表明，如果我们有更多的并发连接，就能实现更高的吞吐量。</p><p></p><p>这个结论似乎是合理的，但现实情况远非如此。原因在于，我们无法创建尽可能多的线程来实现这一点。</p><p></p><p>线程是数量有限的昂贵资源。创建一个线程需要在堆外占用2 MiB的内存。需要记住的另外一件事情是，按照传统的做法，Java线程仅仅对操作系统线程做个一层很薄的封装。我们只能创建数量有限的线程。即便我们有了大量的线程，也无法始终保证应用整体的性能。上下文的内容切换会有相关的成本。</p><p></p><p>你可以通过运行如下的样例看一下能够创建多少个线程。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/3f/3f7025ce4fb501729f27baf39a8be3f8.png\" /></p><p></p><p>到目前为止，我们已经讨论了Java线程的重要性以及它们的一些限制。那么，我们再进一步深入讨论一下。</p><p></p><p></p><h2>我们现在遇到了什么问题</h2><p></p><p></p><p>现代软件应用开发需要处理大量的数据，而且应用的使用率也会很高。这就带来了相关的成本问题。如果我们不留意的话，云计算的成本会迅速累积。</p><p></p><p>我们已经确认，创建线程的成本并不低，而且它们的数量是有限制的，所以我们不能浪费任何线程，而是要充分利用它们的能力。但实际上，情况并非如此。在传统的编程模型中，当我们调用一些需要时间才能获取响应的逻辑时，它会阻塞当前线程。例如，如果我们进行一个网络调用（可能是微服务或数据库调用）的话，用来进行调用的线程会被阻塞，直到得到结果为止。在等待结果的过程中，线程什么事情都不会做，基本上就是处于空闲状态，浪费了宝贵的资源，从而导致云账单的无谓增长。</p><p></p><p>因此，基于上述假设，可以得出结论，阻塞调用对我们并不是什么好事儿。</p><p></p><p>我们可以看一个样例。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/99/990dcc77434fc94fabe1a5d6a1708087.png\" /></p><p></p><p>在上述的代码中，我们进行了五个方法的调用。假设所有的方法均需要一些时间来进行处理。为了简单起见，我们假设它们都需要200毫秒的时间来处理。</p><p></p><p>由于我们是一个接一个地进行所有的调用，这将需要至少200*5=1000毫秒来完成该方法。因此，开始所有这些调用的线程必须等待它们全部完成。</p><p></p><p>在这个场景中，我们可以看到，调用calculateCreditForPerson()方法的线程在大部分时间内都是阻塞的，因为它在等待后续方法的完成。当阻塞的时候，它没有做任何事情。基本上来讲，它的资源因为不能做任何事情而被浪费了。</p><p></p><p>问题是，我们该如何才能改善它呢？</p><p></p><p>目前，业界已经有很多方案尝试来改善这种情况，使线程在这种情况下不会被阻塞。我将从Java历史的最开始说起。</p><p></p><p></p><h2>经典的实现方式</h2><p></p><p></p><p>上述样例中，在方法内部的各个方法调用并不都是互相依赖的。所以，第二个、第三个和第四个调用可以并行进行。如果这三个方法并行执行的话，我们就可以做一些改进。这样，调用者线程将花费更少的时间，这意味着更少的阻塞时间。这将是一个巨大的改进。在这里，我们没有解决阻塞的问题，但是负责调用该方法的主线程处于阻塞状态的时间会大幅减少。它将有更多的时间去做其他的事情。</p><p></p><p>那么，我们该如何实现这一经典的方式呢？</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/27/2773717c71082b3dcdcd3511c5028767.png\" /></p><p></p><p>最终的代码将类似于如上所示。我们将临时创建一个新的线程，并将结果存储在一个AtomicReference中。</p><p></p><p>这种方式很不错，但是我们无法控制要创建多少个线程。如果持续地创建临时线程，我们最终可能会创建过多的线程，这对应用是有害的。此外，如果试图创建过多线程的话，应用可能会抛出java.lang.OutOfMemoryError异常。</p><p></p><p>所以，我们需要进一步地改进。</p><p></p><p></p><h2>Executor框架</h2><p></p><p></p><p>Java 5引入了Executor框架，以及Future和Callable/Runnable。它允许我们控制要创建多少个线程，并对它们进行池化管理。</p><p></p><p>基于此，我们可以按照如下方式改善上述代码：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/09/090c76126aca39d1d9540aa6f526d24e.png\" /></p><p></p><p>对于代码编写来讲，这是一个相当大的改进，但是我们尚未达到目的。Future的机制依然非常复杂。对它的get()调用依然是一个阻塞式的调用。尽管我们进行的是异步调用，但最终还是需要一个阻塞式调用以便于从Future中获取值。</p><p></p><p>另外一个问题在于，它有可能会导致缓存受损（cache corruption，作者在这里指的应该是需要跨CPU内核存取数据，从而导致CPU级别的缓存失效——译者注）。例如，如果主线程向线程池提交任务的话，该任务将会由池中的某个线程来执行。主线程需要数据，但是这些数据却在另外一个线程中。这两个线程可能会位于不同的内核上，从而导致缓存受损。除此之外，在不同核心的上下文之间进行切换也是代价高昂的操作。</p><p></p><p>它还需要使用组合操作。所以，代码更多是命令式的。命令式的代码本身没有什么问题，不过函数式和声明式代码也很有意思。所以，至少我们在这里还可以进行一些改进。</p><p></p><p></p><h2>Fork/Join池</h2><p></p><p></p><p>Java引入了Fork/Join池，它是Java 5所引入的ExecutorService的实现，也是Executor框架的实现。它解决了我们在旧的Executor框架中遇到的很多问题，如缓存受损的问题。除此之外，它的运行理念是，刚刚创建的一批任务很可能会需要更紧密的缓存。这意味着，新创建的任务应该在同一个CPU上运行，而旧的任务可能需要在另外一个CPU上运行。与其他线程池实现相比，Fork/Join池中的每个线程都有自己的队列。此外，Fork/Join 池的实现采用了工作窃取（work-stealing）算法。如果池中的某个线程完成了自己的任务，它可以从另外一个线程的队尾窃取任务。所有的这些都能帮助我们实现更好的性能。</p><p></p><p></p><h2>将这一切组合在一起</h2><p></p><p></p><p>Java 8基于Fork/Join池引入了CompletableFuture。它包含了我们非常喜欢的组合特性。有了它，我们可以将上述代码改写成如下所示的样子：</p><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/10/10abf64040999afbc6fedc1904009df1.png\" /></p><p></p><p></p><h2>反应式Java</h2><p></p><p></p><p>非常不错，我们已经得到了自己想要的一切，也就是通过可组合性实现性能的提升。但是，市场上还有其他的替代方案。像RxJava、Akka、Eclipse Vert.x、Spring WebFlux、Slick这样的反应式框架，也能够为我们带来性能和可组合性的收益。我们来看看WebFlux的样例。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/cf/cf4537824efcb5dd2d9de1d62f1f03af.png\" /></p><p></p><p>但是，这种方式也有一些弊端，比如：</p><p></p><p>这种框架的学习曲线比较陡峭。有些模式对初学者来说可能会很难理解。与之相关的认知体验要求很高，这会损害代码的阅读体验。出现任何问题都很难调试。因为我们不知道特定的代码会在哪个线程上运行，完成任务的路径可能是各种各样的。这就是为何即便有线程转储文件也没有太大的用处的原因。</p><p></p><p>那么，解决方案是什么呢？</p><p></p><p>如果我们能够同时使用最初的命令式代码，又能实现简单的异步功能，那就太完美了。这就是Loom项目的用武之地了。</p><p></p><p></p><h2>Loom项目</h2><p></p><p></p><p>Loom项目允许我们临时创建任意数量的线程，而不必承担前文所述的各种负担。我们甚至不用关心到底要创建多少个线程，事实上，我们可以创建上百万个线程，而且它们的成本很低廉。</p><p></p><p>此处之外，我们还可以继续使用命令式和阻塞代码。所以，根本不用担心阻塞式的代码。</p><p></p><p>Java 19引入了虚拟线程，有了它之后，我们可以拥有任意数量的阻塞代码。</p><p></p><p>如果想要使用虚拟线程的话，我们可以使用如下的Executor：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/35/359ca3fc7ae53cde97d1f3076b551c05.png\" /></p><p></p><p>我们之前为Executor编写的代码不需要做任何改变，只需要传入newVirtualThreadPerTaskExecutor Executor服务即可。</p><p></p><p>虚拟线程会在原始线程之上运行，这些原始线程被称为平台线程。平台线程基本上也就是Fork/Join池中的线程。因此，通过运行虚拟线程，我们可以获得Fork/Join池带来的所有好处。</p><p></p><p>简而言之，虚拟线程的做法是，当它们看到阻塞调用时，就会让出它所占用的平台线程。然后，平台线程就能继续执行其他的虚拟线程。阻塞调用通常会在我们调用睡眠或网络操作时发生，当这些操作完成时，虚拟线程可以重新在平台线程中恢复，以完成其余的任务。</p><p></p><p>通过这种方式，我们没有因为空闲浪费任何的线程时间，它们一直处于繁忙状态。另一方面，虚拟线程是一个Java结构，它可以暂停，并在随后恢复，而不会消耗额外的CPU。</p><p></p><p>这使我们的编程变得非常简单。</p><p></p><p></p><h2>结论</h2><p></p><p></p><p>综上所述，对我们来讲，阻塞调用长期以来都是一个敌人。为了解决它，我们发明了很多方案。最后，基于所有的发明，我们提出了一个新的范式，那就是虚拟线程，有了它，我们不再需要把阻塞调用当作敌人了。</p><p></p><p>基于此，我们可以放心地调用任何阻塞操作，想调用多少就调用多少。</p><p></p><p>这就是我们对待阻塞操作和线程的历史。业界有很多连接二者的方式，都能使我们的开发工作更加轻松。</p><p></p><p>原文链接：</p><p><a href=\"https://www.javaadvent.com/2022/12/a-tale-of-two-cities-how-blocking-calls-are-treated.html\">https://www.javaadvent.com/2022/12/a-tale-of-two-cities-how-blocking-calls-are-treated.html</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/txS9hHTfxasv2uHBATgL\">Java近期新闻：Gradle 8.0、Maven、Payara平台、Piranha、Spring Framework、MyFaces和Piranha</a>\"</p><p><a href=\"https://www.infoq.cn/article/sLiRwa72fHzWvzC2HmKf\">深入OpenTelemetry源代码：Java探针的实现和二次开发</a>\"</p><p><a href=\"https://www.infoq.cn/article/YaBqqD7fd6kX97GbhkGm\">虚拟线程：大规模Java应用的新基石</a>\"</p>",
    "publish_time": "2023-03-09 08:51:49",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "企业全球化出海技术体系建设实录【专题合集】",
    "url": "https://www.infoq.cn/article/7326f30ef47ccf76f3ebaa100",
    "summary": "<p>近日，阿里Q3财报发布，国际零售收入增长26%。</p><p></p><p>不仅阿里的海外电商业务增长迅速，越来越多的中国企业也开始走向海外。但是在国际政经环境复杂变幻的形势之下，企业出海既要应对不同国家的基础设施差异化、要兼顾不同地区的数据合规，还要关注成本和效率……面对上述挑战，拥有稳定高效的全球化技术能力非常关键。</p><p></p><p>从2016年起，阿里陆续收购 Lazada、Daraz、Trendyol 等海外公司，阿里全球化业务布局初步形成，自此正式将全球化技术作为集团重要的技术战略方向来投入。经过多年的演进，逐渐发展成为阿里集团内相对独立的技术体系。</p><p></p><p>近期，我们邀约内部技术团队，首次系统性地沉淀展示阿里全球化的技术能力，包括基础设施、全球化安全生产&amp;质量保障体系、全球化商品域建设、全球化商家平台、用户增长、商品推荐等多个领域的技术演进和能力建设，希望为行业同行者提供一些参考和借鉴。</p><p></p><p></p><h3><a href=\"https://xie.infoq.cn/article/b28db5e9146eb87daf5598a5d\">1. 总览：全球化趋势下，如何建设稳定高效的技术能力？</a>\"</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/c9/c97ee7c458985d8ccf29db8fd5a0d965.png\" /></p><p></p><p>在全球化业务布局的过程中，中国企业面对着语言、文化、地域、监管四个维度的差异和挑战。电商交易的跨语言沟通需要企业在语言翻译领域进行大量投入；文化和用户习惯差异，需要针对不同国家和地区做商品的差异化透出；地区间基础设施的不平衡、数据合规、技术进出口合规都是一个个需要攻克的难题......</p><p></p><p>如何建设稳定高效的全球化技术能力？针对本对本和跨境两种业务模式，该如何选择和部署架构……阿里集团全球化业务平台团队负责人李伟杰从整体角度介绍了全球化技术体系的建设和演进过程。</p><p></p><p>&gt;&gt;&gt; <a href=\"https://xie.infoq.cn/article/b28db5e9146eb87daf5598a5d\">点击查阅文章详情</a>\"</p><p></p><p></p><h3><a href=\"https://xie.infoq.cn/article/25b927989dd715e0c0a267b8f\">2. 基础设施篇 | 6年技术迭代，阿里全球化出海&amp;合规的挑战和探索</a>\"</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/90/90af67461eb1e14fed092d6ffd142922.png\" /></p><p></p><p>海外电商服务的对象大部分场景是跨国家的，而海外不同国家的网络性能和基础硬件设施和国内相比有很多差异，这对业务的稳定性和体验的流畅度提出了很多挑战。</p><p></p><p>举例来说，用户从发起请求到接收到响应的延时越短，代表技术体系的性能越好。而全球互联网服务在延时上有天然的挑战，即物理距离更长，但1 秒钟的延迟也会造成转化率下降，甚至是用户流失。</p><p></p><p>如何保障基础设施的稳定性、解决合规风险问题？本文将首先重点讲解全球化基础设施层的挑战和技术实践。</p><p></p><p>&gt;&gt;&gt; <a href=\"https://xie.infoq.cn/article/25b927989dd715e0c0a267b8f\">点击查阅文章详情</a>\"</p><p></p><p></p><h3><a href=\"https://xie.infoq.cn/article/a7d4a78023afb75f21cf17fe3\">3. 全球化安全生产 &amp; 质量保障体系建设探索</a>\"</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/1e/1e0e97b590baea9a93870dd3107fc715.png\" /></p><p></p><p>全球化电商中的业务、技术及架构和国内技术都有一定差异，从安全生产保障和质量保障角度，这些差异带来了更多的挑战。</p><p></p><p>在业务上，全球化电商主要有本对本和跨境两种最基本的类型。而针对本对本和跨境两种业务模式的选择，背后对应不同的技术架构选型。在组织一场全球化大促时，如何快速发现、定义、解决问题，保障大促安全平稳进行？</p><p></p><p>本文针对全球化安全生产和质量保障体系的一些关键问题进行了解答。</p><p></p><p>&gt;&gt;&gt; <a href=\"https://xie.infoq.cn/article/a7d4a78023afb75f21cf17fe3\">点击查阅文章详情</a>\"</p><p></p><p></p><h3><a href=\"https://xie.infoq.cn/article/2c782c73fe048c2caea02e5b2\">4. 全球化商家平台技术探索与演进</a>\"</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/09/09194dcdcab1290ddb4d2b6d1f2873c2.png\" /></p><p></p><p>全球化环境下，商家产品覆盖面广、产品服务的业务角色多、不同角色业务差异性大......整个产品能力设计会非常复杂。如何差异化支撑全局业务的高效迭代？如何轻量化支撑创新业务的快速建站？成为全球化各个核心平台必须回答的命题。如何进行平衡和取舍？</p><p></p><p>结合全球化商家产品的特性以及前台和中台的组织协同方式，阿里定义出了商家平台服务业务的三种架构模式。本文聚焦全球化商家平台技术架构演进过程以及背后的技术思考。</p><p></p><p>&gt;&gt;&gt; <a href=\"https://xie.infoq.cn/article/2c782c73fe048c2caea02e5b2\">点击查阅文章详情</a>\"</p><p></p><p></p><h3><a href=\"https://xie.infoq.cn/article/36f048c4d0cfd8146e55752e3\">5. 用户卖家平台三方螺旋成长 如何让商品推荐更智能</a>\"</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/53/53d7174ee6e41cb7b04981d93a3bcd8b.png\" /></p><p></p><p>Lazada作为阿里在东南亚的重要电商板块，近年来发展迅速。一方面用户体量不断增长，另一方面业务和供给快速变化。平台每天都有大量商品发布，但参差不齐的商品质量容易为用户带来困惑，此外，商品的转化率还会受到销量评论以及卖家和平台运营动作的影响。如何在动态变化的环境中准确捕捉到高质量的商品，提升用户的购买体验？</p><p></p><p>Lazada将商品演变抽象成一个单独命题，致力于在用户卖家平台三方螺旋成长过程中，让商品推荐更智能。本文将为大家分享阿里在与商品的演变成长性和商品的购买体验相关的三个环节中探索实践的经验。</p><p></p><p>&gt;&gt;&gt; <a href=\"https://xie.infoq.cn/article/36f048c4d0cfd8146e55752e3\">点击查阅文章详情</a>\"</p><p></p><p></p><h3><a href=\"https://xie.infoq.cn/article/20f2150ae4e4b6b14b32040b3\">6. 从混沌到清晰，阿里全球商品类目域建设思考</a>\"</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/1d/1d276f8d4fcecd35d052c64b0728a0eb.png\" /></p><p></p><p>商品是电商产品体系核心之一，类目则是商品模型核心之一，类目系统提供的基础业务数据贯穿了整个电商体系。</p><p></p><p>由于不同地区的文化和操作习惯不尽相同，全球化类目系统需要根据当地业务来进行调整。在知识储备较低、人员流动性大的地区，对类目运营产品依赖性更高。因此，类目域建设在全球化业务中至关重要。本文介绍了商品类目域国内到国际的差异，以及在全球化过程中的建设与思考。</p><p></p><p>&gt;&gt;&gt; <a href=\"https://xie.infoq.cn/article/20f2150ae4e4b6b14b32040b3\">点击查阅文章详情</a>\"</p><p></p><p></p><h3><a href=\"https://xie.infoq.cn/article/219a6c519ea9a1bdb2c0713a4\">7. 阿里国际站用户增长技术探索与实践</a>\"</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/69/692cb4d79179c90574ef2de7d8e8cd55.png\" /></p><p></p><p>和众多传统行业一样，跨境贸易产业近年来也经历了数字化的转型创新，而首先参与进模式创新的地方主要集中于信息展示和业务撮合领域。跨境B类用户与C类买家有着诸多不同，存在着用户结构复杂、行为数据稀疏；目标人群规模小，流量引入的精准性要求高；B类买家留存率低，C类增长策略不可复制三大挑战。本文将为大家分享阿里国际站在用户增长技术体系建设上的探索与实践。</p><p></p><p>&gt;&gt;&gt; <a href=\"https://xie.infoq.cn/article/219a6c519ea9a1bdb2c0713a4\">点击查阅文章详情</a>\"</p><p></p><p></p><h3><a href=\"https://xie.infoq.cn/article/d439b2e90dae2511e9fe50047\">8. 阿里国际站-唤端技术的探索与演进</a>\"</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/26/2614542f65bcb288b4a952058cb92077.png\" /></p><p></p><p>近几年用户增长领域APP推广发展迅猛，而唤端就是其中的重要技术。通过唤端拉新/促活不仅能能够将三方流量规模做大，同时二方流量也能有效利用，给网站不断带来商机。但因场景和目标差异在策略及演进上有所不同，海外业务和国内业务的唤端体系建设有着不同特点。与国内相比，海外业务类型差异大、方向不同，二方互相拉活的优势难以在海外被利用。因此，阿里国际站对海外唤端技术进行了改进和打磨。本文将为大家详细介绍阿里国际站在唤端技术的探索与演进。</p><p></p><p>&gt;&gt;&gt; <a href=\"https://xie.infoq.cn/article/d439b2e90dae2511e9fe50047\">点击查阅文章详情</a>\"</p><p></p><p>欢迎点击关注订阅，一键收藏阿里巴巴全球化系列，未来持续查阅最新文章。</p>",
    "publish_time": "2023-03-09 11:36:57",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "又一大佬冲向ChatGPT风口！美团创始人王兴宣布投资王慧文创业项目，共同打造“中国 OpenAI”",
    "url": "https://www.infoq.cn/article/x8Q7ghQ0CmFeuKUPRZiA",
    "summary": "<p>3月8日，美团创始人王兴在朋友圈中表示，将以个人身份参与王慧文创业公司“光年之外”的A轮投资，并出任董事。</p><p>&nbsp;</p><p>“AI大模型让我既兴奋于即将创造出来的巨大生产力，又忧虑它未来对整个世界的冲击。老王和我在创业路上同行近二十年，既然他决心拥抱这次大浪潮，那我必须支持。”王兴表示。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/52/520f087003fba5d6719d1e6b9146e9aa.png\" /></p><p></p><p>自去年年底发布以来，<a href=\"https://www.infoq.cn/article/YYqCPSdRmtkdSl2hhb9Y\">ChatGPT</a>\" 彻底点燃了科技界，并火速：出圈“，仅用 2 个月时间就收获了 1 亿用户。比尔盖茨评价称，ChatGPT 的技术将“改变我们的世界”。马斯克也在感叹“很多人疯狂地陷入了 ChatGPT 循环中”，“ChatGPT 好得吓人，我们离强大到危险的人工智能不远了”。</p><p>&nbsp;</p><p>ChatGPT 的爆火也掀起了<a href=\"https://www.infoq.cn/theme/173\">应用开发热潮</a>\"。据澎湃新闻报道，最近几个月，在旧金山和硅谷，生成式人工智能聚会、联合办公空间和各种会议中弥漫着兴奋情绪，让人感觉像是回到了移动互联网的创业热潮中。年轻的科技创始人给旧金山社区海斯谷起了个绰号“脑谷（Cerebral Valley）”。</p><p>&nbsp;</p><p>国内对 ChatGPT 感兴趣的企业、个人亦不在少数。</p><p>&nbsp;</p><p>稍早前，原美团联合创始人<a href=\"https://www.infoq.cn/article/7T0i680uu5Elrk3VKbNu\">王慧文</a>\"曾在社交平台发文宣布进军人工智能领域，称将打造“中国的 OpenAI”。</p><p>&nbsp;</p><p>其在文中透露，将成立北京光年之外科技有限公司，王慧文出资 5000 万美元，估值 2 亿美元（约 13.62 亿元人民币），并表示，他个人不占股份，资金占股 25%，75% 的股份用于邀请顶级研发人才，下轮融资已有顶级 VC 认购 2.3 亿美元（约 15.66 亿元人民币）。</p><p>&nbsp;</p><p>天眼查 App 显示，北京光年之外科技有限公司成立于 2018 年 7 月，法定代表人为王慧文，注册资本 100 万人民币，经营范围包括销售自行开发的产品；计算机系统服务等，由王慧文全资持股。</p><p>&nbsp;</p><p>据悉，王兴和王慧文是清华大学室友，近二十年间，两人数次携手创业，联手打造出了校内网、美团等多个案例。2020年，王慧文宣布从美团退休时，王兴曾在公开信中表示，“老王和我是有共同志趣的同学和室友，是携手创业的搭档和并肩战斗的战友，更是可以思想碰撞、灵魂对话的一生挚友”。</p><p>&nbsp;</p><p>此次二人继续联手创业，组队打造中国OpenAI，期待可以给用户带来更多的惊喜。</p>",
    "publish_time": "2023-03-09 11:42:42",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]