[
  {
    "title": "构建重启后依然可用的Windows服务",
    "url": "https://www.infoq.cn/article/sj95UdY5Vqp9Hcxd5XlZ",
    "summary": "<p>当使用C++为Windows编程时，使用Windows服务（Windows Services）几乎是难以避免的。在微软Windows操作系统中，Windows服务发挥着重要的作用，它们能够创建和管理长时间运行的进程，这些进程能够在睡眠、休眠、重启和关机的过程中幸存下来。但是，如果无法做到这一点会怎样呢？在选中<a href=\"https://www.howtogeek.com/243901/the-pros-and-cons-of-windows-10s-fast-startup-mode/\">快速启动（Fast Startup）</a>\"时，关闭计算机会导致服务无法重启，这会给程序带来灾难性的后果。微软在Windows Vista中引入的<a href=\"https://msrc-blog.microsoft.com/2008/10/13/service-isolation-explanation/\">Service Isolation</a>\"可能会导致这类灾难性的后果，在本文中将会阐述如何解决它。</p><p></p><h2>感谢Windows服务</h2><p></p><p></p><p>多年以来，我们一直在使用Windows服务，但是不管我们觉得有多么了解服务，或者有多么自信能够处理它，却始终会遇到更多的问题、挑战和麻烦。其中有些问题根本是没有文档的，或者我们“幸运”一点的话，会有一点糟糕的文档。</p><p></p><p>自从微软引入<a href=\"https://msrc-blog.microsoft.com/2008/10/13/service-isolation-explanation/\">服务隔离</a>\"之后，我们遇到的最令人恼火的问题之一就是当<a href=\"https://www.howtogeek.com/243901/the-pros-and-cons-of-windows-10s-fast-startup-mode/\">快速启动</a>\"选中时，计算机关闭后，无法重启服务。鉴于我们没有找到现成的解决方案，所以我们决定自动动手实现一个，这促成了持久化服务的开发。</p><p></p><p>但是，在深入研究和解释我们的解决方案之前，我们首先从基础知识开始，解释什么是服务，以及为什么要使用Windows服务。</p><p></p><p>NT服务（也叫做Windows服务）指的是由NT内核的服务控制管理器（Service Control Manager）加载的特殊进程，它会在Windows启动（在用户登录前）立即在后台运行。我们使用服务来执行核心和底层的操作系统任务，比如Web服务、事件日志、文件服务、帮助和支持、打印、加密和错误报告。</p><p></p><p>此外，服务使我们能够创建可执行的、长时间运行的应用程序。原因在于服务会在自己的Windows会话环境中运行，所以它不会干扰应用程序的其他组件或会话。显然，我们期望服务会在计算机启动后也自动启动，我们马上就会讨论该问题。</p><p></p><p>进一步来讲，这里显然有一个问题：我们为什么需要持久化的服务？答案很明显，服务应该能够：</p><p></p><p>持续在后台运行。在已登录用户的会话中，调用自身。作为一个看门狗（watchdog），确保给定的应用程序一直在运行。</p><p></p><p>Windows服务需要能够在睡眠、休眠、重启和关机时依然能够存活。但是，正如前文所述，当选中“<a href=\"http://www.howtogeek.com/243901/the-pros-and-cons-of-windows-10s-fast-startup-mode/\">快速启动</a>\"”时，计算机关机再启动的话，会出现一些特定的危险问题。在大多数场景中，服务无法重新启动。</p><p></p><p>因为我们正在开发的是一个反病毒软件，它应该在重启或关机后重新启动，这种情况造成了一个严重的问题，我们迫切需要解决它。</p><p></p><h2>实现良好的服务</h2><p></p><p></p><p>为了创建近乎完美的持久化Windows服务，我们必须首先解决几个底层的问题。</p><p></p><p>其中一个问题与服务隔离有关，被隔离的服务无法访问与任何特定用户相关的上下文。我们某个软件产品将数据存储到了c:\\users\\\\appdata\\local\\中，但是当它从我们的服务中运行的话，这个路径就是无效的，因为服务是在Session 0中运行的。除此之外，在重启后，服务会在所有用户登录之前启动，这形成了解决方案的第一部分：等待用户登录。</p><p></p><p>为了弄清如何做到这一点，我们<a href=\"https://www.codeproject.com/Questions/5061695/Running-a-windows-service-process-on-windows-serve\">在这里</a>\"发布了遇到的问题。</p><p></p><p>事实证明，这是一个没有完美解决方案的问题，但是，本文附带的代码已经得到了应用，并且经过了全面的测试，没有任何的问题。</p><p></p><h2>基础知识</h2><p></p><p></p><p>我们的代码结构和流程可能看起来很复杂，但是这是有一定原因的。在过去的十年间，服务已经与其他进程隔离。从那时开始，Windows服务会在SYSTEM用户账号下运行，而不是其他的用户账号，并且是<a href=\"https://msrc-blog.microsoft.com/2008/10/13/service-isolation-explanation/\">隔离运行的</a>\"。</p><p></p><p>隔离运行的原因在于，服务的功能很强大，可能是潜在的安全风险。正因为如此，微软引入了服务隔离。在这个变化之前，所有的服务会与应用一起在Session 0中运行。</p><p></p><p>但是，在引入了隔离之后（这是在Windows Vista中引入的），情况发生了变化。我们的代码背后的想法是通过调用<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasusera\">CreateProcessAsUserW</a>\"，让Windows服务以某个用户的身份启动自己，这一点将在后文详细阐述。我们的服务叫做SG_RevealerService，它有多个命令，当使用如下的命令行参数调用时，它们会采取相应的行为。</p><p></p><p><code lang=\"cpp\">#define SERVICE_COMMAND_INSTALL L\"Install\"             // The command line argument\n                                                       // for installing the service\n\n#define SERVICE_COMMAND_LAUNCHER L\"ServiceIsLauncher\"  // Launcher command for\n                                                       // NT service\n</code></p><p></p><p>当调用SG_RevealerService时，有三个选项：</p><p></p><p>选项1：不带有任何命令行参数进行调用。在这种情况下什么都不会发生。</p><p></p><p>选项2：带有Install命令行参数进行调用。在这种情况下，服务将自行安装，如果在哈希分隔符（#）添加了有效的可执行路径，服务将会启动，Windows看门狗会保持其一直运行。</p><p></p><p>然后，Service会使用<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasusera\">CreateProcessAsUserW()</a>\"运行自身，新的进程会在用户账号下运行。这给了Service访问上下文的能力，因为Service Isolation，调用实例是无法访问该上下文的。</p><p></p><p>选项3：使用ServiceIsLauncher命令行参数进行调用。服务客户端主应用将会启动。此时，入口函数表明服务已经以当前用户的权限启动了自身。现在，在Task Manager中，我们会看到SG_RevealerService的两个实例，其中一个在SYSTEM用户下，另一个在当前登录用户下。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/windows-services-reliable-restart/en/resources/1figure-1-task-manager-1671630831799.jpg\" /></p><p></p><p><code lang=\"cpp\">/*\nRunHost\n*/\n\nBOOL RunHost(LPWSTR HostExePath,LPWSTR CommandLineArguments)\n{\n    WriteToLog(L\"RunHost '%s'\",HostExePath);\n\n    STARTUPINFO startupInfo = {};\n    startupInfo.cb = sizeof(STARTUPINFO);\n    startupInfo.lpDesktop = (LPTSTR)_T(\"winsta0\\\\default\");\n\n    HANDLE hToken = 0;\n    BOOL bRes = FALSE;\n\n    LPVOID pEnv = NULL;\n    CreateEnvironmentBlock(&amp;pEnv, hToken, TRUE);\n\n    PROCESS_INFORMATION processInfoAgent = {};\n    PROCESS_INFORMATION processInfoHideProcess = {};\n    PROCESS_INFORMATION processInfoHideProcess32 = {};\n\n    if (PathFileExists(HostExePath))\n    {\n        std::wstring commandLine;\n        commandLine.reserve(1024);\n\n        commandLine += L\"\\\"\";\n        commandLine += HostExePath;\n        commandLine += L\"\\\" \\\"\";\n        commandLine += CommandLineArguments;\n        commandLine += L\"\\\"\";\n\n        WriteToLog(L\"launch host with CreateProcessAsUser ...  %s\",\n                     commandLine.c_str());\n\n        bRes = CreateProcessAsUserW(hToken, NULL, &amp;commandLine[0],\n               NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS |\n               CREATE_UNICODE_ENVIRONMENT | CREATE_NEW_CONSOLE |\n               CREATE_DEFAULT_ERROR_MODE, pEnv,\n            NULL, &amp;startupInfo, &amp;processInfoAgent);\n        if (bRes == FALSE)\n        {\n            DWORD   dwLastError = ::GetLastError();\n            TCHAR   lpBuffer[256] = _T(\"?\");\n            if (dwLastError != 0)    // Don't want to see an\n                                     // \"operation done successfully\" error ;-)\n            {\n                ::FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,    // It's a system error\n                    NULL,                                      // No string to be\n                                                               // formatted needed\n                    dwLastError,                               // Hey Windows: Please\n                                                               // explain this error!\n                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Do it in the standard\n                                                               // language\n                    lpBuffer,              // Put the message here\n                    255,                   // Number of bytes to store the message\n                    NULL);\n            }\n            WriteToLog(L\"CreateProcessAsUser failed - Command Line = %s Error : %s\",\n                         commandLine, lpBuffer);\n        }\n        else\n        {\n            if (!writeStringInRegistry(HKEY_LOCAL_MACHINE,\n               (PWCHAR)SERVICE_REG_KEY, (PWCHAR)SERVICE_KEY_NAME, HostExePath))\n            {\n                WriteToLog(L\"Failed to write registry\");\n            }\n        }\n    }\n    else\n    {\n        WriteToLog(L\"RunHost failed because path '%s' does not exists\", HostExePath);\n    }\n    hPrevAppProcess = processInfoAgent.hProcess;\n    \n    CloseHandle(hToken);\n    WriteToLog(L\"Run host end!\");\n\n    return bRes;\n}\n</code></p><p></p><h2>探测用户登录</h2><p></p><p></p><p>第一个挑战是仅在用户登录时，才启动一些动作。为了探测用户的登录，我们首先定义一个全局变量。</p><p></p><p><code lang=\"cpp\">bool g_bLoggedIn = false;\n</code></p><p></p><p>当用户登录时，它的值应该被设置为true 。</p><p></p><h3>订阅登录事件</h3><p></p><p></p><p>我们定义了如下的<a href=\"https://cplusplus.com/doc/tutorial/preprocessor/\">Preprocesor Directives</a>\"：</p><p></p><p><code lang=\"cpp\">#define EVENT_SUBSCRIBE_PATH    L\"Security\"\n#define EVENT_SUBSCRIBE_QUERY    L\"Event/System[EventID=4624]\"\n</code></p><p></p><p>当Service启动后，我们<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/winevt/nf-winevt-evtsubscribe\">订阅登录事件</a>\"，所以当用户登录时，我们会通过设置的回调函数得到一个告警，然后我们就可以继续后面的操作了。为了实现这一点，我们需要一个类来处理订阅的创建并等待事件回调。</p><p></p><p><code lang=\"cpp\">class UserLoginListner\n{\n    HANDLE hWait = NULL;\n    HANDLE hSubscription = NULL;\n\npublic:\n    ~UserLoginListner()\n    {\n        CloseHandle(hWait);\n        EvtClose(hSubscription);\n    }\n\n    UserLoginListner()\n    {\n        const wchar_t* pwsPath = EVENT_SUBSCRIBE_PATH;\n        const wchar_t* pwsQuery = EVENT_SUBSCRIBE_QUERY;\n\n        hWait = CreateEvent(NULL, FALSE, FALSE, NULL);\n\n        hSubscription = EvtSubscribe(NULL, NULL,\n            pwsPath, pwsQuery,\n            NULL,\n            hWait,\n            (EVT_SUBSCRIBE_CALLBACK)UserLoginListner::SubscriptionCallback,\n            EvtSubscribeToFutureEvents);\n        if (hSubscription == NULL)\n        {\n            DWORD status = GetLastError();\n\n            if (ERROR_EVT_CHANNEL_NOT_FOUND == status)\n                WriteToLog(L\"Channel %s was not found.\\n\", pwsPath);\n            else if (ERROR_EVT_INVALID_QUERY == status)\n                WriteToLog(L\"The query \\\"%s\\\" is not valid.\\n\", pwsQuery);\n            else\n                WriteToLog(L\"EvtSubscribe failed with %lu.\\n\", status);\n\n            CloseHandle(hWait);\n        }\n    }\n</code></p><p></p><p>然后，我们需要一个函数实现等待：</p><p></p><p><code lang=\"cpp\">void WaitForUserToLogIn()\n{\n    WriteToLog(L\"Waiting for a user to log in...\");\n    WaitForSingleObject(hWait, INFINITE);\n    WriteToLog(L\"Received a Logon event - a user has logged in\");\n}\n</code></p><p></p><p>我们还需要一个回调函数：</p><p></p><p><code lang=\"cpp\">static DWORD WINAPI SubscriptionCallback(EVT_SUBSCRIBE_NOTIFY_ACTION action, PVOID\n       pContext, EVT_HANDLE hEvent)\n{\n    if (action == EvtSubscribeActionDeliver)\n    {\n        WriteToLog(L\"SubscriptionCallback invoked.\");\n        HANDLE Handle = (HANDLE)(LONG_PTR)pContext;\n        SetEvent(Handle);\n    }\n\n    return ERROR_SUCCESS;\n}\n</code></p><p></p><p>接下来，需要做的就是添加具有如下内容的代码块：</p><p></p><p><code lang=\"cpp\">WriteToLog(L\"Launch client\\n\"); // launch client ...\n{\n    UserLoginListner WaitTillAUserLogins;\n    WaitTillAUserLogins.WaitForUserToLogIn();\n}\n</code></p><p></p><p>到达代码块的底部时，我们就可以确信一个用户已经登录了。</p><p></p><p>在本文后面的内容中，我们将会介绍如何检索登录用户的账号/用户名，以及如何使用GetLoggedInUser()函数。</p><p></p><h2>冒充用户</h2><p></p><p></p><p>当确定一个用户已经登录时，我们需要冒充他们。</p><p></p><p>如下的函数完成了这项工作。它不仅冒充了用户，还调用了<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasuserw\">CreateProcessAsUserW()</a>\"，以该用户的身份运行自己。通过这种方式，我们能够让服务访问用户的上下文，包括文档、桌面等，并允许服务使用用户界面，这对于从Session 0运行服务来讲是无法实现的。</p><p></p><p><a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasuserw\">CreateProcessAsUserW</a>\"创建了一个新的进程及其主线程，它会在给定用户的上下文中运行。</p><p></p><p><code lang=\"cpp\">//Function to run a process as active user from Windows service\nvoid ImpersonateActiveUserAndRun()\n{\n    DWORD session_id = -1;\n    DWORD session_count = 0;\n    WTS_SESSION_INFOW *pSession = NULL;\n\n    if (WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE, 0, 1, &amp;pSession, &amp;session_count))\n    {\n        WriteToLog(L\"WTSEnumerateSessions - success\");\n    }\n    else\n    {\n        WriteToLog(L\"WTSEnumerateSessions - failed. Error %d\",GetLastError());\n        return;\n    }\n    TCHAR szCurModule[MAX_PATH] = { 0 };\n\n    GetModuleFileName(NULL, szCurModule, MAX_PATH);\n\n\n    for (size_t i = 0; i &lt; session_count; i++)\n    {\n        session_id = pSession[i].SessionId;\n        WTS_CONNECTSTATE_CLASS wts_connect_state = WTSDisconnected;\n        WTS_CONNECTSTATE_CLASS* ptr_wts_connect_state = NULL;\n        DWORD bytes_returned = 0;\n        if (::WTSQuerySessionInformation(\n            WTS_CURRENT_SERVER_HANDLE,\n            session_id,\n            WTSConnectState,\n            reinterpret_cast(&amp;ptr_wts_connect_state),\n            &amp;bytes_returned))\n        {\n            wts_connect_state = *ptr_wts_connect_state;\n            ::WTSFreeMemory(ptr_wts_connect_state);\n            if (wts_connect_state != WTSActive) continue;\n        }\n        else\n        {\n            continue;\n        }\n\n        HANDLE hImpersonationToken;\n        if (!WTSQueryUserToken(session_id, &amp;hImpersonationToken))\n        {\n            continue;\n        }\n\n        //Get the actual token from impersonation one\n        DWORD neededSize1 = 0;\n        HANDLE *realToken = new HANDLE;\n        if (GetTokenInformation(hImpersonationToken, (::TOKEN_INFORMATION_CLASS) TokenLinkedToken, realToken, sizeof(HANDLE), &amp;neededSize1))\n        {\n            CloseHandle(hImpersonationToken);\n            hImpersonationToken = *realToken;\n        }\n        else\n        {\n            continue;\n        }\n        HANDLE hUserToken;\n        if (!DuplicateTokenEx(hImpersonationToken,\n            TOKEN_ASSIGN_PRIMARY | TOKEN_ALL_ACCESS | MAXIMUM_ALLOWED,\n            NULL,\n            SecurityImpersonation,\n            TokenPrimary,\n            &amp;hUserToken))\n        {\n            continue;\n        }\n\n\n        // Get user name of this process\n        WCHAR* pUserName;\n        DWORD user_name_len = 0;\n        if (WTSQuerySessionInformationW(WTS_CURRENT_SERVER_HANDLE, session_id, WTSUserName, &amp;pUserName, &amp;user_name_len))\n        {\n            //Now we got the user name stored in pUserName\n        }\n        // Free allocated memory                         \n        if (pUserName) WTSFreeMemory(pUserName);\n        ImpersonateLoggedOnUser(hUserToken);\n        STARTUPINFOW StartupInfo;\n        GetStartupInfoW(&amp;StartupInfo);\n        StartupInfo.cb = sizeof(STARTUPINFOW);\n        PROCESS_INFORMATION processInfo;\n        SECURITY_ATTRIBUTES Security1;\n        Security1.nLength = sizeof SECURITY_ATTRIBUTES;\n        SECURITY_ATTRIBUTES Security2;\n        Security2.nLength = sizeof SECURITY_ATTRIBUTES;\n        void* lpEnvironment = NULL;\n\n        // Obtain all needed necessary environment variables of the logged in user.\n        // They will then be passed to the new process we create.\n\n        BOOL resultEnv = CreateEnvironmentBlock(&amp;lpEnvironment, hUserToken, FALSE);\n        if (!resultEnv)\n        {\n            WriteToLog(L\"CreateEnvironmentBlock - failed. Error %d\",GetLastError());\n            continue;\n        }\n        std::wstring commandLine;\n        commandLine.reserve(1024);\n        commandLine += L\"\\\"\";\n        commandLine += szCurModule;\n        commandLine += L\"\\\" \\\"\";\n        commandLine += SERVICE_COMMAND_Launcher;\n        commandLine += L\"\\\"\";\n        WCHAR PP[1024]; //path and parameters\n        ZeroMemory(PP, 1024 * sizeof WCHAR);\n        wcscpy_s(PP, commandLine.c_str());\n\n        // Next we impersonate - by starting the process as if the current logged in user, has started it\n        BOOL result = CreateProcessAsUserW(hUserToken,\n            NULL,\n            PP,\n            NULL,\n            NULL,\n            FALSE,\n            NORMAL_PRIORITY_CLASS | CREATE_NEW_CONSOLE,\n            NULL,\n            NULL,\n            &amp;StartupInfo,\n            &amp;processInfo);\n\n        if (!result)\n        {\n            WriteToLog(L\"CreateProcessAsUser - failed. Error %d\",GetLastError());\n        }\n        else\n        {\n            WriteToLog(L\"CreateProcessAsUser - success\");\n        }\n        DestroyEnvironmentBlock(lpEnvironment);\n        CloseHandle(hImpersonationToken);\n        CloseHandle(hUserToken);\n        CloseHandle(realToken);\n        RevertToSelf();\n    }\n    WTSFreeMemory(pSession);\n}\n</code></p><p></p><h2>寻找已登录的用户</h2><p></p><p></p><p>为了寻找已登录用户的账号名，我们会使用如下的函数：</p><p></p><p><code lang=\"cpp\">std::wstring GetLoggedInUser()\n{\n    std::wstring user{L\"\"};\n    WTS_SESSION_INFO *SessionInfo;\n    unsigned long SessionCount;\n    unsigned long ActiveSessionId = -1;\n\n    if(WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE,\n                            0, 1, &amp;SessionInfo, &amp;SessionCount))\n    {\n        for (size_t i = 0; i &lt; SessionCount; i++)\n        {\n            if (SessionInfo[i].State == WTSActive ||\n                SessionInfo[i].State == WTSConnected)\n            {\n                ActiveSessionId = SessionInfo[i].SessionId;\n                break;\n            }\n        }\n\n        wchar_t *UserName;\n        if (ActiveSessionId != -1)\n        {\n            unsigned long BytesReturned;\n            if (WTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE,\n                ActiveSessionId, WTSUserName, &amp;UserName, &amp;BytesReturned))\n            {\n                user = UserName;        // Now we have the logged in user name\n                WTSFreeMemory(UserName);    \n            }\n        }\n        WTSFreeMemory(SessionInfo);\n    }\n    return user;\n}\n</code></p><p></p><p>在服务启动后不久，我们就要使用该函数。只要没有用户登录，这个函数就会返回一个空字符串，如果这样的话，我们就知道应该继续等待。</p><p></p><h2>看门狗是Service的好朋友</h2><p></p><p></p><p>Service与看门狗机制协同使用是很理想的方案。</p><p></p><p>这种机制将确保一个给定应用始终处于运行状态，如果它异常关闭的话，看门狗会重新启动它。我们要始终记住，如果用户通过Quit退出的话，我们不希望重启进程。但是，如果进程是通过Task Manager或其他方式被停掉的，我们会希望重启它。一个很好的例子是反病毒程序。我们想要确保恶意软件不能终止本应检测它的反病毒程序。</p><p></p><p>为了实现这一点，我们需要该Service为使用它的程序提供某种API，当该程序的用户选择“Quit”，程序会告知Service，程序的工作已经完成了，Service可以卸载自己了。</p><p></p><h2>一些构建基块</h2><p></p><p></p><p>接下来，我们介绍一些构建基块，要理解本文的代码，它们是必备的。</p><p></p><h3>GetExePath</h3><p></p><p></p><p>为了获取我们的Service或其他可执行文件的路径，如下的函数是非常便利的。</p><p></p><p><code lang=\"cpp\">/**\n * GetExePath() - returns the full path of the current executable.\n *\n * @param values - none.\n * @return a std::wstring containing the full path of the current executable.\n */\nstd::wstring GetExePath()\n{\n    wchar_t buffer[65536];\n    GetModuleFileName(NULL, buffer, sizeof(buffer) / sizeof(*buffer));\n    int pos = -1;\n    int index = 0;\n    while (buffer[index])\n    {\n        if (buffer[index] == L'\\\\' || buffer[index] == L'/')\n        {\n            pos = index;\n        }\n        index++;\n    }\n    buffer[pos + 1] = 0;\n    return buffer;\n}\n</code></p><p></p><h3>WriteLogFile</h3><p></p><p></p><p>当开发Windows Service时（以及其他任何软件），拥有一个日志机制都是很重要的。我们有一个非常复杂的日志机制，但是就本文而言，我添加了一个最小的日志函数，名为WriteToLog。它的运行机制类似于printf ，但是所有发送给它的内容不仅会被格式化，还会存储在一个日志文件中，以备日后检查。这个日志文件的大小会不断增长，因为会有新的日志条目追加到上面。</p><p></p><p>日志文件的路径，通常会位于Service的EXE的路径，但是，由于Service Isolation，在重启计算机后的一小段时间内，这个路径会<a href=\"https://serverfault.com/questions/114238/windows-service-can-i-configure-the-current-working-directory\">变成</a>\" <a href=\"https://serverfault.com/questions/114238/windows-service-can-i-configure-the-current-working-directory\">c:\\Windows\\System32</a>\"，我们并不希望如此。所以，我们的日志函数会检查exe的路径，并且不会假设<a href=\"https://learn.microsoft.com/en-us/windows/win32/fileio/changing-the-current-directory\">Current Directory</a>\"在Service的生命周期内会保持不变。</p><p></p><p><code lang=\"cpp\">/**\n * WriteToLog() - writes formatted text into a log file, and on screen (console)\n *\n * @param values - formatted text, such as L\"The result is %d\",result.\n * @return - none\n */\nvoid WriteToLog(LPCTSTR lpText, ...)\n{\n    FILE *fp;\n    wchar_t log_file[MAX_PATH]{L\"\"};\n    if(wcscmp(log_file,L\"\") == NULL)\n    {\n        wcscpy(log_file,GetExePath().c_str());\n        wcscat(log_file,L\"log.txt\");\n    }\n    // find gmt time, and store in buf_time\n    time_t rawtime;\n    struct tm* ptm;\n    wchar_t buf_time[DATETIME_BUFFER_SIZE];\n    time(&amp;rawtime);\n    ptm = gmtime(&amp;rawtime);\n    wcsftime(buf_time, sizeof(buf_time) / sizeof(*buf_time), L\"%d.%m.%Y %H:%M\", ptm);\n\n    // store passed messsage (lpText) to buffer_in\n    wchar_t buffer_in[BUFFER_SIZE];\n\n    va_list ptr;\n    va_start(ptr, lpText);\n\n    vswprintf(buffer_in, BUFFER_SIZE, lpText, ptr);\n    va_end(ptr);\n\n    // store output message to buffer_out - enabled multiple parameters in swprintf\n    wchar_t buffer_out[BUFFER_SIZE];\n\n    swprintf(buffer_out, BUFFER_SIZE, L\"%s %s\\n\", buf_time, buffer_in);\n\n    _wfopen_s(&amp;fp, log_file, L\"a,ccs=UTF-8\");\n    if (fp)\n    {\n        fwprintf(fp, L\"%s\\n\", buffer_out);\n        fclose(fp);\n    }\n    wcscat(buffer_out,L\"\\n\");HANDLE stdOut = GetStdHandle(STD_OUTPUT_HANDLE);\n    if (stdOut != NULL &amp;&amp; stdOut != INVALID_HANDLE_VALUE)\n    {\n        DWORD written = 0;\n        WriteConsole(stdOut, buffer_out, wcslen(buffer_out), &amp;written, NULL);\n    }\n}\n</code></p><p></p><h2>更多的构建基块：注册表相关的内容</h2><p></p><p></p><p>下面是一些我们用来存储看门狗可执行文件路径的函数，所以当计算机重启后，Service重新启动时，就能使用该路径。</p><p></p><p><code lang=\"cpp\">BOOL CreateRegistryKey(HKEY hKeyParent, PWCHAR subkey)\n{\n    DWORD dwDisposition; //Verify new key is created or open existing key\n    HKEY  hKey;\n    DWORD Ret;\n    Ret =\n        RegCreateKeyEx(\n            hKeyParent,\n            subkey,\n            0,\n            NULL,\n            REG_OPTION_NON_VOLATILE,\n            KEY_ALL_ACCESS,\n            NULL,\n            &amp;hKey,\n            &amp;dwDisposition);\n    if (Ret != ERROR_SUCCESS)\n    {\n        WriteToLog(L\"Error opening or creating new key\\n\");\n        return FALSE;\n    }\n    RegCloseKey(hKey); //close the key\n    return TRUE;\n}\n\nBOOL writeStringInRegistry(HKEY hKeyParent, PWCHAR subkey,\n                           PWCHAR valueName, PWCHAR strData)\n{\n    DWORD Ret;\n    HKEY hKey;\n    //Check if the registry exists\n    Ret = RegOpenKeyEx(\n        hKeyParent,\n        subkey,\n        0,\n        KEY_WRITE,\n        &amp;hKey\n    );\n    if (Ret == ERROR_SUCCESS)\n    {\n        if (ERROR_SUCCESS !=\n            RegSetValueEx(\n                hKey,\n                valueName,\n                0,\n                REG_SZ,\n                (LPBYTE)(strData),\n                ((((DWORD)lstrlen(strData) + 1)) * 2)))\n        {\n            RegCloseKey(hKey);\n            return FALSE;\n        }\n        RegCloseKey(hKey);\n        return TRUE;\n    }\n    return FALSE;\n}\n\nLONG GetStringRegKey(HKEY hKey, const std::wstring &amp;strValueName,\n                     std::wstring &amp;strValue, const std::wstring &amp;strDefaultValue)\n{\n    strValue = strDefaultValue;\n    TCHAR szBuffer[MAX_PATH];\n    DWORD dwBufferSize = sizeof(szBuffer);\n    ULONG nError;\n    nError = RegQueryValueEx(hKey, strValueName.c_str(), 0, NULL,\n             (LPBYTE)szBuffer, &amp;dwBufferSize);\n    if (nError == ERROR_SUCCESS)\n    {\n        strValue = szBuffer;\n        if (strValue.front() == _T('\"') &amp;&amp; strValue.back() == _T('\"'))\n        {\n            strValue.erase(0, 1); // erase the first character\n            strValue.erase(strValue.size() - 1); // erase the last character\n        }\n    }\n    return nError;\n}\n\nBOOL readStringFromRegistry(HKEY hKeyParent, PWCHAR subkey,\n                            PWCHAR valueName, std::wstring&amp; readData)\n{\n    HKEY hKey;\n    DWORD len = 1024;\n    DWORD readDataLen = len;\n    PWCHAR readBuffer = (PWCHAR)malloc(sizeof(PWCHAR) * len);\n    if (readBuffer == NULL)\n        return FALSE;\n    //Check if the registry exists\n    DWORD Ret = RegOpenKeyEx(\n        hKeyParent,\n        subkey,\n        0,\n        KEY_READ,\n        &amp;hKey\n    );\n    if (Ret == ERROR_SUCCESS)\n    {\n        Ret = RegQueryValueEx(\n            hKey,\n            valueName,\n            NULL,\n            NULL,\n            (BYTE*)readBuffer,\n            &amp;readDataLen\n        );\n        while (Ret == ERROR_MORE_DATA)\n        {\n            // Get a buffer that is big enough.\n            len += 1024;\n            readBuffer = (PWCHAR)realloc(readBuffer, len);\n            readDataLen = len;\n            Ret = RegQueryValueEx(\n                hKey,\n                valueName,\n                NULL,\n                NULL,\n                (BYTE*)readBuffer,\n                &amp;readDataLen\n            );\n        }\n        if (Ret != ERROR_SUCCESS)\n        {\n            RegCloseKey(hKey);\n            return false;;\n        }\n        readData = readBuffer;\n        RegCloseKey(hKey);\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n</code></p><p></p><h2>检查宿主（Host）是否在运行</h2><p></p><p></p><p>本文中的程序有一项核心能力，那就是保护我们的SampleApp（我们将其称为宿主），当它未运行时，就重新启动它（所以叫做看门狗）。在真实场景中，我们会检查宿主是被用户终止的（这是允许的），还是被恶意软件终止的（这是不允许的），在后一种情况下，我们将会重启它（否则，如果用户选择Quit，但应用程序将继续“骚扰”系统并反复执行）。</p><p></p><p>如下是它如何实现的：</p><p></p><p>我们创建了一个Timer事件，每隔一定的时间（不应该过于频繁），我们会检查宿主的进程是否在运行，如果没有的话，我们就启动它。我们使用了一个静态布尔型标记（is_running），用来表明我们已经处于该代码块中了，所以在处理过程中时，能够避免再次调用。这是在WM_TIMER代码块中始终要做的事情，因为当定时器设置的频率过高的话，代码块在调用时，前一个WM_TIMER事件的代码依然在执行。</p><p></p><p>我们还通过检查g_bLoggedIn布尔标记来判断是否有用户登录。</p><p></p><p><code lang=\"cpp\">  case WM_TIMER:\n        {\n            if (is_running) break;\n            WriteToLog(L\"Timer event\");\n            is_running = true;\n            HANDLE hProcessSnap;\n            PROCESSENTRY32 pe32;\n            bool found{ false };\n\n            WriteToLog(L\"Enumerating all processess...\");\n            // Take a snapshot of all processes in the system.\n            hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n            if (hProcessSnap == INVALID_HANDLE_VALUE)\n            {\n                WriteToLog(L\"Failed to call CreateToolhelp32Snapshot(). Error code %d\",GetLastError());\n                is_running = false;\n                return 1;\n            }\n\n            // Set the size of the structure before using it.\n            pe32.dwSize = sizeof(PROCESSENTRY32);\n\n            // Retrieve information about the first process,\n            // and exit if unsuccessful\n            if (!Process32First(hProcessSnap, &amp;pe32))\n            {\n                WriteToLog(L\"Failed to call Process32First(). Error code %d\",GetLastError());\n                CloseHandle(hProcessSnap);          // clean the snapshot object\n                is_running=false;\n                break;\n            }\n\n            // Now walk the snapshot of processes, and\n            // display information about each process in turn\n            DWORD svchost_parent_pid = 0;\n            DWORD dllhost_parent_pid = 0;\n            std::wstring szPath = L\"\";\n\n            if (readStringFromRegistry(HKEY_LOCAL_MACHINE, (PWCHAR)SERVICE_REG_KEY, (PWCHAR)SERVICE_KEY_NAME, szPath))\n            {\n                m_szExeToFind = szPath.substr(szPath.find_last_of(L\"/\\\\\") + 1);    // The process name is the executable name only\n                m_szExeToRun = szPath;                                            // The executable to run is the full path\n            }\n            else\n            {\n                WriteToLog(L\"Error reading ExeToFind from the Registry\");\n            }\n\n            do\n            {\n                if (wcsstr( m_szExeToFind.c_str(), pe32.szExeFile))\n                {\n                    WriteToLog(L\"%s is running\",m_szExeToFind.c_str());\n                    found = true;\n                    is_running=false;\n                    break;\n                }\n                if (!g_bLoggedIn)\n                {\n                    WriteToLog(L\"WatchDog isn't starting '%s' because user isn't logged in\",m_szExeToFind.c_str());\n                    return 1;\n                }\n            }\n            while (Process32Next(hProcessSnap, &amp;pe32));\n            if (!found)\n            {\n                WriteToLog(L\"'%s' is not running. Need to start it\",m_szExeToFind.c_str());\n                if (!m_szExeToRun.empty())    // watchdog start the host app\n                {\n                    if (!g_bLoggedIn)\n                    {\n                        WriteToLog(L\"WatchDog isn't starting '%s' because user isn't logged in\",m_szExeToFind.c_str());\n                        return 1;\n                    }\n                    ImpersonateActiveUserAndRun();\n\n                    RunHost((LPWSTR)m_szExeToRun.c_str(), (LPWSTR)L\"\");\n\n                }\n                else\n                {\n                    WriteToLog(L\"m_szExeToRun is empty\");\n                }\n            }\n            CloseHandle(hProcessSnap);\n        }\n        is_running=false;\n        break;\n</code></p><p></p><h2>如何测试Service</h2><p></p><p></p><p>当我们想要测试这个解决方案时，我们雇佣了20个资深的和协作的测试人员。在整个工作过程中，越来多的测试均成功了。在某些时候，它在我们自己的Surface Pro笔记本电脑上运行地非常完美，但是，我们的一位员工报告说，在他的计算机上，在关闭之后，服务没有再次启动，或者在<a href=\"https://en.wikipedia.org/wiki/Protection_ring\">Ring 3</a>\"下没有启动自身。这是一个好消息，因为在开发过程中，当你怀疑某个地方存在缺陷的时候，最糟糕的事情就是无法找到它，也无法重现它。总而言之，10%的测试者报告了问题。因此，这里发布的版本在我们员工的电脑上运行完美，然而2%的测试者仍然不时报告问题。换句话说，SampleApp在关闭计算机并打开后无法启动。</p><p></p><p>如下是对测试服务和看门狗的说明。</p><p></p><h3>SampleApp</h3><p></p><p></p><p>我们包含了一个由Visual Studio Wizard生成的样例应用，作为“宿主”应用，它会被看门狗确保一直运行。你可以单独运行它，外观如下面的图片所示。该应用没有做太多的事情。实际上，它一无是处……</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/windows-services-reliable-restart/en/resources/1figure-2-sample-app-1671630831799.jpg\" /></p><p></p><p>在后面的内容中，我们将提供测试服务和看门狗的指南。你可以在<a href=\"https://github.com/securedglobe/PersistantService\">GitHub</a>\"下载源码。</p><p></p><h3>从CMD中运行</h3><p></p><p>以管理员身份打开CMD。将当前目录变更至Service的EXE所在的路径并输入：</p><p></p><p>SG_RevealerService.exe Install#SampleApp.exe</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/windows-services-reliable-restart/en/resources/1figure-3-command-prompt-1671630831799.jpg\" /></p><p></p><p>你可以看到，我们有两个元素：</p><p></p><p>command元素，这里是Installargument元素，通过哈希分隔符(#)连接至命令元素，应该是我们希望看门狗观察的可执行文件。</p><p></p><p>Service首先会启动SampleApp，从此之后，如果你尝试终止或杀死SampleApp的话，看门狗会在几秒钟后重启它。如果重启，关掉计算机并再次启动，你会发现Service会再次出现并启动SampleApp。这就是我们的Service的目标和功能。</p><p></p><h3>卸载</h3><p></p><p></p><p>最后，如果要停止和卸载服务，我们包含了一个uninstall.bat脚本，它如下所示：</p><p></p><p><code lang=\"cpp\">sc stop sg_revealerservice\nsc delete sg_revealerservice\ntaskkill /f /im sampleapp.exe\ntaskkill /f /im sg_revealerservice.exe\n</code></p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/windows-services-reliable-restart/en/resources/1figure-4-delete-service-1671630831799.jpg\" /></p><p></p><h3>结论</h3><p></p><p></p><p>Windows Service在微软Windows操作系统中起着关键作用，它支持创建和管理长期运行的进程。在有些场景下，如果勾选了“快速启动”，在正常关闭并重启计算机后，服务往往无法重启。本文的目的是创建一个持久化的服务，在Windows重新启动或关机后，能够始终运行并重新启动。其中一个主要的问题与Service Isolation有关。隔离本身（在Windows Vista版本中引入）是很重要和强大的，然而，当我们需要与用户空间交互时，这会产生一些限制。当服务重新启动时，我们希望它能与用户空间进行交互，然而它不能发生地太早（在任何用户登录之前）。不过，你可以通过订阅登录事件来解决这个问题。Service与看门狗机制协同使用是很理想的方案。这种机制能够确保给定的应用一直在运行，并且在异常关闭时，它将重新启动。我们在前面描述的方法的基础上，成功地开发了这个机制，这使得它可以一直运行，在用户登录时得到提醒，并且能够与用户空间进行交互。定时器事件能够用来监控被观察进程的运行。在开发过程中，好的日志机制始终是非常有用的，我们可以使用简单的日志工具，并在需要的时候，使用更为复杂的工具。最终的解决方案必须要进行测试。代码被确认并验证可以运行后，多达2%的测试人员依然可能会报告错误，这是有一定原因的。</p><p></p><p>作者简介：</p><p>Michael Haephrati是Secured Globe, Inc.的联合创始人和首席执行官，该公司于2008年与他的妻子Ruth Haephrati一起创建。Michael是一位音乐作曲家、发明家，也是一位专门从事软件开发和信息安全的专家。凭借30多年的经验，Michael形成了独特的视角，将技术和创新结合起来，并强调终端用户的体验。多年来，Michael领导了各种客户的创新项目和技术。他是“Learning C++”（https://www.manning.com/books/learning-c-plus-plus）的作者，该书由Manning Publications出版。</p><p></p><p>Ruth Haephrati是Secured Globe, Inc.的联合创始人和首席执行官，该公司于2008年与她的丈夫Michael Haephrati一起创建。Ruth是一位作家、演讲者、企业家、网络安全和网络取证专家。在过去的25年里，Ruth与微软和IBM等领先公司合作，担任顾问和C++实践专家。她最近参与了为一个国际客户开发的最先进的反恶意软件技术。在业余时间，Ruth是一位插画家、画家、野生动物摄影师和世界旅行者。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/windows-services-reliable-restart/\">The Service and the Beast: Building a Windows Service that Does Not Fail to Restart</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/3IX18md3WG2kjiM43Kgv\">Windows 11发布重大更新：ChatGPT版Bing集成到任务栏中，可快速访问AI聊天功能</a>\"</p><p><a href=\"https://www.infoq.cn/article/97LDs46oamxHYLAhp5uK\">Kubernetes 1.26 版本正式发布：改进 Windows 支持，加强网络安全和管理功能</a>\"</p>",
    "publish_time": "2023-03-09 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "在Java中我们该如何应对阻塞调用",
    "url": "https://www.infoq.cn/article/Tda86qL5beKOIkIRoYBU",
    "summary": "<p></p><blockquote>本文最初发表于<a href=\"https://www.javaadvent.com/2022/12/a-tale-of-two-cities-how-blocking-calls-are-treated.html\">Java Advent网站</a>\"，经原作者<a href=\"https://foojay.io/today/author/bazlur-rahman/\">A N M Bazlur Rahman</a>\"授权，由InfoQ中文站翻译分享。</blockquote><p></p><p></p><p>Java已经有20多年的历史了，它一直是软件开发领域的主导力量，这种情况应该还会继续下去。然而，它之所以表现如此优异，是有多种原因的，其中之一就是并发。Java通过引入一个内置的线程模型开始了它的并发旅程。</p><p></p><p>在本文中，我将会讨论关于线程模型的一些历史知识，阐述它们是如何帮助我们形成使用Java进行编程时的理解和实践的，以及我们目前处于何处和它的一个特殊问题。</p><p></p><p>这篇文章会有点长，但是我相信你会喜欢它的。</p><p></p><p>让我们开始这段旅程吧！</p><p></p><h2>Java是由线程组成的</h2><p></p><p></p><p>从诞生之初，Java就引入了线程。线程是Java中的基本执行单元。这意味着我们要运行的所有Java代码都需要由线程来执行。线程是Java平台上执行环境的独立单元。</p><p></p><p>由此我们可以看出，如果一个程序有更多的线程，那它就有更多可以执行代码的地方。这意味着可以同时做更多的事情，从而给我们带来很多收益。一个特别的收益就是，通过利用机器上所有可用的资源，这能够提高应用的吞吐量。借助这种方式，我们能够从程序中获得更多的效益。</p><p></p><p>线程广泛存在于Java平台的各个层面中。</p><p></p><p>线程不仅能够执行代码，它还会在其栈中跟踪方法的调用。所以，如果Java程序在执行过程中遇到问题的话，我们会抛出异常。异常中会包含栈跟踪信息，基于此我们可以判断出错误的原因。由此，我们可以说线程是获取栈跟踪信息的一种方式。</p><p></p><p>此处，如果需要通过IDE调试程序的话，我们也会用到线程。如果需要对程序或程序的一部分进行剖析（profile）的话，我们也会用到线程。Java垃圾收集器会运行在一个单独的线程中。所有的这一切都证明，并发或者”线程“是编程平台的一个重要组成部分。</p><p></p><p></p><h2>但是，线程是昂贵的</h2><p></p><p></p><p>在现代Java web应用中，吞吐量是通过使用并发连接实现的。通常情况下，客户端的每个请求都会有一个专门的线程。现代操作系统可以处理上百万的并发连接。这表明，如果我们有更多的并发连接，就能实现更高的吞吐量。</p><p></p><p>这个结论似乎是合理的，但现实情况远非如此。原因在于，我们无法创建尽可能多的线程来实现这一点。</p><p></p><p>线程是数量有限的昂贵资源。创建一个线程需要在堆外占用2 MiB的内存。需要记住的另外一件事情是，按照传统的做法，Java线程仅仅对操作系统线程做个一层很薄的封装。我们只能创建数量有限的线程。即便我们有了大量的线程，也无法始终保证应用整体的性能。上下文的内容切换会有相关的成本。</p><p></p><p>你可以通过运行如下的样例看一下能够创建多少个线程。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/3f/3f7025ce4fb501729f27baf39a8be3f8.png\" /></p><p></p><p>到目前为止，我们已经讨论了Java线程的重要性以及它们的一些限制。那么，我们再进一步深入讨论一下。</p><p></p><p></p><h2>我们现在遇到了什么问题</h2><p></p><p></p><p>现代软件应用开发需要处理大量的数据，而且应用的使用率也会很高。这就带来了相关的成本问题。如果我们不留意的话，云计算的成本会迅速累积。</p><p></p><p>我们已经确认，创建线程的成本并不低，而且它们的数量是有限制的，所以我们不能浪费任何线程，而是要充分利用它们的能力。但实际上，情况并非如此。在传统的编程模型中，当我们调用一些需要时间才能获取响应的逻辑时，它会阻塞当前线程。例如，如果我们进行一个网络调用（可能是微服务或数据库调用）的话，用来进行调用的线程会被阻塞，直到得到结果为止。在等待结果的过程中，线程什么事情都不会做，基本上就是处于空闲状态，浪费了宝贵的资源，从而导致云账单的无谓增长。</p><p></p><p>因此，基于上述假设，可以得出结论，阻塞调用对我们并不是什么好事儿。</p><p></p><p>我们可以看一个样例。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/99/990dcc77434fc94fabe1a5d6a1708087.png\" /></p><p></p><p>在上述的代码中，我们进行了五个方法的调用。假设所有的方法均需要一些时间来进行处理。为了简单起见，我们假设它们都需要200毫秒的时间来处理。</p><p></p><p>由于我们是一个接一个地进行所有的调用，这将需要至少200*5=1000毫秒来完成该方法。因此，开始所有这些调用的线程必须等待它们全部完成。</p><p></p><p>在这个场景中，我们可以看到，调用calculateCreditForPerson()方法的线程在大部分时间内都是阻塞的，因为它在等待后续方法的完成。当阻塞的时候，它没有做任何事情。基本上来讲，它的资源因为不能做任何事情而被浪费了。</p><p></p><p>问题是，我们该如何才能改善它呢？</p><p></p><p>目前，业界已经有很多方案尝试来改善这种情况，使线程在这种情况下不会被阻塞。我将从Java历史的最开始说起。</p><p></p><p></p><h2>经典的实现方式</h2><p></p><p></p><p>上述样例中，在方法内部的各个方法调用并不都是互相依赖的。所以，第二个、第三个和第四个调用可以并行进行。如果这三个方法并行执行的话，我们就可以做一些改进。这样，调用者线程将花费更少的时间，这意味着更少的阻塞时间。这将是一个巨大的改进。在这里，我们没有解决阻塞的问题，但是负责调用该方法的主线程处于阻塞状态的时间会大幅减少。它将有更多的时间去做其他的事情。</p><p></p><p>那么，我们该如何实现这一经典的方式呢？</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/27/2773717c71082b3dcdcd3511c5028767.png\" /></p><p></p><p>最终的代码将类似于如上所示。我们将临时创建一个新的线程，并将结果存储在一个AtomicReference中。</p><p></p><p>这种方式很不错，但是我们无法控制要创建多少个线程。如果持续地创建临时线程，我们最终可能会创建过多的线程，这对应用是有害的。此外，如果试图创建过多线程的话，应用可能会抛出java.lang.OutOfMemoryError异常。</p><p></p><p>所以，我们需要进一步地改进。</p><p></p><p></p><h2>Executor框架</h2><p></p><p></p><p>Java 5引入了Executor框架，以及Future和Callable/Runnable。它允许我们控制要创建多少个线程，并对它们进行池化管理。</p><p></p><p>基于此，我们可以按照如下方式改善上述代码：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/09/090c76126aca39d1d9540aa6f526d24e.png\" /></p><p></p><p>对于代码编写来讲，这是一个相当大的改进，但是我们尚未达到目的。Future的机制依然非常复杂。对它的get()调用依然是一个阻塞式的调用。尽管我们进行的是异步调用，但最终还是需要一个阻塞式调用以便于从Future中获取值。</p><p></p><p>另外一个问题在于，它有可能会导致缓存受损（cache corruption，作者在这里指的应该是需要跨CPU内核存取数据，从而导致CPU级别的缓存失效——译者注）。例如，如果主线程向线程池提交任务的话，该任务将会由池中的某个线程来执行。主线程需要数据，但是这些数据却在另外一个线程中。这两个线程可能会位于不同的内核上，从而导致缓存受损。除此之外，在不同核心的上下文之间进行切换也是代价高昂的操作。</p><p></p><p>它还需要使用组合操作。所以，代码更多是命令式的。命令式的代码本身没有什么问题，不过函数式和声明式代码也很有意思。所以，至少我们在这里还可以进行一些改进。</p><p></p><p></p><h2>Fork/Join池</h2><p></p><p></p><p>Java引入了Fork/Join池，它是Java 5所引入的ExecutorService的实现，也是Executor框架的实现。它解决了我们在旧的Executor框架中遇到的很多问题，如缓存受损的问题。除此之外，它的运行理念是，刚刚创建的一批任务很可能会需要更紧密的缓存。这意味着，新创建的任务应该在同一个CPU上运行，而旧的任务可能需要在另外一个CPU上运行。与其他线程池实现相比，Fork/Join池中的每个线程都有自己的队列。此外，Fork/Join 池的实现采用了工作窃取（work-stealing）算法。如果池中的某个线程完成了自己的任务，它可以从另外一个线程的队尾窃取任务。所有的这些都能帮助我们实现更好的性能。</p><p></p><p></p><h2>将这一切组合在一起</h2><p></p><p></p><p>Java 8基于Fork/Join池引入了CompletableFuture。它包含了我们非常喜欢的组合特性。有了它，我们可以将上述代码改写成如下所示的样子：</p><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/10/10abf64040999afbc6fedc1904009df1.png\" /></p><p></p><p></p><h2>反应式Java</h2><p></p><p></p><p>非常不错，我们已经得到了自己想要的一切，也就是通过可组合性实现性能的提升。但是，市场上还有其他的替代方案。像RxJava、Akka、Eclipse Vert.x、Spring WebFlux、Slick这样的反应式框架，也能够为我们带来性能和可组合性的收益。我们来看看WebFlux的样例。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/cf/cf4537824efcb5dd2d9de1d62f1f03af.png\" /></p><p></p><p>但是，这种方式也有一些弊端，比如：</p><p></p><p>这种框架的学习曲线比较陡峭。有些模式对初学者来说可能会很难理解。与之相关的认知体验要求很高，这会损害代码的阅读体验。出现任何问题都很难调试。因为我们不知道特定的代码会在哪个线程上运行，完成任务的路径可能是各种各样的。这就是为何即便有线程转储文件也没有太大的用处的原因。</p><p></p><p>那么，解决方案是什么呢？</p><p></p><p>如果我们能够同时使用最初的命令式代码，又能实现简单的异步功能，那就太完美了。这就是Loom项目的用武之地了。</p><p></p><p></p><h2>Loom项目</h2><p></p><p></p><p>Loom项目允许我们临时创建任意数量的线程，而不必承担前文所述的各种负担。我们甚至不用关心到底要创建多少个线程，事实上，我们可以创建上百万个线程，而且它们的成本很低廉。</p><p></p><p>此处之外，我们还可以继续使用命令式和阻塞代码。所以，根本不用担心阻塞式的代码。</p><p></p><p>Java 19引入了虚拟线程，有了它之后，我们可以拥有任意数量的阻塞代码。</p><p></p><p>如果想要使用虚拟线程的话，我们可以使用如下的Executor：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/35/359ca3fc7ae53cde97d1f3076b551c05.png\" /></p><p></p><p>我们之前为Executor编写的代码不需要做任何改变，只需要传入newVirtualThreadPerTaskExecutor Executor服务即可。</p><p></p><p>虚拟线程会在原始线程之上运行，这些原始线程被称为平台线程。平台线程基本上也就是Fork/Join池中的线程。因此，通过运行虚拟线程，我们可以获得Fork/Join池带来的所有好处。</p><p></p><p>简而言之，虚拟线程的做法是，当它们看到阻塞调用时，就会让出它所占用的平台线程。然后，平台线程就能继续执行其他的虚拟线程。阻塞调用通常会在我们调用睡眠或网络操作时发生，当这些操作完成时，虚拟线程可以重新在平台线程中恢复，以完成其余的任务。</p><p></p><p>通过这种方式，我们没有因为空闲浪费任何的线程时间，它们一直处于繁忙状态。另一方面，虚拟线程是一个Java结构，它可以暂停，并在随后恢复，而不会消耗额外的CPU。</p><p></p><p>这使我们的编程变得非常简单。</p><p></p><p></p><h2>结论</h2><p></p><p></p><p>综上所述，对我们来讲，阻塞调用长期以来都是一个敌人。为了解决它，我们发明了很多方案。最后，基于所有的发明，我们提出了一个新的范式，那就是虚拟线程，有了它，我们不再需要把阻塞调用当作敌人了。</p><p></p><p>基于此，我们可以放心地调用任何阻塞操作，想调用多少就调用多少。</p><p></p><p>这就是我们对待阻塞操作和线程的历史。业界有很多连接二者的方式，都能使我们的开发工作更加轻松。</p><p></p><p>原文链接：</p><p><a href=\"https://www.javaadvent.com/2022/12/a-tale-of-two-cities-how-blocking-calls-are-treated.html\">https://www.javaadvent.com/2022/12/a-tale-of-two-cities-how-blocking-calls-are-treated.html</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/txS9hHTfxasv2uHBATgL\">Java近期新闻：Gradle 8.0、Maven、Payara平台、Piranha、Spring Framework、MyFaces和Piranha</a>\"</p><p><a href=\"https://www.infoq.cn/article/sLiRwa72fHzWvzC2HmKf\">深入OpenTelemetry源代码：Java探针的实现和二次开发</a>\"</p><p><a href=\"https://www.infoq.cn/article/YaBqqD7fd6kX97GbhkGm\">虚拟线程：大规模Java应用的新基石</a>\"</p>",
    "publish_time": "2023-03-09 08:51:49",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "企业全球化出海技术体系建设实录【专题合集】",
    "url": "https://www.infoq.cn/article/7326f30ef47ccf76f3ebaa100",
    "summary": "<p>近日，阿里Q3财报发布，国际零售收入增长26%。</p><p></p><p>不仅阿里的海外电商业务增长迅速，越来越多的中国企业也开始走向海外。但是在国际政经环境复杂变幻的形势之下，企业出海既要应对不同国家的基础设施差异化、要兼顾不同地区的数据合规，还要关注成本和效率……面对上述挑战，拥有稳定高效的全球化技术能力非常关键。</p><p></p><p>从2016年起，阿里陆续收购 Lazada、Daraz、Trendyol 等海外公司，阿里全球化业务布局初步形成，自此正式将全球化技术作为集团重要的技术战略方向来投入。经过多年的演进，逐渐发展成为阿里集团内相对独立的技术体系。</p><p></p><p>近期，我们邀约内部技术团队，首次系统性地沉淀展示阿里全球化的技术能力，包括基础设施、全球化安全生产&amp;质量保障体系、全球化商品域建设、全球化商家平台、用户增长、商品推荐等多个领域的技术演进和能力建设，希望为行业同行者提供一些参考和借鉴。</p><p></p><p></p><h3><a href=\"https://xie.infoq.cn/article/b28db5e9146eb87daf5598a5d\">1. 总览：全球化趋势下，如何建设稳定高效的技术能力？</a>\"</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/c9/c97ee7c458985d8ccf29db8fd5a0d965.png\" /></p><p></p><p>在全球化业务布局的过程中，中国企业面对着语言、文化、地域、监管四个维度的差异和挑战。电商交易的跨语言沟通需要企业在语言翻译领域进行大量投入；文化和用户习惯差异，需要针对不同国家和地区做商品的差异化透出；地区间基础设施的不平衡、数据合规、技术进出口合规都是一个个需要攻克的难题......</p><p></p><p>如何建设稳定高效的全球化技术能力？针对本对本和跨境两种业务模式，该如何选择和部署架构……阿里集团全球化业务平台团队负责人李伟杰从整体角度介绍了全球化技术体系的建设和演进过程。</p><p></p><p>&gt;&gt;&gt; <a href=\"https://xie.infoq.cn/article/b28db5e9146eb87daf5598a5d\">点击查阅文章详情</a>\"</p><p></p><p></p><h3><a href=\"https://xie.infoq.cn/article/25b927989dd715e0c0a267b8f\">2. 基础设施篇 | 6年技术迭代，阿里全球化出海&amp;合规的挑战和探索</a>\"</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/90/90af67461eb1e14fed092d6ffd142922.png\" /></p><p></p><p>海外电商服务的对象大部分场景是跨国家的，而海外不同国家的网络性能和基础硬件设施和国内相比有很多差异，这对业务的稳定性和体验的流畅度提出了很多挑战。</p><p></p><p>举例来说，用户从发起请求到接收到响应的延时越短，代表技术体系的性能越好。而全球互联网服务在延时上有天然的挑战，即物理距离更长，但1 秒钟的延迟也会造成转化率下降，甚至是用户流失。</p><p></p><p>如何保障基础设施的稳定性、解决合规风险问题？本文将首先重点讲解全球化基础设施层的挑战和技术实践。</p><p></p><p>&gt;&gt;&gt; <a href=\"https://xie.infoq.cn/article/25b927989dd715e0c0a267b8f\">点击查阅文章详情</a>\"</p><p></p><p></p><h3><a href=\"https://xie.infoq.cn/article/a7d4a78023afb75f21cf17fe3\">3. 全球化安全生产 &amp; 质量保障体系建设探索</a>\"</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/1e/1e0e97b590baea9a93870dd3107fc715.png\" /></p><p></p><p>全球化电商中的业务、技术及架构和国内技术都有一定差异，从安全生产保障和质量保障角度，这些差异带来了更多的挑战。</p><p></p><p>在业务上，全球化电商主要有本对本和跨境两种最基本的类型。而针对本对本和跨境两种业务模式的选择，背后对应不同的技术架构选型。在组织一场全球化大促时，如何快速发现、定义、解决问题，保障大促安全平稳进行？</p><p></p><p>本文针对全球化安全生产和质量保障体系的一些关键问题进行了解答。</p><p></p><p>&gt;&gt;&gt; <a href=\"https://xie.infoq.cn/article/a7d4a78023afb75f21cf17fe3\">点击查阅文章详情</a>\"</p><p></p><p></p><h3><a href=\"https://xie.infoq.cn/article/2c782c73fe048c2caea02e5b2\">4. 全球化商家平台技术探索与演进</a>\"</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/09/09194dcdcab1290ddb4d2b6d1f2873c2.png\" /></p><p></p><p>全球化环境下，商家产品覆盖面广、产品服务的业务角色多、不同角色业务差异性大......整个产品能力设计会非常复杂。如何差异化支撑全局业务的高效迭代？如何轻量化支撑创新业务的快速建站？成为全球化各个核心平台必须回答的命题。如何进行平衡和取舍？</p><p></p><p>结合全球化商家产品的特性以及前台和中台的组织协同方式，阿里定义出了商家平台服务业务的三种架构模式。本文聚焦全球化商家平台技术架构演进过程以及背后的技术思考。</p><p></p><p>&gt;&gt;&gt; <a href=\"https://xie.infoq.cn/article/2c782c73fe048c2caea02e5b2\">点击查阅文章详情</a>\"</p><p></p><p></p><h3><a href=\"https://xie.infoq.cn/article/36f048c4d0cfd8146e55752e3\">5. 用户卖家平台三方螺旋成长 如何让商品推荐更智能</a>\"</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/53/53d7174ee6e41cb7b04981d93a3bcd8b.png\" /></p><p></p><p>Lazada作为阿里在东南亚的重要电商板块，近年来发展迅速。一方面用户体量不断增长，另一方面业务和供给快速变化。平台每天都有大量商品发布，但参差不齐的商品质量容易为用户带来困惑，此外，商品的转化率还会受到销量评论以及卖家和平台运营动作的影响。如何在动态变化的环境中准确捕捉到高质量的商品，提升用户的购买体验？</p><p></p><p>Lazada将商品演变抽象成一个单独命题，致力于在用户卖家平台三方螺旋成长过程中，让商品推荐更智能。本文将为大家分享阿里在与商品的演变成长性和商品的购买体验相关的三个环节中探索实践的经验。</p><p></p><p>&gt;&gt;&gt; <a href=\"https://xie.infoq.cn/article/36f048c4d0cfd8146e55752e3\">点击查阅文章详情</a>\"</p><p></p><p></p><h3><a href=\"https://xie.infoq.cn/article/20f2150ae4e4b6b14b32040b3\">6. 从混沌到清晰，阿里全球商品类目域建设思考</a>\"</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/1d/1d276f8d4fcecd35d052c64b0728a0eb.png\" /></p><p></p><p>商品是电商产品体系核心之一，类目则是商品模型核心之一，类目系统提供的基础业务数据贯穿了整个电商体系。</p><p></p><p>由于不同地区的文化和操作习惯不尽相同，全球化类目系统需要根据当地业务来进行调整。在知识储备较低、人员流动性大的地区，对类目运营产品依赖性更高。因此，类目域建设在全球化业务中至关重要。本文介绍了商品类目域国内到国际的差异，以及在全球化过程中的建设与思考。</p><p></p><p>&gt;&gt;&gt; <a href=\"https://xie.infoq.cn/article/20f2150ae4e4b6b14b32040b3\">点击查阅文章详情</a>\"</p><p></p><p></p><h3><a href=\"https://xie.infoq.cn/article/219a6c519ea9a1bdb2c0713a4\">7. 阿里国际站用户增长技术探索与实践</a>\"</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/69/692cb4d79179c90574ef2de7d8e8cd55.png\" /></p><p></p><p>和众多传统行业一样，跨境贸易产业近年来也经历了数字化的转型创新，而首先参与进模式创新的地方主要集中于信息展示和业务撮合领域。跨境B类用户与C类买家有着诸多不同，存在着用户结构复杂、行为数据稀疏；目标人群规模小，流量引入的精准性要求高；B类买家留存率低，C类增长策略不可复制三大挑战。本文将为大家分享阿里国际站在用户增长技术体系建设上的探索与实践。</p><p></p><p>&gt;&gt;&gt; <a href=\"https://xie.infoq.cn/article/219a6c519ea9a1bdb2c0713a4\">点击查阅文章详情</a>\"</p><p></p><p></p><h3><a href=\"https://xie.infoq.cn/article/d439b2e90dae2511e9fe50047\">8. 阿里国际站-唤端技术的探索与演进</a>\"</h3><p></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/26/2614542f65bcb288b4a952058cb92077.png\" /></p><p></p><p>近几年用户增长领域APP推广发展迅猛，而唤端就是其中的重要技术。通过唤端拉新/促活不仅能能够将三方流量规模做大，同时二方流量也能有效利用，给网站不断带来商机。但因场景和目标差异在策略及演进上有所不同，海外业务和国内业务的唤端体系建设有着不同特点。与国内相比，海外业务类型差异大、方向不同，二方互相拉活的优势难以在海外被利用。因此，阿里国际站对海外唤端技术进行了改进和打磨。本文将为大家详细介绍阿里国际站在唤端技术的探索与演进。</p><p></p><p>&gt;&gt;&gt; <a href=\"https://xie.infoq.cn/article/d439b2e90dae2511e9fe50047\">点击查阅文章详情</a>\"</p><p></p><p>欢迎点击关注订阅，一键收藏阿里巴巴全球化系列，未来持续查阅最新文章。</p>",
    "publish_time": "2023-03-09 11:36:57",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "又一大佬冲向ChatGPT风口！美团创始人王兴宣布投资王慧文创业项目，共同打造“中国 OpenAI”",
    "url": "https://www.infoq.cn/article/x8Q7ghQ0CmFeuKUPRZiA",
    "summary": "<p>3月8日，美团创始人王兴在朋友圈中表示，将以个人身份参与王慧文创业公司“光年之外”的A轮投资，并出任董事。</p><p>&nbsp;</p><p>“AI大模型让我既兴奋于即将创造出来的巨大生产力，又忧虑它未来对整个世界的冲击。老王和我在创业路上同行近二十年，既然他决心拥抱这次大浪潮，那我必须支持。”王兴表示。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/52/520f087003fba5d6719d1e6b9146e9aa.png\" /></p><p></p><p>自去年年底发布以来，<a href=\"https://www.infoq.cn/article/YYqCPSdRmtkdSl2hhb9Y\">ChatGPT</a>\" 彻底点燃了科技界，并火速：出圈“，仅用 2 个月时间就收获了 1 亿用户。比尔盖茨评价称，ChatGPT 的技术将“改变我们的世界”。马斯克也在感叹“很多人疯狂地陷入了 ChatGPT 循环中”，“ChatGPT 好得吓人，我们离强大到危险的人工智能不远了”。</p><p>&nbsp;</p><p>ChatGPT 的爆火也掀起了<a href=\"https://www.infoq.cn/theme/173\">应用开发热潮</a>\"。据澎湃新闻报道，最近几个月，在旧金山和硅谷，生成式人工智能聚会、联合办公空间和各种会议中弥漫着兴奋情绪，让人感觉像是回到了移动互联网的创业热潮中。年轻的科技创始人给旧金山社区海斯谷起了个绰号“脑谷（Cerebral Valley）”。</p><p>&nbsp;</p><p>国内对 ChatGPT 感兴趣的企业、个人亦不在少数。</p><p>&nbsp;</p><p>稍早前，原美团联合创始人<a href=\"https://www.infoq.cn/article/7T0i680uu5Elrk3VKbNu\">王慧文</a>\"曾在社交平台发文宣布进军人工智能领域，称将打造“中国的 OpenAI”。</p><p>&nbsp;</p><p>其在文中透露，将成立北京光年之外科技有限公司，王慧文出资 5000 万美元，估值 2 亿美元（约 13.62 亿元人民币），并表示，他个人不占股份，资金占股 25%，75% 的股份用于邀请顶级研发人才，下轮融资已有顶级 VC 认购 2.3 亿美元（约 15.66 亿元人民币）。</p><p>&nbsp;</p><p>天眼查 App 显示，北京光年之外科技有限公司成立于 2018 年 7 月，法定代表人为王慧文，注册资本 100 万人民币，经营范围包括销售自行开发的产品；计算机系统服务等，由王慧文全资持股。</p><p>&nbsp;</p><p>据悉，王兴和王慧文是清华大学室友，近二十年间，两人数次携手创业，联手打造出了校内网、美团等多个案例。2020年，王慧文宣布从美团退休时，王兴曾在公开信中表示，“老王和我是有共同志趣的同学和室友，是携手创业的搭档和并肩战斗的战友，更是可以思想碰撞、灵魂对话的一生挚友”。</p><p>&nbsp;</p><p>此次二人继续联手创业，组队打造中国OpenAI，期待可以给用户带来更多的惊喜。</p>",
    "publish_time": "2023-03-09 11:42:42",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "谷歌发布史上最大AI模型 PaLM-E：5620 亿参数，无需特殊训练可操纵机器人",
    "url": "https://www.infoq.cn/article/GNkCpSlCJ8hQ5v4Of4ft",
    "summary": "<p>本周一，来自谷歌和柏林工业大学的 AI 研究团队推出了<a href=\"https://palm-e.github.io/\"> PaLM-E</a>\"，这是一种多模态视觉语言模型（VLM），具有 5620 亿个参数，集成了可控制机器人的视觉和语言能力。据称这是有史以来规模最大的视觉语言模型，能够执行各种任务且无需重新训练，这套与 ChatGPT 有几分相似的 AI 模型新增视觉功能。</p><p></p><p>根据谷歌的介绍，只要给出一条高级命令，比如“把抽屉里的脆片拿给我”，<a href=\"https://palm-e.github.io/\">PaLM-E</a>\" 就能为机械手臂平台（由 Google Robotics 开发）生成相应的操纵指令。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/1c/1c11bc05f748481a81e283d2043cdbae.png\" /></p><p></p><p>在演示视频中，由 PaLM-E 控制的机械臂正伸手取一袋薯片。</p><p></p><p>PaLM-E 的基本工作原理，是分析机器人摄像头采集到的数据，且无需对场景表示做任何预处理。该模型消除了对数据预处理和标注的需求，有望将机器人的自主水平提升至新的层次。</p><p></p><p><a href=\"https://www.infoq.cn/article/7oYfCjaI0rbbpGsBSYWk\">谷歌</a>\"称，该模型还具有一定弹性，能够对周边环境做出反应。例如，PaLM-E 模型能够引导机器人从厨房中取出袋装薯片，并通过将 PaLM-E 集成至控制回路当中，能够应对执行期间可能发生的意外状况。此外，同一套 PaLM-E 模型能成功通过复杂的指令序列实现了对机器人的自主控制，以往这类任务只能由人类引导完成。</p><p></p><p>谷歌在<a href=\"https://the-decoder.com/google-palm-e-combines-language-vision-and-robotics/\">研究论文</a>\"中解释了 PaLM-E 如何将指令转化为行动：我们展示了 PaLM-E 面对具有挑战性的多样移动操作中，表现出的实际性能。我们主要参考 Ahn 等人的设置方案（2022 年），机器人需要根据人类的指令规划一系列导航与操作动作。例如，给出指令“我把饮料弄洒了，能给我拿东西清理一下吗？”，机器人就会规划一连串“1. 找清洁棉；2. 捡起清洁棉；3. 递给用户；4. 放下清洁棉”的行动。受任务启发，我们设计出三个用例来测试 PaLM-E 的具身推理能力，具体包括可供性预测、故障检测和长期规划。低级策略来自 RT-1（Brohan 等人，2022 年），这是一套采用 RGB 图像加自然语言指令、能够向末端执行器输出控制命令的 transformer 模型。</p><p></p><h2>PaLM-E 到底是个啥？</h2><p></p><p></p><p>PaLM-E 是一款下一令牌预测器，取名“PaLM-E”是因为其基于谷歌的 PaLM 大语言模型（LLM，与 ChatGPT 的底层技术相似）。谷歌进一步向其中添加了感官信息和机器人控制功能，帮助 PaLM 实现了“具身化”。</p><p></p><p>由于基于语言模型，PaLM-E 会进行连续观察，例如接收图像或传感器数据，并将其编码为一系列与语言令牌大小相同的向量。如此一来，模型就能继续以处理语言的方式“理解”感官信息。</p><p></p><p>除了 RT-1 机器人 transformer 之外，PaLM-E 还借鉴了谷歌之前在 ViT-22B 上的经验积累——今年 2 月发布的视觉 transformer 模型。ViT-22B 已经接受过各种视觉任务训练，包括图像分类、对象检测、语义分割和图像描述。</p><p></p><p>Google Robotics 并不是唯一尝试使用神经网络进行机器人控制的研究小组。这项特殊工作与<a href=\"https://www.infoq.cn/article/9wzrGiMTl8XClRgSfL9A\">微软</a>\"最近发布的《ChatGPT for Robotics》论文有相通之处，该文章也尝试以类似方式将视觉数据同大语言模型相结合，探索对机器人进行控制。</p><p></p><p>除了机器人技术之外，<a href=\"https://www.infoq.cn/article/FB6BxlokIrMQgNLl3Vzt\">谷歌研究人员</a>\"还观察到其他一些有趣的效果，其明显来自 PaLM-E 的大语言模型核心。首先，它表现出了“正迁移”，又称助长式迁移，意味着它能把一项任务中学到的知识和技能迁移至另一项任务，而且与单任务机器人模型相比具有“明显更高的性能水平”。</p><p></p><h2>谷歌称正在探索 PaLM-E&nbsp;模型更多应用场景</h2><p></p><p></p><p>此外，研究人员还观察到模型规模有越来越大的趋势：“语言模型越大，在视觉语言和机器人任务训练时就越能保持住这种语言能力。从数量上讲，5620 亿参数的 PaLM-E 模型几乎保留了全部的语言能力。”</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/c8/c82483af15661cba5442d58431e5af15.png\" /></p><p></p><p>在另一不同领域，同一套 PaLM-E 模型能够实时控制机器人。在此之前，机器人还需要人工引导才能完成很长的操作任务（interactive-language.github.io），但现在 PaLM-E 已经能够自主学习这些任务。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/3f/3f7d86d255ad12357948b15c0adee82b.png\" /></p><p></p><p>谷歌称，“PaLM-E 是迄今为止已公开的最大视觉语言模型。我们观察到，尽管只接受了单图像提示训练，但 PaLM-E 仍然掌握了多模态思维推理和多图像推理等新能力。虽然不是我们的工作重点，PaLM-E 在 OK-VQA 基准测试上创下新的同类最佳性能”。</p><p></p><p>研究人员宣称，PaLM-E 还展现出随机应变的能力，例如尽管只接受过单图像提示训练，仍可实现多模态思维链推理（允许模型对包含语言和视觉信息在内的一系列输入进行分析）和多图像推理（同时使用多张输入图像进行推理或预测）。从这个角度看，随着深度学习模型变得越来越复杂，PaLM-E 似乎正带给我们更多惊喜。</p><p></p><p>谷歌研究人员还计划探索 PaLM-E 模型在现实场景中的更多应用，例如家庭自动化或工业机器人。他们希望 PaLM-E 能够启发出更多关于多模态推理和具身化 AI 的研究。</p><p></p><p>如今“多模态”已经成为新的流行语。相信随着企业着力研发具备类人常规任务执行能力的人工通用智能（AGI），多模态的大名也将越来越多为人们所听闻。</p><p></p><p>参考链接：</p><p>https://arstechnica.com/information-technology/2023/03/embodied-ai-googles-palm-e-allows-robot-control-with-natural-commands/</p>",
    "publish_time": "2023-03-09 12:59:33",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "2023第一家倒下的自动驾驶公司：七年没开展实际业务，百亿估值靠吹出来，上市16个月破产了",
    "url": "https://www.infoq.cn/article/VEAmqNAPRjMud9ypeuNV",
    "summary": "<p>近日，据外媒报道，自主卡车新贵Embark宣布破产，结束运营并解雇了大部分员工。</p><p></p><h2>从估值50亿到破产仅16个月</h2><p></p><p>&nbsp;</p><p>自主货运初创公司Embark&nbsp;Trucks曾经创造出了最激动人心的财富故事，但如今的它已宣布结束运营并解雇大部分员工。</p><p>&nbsp;</p><p>在上周五给员工的电子邮件中，公司CEO兼联合创始人Alex Rodrigues写道，“在全面评估了所有潜在方案之后，我们确信已无法按当前形式继续维持业务。”</p><p>&nbsp;</p><p>这个时候，距离<a href=\"https://www.infoq.cn/article/F7Ho0RJ8IHGkO9YwXSyB\">Embark</a>\"这家诞生于旧金山的<a href=\"https://www.infoq.cn/article/fFpp7ZQIMSUclk8ckwsz\">自动驾驶</a>\"卡车新贵完成SPAC（海外借壳上市）、拿下51.6亿美元估值才仅仅过去16个月。</p><p>&nbsp;</p><p>即使是考虑到当时“虚火过旺”的市场状况，还没开始赚钱的<a href=\"https://www.infoq.cn/article/F7Ho0RJ8IHGkO9YwXSyB\">Embark</a>\"能豪取50亿估值还是有些夸张了。但这并不妨碍支持者们奋力吹捧其“精致的自主驾驶软件”，宣称Embark打造的长途卡车将彻底颠覆整个货运行业。</p><p>&nbsp;</p><p>SPAC的赞助方们也为Embark贡献了约6.14亿美元：Northern Genesis Acquisition Corp.&nbsp;II豪掷4.14亿美元，CPP Investments及卡车运输公司Knight-Swift Transportation、Mubadala Capital、Secooia Capital、Sedooia Capital和Tiger Global Management共计拿出2亿美元。</p><p>&nbsp;</p><p>在2021年11月11日首登纳斯达克时，Embark正好赶上了技术股的峰值周期，其股价在接下来几个月内都始终维持在目标估值水平。但随着市场遇冷，投资者的态度也逐渐消极。到2022年1月，Embark的股价迅速缩水一半，六个月后，其股价已经不足上市之初的十分之一。</p><p></p><h2>Embark 的起伏史</h2><p></p><p>&nbsp;</p><p>Embark成立于 2016 年，总部位于旧金山，由 Alex Rodrigues 和 Brandon Moak 共同创立。</p><p>&nbsp;</p><p>据了解，Rodrigues 在 11 岁时就开始制造<a href=\"https://archsummit.infoq.cn/202303/beijing/track/1454\">机器人</a>\"，他在加拿大滑铁卢大学学习机电一体化工程时遇到了 Moak，两人在大学期间曾一同在车库中造出了加拿大第一辆自动驾驶汽车—— 一辆名为“Marvin”的自动驾驶高尔夫球车。</p><p>&nbsp;</p><p>2016 年，Rodrigues 和 Moak 正式创立 Embark，并加入了美国著名创业孵化器 Y Combinator 的孵化计划。据了解，Embark 公司最初的计划是构建用于大学校园的自动驾驶班车。不久后，团队开始转向应用于高速公路的<a href=\"https://www.infoq.cn/article/QtGA7QPzlFc1l2wORpgP\">自动驾驶</a>\"卡车。</p><p>&nbsp;</p><p>自动驾驶卡车市场前景广阔，Embark 也迅速得到了风投的青睐。在 2016 年至 2019 年期间，Embark 筹集到的资金包括：由 Maven Ventures 领投的 200 万美元种子轮融资，由 DCVC 领投的 1500 万美元 A 轮融资，由红杉资本领投的 3000 万美元 B 轮融资，以及由 Tiger Global 领投的 7000 万美元 C 轮融资。</p><p>&nbsp;</p><p>拿到巨额融资后的 Embark 野心勃勃。《华尔街日报》曾在几年前的一篇文章中提到，Embark 的首席执行官 Rodrigues 计划在五年内初步部署一辆全自动驾驶卡车。该公司的长期愿景是：在城市行驶时，由人类卡车司机掌握方向盘，在高速公路上则由计算机控制。</p><p>&nbsp;</p><p>2021 年，Embark 开始谋求上市。2021 年 6 月，Embark 宣布将与空白支票公司 Northern Genesis Acquisition Corp. II 合并在纳斯达克上市。在交易报告中，Embark 表示，他们计划从 2024 年开始在美国南部工业区实现自动驾驶卡车的运营。</p><p>&nbsp;</p><p>2021 年 11 月，Embark 成功上市，市值约 50 亿美元。通过此次上市，Embark 筹集了约 6.14 亿美元的现金总收入。</p><p>&nbsp;</p><p>但自上市开始，Embark 的股价几乎一直在跌，市场也开始质疑 Embark 的能力。</p><p>&nbsp;</p><p>2022 年 1 月，The Bear Cave 发布了一份题为“Embark 科技公司的问题”的报告，让情况变得更加糟糕。这份报告认为，“Embark 公司目前的估值似乎是基于吹嘘而非实际的内容。”报告警告说，Embark 公司“没有专利，只有十几辆测试卡车，而且可能是虚张声势”。</p><p>&nbsp;</p><p>随后，Embark 股东开始集体诉讼，指控 Embark 夸大了其运营和技术能力。在季度申报中，Embark 承认了自己在合并证券集体诉讼中的被告角色，并斥责那些指控“缺乏法律依据”。</p><p>&nbsp;</p><p>公共市场也没有对 Embark 提供支持。2022 年 8 月，为了避免因股价持续低于 1 美元而退市，Embark 公司宣布进行一项 20 比 1 的反向股票分割。此举提升了个股价格，但却并没有提升公司的估值。</p><p>&nbsp;</p><p>自那时起，Embark 的股价开始进一步大幅下跌。与起初的 50 亿美元市值相比，上市仅一年多Embark 的市值几乎跌没了。&nbsp;</p><p></p><h2>运营七年没真正开展业务，只靠外部“输血”难以为继</h2><p></p><p>&nbsp;</p><p>通过对Embark曲折上市之路的跟踪观察，我们发现分析师其实已经预见到了这位自动驾驶卡车新贵的后续遭遇。</p><p>&nbsp;</p><p>这家运营7年的企业自始至终都没能真正开展业务，更不用说创造收入或者实现盈利了。相反，高达几十亿美元的估值完全来自投资市场对Embark<a href=\"https://archsummit.infoq.cn/202303/beijing/track/1477\">技术潜力</a>\"的乐观预期。</p><p>&nbsp;</p><p>但时代已经变了。</p><p>&nbsp;</p><p>正如Rodrigues在上周五的邮件中所言，“资本市场开始对无法创造收入的企业说不，如同无法按时完成商业计划的制造企业被迫推迟业务扩展一样。”</p><p>&nbsp;</p><p>在“全面评估所有的潜在方案之后”，Embark表示将裁掉70%的员工，并关闭位于南加州和休斯顿的办公室。Rodrigues写道，其余30%员工将负责关闭日常运营，最后“感谢各位支持我们的同事”。</p><p>&nbsp;</p><p>别的不讲，最初，Embark确实拥有着勃勃野心。</p><p>&nbsp;</p><p>当时《华尔街日报》曾在报道中引用CEO Rodrigues的原话，预计<a href=\"https://archsummit.infoq.cn/202303/beijing/track/1454\">完全自主驾驶</a>\"卡车在未来五年内即可初步部署。该公司的长期愿景是在市区驾驶时由人类司机接管，到高速公路场景则由计算机控制。</p><p></p><h2>寒冬之下，自动驾驶卡车迎来「倒闭潮」</h2><p></p><p>&nbsp;</p><p>Embark只是投身自主驾驶卡车市场的多家初创公司之一，而其他各位同仁也纷纷在艰难时刻倒闭破产，具体包括：</p><p>&nbsp;</p><p>总部位于旧金山的Otto。作为较早的创业公司之一，Otto专注于自主驾驶卡车，并于2016年以6.8亿美元接受Uber的收购。约两年之后，<a href=\"https://www.infoq.cn/article/fo4Co3jrmbo11GkUt0uD\">Uber</a>\"关闭了自主驾驶卡车部门，并表示将战略重点放在自主驾驶汽车上。</p><p>&nbsp;</p><p>Starsky Robotics，一家由风险投资支持的旧金山自主驾驶货运公司，在B轮融资失败后于2020年倒闭。自2015年成立以来，这家公司共筹集到超2000万美元资金。</p><p></p><p>Peloton Technology，一家位于硅谷的自主驾驶技术初创公司。在2021年倒闭之前，已知融资总额超过7800万美元。</p><p>&nbsp;</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&amp;mid=2247578431&amp;idx=1&amp;sn=4ade672ebe86e1377555e61f5a3fd2c0&amp;chksm=fbeb0af0cc9c83e612131e18142c60fa6818d8a4c5125d6c7cd5ba08ada8289bd49994f57dff&amp;scene=27#wechat_redirect\">TuSimple</a>\"，来自圣迭戈的机器人卡车技术开发商，于2022年4月进行了IPO。初上市时估值高达85亿美元，但目前市值已经缩水至约4.6亿美元。</p><p>&nbsp;</p><p>来自匹兹堡的Aurora于2021年夏季宣布将通过SPAC的方式上市，最初市值约130亿美元（含约25亿美元现金）。但如今，其股价同样下跌至峰值时期的不足十分之一。</p><p>&nbsp;</p><p>参考链接：</p><p><a href=\"https://news.crunchbase.com/transportation/embark-trucks-closes-autonomous-vehicles/\">https://news.crunchbase.com/transportation/embark-trucks-closes-autonomous-vehicles/</a>\"</p>",
    "publish_time": "2023-03-09 13:52:52",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "和谷歌一样，Mozilla也在期待苹果终结Webkit规则",
    "url": "https://www.infoq.cn/article/N6crECI9NBxwui3GmduK",
    "summary": "<p>根据最新消息，考虑到苹果准备取消对竞争对手在 iOS 中使用 WebKit 浏览器引擎的限制，Mozilla 已经开始为这一天的到来提前做准备了。</p><p></p><p>Mozilla 几年前就做过了类似的实验，但是结果在当时并没有公开出来。时过境迁，2022 年 10 月 Mozilla 在存放 Firefox iOS 版代码的 GitHub 存储库中发布了一个问题，其中包含了一条对 GeckoView 的引用，而 GeckoView 是 Firefox 的 Gecko 渲染引擎的包装器。</p><p></p><p>根据当前的苹果 AppStore 指南，iOS 上的第三方浏览器应用程序必须使用苹果自己的 WebKit 浏览器引擎。因此，Mozilla 目前是无法通过 iOS 的 AppStore 发布使用 Gecko，而非 WebKit 引擎的 Firefox 版本的。</p><p></p><p>媒体之前也报道，Mozilla 并不是唯一一家期待 iOS 平台 AppStore 商店可以带来更利于浏览器市场竞争的规则的企业。除了 Mozilla 之外，谷歌已经开始为 iOS 平台开发基于其 Blink 引擎的 Chrome 版本。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/f4/f44b52659a005070a891a2962af3291f.png\" /></p><p></p><p>主要的浏览器制造商——<a href=\"https://www.infoq.cn/article/RCJHtVcEeVjad2kGJD5s\">苹果</a>\"、谷歌和 <a href=\"https://www.infoq.cn/article/dxf9lY8Elt5BtbtEUG0z\">Mozilla</a>\"——都有自己的浏览器渲染引擎。苹果的 Safari 基于 WebKit；<a href=\"https://www.infoq.cn/article/GGzRSK9sVKRrDD7xH97t\">谷歌的 Chrome </a>\"及其开源 Chromium 基金会基于 Blink（该引擎十年前从 WebKit 分叉而来）；Mozilla 的 <a href=\"https://www.infoq.cn/article/hHClLTq2A5lrfz9DusWe\">Firefox</a>\" 基于 Gecko。</p><p></p><p>微软在当年的 Internet Explorer 中使用了自己开发的 Trident 渲染引擎，并在旧版 Edge 中开发了一个名为 EdgeHTML 的 Trident 分支。但自从这家公司将其 Edge 浏览器改为基于 Chromium 代码开发以来，Edge 一直依赖于 Blink 引擎。</p><p></p><p>浏览器渲染引擎负责在屏幕上渲染文本和图像。当浏览器工程师添加新功能或支持新的 API 时，他们通常通过添加渲染引擎代码来实现目的，这从各种 Blink 的增强特性也可以看出来。</p><p></p><p>有时苹果、谷歌和 Firefox 会就新功能达成一致并共同努力解决问题，例如弹出菜单这一特性就是个例子。其他时候，三大浏览器制造商会产生分歧，结果各自的代码库走上不同的路线。</p><p></p><p><a href=\"https://www.infoq.cn/article/TdS104Q68yk3oLONlk9x\">Safari </a>\"的特性开发一直落后于 Chrome 和 Firefox。然而，苹果似乎意识到了监管机构带来的风险，并向 WebKit 团队增加了更多员工以缩小浏览器的能力差距。</p><p></p><p>如果苹果确实允许其他厂商在 iOS 生态系统中使用其他浏览器引擎，谷歌和 Mozilla 将能够通过这些浏览器的桌面版本中积累的显著技术优势来与 Safari 竞争。</p><p></p><p>开发者游说团体 Open Web Advocacy 去年发布了一份报告 Bringing Competition to Walled Gardens，详细阐述了苹果的 WebKit 限制所带来的后果。它将苹果的限制描述为反竞争的自我偏好。</p><p></p><p><img src=\"https://static001.geekbang.org/wechat/images/22/22de3ac765dd8d851dfad269cc4e0cdc.png\" /></p><p></p><p>Web 平台测试仪表盘显示在各个浏览器中的失败数量</p><p></p><p>“苹果正在阻止可互操作的、基于通行标准的 Web 技术成为苹果和谷歌提供的原生私有生态系统的可行替代方案，”该组织的报告给出了这样的结论。</p><p></p><p>“在缺乏竞争的情况下，苹果自己的浏览器对 Web 应用的糟糕支持状态会把开发者和用户推向 AppStore 的封闭生态系统。”</p><p></p><p>虽然前述 GitHub 问题中提到的，用于切换到 GeckoView 的 Firefox for iOS 设置页面可能只是用于 Mozilla 内部的浏览器测试用途，但 Mozilla 的脚步似乎不止于此。对这个 GitHub 问题的简短公开讨论表明，Mozilla 已经预料到苹果的规则可能会发生变化——这是 Mozilla 和其他公司通过持续的监管游说寻求的结果。</p><p></p><p>早在去年12月12 日，一位开源贡献者询问这是什么版本，Mozilla 的高级软件开发人员 Laurie Marceau 回答说这是“针对不在这个代码库中的一个次要项目”。</p><p></p><p>这位开源贡献者随后回复道，“谢谢，希望欧盟赶快落地相关法规，这样我们就可以在 iOS 上拥有好用的 Gecko Firefox 了。”</p><p></p><p>Marceau 的回应是一个竖起大拇指的表情符号。Marceau 对媒体的进一步说明请求没有回应。Mozilla 对媒体的询问没有立即回应，但表示他们稍后可能有话要说。</p><p></p><p>去年12月13日，有报道称苹果正准备在 iOS 17 中允许第三方应用商店上线——该版本预计在 2023 年第三季度发布——从而遵守欧洲数字市场法案的要求。欧盟的这些规则——以及其他监管机构提出的相关担忧——看起来可能会迫使苹果放弃其对 iOS 平台上 WebKit 的相关限制要求。</p><p></p><p>然而，苹果并未就此做出公开承诺，也未回应媒体的置评请求。</p><p></p><p>这不是 Mozilla 第一次为 iOS 准备基于 Gecko 引擎的 Firefox 版本了。Mozilla 前平台工程师 Ted Mielczarek 在 Twitter 上指出，他曾在 2010 年和 2015 年两次参与 Gecko 引擎到 iOS 平台的移植工作。</p><p></p><p>Mozilla 从未要求法院强制苹果在 iOS 上分发基于 Gecko 引擎的 Firefox 版本——这会是一场代价高昂的法律战争，而且它可能并不会赢。但最近，它在 2022 年 9 月的一份题为“五大技术花园围墙：为什么浏览器对互联网至关重要，以及操作系统如何阻碍它们的发展”的报告中表达了公众对苹果 WebKit 规则的反竞争后果的担忧。</p><p></p><p>如果欧盟数字市场法案产生预期的效果，到今年年底这种技术花园围墙将会减少一些。但根据过去的经验，我们也不能太早开香槟。</p><p></p><p>在一封电子邮件声明中，Mozilla 发言人说：“我们遵守苹果的 iOS 应用商店政策，只是在做一些探索性工作，以了解如果这些政策发生变化，iOS 上基于 Gecko 引擎的浏览器将会面临的技术挑战。我们希望人们可以自由使用他们所选择的浏览器，可以自由选择浏览器背后所使用的引擎，我们希望这样的一天能尽早到来。”</p><p></p><p>原文链接：</p><p><a href=\"https://www.theregister.com/2023/02/07/mozilla_google_apple_webkit\">https://www.theregister.com/2023/02/07/mozilla_google_apple_webkit</a>\"</p>",
    "publish_time": "2023-03-09 14:22:37",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "软件持续交付速度提升 40%！DevOps 制品管理有何魔力？",
    "url": "https://www.infoq.cn/article/9OuaokzYV9WfWvv8IXRO",
    "summary": "<p>近年来，混合云、多云正逐步成为企业用云的主流模式。据 IBM 的调查报告显示，仅截至 2021 年，采用混合云、多云战略的企业就已经接近 80%。混合云、多云战略的确能够增加企业资源配置的灵活性，但也给持续交付带来了更大的挑战。在软件发布频率持续增长趋势下，如何将版本快速分发到多个环境中去，成为令不少开发者头疼的问题。</p><p></p><p>近日，亚马逊云科技联合 JFrog 举行 《DevOps 实践：混合云模式下软件单一可信源的建设方法》为主题的 Tech Talk，<a href=\"https://www.infoq.cn/article/CAZFSFzSRfZevqzm8K0V\">JFrog </a>\"（中国）技术总监王青与大家分享了解决该问题的独特思路。</p><p></p><p></p><h2>现有的制品库正在阻碍你的快速发布</h2><p></p><p></p><p>IDC 研究报告显示，到 2024 年全球 APP 数量将达到 520M；2025 年后，超过 60% 的企业每天都将进行版本发布，甚至更快。在如此之快的版本构建需求下，现有的统一代码库、统一持续集成再进行不同环境分发的制品管理方式往往存在一定的局限性。</p><p></p><p>研发团队面临着 Nexus 开源版私服宕机无人维护、开源组件漏洞被引入等问题；测试团队无法清晰地了解版本质量信息，同时测试报告也无法准确进行关联；运维团队在面临宕机问题时候缺乏商业技术支持，缺乏高可用和容灾；在此管理模式下，一旦发生问题，安全团队很难快速发现漏洞、对问题进行定位，从而及时响应。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e3/e3dbc4323e0a29487b97910c8f8c590b.png\" /></p><p></p><p>面对诸多问题，王青提出，建立软件单一可信源对于企业来说是至关重要的。单一可信源是指企业内部单一的，合规地存放所有软件的仓库，包括 war 包，<a href=\"https://www.infoq.cn/article/wbcoOqPAwr9Ij6fL5sDd\">Docker 镜像</a>\"，zip 包等，以及第三方开源组件或者商业软件的授权版本和软件物料清单 (SBOM)。</p><p></p><p></p><h2>为什么要建立软件单一可信源</h2><p></p><p></p><p>建立唯一可信源的制品管理流程后，只需要不断将版本从开发流水线的 CI 服务器里建立晋级，一路晋级到生产环境的制品库，再由生产环境的制品库推送到多云环境中去。对于大型企业来说，通常会有多种云的技术栈，多种语言包都需要构建。通过制品库统一构建，把版本统一上传到 DEV 本地仓库做本地的集成测试，当开发者测试没有问题后，版本会晋级到 Test 仓库供测试来测，此后版本会进入性能和稳定性检测的环境，最终进入到生产环境的仓库中。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/bc/bc24a8c9f54589a3ee0557b2d7021f81.png\" /></p><p></p><p>按照这种制品的晋级流程去建设会大大提高软件交付的效率。JFrog Artifactory 遵循的正是这样一套流程。它是支持 29 种语言包的制品仓库，Maven 包、NPM 包、Docker 镜像、ZIP 文件等多种通用文件都可以进行存储。据王青介绍，JFrog 曾有一个国内大型手机制造商客户，每天单集群数据增长 20TB 左右，共有 10 多个集群。JFrog 和他们一起在研发测试区搭建了本地 Artifactory 集群，支持高并发的上传和下载，通过 5-6 个 Artifactory 节点来作为高可用集群提供服务。</p><p></p><p>这种方案相比传统的需要搭建一个 Nexus 开源版作为 Docker 镜像，再搭建一个 Nexus 开源版作为 Maven 仓库，Maven 仓库可能还要管 NPM 的技术方案，投入人力成本更低且能够提供更高的可用性。对于有多套环境的大型企业来说，软件单一可信源建设的优势就更加明显了，因为多套环境维护成本会线性增长。</p><p></p><p></p><h2>混合云模式下单一可信源的建设方法</h2><p></p><p></p><p>软件单一可信源的建设有助于企业降本增效，提升软件制品的构建速度，那么，该如何构建软件单一可信源呢？王青谈到了一种区别于传统开源方案的独特方式。</p><p></p><p>他说，在公司建设软件仓库的单一可信源时，最基本的是要保证它的高可用性。高可用有两层含义，一是零宕机，二是能够支持高并发的负载。Artifactory 对于生产环境的部署，天然的支持私有云和公有云的一键部署，并且提供实时推送功能。相比较来说，Nexus 开源版是没有推送功能的，因此，也就没办法实现将本地构建的版本推送到多个私有云或者多个公有云上去。</p><p></p><p>假设公司的制品数量级已经达到百万级甚至是千万级，该如何应对这种大规模的读取和写入呢？JFrog 引入了两个概念，一个是读缓存层，一个是写缓存层。这是区别于开源方案的一个很重要的产品功能设计点。Nexus 开源版是没有缓存这个概念的，拉取的时候会去本地查询文件存在与否，这样的问题是，当服务读取操作系统文件的时候，操作系统文件是要耗时的，如果文件块在物理上存储的力度比较分散，实际查询效率会很低。</p><p></p><p>JFrog 在 Artifactory 服务器上添加了一个叫 SSD 的缓存层，通过这个缓存层能够快速读取一些热数据返回给用户。这个设计遵循的是 LRU 的算法，会保持 500G 左右的热数据。除了读缓存，JFrog 还引入了写缓存。因为在将文件上传到服务器上的时候，是先上传到服务器的某一个目录，再通过一个进程写到存储里，有了这个设计，只要把文件成功上传到目录即可创建成功，大大减少了客户端返回的请求时间, 而后端只需建立一个异步任务，把文件存储进去，再把存储目录删掉即可。为了减少存储的压力，JFrog 还设计了冗余同步，能够让用户去配置冗余数量，如上传一个文件时用户要冗余两份，Artifactory 就会把文件从 a 冗余到 b 去，通过轮询拿到热数据返回，从而提高效率。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/3e/3e3ce331fea9a63719e86148a45941cc.png\" /></p><p></p><p>综上所述，高可用性是建立软件单一可信源的基石。尤其是当客户的数据量超过几千万时，如果都保存在存储中，查找的效率就会非常低。在存储方面，JFrog 也进行了优化。GIT 文件存储是按照 checksum 的前两位，以目录的方式去存储每一个文件，所以 GIT 能高效地存储代码仓库里面上百万、上千万的文件，依托的是文件索引的设计。当用户寻找某一个文件的时候，它会先以索引的方式定位到文件在哪个目录，在目录里面再去辨别。相当于建立了树状的结构，因此查询效率会更高。当数据量增大后要提升效率肯定还是需要依赖数据结构，通过每种场景应用不同的数据结构提升效率。</p><p></p><p>完整的高可用服务能够保证制品库建设单一可信源，可信性该如何保证呢？让制品库变得可信就涉及到安全相关的问题。王青说，尤其在面对海外用户时候，面临的最大挑战不是软件发布效率瓶颈，而是安全问题，特别是部署到公有云上的时候。他很形象地比喻，在整个程序的冰山上，代码就是冰山一角，底层有很大的 API 接口、依赖包，还有底层的基础镜像，下面会存在很多开源组件，其中客户提到最多的就是漏洞爆发之后哪些应用将受到什么样的影响，应该修复到哪个版本？</p><p></p><p>对于上述问题，王青认为，现在开源软件比较多，但真正用起来会存在很多问题。如恶意依赖注入、注入恶意二进制或者代码实现勒索等。为此，JFrog 的产品中特别增加了漏洞扫描的功能。当发现漏洞时 ，JFrog 是如何快速定位，然后下线这些服务的升级版本的呢？这需要精准定位的能力。</p><p></p><p>传统的扫描会扫出很多漏洞，缺乏跨语言的依赖，比如无法定位到哪一个 Docker 镜像被 Log4j 污染。JFrog 通过 SCA（software component analysis）来进行漏洞扫描，此外还对某些语言包如 Docker 镜像进行密钥探测，包括上下文分析。扫描出漏洞之后，传统的厂商只会告诉用户有哪几个漏洞，而 JFrog 则会告诉你每个漏洞的评分分别是什么以及该漏洞的影响范围。</p><p></p><p>单一可信源建设要做的不仅仅是扫描，还有治理，对于扫描出的漏洞进行跟踪并精细化管理。安全部门要做的是定义规则，定义策略。公司内部一般有两个概念，一个是漏洞，一个是违规，漏洞是事实，而违规是公司策略。安全部门要定义哪些级别的版本属于违规，而开发者只需要去修复违规就可以了，不用管所有的漏洞。因此，Artifactory 设计了两个维度的管理，一个是根据团队或者软件版本进行扫描，定位到某一个团队。另一个是按照部门去修复，不同部门的安全策略可能是不一样的，所以可以根据不同部门创建 Project 进行扫描和漏洞修复，从而实现有效的漏洞治理。</p><p></p><p>以上介绍的是在单一私有云或者公有云环境下的处理方式，如果要把私有云的制品同步到公有云上，JFrog 是如何做的呢？王青说，这就涉及到 JFrog 另一个功能——制品的双向同步。通过双向同步能力，能借助于亚马逊云科技的 PrivateLink 开设私有网络。只要开了 Link 之后，私有云的制品仓库就能直接推到云上的 VPC 上去，自动复制到不同的 Region，实现制品液体般的流动。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/fc/fce3884687017f8e5e11960f09eb972f.png\" /></p><p></p><p>除制品的双向同步之外，JFrog 还提供统一认证的功能，使云上云下保持一致。通常来说，云上的用户和云下的用户的账号是不能复用的，比如云上用账号 a 登录，云下就要用账号 b，这样用户就需要维护两套账号，导致用的人越多，账号维护的成本就越高。但是，Artifactory 实现了联合身份认证。只要在集群 a 创建用户，它会自动把用户信息同步到集群的每一个节点，用户在云下怎么登录，在云上按照同样的方式登录即可。这个功能特别适合多云环境进行软件制品的传输，能够极大节省公网带宽，提高发布速度，降低成本。</p><p></p><p></p><h2>轻松建立可信发布流程的实践案例</h2><p></p><p></p><p>某大型跨国银行，需要进行云迁移，实现应用上云。他们采用的方案是本地的关键数据库加上存储，到云上直接使用云数据库加上 Amazon S3 云存储，应用直接迁移到 Amazon EKS，Amazon EKS 的使用极大的降低了运维成本。在整个数据迁移的过程中，JFrog 有专门的工具把本地的 Artifactory 制品通过一个脚本直接传到云上的 Artifactory，这种持续的传输实现了业务的零中断，并能将构建速度提升了 30-40%。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/48/4838c78da9cd4f737122f2bb9b0b9ff9.png\" /></p><p></p><p>软件制品从本地推到云端会用到一个 VPC 叫 Internal Gateway。此外，亚马逊云科技在 2022 年 re:Invent 上还最新发布了一款名为 <a href=\"https://www.infoq.cn/article/wYhCKfgNMY0UXt4cUWlf\">Amazon CodeCatalyst</a>\" 的 DevOps 端到端工具，包含需求设计、issue 管理、构建等一系列功能，用户可以通过 &nbsp;Amazon CodeCatalyst 进行构建，构建完成后把版本上传到某个 Amazon ECS , 并且能够和 Artifactory 制品库进行集成。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b3/b3aafdf6f96a9c6076e26608c56a6254.png\" /></p><p></p><p>集成方式如上图所示，用户的代码 Commit 后到 GIT 仓库就能触发 Amazon CodeCatalyst 构建，构建时，通过 JFrog 的 CLI 命令行工具连接到 Artifactory 做远程依赖 PublicRepo 的下载，下载时会触发漏洞扫描，扫描完成后进行晋级，分发到多种云，用 IoT 设备进行更新。整个编排过程由 Amazon CodeCatalyst 进行负责的，并能够和 Artifactory 无缝集成，从而实现轻松地规划、开发、写作、构建和交付应用程序。</p><p></p><p>王青在分享中多次强调，对亚马逊云科技技术和服务感兴趣的开发者可参与亚马逊云科技的培训认证活动，亚马逊云科技的整个培训体系建设非常完善、可进入<a href=\"https://dev.amazoncloud.cn/activity/activityDetail?id=63e3861a6b109935d3b7725d\">亚马逊云科技开发者社区</a>\"。</p>",
    "publish_time": "2023-03-09 14:39:04",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]