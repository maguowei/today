[
  {
    "title": "微服务架构搭好了，可观测方案怎么整？",
    "url": "https://www.infoq.cn/article/7FgqsQVNa1a2BbHyjZf2",
    "summary": "<p>差不多在五年前，分布式系统也已成熟，微服务架构尚未普及，可观测问题就已经在桎梏技术团队的工作效率。一个To C的软件使用问题可能由客服发起，整条支撑链路的所有技术部门，都要逐一排查接口和日志，流程非常原始，也非常低效。如果业务到达一个量级，支撑系统变多，两名研发查上两三个星期也是常事。</p><p>&nbsp;</p><p>微服务架构普及后，问题变得更加严峻。一个服务被拆分成数个黑盒的、虚拟的微服务，故障排除彻底成为一种折磨。这一切都使业务的可观测性成为2022年技术人必须关注的话题。本期<a href=\"https://www.infoq.cn/video/5cJEWsLZdjGRSDR3WXMZ\">《极客有约》</a>\"，我们邀请到博睿数据创始人兼CTO孟曦东和某头部证劵公司SVP的周洪一起聊聊可观测技术究竟是什么？</p><p></p><p></p><p></p><p></p><p>InfoQ：微服务架构的普及对可观测带来了一些挑战，这些挑战又让运维领域发生了怎样的变化？</p><p>&nbsp;</p><p>孟曦东：可观测不是一个新名词。2018年，CNCF将其正式引入IT世界，该理论的出现则可以追溯至2014年前后，主要来自于控制学，希望通过外部输出推断内部的状态变化。如今，技术栈发生了巨大变化，微服务可能构建在容器之上，容器又构建在虚拟机上，虚拟机则在物理机上，包括更复杂的网络支持，这让定位排障遇到了前所未有的困难。CNCF之所以将可观测性带到微服务领域也是希望能有更好的能力控制系统的运行状态。</p><p>&nbsp;</p><p>与传统的监控相比，可观测性的核心点还是有所区别的。监控可能更多在看现实状态的变化，很直接，但并没有表现出问题的核心点在哪。我们认为可观测性是对现今技术架构非常好的适应，可以用另外一种模型来判断风险所在位置，能更好地预防故障发生而不是简单地降级、限流。</p><p>&nbsp;</p><p>InfoQ：在实际应用当中，企业对可观测性的实际感受是什么样的？</p><p>&nbsp;</p><p>周洪：我们面临着线上问题的排查困难，包括一些链路追踪的困难。特别是证券业务对高可用有非常高的要求，某一个业务出现问题可能无法通过降级和限流来解决，对客户来讲还可能面临着经济上的损失，我们对链路的观测，对链路问题的追踪，对链路服务质量有非常高的要求。在技术架构的升级和演进过程中，我们面临着两类比较难以解决的问题，分别是全链路故障定位及解决和缺少相对全局的视角。</p><p>&nbsp;</p><p>InfoQ：如今，大部分企业还停留在粗暴的降级阶段，还是有意识做全局可监控？</p><p>&nbsp;</p><p>孟曦东：可以分成两类，一类是发展靠前的企业，在业务体验或者用户感知能力上面要求较高，内部对此有很多KPI，比如出现问题需要一分钟内发现，十分钟内解决等；另一类是农林牧副渔等领域的传统企业，目前手段还比较初级，只做到了单体的简单监控，整个上层的应用体系还没有完整建立起来。</p><p>&nbsp;</p><p>InfoQ：具体到技术层面，可观测问题可以分为四类，分布式链路追踪、APM、NPM、RUM，方便介绍下这四者的核心思想吗？</p><p>&nbsp;</p><p>孟曦东：从可观测性的建设体系来看，需要有三种类型的数据。RUM可能更多关心的是用户侧，比如用户到底在使用浏览器、APP还是小程序，使用体验如何或者整个运行过程中的数据能力是如何表现出来的；NPM可能更多在描述链路层面，因为这是必备通道，是建立从前端到后台连接的必备过程，在描述整个数据流向的时候，流量数据又是什么样的表现；APM把物理设备层面的能力提升到了以应用代码级为主，可以看最详细的代码状态，或者依赖的中间件以及JVM状态变化。整个链路追踪分段做数据采集，数据来源可能不同，但模型的核心是构建出一套完整的数据链条来帮助我们更好地判断业务受损到底是由哪个环节产生的问题。</p><p>&nbsp;</p><p>InfoQ：APM做到代码级别之后，还有进一步的改进空间吗？</p><p>&nbsp;</p><p>孟曦东：改进空间肯定还是有的。第一，全链路可观测性需要了解代码的整体逻辑，这样才能更好地知道版本迭代时前后接口的变化；第二，我们也需要知道彼此之间的依赖项是什么，从技术内部来看，链路是非常多样化的，尤其是引用了容器云之后，随着Pod的增加和减少，链路变得错综复杂并且更加动态，我们需要有更完整的信息数据来支撑我们做故障定位。</p><p>&nbsp;</p><p>InfoQ：国内外目前在可观测领域的技术发展现状大概是什么样的？</p><p>&nbsp;</p><p>孟曦东：相对于国外来说，国内起步稍晚，我们可以看到国外有很多优秀的友商，在可观测能力的构建上已经非常成熟，他们还与DevOps做融合，加强安全方面的能力等。我认为国内在可观测性领域属于起步阶段，以博睿数据为例，我们今年才真正构建所谓的一体化全栈解决方案。</p><p>&nbsp;</p><p>InfoQ：贵司目前的监控体系大概是如何组建的？</p><p>&nbsp;</p><p>周洪：我们处于典型的起步阶段，基本采用采购加自研的方式，采购是针对一些比较成熟的产品，可以提供标准化的监测，包括流量、耗时、错误等。同时，我们会自己做一些定制化研发，包括从NPM拿数据，从支持拿数据，自己再做串联。这种方式的弊端可能是要投入相当一部分人力。当然效果还是比较明显的，在关键业务上，我们已经可以实现所谓的全链路监测。但是还有一些相对非核心的业务，边缘化的业务，由于企业自身的自研能力再加上资源投入的不足，可能还有进一步的改善空间。</p><p>&nbsp;</p><p>InfoQ：如何快速低成本地构建业务系统的可观测性？</p><p>&nbsp;</p><p>孟曦东：构建一个所谓的可观测性系统有三个要素，一是要有数据；二是背后有一个强大的异构能力的数据引擎；三是需要有高效的查询。最直接经济的方案是看现在的情况是什么样的，哪些需要采购商业化的产品，哪些选择开源项目或者自研，最终对整体进行拼凑，这种方式会高效一些。</p><p>&nbsp;</p><p>InfoQ：能否聊一下目前建设可观测体系通常的路径，比如说什么类型，或者什么规模的企业？</p><p>&nbsp;</p><p>孟曦东：大体分为三类，第一类是自研的，比如头部的互联网公司，自己的研发实力或者研发资源非常多，在公司的发展过程中沉淀了很多有价值的东西；第二类是基于开源做二次构建，比如腰部的公司，打磨出一个可能适合自己或者组织规模的模型，或许APM就可以，不一定是可观测的解决方案；第三类是全部采买三方软件，通过这种方式构建可观测的能力平台。</p><p>&nbsp;</p><p>InfoQ：有什么流程体系去评估是否应通过外采的方式？</p><p>&nbsp;</p><p>周洪：我们有三大衡量标准。一是市场的标准化程度是否足够高，监控本身的效率及系统稳定性；二是全链路监控而非单点监控，是否具备全业务场景的组合能力，是否可以配置化的形式完成组合业务监控；三是是否具备一些更高级的功能，比如业务异常检测、报警规则、自动发现等措施的智能化程度。</p><p>&nbsp;</p><p>InfoQ：目前市场上提供这种可观测的商用产品是不是也不多？</p><p>&nbsp;</p><p>孟曦东：国外的产品不少，因为今年Gartner的APM领域调研报告也增加了可观测性象限，其中列出了一些新型公司。谈到可观测性需要解决的核心问题，也就是数据来源、对数据的理解以及分析利用，国内市场能完整覆盖的方案少之又少，国外在该领域的纯商业化公司更多一些。</p><p>&nbsp;</p><p>InfoQ：大家比较熟知的项目SkyWalking是否适合微服务的架构？</p><p>&nbsp;</p><p>孟曦东：SkyWalking本身应该定义在APM领域更合适。如果是微服务，对探针端的能力是有要求的，据我们现在看到的，SkyWalking还没有真正做到类似商业公司的探针技术，还做不到全智能的基于K8s的直接部署，动态探针以及自动命名。</p><p>&nbsp;</p><p>InfoQ：可观测性技术在解决数据孤岛方面的作用是什么？</p><p>&nbsp;</p><p>孟曦东：大多数用户的监控系统还是比较多的，可能有几套到十几套不等，因为监控系统也有可能是由于不同的组织内部不同的部门构建的，这样就势必会造成一个问题，因为没有从上层做统筹安排，把这些系统真正有机地组成在一起，供所有业务方去真正消费，孤岛问题就比较严重。我们希望能把数据从相互割裂的体系里面抽取出来，做一个统一的描述的模型，然后供不同的业务方去消费。不管是报警场景，还是运维场景，都可以落地到实际的业务场景里面，这样才能真正拉通。我们有一个很重要的特性就是三方数据的开放性或者兼容性，可以把现有的标准集成到一个平台里面，做统一的标准化，统一的模型建设，统一的落盘，然后再抛掉上层做不同场景的消费能力的支持。</p><p>&nbsp;</p><p>InfoQ：AI在监控领域的作用？</p><p>&nbsp;</p><p>孟曦东：AI赋能到监控领域分为几大方面的作用：第一也是最重要的是根因分析的能力，基础是建立一体化的数据平台；第二是希望可以做自动化的框架，不管是第三方的还是商业化的，通过我们的判断触发一些信息让业务做更有价值的动作，让人力可以得到释放。</p><p>&nbsp;</p><p>InfoQ：如何看待国内可观测厂商SaaS发展的一个前景？</p><p>&nbsp;</p><p>孟曦东：很多人都提出国内的SaaS发展与北美差异较大，我个人认为有几个要素：一是国内的市场环境或者技术栈还未到一定程度，北美也是从基础监控、做日志、做APM慢慢累积到现在这个程度的，美国云计算的发展领先中国五六年的时间，所以北美很多业务应用更习惯于放在几大云上；第二，国内存在一些行业政策的监管要求，比如金融领域可能有一些数据方面的安全要求，这也就限制了公有云标准化SaaS能力的交付；第三，产品能力，这个问题不该回避，国内的可观测能力确实还在起步阶段，在整个能力构建图谱上还有差距，如果产品没有打磨好或者没有特别好的能力价值输出，就会影响客户的买单意愿。</p><p>&nbsp;</p><p>InfoQ：OpenTelemetry&nbsp;项目目前在可观测领域比较受欢迎，这是为什么？</p><p>&nbsp;</p><p>孟曦东：首先，OpenTelemetry&nbsp;将原来部分定义的标准真正体系化了。我们很早就有了OpenTracing&nbsp;，但那只是定义了追踪数据的标准格式。任何企业或组织的技术人员，都希望能把某些能力标准化，这样不管是兼容第三方，还是自我迭代都会有一致性或者维护成本方面的好处。其次，该项目提供了非常丰富的SDK和API能力，可以让开发者和企业快速使用。最后，该项目基于CNCF基金会，其中有很多优秀的人物制订了标准。</p><p>&nbsp;</p><p>InfoQ：在生产环境当中，如何选出靠谱的工具去解决可观测性的问题？</p><p>&nbsp;</p><p>孟曦东：在生产中，环境是多样的，我们首先要找到能与当前业务发展情况较好匹配的工具，毕竟每一款工具或者平台都不是万能的，企业会有很多个性化的要求。对于企业级服务，是不是真的有一些标准或者制度可以约束出来，提供给IT人员做问题定位。在整个工作流里面，QA测试完以后是否能覆盖到所有场景。我们认为，对任何企业或者IT组织来讲，APM工具都是必备的，因为可以把不同角色的人用同一种话术连接在一起。我们做运维、研发，或者业务Owner，需要一个平台把这些标准融合在一起，避免大家产生不必要的纠纷。在APM之外，用户肯定还会再构建更完整的能力平台，因为不能只看到内部，还要看到除了数据中心以外的人的反应。因为这部分可能还会需要依托互联网，依托前端业务应用场景定位可能产生的问题，我认为这是一个有机的组合，根据不同的阶段以及人群使用场景构建出一套自己的体系。</p><p>&nbsp;</p><p>InfoQ：对于同样想构建可观测能力的企业有没有什么比较好的建议？</p><p>&nbsp;</p><p>周洪：第一，无论是监测系统还是业务系统，我们关注的是系统本身的稳定性，监测系统的目的是监测本身的应用系统，通过监测发现应用系统的问题，这对我们来讲至关重要，否则一旦出现生产问题，不知道是怀疑监测系统出了问题，还是怀疑业务系统出了问题，这对甲方来说会带来灾难性的后果。</p><p>&nbsp;</p><p>第二，希望能做到更加体系化甚至全家桶方案，作为应用性的企业，我们还是希望把更多的精力放到业务上，提高业务实战水平，通过解藕的方式把监测体系搭建起来，如果本身对应用系统的入侵很大，甚至说影响到业务系统的信赖，就有点得不偿失了。</p><p>&nbsp;</p><p>InfoQ：博睿数据前段时间也在可观测这部分做了一些事情，发布了一体化智能可观测平台ONE，我们怎么理解这里面的“一体化和智能可观测”？</p><p>&nbsp;</p><p>孟曦东：一体化，我们认为就是要全面，数据能力要能覆盖到整个系统的云管边端的全数据链条。第一步是用三方能力接入或者博睿数据提供自己的数据采集能力把它构建起来。第二步体系化或者标准化的过程，真实构建一个立体的组织模型，否则会导致治理或者定义指标能力时出现混乱。第三步，我们认为一体化也是为AI提供一个底座，我们认为未来AI的价值不可或缺，在主动巡检、过程中的异常监测以及后面的根因分析，AI技术在其中发挥了很大的价值。</p><p>&nbsp;</p><p>InfoQ：国内目前可观测市场的未来发展技术方向是什么？博睿数据后续有什么规划？</p><p>&nbsp;</p><p>孟曦东：如果我们认为IT运维是为了业务做服务或者做支撑，不是成本中心，IT本身就会离业务越来越近，这肯定是一个必不可少的发展路径。反过来想，希望IT输出的价值可能也会发生改变，所以我们认为可观测性本身的核心定义就是Google谈的定位问题。如果业务是敏捷的，某个时间点的弹性或者高可靠无法代表全局。随着业务规模的逐渐膨胀，可观测性需要真正把冲突从根上解决，因为最终还是要定位问题，通过定位到的问题做好事前的风险防范、事中的问题排障以及事后的反思。我认为可观测性肯定是未来，不管是由于云计算还是其他技术的发展。</p><p>&nbsp;</p><p>博睿数据今年希望先把一体化做扎实，再在其上构建其他的能力模块。现在因为测试左移越来越流行，我们准备将安全与DevOps结合在一起，同时在知识库和其他一些ITSM工具的整合上面下功夫，希望能帮助到客户做成一个有机的定位平台。</p><p>&nbsp;</p><p>InfoQ：贵司后期在可观测领域会做哪些层面的事情？</p><p>&nbsp;</p><p>周洪：因为我们是应用方，对我们而言，监测本身不是我们的目的，我们的目的是通过监测间接提升整个服务质量和服务水平。我觉得我也代表广大用户给博睿数据等厂商在千亿级别的发展道路上提一些需求：一是希望把监测做得更加精细化；二是注重场景化诉求，我们已经建立了几千个黄金指标、业务指标，如何快速通过编排或者商业结合准确反应到真正的业务监测链路上，而不需要每次根据业务做一些定制化的开发；三是再进一步做到智能化。</p><p>&nbsp;</p><p>讲师介绍：</p><p>&nbsp;</p><p>孟曦东，博睿数据创始人兼CTO。1998年8月至2000年3月，任中国航空第303研究所软件工程师；2000年3月至2008年1月，任北京千龙新闻网络传播有限责任公司技术总监；2008年2月至2016年2月，任博睿数据首席技术官；自2016年2月至今，任博睿数据董事、副总经理。</p><p>&nbsp;</p><p>周洪，某头部证劵公司SVP</p><p>&nbsp;</p><p>&nbsp;</p>",
    "publish_time": "2022-07-19 08:12:35",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "金融场景下，分布式数据库如何精准选型、快速落地？",
    "url": "https://www.infoq.cn/article/WJxYG0oi5GvyioGeKmpU",
    "summary": "<p>随着万物互联的到来，数据的应用场景呈现多元化趋势。其中，金融行业作为国民经济的命脉和枢纽，对底层数据库的能力要求也在提高。具有高性能、可扩展、高可用等特性的分布式数据库正在成为金融行业数字化转型的重要支撑。</p><p></p><p>分布式数据库在金融场景落地中，亟需解决金融业务面临的数据规模增长、数据结构多样化等难点。作为金融企业或金融行业从业者，如何在不同的应用场景下，做好分布式数据库的选型和落地？</p><p></p><p>7 月 26 日 19:00-21:30，我们邀请了 4 位嘉宾，带来 4 场精彩的线上主题分享，解答大家关于金融行业分布式数据库选型、落地实践等实际问题。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ac/acb2604fdf811a942530e4c565a59468.jpeg\" /></p><p></p><h3>议题介绍</h3><p></p><p></p><h5>19:00-19:35《金融业数据库选型之路》</h5><p></p><p>分享嘉宾：韩锋</p><p>议题简介：分布式数据库能够满足金融行业对数据基础设施的高要求，应对高性能、大数据量等多种业务场景。随着近些年来分布式数据库的成熟，金融行业中已有成功案例投入生产系统使用。本次议题聚焦于数据库选型，分享实战中积累的金融行业数据库选型的思考及经验。</p><p></p><h5>19:35-20:10《国产金融级分布式数据库在金融核心场景的探索实践》</h5><p></p><p>分享嘉宾：贾瓅园</p><p>议题简介：从金融级场景到传统金融核心系统场景，在云化的技术浪潮下，国产分布式数据库得以应用在对数据库最高要求的金融行业实现应用。本次分享，将围绕“国产金融级分布式数据库在金融核心场景的探索实践”，与行业探讨当中的经验方案，并展望未来前沿实践方向。</p><p></p><h5>20:10-20:45《金融应用对接分布式数据库》</h5><p></p><p>分享嘉宾：孙亮</p><p>议题简介：金融系统在使用分布式数据库时，可能会遇到哪些问题？会面临哪些改造？会对数据库有哪些要求？本议题将基于实施经验，进行一次探讨与分享。</p><p></p><h5>20:45-21:20《分布式数据库在金融场景下的实战》</h5><p></p><p>分享嘉宾：南云鹏</p><p>议题简介：本次分享将从银行业务场景出发，探讨易用性、可迁移性等要求下，数据库选型的依据及应用实战。</p><p></p><h3>预约报名</h3><p></p><p></p><p>本次公开课，除嘉宾分享外，直播间的小伙伴们还可以通过评论区就分享主题向嘉宾提问互动，现在扫码，即可预约直播！</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/36/36095c356338ff7177b6e271698740b3.jpeg\" /></p><p></p><p></p>",
    "publish_time": "2022-07-19 08:30:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "亚马逊推出基于机器学习的代码助手CodeWhisperer",
    "url": "https://www.infoq.cn/article/8DIQfw2oIiF7qV8ogpI2",
    "summary": "<p>最近，亚马逊云科技推出了基于机器学习的编码助手<a href=\"http://aws.amazon.com/codewhisperer/\">CodeWhisperer</a>\"，它基于开发者使用自然语言编写的注释和集成开发环境（IDE）中的代码提供代码建议。机器学习驱动的服务提高了开发者的生产力。</p><p>&nbsp;</p><p>CodeWhisperer基于各种上下文线索提供建议，包括光标在源代码中的位置、位于光标前面的代码、注释，以及来自同一项目中其他文件的代码。开发者可以完全照搬这些建议，也可以根据需要进行改进和修改。CodeWhisperer使用来自论坛、亚马逊内部代码库、开源代码库和API文档的数十亿行代码进行机器学习训练。</p><p>&nbsp;</p><p>根据亚马逊的说法，开发者可以使用CodeWhisperer来加速开发过程，只需要在IDE中的代码中添加一条注释。编程语言、框架、软件库和云服务必须保持最新。有了CodeWhisperer，开发者可以通过自动代码推荐来加速前端和后端的开发，节省用于构建和训练ML模型的时间和精力，通过对亚马逊云科技服务（包括AWS EC2、AWS Lambda和AWS S3）API的代码推荐来加快开发过程，并减轻编写重复的单元测试代码的负担。</p><p>&nbsp;</p><p>CodeWhisperer还非常重视安全问题，它提供了Python和Java代码扫描，帮助程序员找到他们代码中的漏洞。此外，它还提供了一个引用跟踪器，可以知道代码推荐是否与一组特定的训练数据相似。开发者可以很快找到代码示例，并选择是否在项目中使用它们。</p><p>&nbsp;</p><p>亚马逊表示，推出CodeWhisperer并不是为了提供Copilot的替代方案。亚马逊早在几年前就推出了CodeGuru和DevOpsGuru等服务。</p><p>&nbsp;</p><p>目前，CodeWhisperer兼容Python、Java和JavaScript，支持各种IDE，包括JetBrains、Visual Studio Code、AWS Cloud9和AWS Lambda控制台。</p><p>&nbsp;</p><p>想要体验亚马逊这款最新的代码完成工具的开发者可以提交请求表单进行<a href=\"https://pages.awscloud.com/codewhisperer-sign-up-form.html\">注册</a>\"，并进入等待队列。开发者可以安装<a href=\"https://aws.amazon.com/tools/\">AWS IDE工具包</a>\"，激活CodeWhisperer功能，并在收到预览访问代码后开始使用该工具。</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2022/07/aws-codewhisperer-coding/\">Amazon Unveils ML-Powered Coding Assistant CodeWhisperer</a>\"</p>",
    "publish_time": "2022-07-19 09:01:13",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "使用GraphQL和Ballerina操作多个数据源",
    "url": "https://www.infoq.cn/article/kBD5PhPV2eJQdGIYshxH",
    "summary": "<p>在当今的数字转型时代，应用程序和Web服务之间的相互对话是不可避免的，我们需要通过API来实现这些应用程序之间的通信。各种协议和规范定义了消息通过网络传递的语义和语法，最终形成了一种API架构。</p><p>&nbsp;</p><p>在本文中，我们将探讨如何使用GraphQL和Ballerina将MySQL数据库中的数据作为API公开出来。GraphQL是一种抽象了底层数据源的规范，借助GraphQL，开发人员能够灵活地使用他们喜欢的编程语言处理数据源，如数据库或REST API。</p><p>&nbsp;</p><p></p><h2>GraphQL是什么</h2><p></p><p>&nbsp;</p><p>GraphQL是一种应用层服务器端技术，由Facebook于2012年开始开发，并于2015年公开发布，用于优化REST API调用。GraphQL既可以被视为一种API查询语言，也可以被视为一种服务器端运行时，用于执行由用户定义的查询。</p><p>&nbsp;</p><p>GraphQL的操作类型如下：</p><p>&nbsp;</p><p>查询（读取）；突变（写入/更新）；订阅（连续读取）。</p><p>&nbsp;</p><p>这些操作都只是一个字符串，需要根据GraphQL查询语言规范进行构造。GraphQL对网络层或消息体的格式没有特别要求，不过最常用的一般是HTTP和JSON。</p><p>&nbsp;</p><p></p><h2>GraphQL是更好的REST</h2><p></p><p>&nbsp;</p><p>在过去的十年中，REST已经成为一种流行的API设计架构。REST和GraphQL可以被认为是解决同一问题（通过Web服务访问数据）的两种不同的方法。但是，随着客户端对API的访问需求发生了快速变化，REST API已经变得太不灵活了。推出GraphQL的目的是为了支持更灵活、更高效的数据访问行为。下面列出了选择GraphQL而不是REST的一些关键原因。</p><p>&nbsp;</p><p></p><h4>避免过度获取或获取不足</h4><p></p><p>&nbsp;</p><p>过度获取意味着获取的信息超过了你的需要。这在使用REST时非常常见，因为它总是从给定的端点返回固定的数据集，而客户端实际上具有特定的数据需求。获取不足意味着特定端点没有提供足够的所需信息，客户端不得不发出额外的请求来获取所需的数据。但在使用GraphQL时，你可以使用查询语法定义所需信息的结构，然后通过单个API请求就可以获取所需的信息。</p><p>&nbsp;</p><p></p><h4>客户端可以快速进行产品迭代</h4><p></p><p>&nbsp;</p><p>通常，REST API需要根据客户端应用程序需要的视图来提供端点。如果客户端应用程序发生了变化，它需要的数据可能比以前多也可能比以前少。因此，为了满足新的需求，需要调整REST API。如果使用的是GraphQL，由于客户端可以指定准确的数据需求，所以只需要在客户端做出更改，服务器端不需要做任何额外的工作。</p><p>&nbsp;</p><p></p><h4>支持基于模式和类型系统的开发方式</h4><p></p><p>&nbsp;</p><p>GraphQL有一个强大的类型系统，可用于定义通过API公开出来的数据，所有这些类型都可以使用GraphQL模式定义语言（SDL）写到模式中。模式成了客户端和服务器端之间的契约，不同的团队可以基于定义好的模式分别处理前端和后端的代码逻辑。</p><p>&nbsp;</p><p></p><h2>为什么选择Ballerina</h2><p></p><p>&nbsp;</p><p>你可以使用任何流行的编程语言来构建GraphQL应用程序，如Go、Java、Node.js等。我们选择<a href=\"https://ballerina.io/\">Ballerina</a>\"是因为它提供了很多附加价值：</p><p>&nbsp;</p><p>Ballerina是一种开源的云编程语言，它让网络服务的调用、组合和创建变得更加容易。它是一种现代的、工业级的、用于集成和开发网络服务和应用程序的通用语言。由于具有网络感知类型系统、对网络服务和资源的一流支持、对各种技术（包括GraphQL）的内置支持以及序列图语法等特性，使得开发者体验更加直观。</p><p>&nbsp;</p><p>有两种设计GraphQL端点的方法：</p><p>&nbsp;</p><p>模式优先方法：需要使用GraphQL模式来创建GraphQL服务。代码优先方法：模式是不必需的，可以直接使用代码编写端点，然后生成模式。</p><p>&nbsp;</p><p>Ballerina使用代码优先的方法来设计GraphQL端点。Ballerina的GraphQL实现使用HTTP作为底层协议。在下一节中，我们将探讨这些特性如何帮助你开发GraphQL应用程序。</p><p>&nbsp;</p><p></p><h2>一个书店示例</h2><p></p><p>&nbsp;</p><p>GraphQL服务器的数据源可以是任何东西，如数据库、另一个API或提供数据的服务等。此外，GraphQL可以与任意的数据源组合发生交互。这个示例演示了如何使用Ballerina实现GraphQL服务器，将MySQL数据库中的数据以及通过另一个API调用获取的数据公开出来。</p><p>&nbsp;</p><p>MySQL数据库中保存了与书店相关的数据，包括书籍和作者的信息。与书籍相关的其他信息通过<a href=\"https://developers.google.com/books\">Google Books API</a>\"获得。书店的客户端可以通过GraphQL API完成以下这些操作：</p><p>&nbsp;</p><p>获取所有书籍的详细信息；通过提供书名获取书籍的详细信息；向数据库中添加新书。</p><p>&nbsp;</p><p>上述操作的信息来源如下：</p><p>&nbsp;</p><p>书名、出版年份、ISBN、作者姓名、作者国籍——从数据库获取；平均评分和评分计数——通过ISBN查询Google Books API。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/dc/dc041df2882d9d69753e3a26e5e68f50.png\" /></p><p></p><p>这个示例使用MySQL数据库和Google Books API作为数据源</p><p>&nbsp;</p><p>这个示例的所有<a href=\"https://github.com/anupama-pathirage/ballerina-scenarios/tree/main/ballerina-graphql-with-multiple-datasources\">源代码</a>\"都可以在Github上找到。</p><p>&nbsp;</p><p></p><h4>用示例数据填充数据库</h4><p></p><p>&nbsp;</p><p>首先用示例数据填充MySQL数据库。Bookstore数据库有两张表，“Book”和“Author”，包含以下这些字段。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/da/da55d28786b70f170ef2f3f203d143a3.png\" /></p><p></p><p>Bookstore的数据库模式</p><p>&nbsp;</p><p>可以在data.sql文件中找到创建数据库、表和填充数据的SQL语句。如果将这些语句保存到一个文件中，请在数据库中执行以下命令。</p><p>&nbsp;</p><p><code lang=\"javascript\">mysql -uroot -p &lt; /path/to/file/data.sql</code></p><p>&nbsp;</p><p></p><h2>使用Ballerina实现GraphQL服务</h2><p></p><p>&nbsp;</p><p></p><h4>创建Ballerina项目</h4><p></p><p>&nbsp;</p><p>通过执行下面的命令创建一个Ballerina项目。有关Ballerina项目结构的更多细节，请参考“<a href=\"https://ballerina.io/learn/organize-ballerina-code/\">Organize Ballerina code</a>\"”。</p><p>&nbsp;</p><p><code lang=\"javascript\">bal new bookstore\nCreated new package 'bookstore' at bookstore.</code></p><p>&nbsp;</p><p><code lang=\"javascript\">└── bookstore\n├── Ballerina.toml\n└── main.bal</code></p><p>&nbsp;</p><p>1个目录，2个文件。</p><p>&nbsp;</p><p>因为这是一个服务，不需要main.bal文件，所以可以把它删除。</p><p>&nbsp;</p><p></p><h4>创建记录类型</h4><p></p><p>&nbsp;</p><p>添加一个叫作“<a href=\"https://github.com/anupama-pathirage/ballerina-scenarios/blob/main/ballerina-graphql-with-multiple-datasources/bookstore/bookservice.bal\">bookservice.bal</a>\"”的Ballerina文件，用于实现GraphQL服务逻辑。第一步先定义用于表示书籍和作者数据的记录类型。在Ballerina中，记录是特定类型字段的集合。其中有命名的键，并定义了字段的类型。{|和|}分隔符表示这个记录类型只包含所描述的字段。</p><p>&nbsp;</p><p>下面的“BookDetails”记录表示从数据库中获取到的书籍的详细信息。</p><p>&nbsp;</p><p><code lang=\"typescript\">type BookDetails record {|\n   string title;\n   int published_year;\n   string isbn;\n   string name;\n   string country;\n|};</code></p><p>&nbsp;</p><p>接下来创建用于表示从Google Books API获取到的数据的记录类型。在创建所需的记录之前，需要分析一下根据指定ISBN从Google Books API获取的的JSON响应消息的格式。它返回一个JSON对象，其中包含了一个“items”的数组。它还有另一个叫作“volumeInfo”的对象，这个对象包含了与书籍评论相关的信息，字段名分别为“averageRating”和“ratingsCount”。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/80/80a3a4cc5e7011747bd3e3338d2b7a25.png\" /></p><p></p><p>&nbsp;</p><p>在Ballerina中有两种处理JSON的方式。你可以直接使用内置的“<a href=\"https://ballerina.io/learn/by-example/json-type.html\">json</a>\"”类型，或者将JSON转换成用户定义的“anydata”子类型。下面的示例使用了第二种方法，直接将响应消息映射成记录，因为Ballerina的HTTP客户端数据绑定为此提供了很好的支持。因为你只对与书籍评级相关的字段感兴趣，所以可以只用这些字段来创建记录。另外，你用不到字段名为“items”的中间对象，所以这里可以使用匿名记录，因为你不需要通过名称引用这个记录类型。</p><p>&nbsp;</p><p><code lang=\"typescript\">type BookReviews record {\n   record {\n       VolumeInfo volumeInfo;\n   }[] items;//通过内联的方式定义匿名记录类型\n};\n \ntype VolumeInfo record {\n   int averageRating?;\n   int ratingsCount?;\n};</code></p><p>&nbsp;</p><p></p><h4>创建服务对象</h4><p></p><p>&nbsp;</p><p>Ballerina记录类型和服务类型都可以作为GraphQL的对象类型。记录的字段被映射到GraphQL对象的字段，记录字段的类型被映射到GraphQL对应字段的类型。</p><p>&nbsp;</p><p>服务类型中的每一个资源方法表示GraphQL对象的一个字段，资源方法可以有输入参数，这些输入参数被映射到相应字段的参数。</p><p>&nbsp;</p><p>使用记录类型作为对象有局限性，因此，在这个示例中，我们使用服务类型来表示“Book”对象。</p><p>&nbsp;</p><p>在这个服务中，“BookDetails”是一个final的只读字段，在初始化后不能被赋值。</p><p>&nbsp;</p><p>Ballerina GraphQL服务中的资源可以有层级资源路径。如果出现了层级路径，例如下面的author/…，就会为每一个同名的中间路径段创建一个对象类型。路径段下的每一个子路径都将作为所创建类型的一个字段。</p><p>&nbsp;</p><p><code lang=\"typescript\">service class Book {\n   private final readonly &amp; BookDetails bookDetails;\n \n   function init(BookDetails bookDetails) {\n       self.bookDetails = bookDetails.cloneReadOnly();\n   }\n   resource function get title() returns string {\n       return self.bookDetails.title;\n   }\n   resource function get published_year() returns int {\n       return self.bookDetails.published_year;\n   }\n   resource function get isbn() returns string {\n       return self.bookDetails.isbn;\n   }\n   resource function get author/name() returns string {\n       return self.bookDetails.name;\n   }\n   resource function get author/country() returns string {\n       return self.bookDetails.country;\n   }\n   resource function get reviews() returns VolumeInfo|error {\n       string isbn = self.bookDetails.isbn;\n       return getBookReviews(isbn);\n   }\n}</code></p><p>&nbsp;</p><p></p><h4>创建GraphQL服务</h4><p></p><p>&nbsp;</p><p>现在开始编写GraphQL服务。Ballerina对基于网络的交互提供了一流的支持，因此编写服务就变得很简单。服务对象支持通过远程方法和资源方法进行网络交互。监听器提供了网络和服务对象之间的接口。</p><p>&nbsp;</p><p>首先，你需要导入ballerina/graphql模块。然后，你通过指定要监听的端口来创建GraphQL监听器对象，并将其附加到服务上。</p><p>&nbsp;</p><p>资源方法以REST的方式公开服务，而远程方法则以过程方式公开服务。Ballerina服务可以有资源方法和远程方法，资源方法用于表示GraphQL查询类型，远程方法用于表示可变类型。</p><p>&nbsp;</p><p>下一步是加入远程函数或资源函数。allBooks和bookByName是通过GraphQL查询获取书籍数据的资源函数，因此，它们返回“Book”数组。要将新书添加到数据库中，可以调用“addBook”远程方法。它将书籍的信息作为输入参数，并返回一个int值，这个值表示已插入的书籍的索引，如果发生错误就返回-1。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/3f/3f69a0973501675a3d2f9e0064322006.png\" /></p><p></p><p>Ballerina GraphQL服务</p><p>&nbsp;</p><p>下一步是实现数据访问逻辑，也就是实现远程方法和资源方法。</p><p>&nbsp;</p><p>完整的代码在<a href=\"https://github.com/anupama-pathirage/ballerina-scenarios/blob/main/ballerina-graphql-with-multiple-datasources/bookstore/bookservice.bal\">bookservice.bal</a>\"中。服务的代码如下所示。与DB交互和API调用相关的getBooks、addBookData和getBookReviews函数的更多细节请参阅下一小节。</p><p>&nbsp;</p><p><code lang=\"typescript\">service /bookstore on new graphql:Listener(4000) {\n   resource function get bookByName(string title) returns Book[] {\n       return getBooks(title);\n   }\n   resource function get allBooks() returns Book[] {\n       return getBooks(());\n   }\n   remote function addBook(string authorName, string authorCountry, string title,\n                                               int published_year, string isbn) returns int {\n       int|error ret = addBookData(authorName, authorCountry, title, published_year, isbn);\n       return ret is error ? -1 : ret;\n   }\n}</code></p><p>&nbsp;</p><p></p><h2>实现数据访问逻辑</h2><p></p><p>&nbsp;</p><p>由于本例使用MySQL数据库作为后端数据存储，因此需要提供查询数据库和添加新记录的功能。Ballerina为DB交互提供了一流的支持。</p><p>&nbsp;</p><p>现在，在项目中添加另一个名为<a href=\"https://github.com/anupama-pathirage/ballerina-scenarios/blob/main/ballerina-graphql-with-multiple-datasources/bookstore/bookdatastore.bal\">bookdatastore.bal</a>\"的文件，用于DB交互和API调用相关的实现。首先，你需要创建一个MySQL数据库客户端，并导入<a href=\"https://central.ballerina.io/ballerinax/mysql\">ballerinax/mysql</a>\"、<a href=\"https://central.ballerina.io/ballerina/sql\">ballerina/sql</a>\"和<a href=\"https://central.ballerina.io/ballerinax/mysql.driver\">ballerinax/mysql.driver</a>\"模块。</p><p>&nbsp;</p><p>你可以在初始化客户端时提供配置信息，不过本例使用了<a href=\"https://ballerina.io/learn/configure-ballerina-programs/configure-a-sample-ballerina-service/\">Ballerina的配置功能</a>\"来提供配置信息。用户可以根据不同的环境通过外部输入来改变系统行为，而且敏感数据（如密码）不会通过代码暴露出来。在定义了配置数据库所需的<a href=\"https://github.com/anupama-pathirage/ballerina-scenarios/blob/main/ballerina-graphql-with-multiple-datasources/bookstore/bookdatastore.bal#L6:L14\">可配置记录</a>\"之后，就可以按照如下方式创建DB客户端。</p><p><code lang=\"typescript\">final mysql:Client dbClient = check new (database.host, database.username, database.password, database.name, database.port);</code></p><p>&nbsp;</p><p>然后可以通过项目中的<a href=\"https://github.com/anupama-pathirage/ballerina-scenarios/blob/main/ballerina-graphql-with-multiple-datasources/bookstore/Config.toml\">Config.toml</a>\"文件来提供配置信息。</p><p>&nbsp;</p><p>现在添加一个HTTP客户端，用于从Google Books API获取所需的数据。你需要导入<a href=\"https://central.ballerina.io/ballerina/http\">ballerina/http</a>\"模块，并按照如下方式创建客户端。</p><p><code lang=\"typescript\">final http:Client bookEp = check new (\"https://www.googleapis.com/books/v1\");</code></p><p>&nbsp;</p><p>这样，你就完成了这个场景的实现。完整的访问数据库的代码可以在<a href=\"https://github.com/anupama-pathirage/ballerina-scenarios/blob/main/ballerina-graphql-with-multiple-datasources/bookstore/bookdatastore.bal\">bookdatastore.bal</a>\"中找到。</p><p>&nbsp;</p><p></p><h2>使用生成的图表</h2><p></p><p>&nbsp;</p><p>因为存在多个实体之间的交互，所以集成用例就变得很复杂。因此，理解整个流程和顺序对于维护、改进和解释场景来说至关重要。Ballerina内置了图表功能，可以基于已编写的代码生成完整的序列图。图表可以作为代码的文档，相比直接阅读源代码，这种方式更易于理解程序。你可以使用<a href=\"https://marketplace.visualstudio.com/items?itemName=WSO2.Ballerina\">Ballerina VSCode插件</a>\"查看和编辑这些图表。</p><p>&nbsp;</p><p>下面是getBooks方法对应的图表。其他方法也有类似的图标，你可以使用VSCode插件查看和编辑它们。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d6/d6330b4bec9bd4694a3e29090592ae60.png\" /></p><p></p><p>基于源代码生成的Ballerina图表</p><p>&nbsp;</p><p>运行Bookstore服务</p><p>&nbsp;</p><p>现在，让我们运行并测试GraphQL服务。要运行这个服务，需要在bookstore项目的根目录下执行下面的命令：</p><p><code lang=\"typescript\">bal run</code></p><p>&nbsp;</p><p>如果你使用GraphQL客户端工具连接到这个服务，它将显示下面这个的模式：</p><p>&nbsp;</p><p><code lang=\"typescript\">type Query {\n allBooks: [Book!]!\n bookByName(title: String!): [Book!]!\n}\n \ntype author {\n country: String!\n name: String!\n}\n \ntype VolumeInfo {\n averageRating: Int\n ratingsCount: Int\n}\n \ntype Book {\n reviews: VolumeInfo!\n published_year: Int!\n author: author\n isbn: String!\n title: String!\n}\n \ntype Mutation {\n addBook(\n   authorName: String!\n   authorCountry: String!\n   title: String!\n   published_year: Int!\n   isbn: String!\n ): Int!\n}</code></p><p>&nbsp;</p><p></p><h2>测试Bookstore服务</h2><p></p><p>&nbsp;</p><p>要调用GraphQL服务器，需要使用客户端。你可以在命令行中使用curl向端点发送HTTP POST请求，并将GraphQL查询作为JSON传递给它。另外，你也可以使用<a href=\"https://ballerina.io/learn/graphql-client-tool/\">Ballerina GraphQL客户端工具</a>\"为给定的GraphQL模式（SDL）和GraphQL查询生成Ballerina客户端。如果你喜欢使用图形用户界面，可以使用<a href=\"https://github.com/graphql/graphiql\">GraphiQL</a>\"或<a href=\"https://altair.sirmuel.design/#download\">Altair</a>\"等。</p><p>&nbsp;</p><p>所有请求的端点都是<a href=\"http://localhost:4000/bookstore\">http://localhost:4000/bookstore</a>\"。</p><p>&nbsp;</p><p></p><h4>示例请求1：获取所有书籍的书名</h4><p></p><p>&nbsp;</p><p>GraphQL查询：</p><p><code lang=\"typescript\">{allBooks {title}}</code></p><p>&nbsp;</p><p>响应：</p><p><code lang=\"typescript\">{\n \"data\": {\n   \"allBooks\": [\n     { \"title\": \"Pride and Prejudice\" },\n     { \"title\": \"Sense and Sensibility\" },\n     { \"title\": \"Emma\" },\n     { \"title\": \"War and Peace\" },\n     { \"title\": \"Anna Karenina\" }\n   ]\n }\n}</code></p><p>&nbsp;</p><p>使用curl命令发送相同的请求：</p><p><code lang=\"typescript\">curl -X POST -H \"Content-type: application/json\" -d '{ \"query\": \"{allBooks {title}}\" }' 'http://localhost:4000/bookstore'</code></p><p>&nbsp;</p><p></p><h4>示例请求2：获取所有书籍更多的信息</h4><p></p><p>&nbsp;</p><p>这就是GraphQL真正强大的地方。用户可以按照自己需要的格式请求所需的信息，无需指定不同的端点，只需修改查询即可。你可以看到这里的一些评级是“null”，因为Google Books API调用返回的一些JSON响应没有包含这些信息。</p><p>&nbsp;</p><p>GraphQL查询：</p><p><code lang=\"typescript\">{allBooks {title, author{name}, reviews{ratingsCount, averageRating}}}</code></p><p>&nbsp;</p><p>响应：</p><p><code lang=\"typescript\">{\n \"data\": {\n   \"allBooks\": [\n     {\n       \"title\": \"Pride and Prejudice\",\n       \"author\": {\n         \"name\": \"Jane Austen\"\n       },\n       \"reviews\": {\n         \"ratingsCount\": 1,\n         \"averageRating\": 5\n       }\n     },\n     {\n       \"title\": \"Sense and Sensibility\",\n       \"author\": {\n         \"name\": \"Jane Austen\"\n       },\n       \"reviews\": {\n         \"ratingsCount\": 3,\n         \"averageRating\": 4\n       }\n     },\n     {\n       \"title\": \"Emma\",\n       \"author\": {\n         \"name\": \"Jane Austen\"\n       },\n       \"reviews\": {\n         \"ratingsCount\": null,\n         \"averageRating\": null\n       }\n     },\n     {\n       \"title\": \"War and Peace\",\n       \"author\": {\n         \"name\": \"Leo Tolstoy\"\n       },\n       \"reviews\": {\n         \"ratingsCount\": 5,\n         \"averageRating\": 4\n       }\n     },\n     {\n       \"title\": \"Anna Karenina\",\n       \"author\": {\n         \"name\": \"Leo Tolstoy\"\n       },\n       \"reviews\": {\n         \"ratingsCount\": 1,\n         \"averageRating\": 4\n       }\n     }\n   ]\n }\n}</code></p><p>&nbsp;</p><p>使用curl命令发送相同的请求：</p><p><code lang=\"typescript\">curl -X POST -H \"Content-type: application/json\" -d '{ \"query\": \"{allBooks {title, author{name}, reviews{ratingsCount, averageRating}}}\" }' 'http://localhost:4000/bookstore'</code></p><p>&nbsp;</p><p></p><h4>示例请求3：指定输入参数获取书籍的详细信息</h4><p></p><p>&nbsp;</p><p>GraphQL查询：</p><p><code lang=\"typescript\">{bookByName(title: \"Emma\") {title, published_year}}</code></p><p>&nbsp;</p><p>响应：</p><p><code lang=\"typescript\">{ \"data\": { \"bookByName\": [{ \"title\": \"Emma\", \"published_year\": 1815 }] } }</code></p><p>&nbsp;</p><p>使用curl命令发送相同的请求：</p><p><code lang=\"typescript\">curl -X POST -H \"Content-type: application/json\" -d '{ \"query\": \"{bookByName(title: \\\"Emma\\\") {title, published_year}}\" }' 'http://localhost:4000/bookstore'</code></p><p>&nbsp;</p><p></p><h4>示例请求4：将数据插入数据库</h4><p></p><p>&nbsp;</p><p>GraphQL查询：</p><p><code lang=\"typescript\">mutation {addBook(authorName: \"J. K. Rowling\", authorCountry: \"United Kingdom\", title: \"Harry Potter\", published_year: 2007, isbn: \"9781683836223\")}</code></p><p>&nbsp;</p><p>响应：</p><p><code lang=\"typescript\">{\n \"data\": {\n   \"addBook\": 6\n }\n}</code></p><p>&nbsp;</p><p>使用curl命令发送相同的请求：</p><p><code lang=\"typescript\">curl -X POST -H \"Content-type: application/json\" -d '{ \"query\": \"mutation {addBook(authorName: \\\"J. K. Rowling\\\", authorCountry: \\\"United Kingdom\\\", title: \\\"Harry Potter\\\", published_year: 2007, isbn: \\\"9781683836223\\\")}\" }' 'http://localhost:4000/bookstore'</code></p><p>&nbsp;</p><p></p><h2>总结</h2><p></p><p>&nbsp;</p><p>在现代应用程序开发中，GraphQL可能是比REST更好的选择。Ballerina为网络抽象提供了的一流的支持，可以通过简单而强大的方式开发GraphQL服务。在我们的示例中，我们实现了一个书店的GraphQL应用场景，结合了多个后端数据源，包括MySQL数据库和Google Books API。</p><p>&nbsp;</p><p>你可以访问<a href=\"https://ballerina.io/\">ballerina.io</a>\"来了解更多关于Ballerina的信息。</p><p>&nbsp;</p><p>你可以通过<a href=\"https://github.com/ballerina-platform/ballerina-standard-library/issues?q=is%3Aopen+is%3Aissue+label%3Amodule%2Fgraphql\">检查问题</a>\"来参与Ballerina GraphQL的模块开发。</p><p>&nbsp;</p><p>示例项目的完整源代码可以在<a href=\"https://github.com/anupama-pathirage/ballerina-scenarios/tree/main/ballerina-graphql-with-multiple-datasources\">这里</a>\"找到。</p><p>&nbsp;</p><p></p><h2>更多信息</h2><p></p><p>&nbsp;</p><p>可以参考以下资源了解更多关于Ballerina GraphQL的信息：</p><p>&nbsp;</p><p><a href=\"https://lib.ballerina.io/ballerina/graphql/latest\">Ballerina GraphQL API文档</a>\"</p><p><a href=\"https://github.com/ballerina-platform/module-ballerina-graphql/blob/master/docs/spec/spec.md\">Ballerina GraphQL规范</a>\"</p><p><a href=\"https://github.com/ballerina-platform/module-ballerina-graphql/tree/master/examples\">Ballerina GraphQL示例</a>\"</p><p><a href=\"https://central.ballerina.io/ballerina/graphql\">Ballerina GraphQL模块</a>\"</p><p>&nbsp;</p><p>作者简介：</p><p>&nbsp;</p><p>Anupama Pathirage是WSO2的工程总监、工程经理和Ballerina语言的开发者。她为Ballerina的各个方面（如编译器、运行时、事务、表、数据库客户端和数据处理等）做出了贡献。Anupama拥有软件架构硕士学位和斯里兰卡莫拉图瓦大学计算机科学与工程系一等荣誉学士学位。Anupama在DZone、InfoQ和Medium上发表文章，并定期在国际技术大会上发表演讲。</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/graphql-ballerina/\">Using GraphQL and Ballerina with Multiple Data Sources</a>\"</p>",
    "publish_time": "2022-07-19 09:13:22",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "知乎：如何在大规模集群下使用istio升级微服务架构",
    "url": "https://www.infoq.cn/article/SslDEik5WJa6U5GweKfp",
    "summary": "<p>&nbsp;</p><p></p><blockquote>为进一步加强技术交流，推进云原生生态共建，6月28日下午，首届云原生实践者大会在线上线下同步举办。来自作业帮、知乎、转转、58、同程等多家科技企业的数十名研发人员，以及中国信通院云大所的专家共同参与了此次技术研讨沙龙。&nbsp;研讨会上，知乎核心架构平台开发工程师谢楚瑜讲述了“知乎的istio之旅”，与参会者分享了知乎如何在大规模集群下使用istio升级微服务架构，具体包括如何使istio管理的服务和现存服务之间可以互相通信、知乎的istio迁移都遇到和解决过哪些问题、Service Mesh如何为业务提供了帮助，以及知乎如何在大规模集群中优化性能指标等。&nbsp;以下，是谢楚瑜的分享。</blockquote><p></p><p>&nbsp;</p><p>大家好，我是谢楚瑜，这次主要是和大家分享下知乎是如何进行Service Mesh改造的、在改造期间有遇到了哪些问题，以及随着规模地不断扩大，我们又解决了哪些新的问题。</p><p>&nbsp;</p><p></p><h2>现状</h2><p></p><p>&nbsp;</p><p>先看一下 Service Mesh 在知乎目前的情况。</p><p>&nbsp;</p><p>目前，我们的核心业务以及数百个周边业务都已经完成迁移。在每天的高峰期，Service Mesh中的流量可以达到百万级别的rps。在指标维度也已经达到了百万级别。我们服务治理的各种功能，如压测、鉴权、限流和断路等也通过 Service Mesh 完成了兼容和重构。</p><p>&nbsp;</p><p>然后说下迁移的兼容方案。知乎在早期的时候就已经完成了容器化改造。那时候，我们其实还没有用上K8s，是自己做了一套基于负载均衡以及服务发现的服务通信发现。因此，在迁移Service Mesh时，我们必须首先提供一套方案即可以兼容以前的服务通信，又兼容旧方案的服务治理功能，同时迁移过程对业务无感知，如果有大规模故障还可以快速回滚到旧方案。</p><p>&nbsp;</p><p>为了满足上述需求，我们首先做的就是梳理现有的服务调用流程。</p><p>&nbsp;</p><p>以前，客户端会直接通过注册中心目标服务的负载均衡地址进行访问。但在云原生环境的做法应该是通过coreDNS查询它的一个ServiceIP，通过这个ServiceIP进行服务间通信。如果是在Service Mesh里的话，访问serviceIP 时会直接通过 Envoy 发现一个合适的服务端实例，直接从客户端打到服务端。</p><p>&nbsp;</p><p>考虑到对旧方案的兼容，我们决定对服务发现组件进行改造，增加一个服务发现的代理。如果是上了Mesh的服务访问没上Mesh的服务，那么它其实和以前是一样的，仍然通过旧的负载均衡方案去调用。而对于客户端、服务端都是在Mesh环境下服务调用，这个代理将会返回ServiceIP，这样一来就不需要做SDK层面的修改，可以直接兼容旧的负载均衡方案和新的Service Mesh调用了。这样有一个好处，如果我们需要切换到旧方案，比如紧急回滚的情况，只需要把这个代理上面的配置修改下就可以直接切回过往的一套流量方式。</p><p>&nbsp;</p><p>除此之外，关于鉴权和限流这些功能，我们通过一些Controller实现了一套同步方案，然后通过ServiceMesh的能力实现了兼容。然后关于从零上Mesh其实还有很多改造的点，比如限流。我们上一次IstioCon的分享有比较详细的描述，这次暂时不赘述了。</p><p>&nbsp;</p><p>在迁移期间，我们有遇到过很多的问题。就像我前面提到的，我们当时有一种集中式的代理方案，在切换到Mesh以后，Mesh其实会给每个业务容器实例后加上一个Sidecar，这样相当于说，它的连接方式从以前一种集中式的代理访问，变成一种点对点的模式。</p><p>&nbsp;</p><p>这会直接导致服务端收到并发数发生很明显的变化，很多性能比较敏感的服务也会发生改变。关于这个问题，我们通过一些指标去做连接池的适配，对于延时变化非常敏感的服务，我们会做一些人工处理。</p><p>&nbsp;</p><p>然后是连接管理带来的一些差异。比如我们以前那一套负载均衡方案，会在客户端断开连接以后，仍然保持跟服务端的连接。然而在Istio中，如果客户端连接断开，那么它和服务端连接也就断了，这导致我们的业务会在监控上看到一些不一样的错误，如Golang服务会看到更多的Context Cancel 这类错误。对于这种情况，我们是通过 SDK 对异常的采集做适配来解决。</p><p>&nbsp;</p><p>还有一个比较核心的点。在Istio中，每次读取指标文件都可能在内存里面同时写两份完整的指标配置。当一个实例的指标文件达到上百兆的时候，对Sidecar的性能影响是非常大的。我在后面会具体提到指标这块我们是怎么解决的。</p><p>&nbsp;</p><p></p><h2>业务应用</h2><p></p><p>&nbsp;</p><p>在做好了基础的兼容和适配以后，剩下就是考虑怎么样让业务应用起来。</p><p>&nbsp;</p><p>考虑到Istio对象的复杂度非常高，一上来如果直接看VS、DR，还有Authpolice、Service Entry这些东西的话，很难直接用起来。另外，每一个配置都可能会因为需求的复杂而进行重复配置，比如一个vs的配置里面有时可能会加一个故障注入改一下，然后又加一个重试规则又改一下。</p><p>&nbsp;</p><p>基于这个问题，我们实现了一个类似于Envoyfilter一样的Crd、Istiofilter。通过这个crd，我们可以对Istio应用一种overlay形式配置。这样我们可以通过配置多个Istiofilter 同时管理同一个 vs配置。如果中间某些配置不要了，比如不要流量镜像了，就只需要删掉对应的IstioFilter，随后 vs上面就只会减少这一个mirror的配置，其他配置仍然可以正常使用。目前这一套Istiofilter也是有开源版本的，可以直接在GitHub上找到。</p><p>&nbsp;</p><p>除此之外，我们Mesh的所有能力目前都是直接面向业务研发开放使用的。目前大部分功能都是基于接口这一种粒度进行配置。他们可以通过指标或者自己手动在接口配置界面上配置他们的一些接口定义，在完善接口配置以后就可以在上面使用一些故障注入和限流功能。</p><p>&nbsp;</p><p>考虑到自身业务的特殊性，我们并没有全面使用Istio原生提供的功能。比如，我们自己实现了流量镜像功能，它其实可以支持超过100%这种比例的配置，这样就可以拿线上的流量进行压测，也可以将压力都集中在需要测试的服务端实例上，避免影响其他的客户端应用。</p><p>&nbsp;</p><p>前面提到我们大概有百万级的Rps，同时也已经有10万+的实例运行在上面，这样就会有一些新的问题。比如像Ipvs上如果Service数量太多，一些采集工作会导致它在机器上面软中断时间变长，进而从业务角度观察会有一些网络延迟。最终我们是通过<a href=\"https://gist.github.com/cocotyty/4f5bc48362b9e957c32ced496862aac1\">livepatch</a>\"关闭了特性来解决的这个问题。</p><p>&nbsp;</p><p>然后是做了DNS优化。前面提到，我们当时是用了自己的一套服务发现体系，没有用coreDNS。然后我们在切到Mesh的时候发现，当时的coreDNS 比较难以支撑我们的性能需求。于是我们自己搭建了一套 local Dns，每个K8s节点放一个DNS实例，同时结合这一个Istio的smartdns，减少了由于服务域名没有填写完整而重复查询DNS的次数，这样尽量优化DNS在服务调用中的时间开销。</p><p>&nbsp;</p><p>关于Istio的参数配置，首先由于集群规模较大、服务更新频繁，对于一些服务来说可能配置推送会非常频繁，推送内容也非常比较大，这样的话推送配置非常容易超时。所以，我们根据集群规模调了配置，包括减少了配置推送的量，只针对某个位去推送所需的配置。我们做了一个自动的服务配置范围（sidecar crd）的适配，这样确保每个服务都按需加载配置。</p><p>&nbsp;</p><p>除此之外，我们还使用了Istio 的DiscoverySelector 减少istio采集集群信息的范围。因为我们的集群中除了常规的业务容器外，还有很多永远不会参与服务间通信的容器。但是DiscoverySelector有个问题：它里面的接口可能和我们集群的K8s接口不兼容，Istio 版本如果低于1.13的话，可能会因为panic导致istiod偶发重启。更多细节我们以前也在<a href=\"https://zhuanlan.zhihu.com/p/436796453\">知乎专栏</a>\"上做过很详细的分享。</p><p>&nbsp;</p><p>&nbsp;</p><p>指标方面，前面提到我们指标的维度已经比较大，总维度在百万以上，这对我们的指标系统确实存在一个挑战。我们以前其实只有一个victoriametrics集群，随着指标规模扩大，我们将指标集群分成了两个：一个是短期存储，只存大概一个星期左右的全量指标；另一个是长期存储，它会把短期存储指标里面的pod信息去掉，然后把剩下聚合过的指标存三个月。这样，我们可以做到在大部分情况都能较快地查询到监控数据。</p><p>&nbsp;</p><p>还有一个维度的问题，比如最常见的istio&nbsp;request&nbsp;total 指标，会把某一个客户端的版本信息，以及服务的版本信息全部都带上。但这会遇到一个问题，比如某一个服务端一直不更新、客户端一直更新的情况，会导致服务端有特别多不会增长的指标堆积在里面。可惜Envoy也不支持指标过期的功能，导致每一次拉取指标时我们会多拉很多冗余的指标。</p><p>&nbsp;</p><p>最终，我们决定在服务端去除客户端的版本信息、客户端的指标中去除掉服务端的版本信息，通过这种方式优化指标维度。这样做了之后，我们的指标系统压力有了很大程度的下降，个别服务的duration指标维度甚至下降了20万。通过这些操作，我们集群的监控指标维度基本趋于稳定。</p><p>&nbsp;</p><p>在知乎的Mesh化过程中，Mesh 一方面带来了很多新的问题，比如性能上、运营上的问题。但是另一方面，我们利用Mesh节约了很多过往需要在sdk层面反复实现的功能，也利用Mesh弥补了我们在监控与测试链路方面的许多缺失。Service Mesh是一项充满魅力的技术，而知乎的Mesh之路也将继续下去。</p>",
    "publish_time": "2022-07-19 09:51:45",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "详解“洋葱架构”",
    "url": "https://www.infoq.cn/article/zOlhF7uu455xOVvQwWv3",
    "summary": "<p></p><blockquote>领域驱动设计（Domain-driven design，DDD）是一种为复杂需求开发软件的方法，它将软件的实现与不断发展的核心业务概念模型紧密地结合在一起。</blockquote><p></p><p>&nbsp;</p><p>领域是一个知识的范畴。它指的是我们的软件所要模拟的业务知识。领域驱动设计的中心是领域模型，它对一个领域的流程和规则有着深刻的理解。洋葱架构实现了这一概念，并极大地改善了代码的品质，降低了复杂性，并且支持不断发展的企业系统。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/93/7a/938781120debcffaa9aca8180fb9e67a.png\" /></p><p></p><h2>为什么要用洋葱架构？</h2><p></p><p>&nbsp;</p><p>领域实体是核心和中心部分。洋葱架构是建立在一个领域模型上的，其中各层是通过接口连接的。其背后的思想是，在领域实体和业务规则构成架构的核心部分时，尽可能将外部依赖性保持在外。</p><p>&nbsp;</p><p>它提供了灵活、可持续和可移植的架构。各层之间没有紧密的耦合，并且有关注点的分离。由于所有的代码都依赖于更深的层或者中心，所以提供了更好的可维护性。提高了整体代码的可测试性，因为单元测试可以为单独的层创建，而不会影响到其他的模块。框架/技术可以很容易地改变而不影响核心领域。例如，RabbitMQ 可以被 ActiveMQ 取代，SQL 可以被 MongoDB 取代。</p><p>&nbsp;</p><p></p><h2>原则</h2><p></p><p>&nbsp;</p><p>洋葱架构是由多个同心层构成，它们相互连接，并朝向代表领域的核心。它是基于控制反转（Inversion of Control，IoC）的原则。该架构并不关注底层技术或框架，而是关注实际的领域模型。它是基于以下原则：</p><p>&nbsp;</p><p></p><h3>依赖性</h3><p></p><p>&nbsp;</p><p>圆圈代表不同的责任层。一般来说，我们潜入得越深，就越接近于领域和业务规则。外圈代表机制，内圈代表核心领域逻辑。外层依赖于内层，而内层则对外圈一无所知。通常情况下，属于外圈的类、方法、变量和源代码依赖于内圈，但是反过来也一样。</p><p>&nbsp;</p><p>数据格式/结构可能因层而异。外层的数据格式不应该被内层使用。例如，API 中使用的数据格式可以与 DB 中用于持久化的数据格式不同。数据流可以使用数据传输对象。每当数据跨层/跨界时，它应该以方便该层的形式出现。例如，API 可以有 DTO，DB 层可以有 Entity Objects，这取决于存储在数据库中的对象与领域模型的不同。</p><p>&nbsp;</p><p></p><h3>数据封装</h3><p></p><p>&nbsp;</p><p>每个层/圈封装或隐藏内部的实现细节，并向外层公开接口。所有的层也需要提供便于内层消费的信息。其目的是最小化层与层之间的耦合，最大化跨层垂直切面内的耦合。我们在较深的层定义抽象接口，并在最外层提供其具体实现。这样可以确保我们专注于领域模型，而不必过多地担心实现细节。我们还可以使用依赖性注入框架，比如 Spring，在运行时将接口与实现连接起来。例如，领域中使用的存储库和应用服务中使用的外部服务在基础设施层实现。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/e3/43/e3311c03a2632a88929ae41d29110d43.png\" /></p><p>洋葱架构中的数据封装</p><p></p><h3>关注点的分离</h3><p></p><p>&nbsp;</p><p>应用被分为若干层，每一层都有一组职责，并解决不同的关注点。每一层都作为应用中的模块/包/命名空间。</p><p>&nbsp;</p><p></p><h3>耦合性</h3><p></p><p>&nbsp;</p><p>低耦合性，可以使一个模块与另一个模块交互，而不需要关注另一个模块的内部。所有的内部层都不需要关注外部层的内部实现。</p><p>&nbsp;</p><p></p><h2>洋葱架构层</h2><p></p><p>&nbsp;</p><p>让我们通过一个创建订单的用例来了解架构的不同层和它们的职责。当收到一个创建订单的请求时，我们会对这个订单进行验证，将这个订单保存在数据库中，更新所有订单项目的库存，借记订单金额，最后向客户发送订单完成的通知。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/41/21/418729f9fd237cf1060b916a40960121.png\" /></p><p></p><p>说明各层之间的依赖关系的包图</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/29/b1/297ee78e2cb9aac2dcb1yyd4cd4e11b1.png\" /></p><p></p><h3>领域模型/实体</h3><p></p><p>&nbsp;</p><p>领域实体是领域驱动设计的基本构件，它们被用来在代码中为通用语言的概念建模。实体是在问题域中具有唯一身份的领域概念。领域实体封装了属性和实体行为。它应该是独立于数据库或网络 API 等特定技术的。例如，在订单领域，订单是一个实体，并具有像 OrderId、Address、UserInfo、OrderItems、PricingInfo 这样的属性以及像 AddOrderItems、GetPricingInfo、ValidateOrder 这样的行为。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/8f/2b/8fe54e4533e1cc195d9a8bdcc675812b.png\" /></p><p>订单实体类</p><p></p><h3>领域服务</h3><p></p><p>&nbsp;</p><p>领域服务负责保持领域逻辑和业务规则。所有的业务逻辑应该作为领域服务的一部分来实现。领域服务由应用服务协调，以服务于业务用例。它们不是典型的 CRUD 服务，通常是独立的服务。领域服务负责复杂的业务规则，如在处理订单时计算价格和税收信息，保存和更新订单的订单库接口，更新购买物品信息的库存接口等。</p><p>&nbsp;</p><p>它包含了对其目标非常关键的算法，并且将用例作为应用的核心来实现。</p><p>&nbsp;</p><p></p><h3>应用服务</h3><p></p><p>&nbsp;</p><p>应用服务也被称为“用例”，是只负责协调请求步骤的服务，不应该有任何业务逻辑。应用服务与其他服务交互，以满足客户的请求。让我们考虑一下用例，用一个物品清单创建一个订单。我们首先需要计算价格，包括税收计算/折扣等，保存订单项目并向客户发送订单确认通知。定价计算应该是领域服务的一部分，但涉及定价计算、检查可用性、保存订单和通知用户的协调工作应该是应用服务的一部分。应用服务只能由基础设施服务调用。</p><p>&nbsp;</p><p></p><h3>基础设施服务</h3><p></p><p>&nbsp;</p><p>基础设施服务也被称为基础设施适配器，是洋葱架构的最外层。这些服务负责与外部世界交互，不解决任何领域的问题。这些服务只是与外部资源通信，没有任何逻辑。例如：外部通知服务、GRPC 服务器端点、Kafka 事件流适配器、数据库适配器。</p><p>&nbsp;</p><p></p><h3>可观察性服务</h3><p></p><p>&nbsp;</p><p>可观察性服务负责监控应用。这些服务有助于执行以下任务：</p><p>&nbsp;</p><p>数据收集（指标、日志、痕迹）：主要使用库/侧线来收集代码执行期间的各种数据。数据存储：使用能够集中存储所收集的数据的工具（分类、索引等）。可视化：使用允许你对收集的数据进行可视化的工具。</p><p>&nbsp;</p><p>一些例子包括 Splunk、ELK、Grafana、Graphite、Datadog。</p><p>&nbsp;</p><p></p><h2>测试策略</h2><p></p><p>&nbsp;</p><p>洋葱架构的不同层有不同的职责，相应地也有不同的测试策略。测试金字塔是一个很好的框架，它规定了不同类型的测试。属于领域模型、领域服务和应用服务的业务规则应通过单元测试进行测试。当我们移动到外层时，在基础设施服务中进行集成测试更有意义。对于我们的应用，端到端测试和 BDD 是最合适的测试策略。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/4f/31/4fe71yyeb7b0a9b046yy92e95caaf631.png\" /></p><p>针对不同层的测试策略</p><p></p><h2>微服务</h2><p></p><p>&nbsp;</p><p>当孤立地看待每个微服务时，洋葱架构也适用于微服务。每个微服务都有自己的模型、自己的用例，并定义了自己的外部接口，用于检索或修改数据。这些接口可以用一个适配器来实现，该适配器通过公开 HTTP Rest、GRPC、Thrift Endpoints 等连接到另一个微服务。它很适合微服务，在微服务中，数据访问层不仅包括数据库，还包括例如一个 http 客户端，以从另一个微服务，甚至从外部系统获取数据。</p><p>&nbsp;</p><p></p><h2>应用结构和层数</h2><p></p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/88/fc/88f6eee663410b24aefbb4089e2c4cfc.png\" /></p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/69/01/690317ef04f34ebe39ee77d0dcf7ff01.png\" /></p><p>应用结构和层，包括层如何映射到模块以及它们之间的依赖关系。它还描述了对不同层使用什么样的测试策略</p><p>&nbsp;</p><p></p><h2>模块化与打包</h2><p></p><p>&nbsp;</p><p>有两种方法来组织应用的源代码：</p><p>&nbsp;</p><p>要么，我们可以将所有的包放在一个模块/项目中，要么将应用分为不同的模块/项目，每个模块/项目负责洋葱架构中的一个层。</p><p>&nbsp;</p><p>这在很大程度上取决于应用的复杂性和项目的规模，将源代码分为多个模块。在微服务架构中，模块化可能有意义，也可能没有意义，这取决于复杂性和用例。</p><p>&nbsp;</p><p></p><h2>框架、客户端和驱动</h2><p></p><p>&nbsp;</p><p>基础设施层由网络或服务器的框架、数据库的客户端、队列或外部服务组成。它负责配置和缝合所有的外部服务和框架。洋葱架构提供了解耦功能，因此在任何时候交换技术都会变得更容易。</p><p>&nbsp;</p><p></p><h2>我们需要每个层吗？</h2><p></p><p>&nbsp;</p><p>将我们的应用分层组织有助于实现关注点的分离。但我们需要所有的层吗？也许需要，也许不需要。这取决于用例和应用的复杂性。根据应用的需要，也可以创建更多的抽象层。例如，对于没有很多业务逻辑的小型应用，拥有领域服务可能没有意义。无论哪一层，依赖关系都应该是从外层到内层。</p><p>&nbsp;</p><p></p><h2>总结</h2><p></p><p>&nbsp;</p><p>洋葱架构在开始时可能似乎有些困难，但是<a href=\"https://jeffreypalermo.com/2013/08/onion-architecture-part-4-after-four-years/\">在业界已经得到了普遍的认可</a>\"。这是一种让软件易于演进的强有力架构。通过把应用划分为几层，可以使系统更加易于测试、维护和移植。它有助于在旧框架过时时轻松采用新框架/技术。与其他架构风格类似，如六边形、分层、简洁的架构等，它为常见问题提供了一个解决方案。</p><p>&nbsp;</p><p>作者简介：</p><p>&nbsp;</p><p>Ritesh Kapoor，软件工程师，热衷于研究算法、架构设计、敏捷方法。</p><p>&nbsp;</p><p>原文链接：</p><p>&nbsp;</p><p>https://medium.com/expedia-group-tech/onion-architecture-deed8a554423</p>",
    "publish_time": "2022-07-19 10:14:53",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]