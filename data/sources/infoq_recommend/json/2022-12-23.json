[
  {
    "title": "InfoQ 2022 年趋势报告：Java 篇",
    "url": "https://www.infoq.cn/article/vl9UfPTm6oOPAUgYpN5c",
    "summary": "<p>本报告概述了InfoQ Java编辑团队目前是如何看待Java领域内的技术采用和新兴趋势的。</p><p>&nbsp;</p><p>我们重点关注Java，以及相关的语言（如Kotlin和Scala）、Java虚拟机（JVM）和基于Java的框架和工具。</p><p>&nbsp;</p><p>我们讨论了核心Java的发展趋势，比如新版本Java的采用，以及<a href=\"https://spring.io/projects/spring-framework\">Spring Framework</a>\"、<a href=\"https://jakarta.ee/\">Jakarta EE</a>\"、<a href=\"https://quarkus.io/\">Quarkus</a>\"、<a href=\"https://micronaut.io/\">Micronaut</a>\"、<a href=\"https://helidon.io/\">Helidon</a>\"、<a href=\"https://microprofile.io/\">MicroProfile</a>\"和<a href=\"https://microstream.one/\">MicroStream</a>\"等框架的发展。</p><p>&nbsp;</p><p>本报告有两个主要目标：</p><p>&nbsp;</p><p>协助技术负责人制定中长期技术决策。帮助个人开发者将宝贵的时间和资源投入到可以学习和发展技能的地方。</p><p>&nbsp;</p><p>这是我们发布的第四份Java趋势报告。自2006年以来，我们一直在内部跟踪Java和JVM的发展趋势，这个话题已经有大量的新闻报道。</p><p>&nbsp;</p><p>为了更好地了解InfoQ和QCon报道的关于当前和未来的发展趋势，我们使用了<a href=\"http://www.geoffreyamoore.com/\">Geoffrey Moore</a>\"在同名<a href=\"https://www.amazon.com/Crossing-Chasm-3rd-Disruptive-Mainstream/dp/0062292986\">著作</a>\"中提出的“跨越鸿沟”技术思维模型。</p><p>&nbsp;</p><p>我们试图找出Moore所说的早期市场，早期市场的“客户群是由技术爱好者和有远见的人组成的，他们希望在机会或迫在眉睫的问题出现之前抓住它们。”</p><p>&nbsp;</p><p>与我们对<a href=\"https://www.infoq.cn/article/mJxpWooi8uN1yN48dzBH\">2021年</a>\"、<a href=\"https://www.infoq.cn/article/aHx9jlWKrmJK5O6hKN4c\">2020年</a>\"和<a href=\"https://www.infoq.cn/article/xHcGEQe2*jXl8kDTuNK2\">2019年</a>\"Java趋势报告所做一样，下面是2022年发展趋势图。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/9d/9d41d20cc8978acb720b97105692abdc.png\" /></p><p></p><p>&nbsp;</p><p>作为回顾，下面是2021年发展趋势图：</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/40/40f70ed6a21d8c7c8b62edb91d060d7b.png\" /></p><p></p><p>&nbsp;</p><p>除了在创新者阶段发现了一些新技术之外，一些显著的变化如下所述。</p><p>&nbsp;</p><p>我们决定将所有OpenJDK的下游发行版放到一个标签中，即Java Community JDK，并将它们放到早期大众阶段。这个清单包括：<a href=\"https://aws.amazon.com/corretto/\">Amazon Corretto</a>\"、<a href=\"https://docs.azul.com/core/\">Azul Zulu</a>\"、<a href=\"https://www.microsoft.com/openjdk\">OpenJDK的微软构建版本</a>\"、<a href=\"https://bell-sw.com/libericajdk/\">BellSoft Liberica JDK</a>\"、<a href=\"https://adoptium.net/temurin/\">Eclipse Temurin</a>\"、<a href=\"https://developer.ibm.com/languages/java/semeru-runtimes/\">IBM Semeru</a>\"和<a href=\"https://dragonwell-jdk.io/\">阿里巴巴龙井</a>\"。</p><p>&nbsp;</p><p>Java 17已经进入了早期采用者阶段，因为一些框架，尤其是Spring，已经将Java 17作为基线。</p><p>&nbsp;</p><p>由于MicroStream与Helidon、Micronaut和Spring Boot的持续开发和集成，也加入到了Helidon和Micronaut的早期采用者阶段。</p><p>&nbsp;</p><p>Spring Native被移除，取而代之的是更通用的原生Java。这是因为最初于2020年<a href=\"https://www.infoq.com/news/2020/05/java-leyden/\">推出</a>\"并休眠了两年的<a href=\"https://openjdk.org/projects/leyden/\">Leyden项目</a>\"于2022年5月<a href=\"https://openjdk.org/projects/leyden/notes/01-beginnings\">重新启动</a>\"，VMware决定用GraalVM取代<a href=\"https://github.com/spring-projects-experimental/spring-native/blob/main/README.adoc\">Spring Native</a>\"项目来支持生成原生镜像。</p><p>&nbsp;</p><p>经过一年多的开发，Spring Framework 6.0和Spring Boot 3.0都于2022年11月发布，采用了Java 17+和Jakarta EE 9基线。这些版本还通过<a href=\"https://micrometer.io/\">Micrometer</a>\"内嵌了可观察性。</p><p>&nbsp;</p><p>以下是InfoQ的几位Java Queue编辑与Java Champion对不同主题的讨论摘要。这些编辑和Java Champion包括：</p><p>&nbsp;</p><p><a href=\"https://www.linkedin.com/in/michael-redlich-13a966\">Michael Redlich</a>\"——埃克森美孚技术与工程公司高级研究技术员，InfoQ Java Queue首席编辑；<a href=\"https://es.linkedin.com/in/kittylyst\">Ben Evans</a>\"——Red Hat高级首席软件工程师，InfoQ Java Queue编辑；<a href=\"https://nl.linkedin.com/in/johanjanssen2001\">Johan Janssen</a>\"——ASML软件架构师，InfoQ Java Queue编辑；<a href=\"https://www.linkedin.com/in/daliashea/\">Dalia Abo Sheasha</a>\"——微软产品经理；<a href=\"https://www.linkedin.com/in/billy-korando-129b8197/\">Billy Korando</a>\"——Oracle开发者布道师；<a href=\"https://www.linkedin.com/in/otaviojava/\">Otávio Santana</a>\"——Zup Innovation杰出软件工程师。</p><p>&nbsp;</p><p>我们也要感谢为更新2022年“跨越鸿沟”模型提供输入的其他Java Queue编辑：</p><p>&nbsp;</p><p><a href=\"https://www.linkedin.com/in/costlow/\">Erik Costlow</a>\"——产品高级总监，InfoQ Java Queue编辑；<a href=\"https://www.linkedin.com/in/ksilz/\">Karsten Silz</a>\"——Java全栈开发者，InfoQ Java Queue编辑。</p><p>&nbsp;</p><p>他们为我们在发展趋势图上推荐的一些技术定位提供了更多的背景信息。</p><p></p><h2>OpenJDK</h2><p></p><p>&nbsp;</p><p>Korando：作为<a href=\"https://openjdk.java.net/projects/amber/\">Amber项目</a>\"的一部分，Record类、模式匹配和对字符串的改进让我最为兴奋。我知道，在我的职业生涯中，这些特性在进行数据转换、处理格式化字符串和其他令人沮丧的任务时都非常有用。使用这些特性让我感到兴奋，未来的Java开发者也将受益于这些特性，不必像我一样经历这些挫折。</p><p>&nbsp;</p><p>Santana：Java 8已经过时了。在最近的一项市场调查（如JRebel的报告）中，我们可以看到Java 8的受欢迎程度正在下降。这种变化对于Java市场和开发者体验行业（如IDE、框架、集成工具等）来说都是一件好事。我们还可以看到市场和Java社区为将Java 11作为最低版本要求付出了巨大的努力，比如Quarkus和Jakarta EE的最新版。我相信其他应用程序框架也会效仿，将Java 11作为最低版本要求。当我们谈及Java平台，我相信这些工具和框架占了企业代码的80%左右，所以它们会不断更新，以免失去企业开发者的青睐。向Java 11的迁移也表明了一种更快节奏的文化，Java和JDK版本将更频繁地更新，至少每两年更新一次。</p><p>&nbsp;</p><p>Evans：随着JDK 17的<a href=\"https://www.infoq.com/news/2021/09/java17-released/\">发布</a>\"，JDK 11终于在市场上超越了JDK 8。</p><p>&nbsp;</p><p><a href=\"https://adoptium.net/marketplace/\">Adoptium Marketplace</a>\"的发布和可重复构建的到来比许多人意识到的要重要得多，对于那些必须关心供应链安全的企业和个人来说尤其如此。</p><p>&nbsp;</p><p>Redlich：去年发布的<a href=\"https://www.infoq.com/news/2022/03/java18-released\">Java 18</a>\"和<a href=\"https://www.infoq.com/news/2022/09/java19-released/\">Java 19</a>\"提供了新的预览和孵化器特性，如虚拟线程、结构化并发、switch模式匹配、Record模式以及外部函数和内存API。这些特性以JEP的形式为<a href=\"https://openjdk.java.net/projects/amber/\">Amber项目</a>\"、<a href=\"https://wiki.openjdk.java.net/display/loom\">Loom项目</a>\"和<a href=\"https://openjdk.java.net/projects/panama/\">Panama项目</a>\"提供了持续的贡献。Java 20计划于2023年3月发布，它将提供这些特性的升级预览和孵化器版本。</p><p></p><h2>Java 17及以上版本</h2><p></p><p>&nbsp;</p><p>Sheasha：自从最新的Java 17 LTS发布以来，我们注意到Java 17的采用速度比Java 11发布时要快。这是由各种各样的因素导致的，包括公司采用更现代的DevOps流程和管道，支持更快更容易的应用程序更新。另一个因素是框架和库采用了更快的发布节奏，而这在以前是开发者升级应用程序的一大障碍。最新的Spring Framework 6基于Java 17，这向开发者传达了采用最新版本Java的决心。另一个拥抱更快Java发布节奏的团队是Minecraft团队，他们现在向数百万玩家发布的更新也是基于Java 17的。</p><p>&nbsp;</p><p>与此同时，我们看到许多应用程序仍然在使用Java 8。由于从Java 8升级到Java 11比从Java 11升级到Java 17更困难，因此，已经升级到Java 11的团队更有可能迅速采用Java 17。</p><p>&nbsp;</p><p>我们还看到越来越多的开发者使用非LTS Java版本（Java 18+），因为他们更有信心为自己的应用程序采用更新的Java版本，这样他们可以使用Java的新特性，而不必再等待数年。我们看到许多开发者在创建原型或开发新应用程序时选择了最新的非LTS Java版本。但对于生产环境来说，LTS版本仍然是大多数团队的选择。</p><p>&nbsp;</p><p>Santana：在最新的LTS版本中，Java 17为Java开发者带来了几个新特性，其中Record模式带来了一个主要与企业业务相关的新视角。</p><p>&nbsp;</p><p>Janssen：有许多令人兴奋的变化，例如Spring Boot要求使用Java 17，这有望促进Java 17的采用。</p><p></p><h2>Loom项目与虚拟线程</h2><p></p><p>&nbsp;</p><p>Sheasha：在Java性能方面有很多令人兴奋的变化。许多开发者都很高兴看到Loom项目的更新，因为他们现在可以尝鲜一些新的特性，如<a href=\"https://openjdk.org/jeps/425\">虚拟线程</a>\"。</p><p>&nbsp;</p><p>Korando：将Loom项目的关键特性合并到主线Java发行版中可能是过去一年里最重要的变化。Loom项目的开发在过去几年中一直备受关注，因为它承诺的更高的水平可伸缩性将被应用于许多Java开发者的应用程序中。虽然一些特性，如虚拟线程，现在已经准备好用于生产环境中，但毫无疑问，许多开发者都在热切地等待它们从预览状态移出，成为LTS的一部分，并有望在2023年9月与Java 21一起发布。</p><p>&nbsp;</p><p>Evans：我听到很多人都在谈论Loom项目，但我对它持保留态度——我想等到我们有了更多的实际经验之后再说。我认为它可能会像一些人认为的那样改变游戏规则，但我不认为这是一件容易的事情。</p><p>&nbsp;</p><p>Redlich：2022年9月，备受期待的Java 19发布了对虚拟线程的支持。这方面已经有了孵化器框架，如<a href=\"https://medium.com/helidon/please-welcome-helidon-n%C3%ADma-9a882c5b6f1e\">Helidon Níma</a>\"（Oracle提供的微服务框架）和Vert.x提供的<a href=\"https://github.com/vert-x3/vertx-virtual-threads-incubator\">虚拟线程孵化器项目</a>\"。我预计其他供应商也会效仿。</p><p></p><h2>Jakarta EE</h2><p></p><p>&nbsp;</p><p>在延迟了大约三个月之后，备受期待的<a href=\"https://jakarta.ee/specifications/platform/10/\">Jakarta EE 10</a>\"于2022年9月22日向Java社区发布了。</p><p>&nbsp;</p><p>Redlich：Jakarta EE 10对20多个<a href=\"https://jakarta.ee/specifications/\">规范</a>\"进行了更新，并增加了一个新的<a href=\"https://jakarta.ee/specifications/coreprofile/\">Core Profile</a>\"，作为现有<a href=\"https://jakarta.ee/specifications/platform/\">平台</a>\"和<a href=\"https://jakarta.ee/specifications/webprofile/\">Web Profile</a>\"的补充。Jakarta EE工作组已经在讨论Jakarta EE 10和Jakarta EE 11的小版本更新计划。</p><p></p><h2>原生Java（GraalVM/Spring Native/Leyden项目）</h2><p></p><p>&nbsp;</p><p>Santana：GraalVM越来越受欢迎，这为<a href=\"https://openjdk.org/projects/leyden/\">Leyden项目</a>\"提供了巨大的空间。这是一场如何让Java启动更快的竞赛！</p><p>&nbsp;</p><p>Janssen：GraalVM正在不断改进并支持更多的用例，例如Spring应用程序。</p><p></p><h2>Open Telemetry</h2><p></p><p>&nbsp;</p><p>Evans：<a href=\"https://opentelemetry.io/\">OpenTelemetry</a>\"已经发布了1.0版本，对于这样一个出现时间不长的标准来说，这算是取得了巨大的进步。我没想到OpenTelemetry会这么轻易超越已经很激进的预期。它将实现甘特提出的“到2023年底实现遥测大部分流量”的目标，这远远超出了计划。</p><p>&nbsp;</p><p>Redlich：即将发布的MicroProfile 6.0将首次推出MicroProfile <a href=\"https://github.com/eclipse/microprofile-telemetry/blob/main/README.adoc\">Telemetry</a>\"规范，用以取代MicroProfile 1.3中<a href=\"https://www.infoq.com/news/2018/02/microprofile-13/\">首次引入</a>\"的MicroProfile <a href=\"https://github.com/eclipse/microprofile-opentracing\">OpenTracing</a>\"规范。</p><p></p><h2>容器</h2><p></p><p>&nbsp;</p><p>Sheasha：随着越来越多的Java工作负载迁移到容器中，我们看到了一种转变——从只讨论如何容器化Java应用程序到如何最好地容器化Java应用程序。我们看到了更多关于如何在容器中运行应用程序的最佳实践。例如，微软发表了一篇关于内存分配和垃圾收集的<a href=\"https://docs.microsoft.com/en-us/azure/developer/java/containers/overview\">文章</a>\"。</p><p>&nbsp;</p><p>Evans：Java应用程序的容器化仍在继续演进当中。</p><p></p><h2>微软对Java的支持</h2><p></p><p>&nbsp;</p><p>在2021年4月<a href=\"https://www.infoq.com/news/2021/04/microsoft-build-of-openjdk/\">推出</a>\"自己的OpenJDK下游发行版后，微软继续拥抱Java编程语言。</p><p>&nbsp;</p><p>Sheasha：微软加入了<a href=\"https://jakarta.ee/about/working-group/\">Jakarta EE</a>\"和<a href=\"https://microprofile.io/workinggroup/\">MicroProfile</a>\"工作组，因为微软继续在Java生态系统上进行大量投入，原因有很多，GitHub ReadME项目的这篇<a href=\"https://github.com/readme/featured/java-programming-language\">文章</a>\"对此做了说明。</p><p></p><h2>来自Java社区的声音</h2><p></p><p>&nbsp;</p><p>Sheasha：随着创新速度的加快，现代化仍然是许多开发者面临的挑战。发布的Java版本越多，应用程序在Java版本和框架方面的差距就越大，而且越来越难以缩小。这就是为什么我们看到越来越多的公司在现代化工具上进行了投入。一些项目（如<a href=\"https://docs.openrewrite.org/\">OpenRewrite</a>\"）对我们来说很重要，因为它们可以让我们在不抛弃应用程序的同时保持创新。我们还看到了一些新的项目，例如用于Java的<a href=\"https://projects.eclipse.org/projects/adoptium.emt4j\">Eclipse迁移工具包</a>\"，它可以帮助开发者进行Java版本迁移。</p><p>&nbsp;</p><p>开发者疲于学习和掌握开发应用程序所需的大量知识，因为不断有新的库、框架和特性出现。此外，我们看到了“DevOps”中越来越多的“Ops”部分渗透到开发者的职责当中，所以开发者现在也需要了解Docker和Kubernetes。</p><p>&nbsp;</p><p>Korando：我认为，Loom项目向主线OpenJDK交付特性的兴奋点开始转向了Valhalla项目。Valhalla项目是OpenJDK的另一个长期项目，有望显著改善内存管理和吞吐量性能。希望我们能在2023年将Valhalla项目特性交付到OpenJDK主线！</p><p>&nbsp;</p><p>Santana：<a href=\"https://dzone.com/articles/introduction-to-reflectionless-know-what-the-new-t\">无反射框架</a>\"成为一个新趋势，通过消除反射来缩短应用程序启动时间和减少内存消耗。Quarkus、Micronaut、Spring Native和Jakarta CDI Lite等框架就是这方面的例子。</p><p>&nbsp;</p><p>云是所有解决方案的新目标。我们看到了向各种环境的迁移，不仅是基础设施即服务（IaaS），还包括任何能够提升Java开发者效率并为操作层提供更多抽象的解决方案。</p><p>&nbsp;</p><p>从软件开发者的角度来看，无服务器带来了可伸缩性和简单性。为了利用这些优势，我们可以看到一些解决方案转向了原生。</p><p>&nbsp;</p><p>Evans：今年，Quarkus似乎已经开始关注开发者的意识。我经常会遇到尝试使用Quarkus的开发者，尽管实际的应用数量仍在增长当中。我想人们已经意识到它不仅仅是原生编译的Java，它也是一流的Kubernetes Java，具备很棒的开发体验。</p><p></p><h2>有哪些令人兴奋的新东西我们还没有关注</h2><p></p><p>&nbsp;</p><p>Korando：在JavaOne 2022上宣布将Graal JIT编译器和原生镜像合并到OpenJDK中，这是出乎我们意料的一件事。GraalVM的许多技术都很激动人心，但对于许多Java开发者来说它们很难使用。将这些关键特性合并到OpenJDK中可以让Java开发者更容易地使用它们！</p><p>&nbsp;</p><p>Santana：我们知道，开发工具和架构是一个巨大的产业。因此，我们可以看到许多公司在谈论“完美解决方案”和非权衡决策。但实际上，Java在其他方面被证明具有一致性，并且在一些场景中有一些成功案例。每一种架构决策都存在权衡，我们需要了解其上下文，以便将最佳解决方案应用到最佳的场景中。Java生态系统向我们展示了它是一个生产就绪的平台，它为微服务、CQRS、云原生、无服务器、事件驱动设计、单体系统、SQL、NoSQL、映射器、活动记录等提供了解决方案。</p><p>&nbsp;</p><p>Evans：我没想到Loom会在Java 19中作为试验特性被及时合并到主线，我真的很喜欢Gunnar Morling的JFR Analytics项目。</p><p>&nbsp;</p><p>Janssen：我最近了解了OpenJDK的<a href=\"https://openjdk.org/projects/crac/\">检查点协调恢复</a>\"（Coordinated Restore at Checkpoint，CRaC），它通过运行时优化缩短启动时间。</p><p></p><h2>Java社区</h2><p></p><p>&nbsp;</p><p>Sheasha：就我个人而言，我很庆幸Java在我的整个职业生涯中为我打开了许多扇门。我曾有机会在Java生态系统中担任开发者、团队负责人、开发者布道师和程序经理。</p><p>&nbsp;</p><p>Java在语言方面的不断创新和改进让这个领域变得有趣，还使Java成为解决各种行业各种问题的绝佳选择。对我来说，我喜欢在Java领域工作的一个最大的理由是Java社区，社区里满是来自世界各地的充满热情的人才。</p><p>&nbsp;</p><p>Evans：逐渐跟Java 8告别，并让社区转向Java 17及更高版本，这另人感到兴奋。此外，在可观测性方面，尤其是OpenTelemetry，正变得越来越强大。此外，还有一些关于Profile的新工作（包括Java Flight Recorder）正在启动。</p><p>&nbsp;</p><p>Janssen：我真的很期待与Loom项目合作，希望我们很快就能够开始在项目中使用它。</p><p>&nbsp;</p><p>Redlich：我很享受为开源项目做贡献的时光，最近还成为<a href=\"https://jakarta.ee/specifications/nosql\">Jakarta NoSQL</a>\"和<a href=\"https://jakarta.ee/specifications/data/\">Jakarta Data</a>\"规范以及<a href=\"http://www.jnosql.org/\">Eclipse JNoSQL</a>\"项目（Jakarta NoSQL的兼容实现）的提交者。我们一直致力于在Jakarta EE 11发布时将这两个Jakarta规范及时包含在Jakarta EE平台中。</p><p></p><h2>结论</h2><p></p><p>&nbsp;</p><p>需要注意的是，我们的观点只涵盖了一部分东西。Java生态系统的不同部分可能会有不同的体验。我们的这份2022年报告可以作为讨论的引子，而不是一个明确的声明。我们也希望人们能够就行业的发展方向展开公开的讨论。</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/java-jvm-trends-2022/\">https://www.infoq.com/articles/java-jvm-trends-2022/</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/UjJrO7kBo8QSuFes5tcz\">InfoQ 2022 年趋势报告：.NET篇</a>\"</p><p><a href=\"https://www.infoq.cn/article/bNkyoLzwxU7Li2v94Noe\">InfoQ 2022年趋势报告：人工智能、机器学习和数据工程篇</a>\"</p><p><a href=\"https://www.infoq.cn/article/qrvLruwaMWIeoz2zbrdI\">InfoQ 2022年趋势报告：DevOps与云计算篇</a>\"</p><p><a href=\"https://www.infoq.cn/article/0dJ52ivjyHhxc2YYfgxW\">InfoQ 2022年趋势报告：架构与设计篇</a>\"</p><p><a href=\"https://www.infoq.cn/article/fEJyy2uOUM2h3NEUFXG9\">InfoQ 2022年趋势报告：移动及物联网篇</a>\"</p><p><a href=\"https://www.infoq.cn/article/s2HC2rgLtM3AuppIfJHR\">InfoQ 2022年趋势报告：文化与方法篇</a>\"</p>",
    "publish_time": "2022-12-23 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "重新设计一款数据库，架构会是什么样子？",
    "url": "https://www.infoq.cn/article/JHByNrzzkiEYoj2cZY1E",
    "summary": "<p>好久没写东西，分享一下最近思考的比较多的东西，就当是工作记录了。</p><p></p><p>从一个很重要的问题出发：如果在今天，我们从新设计一个 Database，架构会是什么样子？</p><p></p><p>在进入到具体的技术设计之前，我先分享一下我理解的当今（以及未来）的开发者对于数据库的期待：</p><p>Cost-effective，极致的 Pay-as-you-go，无论是私有云/混合云，还是公有云，云原生的理念在渗透几乎所有的基础软件，能够弹性的利用基础设施是节省成本的关键，谁不喜欢更便宜的东西，我用了多少就给多少钱。另外有着稳定流量的对于性能极端敏感的业务我们另一个话题讨论（因为这种情况下 Serverless 反而可能会更贵）。Ease-of-Use, 易用，使用起来越简单越好，最好把所有基础设施的细节都隐藏掉，极低的心智负担带来极低的上手体验和价值确认。另外我认为目前 SQL 仍然是构建应用最简单的数据库接口，另外对于开发者来说，Modern CLI 体验也是很重要。Unified，这点稍微需要解释一下，如果说第二点是从终端的开发者体验来说，那么这条其实想表达的是：架构的简化，我们这些年发明了太多的数据处理技术，即使做一个普通的应用，可能都要使用 n 种数据库和数据仓库，更头疼的是，规模小的情况和规模大的情况下，很难通过一套方案解决（尽管你的业务形态并没有显著的变化），所以很可能在业务快速增长的时候，开发者需要花费大量的时间进行的基础设施的重构（例如分库分表，或者选用扩展性更好 NoSQL 什么的），这是一个很大的痛点，我们要解决它。</p><p></p><p>针对上面这些趋势和痛点，映射到技术上：</p><p></p><p>内核上使用云原生是架构改造，不仅是存算分离，而是能分离的都分离，因为现在我们要做的已经不再是一个软件，而是一个服务，用户也不会关心服务背后的东西，下面会讲。将 Serverless 作为最终的产品形态（注意：Serverless 并不是技术，而是产品形态），反向倒推架构演进路径。对于新一代的数据库来说，HTAP 是必选的技术路线，一个预言：未来的数据库都会是 HTAP 数据库。只有纯 AP 对于业务来说是不完整的，TP 非常重要。</p><p></p><p>带着这些假设，过去这一年，大概做的工作总结一句话就是把： TiDB 大卸八块，然后利用云的基础设施，将它从新拼装起来变成一个数据库服务。最近低调的发布了 TiDB Serverless Tier 就是这个新引擎的第一次亮相。下面聊聊一些技术和工程上的思考。</p><p></p><h2>做服务而不是做软件</h2><p></p><p>今天做数据库，如果你不提供云服务，出门都不太好意思和人打招呼（很快就会是 Serverless）。有很多人（尤其是数据库内核开发者）会低估做一个云服务的复杂性，经典的论调：‘不就是在云上的自动化部署吗？’ 或者 ‘支持一下 Kubernetes Operator？’…其实并不是，甚至目标都应该反过来：**我们要做的并不是一个数据库软件，而是一个数据库服务，当我们用更长的眼光去看的时候就会发现，后者是包含前者的。**这个认知的转变是做好数据库云服务第一步，也是最重要的一步。</p><p></p><p>我们过去开发程序，不同的模块看到的环境是同构且确定的，例如：开发一个单机上运行的软件，不同的模块虽然可以有逻辑上的边界，但是链接到一起之后，运行起来看到的还是这台计算机的一亩三分地，Everything is a trade-off。即使近几年的分布式系统的兴起，但对于经典的分布式软件来说，大致还是单机软件设计思路的延伸，只是通过 RPC 将多台计算机连接在一起，但是仍然环境是相对确定的，尽管很多软件对于底层的环境变化做了一些适配：例如分布式数据库的动态扩容，数据重均衡 Re-balance 等，但是本质并未变化，只是能够操控和调度的资源变多了。但是在云上，这些假设都发生了变化：</p><p></p><p>多样且几乎无限的资源通过 Service API 的形式提供，对于资源的调度和分配可以通过代码完成，这是革命性的变革。一切资源明码标价，所以程序优化的方向从过去的一维的榨取最好的性能（因为硬件的成本已经事先支付），变成一个动态的问题：尽量花小钱办大事。</p><p></p><p>假设的变化带来的技术上的变化：云上的数据库，首先应该是多个自治的微服务组成的网络。这里的微服务并非一定是在不同的机器上，在物理上可能在一台机器上，但是需要能在远程访问，另外这些服务应该是无状态的（无副作用），方便快速的弹性扩展，这个带来对于开发者的转变就是：放弃对于同步语义的坚持，这个世界是异步化且不可靠的。我很高兴我的偶像 Amazon 的 CTO Werner Vogels 在今年 ReInvent Keynote 上也强调了这一点。放弃掉对于同步和单机的幻想，得到了什么？我们看一些例子：</p><p>第一，最近几年被聊烂的存算分离🙂。在云上，计算的单位价格比存储要高得多，如果计算和存储绑定，那么就没有办法利用存储的价格优势，另外对于一些特定的请求，对于计算的需求很可能与存储节点的物理资源是完全不对等的（想象一下重型的 OLAP 请求的 Resuffle 和分布式聚合）。另外，对于分布式数据库来说，扩容速度是一个重要的用户体验指标，当存算分离后，原则上扩容速度是能做到极快的，因为扩容变成了：1. 启动新的计算节点 2. 缓存预热；反之亦然。</p><p></p><p>第二，对于数据库来说，一些内部组件的微服务化，例如：DDL-as-a-Service。传统数据库的 DDL 对于在线业务是有影响的（即使用了 Online DDL），例如添加索引时候，不可避免的需要进行数据回填，这对于正在服务 OLTP 负载存储节点来说会引起抖动。如果我们仔细思考一下 DDL 就会发现它是一个：全局的，偶发的，重计算，可离线进行，可重入的模块，如果有一个共享的存储层（例如 S3），这类模块非常适合剥离出来变成一个 Serverless 的服务，通过 S3 与 OLTP 的存储引擎共享数据。带来的好处毋庸置疑：</p><p></p><p>对在线业务也是几乎没有性能影响因为按需运行，带来成本下降。</p><p></p><p>类似的例子还有很多：日志（CPU 使用少，但是对于存储要求高），LSM-Tree 存储引擎的 Compaction，数据压缩，元信息服务，连接池，CDC等等，都是可以且很适合被剥离的对象。在新的 Cloud-native 版本的 TiDB 中，我们使用了 Spot Instances 进行存储引擎的 Remote Compaction，带来的成本下降是惊人的。</p><p></p><p>在设计云数据库的时候，另一个重要的要思考的问题是：QoS(Quality of service)，具体到细节大概是：</p><p></p><p>需要定义 WCU 和 RCU，作为控制的单位，因为如果你没有办法定义这个，你将没办法进行资源的分配和调度，乃至定价。多租户是必选项，租户之间一定要可以共享硬件甚至集群资源，大租户也可以独占资源（单租户模式是多租户的一种特化），带来的问题：如何避免 Noisy Neiberhood 问题？如何设计 Throttling 策略？如何避免共享的元信息服务 Overwhelm？如何应对极端的热点？</p><p></p><p>挑战还有很多，我就不一一列举了。很多经验在 AWS 今年那篇 DynamoDB 的新论文中介绍得很详细，大概参考那篇论文即可。</p><p></p><h2>哪些云服务可以被依赖</h2><p></p><p>另一个很重要话题是：云上哪些服务可以依赖？这是因为对于一个第三方厂商来说，跨云（甚至是跨云下，类似混合云）的产品体验是你天然的优势，如果对于特定的云服务依赖得太深太紧，将会让你丧失这份灵活性。所以选择依赖的时候需要非常小心，下面是一些原则：</p><p></p><p>依赖接口和协议 ，而不是具体实现，服务内部你随便自己搞，但是给其他服务暴露的接口要通用且不要做过多假设，简单来说就是被调用者心智负担最小化（UNIX 时代留存下来的古老智慧）。一个很好的例子是： VPC Peering 和 PrivateLink，如果按照这个原则，肯定选择 PrivateLink，因为 VPC Peering 倾向于暴露更多的细节给被使用者。有行业标准就 Follow 行业标准（S3，POSIX 文件系统），每个云上都有对象存储，而且每个云的对象存储 API 大概都会兼容 S3 协议，这就是好的。唯一的例外是安全。如果没办法做到跨云的抽象，也别自己强行造轮子，云有啥就用啥，例如密钥管理，IAM 什么的，千万不要自己发明。</p><p></p><p>下面举几个例子说明一下，对于 Cloud-Native TiDB 来说，在选择依赖的时候做出如下选择：</p><p></p><p>存储：S3，就像上面提到的，每个云都会有 S3 协议的对象存储服务。在数据库中使用类似 LSM-Tree 的分层存储，带来的好处是能够通过一套 API 来利用不同层次的存储介质，例如上层的热数据可以使用本地磁盘，下层的数据在 S3 上，通过异步的 Compaction 来将上层的数据交换到 S3 上。这是 TiDB 存算分离的基础，只有数据在 S3 之后，才能解锁 Remote Compaction 等操作。但是带来的问题是：S3 的高延迟注定了它不能出现在主要的读写链路上（上层缓存失效，会带来极高的长尾延迟），对于这个问题，我是比较乐观的：如果我们考虑 100% 本地缓存的场景，就退化成经典的 Shared-Nothing 的设计，用于支撑最极端的 OLTP 场景我认为是没问题的（参考现在的 TiKV），额外付出代价只是 S3 上的存储成本 which is 很低。如果分片做得足够细，缓存和热点问题是好解决的。分层存储中还可以加入 EBS（分布式块存储）来作为二级缓存，进一步削峰（削弱本地缓存失效带来的延迟突变）我在 2020 年的一次分享中提到，对于云原生的数据库而言，如何能利用好 S3 会是关键。这个观点到现在还没有变化。计算：容器 + Kubernetes，和 S3 一样，每个云都有 K8s 的服务，就像 Linux 一样，K8s 是云的操作系统，虽然存算分离做完后，计算相对好管理一点，但是像一些计算资源池的管理，例如 Serverless 集群需要的快速启动（冬眠唤醒），从 0 开始启动建新 Pod 肯定来不及，需要有一些预留的资源，又例如使用 Spot Instance 来处理 Compaction 任务，万一某个 Spot Instance 被回收，能否再快速找个机器继续工作，又例如负载均衡和 Service Mesh…虽然 S3 帮你把最难搞的状态问题解决了，但是这些纯计算节点的调度问题是很琐碎的，如果你选择自己造轮子，那么大概率最后你会重新发明一个 K8s，所以不如直接拥抱。</p><p></p><p>在云上，还有一个很大的设计问题：文件系统是一个好抽象吗？这个问题来自于在哪层抽象之下屏蔽云的基础设施。在 S3 普及之前，各个大型的分布式系统存储系统，尤其是 Google 的：BigTable，Spanner 等都选择了一个分布式文件系统作为底座（我认为这里面有很深的 Plan9 的痕迹，毕竟 Google 内部这些 Infra 大神很多都是从贝尔实验室来的😄）。那么问题来了，如果有了 S3，我们还需不需要一层文件系统的抽象？我目前还没有想清楚，我倾向于有，理由仍然是存储的缓存，如果有一层文件系统，在文件系统层能够根据文件的访问热度做进行一层缓存，提升扩容时候的预热速度；另一个好处是基于文件系统，生态工具兼容性会更好，很多 UNIX 的工具能直接复用，运维复杂度降低。</p><p></p><h2>将终端用户体验作为优化方向</h2><p></p><p>我在今年的 DevCon 的 Keynote 中提到了一点：云上的数据库如何与现代的开发者体验融合？这个是一个很有意思的话题，因为数据库那么多年了，几乎还是这个样子，SQL is still the king。但是另一方面现在开发者开发的应用以及使用的工具已经和几十年前大不一样了，作为一个从 UNIX 时代过来的老程序员，看到现在年轻一代的开发者使用的眼花缭乱的先进开发工具和理念，只能感叹一代比一代强，虽然操作数据 SQL 仍然是标准，但是数据库软件能否做更多，去融入这些现代的应用开发体验中？</p><p></p><p>我的答案是：还是能做一些微小的贡献的。例如：</p><p></p><p>Serverless ，很多人认为的 Serverless 是一个技术名词，我认为不是，Serverless 更重要的是从用户体验角度定义了什么是更好的云上软件的产品形态。或者这是本来就应该是理所应当的：为什么我作为用户需要关心你有几个节点？为什么我需要关心你内部的参数和配置？为什么我点了启动，你要让我再等半小时？…等等这些在我们这个行业里面过去看起来似乎理所应当的事情，其实仔细想想都觉得挺可笑的，举个例子：假设你去买个车，卖车的先送给你一本发动机维修指南，告诉你读完才能上路，车跑得不快，然后告诉你某个发动机参数需要你调一下，每次启动汽车都要等半小时…是不是很奇怪？对于 Serverless 的产品来说，从用户体验来说，最大的意义在于三件事情：</p><p></p><p>屏蔽掉配置，降低了使用者的心智负担极其快速的启动时间，这点扩展了使用场景和易用性Scale-to-Zero，在多数场景中降低了使用的成本（当有明显波峰波谷，且你没法预测的场景），在小规模时甚至可以免费。</p><p></p><p>有了这三点，才能很好的将数据库嵌入到其他的应用开发框架中，这是构建更大的生态的基础。</p><p></p><p>除了 Serverless 之外，现代的开发者体验（DX）中还包含很多其他的关键要素，例如：</p><p></p><p>Modern CLI：对于开发者来说 CLI 的效率比图形界面高得多，而且更容易通过 Shell 脚本组合其他工具实现自动化。云端-本地统一的开发/调试/部署体验：没有人想天天碰服务器，本地能搞定的事情，就不要让人 SSH。尤其对于云服务来说，如何在云下开发和调试，目前是一个有很多痛点的市场。Example Code / Demo / 脚手架：新一代的偏向 PLG 的服务提供商，例如：Vercel，Supabase 这一套玩的很溜，想想这也是合理的，对于普通的 CRUD 应用来说，基本的代码框架都是相似的，提供一些快速上手的例子，能够让开发者更快的体会到你的产品价值，也帮助开发者更快的构建他们的应用。</p><p></p><h2>未来的挑战</h2><p></p><p>我上面提到的很多技术内容，基本上都是无人区，很难提前预见到所有的挑战，这也是没办法的事情。这一段作为结尾，列一部分有意思的挑战，虽然肯定不完备，希望能对你有所启发：</p><p></p><p>新的产品形态，当不同租户的存储引擎上的数据都在 S3 之后，理论上可以解锁一个更大的基于数据共享和交换的市场（想象一下 Google Docs）， 又或者在 S3 上 + MVCC 理论上可以实现类似 Git 似的对于数据的版本控制，想象一下 git checkout&nbsp;的顺滑体验，只是不同的是，你切换的是你的数据库镜像（我知道已经有云上的数据库产品开始探索这个产品形态），这会带来很多新的应用场景和独特的价值。</p><p></p><p>新的商业模式，云是新的计算机，但这个世界应该不会只有几台计算机，除了标准的 SaaS 模式外，还有没有可能将 DBaaS 作为一个整体进行输出，这可能又是一种全新的商业模式（尤其是在和一些二线或者私有云合作的时候），这时候数据库厂商会变成输出数据库服务产品的厂商（有点绕）</p><p></p><p>新的研发组织，对于一个数据库厂商来说，过去对于研发和产品的需求几乎只限于内核开发，但是在做云服务的过程中，你不仅是开发者，还会是运维和运营者，而且开发云服务对于研发人员的技术栈的要求和数据库内核是完全不一样的，这里面必然涉及巨大的组织变革和人事调整，如何过渡好？</p><p></p><p>问题和挑战嘛，永远都是有的，把这个系统做出来的过程，也是我们理解这个系统的过程，最后送上我很喜欢的一句话，来自著名的物理学家理查德费曼：</p><p></p><p>What I cannot create, I do not understand。</p>",
    "publish_time": "2022-12-23 09:34:26",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]