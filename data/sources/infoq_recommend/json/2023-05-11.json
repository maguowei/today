[
  {
    "title": "Java近期新闻：新的OpenJDK JEP、Payara平台、Spring和Tomcat更新、WildFly 28",
    "url": "https://www.infoq.cn/article/VfaDjlOi0HYmxmPPwiEH",
    "summary": "<p></p><h4>OpenJDK</h4><p></p><p></p><p>JEP 446（<a href=\"https://openjdk.org/jeps/446\">作用域值预览</a>\"）已经从JEP Draft 8304357状态<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-April/007660.html\">提升</a>\"到Candidate状态。该JEP就是之前的范围局部变量（第一轮孵化），是对JDK 20中发布的JEP 429（<a href=\"https://openjdk.org/jeps/429\">作用域值第一轮孵化</a>\"）的一个<a href=\"https://openjdk.org/jeps/12\">特性预览</a>\"。该JEP建议在线程内部和线程之间共享不可变数据。这种方式比使用线程局部变量更好，特别是在大量使用虚拟线程时。</p><p>&nbsp;</p><p>JEP 447（<a href=\"https://openjdk.org/jeps/447\">super()之前的语句</a>\"）已经从JEP Draft 8300786状态<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-April/007662.html\">提升</a>\"到Candidate状态。在<a href=\"https://openjdk.org/projects/amber/\">Amber项目</a>\"的支持下，该JEP建议：如果语句不引用正在创建的实例，则可以出现在构造函数中的this()或super()调用之前，并为构造函数保留现有的安全性和初始化保证。Gavin Bierman是Oracle的技术咨询顾问，他已经向Java社区提供了该JEP的初始规范，以供评审和收集反馈。</p><p>&nbsp;</p><p>JEP 448（<a href=\"https://openjdk.org/jeps/448\">向量API第六轮孵化</a>\"）已从JEP Draft 8305868状态<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-April/007669.html\">提升</a>\"到Candidate状态。在<a href=\"https://openjdk.org/projects/panama/\">Panama项目</a>\"的支持下，该JEP融合了针对前五轮孵化反馈所做的增强：JEP 438，<a href=\"https://openjdk.org/jeps/438\">向量API第五轮孵化</a>\"，在JDK 20中交付；JEP 426，<a href=\"https://openjdk.org/jeps/426\">向量API第四轮孵化</a>\"，在JDK 19中交付；JEP 417，<a href=\"https://openjdk.java.net/jeps/417\">向量API第三轮孵化</a>\"，在JDK 18中交付；JEP 414，<a href=\"https://openjdk.java.net/jeps/414\">向量API第二轮孵化</a>\"，在JDK 17中交付；JEP 338，<a href=\"https://openjdk.java.net/jeps/338\">向量API第一轮孵化</a>\"，在JDK 16中作为<a href=\"https://openjdk.java.net/jeps/11\">孵化器模块</a>\"交付。该JEP建议增强向量API，以便从JEP 424（<a href=\"https://openjdk.java.net/jeps/424\">外部函数和内存API预览</a>\"）定义的MemorySegment中加载向量以及向其中存储向量。</p><p>&nbsp;</p><p>JEP 449（<a href=\"https://openjdk.org/jeps/449\">弃用Windows 32-bit x86平台支持</a>\"）已经从JEP Draft 8303167状态<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-April/007670.html\">提升</a>\"到Candidate状态。该特性是由微软资深项目经理<a href=\"https://www.linkedin.com/in/gdams/\">George Adams</a>\"引入。该JEP建议弃用Windows x86-32位平台支持，并打算在未来的版本中删除这一支持。由于不打算在32位平台上实现JEP 436（<a href=\"https://openjdk.org/jeps/436\">虚拟线程第二次预览</a>\"），所以取消对该平台的支持将能够提升OpenJDK开发人员开发新特性的速度。</p><p>&nbsp;</p><p>JEP Draft 8305968（<a href=\"https://openjdk.org/jeps/8305968\">完整性和强封装</a>\"）和JEP Draft 8306275（<a href=\"https://openjdk.org/jeps/8306275\">默认禁用代理动态加载</a>\"）已经由Oracle Loom项目架构师和技术主管<a href=\"https://inside.java/u/RonPressler/\">Ron Pressler</a>\"<a href=\"https://mail.openjdk.org/pipermail/serviceability-dev/2023-April/047841.html\">提交</a>\"。</p><p>&nbsp;</p><p>完整性和强封装建议默认启用强封装等各种特性，确保代码和数据的完整性。该草案的目标包括：让Java平台可以稳健地维护可维护性、安全性和性能所需的不变性；区分打破封装更方便的用例和必须禁用封装的用例。</p><p>&nbsp;</p><p>默认禁用代理动态加载遵循完整性和强封装的方法，建议默认禁止将代理动态加载到正在运行的JVM中。该草案的目标包括：重新评估适用性和完整性之间的平衡；确保大多数不需要动态加载代理的工具不受影响。</p><p>&nbsp;</p><p>JDK任务控制（JMC） 8.3.1<a href=\"https://twitter.com/OpenJDK/status/1649123842973892612?cxt=HHwWiICwsbrZ7uItAAAA\">发布</a>\"，带来了一些值得注意的修复，如：在macOS和Linux上安装插件后无法打开JMX控制台；在Linux上安装JMC插件后无法编辑Eclipse项目运行配置；无法在jLinked应用程序上执行运行记录。要了解关于该版本的更多细节，请查看<a href=\"https://www.oracle.com/java/technologies/javase/jmc8-release-notes.html\">发布说明</a>\"。</p><p>&nbsp;</p><p></p><h4>JDK 21</h4><p></p><p></p><p>JDK 21<a href=\"https://jdk.java.net/21/\">早期访问构建</a>\"<a href=\"https://github.com/openjdk/jdk/releases/tag/jdk-21%2B19\">Build 19</a>\"在上周发布，其中包括<a href=\"https://github.com/openjdk/jdk/compare/jdk-21%2B18...jdk-21%2B19\">Build 18的更新</a>\"，主要是修复了各种<a href=\"https://bugs.openjdk.org/issues/?jql=project%20%3D%20JDK%20AND%20fixversion%20%3D%2021%20and%20%22resolved%20in%20build%22%20%3D%20b17%20order%20by%20component%2C%20subcomponent\">问题</a>\"。要了解关于这个版本的更多细节，请查看<a href=\"https://jdk.java.net/21/release-notes\">发布说明</a>\"。</p><p>&nbsp;</p><p>对于<a href=\"https://openjdk.java.net/projects/jdk/21/\">JDK 21</a>\"，我们鼓励开发人员通过<a href=\"https://bugreport.java.com/bugreport/\">Java Bug数据库</a>\"报告Bug。</p><p>&nbsp;</p><p></p><h4>JDK 20</h4><p></p><p></p><p>Oracle发布2023年4月的<a href=\"https://www.jpcert.or.jp/english/at/2023/at230008.html\">关键补丁更新</a>\"，其中包括JDK 20的第一个维护版本<a href=\"https://jdk.java.net/20/\">JDK 20.0.1</a>\"，以及<a href=\"https://www.oracle.com/java/technologies/javase/17-0-7-relnotes.html\">JDK 17.0.7</a>\"、<a href=\"https://www.oracle.com/java/technologies/javase/11-0-19-relnotes.html\">JDK 11.0.19</a>\"和<a href=\"https://www.oracle.com/java/technologies/javase/8u371-relnotes.html\">JDK 8u371</a>\"的安全更新。</p><p>&nbsp;</p><p></p><h4>BellSoft</h4><p></p><p></p><p>与Oracle发布2023年4月的<a href=\"https://www.oracle.com/security-alerts/cpuapr2023.html\">关键补丁更新</a>\"（CPU）同时，BellSoft<a href=\"https://bell-sw.com/blog/liberica-jdk-8u372-11-0-19-17-0-7-and-20-0-1-builds-are-generally-available/\">发布</a>\"了其OpenJDK下游发行版<a href=\"https://bell-sw.com/pages/libericajdk/\">Liberica JDK</a>\" 17.0.6.0.1、11.0.18.0.1和8u371版本的CPU补丁。此外，他们还发布了20.0.1、17.0.7、11.0.19和8u372版本的补丁集更新（PSU），其中包含CPU和非关键修复。</p><p>&nbsp;</p><p></p><h4>Spring Framework</h4><p></p><p></p><p><a href=\"https://spring.io/projects/spring-boot\">Spring Boot</a>\" 3.1.0的<a href=\"https://spring.io/blog/2023/04/22/spring-boot-3-1-0-rc1-available-now\">第一个候选版本</a>\"提供了一些值得注意的新特性：改进Testcontainer支持，包括开发阶段支持；支持Docker Compose；增强SSL配置；改进Docker镜像构建。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.1.0-RC1-Release-Notes\">发布说明</a>\"。</p><p>&nbsp;</p><p>Spring Boot 3.0.6的<a href=\"https://spring.io/blog/2023/04/20/spring-boot-3-0-6-available-now-fixing-cve-2023-20873\">发布</a>\"主要解决了CVE-2023-20873漏洞：<a href=\"https://spring.io/security/cve-2023-20873\">在Cloud Foundry上利用通配符模式匹配进行安全绕过</a>\"。该漏洞使得部署到<a href=\"https://cloud.spring.io/spring-cloud-cloudfoundry/reference/html/\">Spring Cloud for Cloud Foundry</a>\"的应用程序容易受到安全绕过的影响。除了文档改进和依赖项升级，该版本还提供了一些值得注意的Bug修复，如：Spring Cloud for Cloud Foundry集成没有使用端点路径映射；ApplicationAvailability bean是自动配置的，即使已经存在自定义bean；Apache Cassandra中的默认配置替换不能解析来自spring.data.cassandra属性文件的配置。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/spring-projects/spring-boot/releases/tag/v3.0.6\">发布说明</a>\"。</p><p>&nbsp;</p><p>同样，Spring Boot 2.7.11的<a href=\"https://spring.io/blog/2023/04/20/spring-boot-2-7-11-available-now-fixing-cve-2023-20873\">发布</a>\"也是为了解决了上面提到的CVE-2023-20873漏洞，并提供了文档方面的改进、依赖项升级和与Spring Boot 3.0.6相同的Bug修复。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/spring-projects/spring-boot/releases/tag/v2.7.11\">发布说明</a>\"。</p><p>&nbsp;</p><p><a href=\"https://spring.io/projects/spring-security\">Spring Security</a>\"的6.1.0-RC1、6.0.3、5.8.3和5.7.8版本<a href=\"https://spring.io/blog/2023/04/17/spring-security-6-1-0-rc1-6-0-3-5-8-3-and-5-7-8-released-fix-cve-2023-20862\">发布</a>\"，主要用于解决CVE-2023-20862漏洞：<a href=\"https://spring.io/security/cve-2023-20862\">空的SecurityContext在注销时未正确保存</a>\"。该漏洞使得序列化版本的注销不能正确地清除安全上下文，并且无法显式地将空的安全上下文保存到HttpSessionSecurityContextRepository 类。这将导致用户在注销之后仍然处于身份已验证状态。要了解关于这些版本的更多细节，请查看<a href=\"https://github.com/spring-projects/spring-security/releases/tag/6.1.0-RC1\">6.1.0-RC1</a>\"、<a href=\"https://github.com/spring-projects/spring-security/releases/tag/6.0.3\">6.0.3</a>\"、<a href=\"https://github.com/spring-projects/spring-security/releases/tag/5.8.3\">5.8.3</a>\"和<a href=\"https://github.com/spring-projects/spring-security/releases/tag/5.7.8\">5.7.8</a>\"的发布说明。</p><p>&nbsp;</p><p><a href=\"https://spring.io/projects/spring-session\">Spring Session</a>\" 3.1.0的第一个候选版本提供了依赖项升级和一个新特性，即重用StringRedisSerializer类的实例，从而消除了实例化其他序列化器实例的需要。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/spring-projects/spring-session/releases/tag/3.1.0-RC1\">发布说明</a>\"。</p><p>&nbsp;</p><p><a href=\"https://spring.io/projects/spring-authorization-server\">Spring Authorization Server</a>\" 1.1.0的<a href=\"https://spring.io/blog/2023/04/18/spring-authorization-server-1-1-0-rc1-available-now\">第一个候选版本</a>\"提供了依赖项升级和新特性，包括：在JdbcOAuth2AuthorizationService类中支持设备代码和用户代码；改进<a href=\"https://www.rfc-editor.org/rfc/rfc8628.html\">OAuth 2.0 Device Authorization Grant</a>\"，包括添加测试和参考文档；改进OpenID Connect 1.0注销端点。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/spring-projects/spring-authorization-server/releases/tag/1.1.0-RC1\">发布说明</a>\"。</p><p>&nbsp;</p><p>同样，Spring Authorization Server的1.0.2和0.4.2版本也<a href=\"https://spring.io/blog/2023/04/18/spring-authorization-server-1-0-2-and-0-4-2-available-now\">发布</a>\"了，带来了依赖项升级和一些值得注意的Bug修复：将不正确的INVALID_CLIENT令牌错误代码返回给正确的INVALID_GRANT令牌错误代码；坏掉的支持链接；认证密钥应该在客户端注册时编码保存；考虑允许在重定向URI中使用localhost。要了解关于这些版本的更多细节，请查看<a href=\"https://github.com/spring-projects/spring-authorization-server/releases/tag/1.0.2\">1.0.2</a>\"和<a href=\"https://github.com/spring-projects/spring-authorization-server/releases/tag/0.4.2\">0.4.2</a>\"版本的发布说明。</p><p>&nbsp;</p><p><a href=\"https://spring.io/projects/spring-integration\">Spring Integration</a>\"的6.1.0-RC1和6.0.5版本发布，它们有一些值得注意的变化，包括：删除了IntegrationWebSocketContainer类中的尾随空格；改进了BaseWsInboundGatewaySpec和TailAdapterSpec类，它们没有覆盖super方法，并且由于target字段未填充而抛出NullPointerException实例。要了解关于这些版本的更多细节，请查看<a href=\"https://github.com/spring-projects/spring-integration/releases/tag/v6.1.0-RC1\">6.1.0-RC1</a>\"和<a href=\"https://github.com/spring-projects/spring-integration/releases/tag/v6.0.5\">6.0.5</a>\"版本的发布说明。</p><p>&nbsp;</p><p><a href=\"https://spring.io/projects/spring-graphql\">Spring for GraphQL</a>\" 1.2.0的<a href=\"https://spring.io/blog/2023/04/19/spring-for-graphql-1-2-0-rc1-released\">第一个候选版本</a>\"提供了以下新特性：更新SchemaMappingInspector类以支持Connection类型；利用Querydsl和Query By Example支持分页；对分页和排序的全面支持。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/spring-projects/spring-graphql/releases/tag/v1.2.0-RC1\">发布说明</a>\"。</p><p>&nbsp;</p><p><a href=\"https://spring.io/projects/spring-shell\">Spring Shell</a>\"的3.1.0-M2、3.0.2和2.1.8版本<a href=\"https://spring.io/blog/2023/04/17/spring-shell-2-1-8-3-0-2-and-3-1-0-m2-are-now-available\">发布</a>\"，带来了一些值得注意的变化，包括：分别基于Spring Boot 3.1.0-M2、3.0.5和2.7.10构建；Bug修复反向移植；对使用位置参数的自定义类型处理进行了重要修复。要了解关于这些版本的更多细节，请查看<a href=\"https://github.com/spring-projects/spring-shell/releases/tag/v3.1.0-M2\">3.1.0-M2</a>\"、<a href=\"https://github.com/spring-projects/spring-shell/releases/tag/v3.0.2\">3.0.2</a>\"和<a href=\"https://github.com/spring-projects/spring-shell/releases/tag/v2.1.8\">2.1.8</a>\"版本的发布说明。</p><p>&nbsp;</p><p></p><h4>WildFly</h4><p></p><p></p><p>Red Hat<a href=\"https://www.wildfly.org/news/2023/04/20/WildFly28-Released/\">发布</a>\"了WildFly 28，改进了对可观察性的支持，并完全支持Jakarta EE 10。WildFly增加了对<a href=\"https://micrometer.io/\">Micrometer</a>\"和<a href=\"https://github.com/eclipse/microprofile-telemetry/blob/main/README.adoc\">MicroProfile Telemetry</a>\"规范的支持，但取消了对<a href=\"https://github.com/eclipse/microprofile-metrics/blob/master/README.adoc\">MicroProfile Metrics</a>\"的支持。Red Hat建议在生产应用程序中使用JDK 17，但是他们也看到，在JDK 20上的效果也不错。要了解关于该版本的更多细节，请查看<a href=\"https://issues.redhat.com/secure/ReleaseNote.jspa?projectId=12313721&amp;version=12405355\">发布说明</a>\"，InfoQ后续也会带来更详细的新闻报道。</p><p>&nbsp;</p><p></p><h4>Payara</h4><p></p><p></p><p>Payara<a href=\"https://blog.payara.fish/whats-new-in-the-april-2023-payara-platform-release\">发布</a>\"了2023年4月版的<a href=\"https://www.payara.fish/\">Payara平台</a>\"，其中包括社区版6.2023.4、企业版6.1.0和企业版5.50.0。</p><p>&nbsp;</p><p>社区版6.2023.4提供的新特性包括：修复了使用JDK17和Records时的Payara 6部署错误；改进了应用程序部署描述符和全局HTTP网络监听器中的<a href=\"https://web.dev/samesite-cookies-explained/\">SameSite</a>\" cookie属性；依赖项升级到EclipseLink 4.0.1、EclipseLink ASM 9.4.0、Hazelcast 5.2.2和ASM 9.4。要了解关于该版本的更多细节，请查看<a href=\"https://docs.payara.fish/community/docs/Release%20Notes/Release%20Notes%206.2023.4.html\">发布说明</a>\"。</p><p>&nbsp;</p><p>类似地，企业版6.1.0的新特性也包括：修复了使用JDK17和Records时的Payara 6部署错误；改进了应用程序部署描述符中的<a href=\"https://web.dev/samesite-cookies-explained/\">SameSite</a>\" cookie属性；依赖项升级到EclipseLink 4.0.1、 EclipseLink ASM 9.4.0、Hazelcast 5.2.2和ASM 9.4。要了解关于该版本的更多细节，请查看<a href=\"https://docs.payara.fish/enterprise/docs/Release%20Notes/Release%20Notes%206.1.0.html\">发布说明</a>\"。</p><p>&nbsp;</p><p>企业版5.50.0还附带了以下特性：解决<a href=\"https://www.rapid7.com/db/vulnerabilities/apache-tomcat-cve-2023-24998/\">CVE-2023-24998</a>\"漏洞。这是<a href=\"https://commons.apache.org/proper/commons-fileupload/\">Apache Commons FileUpload</a>\"中的一个漏洞，由于未对已处理请求部分的数量做限制，所以攻击者可以通过恶意上传触发拒绝服务；修复Hazelcast NoDataMemberInClusterException ；改进应用程序部署描述符中的<a href=\"https://web.dev/samesite-cookies-explained/\">SameSite</a>\" cookie属性；依赖项升级到Hazelcast 5.2.2。要了解关于该版本的更多细节，请查看<a href=\"https://docs.payara.fish/enterprise/docs/5.50.0/Release%20Notes/Release%20Notes%205.50.0.html\">发布说明</a>\"。</p><p>&nbsp;</p><p></p><h4>Open Liberty</h4><p></p><p></p><p>IBM<a href=\"https://openliberty.io/blog/2023/04/18/23.0.0.4-beta.html\">发布</a>\"了Open Liberty 23.0.0.4-beta版，更新了对<a href=\"https://jakarta.ee/specifications/data/\">Jakarta Data</a>\"规范的支持，开发人员现在可以组合使用多种方式指定排序和分类，定义优先级。首先应用由@OrderBy注解或按方法查询关键字定义的排序，然后应用方法或Pageable接口上Sort记录中的参数。</p><p>&nbsp;</p><p></p><h4>Micronaut</h4><p></p><p></p><p>Micronaut基金会<a href=\"https://micronaut.io/2023/04/18/micronaut-framework-3-9-0-released/\">发布</a>\"了Micronaut Framework 3.9.0，带来了以下新特性：允许自定义包，使用@Introspected注解的targetPackage字段编写自省；通过@CrossOrigin注解启用跨域资源共享（CORS）配置；一个破坏性更改，为了防止意外暴露用户的API，配置属性micronaut.server.cors.*.configurations.allowed-origins不支持正则表达式；模块更新，包括：<a href=\"https://micronaut-projects.github.io/micronaut-kubernetes/snapshot/guide/\">Micronaut Kubernetes</a>\"、<a href=\"https://micronaut-projects.github.io/micronaut-security/snapshot/guide/\">Micronaut Security</a>\"、<a href=\"https://micronaut-projects.github.io/micronaut-crac/snapshot/guide/\">Micronaut CRaC</a>\"、<a href=\"https://micronaut-projects.github.io/micronaut-maven-plugin/latest/\">Micronaut Maven</a>\"和<a href=\"https://micronaut.io/launch/\">Micronaut Launch</a>\"。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/micronaut-projects/micronaut-core/releases/tag/v3.9.0\">发布说明</a>\"。</p><p>&nbsp;</p><p></p><h4>Apache软件基金会</h4><p></p><p></p><p></p><p>Apache Tomcat团队发布了<a href=\"https://www.mail-archive.com/announce@apache.org/msg08126.html\">11.0.0-M5</a>\"、<a href=\"https://www.mail-archive.com/announce@apache.org/msg08128.html\">10.1.8</a>\"、<a href=\"https://www.mail-archive.com/announce@apache.org/msg08122.html\">9.0.74</a>\"和<a href=\"https://www.mail-archive.com/announce@apache.org/msg08127.html\">8.5.88</a>\"的点版本。四个版本都有的显著变化包括：将maxParameterCount的默认值从10000减少到1000；修正了<a href=\"https://bz.apache.org/bugzilla/show_bug.cgi?id=66442\">Bug 66442</a>\"修复中的回归，即没有响应体的流在完成时不会减少活动流计数，导致某些连接出现ERR_HTTP2_SERVER_REFUSED_STREAM；实现RFC 9239，<a href=\"https://datatracker.ietf.org/doc/html/rfc9239\">更新ECMAScript媒体类型</a>\"，其中JavaScript的MIME类型更改为text/javaScript。要了解关于这些版本的更多细节，请查看<a href=\"http://tomcat.apache.org/tomcat-11.0-doc/changelog.html\">11.0.0-M5</a>\"、<a href=\"https://tomcat.apache.org/tomcat-10.1-doc/changelog.html\">10.1.8</a>\"、<a href=\"https://tomcat.apache.org/tomcat-9.0-doc/changelog.html\">9.0.74</a>\"和<a href=\"https://tomcat.apache.org/tomcat-8.5-doc/changelog.html\">8.5.88版</a>\"本的发布说明。</p><p>&nbsp;</p><p></p><h4>Ktor</h4><p></p><p></p><p>JetBrains<a href=\"https://blog.jetbrains.com/ktor/2023/04/18/ktor-2-3-0-released/\">发布</a>\"了<a href=\"https://ktor.io/\">Ktor</a>\" 2.3.0，这是一个用于创建微服务和Web应用程序的异步框架。该版本带来了一些改进和修复，包括：支持在定义路由时使用正则表达式；放弃支持将在Kotlin 1.9.0（即将发布）中删除的遗留JS编译器；支持Apache 5和Jetty 11；支持套接字的结构化并发性。要了解关于该版本的更多细节，请查看<a href=\"https://ktor.io/changelog/2.3/#version-2-3-0\">发布说明</a>\"。</p><p>&nbsp;</p><p></p><h4>JHipster</h4><p></p><p></p><p>JHipster团队<a href=\"https://twitter.com/pascalgrimaud/status/1649282351262826496?cxt=HHwWgIC8le3jtuMtAAAA\">发布</a>\"了<a href=\"https://www.jhipster.tech/jhipster-lite/\">JHipster Lite</a>\" 0.32.0，其中有许多依赖项升级，并带来了一些显著的变化，如：通过将spring.jpa.properties.hibernate.cache.use_second_level_cache属性设置为true来支持Hibernate二级缓存；删除执行npm run lint命令时不必要的警告；删除运行npm t命令时不必要的堆栈跟踪信息。要了解关于该版本的更多细节，请查看<a href=\"https://github.com/jhipster/jhipster-lite/releases/tag/v0.32.0\">发布说明</a>\"。</p><p>&nbsp;</p><p></p><h4>JBang</h4><p></p><p></p><p>JBang 0.106.3<a href=\"https://github.com/jbangdev/jbang/releases/tag/v0.106.3\">发布</a>\"，修复了ChatGPT在坏键或使用限制上出错的问题。</p><p>&nbsp;</p><p></p><h4>Gradle</h4><p></p><p></p><p>Gradle 8.1.1<a href=\"https://github.com/gradle/gradle/releases/tag/v8.1.1\">发布</a>\"，修复了一些Bug，包括：当探测一个在<a href=\"https://docs.gradle.org/8.1.1/userguide/configuration_cache.html\">配置缓存</a>\"中存储了大量lambdas的类时，会出现MethodTooLargeException；使用Gradle 8.1构建的Kotlin DSL预编译脚本插件不能与Gradle的其他版本一起使用；Gradle 8.1在buildSrc中为Kotlin配置的freeCompilerArgs方法会破坏构建，提供无用的错误信息。要了解关于该版本的更多细节，请查看<a href=\"https://docs.gradle.org/8.1.1/release-notes.html\">发布说明</a>\"。</p><p>&nbsp;</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/04/java-news-roundup-apr17-2023/\">https://www.infoq.com/news/2023/04/java-news-roundup-apr17-2023/</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/OoCiOPX0mArJd8ozFbWW\">Java 近期新闻：JEP for JDK 21、MicroStream 成为 Eclipse 项目、Helidon、Piranha、Gradle 8.1</a>\"</p><p><a href=\"https://www.infoq.cn/article/gB3ToN16f0iPC3tvdpDZ\">Java 近期新闻：字符串模板、Quarkus、Open Liberty、PrimeFaces、JobRunr、Devnexus 2023</a>\"</p>",
    "publish_time": "2023-05-11 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "软件架构会走向哪里 ？ ｜QCon",
    "url": "https://www.infoq.cn/article/Piv7iBXVxwlvzBrkP1OO",
    "summary": "<p>软件架构的发展大致经历了从单体架构、垂直架构、SOA架构到微服务架构的过程。下一代的软件架构会是什么？架构又会向什么方向演进？在 5月25-26日 QCon全球软件开发大会（广州站）上，我们策划了【<a href=\"https://qcon.infoq.cn/2023/guangzhou/track/1513\">下一代软件架构</a>\"】专题，邀请了阿里云分布式事务产品负责人，Seata 开源项目创始人季敏（清铭），为我们对议题分享质量进行把控。于此同时，我们也邀请了多位专家来分享他们的技术实践，下面是详细介绍：</p><p>&nbsp;</p><p><a href=\"https://qcon.infoq.cn/2023/guangzhou/presentation/5281\">季敏（清铭）</a>\"，阿里云分布式事务产品负责人，Seata 开源项目创始人，将为我们带来题为《下一代微服务架构的实践与探索》的演讲。他将分享阿里巴巴在微服务架构领域的实践经验和未来发展方向，包括微服务架构在阿里巴巴电商中的实践、开源生态的发展和下一代微服务架构的探索；</p><p>&nbsp;</p><p><a href=\"https://qcon.infoq.cn/2023/guangzhou/presentation/5280\">韩聪聪</a>\"，美团履约平台技术专家，将为我们带来题为《美团履约平台调度引擎架构》的演讲。他将从履约调度的业务场景出发，阐述美团调度系统相关的技术方案及选型。他将分享如何提升算力天花板，通过算力的提升支持算法更大的寻优解空间，实现履约调度系统的高吞吐，并在此基础上能够同时完成缩减成本，降本增效，提升计算效能；</p><p>&nbsp;</p><p><a href=\"https://qcon.infoq.cn/2023/guangzhou/presentation/5274\">蔡东赟</a>\"，腾讯高级工程师，将为我们带来题为《零信任安全架构实践》的演讲。他将介绍零信任安全催生的业务背景，落地的通用模型架构，落地场景用户访问服务资源的场景风险、服务场景场景风险。他将分享用户访问服务资源的实践，腾讯的业务背景，解决方案思路以及实现架构技术详解；</p><p>&nbsp;</p><p><a href=\"https://qcon.infoq.cn/2023/guangzhou/presentation/5263\">李杨</a>\"，平安资管科技平台交易系统团队开发组负责人，将为我们带来题为《平安资管投资交易系统架构变革之路》的演讲。他将分享平安资管内部投资交易团队在架构变革过程中如何拆分不同的阶段、采用螺旋式的方式升级的原因、以及如何融合即有的服务、保证架构变革的计划稳步推进等；</p><p>&nbsp;</p><p><a href=\"https://qcon.infoq.cn/2023/guangzhou/presentation/5272\">伍活欣</a>\"，大参林医药集团股份有限公司信息中心部门总监，将为我们带来题为《大参林 POS 系统的稳定性优化实践》的演讲。他将分享大参林如何在基础架构薄弱且历史技术债务沉重的基础下，顺利地对一个“庞然大物”进行技术加固，并最终过渡到完全的自研和自主可控。他将分享他们是如何通过管理加固和技术加固结合，实现了上万家门店的实时监控，实现了机房云端双活，整体稳定性提升了 12 倍的；</p><p>&nbsp;</p><p><a href=\"https://qcon.infoq.cn/2023/guangzhou/presentation/5273\">周健</a>\"，虎牙中间件负责人，将为我们带来题为《虎牙多云接入实践》的演讲。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/71/71f5301fc9a144e9e58437a087e03ec6.png\" /></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/b8/b8232038724456793b8dd97709c83ed2.png\" /></p><p>&nbsp;</p><p>更多精彩议题持续上线中...</p><p>&nbsp;</p><p>活动推荐：</p><p>&nbsp;</p><p>在5月25-26日，QCon全球软件开发大会（广州）站即将落地，在此峰会上，共有十二个专题，近五十余场分享。其中包括稳定性即生命线、编程语言实战、DevOps vs 平台工程、AGI 与 AIGC 落地、下一代软件架构、数据驱动业务、出海的思考、云成本优化、现代数据架构、AIGC浪潮下的效能智能化、新型数据库、大前端技术探索。欢迎与你一起交流，更多详细信息可扫描下方海报二维码了解。</p><p></p><p><img src=\"https://static001.infoq.cn/resource/image/3c/a0/3c21d43ec150b044a957aabd296833a0.jpg\" /></p><p></p><p></p>",
    "publish_time": "2023-05-11 10:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "蚂蚁数科开发者大会 2023 元宇宙分论坛",
    "url": "https://www.infoq.cn/article/Bxv8ajbHmZTMR0lZmak8",
    "summary": "<p>创新技术与数字经济的发展加速渗透融合，产业应用驱动科技加速变迁和跃升，技术探索者迎来黄金时代。</p>\n<p>我们看到，以CHATGPT为代表的AI技术已经无处不在；元宇宙的沉浸感即将成为现实；依托WEB3和区块链技术的应用，越来越多的去中心化产品和服务涌现出来…数字技术的融合创新发展，为产业数字化带来无限的想象力。</p>\n<p>为此，蚂蚁集团数字科技事业群携手广大同行者，于2023 年4 月 26 日在杭州举办的数字科技开发者大会，邀请到学术界、产业界多位技术领袖及众多WEB3、元宇宙等技术方向的开发者，围绕数据要素市场趋势研判、WEB3前瞻技术探索、元宇宙创新体验等热点话题展开讨论。</p>",
    "publish_time": "2023-05-11 10:49:47",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "谷歌发布大语言模型PaLM 2对抗GPT-4，生成式AI融入谷歌搜索，急切反击背后，搜索摇钱树要倒？",
    "url": "https://www.infoq.cn/article/M4oBLcDHp7reGbveMud8",
    "summary": "<p></p><p>今年的谷歌I/O大会，又名“我们超级嫉妒ChatGPT”大会。</p><p></p><h2>下一代大语言模型PaLM 2</h2><p></p><p></p><p>在本届I/O开发者大会上，谷歌发布了其最新大语言模型（LLM）PaLM 2。</p><p></p><p>PaLM 2将成为谷歌Bard聊天机器人的全新底层模型，代表搜索巨头直面OpenAI&nbsp;ChatGPT的挑战。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/cc/cc09637c4696593a29a4fef96c6db0de.png\" /></p><p></p><p>此外，谷歌此次公布的大部分新型AI功能也都将基于PaLM 2实现。PaLM 2现可通过谷歌PaLM API、Firebase和Colab向开发人员开放。</p><p></p><p>与OpenAI类似，谷歌并没有介绍这套下一代模型的过多训练技术细节，甚至未提到参数规模（PaLM 2拥有5400亿参数）。</p><p></p><p>会上，谷歌唯一公布的技术细节就是PaLM 2构建在最新的JAX和TPU v4基础设施之上。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/97/97e4e4796905cce968e6dbd80fb591f6.png\" /></p><p></p><p>DeepMind副总裁Zoubin&nbsp;Ghahramani在正式揭幕前的新闻发布会上表示，“我们在工作中发现，模型的大小并不是决定性因素——不是说模型越大，效果就越好。因此，我们才提供一系列不同规模的模型。我们认为参数规模并不能作为把握模型性能的正确方法，其能力还是要由模型的使用者自行判断，包括确定这些模型在具体使用场景中是否有用。”</p><p></p><p>于是乎，谷歌公司决定全力提升模型的性能表现，尤其很多功能直指GPT-4的痛点。</p><p></p><p>谷歌发现，新模型更擅长常识推理、数学和逻辑。根据Ghahramani的介绍，谷歌公司利用大量数学/科学文本和数学表达式对模型进行了训练。大家知道，主要通过自然语言训练而成的大语言模型在不借助第三方插件的情况下，几乎很难搞定数学问题。但谷歌表示PaLM 2能够轻松解决数学难题，完成推理任务甚至生成相应图表。</p><p></p><p>PaLM 2还改进了代码编写和调试能力。 该模型使用20种编程语言进行训练，包括JavaScript和Python等流行语言，也包括Prolog、Verilog和Fortran等早期语言。PaLM 2作为基础模型托起了Codey——谷歌专为编程和调试打造的专用模型。在本次发布会上，谷歌表示Codey将作为代码补全和生成服务的一部分与用户见面。</p><p></p><p>谷歌今天还强调，PaLM 2使用一套涉及100多种语言的语料库训练而成。用谷歌的话说，这使得它“擅长多语言任务”，包括处理以往模型难以把握的微妙措辞。</p><p></p><p>谷歌将PaLM视为一个模型家族，其下涵盖Codey和Med-PaLM 2（专注于医学知识的模型）等模型。另外还有专注于安全用例的Sec-PaLM，还有能在智能手机上运行的小型PaLM 2模型。后续谷歌可能还会向更多强调隐私的用例开放PaLM，但此次没有给出任何确切时间表。谷歌表示这套小模型每秒能够处理20个token，虽然不是很快，但对某些用例来说已经可以接受（谷歌没有提到是在哪款机型上进行的测试）。</p><p></p><p>谷歌公司亲口承认，他们在发布AI功能时一直采取相当慎重的方式。 谷歌各位代表也一直在强调，谷歌公司希以负责任的态度构建这些工具，并始终将安全性放在首位。PaLM家族自然也不例外。</p><p></p><h2>AI “霸屏”，谷歌一口气发布25款全新AI产品</h2><p></p><p></p><p>这妥妥是一场AI技术和产品“霸屏”的发布会。</p><p></p><p>谷歌在I/O开发者大会上公布了25款全新AI产品，其中也对核心搜索业务在AI推动下的变化简单做了展示。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/a1/a1dabfef432ed985415b040570785db3.png\" /></p><p></p><p>众所周知，现在全球围绕着“生成式AI”和大模型的AI竞赛正在日趋白热化。这场发布会的核心亮点包括：</p><p></p><p>“搜索生成体验”将传统搜索与AI聊天体验相结合，后续将很快作为“搜索实验室”（Search Labs）中的部分功能推出，让客户尝试其“实验性”产品。**谷歌推出了其最新的AI模型PaLM 2。**这套模型接受学术研究论文、医学文本和100多种语言素材的训练，负责为谷歌的新型AI产品提供支持。谷歌对标ChatGPT的竞争产品Bard最终将登陆Gemini。Gemini是谷歌DeepMind正在开发的一套新的大语言模型。谷歌正在将新的AI模型整合至Google Workspace产品当中，包括Docs和Sheets。届时，客户将能够根据Google Slides中的文本创建图像，并通过描述任务内容（例如规划一次假期出行）制作出电子表格。在Google Doc中，用户可以写下想要创建的内容的简短描述，PaLM 2将为您补全其余部分文本。在整个产品线中，谷歌还公布了面向计算机程序员的新AI协作工具，能够帮助他们加快编程速度并将结果导出至Replit等其他软件开发工具。谷歌CEO桑达尔·皮查伊在I/O开发者大会的舞台上表示，“我们正在以一种大胆且负责的方式，重新构想我们的所有核心产品，包括搜索业务。”</p><p></p><h2>生成式AI加入谷歌搜索</h2><p></p><p>发布会上，谷歌推出了一款AI驱动的搜索引擎，其总体目标是“让搜索更智能，让搜索更简单”。</p><p></p><p>这款搜索引擎现可接收用户输入的提示词，整个使用过程更趋近人们在现实生活中的问询过程。而在我们熟悉的搜索结果列表之上，将出现由AI针对用户问题生成的概括性回答。</p><p></p><p>谷歌高管Cathy Edwards在大会上指出，不同于以往直接搜索“哪个国家公园最好玩”的用法，现在用户可以像跟朋友聊天那样询问Google引擎哪处公园更适合带小孩和遛狗。例如，用户向搜索引擎提问，“对于带3岁以下小孩和宠物狗出行的家庭来说，布莱斯峡谷公园和拱门国家公园哪个更适合？”</p><p></p><p>Edwards强调，“虽然问题本身没有变化，但以往的搜索引擎可能没法直接消化完整的查询。用户会把它拆分成多个更小的部分、筛选信息，然后再自行拼凑起来——现在，搜索功能本身将为您搞定这些麻烦。”</p><p></p><p>Edwards将谷歌生成的摘要称为“AI驱动的快照，能帮助您快速了解关于某个主题的概况。”摘要中将包含来源链接，用户可以选择不同的查看格式来进一步剖析摘要背后的来源。AI生成的摘要还提供可点击的建议问题以鼓励交互，整个体验跟AI聊天机器人颇为相似。</p><p></p><p>AI驱动的定制化结果，也有望重塑消费者的线上购物体验。例如，谷歌在演示中询问了关于适合日常出行的自行车款式，结果不仅包含指向自行车商品的链接、价格和评论，还提供关于适合特定用途的自行车建议，以及理想车型应当具备的几大特点。Edwards提醒观众，在AI生成的摘要下方仍然保留了传统的搜索结果列表，继续将用户引导至已发布的原始内容处。她认为正是这种可溯源性，帮助维持着“网络的蓬勃发展”。</p><p></p><p>搜索生成体验未来将登陆美国用户的Chrome桌面，还有Android和iOS系统上的Google App，且仅提供英文版本。谷歌表示将在未来几周开放测试邀请，感兴趣的朋友可以点击此处申请（<a href=\"http://labs.google.com/search\">http://labs.google.com/search</a>\"）。</p><p></p><p>这里推荐Geekflare上发表的一篇文章（<a href=\"https://geekflare.com/generative-ai-search/\">https://geekflare.com/generative-ai-search/</a>\"），其中解释了部分AI基本术语，对传统搜索与生成式搜索的工作原理进行细分。</p><p></p><h2>生成式AI加持下的搜索和Bard是两款互补产品</h2><p></p><p></p><p>很多朋友可能奇怪，谷歌不是已经搞了生成式AI机器人Bard了吗？</p><p></p><p>确实，但Bard是Bard，跟Google搜索不是一码事。</p><p></p><p>Bard是独立的聊天机器人系统，一直在bard.google.com这块小空间里圈地自萌。如果说Bard是谷歌对ChatGPT的回应，那Google.com上面向数十亿日常用户的生成式搜索就是谷歌对Bing的回应。</p><p></p><p>谷歌之所以没有立即将Bard集成进Google搜索，原因在于：</p><p></p><p>1）谷歌对生成式AI一直持谨慎态度；</p><p></p><p>2）生成式AI的大规模运行成本极高。</p><p></p><p>因此，谷歌方面采取了缓动、观望的态度，这跟微软正好相反。总之在Google.com上，“搜索生成体验”将仅仅是“搜索实验室”（Search Labs）功能中的一个设置选项。</p><p></p><p>搜索生成体验的基本思路，就是在搜索结果之前通过大量文本尝试解答用户的问题。在谷歌的演示中，搜索页面中那熟悉的蓝色链接消失不见——用户必须向下滚动才能看到它们。有时候，AI生成结果上方甚至还有广告，这就把原始链接挤到了更靠下的位置。</p><p></p><p>虽然尚处于实验阶段，但谷歌最新布的“搜索生成体验”显然就是其核心搜索业务的未来发展方向。</p><p></p><p>**但谷歌仍在谨慎行事，想要保护其搜索广告业务。**于是新产品还是延续了之前的广告运作方式：搜索一款产品，结果中会夹杂着AI输出和广告内容。</p><p></p><p>谷歌搜索业务副总裁Cathy Edwards在接受采访时表示，“我认为只要用户想要做出购买决定，只要用户在做出购买决定时还需要推荐选项，那广告就仍有存在的空间。”</p><p></p><p>之所以这套广告系统仍然存在，是因为谷歌在勉力维持。它的AI模型会将答案限制成高度结构化的格式，这样才能给结果中插入的广告预留空间。</p><p></p><p>当用户想要更好的聊天体验时，谷歌希望他们能选择ChatGPT的竞争对手Bard，这边有更完整的对话体验，也有大语言模型仍解决不了的“一本正经胡说八道”。</p><p></p><p>Edwards强调，“我们认为搜索和Bard是两款互补的产品，分别对应不同的用途。我们真正关注的不是怎样把聊天机器人硬塞进去，而是着眼于全世界每天有大量用户使用的产品，思考如何利用生成式AI把它变得更好。”</p><p></p><h2>“急切”的创新：ChatGPT 横空出世，搜索摇钱树要倒？</h2><p></p><p></p><p>谷歌本该在几年前就发布其中某些产品。搜索巨头掌握着业内最优秀的部分AI人才（虽然一部分已经离开谷歌自立门户），并在该领域中取得了开创性的发现，包括让ChatGPT成为可能的transformer模型。</p><p></p><p>但谷歌却坚持把AI藏在幕后，甚至因此在消费级聊天这场竞赛中被对手甩开。</p><p></p><p>这个原因并不难理解：谷歌的核心搜索业务太棒了，根本不容颠覆。其母公司Alphabet上个季度的“搜索和其他收入”约为400亿美元，占公司总收入的近60%。我们甚至可以说，谷歌对于搜索广告的依赖比苹果对iPhone的依赖还要强。</p><p></p><p>所以除非市场发生根本性变化，否则Alphabet绝对不会主动去破坏这块甜美可口的蛋糕。</p><p></p><p>但随着消费者倾心于ChatGPT，用自然语言跟软件直接交流、获取回应迅速成为业界主流。相比之下，在搜索栏里输入关键字就像老掉牙的落后产物。所以谷歌要么提供类似的新一代体验，要么就眼睁睁看着消费者转向别处。但无论如何，谷歌似乎都有可能永远失去过往的辉煌——Perplexity等初创公司就在尝试订阅搜索模式，而且跟谷歌以往的搜索广告业务大不相同。</p><p></p><p>Alphabet多年来坐拥一棵几乎无需竞争的摇钱树，在顺风顺水之下拿点闲钱出来搞创新，包括Waymo机器人出租车和生物技术垂直项目Calico。但如今，他们必须把最优秀的资源集中起来重塑谷歌的核心业务。</p><p></p><h2>AI迎来指数级进步，但谷歌等巨头已创新乏力？</h2><p></p><p>风险投资人士Chamath&nbsp;Palihapitiya在最近的“All-In”播客中表示，在AI迅速进步的背景下，他怀疑包括谷歌在内的多家科技巨头已经不具备相应的创新能力。“他们的成长方式并不依靠创新。</p><p></p><p>看看谷歌、Facebook、微软还有苹果，谁还记得他们最后一次完成巨大的颠覆性创新是什么时候？似乎2010年之后就很少了。虽然他们偶尔也想做点有机创新，但往往不知道该如何正确分配资本。”</p><p></p><p>另外，值得注意的是，本届I/O大会可谓“正值风雨飘摇之时”。据《华盛顿邮报》报道，谷歌公司今年1月刚刚解雇了1.2万名员工，如今谷歌内部可谓气氛紧张，人人自危。</p><p></p><p>参考链接：</p><p></p><p><a href=\"https://www.semafor.com/article/05/10/2023/googles-ai-search-is-over\">https://www.semafor.com/article/05/10/2023/googles-ai-search-is-over</a>\"</p><p></p><p><a href=\"https://techcrunch.com/2023/05/10/google-launches-palm-2-its-next-gen-large-language-model/\">https://techcrunch.com/2023/05/10/google-launches-palm-2-its-next-gen-large-language-model/</a>\"</p><p></p><p><a href=\"https://arstechnica.com/gadgets/2023/05/google-finally-demos-generative-ai-in-search-with-a-waitlist-starting-today/\">https://arstechnica.com/gadgets/2023/05/google-finally-demos-generative-ai-in-search-with-a-waitlist-starting-today/</a>\"</p>",
    "publish_time": "2023-05-11 11:22:57",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "责任链模式在复杂数据处理场景中的实战",
    "url": "https://www.infoq.cn/article/29c191a5ec143ed5867addcb3",
    "summary": "<p>作者：黄维杰</p><p></p><p></p><blockquote>相信大家在日常的开发中都遇到过复杂数据处理和复杂数据校验的场景，本文从一线开发者的角度，分享了责任链模式在这种复杂数据处理场景下的实战案例，此外，作者在普通责任链模式的基础上进行了升级改造，可以适配更加复杂的应用场景，希望可以让读者对于设计模式-责任链模式有更深刻的印象。</blockquote><p></p><p></p><p></p><h1>一、什么是责任链模式</h1><p></p><p></p><p></p><h2>1.1&nbsp;概念</h2><p></p><p></p><p>责任链模式让多个对象都有机会处理同一个请求。它将请求的发送者和处理者之间进行解耦，同时将这些处理者对象连成一条链，并沿着这条链传递该请求，满足条件的处理者会执行相应的逻辑直至走完整个链条。</p><p></p><p></p><h2>1.2&nbsp;应用场景</h2><p></p><p></p><p>如果在一次请求中，需要多个处理者处理多种复杂的逻辑，且希望能够解耦多个处理者，实现高扩展性，可以考虑使用责任链模式。</p><p></p><p></p><h1>二、Servlet中的过滤器(Filter)和过滤器链(FilterChain)</h1><p></p><p></p><p></p><h2>2.1&nbsp;概念</h2><p></p><p></p><p>Filter和FilterChain是【责任链模式】的一种热门应用场景，过滤器Filter相信大家都很熟悉了，我们在Servlet中经常能发现它的身影。</p><p></p><p>【Filter】一般用于Servlet处理之前做一些前置的校验，每个Filter都有自己的职责和逻辑。调用filter时，需要传入当前filterChain的引用，来告诉filter当前执行的是哪一个filterChain。</p><p></p><p><code lang=\"null\">public interface Filter {\n    //初始化方法\n    public void init(FilterConfig filterConfig) throws ServletException;\n    //处理逻辑，\n    public void doFilter(ServletRequest request, ServletResponse response,\n            FilterChain chain) throws IOException, ServletException;\n    //生命周期销毁\n    public void destroy();\n}</code></p><p></p><p>【FilterChain】是由多个Filter组成的链条，如果在链上的filter校验通过或处理完成，那么调用\"chain.doFilter(request, response)\"就可以让下一个filter继续执行逻辑直到filterChain结束</p><p></p><p><code lang=\"null\">public interface FilterChain {\n    public void doFilter(ServletRequest request, ServletResponse response)\n            throws IOException, ServletException;\n}</code></p><p></p><p></p><h2>2.2&nbsp;在Servlet中的拦截过程</h2><p></p><p></p><p>请求资源时，过滤器链中的过滤器依次对请求进行处理，并将请求传递给下一个过滤器，直到最后将请求传递给目标资源。发送响应信息时，则按照相反的顺序对响应进行处理，直到将响应返回给客户端。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e9/e9d6a60ffe6a1661902365370554d2e8.png\" /></p><p></p><p></p><h2>2.3&nbsp;启发</h2><p></p><p></p><p>Servlet中的责任链模式给我们展示的是利用Filter和FilterChain来过滤和拦截请求；我们在复杂的业务场景中是否也能模仿来实现一个业务处理的责任链呢？</p><p></p><p>我们可以发现，Filter与Filter之间是互相解耦的，我们可以很轻量级的加入一个新的Filter到FilterChain当中；</p><p></p><p>此外，我们还可以实现多个FilterChain，其中装载不同的Filter来适配多种业务场景。</p><p></p><p></p><h1>三、业务场景应用案例</h1><p></p><p></p><p></p><h2>3.1&nbsp;业务场景</h2><p></p><p></p><p>在电商平台的很多业务场景下，涉及到对于数据的多重校验或多重过滤等操作。而随着业务的增长，校验逻辑或者数据处理逻辑会变得越来越复杂，这个时候责任链模式就能够体现出很好的优势了。</p><p></p><p>拿创建优惠券活动来举例；用户可以自由选择某些类目、某些商品或者某些门店来参与券活动；并且可以按需导入或者选择自己需要参与活动的数据；</p><p></p><p>【系统需要校验用户上传的数据是否满足业务条件、并将校验失败的数据返回给客户】</p><p></p><p></p><h2>3.2&nbsp;复杂点</h2><p></p><p></p><p>根据上述业务场景，在一次请求中，我们需要做多种校验逻辑：</p><p></p><p>数据鉴权校验、过滤用户无权限的数据。若用户选择商品，需对商品类型进行校验；（电商的商品模型有很多种，每一种商品模型都对应一种校验规则）。若用户选择门店，需对门店类型进行校验；（电商的门店类型也有很多，比如线上门店、旗舰店、线下门店等等，需要判断门店是否能够参与优惠活动）。对于不同投放渠道也有不同渠道的校验规则。我们需要完整的走完所有校验逻辑，而不能因为中途的一个逻辑校验不通过而阻断校验，因为我们需要返回给用户一个完整的数据校验结果；举个例子，如果用户上传的商品当中，既存在无权限的商品，又存在不符合商品类型的数据，那么我们需要走完所有校验逻辑，一并给用户返回所有的报错，而不是只返回无权限的商品。其他校验规则……</p><p></p><p>如果不使用设计模式</p><p></p><p>如果使用流水式代码，将会显得很臃肿，且有很多if else……嵌套，让人很难看懂和维护。如下：</p><p></p><p><code lang=\"null\">//校验数据\nif (用户选择商品) {\n        if (商品模型一) {\n        //校验逻辑1\n      } else if (商品模型二) {\n        //校验逻辑2\n      } else if (商品模型三) {\n        //校验逻辑3\n      } else {\n        //校验逻辑4\n      }\n} else if (用户选择门店) {\n        if (门店模型一) {\n            //校验逻辑1\n          } else if (门店模型二) {\n            //校验逻辑2\n          }\n  //校验逻辑……\n} else if (用户选择类目) {\n  //校验逻辑……\n}\n//校验渠道\nif (渠道是A渠道){\n​\n} else if (渠道是B渠道){\n​\n}</code></p><p></p><p>上述伪代码仅仅只覆盖了几种简单的校验场景；试想就算开发完成之后，如果下次再有一个业务逻辑校验需要加入进来，则对代码需要进行很大的改动，需要重新梳理if else的逻辑，缺乏代码的可读性和可拓展性。</p><p></p><p>如果使用责任链模式</p><p></p><p>我们可以遵守单一职责原则，定义多个Filter对象，每个对象实现自己的业务校验逻辑；同时主干代码上仅需要初始化一个FilterChain，并调用doFilter方法执行链上每一个filter即可。</p><p></p><p></p><h2>3.3&nbsp;使用责任链模式+改进</h2><p></p><p></p><p>参照Servlet的filter与filterChain接口【见2.1】，实现了多种不同的过滤器，也在其基础上结合业务需求进行了相应的改进：</p><p></p><p>定义AbstractOrderFilter抽象类</p><p></p><p>让Filter对象具备顺序属性，初始化FilterChain的时候，可以按顺序排列filter；同时定义accept方法，让filter自行控制是否处理请求。</p><p></p><p><code lang=\"null\">@Data\npublic abstract class AbstractOrderFilter implements Filter, Comparable {\n    protected Integer order;\n    @Override\n    public int compareTo(AbstractOrderFilter o) {\n        return getOrder().compareTo(o.getOrder());\n    }\n    //根据Filter自己使用的业务场景，自行定义\n    public boolean accept(FilterRequestDTO filterRequestDTO) {\n        return true;\n    }\n    @Override\n    public void doFilter(FilterRequestDTO filterRequestDTO, FilterChain filterChain) {\n    }\n}</code></p><p></p><p>继承AbstractOrderFilter，遵守单一职责原则，实现多种Filter</p><p></p><p>举例：定义一个ItemPermissionFilter，专门做商品权限校验。</p><p></p><p><code lang=\"null\">@Slf4j\npublic class ItemPermissionFilter extends AbstractOrderFilter {\n    //当前filter对应的业务逻辑manager（自行根据业务场景定义）\n    ItemCheckManager itemCheckManager;\n    //构造器私有\n    private ItemPermissionFilter(Integer order, ItemCheckManager itemCheckManager) {\n        super.order = order;\n        this.itemCheckManager = itemCheckManager;\n    }\n    @Override\n    public void doFilter(FilterRequestDTO filterRequestDTO, FilterChain filterChain) {\n        if (accept(filterRequestDTO)) {\n          //业务逻辑对应的manager进行校验处理（不做展开）\n            itemCheckManager.checkItemPermission(filterRequestDTO, elementCheckResults);\n        }\n        //继续走责任链的下一个filter\n        filterChain.doFilter(filterRequestDTO);\n    }\n    @Override\n    public boolean accept(FilterRequestDTO filterRequestDTO) {\n        //自行根据业务场景定义处理何种请求\n        return true;\n    }\n    //对外暴露的create方法\n    public static ItemPermissionFilter create(Integer order, ItemCheckManager itemCheckManager) {\n        return new ItemPermissionFilter(order, itemCheckManager);\n    }\n}</code></p><p></p><p>定义CouponFilterChain实现filterChain接口，定义对于内部filter的处理逻辑</p><p></p><p>注意其中几个属性:</p><p></p><p>filters：是filterChain当中的filter集合。posLocal：是一个ThreadLocal变量，记录着当前filterChain执行到了第几个filter的index。checkResult：也是一个ThreadLocal变量，它记录着全局所有Filter的校验结果，每执行一个filter，filter就会把当前的执行结果记录在该变量中，之后会统一返回给用户，大大减少了参数的传递复杂度。</p><p></p><p><code lang=\"null\">public class CouponFilterChain implements FilterChain {\n    /**\n     * 责任链中的所有的处理组件 非变量\n     */\n    private final List<!--? extends AbstractOrderFilter--> filters;\n    /**\n     * 当前执行到的位置 这是个共享变量\n     */\n    private static ThreadLocal posLocal = ThreadLocal.withInitial(() -&gt; 0);\n​\n    /**\n     * 责任链的校验结果--即需要给用户反馈的校验结果，共享变量，threadLocal，会作为全局参数\n     */\n    public static final ThreadLocal&gt; checkResult = new ThreadLocal&lt;&gt;();\n​\n    /**\n     * 包含filter数量 非变量\n     */\n    private final int size;\n​\n    @Override\n    public void doFilter(FilterRequestDTO filterRequestDTO) {\n      //共享变量记住当前filterChain执行的filter的index，直至结束\n        Integer pos = posLocal.get();\n        if (pos &lt; size) {\n            pos++;\n            posLocal.set(pos);\n            Filter filter = this.filters.get(pos - 1);\n            filter.doFilter(filterRequestDTO, this);\n        }\n    }\n​\n    //供外部业务代码调用的主要方法\n   public BaseResult process(FilterRequestDTO filterRequestDTO) {\n        this.doFilter(filterRequestDTO);\n        //将共享变量里面的结果取出来，返回给用户\n        return BaseResult.makeSuccess(checkResult.get(););\n    }\n​\n    @Override\n  //注意避免ThreadLocal内存泄漏，要remove\n    public void reset() {\n        posLocal.remove();\n        posLocal.set(0);\n        checkResult.remove();\n    }\n​\n    public CouponFilterChain(List<!--? extends AbstractOrderFilter--> filters) {\n        filters.sort(AbstractOrderFilter::compareTo);\n        this.filters = filters;\n        this.size = filters.size();\n    }\n}</code></p><p></p><p>责任链初始化 — 根据业务场景自行拼接filter</p><p></p><p>在实现好了Filter已经FilterChain之后，我们需要对他们进行初始化，这个时候就可以根据所需要的业务场景自行组装filter到filterChain当中; 有多种初始化方法，下面只简单介绍一种（将商品filter和门店filter初始化）。</p><p></p><p><code lang=\"null\">@Component\n@Slf4j\npublic class FilterChainManager {\n    @Resource\n    StoreManager storeManager;\n    @Resource\n    ItemManager itemManager;\n​\n    private CouponFilterChain couponFilterChain;\n​\n    //初始化责任链\n    @PostConstruct\n    private void init() {\n        //总链\n        List filters = new ArrayList&lt;&gt;();\n        //按需添加链上的filter……\n        //商品校验filter\n        filters.add(ItemFilter.create(100, ItemManager));\n        //门店校验filter\n        filters.add(StoreFilter.create(200, StoreManager));\n        this.couponFilterChain = new CouponFilterChain(filters);\n    }\n​\n   //供外部调用的方法\n   public BaseResult process(FilterRequestDTO filterRequestDTO) {\n        BaseResult result = null;\n        try {\n            //责任链模式，校验每一个参数的合法性并输出错误原因\n            result = couponFilterChain.process(filterRequestDTO);\n            return result\n        } catch (Exception e) {\n            return TMPResult.failOf(\"system error\", e.getMessage());\n        } finally {\n            //这里非常重要 必须重置\n            if (couponFilterChain != null) {\n                couponFilterChain.reset();\n            }\n        }\n    }\n}</code></p><p></p><p>到此我们已经实现了责任链模式，可以画个图理解一下：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/f1/f1085817e2db97360dafcebb0b283be0.png\" /></p><p></p><p></p><p>拓展 —&nbsp;组合过滤器CompositeFilter + FilterChain</p><p></p><p>有时候我们的filter当中可能需要加上一些子处理，为了遵守单一职责原则，不适合将这些业务逻辑放在同一个filter中，于是考虑将多个filter合并组合成一个大的Filter; SpringMVC还有一种过滤器叫做组合过滤器CompositeFilter，过滤器里面嵌套过滤器，使得整个处理过程更加有层次；参照org.springframework.web.filter.CompositeFilter，自己定义了一个CompositeFilter。</p><p></p><p><code lang=\"null\">/**\n * 合成的过滤器，改过滤器内部由多个过滤器组合而成\n */\npublic class CompositeFilter extends AbstractOrderFilter {\n    /**\n     * 所有的责任事件\n     */\n    private List<!--? extends AbstractOrderFilter--> filters = new ArrayList();\n​\n    public CompositeFilter(Integer order, List<!--? extends AbstractOrderFilter--> filters) {\n        super.order = order;\n        this.filters = filters;\n    }\n​\n    @Override\n    public void doFilter(FilterRequestDTO filterRequestDTO, FilterChain filterChain) {\n        (new InnerFilterChain(filterChain, this.filters)).doFilter(filterRequestDTO);\n    }\n​\n    /**\n     * 内部链处理逻辑，优先将合成过滤器的内部过滤器进行处理，然后再传给下一个过滤器\n     */\n    private static class InnerFilterChain implements FilterChain {\n        private final FilterChain originalChain;\n        private final List<!--? extends AbstractOrderFilter--> additionalFilters;\n        private int currentPosition = 0;\n​\n        public InnerFilterChain(FilterChain chain, List<!--? extends AbstractOrderFilter--> additionalFilters) {\n            this.originalChain = chain;\n            this.additionalFilters = additionalFilters;\n        }\n​\n        @Override\n        public void doFilter(FilterRequestDTO filterRequestDTO) {\n            if (this.currentPosition &gt;= this.additionalFilters.size()) {\n                //如果已经执行完了内部过滤器，则跳到外部继续执行外部下一个节点的过滤器\n                this.originalChain.doFilter(filterRequestDTO);\n            } else {\n                //继续执行内部过滤器\n                this.currentPosition++;\n                AbstractOrderFilter currentFilter = this.additionalFilters.get(this.currentPosition - 1);\n                currentFilter.doFilter(filterRequestDTO, this);\n            }\n​\n        }\n​\n        @Override\n        public void reset() {\n​\n        }\n    }\n​\n    public static CompositeFilter create(Integer order, List<!--? extends AbstractOrderFilter--> filters) {\n        filters.sort(AbstractOrderFilter::compareTo);\n        return new CompositeFilter(order, filters);\n    }\n}</code></p><p></p><p>实现了组合过滤器之后，可以将其与FilterChain结合; 示意图如下图所示，在一条责任链上可以有普通的Filter和CompositeFilter，当执行到B时，按照B内部的顺序，从内部子filterB1执行开始一直到B4，直到执行完整个组合责任链然后再执行C，依次类推。可以看出CompositeFilter让整个责任链模块化，模块与模块之间能够各司其职，模块内部也能按照自定义的顺序执行。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/9b/9be205e1871f5fcae183a74da45b2787.png\" /></p><p></p><p></p><p></p><h1>四、思考</h1><p></p><p></p><p>本文实现的责任链仅供参考，大家可以结合自己的业务场景定义合适的FilterChain和Filter；与Servlet中的Filter不同的是，本文中定义的Filter只有一个入参FilterRequestDTO，而是将response作为了ThreadLocal共享变量，大家使用时也一定要注意内存泄漏的风险。</p><p></p><p>其实不需要FilterChain，我们只需要使用一个List并保留Filter与Filter之间的引用关系即可，如一个Filter的next指针指向下一个Filter；定义FilterChain的原因我想也是开发者考虑到封装和更好的变化。</p><p></p><p>如果直接上手阅读源码，很容易被层层的方法带乱自己的阵脚；带着问题和目的去阅读和学习源码是一件事半功倍的事情，会让你在学习过程中有一条清晰明朗的线。</p>",
    "publish_time": "2023-05-11 10:57:01",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "蚂蚁数科开发者大会 2023 Web3分论坛",
    "url": "https://www.infoq.cn/article/WV5qN6rac6hfkzvi3wHL",
    "summary": "<p>创新技术与数字经济的发展加速渗透融合，产业应用驱动科技加速变迁和跃升，技术探索者迎来黄金时代。</p>\n<p>我们看到，以CHATGPT为代表的AI技术已经无处不在；元宇宙的沉浸感即将成为现实；依托WEB3和区块链技术的应用，越来越多的去中心化产品和服务涌现出来…数字技术的融合创新发展，为产业数字化带来无限的想象力。</p>\n<p>为此，蚂蚁集团数字科技事业群携手广大同行者，于2023 年4 月 26 日在杭州举办的数字科技开发者大会，邀请到学术界、产业界多位技术领袖及众多WEB3、元宇宙等技术方向的开发者，围绕数据要素市场趋势研判、WEB3前瞻技术探索、元宇宙创新体验等热点话题展开讨论。</p>",
    "publish_time": "2023-05-11 12:38:27",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "一部手机就可运行，精通Python等20种语言！谷歌终于能与OpenAI 打擂台了，全新PaLM 2比肩GPT-4",
    "url": "https://www.infoq.cn/article/8rtmSJNmCIZauii2I7ju",
    "summary": "<p>&nbsp;</p><p>“也许这有点不合常理，但这是我很长时间以来看到的最好的谷歌I/O。”有开发者对昨晚如期而至的谷歌I/O 2023大会作出了如此评价，“我知道今年人工智能将受到极大关注，但我仍对许多新功能以及这些集成发生的速度感到惊喜。”</p><p>&nbsp;</p><p>在这次I/O大会上，谷歌试图向大众呈现出自己与OpenAI抗衡的实力：发布了与GPT-4对打的PaLM 2、Bard 进化后向所有人开放、移动端也可以用AI新功能等等。正如谷歌首席执行官<a href=\"https://blog.google/technology/ai/google-io-2023-keynote-sundar-pichai/#ai-products\">Sundar Pichai </a>\"说的，谷歌正在重构自己的所有核心产品，包括搜索。</p><p></p><h2>与 GPT-4 对打的PaLM 2</h2><p></p><p>&nbsp;</p><p>毫无疑问，被寄予厚望的PaLM 2成为这次大会的亮点之一。PaLM 2 是⼀种基于<a href=\"https://www.infoq.cn/article/ZG3J9h*cW7mJAK0NXwos\"> Transformer </a>\"的模型，使⽤类似于 UL2 的混合⽬标进⾏训练。</p><p>&nbsp;</p><p>谷歌于 2022 年 4 月首次宣布推出 PaLM 模型。PaLM 的应用在这一年取得了很大的进展，今年 3 月，该公司推出了一款适用于 PaLM 的 API 以及一系列人工智能企业工具，帮助企业“通过简单的自然语言提示生成文本、图像、代码、视频、音频等”。这次大会上，Pichai 宣布推出 PaLM 2 预览版本，改进了数学、代码、推理、多语言翻译和自然语言生成能力。</p><p>&nbsp;</p><p></p><h4>多语言能力</h4><p></p><p>&nbsp;</p><p>谷歌声称，PaLM 2 是一种最先进的语言模型，具有改进的多语言、推理和编码功能。PaLM 2在所有数据集上都优于PaLM，并取得了与GPT-4竞争的结果。</p><p>&nbsp;</p><p>之前的大型预训练语言模型通常使用以英语文本为主的数据集，谷歌设计了一个更多语言和多样化的预训练混合模型，扩展到数百种语言和领域（例如编程语言、数学和并行多语言文档）。更大的模型可以处理更多不同的非英语数据集，而不会导致英语语言理解性能的下降，并应用重复数据删除来减少记忆。</p><p>&nbsp;</p><p>PaLM 2 在多语言文本方面接受了更多的训练，涵盖 100 多种语言，显着提高了其在多种语言中理解、生成和翻译细微差别文本（包括成语、诗歌和谜语）的能力。根据基准测试，对于具有思维链prompt或自洽性的MATH、GSM8K和MGSM基准评估，PaLM 2的部分结果超越了GPT-4。</p><p><img src=\"https://static001.geekbang.org/infoq/b8/b8334d6edc70a0bafc5f30d02eb6fef6.png\" /></p><p>PaLM 2 还通过了“精通”级别的高级语言能力考试。其中，PaLM 2的日语水平达到了A级，而PaLM是F级。PaLM 2的法语水平达到了C1级。</p><p><img src=\"https://static001.geekbang.org/infoq/bf/bf2ea28d4bfb652cd557bdb6589bc653.png\" /></p><p></p><p>PaLM 2 和 PaLM 在最新的专业语⾔能⼒考试中的表现</p><p>&nbsp;</p><p>不仅如此，PaLM 2 还了解重要的语言细微差别。在一篇描述 PaLM 2 功能的研究论文中，谷歌工程师声称该系统的语言熟练程度“足以教授该语言”，并指出这是由于其训练数据中非英语文本更为普遍。</p><p><img src=\"https://static001.geekbang.org/infoq/89/89f17e81c395b308497340180f2fa81a.png\" /></p><p></p><p>PaLM 2 的广泛数据集包括科学论文和包含数学表达式的网页，因此它还展示了逻辑、常识推理和数学方面的改进能力。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/a1/a1d9ec23e05878dfc8b8a326ee9923e5.png\" /></p><p></p><p>PaLM 2 推理能力示例</p><p></p><h4>支持20 种编程语言</h4><p></p><p>&nbsp;</p><p>PaLM 2 还改进了对编写和调试代码的支持。该模型使用 20 种编程语言进行了训练，包括 JavaScript 和 Python 等流行语言，还包括 Prolog、Verilog 和 Fortran 等语言。PaLM 2 构成了 Codey 的基础，Codey 是谷歌用于编码和调试的专业模型，它也作为其代码完成和生成服务的一部分推出。</p><p>&nbsp;</p><p>代码语⾔模型是当今最具经济意义和被⼴泛部署的 LLM 之⼀。为了在开发⼈员⼯作流程中进⾏低延迟、⾼吞吐量部署，谷歌通过在扩展的、代码密集型、多语⾔的数据混合上继续训练 PaLM 2-S 模型，构建了⼀个⼩型的、特定于编码的 PaLM 2 模型，谷歌将⽣成的模型称为PaLM 2-S* 。</p><p>&nbsp;</p><p>PaLM 2-S* 在大量公开可用的源代码数据集上进行了预训练。它擅长 Python 和 JavaScript 等流行的编程语言，但也可以生成 Prolog、Fortran 和 Verilog 等语言的专用代码。</p><p>&nbsp;</p><p>PaLM 2-S*在除了两种语言之外的所有语言上都优于PaLM，同时在像Julia和Haskell这样的低资源语言上几乎没有下降。例如，PaLM 2-S*在Haskell上比更大的PaLM-Coder-540B提高了6.3倍，在Julia上提高了4.7倍。值得注意的是，Java、JavaScript 和 TypeScript 的性能实际上比原始语言Python更高。</p><p><img src=\"https://static001.geekbang.org/infoq/b8/b862c67d755179a9ebd061178ceb5888.png\" /></p><p>PaLM 2 可以跨编程和自然语言生成代码和自然语言。大会上，Pichai 还展示了在修改代码Bug后，PaLM 2 给出的韩语评论。</p><p></p><p>谷歌内部已经有超过 70 个产品团队正在使用 PaLM 2 构建产品，包括分别针对安全知识和医疗知识微调而成的 Sec-PaLM 和 Med-PaLM 2。</p><p>&nbsp;</p><p>其中，Sec-PaLM 是专注于安全用例的版本，使用 AI 帮助分析和解释具有潜在恶意脚本的行为，并检测哪些脚本对个人或组织构成威胁。Med-PaLM 2是基于健康数据训练的版本，可以轻松通过美国医学执照考试，达到“专家”水平。</p><p></p><h2>不需要云，一部手机即可</h2><p></p><p>&nbsp;</p><p>Hoffmann等人提出的计算最优缩放（Compute-optimal scaling）表明，数据大小至少与模型大小同等重要。谷歌在对更大的计算量进行验证后，同样发现数据和模型大小应该大致按 1：1 缩放，以实现给定训练量的最佳性能计算（与过去趋势相反，过去趋势将模型扩展的速度比数据集快3倍)。</p><p>&nbsp;</p><p>谷歌表示，模型缩放并不是提⾼性能的唯⼀⽅法。相反，可以通过细致的数据选择和⾼效的架构/⽬标来释放性能。此外，更⼩但质量更⾼的模型显着提⾼了推理效率，降低了服务成本，并使模型的下游应⽤能够为更多的应⽤程序和用户服务。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/3f/3f4112574b5181a42cc4c5ee4957e371.png\" /></p><p></p><p>PaLM 2比PaLM存储的训练数据更少</p><p>&nbsp;</p><p>与其他需要大量时间和资源来创建的大型语言模型一样，PaLM 2 与其说是一个产品，不如说是一个产品系列。</p><p>&nbsp;</p><p>PaLM 2包含了4个不同参数的模型，包括壁虎（Gecko）、水獭（Otter）、野牛（Bison）和独角兽（Unicorn），并在特定领域的数据上进行了微调，为企业客户执行某些任务。这意味着用户不用花费大量的时间和资源来创建模型，直接部署即可。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/19/1937b734b3859cb76bd79057e3e3fb6c.png\" /></p><p></p><p>&nbsp;其中，Gecko 非常轻巧，可以在移动设备上工作，每秒可以处理20个token，大约每秒16或17个单词，即使在离线时也能在设备上运行出色的交互式应用程序。Gecko 不需要用户在云工作，也不需要特别强大的硬件，一个完全移动的手机芯片组就足够了。</p><p>&nbsp;</p><p>“我们在工作中发现，并不是模型越大越好。”DeepMind 副总裁 Zoubin Ghahramani 说道，“这就是为什么我们提供了一系列不同尺寸的模型。实际上，参数规模并不是一种判断模型能力的有效方法，能力实际上是由使用模型的人来判断的，并确定它们在模型实现测试中是否有用。”</p><p>&nbsp;</p><p>谷歌没有说明使用什么硬件来测试这个模型，只是说它在“最新的手机上”运行。然而，将语言模型的小型化意义重大。这样的系统在云端运行的成本很高，在本地使用可以减少成本。另外，还可以改善隐私等。不过问题在于，较小版本的语言模型不可避免地不如它们的较大版本。</p><p>&nbsp;</p><p>另外大会上，谷歌还推出了个性化Android 手机的新方法，包括 Magic Compose、Cinematic Wallpaper 和 Generative AI Wallpaper。其中，Magic Compose 是由生成式 AI 提供支持的Google Messages新功能，会根据消息的上下文提供回复建议，甚至会将用户写的内容转换为不同的风格。&nbsp;下一代移动操作系统 Android 14 将支持这些新功能。</p><p>&nbsp;</p><p>PaLM 2 现在可通过 Google 的 PaLM API、Firebase 和Colab提供给开发人员。借助 PaLM 2，谷歌希望缩小公司与微软等竞争对手之间的“人工智能差距”，否则可能会被认为实施其 AI 研究的速度缓慢。</p><p>&nbsp;</p><p>在 Google Brain 和 DeepMind 合并之后，谷歌新的大模型也在研发当中。Pichai 表示，现在谷歌的研究重心正在转向 Gemini，这是一种多模态和高效的机器学习工具。</p><p></p><h2>Bard 的进化</h2><p></p><p>&nbsp;</p><p>在谷歌内部内，PaLM 2 已经被用于支持 25 种功能和产品，包括该公司的实验性聊天机器人 Bard。Bard 在图像功能、编码功能和应用程序集成等方面都做了大幅更新。</p><p>&nbsp;</p><p>Bard 将更加直观地响应用户问题。比如对于“新奥尔良有哪些必看景点？”之类的问题，除了文本之外，用户还将看到丰富的图片视觉效果。用户还可以在自己的要求中附加图像和文本：</p><p></p><p>&nbsp;</p><p>编程方面，谷歌也将开发人员的反馈整合到了一些关键的编码升级中，包括：</p><p>&nbsp;</p><p>来源引用：从下周起，代码引用将更加精确。如果 Bard 引入了一段代码或引用了其他内容，只需单击注释，Bard 就会在相应内容下划线并链接到源代码。深色主题：这是开发人员要求的另一项功能，谷歌希望以此让开发人员更轻松地与Bard 互动。“导出”按钮：谷歌即将与合作伙伴 Replit 一起推出导出和运行代码的功能，首先会从 Python 开始。</p><p>&nbsp;</p><p>另外，由于人们经常要求 Bard 抢先起草电子邮件和文档，谷歌大会上推出了两个导出操作，用户可以轻松将 Bard 的回复直接转移到 Gmail 和 Docs 中。</p><p>&nbsp;</p><p>继微软5 月 4 日宣布公司旗下基于 ChatGPT-4 的 Bing Chat 功能面向所有用户开放后，谷歌在本次大会上也宣布，Bard 将并向 180 多个国家和地区开放，其他更多国家和地区也将陆续开放。Bard 现在有日语和韩语版本，谷歌表示很快就会支持 40 种语言。</p><p>&nbsp;</p><p></p><h2>结束语</h2><p></p><p>&nbsp;</p><p>“作为 AI-first 公司，我们的旅程已经有七年了，我们正处于一个激动人心的转折点。”Pichai 说道，“AI 的转变与它来时一样大，没有一家公司可以单独做到这一点。我们的开发者社区将是释放未来巨大机遇的关键。”</p><p>&nbsp;</p><p>PaLM 2 无疑是谷歌在 AI 语言模型方面迈出的重要一步，但它面临着更广泛的、该类技术普遍存在的挑战。</p><p>&nbsp;</p><p>例如，一些专家质疑用于创建语言模型的训练数据的合法性。这些数据通常是从互联网上抓取的，通常包括受版权保护的文本和盗版电子书。创建模型的科技公司通常拒绝回答他们从何处获取训练数据的问题。谷歌在其对 PaLM 2 的描述中延续了这一传统，仅指出该系统的训练语料库由“一组不同的来源组成：网络文档、书籍、代码、数学和对话数据”，但没有提供更多细节。</p><p>&nbsp;</p><p>语言模型的输出也存在一些固有问题，例如“虚假”，或者这些系统倾向于简单地编造信息。谷歌研究副总裁 Zoubin Ghahramani在接受外媒采访时表示，在这方面，PaLM 2 是对早期模型的改进，“从某种意义上说，我们正在投入大量精力来不断改进基础和归因指标”，但他也指出，整个领域在打击人工智能产生的虚假信息方面“还有很长的路要走”。</p><p>&nbsp;</p><p>虽然很多开发者很开心看到谷歌的发布成果，但部分人还是对“实际用起来是否会像谷歌宣传的那样的好”保持怀疑。相信我们会很快看到这个问题的答案。</p><p>&nbsp;</p><p>&nbsp;</p><p>参考链接：</p><p><a href=\"https://ai.google/static/documents/palm2techreport.pdf\">https://ai.google/static/documents/palm2techreport.pdf</a>\"</p><p><a href=\"https://blog.google/technology/ai/google-io-2023-keynote-sundar-pichai/#ai-responsibility\">https://blog.google/technology/ai/google-io-2023-keynote-sundar-pichai/#ai-responsibility</a>\"</p><p><a href=\"https://www.theverge.com/2023/5/10/23718046/google-ai-palm-2-language-model-bard-io\">https://www.theverge.com/2023/5/10/23718046/google-ai-palm-2-language-model-bard-io</a>\"</p>",
    "publish_time": "2023-05-11 12:56:53",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]