[
  {
    "title": "Azure Cosmos DB的MongoDB Intra-Account集合复制功能开始公共预览",
    "url": "https://www.infoq.cn/article/s7kxks1tjUbaNEXsNRgP",
    "summary": "<p>微软最近推出了针对 <a href=\"https://learn.microsoft.com/zh-cn/azure/cosmos-db/mongodb/introduction\">Azure Cosmos DB for MongoDB</a>\" 的 <a href=\"https://learn.microsoft.com/zh-cn/azure/cosmos-db/intra-account-container-copy\">Intra-Account Collection Copy</a>\"的公共预览版，允许用户在同一帐户内复制集合，并提供了强大的数据管理和迁移能力。</p><p>&nbsp;</p><p><a href=\"https://learn.microsoft.com/zh-cn/azure/cosmos-db/introduction\">Azure Cosmos DB</a>\"&nbsp;是一个全面托管的 NoSQL 数据库，针对 NoSQL 工作负载支持多种 API，例如 MongoDB 和 Apache Cassandra，包括本机 NoSQL 和兼容 API。此外，该服务还<a href=\"https://www.infoq.com/news/2022/10/azure-cosmosdb-postgresql-ga/\">支持 PostgreSQL 的关系型工作负载</a>\"。</p><p>&nbsp;</p><p>去年，该公司首次<a href=\"https://devblogs.microsoft.com/cosmosdb/copy-container-preview/\">引入</a>\"了Intra-account容器复制作业的预览功能，以允许用户使用Azure CLI为Azure Cosmos DB的Core（SQL）API和Cassandra API创建容器的离线副本。Azure Cosmos DB现在还具有针对MongoDB的Intra-Account集合复制功能，根据该公司的说法，\"使用户能够以离线方式在同一Azure Cosmos DB账户内复制集合\"。</p><p>&nbsp;</p><p>Cosmos DB中的帐户包含所有Azure Cosmos DB资源：数据库、容器和项目。当<a href=\"https://learn.microsoft.com/en-us/azure/cosmos-db/nosql/quickstart-portal\">创建帐户</a>\"时，用户可以选择MongoDB API。随后，他们可以添加数据库和<a href=\"https://learn.microsoft.com/en-us/azure/cosmos-db/mongodb/how-to-create-container\">集合</a>\"（容器）。在帐户中，用户可以创建多个集合。</p><p>&nbsp;</p><p>使用 MongoDB 帐户复制集合的功能可以帮助数据迁移，比如当数据发生变化且现有的 <a href=\"https://learn.microsoft.com/zh-cn/azure/cosmos-db/mongodb/indexing#indexing-for-mongodb-server-version-36-and-higher\">分片键</a>\" 不再有效时。用户可以在新集合上选择另一个分片键，并使用集合复制迁移数据。另一个用例是通过定义新的唯一键索引策略并使用集合复制将数据迁移到新集合以更新容器的 <a href=\"https://learn.microsoft.com/zh-cn/azure/cosmos-db/unique-keys\">唯一键索引</a>\" 。</p><p>&nbsp;</p><p>用户可以<a href=\"https://learn.microsoft.com/en-us/azure/cosmos-db/intra-account-container-copy#api-for-mongodb\">注册预览功能</a>\"，并通过CLI安装<a href=\"https://learn.microsoft.com/azure/cosmos-db/how-to-container-copy#install-the-azure-cosmos-db-preview-extension\">Azure Cosmos DB预览扩展</a>\"来迁移集合或数据库。接下来，选择他们想要复制数据的源集合和目标集合，然后从Azure CLI<a href=\"https://learn.microsoft.com/azure/cosmos-db/how-to-container-copy#create-intra-account-container-copy-job-for-api-for-mongodb-account\">开始集合复制操作</a>\"。最后，用户可以<a href=\"https://learn.microsoft.com/azure/cosmos-db/how-to-container-copy#monitor-the-progress-of-a-container-copy-job\">监视进度</a>\"。</p><p>&nbsp;</p><p>这是一个在Azure Cosmos DB的MongoDB账户中复制容器的作业：</p><p><code lang=\"sql\">az cosmosdb dts copy `\n    --resource-group $resourceGroup `\n    --account-name $accountName `\n    --job-name $jobName `\n    --source-mongo database=$sourceDatabase collection=$sourceCollection `\n    --dest-mongo database=$destinationDatabase collection=$destinationCollection</code></p><p></p><p>许多其他云数据库服务都支持MongoDB。其中一个是<a href=\"https://www.mongodb.com/products/platform/cloud\">MongoDB Atlas</a>\"，MongoDB自己的完全托管的云数据库服务。这个数据库服务还支持从一个数据库迁移到另一个数据库，类似于Cosmos DB针对MongoDB的最新功能Inter-Account Collection copy。使用MongoDB Atlas，用户可以将数据从现有的MongoDB部署、JSON或CSV文件导入到Atlas中的部署，<a href=\"https://www.mongodb.com/docs/atlas/import/\">可以选择使用Atlas协助的实时迁移，或者使用工具进行自主迁移</a>\"，将数据从他们现有的部署迁移到Atlas中。</p><p>&nbsp;</p><p>最后，这份<a href=\"https://learn.microsoft.com/en-us/azure/cosmos-db/intra-account-container-copy#supported-regions\">文档</a>\"提供了支持该功能的Azure区域列表。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/09/azure-cosmos-intra-account-copy/\">Intra-Account Collection Copy in Azure Cosmos DB for MongoDB in Public Preview (infoq.com)</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/0HLeJbIogjXgqZ8bbCJj\">分布式PostgreSQL基准测试：Azure Cosmos DB、CockroachDB和YugabyteDB</a>\"</p><p><a href=\"https://www.infoq.cn/article/u6hQhlyfAGp1k8MLyErM\">Azure与OpenAI联手，为政府机构提供人工智能解决方案</a>\"</p>",
    "publish_time": "2023-09-09 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "打爆React泡沫，重新审视前端技术选择",
    "url": "https://www.infoq.cn/article/SMRLqjxuNkWgQKW1SMbH",
    "summary": "<p>&nbsp;</p><p></p><blockquote>在上一篇文章<a href=\"https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247522110&amp;idx=1&amp;sn=6954030dbfcec1dd631a71e598dca9de&amp;chksm=f952227dce25ab6b4eb71c41bbcef37fe2416b08142e594e017891054b2af259be749440846c&amp;token=1500496419&amp;lang=zh_CN#rd\">“我从“过时”的 React 开发中汲取经验教训”</a>\"中，作者认为许多经常使用 React 的人并未充分意识到它在某些方面已经落后了。总结了 React “泡沫” 的问题以及超越现状的一些思考，本篇作者给出了一些替代选择。</blockquote><p></p><p>&nbsp;</p><p></p><h2>如果React真的已经过时，那有什么靠谱的替代方案吗？</h2><p></p><p>&nbsp;</p><p>我给大家介绍几种，包括相关用例。React的一大核心问题，就是它总想大包大揽、满足开发者的所有&nbsp;需求。但这样一把瑞士军刀，在很多方面肯定是及不上专款专用的独立工具。</p><p>&nbsp;</p><p>在开始介绍之前，我再简单提两点：</p><p>接下来列出的选项，主要涵盖了我之前提到的几种现代框架。我并不是要建议大家学习或者使用全部这些框架。如果非要选择一种，那Svelte或者Vue都是可以的。总之，我把它们都列出来只是为了讨论更全面，不是说都得学。这里的推荐肯定有所遗漏，其他的方案还有很多。</p><p>例如，我忽略了Ember和Angular，因为它们的岁数比React还大。而且在基准测试中，它们的性能一般也不会显著优于React。</p><p>&nbsp;</p><p>我还忽略了Alpine和Petite&nbsp;Vue这类轻量级选项，因为它们更多是jQuery的替代品、跟React关系不大。它们的最大用途，就是在不想用框架这类笨重技术时顶上。</p><p>&nbsp;</p><p>最后，我还忽略了其他一些优秀的相关工具。比如说Eleventy，其实它更像一种纯粹的静态站点生成器，而不能称为真正的框架（但如果你正好在用Gatsby，那Eleventy确实要更胜一筹）。</p><p>&nbsp;</p><p>总之，大家把这份推荐当成一份“旅游小攻略”就行，要求别太严格。</p><p></p><h2>Svelte（我的个人最佳）</h2><p></p><p></p><p>女士们、先生们，2023年最佳前端框架奖得主：Svelte！</p><p>&nbsp;</p><p>如果非要选择一种框架来推荐，那我的答案就是Svelte。</p><p>&nbsp;</p><p>打趣地讲，要说谁能出手把把React彻底打扒，那我派出的最佳选手就是Svelte。我一直觉得Svelte就是“那个做对了的React，不玩任何虚的”。正如我2019年发推文所说，也许这种说法最初看起来像开玩笑，但随着时间推移，它正变得越来越准确。</p><p>&nbsp;</p><p>Svelte使用起来非常简单，相对易于学习（毕竟大家已经掌握React了，而且二者的语法也很相似），在几乎任何情况下性能都更好。React能做到的，Svelte几乎都能做到。</p><p>&nbsp;</p><p>Svelte速度很快，基本能跟性能最强的框架相媲美。它的开发体验也很出色，在开发者满意度调查上经常名列前茅。</p><p>&nbsp;</p><p>Svelte还尽可能贴近Web平台，所以尽管它非常强大，其概念也不会太过偏离普通开发者的认知。Svelte还包含transitions、easings、CSS处理、component-scoped样式等更多开箱即用的方便功能。</p><p>&nbsp;</p><p>说了这么多，大家肯定觉得Svelte会相当臃肿。但情况并非如此，它并不是JavaScript运行时，而只是编译器。在构建期间，大家用不上的东西都会被剥离出去，代码则被转译成普通JavaScript。也就是说，Svelte的捆绑包只相当于React的几分之一。</p><p>&nbsp;</p><p>虽然Svelte的使用感受很像是框架，但它在本质上只是个小型、相当优雅的HTML超集，具有令人身心愉悦的简单语法，而且可以编译成快速、小巧的捆绑包。</p><p>&nbsp;</p><p>Svelte自己的元框架SvelteKit也相当通用且强大，可支持静态、服务器端、边缘部署甚至是每路由混合。它在2022年迎来了1.0版本，已经为生产应用做好了充分准备。（它还得到了Next.js开发商Vercel的支持。）</p><p>&nbsp;</p><p>SVELTE适用于：</p><p>打算重新探索前端开发的乐趣，需要全面且优质选项的前端开发者。</p><p>&nbsp;</p><p>SVELTE能够替代：</p><p>大家在React上完成的全部工作。Svelte对应替代React本体，SvelteKit则功能完备，足以替代Next、Tasby及、或Remix（甚至全盘接手）。</p><p></p><h2>Vue</h2><p></p><p></p><p>Vue可能是跟React最为相近的选项，背后的生态系统规模也堪称业界第二。但它的性能要比React好得多，而且更注重UI。</p><p>&nbsp;</p><p>在某些方面，Vue可以算是React的最小提升版。现在，Vue 3中甚至直接提供类似于hooks的方法。但Vue使用的是更接近默认HTML，而非JSX的模板语言，这使得在模板文件中编写条件与循环变得更轻松，不必借助map和三元组等变通方法。</p><p>&nbsp;</p><p>Vue的Nuxt元框架跟Next类似，也一直受到良好的维护并随时添加新功能。Vue的“电池”也比React更丰富，包括开箱即用的scoped CSS处理和简单的transitions/animations选项。</p><p>&nbsp;</p><p>VUE适用于：</p><p>对于社区规模、整体框架流行度比较看重；希望保留React的使用感受，但需要更多“电池”或类HTML特征；强调框架独立性，不希望工具被单一大公司拥有的前端开发者。</p><p>&nbsp;</p><p>VUE能够替代：</p><p>React本体；Nuxt元框架则能全面替代各种Next用例。</p><p>&nbsp;</p><p></p><h2>Solid</h2><p></p><p></p><p>Solid就是我理想中React的样子，各方面都做得更好。如果不认真分辨，大家甚至感受不出它跟React有什么不同——只是性能要强得多。实际上，Solid也是运行速度最快的框架选项之一。</p><p>&nbsp;</p><p>Solid本质上以React为起点，之后重新做了设计规划，消除了复杂性、性能问题和大量样板。Solid还提出了Signals的概念，消除了组件渲染和生命周期方面最让人头痛的混乱和陷阱。甚至可以这样说，Solid就是符合现代构建理念的React，基于2013年以来前端社区积累下的种种经验和教训。</p><p>&nbsp;</p><p>Solid还提供自己的元框架SolidStart，只是目前还处于beta测试阶段。Solid的本体已经足够成熟、可堪大用，而且背后的支持力量也绝对令人印象深刻。</p><p>&nbsp;</p><p>SOLID适用于：</p><p>比较喜欢React（和JSX），但希望获得更现代、更快且/或更简单的使用体验，而且把性能当作头等大事的前端开发者。</p><p>&nbsp;</p><p>SOLID能够替代：</p><p>React和ReactDOM。SolidStart未来也有可能取代Next，但截至本文撰稿时，它仍处于beta测试阶段。</p><p>&nbsp;</p><p></p><h2>Fresh</h2><p></p><p></p><p>Fresh是一套基于Deno的“孤岛”式架构服务器端渲染前端框架，而且比推荐清单里的其他项目都要年轻一些。它最大的特点就是全面拥抱最小化JS，“孤岛”式设计也逾期能够运行在边缘位置上。也就是说，其服务器代码运行更快、更安全、默认使用TypeScript，而且Deno相较于传统Node也有自己的优势（比如更易用，提供第一方linting、测试和代码格式化设置等）。</p><p>&nbsp;</p><p>Fresh的每个组件要么经过静态渲染，要么在响应时作为HTML交付（不涉及任何JavaScript），也就是所谓“孤岛”。它只会在客户端上渲染。当然，大家也可以需求进行混合和匹配。因为Fresh运行在Deno之上，所以能够支持速度极快的动态内容，保证这些内容在任意位置的任何设备上快速加载完成。</p><p>&nbsp;</p><p>Fresh使用Preact，所以速度肯定差不了。如果大家用惯了React，上手不会太大。而且再次强调：Deno上的构建体验真的太棒了。</p><p>&nbsp;</p><p>FRESH适用于：</p><p>喜欢在云上托管全球可用的服务器端应用，希望只交付最小化JavaScript，且/或乐于尝试最新技术的前端开发者。</p><p>&nbsp;</p><p>FRESH:能够替代：</p><p>React中的Remix，Fresh可能也是最接近的替代方案。</p><p>&nbsp;</p><p></p><h2>Astro</h2><p></p><p></p><p>Astro属于下一代高性能静态网站生成器，而且适用范围远不止于静态开发。Astro也是这份推荐清单中最年轻的选项之一，目前已经拥有非常稳定的1.0版本，并在技术社区中赢得了广泛赞誉和接纳。</p><p>&nbsp;</p><p>作为新一代SSG构建方案（React的粉丝们有福了，它也支持JSX和MDX），Astro现可提供动态服务器端功能。我绝对建议大家用它替代Gatsby开发各种内容密集型或静态网站。</p><p>&nbsp;</p><p>它还有自己的杀手级功能：Astro默认不发送JavaScript，大家只须选择自己真正想用的要素。</p><p>Astro还能兼容大家想用的一切前端框架，所以如果各位想要用React、Vue、Svelte或者其他框架作为模板，也完全没有问题！</p><p>&nbsp;</p><p>ASTRO适用于：</p><p>打算构建主要基于静态内容或者Markdown的网站（包括一些服务器端渲染或逻辑）、想把发布的JavaScript控制在最低程度，而且打算沿用自己熟悉的前端框架的前端开发者。</p><p>&nbsp;</p><p>ASTRO能够替代：</p><p>Gatsby，或者其他基于React的类似内容工具。</p><p>&nbsp;</p><p></p><h2>Preact</h2><p></p><p></p><p>如果大家长期生活在React的世界里，那应该或多或少听说过Preact。这里再具体解释一下：Preact是React的轻量化、高速度版本。虽然它在诞生之初主要作为React的替代方案，但如今已经拥有不少React所不具备的优越特性（比如我们前文提到过的Signals）。</p><p>&nbsp;</p><p>PREACT适用于：</p><p>还想坚持使用React，但希望运行速度更快的前端开发者。</p><p>&nbsp;</p><p>PREACT能够替代：</p><p>React。（事实上，Preact就是React开头加个P，而P代表的就是性能。当然，这都是我自己臆想出来的，Preact团队可没这么说。）</p><p>&nbsp;</p><p></p><h2>Qwik</h2><p></p><p></p><p>Qwik使用一种新的水合与性能优化方法，在服务器端渲染React类代码（JSX）。但准确来说，它的处理方式并不能真正称为“水合”；相反，它是把JavaScript序列化到DOM当中，并在需要时做最小加载。Qwik在这份推荐清单中比较有深度的选项，特别适合需要处理大量交互且重视运行速度的开发场景。</p><p>&nbsp;</p><p>QWIK适用于：</p><p>需要向浏览器发送大量JavaScript，而且希望显著提升性能水平的前端开发者。</p><p>&nbsp;</p><p>QWIK能够替代：</p><p>React本体，可以在边缘设备上高效运行。</p><p>&nbsp;</p><p></p><h2>Web组件库</h2><p></p><p></p><p>关于这个问题，本文不会谈得太深。而且坦白讲，我并不是这方面的专家、缺少Web组件或者Web组件框架的深厚使用经验，所以没办法把这个问题讲好、讲透。</p><p>&nbsp;</p><p>总而言之，有一些项目可以从Web组件框架/库中获益，包括Lit、Stencil、Polymer等各种库。这些库能帮助大家实际编写Web组件，而不用在特定的前端框架内生成“专有”组件。由此生成的组件可以被移植到任何Web项目中并顺利起效。</p><p>&nbsp;</p><p>在我看来，大多数项目最适合的肯定还是前端框架，而不是纯Web组件——或者至少是二者相结合。也许未来的情况会有转变，但就目前来看，我认为多数情况下纯Web组件的方法仍然不足以支撑多数项目需求。</p><p>&nbsp;</p><p>当然，也有一些用例需要考虑基于纯Web组件的方法。对于这类项目来说，React绝对有点“杀鸡用牛刀”了，这时候选择前面提到的Web组件库明显更为合适。</p><p>&nbsp;</p><p>WEB组件库适用于：</p><p>需要在多个环境中重用相同组件，希望在未来的开发中避免受到框架变化的影响，或者只是想立足前端平台、并愿意承担Web组件固有劣势的前端开发者。</p><p>&nbsp;</p><p>WEB能够替代：</p><p>React，但也许只能替代一部分，具体要由大家的用例而定。</p><p>&nbsp;</p><p></p><h2>写在最后</h2><p></p><p></p><p>撰写本文的同时，我正巧要转向全职React开发工作，自然有理由再跟大家聊聊自己的体会。</p><p>&nbsp;</p><p>经过思考，我发觉React能够如此流行，很大程度上就是因为人们不愿再跨出这片舒适区。</p><p>&nbsp;</p><p>React肯定不是最好的前端框架，但大多数人需要的也从来不是最好的；只要足够好，足够好就行了。（我们是人，而人的决策总会掺杂很多个人的、情感的、非理性的因素。每个人都是如此，这倒没啥问题。）</p><p>&nbsp;</p><p>我们似乎都在跳跃式地采用技术，而非遵循线性的发展原则，至少在前端领域是这样的。于是乎，大多数人之所以义无反顾地跳上React这辆大车，原因就是当时的开发者已经被陈旧的技术折磨得苦不堪言，忙于找寻能帮自己逃离苦海的抓手。我们并没有小心谨慎、按部就班地推进转型（这也可能是因为当时根本就没有这么个选项），而是直接从上个时代的方案一口气冲到了这个时代。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/53/53985efd1611ce3f686047b3895a8bfc.png\" /></p><p></p><p>&nbsp;</p><p>但问题是，自从多年前迈出那一步之后，我们又长期待在原地、不愿继续前进了。</p><p>&nbsp;</p><p>而现在的我有种感觉：下一次飞跃已经为期不远。</p><p>&nbsp;</p><p>我不知道下一次飞跃会是什么、因为什么，但我发现大家感受到的很多问题在React中其实找不到答案。这种感觉跟当初使用jQuery的时候很相似。所以我认为大家最终会擦亮双眼，意识到是时候迈出下一步了。</p><p>&nbsp;</p><p>那新的抓手会是什么？我不知道。也许就是套Web平台，甚至到那个时候我们连框架都不需要了。当然，它也可能是套更强大的框架，强大到超出我们迄今为止的想象。也许它甚至不会独立存在，而是体现为大量工具的多样性，不再围绕广泛接受的单一标准展开（当然，在这几种选项中第三点是可能性最低的，因为我们人类就是一群忙碌的猴子，而且特别喜欢别人塞给我们现成的答案）。</p><p>&nbsp;</p><p>唯一可以肯定的，就是随着时间的持续推移，React跟那个理想状态间的差距也在越拉越大。</p><p>所以我们身处的每一天，都比前一天更值得去探索自己在前端开发中究竟错过了什么。</p><p>&nbsp;</p><p>感谢大家腾出时间，听取我的一点胡言乱语。</p><p></p><h5>参与链接：</h5><p></p><p></p><p><a href=\"https://joshcollinsworth.com/blog/antiquated-react#part-2-things-you-forgot-or-never-knew-because-of-react\">https://joshcollinsworth.com/blog/antiquated-react#part-2-things-you-forgot-or-never-knew-because-of-react</a>\"</p><p></p><p></p><h5> 相关阅读：</h5><p></p><p><a href=\"https://xie.infoq.cn/article/3e10ee935ffd1b23b1ecd8842\">看透 react 源码之感受 react 的进化</a>\"</p><p><a href=\"https://xie.infoq.cn/article/9d8a9c2ca82a82fdb098ee31b\">前端开发框架 React 技术如何与小程序结合，进行页面构建</a>\"</p><p><a href=\"https://xie.infoq.cn/article/7c17044e7d4827b37bfd698cb\">React 源码分析 1-jsx 转换及 React.createElement</a>\"</p><p><a href=\"https://xie.infoq.cn/article/958fbe57ff88cdba990d99739\">手写一个 react，看透 react 运行机制</a>\"</p>",
    "publish_time": "2023-09-09 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]