[
  {
    "title": "避免成为“象牙塔”架构师：架构师和组织之间的关系",
    "url": "https://www.infoq.cn/article/T4PEt15NU2JUk1VWhTMv",
    "summary": "<p>在最近的访谈节目中，参与者讨论了<a href=\"https://youtu.be/2ezIiYHLXhc\">软件架构师与组织之间的关系</a>\"。他们详细描述了一个成功的架构师是如何影响他人的，他们可以深入细节，置身其中，也可以纵览全局，并在两种状态之间来回切换。</p><p>&nbsp;</p><p>微软公司副总裁<a href=\"https://www.linkedin.com/in/ulrichhomann/\">Uli Homann</a>\"说：</p><p>&nbsp;</p><p></p><blockquote>有时候，架构师被认为是象牙塔架构师，因为他们没有真正去参与一线的开发。他们不会明白压力来自哪里，现实是怎样的，只会告诉别人使用某种技术，却没有详细了解这意味着什么。&nbsp;我认为，高级架构师的目标是驱动努力的方向。当你身处战壕，你看见的是树，而不是森林。所以你需要在理解细节和纵观全局之间取得平衡，你需要知道我们仍然在正确的道路上还是已经在其他人都向右时却向左走了？&nbsp;避免陷入这种复杂的局面——人们不喜欢你或认为你只是在说而不是在做——的唯一方法就是“做”。你必须参与讨论，还得能够抽身回来。你看到了树的细节，然后还能确保树仍然位于森林之中，并根据你在战壕中所学到的知识更新企业架构策略。</blockquote><p></p><p>&nbsp;</p><p>Homann解释说，当架构师说了一些东西，这些东西实际上是有意义的，但在现实中变得不再有意义，这个时候就出现了脱节。如果反馈循环没有发生，架构就不会根据现实的反馈进行更新，从而偏离现实。“给出方向和策略是可以的，但之后要深入团队，让他们接受这些决定，并从谈话中了解你想要构建的东西是否真的有效。”</p><p>&nbsp;</p><p>微软首席架构师<a href=\"https://twitter.com/mougue\">Eric Charran</a>\"解释了为什么他认为软件架构师有时候应该是公职人员和有时候应该是社区组织者。作为一名公职人员，架构师的目标是帮助团队实现目标，包括亲自参与其中。“我能帮上什么忙？”是一个关键问题，“这里有一些有用的工具和技术”也是一个关键问题。作为社区组织者，架构师应该将他们所学到的知识传播到组织的其他部分，并适当地给团队一些赞扬。他说：“作为一名架构师，当团队开始站在我的肩膀上做事情时，我就成功了。”</p><p>&nbsp;</p><p>当主持人<a href=\"https://twitter.com/otterbook\">David Blank-Edelman</a>\"（微软资深云布道者）问到如何让人们听你话的时候，Charran回答说，人们想做好工作，如果他们看到你能帮助他们，他们就会听你的。他还说，人们不会根据事实做出决定，他们会做出情绪化的决定，并寻找事实来支持他们。“你必须愿意花时间帮助他们进入一种舒适的状态，让他们能够倾听你的观点。如果他们不愿意听你的观点，那么即使你可能是100%正确的，也只打赢了一半的仗。”</p><p>&nbsp;</p><p>Charran指出，如果架构师反复向同样的人解释同样的事情，他们应该只使用职位的权威，并成为“友好的投球者”。Homann补充说，架构师应该始终努力用外部证据来支持他们的建议，并指出，如果架构师自己无法打动人们，可以尝试通过其他人来打动他们。</p><p>&nbsp;</p><p>原文原文：</p><p><a href=\"https://www.infoq.com/news/2023/01/ivory-tower-architects/\">https://www.infoq.com/news/2023/01/ivory-tower-architects/</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/video/f8dUjceJYXNvdoEsISBD\">十年架构师锻造之路｜InfoQ 大会早班车第 10 期</a>\"</p><p><a href=\"https://www.infoq.cn/article/x5I9egrl31GuWjuBE9B5\">十四年架构师揭秘：要做架构师先要在鸟群中做好鸟</a>\"</p>",
    "publish_time": "2023-04-03 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "“诱骗”ChatGPT生成Win95系统密钥，1/3概率可激活；微软Teams落地国内；京东拟分拆旗下两公司上市｜AI一周资讯",
    "url": "https://www.infoq.cn/article/XVRINNYgprSOwajdgNii",
    "summary": "<p></p><blockquote>滴滴云3月31日起不再对外提供公有云服务；汽车雷达在无人陵园显示全是人，理想回应；腾讯副总裁郄小虎离职；京东拟分拆旗下两公司上市，股价暴涨......</blockquote><p></p><p></p><h2>资讯</h2><p></p><p></p><h4>滴滴云3月31日起不再对外提供公有云服务</h4><p></p><p></p><p>滴滴云宣布，由于产品线调整，将于2023年3月31日0:00起不再对外提供公有云服务。</p><p></p><p>滴滴云表示，如账户中仍有资源或余额，请在2023年6月30日24:00前及时进行资源备份迁移和提交退款申请。</p><p></p><p>据了解，滴滴云是滴滴出行的<a href=\"https://www.infoq.cn/article/2OTLSfjvdDCTy5bWCKvh\">云计算</a>\"服务，致力于为开发者提供简单快捷、高效稳定、高性价比、安全可靠的IT基础设施云服务。</p><p></p><h4>微软 Teams 国内版由世纪互联运营</h4><p></p><p>4月1日，<a href=\"https://www.infoq.cn/article/9wzrGiMTl8XClRgSfL9A\">微软</a>\"官方微信号宣布，旗下的办公协作应用Teams正式落地国内市场。</p><p></p><p>Microsoft Teams国内版将由世纪互联运营，Teams 会议室、Teams 应用商店、Teams 电话等更多功能将会陆续开启。</p><p></p><p>微软表示，为了更好满足跨国企业、大中型企业、创业团队等对于办公体验的不同需求，由世纪互联运营的Teams将作为Microsoft 365/Office 365组件，以不同服务订阅的形式提供给不同行业、不同需求的客户。</p><p></p><h4>主播“诱骗”ChatGPT 生成 Win95 系统密钥，1/3概率可激活</h4><p></p><p></p><p>4月1日，据IT之家报道，YouTube 频道 Enderman 在最新一期视频中，“诱骗”ChatGPT 生成可激活 Win95 系统的密钥。</p><p></p><p>该主播首先直接要求 <a href=\"https://archsummit.infoq.cn/2023/shanghai/track/1503\">ChatGPT</a>\" 生成 Win95 系统的密钥，理所当然地遭到了拒绝。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/57/577657f0fe2b2166d6db7167201ff1af.jpeg\" /></p><p></p><p>主播表示生成 Win95 密钥纯粹是出于好玩的目的，而且 Win95 的密钥生成机制也相当简单。该主播随后将 Win95 的密钥规则告诉 ChatGPT，然后通过调整一些语序和改进，生成了相应的密钥。</p><p></p><p>该主播随后在一台 Win95 虚拟机上随机测试了这些密钥，发现只有三分之一的密钥可以成功激活。</p><p></p><h4>汽车雷达在无人陵园显示全是人，理想回应</h4><p></p><p></p><p>日前，有车主在社交媒体发布视频称，自己的理想L9在空无一人的陵园道路上识别并标注出了数位行人。</p><p></p><p>3月29日，理想汽车方面就此回应称，“理想Max系列车型，使用激光雷达和视觉摄像头融合感知，受限于当前市场上传感器识别能力的局限性，车辆在某些场景下会出现显示异常，我们会在后续的OTA优化算法来加强识别能力。”</p><p></p><h4>腾讯副总裁郄小虎离职</h4><p></p><p></p><p>3月30日消息，据晚点LatePost报道，腾讯副总裁、PCG（平台与内容事业群）信息与服务线负责人郄小虎已离任。目前尚不清楚这位资深技术专家接下来的去向。郄小虎于 2020 年 9 月加入腾讯，任公司副总裁，负责 PCG 技术线相关职能。2021年12月接任 PCG 信息与服务线后，他管理着 QQ 浏览器、搜狗搜索、搜狗输入法等业务。郄小虎分管的业务将由腾讯副总裁、PCG 技术副总裁曾宇直接负责。曾宇于2002年加入腾讯，2012年升任公司副总裁，是腾讯资深的技术专家和管理者。</p><p></p><h4>任正非再次强调华为不造车，汽车设计不得使用华为/HUAWEI标志</h4><p></p><p></p><p>3月31日，据36氪报道，华为再次关于汽车业务发出决策公告。公告由华为创始人、董事长任正非署名发出，再次强调“<a href=\"https://www.infoq.cn/article/I0NcBrPUqHAgmaoKmeQF\">华为不造车”</a>\"，“有效期5年”。除此之外，任正非还对华为标志在汽车设计上的露出提出了严格要求。</p><p></p><p>“强调不能使用华为/HUAWEI出现在整车宣传和外观上。”消息人士告诉36氪，而且重点指出，“不能使用’华为问界’，’HUAWEI AITO’。”</p><p></p><h4>京东拟分拆旗下两公司上市，股价暴涨</h4><p></p><p></p><p>阿里日前宣布组织架构调整，未来子公司业务都有机会独立上市。</p><p></p><p>紧随其后，3月30日晚，<a href=\"https://www.infoq.cn/article/XZkteGNvhGPw4UGKMXZW\">京东</a>\"集团发布公告称，拟分拆旗下京东产发、京东工业于港交所主板独立上市。京东产发和京东工业随即向港交所递交A1申请文件，首次披露其业务构成及经营数据。受消息刺激，3月30日京东美股一度涨逾9%。</p><p></p><p>31日涨势延续到港股，早盘京东集团股价一度涨逾8%，最高报176.5港元，近9个交易日股价累计上涨超16%。</p><p></p><h4>美光计划裁员15%，实施高管减薪</h4><p></p><p></p><p>3月29日消息，据路透社报道，美光公司预计第3季度营收将暴跌60%，同时美光宣布，2023年裁员扩大到15%。数据显示，美光Q2营收同比下降约53%，至36.9亿美元，分析师预期为37.3亿美元；净亏损23亿美元，上年同期净利润22.6亿美元。由于芯片行业仍面临供过于求的困扰，美光预计营收将出现自2001年以来最严重的下滑。Mehrotra同时宣布，除了高阶主管减薪、全面停发2023会计年度奖金外，目前预期整体人力缩减比例将逼近15%。</p><p></p><h4>Databricks 开源 LLM，训练只需三个小时、30 美元</h4><p></p><p></p><p>据开源中国报道，大数据分析公司 Databricks Inc 近日也加入了生成式 AI 领域的竞争之中，发布了一个名为&nbsp;Dolly&nbsp;的开源大型语言模型，将模型命名为 Dolly 是为了向第一只克隆羊多莉致敬。</p><p></p><p>像 ChatGPT 和 Bard 这样的生成式 AI，它们使用的数据通常来自于在成千上万不同网站，使用的数据量十分惊人，而且想要使用这些数据训练 AI 还需要数以千计的强大 GPU 在背后提供支持。</p><p></p><p>Databricks 希望通过开源 <a href=\"https://www.databricks.com/blog/2023/03/24/hello-dolly-democratizing-magic-chatgpt-open-models.html\">Dolly </a>\"及其训练数据，让任何人都能开发出一个真正像人类的 AI，而无需投资数百万美元，也让这类 AI 不再是只有大型科技公司才能负担得起的东西，数以百万计的小公司也将能够从中受益。</p><p></p><p>除此之外，让各个小公司构建自己的模型，而不将数据通过 API 发送给专有模型背后的服务提供商，也可以保护小公司的敏感数据和专有的知识产权。此外，一些公司可能在模型质量、成本和期望行为方面有不同的权衡，这些公司也可以根据需求调整模型。</p><p></p><p>Dolly项目地址：<a href=\"https://www.databricks.com/blog/2023/03/24/hello-dolly-democratizing-magic-chatgpt-open-models.html\">https://www.databricks.com/blog/2023/03/24/hello-dolly-democratizing-magic-chatgpt-open-models.html</a>\"</p><p></p><p>Databricks 首席执行官 Ali Ghodsi 表示，Dolly 只需要非常少的数据和非常短的时间就能完成训练。</p><p></p><p></p><blockquote>只需 30 美元、一台服务器和三个小时，我们就能教 Dolly 开始进行人类级别的交互。</blockquote><p></p><p></p><h2>IT业界热评新闻</h2><p></p><p></p><h4>周鸿祎回应马斯克呼吁暂停GPT5研发：不发展才是最大的不安全</h4><p></p><p></p><p>3月30日，周鸿祎发长文回应马斯克呼吁暂停GPT-5的研发。周鸿祎表示，自己是做安全的，但我坚定地认为，不发展才是最大的不安全。“不管你愿不愿意，GPT 都将引领一场新的工业革命，意义超越互联网和 iPhone 的发明。它将带来生产力的大幅提升，进而提升国家竞争力。中国一定要迎头赶上。”</p><p></p><h4>消息称马斯克或最早4月来中国：特斯拉FSD有望落地</h4><p></p><p></p><p>3月31日消息，据财联社援引路透社报道，有消息人士称，<a href=\"https://www.infoq.cn/article/Sktl2hsqUBygTlDGRzOI\">特斯拉CEO埃隆·马斯克</a>\"或最早于4月份来中国。马斯克此行的目的暂时不得而知，不过近日倒是有不少汽车、科技博主明里暗里地表示，特斯拉的FSD驾驶系统或将在国内落地。</p><p></p><p>FSD，也就是Full Self-Drive的简称，中文名“完全自动驾驶能力”，目前在北美市场已经开放，且进行了长达一年多的测试，表现可圈可点，但在国内，由于相关政策的限制，特斯拉FSD一直未能落地。</p><p></p><p>在特斯拉官网上可以看到，FSD功能为选装，售价6.4万，包含基础版辅助驾驶和增强版自动辅助驾驶的全部功能，包括自动辅助导航驾驶、自动辅助变道、自动泊车、智能召唤，还拥有自动识别交通信号灯和停车标志并做出反应，在城市街道中自动辅助驾驶。</p><p></p><p>但需要注意的是，特斯拉同时还指出，目前可用的功能需要驾驶员主动进行监控，车辆尚未实现完全自动驾驶。上述功能的激活与使用将需要数十亿英里的行驶里程的论证，以达到远超人类驾驶员的可靠性；同时还有赖于行政审批（某些司法管辖区可能会需要更长的时间）。</p><p></p><p>不过以上均为猜测，具体情况有待进一步的确认，4月份<a href=\"https://www.infoq.cn/article/5LYIHLWuPVU8btDrfBut\">马斯克</a>\"来中国之后，一些疑问或将给出结果。</p><p></p>",
    "publish_time": "2023-04-03 09:44:52",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "三年回顾：JavaScript与TypeScript最新特性汇总",
    "url": "https://www.infoq.cn/article/SZZal8JbzaFq1O9YejCy",
    "summary": "<p></p><blockquote>全文 7739 字，建议收藏。本文涵盖了过去三年中发布的最新 JavaScript 和 TypeScript 特性，包括异步迭代器、nullish 合并、可选链、私有字段等等。对于每个特性，文章提供了简单的解释、示例代码以及使用场景，以便开发者能够更好地理解和应用这些新特性。同时，文章还介绍了如何在项目中使用这些特性，以及如何通过 polyfill 或者 Babel 等工具使旧的浏览器支持这些新特性。</blockquote><p></p><p></p><p>本文将带大家回顾过去三年（乃至更早）以来，JavaScript/ECMAScript 以及 TypeScript 经历的一系列功能变化。</p><p></p><p>当然，这里提到的很多功能也许跟大家的日常工作八竿子打不着。但关注功能的发展变化，应该能帮助您加深对这些语言的理解。</p><p></p><p>有很多 TypeScript 功能并没有被记录在内，因为它们总体上可以概括为“之前它的运作效果跟期望不同，但现在相同了”。所以如果大家之前对某些问题有所诟病，现在不妨重试一次。</p><p></p><p></p><h3>概述</h3><p></p><p></p><p>●&nbsp;&nbsp;JavaScript / ECMAScript (按时间排序)</p><p></p><p>●&nbsp;&nbsp;TypeScript (按时间排序)</p><p></p><p></p><h2>ECMAScript</h2><p></p><p></p><h3>更早（更早发布但仍然重要）</h3><p></p><p></p><p>●&nbsp;&nbsp;标记模板字面量：通过在模板字面量之前添加函数名，可以将函数传递至模板字面量和模板值的某些部分。这项功能有不少有趣的用途。</p><p></p><p><code lang=\"javascript\">// Let's say we want to write a way to log arbitrary strings containing a number, but format the number.\n// We can use tagged templates for that.\nfunction formatNumbers(strings: TemplateStringsArray, number: number): string {\n  return strings[0] + number.toFixed(2) + strings[1];\n}\nconsole.log(formatNumbers`This is the value: ${0}, it's important.`); // This is the value: 0.00, it's important.\n// Or if we wanted to \"translate\" (change to lowercase here) translation keys within strings.\nfunction translateKey(key: string): string {\n  return key.toLocaleLowerCase();\n}\nfunction translate(strings: TemplateStringsArray, ...expressions: string[]): string {\n  return strings.reduce((accumulator, currentValue, index) =&gt; accumulator + currentValue + translateKey(expressions[index] ?? ''), '');\n}\nconsole.log(translate`Hello, this is ${'NAME'} to say ${'MESSAGE'}.`); // Hello, this is name to say message.\n\n</code></p><p></p><p>●&nbsp;&nbsp;Symbols（之前被错误归类为 ES2022）：对象的唯一键：Symbol(“foo”) === Symbol(“foo”); // false。内部使用。</p><p></p><p><code lang=\"javascript\">const obj: { [index: string]: string } = {};\nconst symbolA = Symbol('a');\nconst symbolB = Symbol.for('b');\nconsole.log(symbolA.description); // \"a\"\nobj[symbolA] = 'a';\nobj[symbolB] = 'b';\nobj['c'] = 'c';\nobj.d = 'd';\nconsole.log(obj[symbolA]); // \"a\"\nconsole.log(obj[symbolB]); // \"b\"\n// The key cannot be accessed with any other symbols or without a symbol.\nconsole.log(obj[Symbol('a')]); // undefined\nconsole.log(obj['a']); // undefined\n// The keys are not enumerated when using for ... in.\nfor (const i in obj) {\n  console.log(i); // \"c\", \"d\"\n}\n</code></p><p></p><p></p><h3>ES2020</h3><p></p><p></p><p>●&nbsp;&nbsp;可选链：要访问一个可能未定义的对象的值（通过索引），可以通过在父对象名称后添加? 来使用可选链。可选链也可用于索引 ([…]) 或者函数调用。</p><p></p><p><code lang=\"typescript\">// PREVIOUSLY:\n// If we have an object variable (or any other structure) we don't know for certain is defined,\n// We can not easily access the property.\nconst object: { name: string } | undefined = Math.random() &gt; 0.5 ? undefined : { name: 'test' };\nconst value = object.name; // type error: 'object' is possibly 'undefined'.\n// We could first check if it is defined, but this hurts readability and gets complex for nested objects.\nconst objectOld: { name: string } | undefined = Math.random() &gt; 0.5 ? undefined : { name: 'test' };\nconst valueOld = objectOld ? objectOld.name : undefined;\n// NEW:\n// Instead we can use optional chaining.\nconst objectNew: { name: string } | undefined = Math.random() &gt; 0.5 ? undefined : { name: 'test' };\nconst valueNew = objectNew?.name;\n// This can also be used for indexing and functions.\nconst array: string[] | undefined = Math.random() &gt; 0.5 ? undefined : ['test'];\nconst item = array?.[0];\nconst func: (() =&gt; string) | undefined = Math.random() &gt; 0.5 ? undefined : () =&gt; 'test';\nconst result = func?.();\n</code></p><p></p><p>●&nbsp;&nbsp;import(): 动态导入，例如 import … from …，但在运行上且使用变量。</p><p></p><p><code lang=\"javascript\">let importModule;\nif (shouldImport) {\nimportModule = await import('./module.mjs');\n}\n</code></p><p></p><p>●&nbsp;&nbsp;String.matchAll: 获取正则表达式的多个匹配项，包括其捕获组，且不使用循环。</p><p></p><p><code lang=\"javascript\">const stringVar = 'testhello,testagain,';\n// PREVIOUSLY:\n// Only gets matches, but not their capture groups.\nconsole.log(stringVar.match(/test([\\w]+?),/g)); // [\"testhello,\", \"testagain,\"]\n// Only gets one match, including its capture groups.\nconst singleMatch = stringVar.match(/test([\\w]+?),/);\nif (singleMatch) {\n  console.log(singleMatch[0]); // \"testhello,\"\n  console.log(singleMatch[1]); // \"hello\"\n}\n// Gets the same result, but is very unintuitive (the exec method saves the last index).\n// Needs to be defined outside the loop (to save the state) and be global (/g),\n// otherwise this will produce an infinite loop.\nconst regex = /test([\\w]+?),/g;\nlet execMatch;\nwhile ((execMatch = regex.exec(stringVar)) !== null) {\n  console.log(execMatch[0]); // \"testhello,\", \"testagain,\"\n  console.log(execMatch[1]); // \"hello\", \"again\"\n}\n// NEW:\n// Regex needs to be global (/g), also doesn't make any sense otherwise.\nconst matchesIterator = stringVar.matchAll(/test([\\w]+?),/g);\n// Needs to be iterated or converted to an array (Array.from()), no direct indexing.\nfor (const match of matchesIterator) {\n  console.log(match[0]); // \"testhello,\", \"testagain,\"\n  console.log(match[1]); // \"hello\", \"again\"\n}\n</code></p><p></p><p>●&nbsp;&nbsp;Promise.allSettled(): 与 Promise.all() 类似，但需要等待所有 Promises 完成，且不会在第一次 reject/throw 时返回。它能让降低错误处理的难度。</p><p></p><p><code lang=\"javascript\">async function success1() {return 'a'}\nasync function success2() {return 'b'}\nasync function fail1() {throw 'fail 1'}\nasync function fail2() {throw 'fail 2'}\n// PREVIOUSLY:\nconsole.log(await Promise.all([success1(), success2()])); // [\"a\", \"b\"]\n// but:\ntry {\n  await Promise.all([success1(), success2(), fail1(), fail2()]);\n} catch (e) {\n  console.log(e); // \"fail 1\"\n}\n// Notice: We only catch one error and can't access the success values.\n// PREVIOUS FIX (really suboptimal):\nconsole.log(await Promise.all([ // [\"a\", \"b\", undefined, undefined]\n  success1().catch(e =&gt; { console.log(e); }),\n  success2().catch(e =&gt; { console.log(e); }),\n  fail1().catch(e =&gt; { console.log(e); }), // \"fail 1\"\n  fail2().catch(e =&gt; { console.log(e); })])); // \"fail 2\"\n// NEW:\nconst results = await Promise.allSettled([success1(), success2(), fail1(), fail2()]);\nconst sucessfulResults = results\n  .filter(result =&gt; result.status === 'fulfilled')\n  .map(result =&gt; (result as PromiseFulfilledResult).value);\nconsole.log(sucessfulResults); // [\"a\", \"b\"]\nresults.filter(result =&gt; result.status === 'rejected').forEach(error =&gt; {\n  console.log((error as PromiseRejectedResult).reason); // \"fail 1\", \"fail 2\"\n});\n// OR:\nfor (const result of results) {\n  if (result.status === 'fulfilled') {\n    console.log(result.value); // \"a\", \"b\"\n  } else if (result.status === 'rejected') {\n    console.log(result.reason); // \"fail 1\", \"fail 2\"\n  }\n}\n</code></p><p></p><p>●&nbsp;&nbsp;globalThis: 在全局上下文中访问变量，与环境无关（浏览器、NodeJS 等）。仍被视为较差实践，但在某些情况下是必要的。类似于浏览器上的 this。</p><p></p><p><code lang=\"javascript\">console.log(globalThis.Math); // Math Object\n</code></p><p></p><p>●import.meta: 在使用 ES-modules 时，获取当前模块的 URL import.meta.url。</p><p></p><p><code lang=\"javascript\">console.log(import.meta.url); // \"file://...\"\n</code></p><p></p><p>●&nbsp;&nbsp;export * as … from …: 轻松将默认值重新导出为子模块。</p><p></p><p><code lang=\"javascript\">export * as am from 'another-module'\nimport { am } from 'module'\n</code></p><p></p><p></p><h3>ES2021</h3><p></p><p></p><p>●&nbsp;&nbsp;String.replaceAll(): 替换掉某字符串内某一子字符串的所有实例，无需始终使用带有全局标志（/g）的正则表达式。</p><p></p><p><code lang=\"javascript\">const testString = 'hello/greetings everyone/everybody';\n// PREVIOUSLY:\n// Only replaces the first instance\nconsole.log(testString.replace('/', '|')); // 'hello|greetings everyone/everybody'\n// Instead a regex needed to be used, which is worse for performance and needs escaping.\n// Not the global flag (/g).\nconsole.log(testString.replace(/\\//g, '|')); // 'hello|greetings everyone|everybody'\n// NEW:\n// Using replaceAll this is much clearer and faster.\nconsole.log(testString.replaceAll('/', '|')); // 'hello|greetings everyone|everybody'\n</code></p><p></p><p>●&nbsp;&nbsp;Promise.any: 当只需要获取 promises 列表中的一个结果时，则返回第一个结果；仅在所有 promises 均被拒绝时才返回 AggregateError，而非立即拒绝的 Promise.race。</p><p></p><p><code lang=\"javascript\">async function success1() {return 'a'}\nasync function success2() {return 'b'}\nasync function fail1() {throw 'fail 1'}\nasync function fail2() {throw 'fail 2'}\n// PREVIOUSLY:\nconsole.log(await Promise.race([success1(), success2()])); // \"a\"\n// but:\ntry {\n  await Promise.race([fail1(), fail2(), success1(), success2()]);\n} catch (e) {\n  console.log(e); // \"fail 1\"\n}\n// Notice: We only catch one error and can't access the success value.\n// PREVIOUS FIX (really suboptimal):\nconsole.log(await Promise.race([ // \"a\"\n  fail1().catch(e =&gt; { console.log(e); }), // \"fail 1\"\n  fail2().catch(e =&gt; { console.log(e); }), // \"fail 2\"\n  success1().catch(e =&gt; { console.log(e); }),\n  success2().catch(e =&gt; { console.log(e); })]));\n// NEW:\nconsole.log(await Promise.any([fail1(), fail2(), success1(), success2()])); // \"a\"\n// And it only rejects when all promises reject and returns an AggregateError containing all the errors.\ntry {\n  await Promise.any([fail1(), fail2()]);\n} catch (e) {\n  console.log(e); // [AggregateError: All promises were rejected]\n  console.log(e.errors); // [\"fail 1\", \"fail 2\"]\n}\n</code></p><p></p><p>●&nbsp;&nbsp;Nullish coalescing assignment (??=): 仅在之前为 “nullish”（null 或 undefined）时才分配值。</p><p></p><p><code lang=\"javascript\">let x1 = undefined;\nlet x2 = 'a';\nconst getNewValue = () =&gt; 'b';\n// Assigns the new value to x1, because undefined is nullish.\nx1 ??= 'b';\nconsole.log(x1) // \"b\"\n// Does not assign a new value to x2, because a string is not nullish.\n// Also note: getNewValue() is never executed.\nx2 ??= getNewValue();\nconsole.log(x1) // \"a\"\n</code></p><p></p><p>●&nbsp;&nbsp;Logical and assignment (&amp;&amp;=): 仅在之前为“truhty”（true 或可以转换为 true 的值）时才分配值。</p><p></p><p><code lang=\"javascript\">let x1 = undefined;\nlet x2 = 'a';\nconst getNewValue = () =&gt; 'b';\n// Does not assign a new value to x1, because undefined is not truthy.\n// Also note: getNewValue() is never executed.\nx1 &amp;&amp;= getNewValue();\nconsole.log(x1) // undefined\n// Assigns a new value to x2, because a string is truthy.\nx2 &amp;&amp;= 'b';\nconsole.log(x1) // \"b\"\n</code></p><p></p><p>●&nbsp;&nbsp;Logical or assignment (||=): 仅在之前为“falsy”（false 或转换为 false）时才分配值。</p><p></p><p><code lang=\"javascript\">let x1 = undefined;\nlet x2 = 'a';\nconst getNewValue = () =&gt; 'b';\n// Assigns the new value to x1, because undefined is falsy.\nx1 ||= 'b';\nconsole.log(x1) // \"b\"\n// Does not assign a new value to x2, because a string is not falsy.\n// Also note: getNewValue() is never executed.\nx2 ||= getNewValue();\nconsole.log(x1) // \"a\"\n</code></p><p></p><p>●&nbsp;&nbsp;WeakRef: 保留对一个对象的“weak”引用，但不阻止对象被垃圾回收。</p><p></p><p><code lang=\"cs\">const ref = new WeakRef(element);\n// Get the value, if the object/element still exists and was not garbage-collected.\nconst value = ref.deref;\nconsole.log(value); // undefined\n// Looks like the object does not exist anymore.\n</code></p><p></p><p>●&nbsp;&nbsp;数字分隔符 (_): 使用 _ 分隔数字以提高可读性。不会对功能造成影响。</p><p></p><p><code lang=\"cs\">const int = 1_000_000_000;\nconst float = 1_000_000_000.999_999_999;\nconst max = 9_223_372_036_854_775_807n;\nconst binary = 0b1011_0101_0101;\nconst octal = 0o1234_5670;\nconst hex = 0xD0_E0_F0;\n</code></p><p></p><p></p><h3>ES2022</h3><p></p><p></p><p>●&nbsp;&nbsp;#private: 通过以 # 开头的命名，使类成员（属性和方法）私有，即只能通过类本身进行访问。其无法被删除或动态分配。任何不正确行为都会导致 JavaScript（注意，不是 TypeScript）语法错误。不推荐在 TypeScript 项目中这样做，而应用直接使用 private 关键字。</p><p></p><p><code lang=\"cs\">class ClassWithPrivateField {\n#privateField;\n#anotherPrivateField = 4;\nconstructor() {\nthis.#privateField = 42; // Valid\nthis.#privateField; // Syntax error\nthis.#undeclaredField = 444; // Syntax error\nconsole.log(this.#anotherPrivateField); // 4\n}\n}\nconst instance = new ClassWithPrivateField();\ninstance.#privateField === 42; // Syntax error\n</code></p><p></p><p>●&nbsp;&nbsp;静态类成员: 将任意类字段（属性和方法）标记为静态。</p><p></p><p><code lang=\"javascript\">class Logger {\nstatic id = 'Logger1';\nstatic type = 'GenericLogger';\nstatic log(message: string | Error) {\nconsole.log(message);\n}\n}\nclass ErrorLogger extends Logger {\nstatic type = 'ErrorLogger';\nstatic qualifiedType;\nstatic log(e: Error) {\nreturn super.log(e.toString());\n}\n}\nconsole.log(Logger.type); // \"GenericLogger\"\nLogger.log('Test'); // \"Test\"\n// The instantiation of static-only classes is useless and only done here for demonstration purposes.\nconst log = new Logger();\nErrorLogger.log(new Error('Test')); // Error: \"Test\" (not affected by instantiation of the parent)\nconsole.log(ErrorLogger.type); // \"ErrorLogger\"\nconsole.log(ErrorLogger.qualifiedType); // undefined\nconsole.log(ErrorLogger.id); // \"Logger1\"\n// This throws because log() is not an instance method but a static method.\nconsole.log(log.log()); // log.log is not a function\n</code></p><p></p><p>●&nbsp;&nbsp;类中的静态初始化块: 类初始化时运行的块，基本属于静态成员的“构造函数”。</p><p></p><p><code lang=\"javascript\">class Test {\nstatic staticProperty1 = 'Property 1';\nstatic staticProperty2;\nstatic {\nthis.staticProperty2 = 'Property 2';\n}\n}\nconsole.log(Test.staticProperty1); // \"Property 1\"\nconsole.log(Test.staticProperty2); // \"Property 2\"\n</code></p><p></p><p>●&nbsp;&nbsp;导入断言（非标准，在 V8 中实现）：以 import … from … assert { type: ‘json’ }的形式对导入类型做断言，可用于在不解析 JSON 的前提下将其导入。</p><p></p><p><code lang=\"typescript\">import json from './foo.json' assert { type: 'json' };\nconsole.log(json.answer); // 42\n</code></p><p></p><p>●&nbsp;&nbsp;RegExp 匹配索引：获取正则表达式匹配和捕获组的开始和结束索引。适用于 RegExp.exec(), String.match() 和 String.matchAll()。</p><p></p><p><code lang=\"javascript\">const matchObj = /(test+)(hello+)/d.exec('start-testesthello-stop');\n// PREVIOUSLY:\nconsole.log(matchObj?.index);\n// NEW:\nif (matchObj) {\n// Start and end index of entire match (before we only had the start).\nconsole.log(matchObj.indices[0]); // [9, 18]\n// Start and end indexes of capture groups.\nconsole.log(matchObj.indices[1]); // [9, 13]\nconsole.log(matchObj.indices[2]); // [13, 18]\n}\n</code></p><p></p><p>●&nbsp;&nbsp;负索引 (.at(-1)): 在索引数组或字符串时，可以使用 at 从末尾开始索引。相当于 arr[arr.length - 1)</p><p></p><p><code lang=\"javascript\">console.log([4, 5].at(-1)) // 5\n</code></p><p></p><p>●&nbsp;&nbsp;hasOwn: 推荐使用的新方法，用于查找对象具有哪些属性，用于替代 obj.hasOwnProperty()。在某些特殊情况下效果更好。</p><p></p><p><code lang=\"javascript\">const obj = { name: 'test' };\nconsole.log(Object.hasOwn(obj, 'name')); // true\nconsole.log(Object.hasOwn(obj, 'gender')); // false\n</code></p><p></p><p>●&nbsp;&nbsp;错误原因（Error cause）: 现在可以为错误指定可选原因，允许在重新抛出时指定原始错误。</p><p></p><p><code lang=\"javascript\">try {\ntry {\nconnectToDatabase();\n} catch (err) {\nthrow new Error('Connecting to database failed.', { cause: err });\n}\n} catch (err) {\nconsole.log(err.cause); // ReferenceError: connectToDatabase is not defined\n}\n</code></p><p></p><p></p><h3>之后（已可在 TypeScript 4.9 中使用）</h3><p></p><p></p><p>●&nbsp;&nbsp;Auto-Accessor: 自动将属性设为私有，并为其创建 get/set 访问器。</p><p></p><p><code lang=\"typescript\">class Person {\naccessor name: string;\nconstructor(name: string) {\nthis.name = name;\nconsole.log(this.name) // 'test'\n}\n}\nconst person = new Person('test');\n</code></p><p></p><p></p><h2>TypeScript</h2><p></p><p></p><h3>基础（进一步介绍上下文）</h3><p></p><p></p><p>●&nbsp;&nbsp;泛型: 将类型传递至其他类型，负责在对类型进行泛化后仍保证类型安全。应始终优先使用泛型，而非 any 或 unknown。</p><p></p><p><code lang=\"php\">// WITHOUT:\nfunction getFirstUnsafe(list: any[]): any {\nreturn list[0];\n}\nconst firstUnsafe = getFirstUnsafe(['test']); // typed as any\n// WITH:\nfunction getFirst(list: Type[]): Type {\nreturn list[0];\n}\nconst first = getFirst(['test']); // typed as string\n// In this case the parameter can even be dropped because it is inferred from the argument.\nconst firstInferred = getFirst(['test']); // typed as string\n// The types accepted as generics can also be limited using `extends`. The Type is also usually shortened to T.\nclass List {\nprivate list: T[] = [];\nget(key: number): T {\nreturn this.list[key];\n}\npush(value: T): void {\nthis.list.push(value);\n}\n}\nconst list = new List();\nlist.push(9); // Type error: Argument of type 'number' is not assignable to parameter of type 'string'.\nconst booleanList = new List(); // Type error: Type 'boolean' does not satisfy the constraint 'string | number'.\n</code></p><p></p><p></p><h3>更早（更早发布但仍然重要）</h3><p></p><p></p><p>●&nbsp;&nbsp;实用程序类型: TypeScript 中包含多种实用程序类型，这里解释其中最重要的几种。</p><p></p><p><code lang=\"typescript\">interface Test {\n  name: string;\n  age: number;\n}\n// The Partial utility type makes all properties optional.\ntype TestPartial = Partial; // typed as { name?: string | undefined; age?: number | undefined; }\n// The Required utility type does the opposite.\ntype TestRequired = Required; // typed as { name: string; age: number; }\n// The Readonly utility type makes all properties readonly.\ntype TestReadonly = Readonly; // typed as { readonly name: string; readonly age: string }\n// The Record utility type allows the simple definition of objects/maps/dictionaries. It is preferred to index signatures whenever possible.\nconst config: Record = { option: false, anotherOption: true };\n// The Pick utility type gets only the specified properties.\ntype TestLess = Pick; // typed as { name: string; }\ntype TestBoth = Pick; // typed as { name: string; age: string; }\n// The Omit utility type ignores the specified properties.type\ntype TestFewer = Omit; // typed as { age: string; }\ntype TestNone = Omit; // typed as {}\n// The Parameters utility type gets the parameters of a function type.\nfunction doSmth(value: string, anotherValue: number): string {\n  return 'test';\n}\ntype Params = Parameters; // typed as [value: string, anotherValue: number]\n// The ReturnType utility type gets the return type of a function type.\ntype Return = ReturnType; // typed as string\n// There are many more, some of which are introduced further down.\n</code></p><p></p><p>●&nbsp;&nbsp;条件类型: 根据某种类型是否匹配 / 扩展另一种类型，来对类型做有条件设置。可以按照 JavaScript 中条件（三元）运算符的方式理解。</p><p></p><p><code lang=\"typescript\">// Only extracts the array type if it is an array, otherwise returns the same type.\ntype Flatten = T extends any[] ? T[number] : T;\n// Extracts out the element type.\ntype Str = Flatten; // typed as string\n// Leaves the type alone.\ntype Num = Flatten; // typed as number\n</code></p><p></p><p>●&nbsp;&nbsp;使用条件类型进行推断: 并非所有泛型类型都需要由用户指定，有些也可以从代码中推断得出。要实现基于类型推断的条件逻辑，必须有 infer 关键字，它会以某种方式定义临时推断类型变量。</p><p></p><p><code lang=\"typescript\">// Starting with the previous example, this can be written more cleanly.\ntype FlattenOld = T extends any[] ? T[number] : T;\n// Instead of indexing the array, we can just infer the Item type from the array.\ntype Flatten = T extends (infer Item)[] ? Item : T;\n// If we wanted to write a type that gets the return type of a function and otherwise is undefined, we could also infer that.\ntype GetReturnType = Type extends (...args: any[]) =&gt; infer Return ? Return : undefined;\ntype Num = GetReturnType&lt;() =&gt; number&gt;; // typed as number\ntype Str = GetReturnType&lt;(x: string) =&gt; string&gt;; // typed as string\ntype Bools = GetReturnType&lt;(a: boolean, b: boolean) =&gt; void&gt;; // typed as undefined\n</code></p><p></p><p>●&nbsp;&nbsp;元组可选元素与其余元素: 使用 ? 声明元组中的可选元素，使用 … 声明元组中的其余元素。</p><p></p><p><code lang=\"typescript\">// If we don't yet know how long a tuple is going to be, but it's at least one, we can specify optional types using `?`.\nconst list: [number, number?, boolean?] = [];\nlist[0] // typed as number\nlist[1] // typed as number | undefined\nlist[2] // typed as boolean | undefined\nlist[3] // Type error: Tuple type '[number, (number | undefined)?, (boolean | undefined)?]' of length '3' has no element at index '3'.\n// We could also base the tuple on an existing type.\n// If we want to pad an array at the start, we could do that using the rest operator `...`.\nfunction padStart(arr: T, pad: string): [string, ...T] {\n  return [pad, ...arr];\n}\nconst padded = padStart([1, 2], 'test'); // typed as [string, number, number]\n</code></p><p></p><p>●&nbsp;&nbsp;抽象类和方法: 类和类中的各方法可以被声明为 abstract，以防止其被实例化。</p><p></p><p><code lang=\"java\">abstract class Animal {\n  abstract makeSound(): void;\n  move(): void {\n    console.log('roaming the earth...');\n  }\n}\n// Abstract methods need to be implemented when extended.\nclass Cat extends Animal {} // Compile error: Non-abstract class 'Cat' does not implement inherited abstract member 'makeSound' from class 'Animal'.\nclass Dog extends Animal {\n  makeSound() {\n    console.log('woof');\n  }\n}\n// Abstract classes cannot be instantiated (like Interfaces), and abstract methods cannot be called.\nnew Animal(); // Compile error: Cannot create an instance of an abstract class.\nconst dog = new Dog().makeSound(); // \"woof\"\n</code></p><p></p><p>●&nbsp;&nbsp;构造函数签名: 在类声明之外，定义构造函数的类型。在大多数情况下不应使用，建议用抽象类代替。</p><p></p><p><code lang=\"typescript\">interface MyInterface {\n  name: string;\n}\ninterface ConstructsMyInterface {\n  new(name: string): MyInterface;\n}\nclass Test implements MyInterface {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\nclass AnotherTest {\n  age: number;\n}\nfunction makeObj(n: ConstructsMyInterface) {\n    return new n('hello!');\n}\nconst obj = makeObj(Test); // typed as Test\nconst anotherObj = makeObj(AnotherTest); // Type error: Argument of type 'typeof AnotherTest' is not assignable to parameter of type 'ConstructsMyInterface'.\n</code></p><p></p><p>●&nbsp;&nbsp;ConstructorParameters Utility 类型: 属于 TypeScript 辅助函数，能够根据构造函数类型（但不是类）获取构造函数参数。</p><p></p><p><code lang=\"typescript\">// What if we wanted to get the constructor argument for our makeObj function.\ninterface MyInterface {\n  name: string;\n}\ninterface ConstructsMyInterface {\n  new(name: string): MyInterface;\n}\nclass Test implements MyInterface {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\nfunction makeObj(test: ConstructsMyInterface, ...args: ConstructorParameters) {\n  return new test(...args);\n}\nmakeObj(Test); // Type error: Expected 2 arguments, but got 1.\nconst obj = makeObj(Test, 'test'); // typed as Test\n</code></p><p></p><p></p><h3>TypeScript 4.0</h3><p></p><p></p><p>●&nbsp;&nbsp;可变元组类型: 元组中的其余元素现在是通用的，且允许使用多个其余元素。</p><p></p><p><code lang=\"typescript\">// What if we had a function that combines two tuples of undefined length and types? How can we define the return type?\n// PREVIOUSLY:\n// We could write some overloads.\ndeclare function concat(arr1: [], arr2: []): [];\ndeclare function concat<a>(arr1: [A], arr2: []): [A];\ndeclare function concat<a>(arr1: [A], arr2: [B]): [A, B];\ndeclare function concat<a>(arr1: [A], arr2: [B, C]): [A, B, C];\ndeclare function concat<a>(arr1: [A], arr2: [B, C, D]): [A, B, C, D];\ndeclare function concat<a>(arr1: [A, B], arr2: []): [A, B];\ndeclare function concat<a>(arr1: [A, B], arr2: [C]): [A, B, C];\ndeclare function concat<a>(arr1: [A, B], arr2: [C, D]): [A, B, C, D];\ndeclare function concat<a>(arr1: [A, B], arr2: [C, D, E]): [A, B, C, D, E];\ndeclare function concat<a>(arr1: [A, B, C], arr2: []): [A, B, C];\ndeclare function concat<a>(arr1: [A, B, C], arr2: [D]): [A, B, C, D];\ndeclare function concat<a>(arr1: [A, B, C], arr2: [D, E]): [A, B, C, D, E];\ndeclare function concat<a>(arr1: [A, B, C], arr2: [D, E, F]): [A, B, C, D, E, F];\n// Even just for three items each, this is really suboptimal.\n// Instead we could combine the types.\ndeclare function concatBetter(arr1: T[], arr2: U[]): (T | U)[];\n// But this types to (T | U)[]\n// NEW:\n// With variadic tuple types, we can define it easily and keep the information about the length.\ndeclare function concatNew(arr1: T, arr2: U): [...T, ...U];\nconst tuple = concatNew([23, 'hey', false] as [number, string, boolean], [5, 99, 20] as [number, number, number]);\nconsole.log(tuple[0]); // 23\nconst element: number = tuple[1]; // Type error: Type 'string' is not assignable to type 'number'.\nconsole.log(tuple[6]); // Type error: Tuple type '[23, \"hey\", false, 5, 99, 20]' of length '6' has no element at index '6'.\n</a></code></p><p></p><p><a>●&nbsp;&nbsp;标记元组元素: 元组元素现可被命名为 [start: number, end: number] 的形式。如果命名其中一个元素，则所有元素必须均被命名。</a></p><p></p><p><a><code lang=\"typescript\">type Foo = [first: number, second?: string, ...rest: any[]];\n// This allows the arguments to be named correctly here, it also shows up in the editor.\ndeclare function someFunc(...args: Foo);\n</code></a></p><p></p><p><a>●&nbsp;&nbsp;从构造函数推断类属性: 在构造函数中设置属性时，现可推断其类型，不再需要手动设置。</a></p><p></p><p><a><code lang=\"typescript\">class Animal {\n// No need to set types when they are assigned in the constructor.\nname;\nconstructor(name: string) {\nthis.name = name;\nconsole.log(this.name); // typed as string\n}\n}\n</code></a></p><p></p><p><a>●JSDoc @deprecated 支持: TypeScript 现可识别 JSDoc/TSDoc @deprecated 标签。</a></p><p></p><p><a><code lang=\"typescript\">/** @deprecated message */\ntype Test = string;\nconst test: Test = 'dfadsf'; // Type error: 'Test' is deprecated.\n</code></a></p><p></p><p></p><h3><a>TypeScript 4.1</a></h3><p></p><p></p><p><a>●&nbsp;&nbsp;模板字面量类型: 在定义字面量类型时，可以通过 ${Type}等模板指定类型。这样可以构造复杂的字符串类型，例如将多个字符串字面量组合起来。</a></p><p></p><p><a><code lang=\"typescript\">type VerticalDirection = 'top' | 'bottom';\ntype HorizontalDirection = 'left' | 'right';\ntype Direction = `${VerticalDirection} ${HorizontalDirection}`;\nconst dir1: Direction = 'top left';\nconst dir2: Direction = 'left'; // Type error: Type '\"left\"' is not assignable to type '\"top left\" | \"top right\" | \"bottom left\" | \"bottom right\"'.\nconst dir3: Direction = 'left top'; // Type error: Type '\"left top\"' is not assignable to type '\"top left\" | \"top right\" | \"bottom left\" | \"bottom right\"'.\n// This can also be combined with generics and the new utility types.\ndeclare function makeId(first: T, second: U): `${Capitalize}-${Lowercase<u>}`;\n</u></code></a></p><p></p><p><a><u>●&nbsp;&nbsp;在映射类型中重新映射键: 为已映射的类型重新分配类型，但仍使用其值，例如 [K in keyof T as NewKeyType]: T[K]。</u></a></p><p></p><p><a><u><code lang=\"typescript\">// Let's say we wanted to reformat an object but prepend its IDs with an underscore.\nconst obj = { value1: 0, value2: 1, value3: 3 };\nconst newObj: { [Property in keyof typeof obj as `_${Property}`]: number }; // typed as { _value1: number; _value2: number; value3: number; }\n</code></u></a></p><p></p><p><a><u>●&nbsp;&nbsp;递归条件类型: 在定义之内使用条件类型，这种类型允许以有条件方式解包无限嵌套值。</u></a></p><p></p><p><a><u><code lang=\"typescript\">type Awaited = T extends PromiseLike ? Awaited<u> : T;\ntype P1 = Awaited; // typed as string\ntype P2 = Awaited&gt;; // typed as string\ntype P3 = Awaited&gt;&gt;; // typed as string\n</u></code></u></a></p><p></p><p><a><u><u>●&nbsp;&nbsp;JSDOC @see 标签的编辑器支持: JSDoc/TSDoc @see variable/type/link 标签现可在编辑器中受到支持。</u></u></a></p><p></p><p><a><u><u><code lang=\"cs\">const originalValue = 1;\n/**\n* Copy of another value\n* @see originalValue\n*/\nconst value = originalValue;\n</code></u></u></a></p><p></p><p><a><u><u>●&nbsp;&nbsp;tsc — explainFiles: &nbsp;--explainFiles 选项可被 TypeScript CLI 用于解释哪些文件是编译的一部分、为什么会这样。这一点对于调试非常重要。警告：对于大型项目或较为复杂的设置，这会生成大量输出，建议改用 tsc --explainFiles | less 或其他类似功能。</u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">tsc --explainFiles\n&lt;<output><=\"\" code=\"\"></output></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;解构变量可被显式标记为未使用: 在解构时，可使用下划线将变量标记为未使用，从而防止 TypeScript 抛出“未使用的变量”错误。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"javascript\">const [_first, second] = [3, 5];\nconsole.log(second);\n// Or even shorter\nconst [_, value] = [3, 5];\nconsole.log(value);\n</code></code></u></u></a></p><p></p><p></p><h3><a><u><u><code lang=\"javascript\">TypeScript 4.3</code></u></u></a></h3><p></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;属性上的单独写入类型: 在定义 set/get 访问器时，write/set 类型现可不同于 read/get 类型。意味着设置器能够接受相同值的多种格式。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">class Test {\nprivate _value: number;\nget value(): number {\nreturn this._value;\n}\nset value(value: number | string) {\nif (typeof value === 'number') {\nthis._value = value;\nreturn;\n}\nthis._value = parseInt(value, 10);\n}\n}\n</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;override: 使用 override，会将继承的类方法显式标记为覆写。因此当父类发生变化时，TypeScript 会提醒父方法已不存在，从而实现更安全的复杂继承模式。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">class Parent {\ngetName(): string {\nreturn 'name';\n}\n}\nclass NewParent {\ngetFirstName(): string {\nreturn 'name';\n}\n}\nclass Test extends Parent {\noverride getName(): string {\nreturn 'test';\n}\n}\nclass NewTest extends NewParent {\noverride getName(): string { // Type error: This member cannot have an 'override' modifier because it is not declared in the base class 'NewParent'.\nreturn 'test';\n}\n}\n</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;静态索引签名: 在类上使用静态属性时，现在也可以使用 static [propName: string]: string 设置索引签名。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">// PREVIOUSLY:\nclass Test {}\nTest.test = ''; // Type error: Property 'test' does not exist on type 'typeof Test'.\n// NEW:\nclass NewTest {\nstatic [key: string]: string;\n}\nNewTest.test = '';\n</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">●对JSDOC@link标签提供编辑器支持: JSDoc/TSDoc {@link variable/type/link} 内联标签现可在编辑器中显示和解析。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">const originalValue = 1;\n/**\n* Copy of {@link originalValue}\n*/\nconst value = originalValue;\n</code></code></u></u></a></p><p></p><p></p><h3><a><u><u><code lang=\"javascript\">TypeScript 4.4</code></u></u></a></h3><p></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;精确的可选属性类型 ( — exactOptionalPropertyTypes): 使用编译器标志 --exactOptionalPropertyTypes 时（或在 tsconfig.json 中），隐式允许 undefined（例如 property?: string）的属性将不允许被分配为 undefined。相反，undefined 必须经过明确许可，例如 property: string | undefined。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"typescript\">class Test {\nname?: string;\nage: number | undefined;\n}\nconst test = new Test();\ntest.name = 'test'; // Type error: Option 'exactOptionalPropertyTypes' cannot be specified without specifying option 'strictNullChecks'.\ntest.age = 0;\n</code></code></u></u></a></p><p></p><p></p><h3><a><u><u><code lang=\"javascript\">TypeScript 4.5</code></u></u></a></h3><p></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;Awaited 类型与 Promise 改进: 新的 Awaited&lt;&gt;实用程序类型能从无限嵌套的 Promises 中提取值类型（类似于 await 对该值的操作）。这也改进了 Promise.all() 的类型推断。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"typescript\">// Let's say we want to have a generic awaited value.\n// We can use the Awaited utility type for this (its source code was part of a previous example),\n// so infinitely nested Promises all resolve to their value.\ntype P1 = Awaited; // typed as string\ntype P2 = Awaited&gt;; // typed as string\ntype P3 = Awaited&gt;&gt;; // typed as string\n</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;导入名称上的类型修饰符: 在普通（非 import type）导入语句中，关键字 type 可用于表示该值只应在类型编译时导入（且可以去除）。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"typescript\">// PREVIOUSLY:\n// The optimal way to import types is to use the `import type` keyword to prevent them from actually being imported after compilation.\nimport { something } from './file';\nimport type { SomeType } from './file';\n// This needs two import statements for the same file.\n// NEW:\n// Now this can be combined into one statement.\nimport { something, type SomeType } from './file';\n</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;const 断言: 在将常量定义为 as const 时，即可将其准确归类为字面量类型。这项功能有多种用例，可以轻松进行准确分类。此功能还会令对象和数组成为 readonly，防止常量对象发生突变。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"typescript\">// PREVIOUSLY:\n// The optimal way to import types is to use the `import type` keyword to prevent them from actually being imported after compilation.\nimport { something } from './file';\nimport type { SomeType } from './file';\n// This needs two import statements for the same file.\n// NEW:\n// Now this can be combined into one statement.\nimport { something, type SomeType } from './file';\n</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;类中各方法的片段补全: 当一个类继承多个方法类型时，编辑器现可为各类型提供建议片段。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><img src=\"https://static001.geekbang.org/wechat/images/df/df5368d7cf6f2edd8a771e40cbf2218a.gif\" /></code></u></u></a></p><p></p><p></p><h3><a><u><u><code lang=\"javascript\">TypeScript 4.6</code></u></u></a></h3><p></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;索引访问推断改进：当直接在键内直接索引一个类型时，如果该类型位于同一对象上，现在其准确率会更高。这也是 TypeScript 现代化特性的良好体现。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"typescript\">interface AllowedTypes {\n'number': number;\n'string': string;\n'boolean': boolean;\n}\n// The Record specifies the kind and value type from the allowed types.\ntype UnionRecord = { [Key in AllowedKeys]:\n{\nkind: Key;\nvalue: AllowedTypes[Key];\nlogValue: (value: AllowedTypes[Key]) =&gt; void;\n}\n}[AllowedKeys];\n// The function logValue only accepts the value of the Record.\nfunction processRecord(record: UnionRecord) {\nrecord.logValue(record.value);\n}\nprocessRecord({\nkind: 'string',\nvalue: 'hello!',\n// The value used to implicitly have the type string | number | boolean,\n// but now is correctly inferred to just string.\nlogValue: value =&gt; {\nconsole.log(value.toUpperCase());\n}\n});\n</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;TypeScript Trace Analyzer ( — generateTrace): &nbsp;--generateTrace</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">选项可在 TypeScript CLI 当中用于生成一个文件，其中包含关于类型检查和编译过程的详情信息。这有助于优化复杂类型。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">tsc --generateTrace trace\ncat trace/trace.json\n&lt;<output><<output><=\"\" code=\"\"></output></code></code></u></u></a></p><p></p><p></p><h3><a><u><u><code lang=\"javascript\"><code lang=\"cs\">TypeScript 4.7</code></code></u></u></a></h3><p></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;在 Node.js 中支持 ECMAScript 模块: 在使用 ES Modules 替代 CommonJS 时，TypeScript 现可支持指定默认值。具体指定在 tsconfig.json 中实现。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><code lang=\"javascript\">...\n\"compilerOptions\": [\n...\n\"module\": \"es2020\"\n]\n...\n</code></code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;package.json 中的类型: &nbsp;package.json 中的 type 字段可被设定为\"module\"，以供 ES Modules 使用 node.js。在大多数情况下，这种方式对 TypeScript 已经足够，不需要前面提到的编译器选项。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><code lang=\"javascript\">...\n\"type\": \"module\"\n...\n</code></code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;实例化表达式: 实例化表达式允许在引用一个值时，指定类型参数。这样可以在不创建包装器的前提下，收窄泛型类型。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><code lang=\"php\">class List {\nprivate list: T[] = [];\nget(key: number): T {\nreturn this.list[key];\n}\npush(value: T): void {\nthis.list.push(value);\n}\n}\nfunction makeList(items: T[]): List {\nconst list = new List();\nitems.forEach(item =&gt; list.push(item));\nreturn list;\n}\n// Let's say we want to have a function that creates a list but only allows certain values.\n// PREVIOUSLY:\n// We need to manually define a wrapper function and pass the argument.\nfunction makeStringList(text: string[]) {\nreturn makeList(text);\n}\n// NEW:\n// Using instantiation expressions, this is much easier.\nconst makeNumberList = makeList;\n</code></code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;扩展对推断类型变量的约束: 在条件类型中推断类型变量时，现在可以使用 extends 直接将其收窄 / 约束。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><code lang=\"typescript\">// Let's say we want to type a type that only gets the first element of an array if it's a string.\n// We can use conditional types for this.\n// PREVIOUSLY:\ntype FirstIfStringOld =\nT extends [infer S, ...unknown[]]\n? S extends string ? S : never\n: never;\n// But this needs two nested conditional types. We can also do it in one.\ntype FirstIfString =\nT extends [string, ...unknown[]]\n// Grab the first type out of `T`\n? T[0]\n: never;\n// This is still suboptimal because we need to index the array for the correct type.\n// NEW:\n// Using extends Constraints on infer Type Variables, this can be declared a lot easier.\ntype FirstIfStringNew =\nT extends [infer S extends string, ...unknown[]]\n? S\n: never;\n// Note that the typing worked the same before, this is just a cleaner syntax.\ntype A = FirstIfStringNew&lt;[string, number, number]&gt;; // typed as string\ntype B = FirstIfStringNew&lt;[\"hello\", number, number]&gt;; // typed as \"hello\"\ntype C = FirstIfStringNew&lt;[\"hello\" | \"world\", boolean]&gt;; // typed as \"hello\" | \"world\"\ntype D = FirstIfStringNew&lt;[boolean, number, string]&gt;; // typed as never\n</code></code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;类型参数的可选变体注释: 泛型在检查是否“匹配”时可以有不同行为，例如对 getter 和 setter，对是否允许继承的判断是相反的。为了明确起见，现在用户可以明确指定。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><code lang=\"javascript\">// Let's say we have an interface / a class that extends another one.\ninterface Animal {\nanimalStuff: any;\n}\ninterface Dog extends Animal {\ndogStuff: any;\n}\n// And we have some generic \"getter\" and \"setter\".\ntype Getter = () =&gt; T;\ntype Setter = (value: T) =&gt; void;\n// If we want to find out if Getter matches Getter or Setter matches Setter, this depends on the covariance.\nfunction useAnimalGetter(getter: Getter) {\ngetter();\n}\n// Now we can pass a Getter into the function.\nuseAnimalGetter((() =&gt; ({ animalStuff: 0 }) as Animal));\n// This obviously works.\n// But what if we want to use a Getter which returns a Dog instead?\nuseAnimalGetter((() =&gt; ({ animalStuff: 0, dogStuff: 0 }) as Dog));\n// This works as well because a Dog is also an Animal.\nfunction useDogGetter(getter: Getter) {\ngetter();\n}\n// If we try the same for the useDogGetter function we will not get the same behavior.\nuseDogGetter((() =&gt; ({ animalStuff: 0 }) as Animal)); // Type error: Property 'dogStuff' is missing in type 'Animal' but required in type 'Dog'.\n// This does not work, because a Dog is expected, not just an Animal.\nuseDogGetter((() =&gt; ({ animalStuff: 0, dogStuff: 0 }) as Dog));\n// This, however, works.\n// Intuitively we would maybe expect the Setters to behave the same, but they don't.\nfunction setAnimalSetter(setter: Setter, value: Animal) {\nsetter(value);\n}\n// If we pass a Setter of the same type it still works.\nsetAnimalSetter((value: Animal) =&gt; {}, { animalStuff: 0 });\nfunction setDogSetter(setter: Setter, value: Dog) {\nsetter(value);\n}\n// Same here.\nsetDogSetter((value: Dog) =&gt; {}, { animalStuff: 0, dogStuff: 0 });\n// But if we pass a Dog Setter into the setAnimalSetter function, the behavior is reversed from the Getters.\nsetAnimalSetter((value: Dog) =&gt; {}, { animalStuff: 0, dogStuff: 0 }); // Type error: Argument of type '(value: Dog) =&gt; void' is not assignable to parameter of type 'Setter'.\n// This time it works the other way around.\nsetDogSetter((value: Animal) =&gt; {}, { animalStuff: 0, dogStuff: 0 });\n// NEW:\n// To signal this to TypeScript (not needed but helpful for readability), use the new Optional Variance Annotations for Type Parameters.\ntype GetterNew = () =&gt; T;\ntype SetterNew = (value: T) =&gt; void;\n</code></code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;使用 moduleSuffixes 实现分辨率自定义: 在使用具有自定义文件后缀的环境时（例如，.ios 用于原生应用构建），现在您可以为 TypeScript 指定这些后缀以正确对导入进行解析。具体指定在 tsconfig.json 中实现。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><code lang=\"python\">...\n\"compilerOptions\": [\n...\n\"module\": [\".ios\", \".native\", \"\"]\n]\n...\nimport * as foo from './foo';\n// This first checks ./foo.ios.ts, ./foo.native.ts, and finally ./foo.ts.\n</code></code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;在编辑器内转到源定义: 在编辑器中，开放新的“转到源定义”菜单项。其功能类似于“转到定义”，但更多指向.ts 和 .js 文件，而非类型定义 (.d.ts)。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><img src=\"https://static001.geekbang.org/wechat/images/cb/cb8e6717c99bfa77c1b952143edeca25.gif\" /></code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><img src=\"https://static001.geekbang.org/wechat/images/aa/aafcc6a9f17ce3871708f31e0eb83f21.gif\" /></code></code></u></u></a></p><p></p><p></p><h3><a><u><u><code lang=\"javascript\"><code lang=\"cs\">TypeScript 4.9</code></code></u></u></a></h3><p></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;satisfies 运算符: satisfies 运算符允许检查与类型间的兼容性，且无需实际分配该类型。这样可以在保持兼容性的同时，获得更准确的类型推断。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><code lang=\"typescript\">// PREVIOUSLY:\n// Let's say we have an object/map/dictionary which stores various items and their colors.\nconst obj = {\nfireTruck: [255, 0, 0],\nbush: '#00ff00',\nocean: [0, 0, 255]\n} // typed as { fireTruck: number[]; bush: string; ocean: number[]; }\n// This implicitly types the properties so we can operate on the arrays and the string.\nconst rgb1 = obj.fireTruck[0]; // typed as number\nconst hex = obj.bush; // typed as string\n// Let's say we only want to allow certain objects.\n// We could use a Record type.\nconst oldObj: Record = {\nfireTruck: [255, 0, 0],\nbush: '#00ff00',\nocean: [0, 0, 255]\n} // typed as Record\n// But now we lose the typings of the properties.\nconst oldRgb1 = oldObj.fireTruck[0]; // typed as string | number\nconst oldHex = oldObj.bush; // typed as string | number\n// NEW:\n// With the satisfies keyword we can check compatibility with a type without actually assigning it.\nconst newObj = {\nfireTruck: [255, 0, 0],\nbush: '#00ff00',\nocean: [0, 0, 255]\n} satisfies Record // typed as { fireTruck: [number, number, number]; bush: string; ocean: [number, number, number]; }\n// And we still have the typings of the properties, the array even got more accurate by becoming a tuple.\nconst newRgb1 = newObj.fireTruck[0]; // typed as number\nconst newRgb4 = newObj.fireTruck[3]; // Type error: Tuple type '[number, number, number]' of length '3' has no element at index '3'.\nconst newHex = newObj.bush; // typed as string\n</code></code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;编辑器中的“删除未使用的导入”与“排序导入”命令: 在编辑器中，新命令（及自动修复）“删除未使用的导入”和“排序导入”让导入管理更加轻松易行。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><img src=\"https://static001.geekbang.org/wechat/images/cf/cf9486e812b0cf2c6b1bab06ece29c8b.gif\" /></code></code></u></u></a></p><p></p><p></p><h5><a><u><u><code lang=\"javascript\"><code lang=\"cs\">原文链接：</code></code></u></u></a></h5><p></p><p><u><u><code lang=\"javascript\"><code lang=\"cs\"><a href=\"https://medium.com/@LinusSchlumberger/all-javascript-and-typescript-features-of-the-last-3-years-629c57e73e42\">https://medium.com/@LinusSchlumberger/all-javascript-and-typescript-features-of-the-last-3-years-629c57e73e42</a>\"</code></code></u></u></p><p></p><p></p><h5><u><u><code lang=\"javascript\"><code lang=\"cs\">相关阅读：</code></code></u></u></h5><p></p><p><u><u><code lang=\"javascript\"><code lang=\"cs\"><a href=\"https://xie.infoq.cn/article/6ff79700fb3bfa972c1beebf3\">TypeScript 与 JavaScript：你应该知道的区别</a>\"</code></code></u></u></p><p><u><u><code lang=\"javascript\"><code lang=\"cs\"><a href=\"https://www.infoq.cn/article/CBb3RhvCHflT42ppOLkR\">JavaScript 框架太多了？相反，是太少了</a>\"</code></code></u></u></p><p><u><u><code lang=\"javascript\"><code lang=\"cs\"><a href=\"https://xie.infoq.cn/article/e976363d22c7ffd126d9b6eb1\">最佳的 18 个 JAVASCRIPT 前端开发框架和库</a>\"</code></code></u></u></p><p><u><u><code lang=\"javascript\"><code lang=\"cs\"><a href=\"https://www.infoq.cn/article/ds994KySqo868U3e8s4N\">我踩过了 TypeScript 的坑，只想告诉你快来</a>\"</code></code></u></u></p>",
    "publish_time": "2023-04-03 12:34:50",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "数据库内核杂谈（二十九）- 多租户(multi-tenant)系统设计的思考（番外）",
    "url": "https://www.infoq.cn/article/qLOvcpaqSy4asOuPV5vd",
    "summary": "<p>欢迎阅读新一期的数据库内核杂谈。这期杂谈，不聊数据库，咱们插入一个番外篇，聊一下多租户(multi-tenant)应用的系统设计。对于多租户系统的思考，源于最近的工作，再结合内核杂谈前几期阅读的关于AWS DynamoDB的论文。我的工作主要是构建云端的服务来支持整个自动驾驶产品的迭代，可以认为是为用户提供SAAS服务。这些服务的质量和稳定性，本质上都可以通过引入正确的多租户系统架构来解决。</p><p>&nbsp;</p><p></p><h1>什么是多租户(multi-tenant)系统架构</h1><p></p><p>多租户系统是一种软件架构：一个服务实例会同时为多个客户或用户（称为租户）提供服务。这种方法允许在租户之间高效共享计算资源、基础设施和服务，同时保持数据隔离和安全性。多租户架构的好处主要在：1）节约成本，资源的共享可以降低供应商和租户的基础设施和维护的成本；2）简化管理，集中执行更新、安全补丁和维护任务，从而使所有租户一次受益并减少管理开销。此外，多租户应用程序还为可扩展性而设计，使系统能够随着租户数量及其资源需求的增长而增长。这确保了在适应多样化客户群体的不断变化需求的同时，能够实现最佳性能和资源利用。</p><p>&nbsp;</p><p>绝大部分（如果不是全部的话）公有云的SAAS服务基本都属于多租户应用。比如AWS的DynamoDB服务，是一款非常受欢迎的key-value的NoSQL系统。对每个用户而言，DynamoDB服务就是一堆简单的调用接口。不同用户之间完全不会感知到彼此的存在，这些用户也不会互相影响（参考 <a href=\"https://www.infoq.cn/article/aEUY5kcI1a3iqGUyGzUy\">https://www.infoq.cn/article/aEUY5kcI1a3iqGUyGzUy</a>\")。</p><p>&nbsp;</p><p></p><h1>设计和开发多租户系统的挑战</h1><p></p><p>天下没有免费的午餐。虽然能带来成本节约和简化管理，但设计多租户系统仍面临着很多挑战。因为开发人员必须在确保效率、安全性和可扩展性的同时，平衡多个租户的需求。主要的挑战在于：</p><p>数据隔离：确保数据的隔离（安全）在多租户应用中至关重要，因为租户的数据必须保持独立且无法被其他租户访问。设计一个能够有效隔离每个租户数据的同时仍允许高效资源共享的系统会很复杂。这需要实施严格的权限控制、面向租户的数据访问和加密，来保护敏感信息。保持性能稳定：多租户应用程序必须为所有租户提供一致的性能，无论用户数量或资源消耗程度如何。这需要设计一个可扩展且稳健的架构，能够处理可变的工作负载并根据需求自动调整资源。必须采用监控和性能优化技术（如负载均衡和缓存）来确保系统顺畅运行。合理管理资源：和保持性能相关，有效分配和管理资源（如计算、存储和网络容量）对多租户应用至关重要。开发人员必须实施资源配额、限流和监控策略，以确保公平分配资源并防止单个租户占用过多资源。提供定制：不同的租户可能在功能、外观或配置方面有独特的要求。设计一个支持定制和可扩展性的多租户应用可能具有挑战性。开发人员必须创建模块化和灵活的架构，允许租户根据其特定需求定制应用程序，而不影响整个系统的稳定性或性能。租户生命周期管理：在多租户环境中处理租户的入驻、升级、降级和退出会非常复杂。开发人员需要建立管理租户生命周期事件的流程和自动化，确保平稳过渡，最大程度地减少服务中断。安全与合规：多租户应用程序必须遵守严格的安全和合规要求，尤其是在处理敏感数据或在受监管行业运营时。实施严格的安全措施（如数据加密、安全访问控制和定期安全审计）非常有挑战性且耗时。计费和计量：在共享环境中，准确跟踪和计费每个租户的资源使用非常复杂。设计一个透明且公平的计费系统需要实施计量和监控机制，以准确捕捉特定租户的使用数据。</p><p>在设计多租户应用时，需要对这些挑战进行仔细的规划和架构决策。我们需要在设计初期中就全盘考量上述的挑战。</p><p>&nbsp;</p><p></p><h1>多租户系统的设计思考</h1><p></p><p>如果你问ChatGPT，哪些是设计多租户系统的最佳实践，它会把上面的这些条目再给你列一下，再给你一些建议（针对每个条目，应该注意哪些）。阅读后，我觉得信息增益不大。倒是AWS的DynamoDB的论文，给了我很多启发。以下是我的思考。</p><p>&nbsp;</p><p></p><h2>用户的权利和义务SLA</h2><p></p><p>用一句话概括就是，设置并管理好用户的预期。在执行层面就是，和用户对齐服务的SLA，并通过技术手段严格遵守SLA。</p><p>&nbsp;</p><p>通常，我们认为服务的SLA就是稳定性几个9，服务中断不超过多少时间，修复时间不超过多长等等，这些SLA当然重要。在我看来，这些SLA定义了用户的权利。DynamoDB服务，还定义了哪些其他的SLA呢？ DynamoDB的表通常被划分为多个partition, 对于每一个 partition（作为计算和存储的基本调度单元），DynamoDB 引入了 Read Capacity Unit（RCU)和 Write Capacity Unit（WCU）来控制其相应的吞吐SLA。RCU 的定义如下，对于一个至多 4KB 的 item，一个 RCU 保证每秒做一次强一致读。同理，WCU 的定义是对于一个至多 4KB 的 item，一个 WCU 保证每秒做一次写操作。将一个表的所有的 partition 的 RCU 和 WCU 求和，即为这个表的总吞吐SLA。举个例子，一个表有4个partition，每个partition如果申请了800 RCU和WCU，那这张表的整体RCU和WCU就是3200，即，这张表应该要保证每秒能进行3200次的读操作和写操作。乍一看，这个SLA依然是用户的权利。但精髓的是，DynamoDB通过严格的throttling机制，同时也限制了这个表的读写上限为3200 QPS。如此，这张表的3200 QPS也变成了用户的义务SLA。即，用户必须遵守义务SLA（当然，DynamoDB是通过技术手段确保了用户必须去遵守），才能享受权利SLA，比如稳定性几个9，返回延时保证在单毫秒级别等等。</p><p>&nbsp;</p><p>这真的是一个非常精妙的设计！通过严格遵守义务SLA，把复杂系统里的很多不确定性因素都避免了。当每个用户都定义好了义务SLA，就不会再出现意外的流量激增（traffic spike）（当然， DynamoDB也引入了一些新颖的设计，来解决这种临时的流量激增，但这不在本文的讨论范围内），因为所有用户的义务SLA的总和就是最大吞吐需求。有了明确的需求，系统可以提前做好充裕的资源分配，也不用担心这些资源会不够。只有当需求（义务SLA）改变的时候，才需要新增资源。</p><p>&nbsp;</p><p></p><h2>Force用户严格遵守义务SLA</h2><p></p><p>多租户系统的一个非常大的挑战就是，一个bad player可能会导致整体服务不稳定从而影响其他租户。这就违反了多租户系统的第一设计原则：不同租户理论上不应该知道其他租户的存在。杜绝bad player出现的最好的方式就是，扼杀在萌芽中。有效的技术手段就是active地throttling（限流），确保用户就不能变成一个bad player。DynamoDB也是这么去做的。</p><p>&nbsp;</p><p></p><h1>其他的多租户系统设计实践</h1><p></p><p>如果能严格遵守上述的设计原则，其他的设计会变得更水到渠成。这里，也总结一下多租户系统的一些其他设计原则：</p><p>做好租户隔离：实施数据分区策略，如单独的数据库、单独的模式或带有租户标识符列的共享模式，以确保数据隐私和安全。此外，应用严格的访问控制和租户上下文感知数据访问，以保护租户数据。设计好可水平扩展性（horizontal scaling）：可水平扩展是多租户系统的关键，必须要能够做到。你可以依赖分布式系统设计来完成，也可以通过申请独立资源，为每个租户独立部署（当然这个方法比较原始）。确保系统可以增加更多资源以适应不断增加的工作负载。通过分布式和云原生来统一部署的好处在于，可以做到动态地扩缩容，也能根据不同租户的业务属性不同，做好削峰填谷，以确保最佳性能和资源利用。定制化和可扩展性：开发支持租户定制、扩展的模块化和灵活的架构。使用可配置设置、插件和基于 API 的界面，允许租户根据其独特要求定制应用程序，而不影响整个系统的稳定性或性能。集中式管理：实施集中式管理系统，用于应用程序更新、安全补丁和维护任务。这简化了管理，减少了开销，并确保所有租户同时受益于改进和修复。可观察性和监控：完善的可观测性属于基本操作。实施全面的监控和可观察性工具，以跟踪应用程序性能、资源使用和潜在问题。使用日志、指标和跟踪解决方案，以获取应用程序健康状况并识别改进方案。计费和计量：设计透明公平的计费系统，准确追踪每个租户的资源使用和成本。实施计量和监控机制，捕获租户特定的使用数据并生成计费报告。</p><p>&nbsp;</p><p></p><h1>总结</h1><p></p><p>这期番外篇，依然是从DynamoDB服务引申出来，讨论了一下多租户系统设计的思考。如果你一定要从这篇文章中获得些什么，就是下面这两句话：提供一个稳定的，严格遵守SLA的服务，远比提供一个不稳定，但偶尔能超越预期的服务要对用户更友善。设计多租户系统时，除了和用户定义好权利SLA，也定义好义务SLA，并严格执行这些SLA。</p><p>&nbsp;</p><p></p><h1>内核杂谈微信群和知识星球</h1><p></p><p>内核杂谈有个微信群，大家会在上面讨论数据库相关话题。目前群人数快400人啦，所以已经不能分享群名片加入了，可以添加我的微信（zhongxiangu）或者是内核杂谈编辑的微信（wyp_34358），备注：内核杂谈。</p><p>&nbsp;</p><p>除了数据库内核的专题blog，我还会push自己分享每天看到的有趣的IT新闻，放在我的知识星球里（免费的，为爱发电），欢迎加入。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/70/70bf009e0765b8417a2908a94be2ec06.jpeg\" /></p><p></p><h5>相关阅读：</h5><p></p><p><a href=\"https://xie.infoq.cn/article/9472adf321bcce7bc4835eee6\">分享：从数据库开发者的视角，预测 5 个开发趋势</a>\"</p><p><a href=\"https://xie.infoq.cn/article/fb83fe3ef4cb38bb15e2b5e3d\">腾讯云数据库性能打破世界纪录 每分钟可处理 8.14 亿笔交易</a>\"</p><p><a href=\"https://xie.infoq.cn/article/6b4823fedfe05fb494a4055a7\">从传统数据库痛点看分布式数据库选型问题</a>\"</p><p><a href=\"https://xie.infoq.cn/article/d22c59d43971c06c71adc6e7c\">开源面对面：浅谈数据库技术与人工智能的结合与实践</a>\"</p>",
    "publish_time": "2023-04-03 13:28:40",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "全球首个封禁ChatGPT的国家：OpenAI涉嫌数据泄露，如不整改将罚2000万欧元",
    "url": "https://www.infoq.cn/article/0Ajci2Edm9HHZ0O7kKRt",
    "summary": "<p></p><blockquote>由于意大利是首个宣布禁用 ChatGPT 的发达国家，也有声音认为，意大利此举或许会引发连锁反应。</blockquote><p></p><p></p><h2>意大利宣布禁用 ChatGPT</h2><p></p><p></p><p>据路透社报道，意大利数据保护局 Garante 在 3 月 31 日宣布暂时禁用 <a href=\"https://www.infoq.cn/theme/173\">ChatGPT</a>\"，并对其涉嫌违反隐私规则展开了调查。目前，<a href=\"https://www.infoq.cn/article/ZWixRo76hFsOw38tRHNF\">OpenAI</a>\" 已在意大利下线 ChatGPT，意大利也成为了全球首个封禁 ChatGPT 的国家（部分国家和地区在一开始就无法使用 ChatGPT。）</p><p></p><p>意大利数据保护局 Garante 认为，3 月 20 日 ChatGPT 平台出现了用户对话数据和付款服务支付信息丢失情况。此外平台没有就收集处理用户信息进行告知，缺乏大量收集和存储个人信息的法律依据。</p><p></p><p>意大利个人数据监管局（GPDP）指出，由于违反欧盟的《通用数据保护条例》（GDPR）和意大利自己的数据保护法，他们将立即对涉及意大利公民的“个人数据处理做临时限制”。</p><p></p><p>GPDP 在声明中强调，“我们发现，OpenAI 对其收集用户及各相关方数据的行为缺乏清晰说明。”另外，ChatGPT 对用户数据的处理还可能造成错误印象，“因为 ChatGPT 提供的信息并不一定与真实数据相对应。”</p><p></p><p>GPDP 还对 OpenAI 忽略用户年龄审查表达了担忧。作为微软的投资对象，OpenAI 曾提到其 ChatGPT 是专为 13 岁或以上的用户群体所设计。但这项服务在发布后并没有对用户做年龄验证，GPDP 认为“考虑到其发展程度和自我意识，未成年人在使用时可能接触到绝对不合适的答案。”</p><p></p><p>GPDP 提到，临时限制将适用于在意大利境内从相关各方处收集到的全部个人数据，这实质上就是封禁了 ChatGPT 服务。直到 OpenAI 能够证明其已经解决了 GPDP 发现的问题，封禁才会被解除。</p><p></p><p>OpenAI 表示，应 Garante 的要求，它已为意大利用户禁用了 ChatGPT。ChatGPT 网页上的一则通知称，该网站的所有者可能设置了限制，阻止用户访问该网站。OpenAI 补充说：“我们在训练我们的人工智能系统（如 ChatGPT）努力减少个人数据，因为我们希望我们的人工智能了解世界，而不是了解个人。”</p><p></p><p>此外，OpenAI 方面有 20 天时间对 GPDP 的其他指控做出回应，否则将面临高达 2000 万欧元（约合 2170 万美元）或全球年营业额 4% 的罚款（以较高者为准）。</p><p></p><p>由于意大利是首个宣布禁用 ChatGPT 的发达国家，也有声音认为，意大利此举或许会引发连锁反应。</p><p></p><h2>监管机构瞄准 AI</h2><p></p><p></p><p>事实上，这不是监管机构首次对涉嫌不当行为的 AI 采取行动。</p><p></p><p>据彭博社近日报道，美国联邦贸易委员会（FTC）建议提起诉讼，指控亚马逊的 <a href=\"https://www.infoq.cn/article/QNcQ16QQRGK7tQhOqeU9\">Alexa</a>\" 音箱在未经父母同意的情况下收集 13 岁以下儿童的信息，违反了《儿童在线隐私保护法》。司法部最早可能在 4 月代表联邦贸易委员会提起诉讼。</p><p></p><p>今年 2 月，意大利个人数据监管局（GPDP）也曾对 Replika 发出禁令。</p><p></p><p>Replika 是一款 AI 聊天机器人应用，用户不但能与之交谈，甚至可以将其设定为虚拟伴侣。GPDP 表示，他们担心 Replika 可能会令“仍处于发育阶段（即未成年人）”或“处于情绪脆弱状态”的个人陷入风险。之前也曾有媒体报道称，Replika 公司 CEO Eugenia Kuyda 承认这款应用愚弄过用户，让原本情绪稳定的个人误以为 Replika 具有感知能力、甚至与这款聊天机器人建立了情感关系。</p><p></p><p>意大利当局还认定 Replika 缺乏年龄验证机制，因此在今年 2 月宣布 Replika 违反了 GDPR 并以非法方式处理个人数据。</p><p></p><p>国际律师事务所 Ropes &amp; Gray 驻伦敦的隐私律师 Edward Machin 认为，ChatGPT 和 Replika 这类工具刚刚出现，人们很容易忽略其在“几周”之间就已经全面蹿红。</p><p></p><p>Machin 在一份声明中表示，大多数用户可能没有认真考虑过自己的数据被 OpenAI 用于训练会对其隐私造成哪些影响。“这里的问题是，对方没有向用户提供信息以确保做出明智的决定。另外，其实没有法理依据来支撑其处理用户数据的行为。”</p><p></p><p>Machin 强调，封禁 OpenAI 继续接触意大利民众的数据是 GPDP 所能采取的最有力的干预手段之一。“我认为欧洲各地的监管机构应该会感谢 GPDP 率先采取了这一措施，相信后续还会有更多国家决定跟进并发布类似的禁令。”</p><p></p><p>对于 ChatGPT 而言，最近正值多事之秋。除了面临来自意大利方面的压力，还要面临非营利组织人工智能与数字政策中心（CAIDP）的投诉。</p><p></p><p>据 The Verge 3 月 30 日报道，非营利组织人工智能与数字政策中心（CAIDP）向美国联邦贸易委员会（FTC）投诉，要求 FTC 调查 OpenAI 违反消费者保护规则的行为，该组织认为 GPT-4 具有偏见性、欺骗性、对隐私和公共安全构成风险。</p><p></p><p>CAIDP 认为，OpenAI 违反了 FTC 对人工智能产品的指导，并违反了 FTC 法案第 5 条，该法案禁止不公平和欺骗性的商业行为。CAIDP 敦促 FTC 对 OpenAI 进行调查，并暂停其大型语言模型的商业部署，包括 ChatGPT 的最新版本。</p><p></p><p>参考链接：</p><p><a href=\"https://www.theregister.com/2023/03/31/italy_bans_chatgpt_for_unlawful/\">https://www.theregister.com/2023/03/31/italy_bans_chatgpt_for_unlawful/</a>\"</p>",
    "publish_time": "2023-04-03 14:08:46",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "2023开放原子校源行（北京站）成功举办",
    "url": "https://www.infoq.cn/article/6ZxFDYIa5Vf8eG0XUVgh",
    "summary": "<p>4月2日，以“聚缘于校，开源共行”为主题的开放原子校源行（北京站）活动在北京航空航天大学举行。工业和信息化部党组成员、副部长王江平，北京航空航天大学党委书记赵长禄，教育部高等教育司副司长王启明出席活动并致辞;<a href=\"https://www.openatom.org/\">开放原子开源基金会</a>\"理事长孙文龙发布“开放原子校源行”总体方案，开放原子开源基金会副理事长、腾讯公司副总裁王巨宏，北京航空航天大学软件学院院长胡春明发表主题演讲；63所高校、央视网与基金会签署合作协议;与会领导为53个“开放原子开源社团”授牌。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/96/96a1f5a23a7d1563456f5d1a0f1fd4b4.jpeg\" /></p><p></p><p>王江平表示，开源人才是开源体系建设的基础和关键。加快推进开源“进校园”，积极宣传推广开源文化，对于厚培开源人才底座、夯实开源发展基础、提升软件源头创新和供给能力具有重要意义。下一步，开放原子开源基金会要坚持系统性思维，引导产、学、研、用、媒等各方资源向开源人才倾斜，切实推进“校源行”活动取得实效。高校要发挥育人主体作用，33所特色化示范性软件学院、7所工业和信息化部部属高校要发挥示范带头作用，将开源贡献作为学生评优评先、考试考核的重要依据，将高校建成开源文化传播的活水泉、优质开源项目的策源地。企业要积极推动开源人才供需对接，在教师资源、实践平台、项目交流等方面加大对“校源行”活动的支持力度，带动开源企业、开源项目、开源社区“走进校园”。青年学生要贡献新生力量，在校期间苦练本领、创先争优，步入社会后，努力成为行业的骨干、时代的先锋，成为具有家国情怀、卓越创新能力的开源人才。</p><p></p><p>赵长禄指出，北京航空航天大学作为国内最早开展软件技术和软件工程研究的高校之一，围绕开源战略，发挥学科平台和人才优势，开展了一系列探索：一是打造开源育人体系。面向本研学生开设开源课程，鼓励学生参加开源项目。二是组织开源科技攻关。围绕开源软件、群体化软件工程和群体智能方向，承担了一批重大任务。三是营造校园开源生态。支持学生成立开放原子北航开源社团，积极传播开源理念和开源文化。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/1b/1b558b6dc202e554620bcaf19eecb584.jpeg\" /></p><p></p><p>秘书长冯冠霖与央视网总经理助理刘科签署协议</p><p>理事长孙文龙和央视网总经理王冰松鉴签</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/5c/5c1bb3789170b0205eea9e0bd4d90a49.jpeg\" /></p><p></p><p>孙文龙理事长、王巨宏副理事长为53个“开放原子开源社团”授牌</p><p></p><p>活动由开放原子开源基金会、央视网联合主办，北京航空航天大学承办。工业和信息化部信息技术发展司、人事教育司相关负责同志，央视网负责同志，全国高校代表、600多名北京航空航天大学学生及相关企业、开源项目负责人等参加活动。</p><p></p><p>央视网、新华网、人民日报社、经济日报、中国教育报、人民邮电报、中国电子报、中国工业报社、至顶网、InfoQ、51CTO、CSDN等多家媒体对此次活动进行了专题报道。</p>",
    "publish_time": "2023-04-03 15:55:19",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "文心一言员工跳槽工资翻倍；推特算法“面向老板编程”；马云回来了，阿里分拆了｜Q资讯",
    "url": "https://www.infoq.cn/article/JmTM6uLv1PyTZjsJbKNY",
    "summary": "<p></p><p></p><h2>科技公司</h2><p></p><p></p><h4>文心一言员工跳槽工资翻倍，“百万年薪不是问题”</h4><p></p><p>&nbsp;</p><p>有消息称，<a href=\"https://www.infoq.cn/article/Mz92EUBpvOwykbNG2iMz\">文心一言</a>\"团队员工开始受到友商挖角。有猎头表示，文心员工被疯狂追捧，3 年员工身价翻倍，5-8 年员工另算，百万年薪不是问题。一名长期跟踪 AI 人才的猎头证实了这一消息，他用“疯狂”来形容这场抢人大战。</p><p>&nbsp;</p><p>据悉，除了腾讯、网易、米哈游等在 AI 技术上探索已久的游戏大厂之外，三七互娱、完美世界、巨人网络等上市大厂也都一并加入其中，甚至掏出了近百万年薪招揽人才。</p><p>&nbsp;</p><p></p><h4>“千人联名”暂停更强 AI 开发引激战</h4><p></p><p>&nbsp;</p><p>生命未来研究所近日发布公开信，呼吁 AI 实验室立即暂停训练比 GPT-4 更强的 AI 模型，暂停至少6个月。据悉，马斯克、图灵奖得主 Yoshua Bengio、Stability AI 创始人 Emad Mostaque 等上千名科技大佬联名签署该信。</p><p>&nbsp;</p><p>对此，一众 AI 大牛发文公开反对。吴恩达表示在 GPT-4 出现之后要求 AI 训练暂停 6 个月是很可怕的事情：它（GPT-4）在教育、医疗保健、食品等领域都有很多新的应用，这将帮助许多人。图灵奖巨头LeCun称，我不同意这封信的前提。</p><p></p><h4>意大利禁止使用 ChatGPT，并限制 OpenAl 处理意大利用户信息</h4><p></p><p>&nbsp;</p><p>3月31日消息，意大利数据保护机构对 OpenAl 公司非法收集用户信息展开调查。意大利个人数据</p><p>保护局今天宣布，即日起禁止使用聊天机器人<a href=\"https://www.infoq.cn/article/uZFepbwFzA9uoHEiRLQR\"> ChatGPT</a>\"，并限制开发这一平台的美国人工智能公司 OpenAl 处理意大利用户信息。同时，意大利个人数据保护局指出，本月20日，ChatGPT 平台出现了“用户对话数据和付款服务支付信息丢失”的情况。</p><p>&nbsp;</p><p>此外，该平台没有就收集处理用户信息进行告知，缺乏大量收集和存储个人信息的法律依据。OpenAl 公司“必须在20天内通过其在欧洲的代表向意大利个人数据保护局通报公司执行保护局要求而采取的措施”，否则将被处以最高2千万欧元或公司全球年营业额4%的罚款。</p><p>&nbsp;</p><p></p><h4>马斯克开源算法，网友发现Twitter“面向老板编程”</h4><p></p><p>&nbsp;</p><p>3 月 31 日，正如马斯克一再承诺的那样，<a href=\"https://www.infoq.cn/news/3OOPEivwhT0gLcKP0Nwl\">Twitter 已将其部分源代码正式开源</a>\"，其中包括在用户时间线中推荐推文的算法。目前，该项目在 GitHub 已收获 10k+ 个 Star。马斯克表示，每过 24 小时到 48 小时，Twitter 会根据用户建议对推荐算法进行一次更新。</p><p>&nbsp;</p><p>外媒发现，Twitter 的算法可能会根据来源不同地对待推文。Twitter 的算法专门标记了“推文作者是否是 Elon Musk”还有其他标签表明作者是否是“高级用户”等。代码公开的几小时内，有人在 Twitter 代码中找到了一些“奇怪”的地方，比如马斯克在 Twitter 算法中有自己的特征类。</p><p>&nbsp;</p><p></p><h4>快速变现！微软&nbsp;Bing Chat&nbsp;在回复中加入广告</h4><p></p><p>&nbsp;</p><p>据外媒报道，微软公司正在通过&nbsp;Bing Chat&nbsp;搜索引擎的回复来销售广告，这也凸显了该人工智能工具的潜在收入模式。据了解，微软已经与一些参与 Microsoft Start 新闻源服务的合作伙伴进行了会面。这些合作伙伴向微软提供了反馈，告诉微软可以如何利用 Bing Chat 来链接到他们的内容和服务。</p><p>&nbsp;</p><p>由于微软仍然认为这些广告计划是“早期想法”，因此很有可能在未来几个月内，Bing Chat 的广告格式和整体广告体验会发生变化。</p><p>&nbsp;</p><p></p><h4>马云回国现身杭州，首谈 ChatGPT</h4><p></p><p>&nbsp;</p><p>3月27日，马云近日现身杭州阿里投资创办的 K12 云谷学校。据报道，马云称，ChatGPT 已经对教育带来挑战，但是 ChatGPT 这一类技术只是 AI 时代的开始。我们要用人工智能去解决问题，而不是被人工智能所控制，虽然人的体力、脑力比不过机器，但机器只有“芯”，而人有“心”。</p><p>&nbsp;</p><p>他认为，工业时代是知识驱动，知识的竞争；数字时代，是智慧驱动，是创造力和想象力的竞争，是领导力、担当力、责任的竞争，是独立思考的竞争。</p><p>&nbsp;</p><p></p><h4>搜狗输入法之父加入王慧文 AI 团队</h4><p></p><p>&nbsp;</p><p>有着搜狗输入法之父之称的马占凯日前在微博上宣布加入美团创始人之一王慧文创立的光年之外公司，共赴 AGI 通用人工智能的伟大征程。马占凯表示，“大模型为基础的 AGI 开启了第四次科技革命，这将是一个多层次多波次的大浪潮，最终会改变一切，我必须参与其中。”</p><p>&nbsp;</p><p>2005年，马占凯首次提出将搜索和输入法结合产品理念，研发出搜狗输入法，被称为“搜狗输入法之父”。2009年4月，马占凯离开搜狗并加盟奇虎360，2012年3月，马占凯加盟美团网。</p><p></p><h4>阿里启动重大组织变革：除了淘宝天猫，其他业务都可独立上市</h4><p></p><p>&nbsp;</p><p>3月28日，阿里巴巴集团董事会主席兼首席执行官张勇<a href=\"https://www.infoq.cn/article/1355ucJPDy1zNadh4yhp\">发布全员信</a>\"，宣布启动“1+6+N”组织变革。在阿里巴巴集团之下，将设立阿里云智能、淘宝天猫商业、本地生活、菜鸟、国际数字商业、大文娱等六大业务集团和多家业务公司。业务集团和业务公司分别成立董事会，实行各业务集团和业务公司董事会领导下的 CEO 负责制，阿里巴巴集团全面实行控股公司管理。</p><p>&nbsp;</p><p>阿里巴巴首席财务官徐宏补充称，在所有的业务板块和业务公司里，除了淘宝天猫商业集团，其他所有的业务集团和业务公司最终都会形成可独立融资和分拆，包括寻找独立上市主体。</p><p>&nbsp;</p><p></p><h4>曝暴雪 CEO 曾要求网易一次性支付5亿美元才能续约</h4><p></p><p>&nbsp;</p><p>近日，外媒《纽约时报》发文称，动视暴雪 CEO 鲍比・考迪克曾向网易开出“一次性支付 5 亿美元预付金”的天价续约条件。如果网易预先支付 5 亿美元，那么动视暴雪就同意与其签订新协议，但最终网易拒绝了这一不合理的“天价”方案。</p><p>&nbsp;</p><p>报道称，鲍比早在合作谈判开始前就对网易“心存不满”，只因网易投资了他不希望投资的公司。暴雪国服停服后，暴雪一直在尝试寻找新的合作伙伴，但却始终没有“接盘侠”。</p><p>&nbsp;</p><p></p><h4>微软2022年员工薪水曝光：软件工程师最高年薪28.8万美元</h4><p></p><p>&nbsp;</p><p>据报道，微软近日在一份工作签证申请中披露了其员工的薪待遇。该文件显示，微软软件工程师的最高年薪为28.8万美元，而硬件工程师的最高年薪为23.9万美元。</p><p>&nbsp;</p><p>微软并没有主动透明化其员工的薪资，但这些信息在近日微软提交给美国外籍劳工认证办公室（OFLC）的一份工作签证申请中得以被披露。文件显示，2022年微软件工程师的年薪在9.4万美元至28.8万美元之间，而硬件工程师的年薪在11.5万美元至23.9万美元。</p><p>&nbsp;</p><p></p><h2>IT业界</h2><p></p><p>&nbsp;</p><p></p><h4>Twitter 要求 GitHub 披露其源代码上传者的身份，法庭签署传票</h4><p></p><p>&nbsp;</p><p>Twitter 上周披露它的部分源代码被人在今年初上传到 GitHub。上周五 Twitter 向北加州地区法院递交申请，要求法庭签发传票强迫 GitHub 披露源代码上传者 Free Speech Enthusiast 的身份。</p><p>&nbsp;</p><p>本周二法庭书记员签署了传票，GitHub 需要在 4 月 3 日前提供上传者所有的身份信息，包括姓名、地址、电话号码、电邮地址、社媒档案数据和 IP 地址。GitHub 还被要求提供 Free Speech Enthusiast 所上传代码仓库中发布、上传、下载或修改数据的用户的相同类型的信息。</p><p>&nbsp;</p><p></p><h4>curl 项目获彭博社一万美金的捐赠</h4><p></p><p>&nbsp;</p><p>curl 项目作者 Daniel Stenberg 称收到了彭博社开源项目办公室来函，curl 项目成为彭博社 FOSS Contributor Fund 基金的首个赞助对象，彭博社通过 Open Source Collective 向其资助 1 万美元。curl 不能自己持有资金或任何资产，其所有资金都由 Open Source Collective 托管。</p><p>&nbsp;</p><p>近日，curl 团队发布了最新的8.0.0 版本。虽然头顶主要版本的编号，但该版本并未做出任何突破性的变更或升级，主要由于恰逢 curl 诞生 25 周年，所以用了 8.0.0 表示庆贺。这次的版本不含任何 API 或 ABI 中断。</p><p>&nbsp;</p>",
    "publish_time": "2023-04-03 16:42:20",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "要「解放」数据，浪潮云抢先押注下一个技术风口",
    "url": "https://www.infoq.cn/article/5gu7AV0O4Q2PPBusD2Jo",
    "summary": "<p></p><p>3月29日，InfoQ获悉，浪潮云发布了数据云业务战略，推动可信数据自由流动。</p><p>&nbsp;</p><p></p><h2>数据云进入发展元年</h2><p></p><p>&nbsp;</p><p>发布会现场，IDC分析师钟振山分享了数据云的发展现状。</p><p>&nbsp;</p><p>现在正处在数据爆发的阶段，IDC预测，未来五年，全球数据量将会增长一倍以上，这其中，中国本土的数据量会仅次于北美地区，达到大概56.16ZB的规模，另外年复合增长率接近25%，增长率将成全球第一，也就是说，未来几年中国将会超越北美地区成为全球最大的数据市场。</p><p>&nbsp;</p><p>但在这个过程中，一个有意思的现象是，数据的总量在不断增长，但真正使用的数据或产生价值的数据只占总数据量非常小的一部分。</p><p>&nbsp;</p><p>不过这一现象在最近几个月出现了根本性的颠覆，原因就是ChatGPT以及AIGC超级应用的出现。这种应用的背后是千亿级参数大规模的大模型，它们需要对海量数据进行标注和训练，从而达到相对智能的状态。随着应用技术不断普及和成熟，可以预见到，未来数据的使用，数据的价值会产生根本性改变。所有的数据将来都可以被利用起来，从而为企业和社会产生相应的价值。</p><p>&nbsp;</p><p>另外，现在总数据量中，大部分的数据来源于企业级，大概占70%比例，基本上来源于以下几个行业，政府、媒体、专业服务，金融、医疗、零售等。这些行业都具备一个比较普遍的共性，它们都有巨大的数据量产生。这为企业带来的巨大挑战是，如何有效存储、保护、使用和管理分析企业内部的数据。</p><p>&nbsp;</p><p>回到ChatGPT的出现来看这个问题，可以想象，对于一个企业来说，想自建这类应用基本不太可能。所以，企业如果真正将来希望自身的数据以及行业内的数据产生更大的价值，必须依赖于基于云计算的技术。也就是，未来对于云端的存储和算力的资源需求，会有爆发性的增长。</p><p>&nbsp;</p><p>IDC预计，到2026年大概27%的数据会产生于云端，另外可能会有60%左右的数据，会被存储在云端，在企业级市场比例会更高，大概达到70%-80%左右。在未来，企业更加关注的是如何使用分布式共享式的资源池，实现对于数据价值的深度挖掘。</p><p>&nbsp;</p><p>对企业来说，在进行数字化转型过程中，需要意识到，整体意识形态需要逐步地从数据上云转向数据在云上，真正实现对于数据深层价值深度的挖掘。IDC看到，企业的CIO等管理层也更加关注数据云相关的产品或者服务所带来的安全性、灵活性以及低成本和高效化的特点，数据安全仍然是企业在上云时最关注的话题，如何合法合规去使用在云上的资源，势必会成为一个企业今后在数字化转型历程中最关键的因素。</p><p>&nbsp;</p><p>数据云的服务出现，会给企业提供更加可信任的空间，可以实现在数据全周期内安全管控。最终企业想要的是统一的、全面的、安全的数据访问和管理流程。这个流程会取代过去传统的以数据分发和系统维护升级的传统运维方式。</p><p>&nbsp;</p><p>数据云主要具备几大优势，第一安全性，第二是全面性，第三是灵活性，第四是可见一站式服务。数据云这种服务，不同于传统的解决方案或者平台类或者数据中台类产品的地方在于，它更多突出即视化的概念，为企业提供更加开放灵活的环境，帮助企业实现转型。市场变化非常快速，企业需要具备更有效的，或者更高效的开发能力，才能应对数字经济下整体的大的市场环境。</p><p>&nbsp;</p><p>在企业逐步从数据上云转变到云上数据的过程中，IDC认为其中存在四个阶段。第一是业务流程化，第二是管理平台化，第三是应用繁衍化，第四是底座生态化。</p><p>&nbsp;</p><p>现在国内绝大多数数字化转型企业，它们处在第一或者第二阶段，也就是，它们首先需要把内部的流程和管理机制数字化之后，才能够真正实现数字化转型整体的价值。这也说明，我们在数字化转型道路上还有很长路要走。从另一角度看，企业在数字化转型道路上，还有更多价值可以挖掘，尤其像云计算、人工智能这种技术，如何把它真正融入到企业核心业务当中去，让企业内部的核心资产，也就是数据资产产生更大的价值。</p><p>&nbsp;</p><p>数据云最终的目标是打造安全的数据与业务向融合的平台，这个平台一定是以云计算技术为底座，为企业通过一系列新兴的科技，比如区块链，包括联邦学习、加密计算等等，为企业来提供安全以及合规的数据处理环境。</p><p>&nbsp;</p><p>同时，企业也需要能够有能力去快速的开发和迭代出业务，跟业务强相关的应用，这些特点都是云厂商主要的技术特点，也就是说，未来云计算以及相关的云基础供应方，将会在产业以及企业的数字化转型进程中起到非常关键的作用。</p><p>&nbsp;</p><p>从行业角度来讲，现在可以看到，大部分的数据云的行业应用主要是集中在智慧政务、数字城市管理，以及产业智能化三个方面。可以预见到，随着数据云以及数据要素的概念逐渐成熟，以及技术逐渐普及，未来在供应链，在工业、农业，应急等传统行业里面，同样存在巨大的市场潜力和空间。</p><p>&nbsp;</p><p>从交付模式角度来看，模型即服务，是一个未来交付的主要方式，厂商与丰富行业经验以及技术相融合，可以为企业提供标准化智能化和产品化的数据标准数据服务产品。现阶段大部分的应用主要是集中在政府侧，从整体数字中国进程来讲，政府将会起到非常关键的支点作用。</p><p>&nbsp;</p><p>2022年是数据云产业发展的元年，全球有越来越多的厂商在不断地布局数据云产业，云厂商方面，去年谷歌已经发布了它们第一款数据云产品；在国内，浪潮云发布了数据云战略。</p><p>浪潮集团执行总裁、总工程师，浪潮云董事长肖雪表示，“数据的指数级增长和算力的线性增长带来的算力需求和算力发展不匹配的问题日益突出。如何增加算力供给，提高算力利用率成为急需解决的问题。在这方面，浪潮云进行了大量实践，可以提供一站式运维专家级服务，支持政府、行业、企业的不同计算需求。”</p><p>&nbsp;</p><p></p><h2>浪潮数据云发布</h2><p></p><p>&nbsp;</p><p>&nbsp;</p><p>回归产业自身，数据云将如何助力政企用户释放海量数据价值。浪潮云给出答案——基础设施先行。数据空间作为实现数据开放共享和可信流通的新型基础设施，基于“可用不可见、可控可计量”的应用模式，为数据要素市场化提供实现路径。</p><p>&nbsp;</p><p>浪潮云总经理颜亮中表示，浪潮云以数据为核心，从新要素、新产品、新模式三个方面出发，推出浪潮数据云，提供支撑数据空间的分布式数据基础设施服务，秉承数据优先（Data First），围绕“数采-数算-数用”价值链与数据可信自由流通，打造新产品，应用新模式，释放数据价值。</p><p>&nbsp;</p><p>浪潮云正式发布数据云业务战略——百城千业计划，进一步迭代深化专业、生态、可信赖三大核心优势，通过百亿投入打造联合运营模式，依托数据云联盟持续加大生态合作，计划在十八个月内实现浪潮数据云在百城千业的落地覆盖。</p><p>&nbsp;</p><p></p><h3>浪潮为什么选择数据云？</h3><p></p><p>&nbsp;</p><p>浪潮云总经理颜亮详细阐述了，浪潮选择数据云方向背后的考量。</p><p>&nbsp;</p><p>一方面大的背景是，全球云厂商、大数据厂商都在朝这个方向尝试，关键词围绕着数据：数据现在到底发展到了什么程度，面临着什么样的问题，企业为什么奔着这个方向集中精力找新的解决方案。</p><p>&nbsp;</p><p>近10年来，人们对数据的理解不断随着时代变迁。2011年《大众科学》提到，数据就是力量，2017年《经济学人》点出了世界上最有价值的资源不再是石油，而是数据。到2020年，出现了云和数据的结合，创造新的竞争力，这时全球各国都已或早或晚的提出了自己的数据战略。由此可见，在发展过程中，大家逐步接受了数据是新一代的能源的理念。与此同时，未来不论是中国还是全球，数据的增速仍然非常之快。</p><p>&nbsp;</p><p>但是问题来了，数据作为新一代能源，怎么“解放”它？现在这个问题还比较模糊。从中国的角度讲，我们具备海量数据优势，如何用新的技术、新的工具，去“解放”这些海量的数据是关注的重点。</p><p>&nbsp;</p><p>过去这几年，全国各地都在尝试“解放”数据。但数据“解放”还面临一些困境，数据实际上不是没有发挥价值，数据在领域内或者在封闭体系内发挥了巨大的价值。但面向产业与企业价值还不够大，数据在企业内、在行业的赋能还是隐形的，这意味着数据交易的商业模式碰到了困难。</p><p>&nbsp;</p><p>一个新的商业模式成功不成功，往底下需要钻两层，一是支撑商业模式的运营体系，在企业里是企业的运行体系，在产业里面是产业的运行环境，再往下一层是基础设施。我们过去总以为云计算就是数据的基础设施，现在来看，只能算是基础设施的基础设施。还应该有新的层次，面向数据的直接服务于数据的基础设施。由此看，数据的商业模式上受困于运营支持体系，以及数据基础设施不成形。</p><p>&nbsp;</p><p>数据基础设施服务对象是数据，过去数据不需要基础设施，因为它长在应用里。如果数据给算力解耦，数据作为独立存在的时候，怎么服务于它，怎么支撑于它？过去所有信息化系统是支撑应用的，某个系统上云，某个系统建设项目，是基于应用的，所有的数据都跟着应用走的，“住在应用的家里”。</p><p>&nbsp;</p><p>我国从国家层面成立了数据局，各个地方有大数据局，不是奔着应用去的，它服务应用，数据是独立对象。现在一些政府正在探索数据的新一代基础设施，包括数据快车、数据快通道等。</p><p>&nbsp;</p><p>总结来说，数据云就是怎么弥补和怎么提升面向数据的基础设施。在数据的基础设施中，数据云只是它组成一部分。这是一件需要整个社会为之努力的事情，所以可以看到，现在是政府主导在建设。</p><p>&nbsp;</p><p>数据云的概念最早在2013年提出来，2020年，欧盟发展了这个概念，称之为数据空间。数据空间才有可能是数据的基础设施，或者是数据的“家”。数据空间的结构包含数据地图、认证中心，审计清算等，企业通过连接器再到数据空间，产生真的数据交换，或者是数据交易和流通，统一身份认证、容器管理、数据存储、区块链等，这是公共能力，是数据云要供给的核心部分，这部分是政府牵头云服务商来做的。数据空间体系，底下支撑的是云服务商。公共能力上面是运行面，运行面是面向企业，面向政府，面向具像的组织，再往上是数据地图、审计清算等。</p><p>&nbsp;</p><p></p><h3>提出解决思路：打造数据云来支撑数据空间建设</h3><p></p><p>&nbsp;</p><p>浪潮云的解决思路是通过打造数据云来支撑数据空间建设。具体是以数据为主轴，以数据空间为基础设施，以数据云为技术支撑。数据云支撑数据空间的分布式数据基础设施服务。</p><p>&nbsp;</p><p>数据云有三个创新之处，第一个是新要素，新的理解是Data First，数据优先，相对于土地，劳动力、资本等三要素，数据最大的特点是它没有边际成本，它的稀缺性是人为的，它不是自然属性。既然是人为的稀缺性，就可以通过人为的方式去解决，加大它的流通就能提升效率。</p><p>&nbsp;</p><p>第二是新产品。从认知到理论，从理论到技术，从技术到工具，最后直接帮到社会、用户的是工具，就算是社会基础设施，也无非是工具集，一定要有技术的产品化，新产品要出来。具体来说，在数据采集、数据计算、数据应用、数据流通领域都有产品板块，云包含了采集端，从分布式计算平台，IoT平台，实时数据库，分布式数据库，这都是浪潮基于技术形成的服务。</p><p>&nbsp;</p><p>第三是新模式，数据既然独立了，就得把它当做一个对象去运营，但现在真正把数据作为独立要素去运营的少之又少，这需要平台支撑。此外还需要开放的生态系统，数据中台、数据平台必须跟云耦合在一起，数据云要跨云，要跨算力系统，数据云要有跨算力系统的能力，才有可能形成大的流通支撑。从厂商角度来讲，我们奔着开放生态的方向去做，浪潮云有自己的算力平台，但解耦，支撑其他的云平台。另外，要建设管理运营服务商，一定有独立的服务商出来，承担各自的服务角色，政府是政策的主管和监管部门。</p><p>&nbsp;</p><p>浪潮云的计划百城千业，投入100亿，建设100朵城市的数据云。基于数据云有区域的概念，因为政府的驱动基于区域概念，然后再领域，&nbsp;100个城市怎么赋能千业或者支撑千业数字化转型，还是通过数据云的落地，结合政府的落地，再结合市场化现在可以推动的数据。</p><p>&nbsp;</p><p>此外，赛迪顾问还在现场发起成立了开放性生态联盟——数据云联盟。&nbsp;赛迪顾问云计算和大数据研究中心总经理郑昊介绍，当前数据云联盟已吸纳493家生态伙伴加入，联盟将由浪潮云担任理事长单位，以浪潮数据云所提供的分布式数据基础设施服务为支撑，面向联盟成员开放数据服务、数据模型、数据应用等能力，实现成员间的信息资源共享和多层次合作，形成优质产业链，充分释放数据要素价值。</p><p>&nbsp;</p><p></p><h3>以数据为核心，构建云体系中的技术服务能力</h3><p></p><p>&nbsp;</p><p>战略目标的实现需要落实到具体的产业、技术和应用上，浪潮云首席技术官孙思清介绍了浪潮数据云在以数据为核心，构建整个云体系中的技术服务能力方面的工作。</p><p>&nbsp;</p><p>孙思清表示，在没有云计算之前，最早IT是以应用为核心的IT架构，那时基本上基础设施、数据和应用是耦合在一块的，这是云计算前期的时代。进入到第二个阶段后，进入到以算力基础设施为核心。而进入数据元年之后，云计算围绕着数据来打造整个云计算的架构，提供数据的从数采、数算和数用，全生命周期的支撑能力，云是围绕数来转，以数为核心来构建整个云体系。</p><p>围绕六个方面构建核心技术能力</p><p>构建整个数据云的过程中，包括6个方面的能力，涵盖了从数据采集，数据存储、数据计算，数据治理，数据流通、数据使用等方面的全栈能力。</p><p>&nbsp;</p><p>从数采层面看，首先是全域全量的数据采集，原来解决数据场景问题是单点解决的，大模型的出现对数据提出了更高的要求，各个行业数据既然是战略资产，全域全量拥有这些数据是未来发展核心竞争力。在数采层面，要解决全域全量的数据采集，包括采集完后，如何对不同类型、不同来源的数据进行治理的问题 。</p><p>&nbsp;</p><p>在数据计算层面，如何能够调度闲散的算力，提供数据高效的计算，这在技术上的关键点。最关键的是所有这些数据从数采到数算，为了数据使用，如何去通过数据驱动来进行业务的创新，也是整个构建数据云的关键点。</p><p>&nbsp;</p><p>围绕这六个方面，浪潮云提供了多项技术能力。在全域全量数据的采集，尤其对IoT层面的数据采集边端，浪潮实现了数据安全传输，接触到物联感知平台的汇聚，从边缘到数据的汇聚，汇聚了图像、文本语音等多模态的数据。</p><p>&nbsp;</p><p>同时数据存储的要求也提高了，浪潮在分布式混合的数据存储层面进行了相关研发和技术上的突破，推出了分布式数据库，能实现多模数据存储，底层无论是什么形态的数据，都可以统一数据访问，统一数据存储，整个存储空间比传统数据存储节省90%以上，从存储成本上，大约占用三分之一左右，响应比传统模式快了接近30%。</p><p>&nbsp;</p><p>全域全量海量数据采集完，如何保证这些数据能用可用这是关键，尤其在数据多元的情况下。浪潮数据云提供了数据治理工厂，通过多年在行业中的积累，积累治理规则有5000多项，包括数据质量检测等。所有的数据多元异构的数据进来后，能够快速把它变成标准化的数据，从数据的标准，元数据、组数据，到数据质量的检测，最终把数据资源变成数据的资产。通过数据治理工厂，整个智能化流水线式的数据处理过程，大大的节省工作量，提高工作效率。</p><p>&nbsp;</p><p>另一个问题是，如果把这些数据变成模型，把算法变成数据产品，很重要的是需要算力。算力面临一个矛盾，一方面随着数据快速增长，算力不足。但同时又在很多地方散落了很多闲置算力，如何把这些算力整合起来提供算力是一个问题。对此，浪潮云在全国布局了多个算力中心，总共有7个核心节点，全国有113个二级节点，来提供算力服务。</p><p>&nbsp;</p><p>有了底层的算力支撑，对数据的处理，数据的计算，数据计算模式并不一样，有最简单的机器学习，最复杂的大模型训练，基于安全的多方计算，包括高性能计算，实时计算，流式计算等，计算模式完全不一样。基于云提供整个数据一站式的数据的处理能力，传统的大数据和云，和现在基础设施算力是两个隔离的状态。浪潮提供数据处理平台，底层存储融合存储能力，用云原生算力调度，在上面跑各种算力不同的模式数据计算。底层从存储来看，湖仓一体，从存储和计算来看，计算和存储分离。另外计算流批一体，在计算模式上深度融合。从云和数完全融合之后，资源利用率有了比较大的提升，同时对数据的访问I/O效率也得到很大提升。</p><p>&nbsp;</p><p>最终数据要用起来。如何把这些数据转换成数据产品，数据产品有很多，有原始的数据资源，有数据资产，有训练完的模型算法。实际上从现在来看，终极走到大模型超级的智能体，这都是从整个数据使用呈现出来的方式。浪潮有大量的数据，从数据产品层面，有接近350多个数据产品，从多个行业中，梳理了100多个数据所，把数据分级分类。目前浪潮整个模型算法，现在已经有接近200多个了，在这些行业已经有比较强的积累，可以在一些行业落地时直接使用数据的模型算法和产品。</p><p>&nbsp;</p><p></p><h3>数据云应用实践</h3><p></p><p>&nbsp;</p><p>深入各行各业，数据云的更多场景化创新与价值创造，正在从智慧政务、城市管理、产业智能等各个领域涌现。浪潮云提供了部分应用案例：</p><p>&nbsp;</p><p>在山东，浪潮数据云助力构建山东省一体化大数据中心，纵向打穿省级、市级、区县、街镇四级节点，横向实现各部门数据互联互通，自项目运行至今，已汇聚1056亿条数据，共享24万余项数据资源，提供390亿次共享服务。</p><p>&nbsp;</p><p>在上海虹口，围绕一网统管业务、数字赋能底座、数字孪生平台、综合应用场景四大核心业务，浪潮数据云与城市运行管理中心合力打造“3+2+1”的现代化城市治理体系，通过数据赋能城市治理，助力城市运行。</p><p>&nbsp;</p><p>此外，首自信公司联合浪潮数据云构建首钢集团智能制造大数据平台，实现数据采集汇聚、数据计算、数据应用和数据共享，同时打造“数据驱动”的智慧供应链、智能工厂、安全环保、数智服务等多领域解决方案及产品，具备钢铁全流程的咨询及解决方案、标准产品及实施交付、统一技术平台、综合人才培养四大能力。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p>",
    "publish_time": "2023-04-03 16:49:56",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "对话OpenCloudOS社区：如何促进操作系统开源生态繁荣？",
    "url": "https://www.infoq.cn/article/vHw7ObgwS1CzvHKgSYbl",
    "summary": "<p>3 月 31 日，国产<a href=\"https://www.infoq.cn/article/4lDxHRoqXbSw6zl29AEo\">操作系统</a>\"开源社区 OpenCloudOS 正式发布首个全自研社区<a href=\"https://www.infoq.cn/news/Epaw0GXBomUsfvzJK9iE\"> 9.0 版本</a>\"。OpenCloudOS 以打造从 L1 到 L3 全覆盖的操作系统发行版为特色，致力于研发自主可控的下一代云原生操作系统，并以社区为依托，建设操作系统开源生态。</p><p>&nbsp;</p><p>发布会结束后，<a href=\"https://www.infoq.cn/article/h4g17zGGfVYHzpvrj2gD\">OpenCloudOS 社区</a>\" TOC 成员、腾讯操作系统负责人王佳，OpenCloudOS社区副秘书长、腾讯开源专家耿航，红旗 OpenCloudOS 产品线研发经理杨科，中兴新支点操作系统产品部部长莫庆良，九州云 CTO 龚永生，OpenCloudOS 社区副理事长、Intel 开源技术中心总监杨继国接受了 InfoQ 在内的少数几家媒体的采访。以下为采访实录，经编辑。</p><p>&nbsp;</p><p>问：CentOS 停服之后，从 CentOS 向 OpenCloudOS 迁移的过程中有哪些典型的问题？最新发布的 OpenCloudOS 9.0 版本在支持平滑迁移方面具备哪些特性或能力？</p><p>&nbsp;</p><p>王佳：迁移可能是大家普遍面临的问题，其实我们很早就在社区里做过一些计划，其中一个重点就是关于兼容性评估方面的工作，我们社区实际上已经正在做了。我们希望做到的效果就是，在一个业务场景里，不管他是从别的系统迁移到 OpenCloudOS 9.0，或者从 OpenCloudOS 8 系列迁移到 9 系列，我们通过相关工具做一个评估，在那个业务系统上去跑一下，生成一个可迁移的一个报告。这个报告会反映是否存在兼容性的问题，如果存在，需要判断是哪里不兼容，比如，是某个软件包，还是涉及到一些 API 层面的事情等等。我们就会跟用户一起来评估迁移的成本、迁移代价等。</p><p>&nbsp;</p><p>另一方面说，如果我使用的是一个很新的版本，迁移跨度很长，这种前后兼容的版本其实是比较难实现的。我们做 OpenCloudOS 兼容其实也是一个很小的范围，当我们的新特性进去以后，是很难长期去做一个兼容的，但是我们会尽量减少一些用户的迁移门槛，提供迁移服务。</p><p>&nbsp;</p><p>当然如果考虑实际应用来讲，如果是短期的或者很紧急的场景，我们可能推荐一些比较接近的版本。如果用户的环境比较老，我们建议他可能选与它的版本比较接近的一个对应的 OpenCloudOS 版本去使用，这样，它的成本就会小很多。</p><p>&nbsp;</p><p>问：目前大家对于操作系统国产化讨论得比较多，企业在业务场景中进行操作系统迁移的时候，通常主要考虑哪些关键点？</p><p>&nbsp;</p><p>王佳：业务场景是非常复杂的，作为一个底层平台，我们把可靠性是放在第一位的。比如，出现问题需要在多少时间内响应，在多少时间内解决问题，提供任务定价。其实我们支持团队有的时候是 7*24 小时的，因为我们现在业务很多都在线服务的模块，所以我们会把可靠性放在第一位。</p><p>&nbsp;</p><p>莫庆良：我们新支点操作系统长期与行业一线打交道，关于我们整个国产化替代事情，现在热度的确很高。其实各行业一开始是搞不清楚国产化替代这件事情，因为国产操作系统一直没有真正在各行业里大规模的应用和备受关注。虽然新支点操作系统从 2010 年已经大规模的商用了，但是大家看到的都是前端应用的东西，而看不到后端的基础软件，所以以前大家对此关注度不够，但现在国产化的事情已变得非常的紧迫。</p><p>&nbsp;</p><p>关于企业客户考虑的关键点，我想主要讲行业客户，因为行业客户才是真正了解操作系统需求的人。他们最关注的第一点是操作系统的根是在哪里？比如，这个操作系统是基于哪个开源社区。所以，未来的开源社区话语权会很高，我认为紧跟各个开源社区一起是很重要的方向，而且我们会积极参与开源社区并努力在社区做贡献，这是一个很重要的事情。现在有一些开源社区的操作系统版本已经被行业认可，我觉得这是一个非常好的现象。第一是可以免费使用，第二就是还能获得持续的支持，相信未来将会有更多的行业参与进来。</p><p>&nbsp;</p><p>第二个关键点，行业客户会很关注厂家的实力，服务提供商到底有没有能力去把事情做好。例如研发人数少的小公司，或者说是在操作系统方面没有一些深入研发参与，没有话语权的公司，行业客户会认为当出问题的时候，厂家是搞不定的，客户的业务是没办法得到保障的。所以未来得依靠大的开源社区，或依靠一些大公司提供操作系统版本和相关服务。</p><p>&nbsp;</p><p>第三个关键点就是厂家的服务能力，行业客户的服务需求多样性，比如，远程在线服务或者现场服务。有些客户的业务是不能联网的，需要有人值守，而且业务覆盖的点又非常大，甚至遍布 30 个省份，服务能力不足的公司就没办法满足客户的需求。所以，未来行业客户对这些服务能力的要求会比较高。</p><p>&nbsp;</p><p>另外，行业客户也很关心安全性。虽然现在很多操作系统要与安全软件厂商有合作，但如果出现安全问题的时候，厂家没办法快速修复，或者厂家一开始就没考虑到该安全问题，这样是满足不了行业客户要求的。</p><p>&nbsp;</p><p>问：目前除了 OpenCloudOS，还有多个操作系统社区，和其他社区相比，OpenCloudOS 社区的主打特色是什么？怎样去促进整个社区开源生态的繁荣？</p><p>&nbsp;</p><p>王佳：我发表一下个人观点。大家做社区的初心或者说动机是不太一样的，我们看到不同的社区有多样化的组成，有商业公司、机构、高校，也有其他开源社区，我认为首先大家肯定都是为了在中国的操作系统领域凝心聚力去做事情。OpenCloudOS 的出发点和其他社区不同，其实从我们今天关于 L1 到 L3 的介绍中也可以看出来，我们的重心是在 L3 上面的。</p><p>&nbsp;</p><p>我们当然欢迎更多的伙伴们一起参与到对上游版本的贡献里面，但是这并不是我们强调的，我们更强调的是用户价值，社区里面输出的东西有更多的人来用，社区版本的开发有更多人来参与。在 OpenCloudOS 社区，我们希望更多是去解决用户对自主可控系统的需求，能不能直接用的问题。</p><p>&nbsp;</p><p>OpenCloudOS 9.0 的特色就是创新先进、高效经济、开放独立，这就是我们的特色。</p><p>&nbsp;</p><p>龚永生：其实兼容性对我们这样的在操作系统上面部署和开发业务应用的一些厂商来说，是很重要的。</p><p>&nbsp;</p><p>我问我的同事，我们如果要把软件迁移到 OpenCloudOS 上面，工作量大吗？他们说好像没问题，工作量很小就已经切换过来了。但是运行的稳定性等等，需要我们厂商和 OpenCloudOS 团队一起观察一段时间。我们为什么倾向于某个操作系统，我们为什么敢用？因为这是我们自己的一个社区，或者是我们找到腾讯这样的合作伙伴。我们跟腾讯其实有很深的渊源，他们的人还有我们的人经常在一块，这是一个社区生态必不可少的条件。如果说到其他的一个社区去，我一个人都不认识，找不到人解决不了问题，这是比较麻烦事。一个生态的建设，肯定是朋友圈的建设。所以他认识我我认识他，我就进来了，我信他，这就是生态的作用。</p><p>&nbsp;</p><p>杨科：我的理解是合作共赢，像我们公司加入 OpenCloudOS 社区，除了我们得到 OpenCloudOS 社区的一些技术创新支持外，我们也会向社区回馈一些东西，最终的目的都是为了更好的服务客户，这是我们的终极使命。我们加入 OpenCloudOS 社区希望与社区协同发展，达到合作共赢的目的，一起壮大国产化开源事业。</p><p>&nbsp;</p><p>耿航：在 OpenCloudOS 社区，腾讯既是最大的贡献者，也是最大的用户。开源软件需要这样一个很大的实验场。</p><p>&nbsp;</p><p>当前，国内外的操作系统百花齐放，包括服务器操作系统、物联网操作系统等等，用梅院士的说法就是，泛在操作系统生态在逐步形成。腾讯也跟梅院士还有一些实验室，推进泛在操作系统方面的一些研究，打造整个泛在操作系统的生态。此外，OpenCloudOS 社区有很多的 GPU 厂商，这些 GPU 厂商也都在参与到我们社区里，并且帮助社区完善 GPU 方面的一些特色。</p><p>&nbsp;</p><p>问：OpenCloudOS 社区有非常多的合作伙伴，但目前这些合作伙伴主要集中在国内，OpenCloudOS 社区对于国际化是否有规划？</p><p>&nbsp;</p><p>王佳：其实对于国际化，我们考虑的还挺多的。无论是谁来做操作系统版本，大家都是在 Linux 生态，这是一个开源的生态。做开源，其实有个很重要的问题，就是开源话语权。我刚才讲我们是一般定义层级是从 L1 开始，其实再往上还有 L0 级，L0 是软件原生版本/社区，属于原创，例如，Linux 内核社区就属于 L0 社区。</p><p>&nbsp;</p><p>国内有很多社区是从 L1 开始的，L1 级别对整个操作系统发行版来说相当于最上游，再往上就已经没有发行版了。但是发行版本身是由很多软件组成的，如果说论根来讲，我个人理解根是在更上层。如果要去和国外操作系统掰手腕的话，我觉得我们可能要争的是在 L0 层。</p><p>&nbsp;</p><p>我前面也讲到 OpenCloudOS 社区为什么重心放在 L3 层，因为我们发现其实是一个空白的地方，就我个人想法来讲，我不认为我们国内的操作系统社区之间是一种竞争的关系，大家定位不同，更多是一种互补。</p><p>&nbsp;</p><p>杨继国：国际化其实是每一个做软件的厂商都需要面对的问题。虽然 OpenCloudOS 社区是一个比较年轻的社区，但我认为它有一些自己的优势，第一个就是我们的用户基础，因为国外的社区基本上很多是爱好者，中国社区有非常强的用户基础，比如像我们的行业用户，我们的商业用户，从使用的行业来说其实超过了国际的一些社区。中国本身 IT 的发展是非常快，我们也有这么一个非常好的基础。</p><p>&nbsp;</p><p>另外一个我觉得很重要的就是开发者的基础，中国的开发者基数这些年成长非常快。所以如果我们能够把用户和开发者结合起来，那么在中国做开源，实际上就会形成一股非常强大的力量，这本身就能够在国际社区里面取得一个非常重要的话语权，我认为这是一个逐渐积累的过程。</p><p>&nbsp;</p><p>问：如何理解云原生操作系统？这是我们的机会吗？</p><p>&nbsp;</p><p>王佳：如果从云原生角度来说，OpenCloudOS 应该是最正规、最正式的一个云原生系统的名字，里面就带了 Cloud 云，我想谈一下这背后的故事。</p><p>&nbsp;</p><p>我个人认为，云原生操作系统是一个比较有争议的定义。从狭义上来讲，什么叫云原生？云原生是 Cloud Native，先有云，后在云上产生的系统，那才叫云原生系统，这是很狭义的定义。事实上，我们到今天也没有看到真正有一个操作系统是在云上长出来的。</p><p>&nbsp;</p><p>可能有的团队定义，比如像那种很轻量的，或那种极致的小运行环境，可能这算是一种。它只能去管理的小颗粒的资源，这种系统叫云原生的系统。其实本质来讲，它可能还算是一个 Linux 的延伸，或者我们知道业界有一些项目，他自己做一些这样的事情，可能具备类似操作系统的能力，但它不是一个传统意义上的操作系统，这就是比较狭义上的定义。</p><p>&nbsp;</p><p>还有一种说法，可能我们从操作系统的能力来讲，它的定义是个云操作系统，这个操作系统是比云兴起要早，但是它有很强的云上服务的能力，有很多相应的组件在里面，有人觉得可以把它叫云原生操作系统，这也是一种定义。</p><p>&nbsp;</p><p>OpenCloudOS 对云原生系统的理解是什么？我们还是回到现实，回到 Linux 体系。我们理解云原生系统，不仅仅会考虑我们在虚拟化、容器等相关的组件上的支持，因为这是首先必须要去做的事情，而且是要做好的事情。</p><p>&nbsp;</p><p>其次，我们考虑的更深的一点就是回到云本身的价值，回到云的栈里面，操作系统它应该承担一个什么样的角色？在整个云的生态价值里，操作系统产生的价值，我觉得应该不应该脱离云的价值，那云的价值在哪里？大家都知道，云最大价值就是在于弹性，在于资源的效率，在于可扩展性等，这是没有争议的。</p><p>&nbsp;</p><p>操作系统怎么去兑现这些价值？如果说操作系统跟这些价值是关联的，我们就可以认为这是一个云原生的操作系统，这就是我们为什么非常强调要去讲高效、讲经济、讲绿色。举例来说，绿色就属于能源管理，其实现在机房特别是云机房耗电量是相当恐怖的，而且规模一直在膨胀。我们把这些资源效率、能效、相关特性的研发当做很重点的事情，原因就在于我们认为云上需要操作系统的这些核心能力，操作系统在资源管理者角色上应该发挥它应有的力量。</p><p>&nbsp;</p><p>如果不能给云本身的价值去添彩，去增加云本身的价值，我们觉得云原生就只是形式上的东西，表面上的东西，所以我们把资源效率、能效、降低单位资源成本这些作为我们 OpenCloudOS 的一个特色，长期去打造，这也是我们采用 OpenCloudOS 这个名字的原因。</p><p>&nbsp;</p><p>&nbsp;</p>",
    "publish_time": "2023-04-03 17:52:08",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "企业实时数据服务平台建设最佳实践",
    "url": "https://www.infoq.cn/article/P1qM3XuMBrNLDSdFx12d",
    "summary": "<p><img alt=\"\" src=\"https://static001.infoq.cn/resource/image/f4/b6/f473abf4af069121f480334c3be463b6.jpg\" /><br />\n在过去的30年，企业投入了大量的资金和人力在信息化系统的建设上。这些信息化系统往往是有应用程序和其对应的数据库系统组成一体，互相之间并不联通，渐渐就形成一个个的企业内数据孤岛。而今日的企业，面临激烈的同质化竞争，都在拥抱数字化转型的战略举措，通过数据为企业赋能，产生新的价值，提高用户体验和改善客户留存等。通过数据，企业可以洞察在销售，市场，渠道，运营和生产中的真实情况。数据也可以为数据科学家和机器学习，人工智能提供宝贵的输入，为企业创造更多更大的价值提供可能。</p>\n<p>但是，数据孤岛的问题正在成为这些企业数字化转型的一个主要的阻碍。例如，国内某航空公司仅乘客相关的系统就有80多套。客户的信息散落在平时互不联通的业务系统内，无论是哪个渠道，都无法的获得某个客户完整的个人信息、行程信息或交互信息。这导致了企业无法提供最好的客服体验，无法做到精准推送等业务场景，直接影响客户留存和销售增值等场景。</p>\n<p>除此之外，企业对数据的需求日益增多，传统的数据的交付已经是大多数企业在数据变现方面的最大瓶颈。再加上今日日益复杂的云上云下的生态环境，有效，快速，高效且实时的数据能力，将会是企业竞争力中最重要的因素之一。</p>\n<p>当企业需要构建数据驱动的新型业务的时候并且需要获取到已有业务系统的数据时候, 传统的数据解决方案包括：</p>\n<ol>\n<li>直接在原有数据库系统上使用</li>\n<li>从源库里使用工具将数据导出，再导入到新的库里</li>\n<li>为新业务的数据需求，使用ETL工具或者编写程序进行数据抽取及同步</li>\n<li>如果对数据的时效性要求比较高，通常会使用CDC + Kafka + Java 代码方式来搭建实时管道</li>\n</ol>\n<p>第一种和第二种模式的最大问题有两点：</p>\n<ol>\n<li>是对源库的压力增大，影响已有业务的使用；</li>\n<li>源库的数据结构通常难以修改（缺乏文档、中断已有业务可能性）。因为如此，所以很少会采用第一种方案；</li>\n<li>开发成本比较高，难以协调。</li>\n</ol>\n<p>第三种方案，就是在每一个新的业务需要的时候, 就去从各个源系统进行一次性或者定期的抽取，这种方式的不足点有：</p>\n<ol>\n<li>复用不足，每次新的业务都需要进行ETL开发；</li>\n<li>对有实时数据需求的场景支持不足；</li>\n<li>ETL 通常使用脚本或者零星的工具完成，无统一管理，容易出错。</li>\n</ol>\n<p>第四种基于Kafka的方案，是针对实时数据场景较为常见的解决方案，其有以下特点及不足点：</p>\n<ol>\n<li>通常需要采购一个额外的CDC工具或者侵入式修改原来的业务代码来推送实时数据到Kafka；</li>\n<li>目标端依然需要使用Java 代码来拉取数据；</li>\n<li>整体的开发和维护成本较高。</li>\n</ol>\n<p>随着流处理数据技术的成熟, 企业对数据快速交付, 实时交付, 灵活交付的需求越来越明显传统的应用及架构无法满足企业数据需求, 但是由于这些应用仍然在支撑着企业的核心运营业务, 我们无法在短时间内对它们进行革新换代一个新的思路就是使用数据实时同步+实时数据处理+实时数据发布的新一代数据平台, 在保留原有系统基础上, 构建一个高度一致的数据镜像 , 并采用主数据管理技术, 形成企业的完整、准确、可信的统一数据模型，结合无代码发布及实时推送方式，将数据发布到下游业务系统。</p>",
    "publish_time": "2023-04-03 19:27:47",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]