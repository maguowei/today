[
  {
    "title": "避免成为“象牙塔”架构师：架构师和组织之间的关系",
    "url": "https://www.infoq.cn/article/T4PEt15NU2JUk1VWhTMv",
    "summary": "<p>在最近的访谈节目中，参与者讨论了<a href=\"https://youtu.be/2ezIiYHLXhc\">软件架构师与组织之间的关系</a>\"。他们详细描述了一个成功的架构师是如何影响他人的，他们可以深入细节，置身其中，也可以纵览全局，并在两种状态之间来回切换。</p><p>&nbsp;</p><p>微软公司副总裁<a href=\"https://www.linkedin.com/in/ulrichhomann/\">Uli Homann</a>\"说：</p><p>&nbsp;</p><p></p><blockquote>有时候，架构师被认为是象牙塔架构师，因为他们没有真正去参与一线的开发。他们不会明白压力来自哪里，现实是怎样的，只会告诉别人使用某种技术，却没有详细了解这意味着什么。&nbsp;我认为，高级架构师的目标是驱动努力的方向。当你身处战壕，你看见的是树，而不是森林。所以你需要在理解细节和纵观全局之间取得平衡，你需要知道我们仍然在正确的道路上还是已经在其他人都向右时却向左走了？&nbsp;避免陷入这种复杂的局面——人们不喜欢你或认为你只是在说而不是在做——的唯一方法就是“做”。你必须参与讨论，还得能够抽身回来。你看到了树的细节，然后还能确保树仍然位于森林之中，并根据你在战壕中所学到的知识更新企业架构策略。</blockquote><p></p><p>&nbsp;</p><p>Homann解释说，当架构师说了一些东西，这些东西实际上是有意义的，但在现实中变得不再有意义，这个时候就出现了脱节。如果反馈循环没有发生，架构就不会根据现实的反馈进行更新，从而偏离现实。“给出方向和策略是可以的，但之后要深入团队，让他们接受这些决定，并从谈话中了解你想要构建的东西是否真的有效。”</p><p>&nbsp;</p><p>微软首席架构师<a href=\"https://twitter.com/mougue\">Eric Charran</a>\"解释了为什么他认为软件架构师有时候应该是公职人员和有时候应该是社区组织者。作为一名公职人员，架构师的目标是帮助团队实现目标，包括亲自参与其中。“我能帮上什么忙？”是一个关键问题，“这里有一些有用的工具和技术”也是一个关键问题。作为社区组织者，架构师应该将他们所学到的知识传播到组织的其他部分，并适当地给团队一些赞扬。他说：“作为一名架构师，当团队开始站在我的肩膀上做事情时，我就成功了。”</p><p>&nbsp;</p><p>当主持人<a href=\"https://twitter.com/otterbook\">David Blank-Edelman</a>\"（微软资深云布道者）问到如何让人们听你话的时候，Charran回答说，人们想做好工作，如果他们看到你能帮助他们，他们就会听你的。他还说，人们不会根据事实做出决定，他们会做出情绪化的决定，并寻找事实来支持他们。“你必须愿意花时间帮助他们进入一种舒适的状态，让他们能够倾听你的观点。如果他们不愿意听你的观点，那么即使你可能是100%正确的，也只打赢了一半的仗。”</p><p>&nbsp;</p><p>Charran指出，如果架构师反复向同样的人解释同样的事情，他们应该只使用职位的权威，并成为“友好的投球者”。Homann补充说，架构师应该始终努力用外部证据来支持他们的建议，并指出，如果架构师自己无法打动人们，可以尝试通过其他人来打动他们。</p><p>&nbsp;</p><p>原文原文：</p><p><a href=\"https://www.infoq.com/news/2023/01/ivory-tower-architects/\">https://www.infoq.com/news/2023/01/ivory-tower-architects/</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/video/f8dUjceJYXNvdoEsISBD\">十年架构师锻造之路｜InfoQ 大会早班车第 10 期</a>\"</p><p><a href=\"https://www.infoq.cn/article/x5I9egrl31GuWjuBE9B5\">十四年架构师揭秘：要做架构师先要在鸟群中做好鸟</a>\"</p>",
    "publish_time": "2023-04-03 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "“诱骗”ChatGPT生成Win95系统密钥，1/3概率可激活；微软Teams落地国内；京东拟分拆旗下两公司上市｜AI一周资讯",
    "url": "https://www.infoq.cn/article/XVRINNYgprSOwajdgNii",
    "summary": "<p></p><blockquote>滴滴云3月31日起不再对外提供公有云服务；汽车雷达在无人陵园显示全是人，理想回应；腾讯副总裁郄小虎离职；京东拟分拆旗下两公司上市，股价暴涨......</blockquote><p></p><p></p><h2>资讯</h2><p></p><p></p><h4>滴滴云3月31日起不再对外提供公有云服务</h4><p></p><p></p><p>滴滴云宣布，由于产品线调整，将于2023年3月31日0:00起不再对外提供公有云服务。</p><p></p><p>滴滴云表示，如账户中仍有资源或余额，请在2023年6月30日24:00前及时进行资源备份迁移和提交退款申请。</p><p></p><p>据了解，滴滴云是滴滴出行的<a href=\"https://www.infoq.cn/article/2OTLSfjvdDCTy5bWCKvh\">云计算</a>\"服务，致力于为开发者提供简单快捷、高效稳定、高性价比、安全可靠的IT基础设施云服务。</p><p></p><h4>微软 Teams 国内版由世纪互联运营</h4><p></p><p>4月1日，<a href=\"https://www.infoq.cn/article/9wzrGiMTl8XClRgSfL9A\">微软</a>\"官方微信号宣布，旗下的办公协作应用Teams正式落地国内市场。</p><p></p><p>Microsoft Teams国内版将由世纪互联运营，Teams 会议室、Teams 应用商店、Teams 电话等更多功能将会陆续开启。</p><p></p><p>微软表示，为了更好满足跨国企业、大中型企业、创业团队等对于办公体验的不同需求，由世纪互联运营的Teams将作为Microsoft 365/Office 365组件，以不同服务订阅的形式提供给不同行业、不同需求的客户。</p><p></p><h4>主播“诱骗”ChatGPT 生成 Win95 系统密钥，1/3概率可激活</h4><p></p><p></p><p>4月1日，据IT之家报道，YouTube 频道 Enderman 在最新一期视频中，“诱骗”ChatGPT 生成可激活 Win95 系统的密钥。</p><p></p><p>该主播首先直接要求 <a href=\"https://archsummit.infoq.cn/2023/shanghai/track/1503\">ChatGPT</a>\" 生成 Win95 系统的密钥，理所当然地遭到了拒绝。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/57/577657f0fe2b2166d6db7167201ff1af.jpeg\" /></p><p></p><p>主播表示生成 Win95 密钥纯粹是出于好玩的目的，而且 Win95 的密钥生成机制也相当简单。该主播随后将 Win95 的密钥规则告诉 ChatGPT，然后通过调整一些语序和改进，生成了相应的密钥。</p><p></p><p>该主播随后在一台 Win95 虚拟机上随机测试了这些密钥，发现只有三分之一的密钥可以成功激活。</p><p></p><h4>汽车雷达在无人陵园显示全是人，理想回应</h4><p></p><p></p><p>日前，有车主在社交媒体发布视频称，自己的理想L9在空无一人的陵园道路上识别并标注出了数位行人。</p><p></p><p>3月29日，理想汽车方面就此回应称，“理想Max系列车型，使用激光雷达和视觉摄像头融合感知，受限于当前市场上传感器识别能力的局限性，车辆在某些场景下会出现显示异常，我们会在后续的OTA优化算法来加强识别能力。”</p><p></p><h4>腾讯副总裁郄小虎离职</h4><p></p><p></p><p>3月30日消息，据晚点LatePost报道，腾讯副总裁、PCG（平台与内容事业群）信息与服务线负责人郄小虎已离任。目前尚不清楚这位资深技术专家接下来的去向。郄小虎于 2020 年 9 月加入腾讯，任公司副总裁，负责 PCG 技术线相关职能。2021年12月接任 PCG 信息与服务线后，他管理着 QQ 浏览器、搜狗搜索、搜狗输入法等业务。郄小虎分管的业务将由腾讯副总裁、PCG 技术副总裁曾宇直接负责。曾宇于2002年加入腾讯，2012年升任公司副总裁，是腾讯资深的技术专家和管理者。</p><p></p><h4>任正非再次强调华为不造车，汽车设计不得使用华为/HUAWEI标志</h4><p></p><p></p><p>3月31日，据36氪报道，华为再次关于汽车业务发出决策公告。公告由华为创始人、董事长任正非署名发出，再次强调“<a href=\"https://www.infoq.cn/article/I0NcBrPUqHAgmaoKmeQF\">华为不造车”</a>\"，“有效期5年”。除此之外，任正非还对华为标志在汽车设计上的露出提出了严格要求。</p><p></p><p>“强调不能使用华为/HUAWEI出现在整车宣传和外观上。”消息人士告诉36氪，而且重点指出，“不能使用’华为问界’，’HUAWEI AITO’。”</p><p></p><h4>京东拟分拆旗下两公司上市，股价暴涨</h4><p></p><p></p><p>阿里日前宣布组织架构调整，未来子公司业务都有机会独立上市。</p><p></p><p>紧随其后，3月30日晚，<a href=\"https://www.infoq.cn/article/XZkteGNvhGPw4UGKMXZW\">京东</a>\"集团发布公告称，拟分拆旗下京东产发、京东工业于港交所主板独立上市。京东产发和京东工业随即向港交所递交A1申请文件，首次披露其业务构成及经营数据。受消息刺激，3月30日京东美股一度涨逾9%。</p><p></p><p>31日涨势延续到港股，早盘京东集团股价一度涨逾8%，最高报176.5港元，近9个交易日股价累计上涨超16%。</p><p></p><h4>美光计划裁员15%，实施高管减薪</h4><p></p><p></p><p>3月29日消息，据路透社报道，美光公司预计第3季度营收将暴跌60%，同时美光宣布，2023年裁员扩大到15%。数据显示，美光Q2营收同比下降约53%，至36.9亿美元，分析师预期为37.3亿美元；净亏损23亿美元，上年同期净利润22.6亿美元。由于芯片行业仍面临供过于求的困扰，美光预计营收将出现自2001年以来最严重的下滑。Mehrotra同时宣布，除了高阶主管减薪、全面停发2023会计年度奖金外，目前预期整体人力缩减比例将逼近15%。</p><p></p><h4>Databricks 开源 LLM，训练只需三个小时、30 美元</h4><p></p><p></p><p>据开源中国报道，大数据分析公司 Databricks Inc 近日也加入了生成式 AI 领域的竞争之中，发布了一个名为&nbsp;Dolly&nbsp;的开源大型语言模型，将模型命名为 Dolly 是为了向第一只克隆羊多莉致敬。</p><p></p><p>像 ChatGPT 和 Bard 这样的生成式 AI，它们使用的数据通常来自于在成千上万不同网站，使用的数据量十分惊人，而且想要使用这些数据训练 AI 还需要数以千计的强大 GPU 在背后提供支持。</p><p></p><p>Databricks 希望通过开源 <a href=\"https://www.databricks.com/blog/2023/03/24/hello-dolly-democratizing-magic-chatgpt-open-models.html\">Dolly </a>\"及其训练数据，让任何人都能开发出一个真正像人类的 AI，而无需投资数百万美元，也让这类 AI 不再是只有大型科技公司才能负担得起的东西，数以百万计的小公司也将能够从中受益。</p><p></p><p>除此之外，让各个小公司构建自己的模型，而不将数据通过 API 发送给专有模型背后的服务提供商，也可以保护小公司的敏感数据和专有的知识产权。此外，一些公司可能在模型质量、成本和期望行为方面有不同的权衡，这些公司也可以根据需求调整模型。</p><p></p><p>Dolly项目地址：<a href=\"https://www.databricks.com/blog/2023/03/24/hello-dolly-democratizing-magic-chatgpt-open-models.html\">https://www.databricks.com/blog/2023/03/24/hello-dolly-democratizing-magic-chatgpt-open-models.html</a>\"</p><p></p><p>Databricks 首席执行官 Ali Ghodsi 表示，Dolly 只需要非常少的数据和非常短的时间就能完成训练。</p><p></p><p></p><blockquote>只需 30 美元、一台服务器和三个小时，我们就能教 Dolly 开始进行人类级别的交互。</blockquote><p></p><p></p><h2>IT业界热评新闻</h2><p></p><p></p><h4>周鸿祎回应马斯克呼吁暂停GPT5研发：不发展才是最大的不安全</h4><p></p><p></p><p>3月30日，周鸿祎发长文回应马斯克呼吁暂停GPT-5的研发。周鸿祎表示，自己是做安全的，但我坚定地认为，不发展才是最大的不安全。“不管你愿不愿意，GPT 都将引领一场新的工业革命，意义超越互联网和 iPhone 的发明。它将带来生产力的大幅提升，进而提升国家竞争力。中国一定要迎头赶上。”</p><p></p><h4>消息称马斯克或最早4月来中国：特斯拉FSD有望落地</h4><p></p><p></p><p>3月31日消息，据财联社援引路透社报道，有消息人士称，<a href=\"https://www.infoq.cn/article/Sktl2hsqUBygTlDGRzOI\">特斯拉CEO埃隆·马斯克</a>\"或最早于4月份来中国。马斯克此行的目的暂时不得而知，不过近日倒是有不少汽车、科技博主明里暗里地表示，特斯拉的FSD驾驶系统或将在国内落地。</p><p></p><p>FSD，也就是Full Self-Drive的简称，中文名“完全自动驾驶能力”，目前在北美市场已经开放，且进行了长达一年多的测试，表现可圈可点，但在国内，由于相关政策的限制，特斯拉FSD一直未能落地。</p><p></p><p>在特斯拉官网上可以看到，FSD功能为选装，售价6.4万，包含基础版辅助驾驶和增强版自动辅助驾驶的全部功能，包括自动辅助导航驾驶、自动辅助变道、自动泊车、智能召唤，还拥有自动识别交通信号灯和停车标志并做出反应，在城市街道中自动辅助驾驶。</p><p></p><p>但需要注意的是，特斯拉同时还指出，目前可用的功能需要驾驶员主动进行监控，车辆尚未实现完全自动驾驶。上述功能的激活与使用将需要数十亿英里的行驶里程的论证，以达到远超人类驾驶员的可靠性；同时还有赖于行政审批（某些司法管辖区可能会需要更长的时间）。</p><p></p><p>不过以上均为猜测，具体情况有待进一步的确认，4月份<a href=\"https://www.infoq.cn/article/5LYIHLWuPVU8btDrfBut\">马斯克</a>\"来中国之后，一些疑问或将给出结果。</p><p></p>",
    "publish_time": "2023-04-03 09:44:52",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "三年回顾：JavaScript与TypeScript最新特性汇总",
    "url": "https://www.infoq.cn/article/SZZal8JbzaFq1O9YejCy",
    "summary": "<p></p><blockquote>全文 7739 字，建议收藏。本文涵盖了过去三年中发布的最新 JavaScript 和 TypeScript 特性，包括异步迭代器、nullish 合并、可选链、私有字段等等。对于每个特性，文章提供了简单的解释、示例代码以及使用场景，以便开发者能够更好地理解和应用这些新特性。同时，文章还介绍了如何在项目中使用这些特性，以及如何通过 polyfill 或者 Babel 等工具使旧的浏览器支持这些新特性。</blockquote><p></p><p></p><p>本文将带大家回顾过去三年（乃至更早）以来，JavaScript/ECMAScript 以及 TypeScript 经历的一系列功能变化。</p><p></p><p>当然，这里提到的很多功能也许跟大家的日常工作八竿子打不着。但关注功能的发展变化，应该能帮助您加深对这些语言的理解。</p><p></p><p>有很多 TypeScript 功能并没有被记录在内，因为它们总体上可以概括为“之前它的运作效果跟期望不同，但现在相同了”。所以如果大家之前对某些问题有所诟病，现在不妨重试一次。</p><p></p><p></p><h3>概述</h3><p></p><p></p><p>●&nbsp;&nbsp;JavaScript / ECMAScript (按时间排序)</p><p></p><p>●&nbsp;&nbsp;TypeScript (按时间排序)</p><p></p><p></p><h2>ECMAScript</h2><p></p><p></p><h3>更早（更早发布但仍然重要）</h3><p></p><p></p><p>●&nbsp;&nbsp;标记模板字面量：通过在模板字面量之前添加函数名，可以将函数传递至模板字面量和模板值的某些部分。这项功能有不少有趣的用途。</p><p></p><p><code lang=\"javascript\">// Let's say we want to write a way to log arbitrary strings containing a number, but format the number.\n// We can use tagged templates for that.\nfunction formatNumbers(strings: TemplateStringsArray, number: number): string {\n  return strings[0] + number.toFixed(2) + strings[1];\n}\nconsole.log(formatNumbers`This is the value: ${0}, it's important.`); // This is the value: 0.00, it's important.\n// Or if we wanted to \"translate\" (change to lowercase here) translation keys within strings.\nfunction translateKey(key: string): string {\n  return key.toLocaleLowerCase();\n}\nfunction translate(strings: TemplateStringsArray, ...expressions: string[]): string {\n  return strings.reduce((accumulator, currentValue, index) =&gt; accumulator + currentValue + translateKey(expressions[index] ?? ''), '');\n}\nconsole.log(translate`Hello, this is ${'NAME'} to say ${'MESSAGE'}.`); // Hello, this is name to say message.\n\n</code></p><p></p><p>●&nbsp;&nbsp;Symbols（之前被错误归类为 ES2022）：对象的唯一键：Symbol(“foo”) === Symbol(“foo”); // false。内部使用。</p><p></p><p><code lang=\"javascript\">const obj: { [index: string]: string } = {};\nconst symbolA = Symbol('a');\nconst symbolB = Symbol.for('b');\nconsole.log(symbolA.description); // \"a\"\nobj[symbolA] = 'a';\nobj[symbolB] = 'b';\nobj['c'] = 'c';\nobj.d = 'd';\nconsole.log(obj[symbolA]); // \"a\"\nconsole.log(obj[symbolB]); // \"b\"\n// The key cannot be accessed with any other symbols or without a symbol.\nconsole.log(obj[Symbol('a')]); // undefined\nconsole.log(obj['a']); // undefined\n// The keys are not enumerated when using for ... in.\nfor (const i in obj) {\n  console.log(i); // \"c\", \"d\"\n}\n</code></p><p></p><p></p><h3>ES2020</h3><p></p><p></p><p>●&nbsp;&nbsp;可选链：要访问一个可能未定义的对象的值（通过索引），可以通过在父对象名称后添加? 来使用可选链。可选链也可用于索引 ([…]) 或者函数调用。</p><p></p><p><code lang=\"typescript\">// PREVIOUSLY:\n// If we have an object variable (or any other structure) we don't know for certain is defined,\n// We can not easily access the property.\nconst object: { name: string } | undefined = Math.random() &gt; 0.5 ? undefined : { name: 'test' };\nconst value = object.name; // type error: 'object' is possibly 'undefined'.\n// We could first check if it is defined, but this hurts readability and gets complex for nested objects.\nconst objectOld: { name: string } | undefined = Math.random() &gt; 0.5 ? undefined : { name: 'test' };\nconst valueOld = objectOld ? objectOld.name : undefined;\n// NEW:\n// Instead we can use optional chaining.\nconst objectNew: { name: string } | undefined = Math.random() &gt; 0.5 ? undefined : { name: 'test' };\nconst valueNew = objectNew?.name;\n// This can also be used for indexing and functions.\nconst array: string[] | undefined = Math.random() &gt; 0.5 ? undefined : ['test'];\nconst item = array?.[0];\nconst func: (() =&gt; string) | undefined = Math.random() &gt; 0.5 ? undefined : () =&gt; 'test';\nconst result = func?.();\n</code></p><p></p><p>●&nbsp;&nbsp;import(): 动态导入，例如 import … from …，但在运行上且使用变量。</p><p></p><p><code lang=\"javascript\">let importModule;\nif (shouldImport) {\nimportModule = await import('./module.mjs');\n}\n</code></p><p></p><p>●&nbsp;&nbsp;String.matchAll: 获取正则表达式的多个匹配项，包括其捕获组，且不使用循环。</p><p></p><p><code lang=\"javascript\">const stringVar = 'testhello,testagain,';\n// PREVIOUSLY:\n// Only gets matches, but not their capture groups.\nconsole.log(stringVar.match(/test([\\w]+?),/g)); // [\"testhello,\", \"testagain,\"]\n// Only gets one match, including its capture groups.\nconst singleMatch = stringVar.match(/test([\\w]+?),/);\nif (singleMatch) {\n  console.log(singleMatch[0]); // \"testhello,\"\n  console.log(singleMatch[1]); // \"hello\"\n}\n// Gets the same result, but is very unintuitive (the exec method saves the last index).\n// Needs to be defined outside the loop (to save the state) and be global (/g),\n// otherwise this will produce an infinite loop.\nconst regex = /test([\\w]+?),/g;\nlet execMatch;\nwhile ((execMatch = regex.exec(stringVar)) !== null) {\n  console.log(execMatch[0]); // \"testhello,\", \"testagain,\"\n  console.log(execMatch[1]); // \"hello\", \"again\"\n}\n// NEW:\n// Regex needs to be global (/g), also doesn't make any sense otherwise.\nconst matchesIterator = stringVar.matchAll(/test([\\w]+?),/g);\n// Needs to be iterated or converted to an array (Array.from()), no direct indexing.\nfor (const match of matchesIterator) {\n  console.log(match[0]); // \"testhello,\", \"testagain,\"\n  console.log(match[1]); // \"hello\", \"again\"\n}\n</code></p><p></p><p>●&nbsp;&nbsp;Promise.allSettled(): 与 Promise.all() 类似，但需要等待所有 Promises 完成，且不会在第一次 reject/throw 时返回。它能让降低错误处理的难度。</p><p></p><p><code lang=\"javascript\">async function success1() {return 'a'}\nasync function success2() {return 'b'}\nasync function fail1() {throw 'fail 1'}\nasync function fail2() {throw 'fail 2'}\n// PREVIOUSLY:\nconsole.log(await Promise.all([success1(), success2()])); // [\"a\", \"b\"]\n// but:\ntry {\n  await Promise.all([success1(), success2(), fail1(), fail2()]);\n} catch (e) {\n  console.log(e); // \"fail 1\"\n}\n// Notice: We only catch one error and can't access the success values.\n// PREVIOUS FIX (really suboptimal):\nconsole.log(await Promise.all([ // [\"a\", \"b\", undefined, undefined]\n  success1().catch(e =&gt; { console.log(e); }),\n  success2().catch(e =&gt; { console.log(e); }),\n  fail1().catch(e =&gt; { console.log(e); }), // \"fail 1\"\n  fail2().catch(e =&gt; { console.log(e); })])); // \"fail 2\"\n// NEW:\nconst results = await Promise.allSettled([success1(), success2(), fail1(), fail2()]);\nconst sucessfulResults = results\n  .filter(result =&gt; result.status === 'fulfilled')\n  .map(result =&gt; (result as PromiseFulfilledResult).value);\nconsole.log(sucessfulResults); // [\"a\", \"b\"]\nresults.filter(result =&gt; result.status === 'rejected').forEach(error =&gt; {\n  console.log((error as PromiseRejectedResult).reason); // \"fail 1\", \"fail 2\"\n});\n// OR:\nfor (const result of results) {\n  if (result.status === 'fulfilled') {\n    console.log(result.value); // \"a\", \"b\"\n  } else if (result.status === 'rejected') {\n    console.log(result.reason); // \"fail 1\", \"fail 2\"\n  }\n}\n</code></p><p></p><p>●&nbsp;&nbsp;globalThis: 在全局上下文中访问变量，与环境无关（浏览器、NodeJS 等）。仍被视为较差实践，但在某些情况下是必要的。类似于浏览器上的 this。</p><p></p><p><code lang=\"javascript\">console.log(globalThis.Math); // Math Object\n</code></p><p></p><p>●import.meta: 在使用 ES-modules 时，获取当前模块的 URL import.meta.url。</p><p></p><p><code lang=\"javascript\">console.log(import.meta.url); // \"file://...\"\n</code></p><p></p><p>●&nbsp;&nbsp;export * as … from …: 轻松将默认值重新导出为子模块。</p><p></p><p><code lang=\"javascript\">export * as am from 'another-module'\nimport { am } from 'module'\n</code></p><p></p><p></p><h3>ES2021</h3><p></p><p></p><p>●&nbsp;&nbsp;String.replaceAll(): 替换掉某字符串内某一子字符串的所有实例，无需始终使用带有全局标志（/g）的正则表达式。</p><p></p><p><code lang=\"javascript\">const testString = 'hello/greetings everyone/everybody';\n// PREVIOUSLY:\n// Only replaces the first instance\nconsole.log(testString.replace('/', '|')); // 'hello|greetings everyone/everybody'\n// Instead a regex needed to be used, which is worse for performance and needs escaping.\n// Not the global flag (/g).\nconsole.log(testString.replace(/\\//g, '|')); // 'hello|greetings everyone|everybody'\n// NEW:\n// Using replaceAll this is much clearer and faster.\nconsole.log(testString.replaceAll('/', '|')); // 'hello|greetings everyone|everybody'\n</code></p><p></p><p>●&nbsp;&nbsp;Promise.any: 当只需要获取 promises 列表中的一个结果时，则返回第一个结果；仅在所有 promises 均被拒绝时才返回 AggregateError，而非立即拒绝的 Promise.race。</p><p></p><p><code lang=\"javascript\">async function success1() {return 'a'}\nasync function success2() {return 'b'}\nasync function fail1() {throw 'fail 1'}\nasync function fail2() {throw 'fail 2'}\n// PREVIOUSLY:\nconsole.log(await Promise.race([success1(), success2()])); // \"a\"\n// but:\ntry {\n  await Promise.race([fail1(), fail2(), success1(), success2()]);\n} catch (e) {\n  console.log(e); // \"fail 1\"\n}\n// Notice: We only catch one error and can't access the success value.\n// PREVIOUS FIX (really suboptimal):\nconsole.log(await Promise.race([ // \"a\"\n  fail1().catch(e =&gt; { console.log(e); }), // \"fail 1\"\n  fail2().catch(e =&gt; { console.log(e); }), // \"fail 2\"\n  success1().catch(e =&gt; { console.log(e); }),\n  success2().catch(e =&gt; { console.log(e); })]));\n// NEW:\nconsole.log(await Promise.any([fail1(), fail2(), success1(), success2()])); // \"a\"\n// And it only rejects when all promises reject and returns an AggregateError containing all the errors.\ntry {\n  await Promise.any([fail1(), fail2()]);\n} catch (e) {\n  console.log(e); // [AggregateError: All promises were rejected]\n  console.log(e.errors); // [\"fail 1\", \"fail 2\"]\n}\n</code></p><p></p><p>●&nbsp;&nbsp;Nullish coalescing assignment (??=): 仅在之前为 “nullish”（null 或 undefined）时才分配值。</p><p></p><p><code lang=\"javascript\">let x1 = undefined;\nlet x2 = 'a';\nconst getNewValue = () =&gt; 'b';\n// Assigns the new value to x1, because undefined is nullish.\nx1 ??= 'b';\nconsole.log(x1) // \"b\"\n// Does not assign a new value to x2, because a string is not nullish.\n// Also note: getNewValue() is never executed.\nx2 ??= getNewValue();\nconsole.log(x1) // \"a\"\n</code></p><p></p><p>●&nbsp;&nbsp;Logical and assignment (&amp;&amp;=): 仅在之前为“truhty”（true 或可以转换为 true 的值）时才分配值。</p><p></p><p><code lang=\"javascript\">let x1 = undefined;\nlet x2 = 'a';\nconst getNewValue = () =&gt; 'b';\n// Does not assign a new value to x1, because undefined is not truthy.\n// Also note: getNewValue() is never executed.\nx1 &amp;&amp;= getNewValue();\nconsole.log(x1) // undefined\n// Assigns a new value to x2, because a string is truthy.\nx2 &amp;&amp;= 'b';\nconsole.log(x1) // \"b\"\n</code></p><p></p><p>●&nbsp;&nbsp;Logical or assignment (||=): 仅在之前为“falsy”（false 或转换为 false）时才分配值。</p><p></p><p><code lang=\"javascript\">let x1 = undefined;\nlet x2 = 'a';\nconst getNewValue = () =&gt; 'b';\n// Assigns the new value to x1, because undefined is falsy.\nx1 ||= 'b';\nconsole.log(x1) // \"b\"\n// Does not assign a new value to x2, because a string is not falsy.\n// Also note: getNewValue() is never executed.\nx2 ||= getNewValue();\nconsole.log(x1) // \"a\"\n</code></p><p></p><p>●&nbsp;&nbsp;WeakRef: 保留对一个对象的“weak”引用，但不阻止对象被垃圾回收。</p><p></p><p><code lang=\"cs\">const ref = new WeakRef(element);\n// Get the value, if the object/element still exists and was not garbage-collected.\nconst value = ref.deref;\nconsole.log(value); // undefined\n// Looks like the object does not exist anymore.\n</code></p><p></p><p>●&nbsp;&nbsp;数字分隔符 (_): 使用 _ 分隔数字以提高可读性。不会对功能造成影响。</p><p></p><p><code lang=\"cs\">const int = 1_000_000_000;\nconst float = 1_000_000_000.999_999_999;\nconst max = 9_223_372_036_854_775_807n;\nconst binary = 0b1011_0101_0101;\nconst octal = 0o1234_5670;\nconst hex = 0xD0_E0_F0;\n</code></p><p></p><p></p><h3>ES2022</h3><p></p><p></p><p>●&nbsp;&nbsp;#private: 通过以 # 开头的命名，使类成员（属性和方法）私有，即只能通过类本身进行访问。其无法被删除或动态分配。任何不正确行为都会导致 JavaScript（注意，不是 TypeScript）语法错误。不推荐在 TypeScript 项目中这样做，而应用直接使用 private 关键字。</p><p></p><p><code lang=\"cs\">class ClassWithPrivateField {\n#privateField;\n#anotherPrivateField = 4;\nconstructor() {\nthis.#privateField = 42; // Valid\nthis.#privateField; // Syntax error\nthis.#undeclaredField = 444; // Syntax error\nconsole.log(this.#anotherPrivateField); // 4\n}\n}\nconst instance = new ClassWithPrivateField();\ninstance.#privateField === 42; // Syntax error\n</code></p><p></p><p>●&nbsp;&nbsp;静态类成员: 将任意类字段（属性和方法）标记为静态。</p><p></p><p><code lang=\"javascript\">class Logger {\nstatic id = 'Logger1';\nstatic type = 'GenericLogger';\nstatic log(message: string | Error) {\nconsole.log(message);\n}\n}\nclass ErrorLogger extends Logger {\nstatic type = 'ErrorLogger';\nstatic qualifiedType;\nstatic log(e: Error) {\nreturn super.log(e.toString());\n}\n}\nconsole.log(Logger.type); // \"GenericLogger\"\nLogger.log('Test'); // \"Test\"\n// The instantiation of static-only classes is useless and only done here for demonstration purposes.\nconst log = new Logger();\nErrorLogger.log(new Error('Test')); // Error: \"Test\" (not affected by instantiation of the parent)\nconsole.log(ErrorLogger.type); // \"ErrorLogger\"\nconsole.log(ErrorLogger.qualifiedType); // undefined\nconsole.log(ErrorLogger.id); // \"Logger1\"\n// This throws because log() is not an instance method but a static method.\nconsole.log(log.log()); // log.log is not a function\n</code></p><p></p><p>●&nbsp;&nbsp;类中的静态初始化块: 类初始化时运行的块，基本属于静态成员的“构造函数”。</p><p></p><p><code lang=\"javascript\">class Test {\nstatic staticProperty1 = 'Property 1';\nstatic staticProperty2;\nstatic {\nthis.staticProperty2 = 'Property 2';\n}\n}\nconsole.log(Test.staticProperty1); // \"Property 1\"\nconsole.log(Test.staticProperty2); // \"Property 2\"\n</code></p><p></p><p>●&nbsp;&nbsp;导入断言（非标准，在 V8 中实现）：以 import … from … assert { type: ‘json’ }的形式对导入类型做断言，可用于在不解析 JSON 的前提下将其导入。</p><p></p><p><code lang=\"typescript\">import json from './foo.json' assert { type: 'json' };\nconsole.log(json.answer); // 42\n</code></p><p></p><p>●&nbsp;&nbsp;RegExp 匹配索引：获取正则表达式匹配和捕获组的开始和结束索引。适用于 RegExp.exec(), String.match() 和 String.matchAll()。</p><p></p><p><code lang=\"javascript\">const matchObj = /(test+)(hello+)/d.exec('start-testesthello-stop');\n// PREVIOUSLY:\nconsole.log(matchObj?.index);\n// NEW:\nif (matchObj) {\n// Start and end index of entire match (before we only had the start).\nconsole.log(matchObj.indices[0]); // [9, 18]\n// Start and end indexes of capture groups.\nconsole.log(matchObj.indices[1]); // [9, 13]\nconsole.log(matchObj.indices[2]); // [13, 18]\n}\n</code></p><p></p><p>●&nbsp;&nbsp;负索引 (.at(-1)): 在索引数组或字符串时，可以使用 at 从末尾开始索引。相当于 arr[arr.length - 1)</p><p></p><p><code lang=\"javascript\">console.log([4, 5].at(-1)) // 5\n</code></p><p></p><p>●&nbsp;&nbsp;hasOwn: 推荐使用的新方法，用于查找对象具有哪些属性，用于替代 obj.hasOwnProperty()。在某些特殊情况下效果更好。</p><p></p><p><code lang=\"javascript\">const obj = { name: 'test' };\nconsole.log(Object.hasOwn(obj, 'name')); // true\nconsole.log(Object.hasOwn(obj, 'gender')); // false\n</code></p><p></p><p>●&nbsp;&nbsp;错误原因（Error cause）: 现在可以为错误指定可选原因，允许在重新抛出时指定原始错误。</p><p></p><p><code lang=\"javascript\">try {\ntry {\nconnectToDatabase();\n} catch (err) {\nthrow new Error('Connecting to database failed.', { cause: err });\n}\n} catch (err) {\nconsole.log(err.cause); // ReferenceError: connectToDatabase is not defined\n}\n</code></p><p></p><p></p><h3>之后（已可在 TypeScript 4.9 中使用）</h3><p></p><p></p><p>●&nbsp;&nbsp;Auto-Accessor: 自动将属性设为私有，并为其创建 get/set 访问器。</p><p></p><p><code lang=\"typescript\">class Person {\naccessor name: string;\nconstructor(name: string) {\nthis.name = name;\nconsole.log(this.name) // 'test'\n}\n}\nconst person = new Person('test');\n</code></p><p></p><p></p><h2>TypeScript</h2><p></p><p></p><h3>基础（进一步介绍上下文）</h3><p></p><p></p><p>●&nbsp;&nbsp;泛型: 将类型传递至其他类型，负责在对类型进行泛化后仍保证类型安全。应始终优先使用泛型，而非 any 或 unknown。</p><p></p><p><code lang=\"php\">// WITHOUT:\nfunction getFirstUnsafe(list: any[]): any {\nreturn list[0];\n}\nconst firstUnsafe = getFirstUnsafe(['test']); // typed as any\n// WITH:\nfunction getFirst(list: Type[]): Type {\nreturn list[0];\n}\nconst first = getFirst(['test']); // typed as string\n// In this case the parameter can even be dropped because it is inferred from the argument.\nconst firstInferred = getFirst(['test']); // typed as string\n// The types accepted as generics can also be limited using `extends`. The Type is also usually shortened to T.\nclass List {\nprivate list: T[] = [];\nget(key: number): T {\nreturn this.list[key];\n}\npush(value: T): void {\nthis.list.push(value);\n}\n}\nconst list = new List();\nlist.push(9); // Type error: Argument of type 'number' is not assignable to parameter of type 'string'.\nconst booleanList = new List(); // Type error: Type 'boolean' does not satisfy the constraint 'string | number'.\n</code></p><p></p><p></p><h3>更早（更早发布但仍然重要）</h3><p></p><p></p><p>●&nbsp;&nbsp;实用程序类型: TypeScript 中包含多种实用程序类型，这里解释其中最重要的几种。</p><p></p><p><code lang=\"typescript\">interface Test {\n  name: string;\n  age: number;\n}\n// The Partial utility type makes all properties optional.\ntype TestPartial = Partial; // typed as { name?: string | undefined; age?: number | undefined; }\n// The Required utility type does the opposite.\ntype TestRequired = Required; // typed as { name: string; age: number; }\n// The Readonly utility type makes all properties readonly.\ntype TestReadonly = Readonly; // typed as { readonly name: string; readonly age: string }\n// The Record utility type allows the simple definition of objects/maps/dictionaries. It is preferred to index signatures whenever possible.\nconst config: Record = { option: false, anotherOption: true };\n// The Pick utility type gets only the specified properties.\ntype TestLess = Pick; // typed as { name: string; }\ntype TestBoth = Pick; // typed as { name: string; age: string; }\n// The Omit utility type ignores the specified properties.type\ntype TestFewer = Omit; // typed as { age: string; }\ntype TestNone = Omit; // typed as {}\n// The Parameters utility type gets the parameters of a function type.\nfunction doSmth(value: string, anotherValue: number): string {\n  return 'test';\n}\ntype Params = Parameters; // typed as [value: string, anotherValue: number]\n// The ReturnType utility type gets the return type of a function type.\ntype Return = ReturnType; // typed as string\n// There are many more, some of which are introduced further down.\n</code></p><p></p><p>●&nbsp;&nbsp;条件类型: 根据某种类型是否匹配 / 扩展另一种类型，来对类型做有条件设置。可以按照 JavaScript 中条件（三元）运算符的方式理解。</p><p></p><p><code lang=\"typescript\">// Only extracts the array type if it is an array, otherwise returns the same type.\ntype Flatten = T extends any[] ? T[number] : T;\n// Extracts out the element type.\ntype Str = Flatten; // typed as string\n// Leaves the type alone.\ntype Num = Flatten; // typed as number\n</code></p><p></p><p>●&nbsp;&nbsp;使用条件类型进行推断: 并非所有泛型类型都需要由用户指定，有些也可以从代码中推断得出。要实现基于类型推断的条件逻辑，必须有 infer 关键字，它会以某种方式定义临时推断类型变量。</p><p></p><p><code lang=\"typescript\">// Starting with the previous example, this can be written more cleanly.\ntype FlattenOld = T extends any[] ? T[number] : T;\n// Instead of indexing the array, we can just infer the Item type from the array.\ntype Flatten = T extends (infer Item)[] ? Item : T;\n// If we wanted to write a type that gets the return type of a function and otherwise is undefined, we could also infer that.\ntype GetReturnType = Type extends (...args: any[]) =&gt; infer Return ? Return : undefined;\ntype Num = GetReturnType&lt;() =&gt; number&gt;; // typed as number\ntype Str = GetReturnType&lt;(x: string) =&gt; string&gt;; // typed as string\ntype Bools = GetReturnType&lt;(a: boolean, b: boolean) =&gt; void&gt;; // typed as undefined\n</code></p><p></p><p>●&nbsp;&nbsp;元组可选元素与其余元素: 使用 ? 声明元组中的可选元素，使用 … 声明元组中的其余元素。</p><p></p><p><code lang=\"typescript\">// If we don't yet know how long a tuple is going to be, but it's at least one, we can specify optional types using `?`.\nconst list: [number, number?, boolean?] = [];\nlist[0] // typed as number\nlist[1] // typed as number | undefined\nlist[2] // typed as boolean | undefined\nlist[3] // Type error: Tuple type '[number, (number | undefined)?, (boolean | undefined)?]' of length '3' has no element at index '3'.\n// We could also base the tuple on an existing type.\n// If we want to pad an array at the start, we could do that using the rest operator `...`.\nfunction padStart(arr: T, pad: string): [string, ...T] {\n  return [pad, ...arr];\n}\nconst padded = padStart([1, 2], 'test'); // typed as [string, number, number]\n</code></p><p></p><p>●&nbsp;&nbsp;抽象类和方法: 类和类中的各方法可以被声明为 abstract，以防止其被实例化。</p><p></p><p><code lang=\"java\">abstract class Animal {\n  abstract makeSound(): void;\n  move(): void {\n    console.log('roaming the earth...');\n  }\n}\n// Abstract methods need to be implemented when extended.\nclass Cat extends Animal {} // Compile error: Non-abstract class 'Cat' does not implement inherited abstract member 'makeSound' from class 'Animal'.\nclass Dog extends Animal {\n  makeSound() {\n    console.log('woof');\n  }\n}\n// Abstract classes cannot be instantiated (like Interfaces), and abstract methods cannot be called.\nnew Animal(); // Compile error: Cannot create an instance of an abstract class.\nconst dog = new Dog().makeSound(); // \"woof\"\n</code></p><p></p><p>●&nbsp;&nbsp;构造函数签名: 在类声明之外，定义构造函数的类型。在大多数情况下不应使用，建议用抽象类代替。</p><p></p><p><code lang=\"typescript\">interface MyInterface {\n  name: string;\n}\ninterface ConstructsMyInterface {\n  new(name: string): MyInterface;\n}\nclass Test implements MyInterface {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\nclass AnotherTest {\n  age: number;\n}\nfunction makeObj(n: ConstructsMyInterface) {\n    return new n('hello!');\n}\nconst obj = makeObj(Test); // typed as Test\nconst anotherObj = makeObj(AnotherTest); // Type error: Argument of type 'typeof AnotherTest' is not assignable to parameter of type 'ConstructsMyInterface'.\n</code></p><p></p><p>●&nbsp;&nbsp;ConstructorParameters Utility 类型: 属于 TypeScript 辅助函数，能够根据构造函数类型（但不是类）获取构造函数参数。</p><p></p><p><code lang=\"typescript\">// What if we wanted to get the constructor argument for our makeObj function.\ninterface MyInterface {\n  name: string;\n}\ninterface ConstructsMyInterface {\n  new(name: string): MyInterface;\n}\nclass Test implements MyInterface {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\nfunction makeObj(test: ConstructsMyInterface, ...args: ConstructorParameters) {\n  return new test(...args);\n}\nmakeObj(Test); // Type error: Expected 2 arguments, but got 1.\nconst obj = makeObj(Test, 'test'); // typed as Test\n</code></p><p></p><p></p><h3>TypeScript 4.0</h3><p></p><p></p><p>●&nbsp;&nbsp;可变元组类型: 元组中的其余元素现在是通用的，且允许使用多个其余元素。</p><p></p><p><code lang=\"typescript\">// What if we had a function that combines two tuples of undefined length and types? How can we define the return type?\n// PREVIOUSLY:\n// We could write some overloads.\ndeclare function concat(arr1: [], arr2: []): [];\ndeclare function concat<a>(arr1: [A], arr2: []): [A];\ndeclare function concat<a>(arr1: [A], arr2: [B]): [A, B];\ndeclare function concat<a>(arr1: [A], arr2: [B, C]): [A, B, C];\ndeclare function concat<a>(arr1: [A], arr2: [B, C, D]): [A, B, C, D];\ndeclare function concat<a>(arr1: [A, B], arr2: []): [A, B];\ndeclare function concat<a>(arr1: [A, B], arr2: [C]): [A, B, C];\ndeclare function concat<a>(arr1: [A, B], arr2: [C, D]): [A, B, C, D];\ndeclare function concat<a>(arr1: [A, B], arr2: [C, D, E]): [A, B, C, D, E];\ndeclare function concat<a>(arr1: [A, B, C], arr2: []): [A, B, C];\ndeclare function concat<a>(arr1: [A, B, C], arr2: [D]): [A, B, C, D];\ndeclare function concat<a>(arr1: [A, B, C], arr2: [D, E]): [A, B, C, D, E];\ndeclare function concat<a>(arr1: [A, B, C], arr2: [D, E, F]): [A, B, C, D, E, F];\n// Even just for three items each, this is really suboptimal.\n// Instead we could combine the types.\ndeclare function concatBetter(arr1: T[], arr2: U[]): (T | U)[];\n// But this types to (T | U)[]\n// NEW:\n// With variadic tuple types, we can define it easily and keep the information about the length.\ndeclare function concatNew(arr1: T, arr2: U): [...T, ...U];\nconst tuple = concatNew([23, 'hey', false] as [number, string, boolean], [5, 99, 20] as [number, number, number]);\nconsole.log(tuple[0]); // 23\nconst element: number = tuple[1]; // Type error: Type 'string' is not assignable to type 'number'.\nconsole.log(tuple[6]); // Type error: Tuple type '[23, \"hey\", false, 5, 99, 20]' of length '6' has no element at index '6'.\n</a></code></p><p></p><p><a>●&nbsp;&nbsp;标记元组元素: 元组元素现可被命名为 [start: number, end: number] 的形式。如果命名其中一个元素，则所有元素必须均被命名。</a></p><p></p><p><a><code lang=\"typescript\">type Foo = [first: number, second?: string, ...rest: any[]];\n// This allows the arguments to be named correctly here, it also shows up in the editor.\ndeclare function someFunc(...args: Foo);\n</code></a></p><p></p><p><a>●&nbsp;&nbsp;从构造函数推断类属性: 在构造函数中设置属性时，现可推断其类型，不再需要手动设置。</a></p><p></p><p><a><code lang=\"typescript\">class Animal {\n// No need to set types when they are assigned in the constructor.\nname;\nconstructor(name: string) {\nthis.name = name;\nconsole.log(this.name); // typed as string\n}\n}\n</code></a></p><p></p><p><a>●JSDoc @deprecated 支持: TypeScript 现可识别 JSDoc/TSDoc @deprecated 标签。</a></p><p></p><p><a><code lang=\"typescript\">/** @deprecated message */\ntype Test = string;\nconst test: Test = 'dfadsf'; // Type error: 'Test' is deprecated.\n</code></a></p><p></p><p></p><h3><a>TypeScript 4.1</a></h3><p></p><p></p><p><a>●&nbsp;&nbsp;模板字面量类型: 在定义字面量类型时，可以通过 ${Type}等模板指定类型。这样可以构造复杂的字符串类型，例如将多个字符串字面量组合起来。</a></p><p></p><p><a><code lang=\"typescript\">type VerticalDirection = 'top' | 'bottom';\ntype HorizontalDirection = 'left' | 'right';\ntype Direction = `${VerticalDirection} ${HorizontalDirection}`;\nconst dir1: Direction = 'top left';\nconst dir2: Direction = 'left'; // Type error: Type '\"left\"' is not assignable to type '\"top left\" | \"top right\" | \"bottom left\" | \"bottom right\"'.\nconst dir3: Direction = 'left top'; // Type error: Type '\"left top\"' is not assignable to type '\"top left\" | \"top right\" | \"bottom left\" | \"bottom right\"'.\n// This can also be combined with generics and the new utility types.\ndeclare function makeId(first: T, second: U): `${Capitalize}-${Lowercase<u>}`;\n</u></code></a></p><p></p><p><a><u>●&nbsp;&nbsp;在映射类型中重新映射键: 为已映射的类型重新分配类型，但仍使用其值，例如 [K in keyof T as NewKeyType]: T[K]。</u></a></p><p></p><p><a><u><code lang=\"typescript\">// Let's say we wanted to reformat an object but prepend its IDs with an underscore.\nconst obj = { value1: 0, value2: 1, value3: 3 };\nconst newObj: { [Property in keyof typeof obj as `_${Property}`]: number }; // typed as { _value1: number; _value2: number; value3: number; }\n</code></u></a></p><p></p><p><a><u>●&nbsp;&nbsp;递归条件类型: 在定义之内使用条件类型，这种类型允许以有条件方式解包无限嵌套值。</u></a></p><p></p><p><a><u><code lang=\"typescript\">type Awaited = T extends PromiseLike ? Awaited<u> : T;\ntype P1 = Awaited; // typed as string\ntype P2 = Awaited&gt;; // typed as string\ntype P3 = Awaited&gt;&gt;; // typed as string\n</u></code></u></a></p><p></p><p><a><u><u>●&nbsp;&nbsp;JSDOC @see 标签的编辑器支持: JSDoc/TSDoc @see variable/type/link 标签现可在编辑器中受到支持。</u></u></a></p><p></p><p><a><u><u><code lang=\"cs\">const originalValue = 1;\n/**\n* Copy of another value\n* @see originalValue\n*/\nconst value = originalValue;\n</code></u></u></a></p><p></p><p><a><u><u>●&nbsp;&nbsp;tsc — explainFiles: &nbsp;--explainFiles 选项可被 TypeScript CLI 用于解释哪些文件是编译的一部分、为什么会这样。这一点对于调试非常重要。警告：对于大型项目或较为复杂的设置，这会生成大量输出，建议改用 tsc --explainFiles | less 或其他类似功能。</u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">tsc --explainFiles\n&lt;<output><=\"\" code=\"\"></output></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;解构变量可被显式标记为未使用: 在解构时，可使用下划线将变量标记为未使用，从而防止 TypeScript 抛出“未使用的变量”错误。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"javascript\">const [_first, second] = [3, 5];\nconsole.log(second);\n// Or even shorter\nconst [_, value] = [3, 5];\nconsole.log(value);\n</code></code></u></u></a></p><p></p><p></p><h3><a><u><u><code lang=\"javascript\">TypeScript 4.3</code></u></u></a></h3><p></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;属性上的单独写入类型: 在定义 set/get 访问器时，write/set 类型现可不同于 read/get 类型。意味着设置器能够接受相同值的多种格式。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">class Test {\nprivate _value: number;\nget value(): number {\nreturn this._value;\n}\nset value(value: number | string) {\nif (typeof value === 'number') {\nthis._value = value;\nreturn;\n}\nthis._value = parseInt(value, 10);\n}\n}\n</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;override: 使用 override，会将继承的类方法显式标记为覆写。因此当父类发生变化时，TypeScript 会提醒父方法已不存在，从而实现更安全的复杂继承模式。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">class Parent {\ngetName(): string {\nreturn 'name';\n}\n}\nclass NewParent {\ngetFirstName(): string {\nreturn 'name';\n}\n}\nclass Test extends Parent {\noverride getName(): string {\nreturn 'test';\n}\n}\nclass NewTest extends NewParent {\noverride getName(): string { // Type error: This member cannot have an 'override' modifier because it is not declared in the base class 'NewParent'.\nreturn 'test';\n}\n}\n</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;静态索引签名: 在类上使用静态属性时，现在也可以使用 static [propName: string]: string 设置索引签名。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">// PREVIOUSLY:\nclass Test {}\nTest.test = ''; // Type error: Property 'test' does not exist on type 'typeof Test'.\n// NEW:\nclass NewTest {\nstatic [key: string]: string;\n}\nNewTest.test = '';\n</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">●对JSDOC@link标签提供编辑器支持: JSDoc/TSDoc {@link variable/type/link} 内联标签现可在编辑器中显示和解析。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">const originalValue = 1;\n/**\n* Copy of {@link originalValue}\n*/\nconst value = originalValue;\n</code></code></u></u></a></p><p></p><p></p><h3><a><u><u><code lang=\"javascript\">TypeScript 4.4</code></u></u></a></h3><p></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;精确的可选属性类型 ( — exactOptionalPropertyTypes): 使用编译器标志 --exactOptionalPropertyTypes 时（或在 tsconfig.json 中），隐式允许 undefined（例如 property?: string）的属性将不允许被分配为 undefined。相反，undefined 必须经过明确许可，例如 property: string | undefined。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"typescript\">class Test {\nname?: string;\nage: number | undefined;\n}\nconst test = new Test();\ntest.name = 'test'; // Type error: Option 'exactOptionalPropertyTypes' cannot be specified without specifying option 'strictNullChecks'.\ntest.age = 0;\n</code></code></u></u></a></p><p></p><p></p><h3><a><u><u><code lang=\"javascript\">TypeScript 4.5</code></u></u></a></h3><p></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;Awaited 类型与 Promise 改进: 新的 Awaited&lt;&gt;实用程序类型能从无限嵌套的 Promises 中提取值类型（类似于 await 对该值的操作）。这也改进了 Promise.all() 的类型推断。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"typescript\">// Let's say we want to have a generic awaited value.\n// We can use the Awaited utility type for this (its source code was part of a previous example),\n// so infinitely nested Promises all resolve to their value.\ntype P1 = Awaited; // typed as string\ntype P2 = Awaited&gt;; // typed as string\ntype P3 = Awaited&gt;&gt;; // typed as string\n</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;导入名称上的类型修饰符: 在普通（非 import type）导入语句中，关键字 type 可用于表示该值只应在类型编译时导入（且可以去除）。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"typescript\">// PREVIOUSLY:\n// The optimal way to import types is to use the `import type` keyword to prevent them from actually being imported after compilation.\nimport { something } from './file';\nimport type { SomeType } from './file';\n// This needs two import statements for the same file.\n// NEW:\n// Now this can be combined into one statement.\nimport { something, type SomeType } from './file';\n</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;const 断言: 在将常量定义为 as const 时，即可将其准确归类为字面量类型。这项功能有多种用例，可以轻松进行准确分类。此功能还会令对象和数组成为 readonly，防止常量对象发生突变。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"typescript\">// PREVIOUSLY:\n// The optimal way to import types is to use the `import type` keyword to prevent them from actually being imported after compilation.\nimport { something } from './file';\nimport type { SomeType } from './file';\n// This needs two import statements for the same file.\n// NEW:\n// Now this can be combined into one statement.\nimport { something, type SomeType } from './file';\n</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;类中各方法的片段补全: 当一个类继承多个方法类型时，编辑器现可为各类型提供建议片段。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><img src=\"https://static001.geekbang.org/wechat/images/df/df5368d7cf6f2edd8a771e40cbf2218a.gif\" /></code></u></u></a></p><p></p><p></p><h3><a><u><u><code lang=\"javascript\">TypeScript 4.6</code></u></u></a></h3><p></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;索引访问推断改进：当直接在键内直接索引一个类型时，如果该类型位于同一对象上，现在其准确率会更高。这也是 TypeScript 现代化特性的良好体现。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"typescript\">interface AllowedTypes {\n'number': number;\n'string': string;\n'boolean': boolean;\n}\n// The Record specifies the kind and value type from the allowed types.\ntype UnionRecord = { [Key in AllowedKeys]:\n{\nkind: Key;\nvalue: AllowedTypes[Key];\nlogValue: (value: AllowedTypes[Key]) =&gt; void;\n}\n}[AllowedKeys];\n// The function logValue only accepts the value of the Record.\nfunction processRecord(record: UnionRecord) {\nrecord.logValue(record.value);\n}\nprocessRecord({\nkind: 'string',\nvalue: 'hello!',\n// The value used to implicitly have the type string | number | boolean,\n// but now is correctly inferred to just string.\nlogValue: value =&gt; {\nconsole.log(value.toUpperCase());\n}\n});\n</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;TypeScript Trace Analyzer ( — generateTrace): &nbsp;--generateTrace</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">选项可在 TypeScript CLI 当中用于生成一个文件，其中包含关于类型检查和编译过程的详情信息。这有助于优化复杂类型。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">tsc --generateTrace trace\ncat trace/trace.json\n&lt;<output><<output><=\"\" code=\"\"></output></code></code></u></u></a></p><p></p><p></p><h3><a><u><u><code lang=\"javascript\"><code lang=\"cs\">TypeScript 4.7</code></code></u></u></a></h3><p></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;在 Node.js 中支持 ECMAScript 模块: 在使用 ES Modules 替代 CommonJS 时，TypeScript 现可支持指定默认值。具体指定在 tsconfig.json 中实现。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><code lang=\"javascript\">...\n\"compilerOptions\": [\n...\n\"module\": \"es2020\"\n]\n...\n</code></code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;package.json 中的类型: &nbsp;package.json 中的 type 字段可被设定为\"module\"，以供 ES Modules 使用 node.js。在大多数情况下，这种方式对 TypeScript 已经足够，不需要前面提到的编译器选项。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><code lang=\"javascript\">...\n\"type\": \"module\"\n...\n</code></code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;实例化表达式: 实例化表达式允许在引用一个值时，指定类型参数。这样可以在不创建包装器的前提下，收窄泛型类型。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><code lang=\"php\">class List {\nprivate list: T[] = [];\nget(key: number): T {\nreturn this.list[key];\n}\npush(value: T): void {\nthis.list.push(value);\n}\n}\nfunction makeList(items: T[]): List {\nconst list = new List();\nitems.forEach(item =&gt; list.push(item));\nreturn list;\n}\n// Let's say we want to have a function that creates a list but only allows certain values.\n// PREVIOUSLY:\n// We need to manually define a wrapper function and pass the argument.\nfunction makeStringList(text: string[]) {\nreturn makeList(text);\n}\n// NEW:\n// Using instantiation expressions, this is much easier.\nconst makeNumberList = makeList;\n</code></code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;扩展对推断类型变量的约束: 在条件类型中推断类型变量时，现在可以使用 extends 直接将其收窄 / 约束。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><code lang=\"typescript\">// Let's say we want to type a type that only gets the first element of an array if it's a string.\n// We can use conditional types for this.\n// PREVIOUSLY:\ntype FirstIfStringOld =\nT extends [infer S, ...unknown[]]\n? S extends string ? S : never\n: never;\n// But this needs two nested conditional types. We can also do it in one.\ntype FirstIfString =\nT extends [string, ...unknown[]]\n// Grab the first type out of `T`\n? T[0]\n: never;\n// This is still suboptimal because we need to index the array for the correct type.\n// NEW:\n// Using extends Constraints on infer Type Variables, this can be declared a lot easier.\ntype FirstIfStringNew =\nT extends [infer S extends string, ...unknown[]]\n? S\n: never;\n// Note that the typing worked the same before, this is just a cleaner syntax.\ntype A = FirstIfStringNew&lt;[string, number, number]&gt;; // typed as string\ntype B = FirstIfStringNew&lt;[\"hello\", number, number]&gt;; // typed as \"hello\"\ntype C = FirstIfStringNew&lt;[\"hello\" | \"world\", boolean]&gt;; // typed as \"hello\" | \"world\"\ntype D = FirstIfStringNew&lt;[boolean, number, string]&gt;; // typed as never\n</code></code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;类型参数的可选变体注释: 泛型在检查是否“匹配”时可以有不同行为，例如对 getter 和 setter，对是否允许继承的判断是相反的。为了明确起见，现在用户可以明确指定。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><code lang=\"javascript\">// Let's say we have an interface / a class that extends another one.\ninterface Animal {\nanimalStuff: any;\n}\ninterface Dog extends Animal {\ndogStuff: any;\n}\n// And we have some generic \"getter\" and \"setter\".\ntype Getter = () =&gt; T;\ntype Setter = (value: T) =&gt; void;\n// If we want to find out if Getter matches Getter or Setter matches Setter, this depends on the covariance.\nfunction useAnimalGetter(getter: Getter) {\ngetter();\n}\n// Now we can pass a Getter into the function.\nuseAnimalGetter((() =&gt; ({ animalStuff: 0 }) as Animal));\n// This obviously works.\n// But what if we want to use a Getter which returns a Dog instead?\nuseAnimalGetter((() =&gt; ({ animalStuff: 0, dogStuff: 0 }) as Dog));\n// This works as well because a Dog is also an Animal.\nfunction useDogGetter(getter: Getter) {\ngetter();\n}\n// If we try the same for the useDogGetter function we will not get the same behavior.\nuseDogGetter((() =&gt; ({ animalStuff: 0 }) as Animal)); // Type error: Property 'dogStuff' is missing in type 'Animal' but required in type 'Dog'.\n// This does not work, because a Dog is expected, not just an Animal.\nuseDogGetter((() =&gt; ({ animalStuff: 0, dogStuff: 0 }) as Dog));\n// This, however, works.\n// Intuitively we would maybe expect the Setters to behave the same, but they don't.\nfunction setAnimalSetter(setter: Setter, value: Animal) {\nsetter(value);\n}\n// If we pass a Setter of the same type it still works.\nsetAnimalSetter((value: Animal) =&gt; {}, { animalStuff: 0 });\nfunction setDogSetter(setter: Setter, value: Dog) {\nsetter(value);\n}\n// Same here.\nsetDogSetter((value: Dog) =&gt; {}, { animalStuff: 0, dogStuff: 0 });\n// But if we pass a Dog Setter into the setAnimalSetter function, the behavior is reversed from the Getters.\nsetAnimalSetter((value: Dog) =&gt; {}, { animalStuff: 0, dogStuff: 0 }); // Type error: Argument of type '(value: Dog) =&gt; void' is not assignable to parameter of type 'Setter'.\n// This time it works the other way around.\nsetDogSetter((value: Animal) =&gt; {}, { animalStuff: 0, dogStuff: 0 });\n// NEW:\n// To signal this to TypeScript (not needed but helpful for readability), use the new Optional Variance Annotations for Type Parameters.\ntype GetterNew = () =&gt; T;\ntype SetterNew = (value: T) =&gt; void;\n</code></code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;使用 moduleSuffixes 实现分辨率自定义: 在使用具有自定义文件后缀的环境时（例如，.ios 用于原生应用构建），现在您可以为 TypeScript 指定这些后缀以正确对导入进行解析。具体指定在 tsconfig.json 中实现。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><code lang=\"python\">...\n\"compilerOptions\": [\n...\n\"module\": [\".ios\", \".native\", \"\"]\n]\n...\nimport * as foo from './foo';\n// This first checks ./foo.ios.ts, ./foo.native.ts, and finally ./foo.ts.\n</code></code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;在编辑器内转到源定义: 在编辑器中，开放新的“转到源定义”菜单项。其功能类似于“转到定义”，但更多指向.ts 和 .js 文件，而非类型定义 (.d.ts)。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><img src=\"https://static001.geekbang.org/wechat/images/cb/cb8e6717c99bfa77c1b952143edeca25.gif\" /></code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><img src=\"https://static001.geekbang.org/wechat/images/aa/aafcc6a9f17ce3871708f31e0eb83f21.gif\" /></code></code></u></u></a></p><p></p><p></p><h3><a><u><u><code lang=\"javascript\"><code lang=\"cs\">TypeScript 4.9</code></code></u></u></a></h3><p></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;satisfies 运算符: satisfies 运算符允许检查与类型间的兼容性，且无需实际分配该类型。这样可以在保持兼容性的同时，获得更准确的类型推断。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><code lang=\"typescript\">// PREVIOUSLY:\n// Let's say we have an object/map/dictionary which stores various items and their colors.\nconst obj = {\nfireTruck: [255, 0, 0],\nbush: '#00ff00',\nocean: [0, 0, 255]\n} // typed as { fireTruck: number[]; bush: string; ocean: number[]; }\n// This implicitly types the properties so we can operate on the arrays and the string.\nconst rgb1 = obj.fireTruck[0]; // typed as number\nconst hex = obj.bush; // typed as string\n// Let's say we only want to allow certain objects.\n// We could use a Record type.\nconst oldObj: Record = {\nfireTruck: [255, 0, 0],\nbush: '#00ff00',\nocean: [0, 0, 255]\n} // typed as Record\n// But now we lose the typings of the properties.\nconst oldRgb1 = oldObj.fireTruck[0]; // typed as string | number\nconst oldHex = oldObj.bush; // typed as string | number\n// NEW:\n// With the satisfies keyword we can check compatibility with a type without actually assigning it.\nconst newObj = {\nfireTruck: [255, 0, 0],\nbush: '#00ff00',\nocean: [0, 0, 255]\n} satisfies Record // typed as { fireTruck: [number, number, number]; bush: string; ocean: [number, number, number]; }\n// And we still have the typings of the properties, the array even got more accurate by becoming a tuple.\nconst newRgb1 = newObj.fireTruck[0]; // typed as number\nconst newRgb4 = newObj.fireTruck[3]; // Type error: Tuple type '[number, number, number]' of length '3' has no element at index '3'.\nconst newHex = newObj.bush; // typed as string\n</code></code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;编辑器中的“删除未使用的导入”与“排序导入”命令: 在编辑器中，新命令（及自动修复）“删除未使用的导入”和“排序导入”让导入管理更加轻松易行。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><img src=\"https://static001.geekbang.org/wechat/images/cf/cf9486e812b0cf2c6b1bab06ece29c8b.gif\" /></code></code></u></u></a></p><p></p><p></p><h5><a><u><u><code lang=\"javascript\"><code lang=\"cs\">原文链接：</code></code></u></u></a></h5><p></p><p><u><u><code lang=\"javascript\"><code lang=\"cs\"><a href=\"https://medium.com/@LinusSchlumberger/all-javascript-and-typescript-features-of-the-last-3-years-629c57e73e42\">https://medium.com/@LinusSchlumberger/all-javascript-and-typescript-features-of-the-last-3-years-629c57e73e42</a>\"</code></code></u></u></p><p></p><p></p><h5><u><u><code lang=\"javascript\"><code lang=\"cs\">相关阅读：</code></code></u></u></h5><p></p><p><u><u><code lang=\"javascript\"><code lang=\"cs\"><a href=\"https://xie.infoq.cn/article/6ff79700fb3bfa972c1beebf3\">TypeScript 与 JavaScript：你应该知道的区别</a>\"</code></code></u></u></p><p><u><u><code lang=\"javascript\"><code lang=\"cs\"><a href=\"https://www.infoq.cn/article/CBb3RhvCHflT42ppOLkR\">JavaScript 框架太多了？相反，是太少了</a>\"</code></code></u></u></p><p><u><u><code lang=\"javascript\"><code lang=\"cs\"><a href=\"https://xie.infoq.cn/article/e976363d22c7ffd126d9b6eb1\">最佳的 18 个 JAVASCRIPT 前端开发框架和库</a>\"</code></code></u></u></p><p><u><u><code lang=\"javascript\"><code lang=\"cs\"><a href=\"https://www.infoq.cn/article/ds994KySqo868U3e8s4N\">我踩过了 TypeScript 的坑，只想告诉你快来</a>\"</code></code></u></u></p>",
    "publish_time": "2023-04-03 12:34:50",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "数据库内核杂谈（二十九）- 多租户(multi-tenant)系统设计的思考（番外）",
    "url": "https://www.infoq.cn/article/qLOvcpaqSy4asOuPV5vd",
    "summary": "<p>欢迎阅读新一期的数据库内核杂谈。这期杂谈，不聊数据库，咱们插入一个番外篇，聊一下多租户(multi-tenant)应用的系统设计。对于多租户系统的思考，源于最近的工作，再结合内核杂谈前几期阅读的关于AWS DynamoDB的论文。我的工作主要是构建云端的服务来支持整个自动驾驶产品的迭代，可以认为是为用户提供SAAS服务。这些服务的质量和稳定性，本质上都可以通过引入正确的多租户系统架构来解决。</p><p>&nbsp;</p><p></p><h1>什么是多租户(multi-tenant)系统架构</h1><p></p><p>多租户系统是一种软件架构：一个服务实例会同时为多个客户或用户（称为租户）提供服务。这种方法允许在租户之间高效共享计算资源、基础设施和服务，同时保持数据隔离和安全性。多租户架构的好处主要在：1）节约成本，资源的共享可以降低供应商和租户的基础设施和维护的成本；2）简化管理，集中执行更新、安全补丁和维护任务，从而使所有租户一次受益并减少管理开销。此外，多租户应用程序还为可扩展性而设计，使系统能够随着租户数量及其资源需求的增长而增长。这确保了在适应多样化客户群体的不断变化需求的同时，能够实现最佳性能和资源利用。</p><p>&nbsp;</p><p>绝大部分（如果不是全部的话）公有云的SAAS服务基本都属于多租户应用。比如AWS的DynamoDB服务，是一款非常受欢迎的key-value的NoSQL系统。对每个用户而言，DynamoDB服务就是一堆简单的调用接口。不同用户之间完全不会感知到彼此的存在，这些用户也不会互相影响（参考 <a href=\"https://www.infoq.cn/article/aEUY5kcI1a3iqGUyGzUy\">https://www.infoq.cn/article/aEUY5kcI1a3iqGUyGzUy</a>\")。</p><p>&nbsp;</p><p></p><h1>设计和开发多租户系统的挑战</h1><p></p><p>天下没有免费的午餐。虽然能带来成本节约和简化管理，但设计多租户系统仍面临着很多挑战。因为开发人员必须在确保效率、安全性和可扩展性的同时，平衡多个租户的需求。主要的挑战在于：</p><p>数据隔离：确保数据的隔离（安全）在多租户应用中至关重要，因为租户的数据必须保持独立且无法被其他租户访问。设计一个能够有效隔离每个租户数据的同时仍允许高效资源共享的系统会很复杂。这需要实施严格的权限控制、面向租户的数据访问和加密，来保护敏感信息。保持性能稳定：多租户应用程序必须为所有租户提供一致的性能，无论用户数量或资源消耗程度如何。这需要设计一个可扩展且稳健的架构，能够处理可变的工作负载并根据需求自动调整资源。必须采用监控和性能优化技术（如负载均衡和缓存）来确保系统顺畅运行。合理管理资源：和保持性能相关，有效分配和管理资源（如计算、存储和网络容量）对多租户应用至关重要。开发人员必须实施资源配额、限流和监控策略，以确保公平分配资源并防止单个租户占用过多资源。提供定制：不同的租户可能在功能、外观或配置方面有独特的要求。设计一个支持定制和可扩展性的多租户应用可能具有挑战性。开发人员必须创建模块化和灵活的架构，允许租户根据其特定需求定制应用程序，而不影响整个系统的稳定性或性能。租户生命周期管理：在多租户环境中处理租户的入驻、升级、降级和退出会非常复杂。开发人员需要建立管理租户生命周期事件的流程和自动化，确保平稳过渡，最大程度地减少服务中断。安全与合规：多租户应用程序必须遵守严格的安全和合规要求，尤其是在处理敏感数据或在受监管行业运营时。实施严格的安全措施（如数据加密、安全访问控制和定期安全审计）非常有挑战性且耗时。计费和计量：在共享环境中，准确跟踪和计费每个租户的资源使用非常复杂。设计一个透明且公平的计费系统需要实施计量和监控机制，以准确捕捉特定租户的使用数据。</p><p>在设计多租户应用时，需要对这些挑战进行仔细的规划和架构决策。我们需要在设计初期中就全盘考量上述的挑战。</p><p>&nbsp;</p><p></p><h1>多租户系统的设计思考</h1><p></p><p>如果你问ChatGPT，哪些是设计多租户系统的最佳实践，它会把上面的这些条目再给你列一下，再给你一些建议（针对每个条目，应该注意哪些）。阅读后，我觉得信息增益不大。倒是AWS的DynamoDB的论文，给了我很多启发。以下是我的思考。</p><p>&nbsp;</p><p></p><h2>用户的权利和义务SLA</h2><p></p><p>用一句话概括就是，设置并管理好用户的预期。在执行层面就是，和用户对齐服务的SLA，并通过技术手段严格遵守SLA。</p><p>&nbsp;</p><p>通常，我们认为服务的SLA就是稳定性几个9，服务中断不超过多少时间，修复时间不超过多长等等，这些SLA当然重要。在我看来，这些SLA定义了用户的权利。DynamoDB服务，还定义了哪些其他的SLA呢？ DynamoDB的表通常被划分为多个partition, 对于每一个 partition（作为计算和存储的基本调度单元），DynamoDB 引入了 Read Capacity Unit（RCU)和 Write Capacity Unit（WCU）来控制其相应的吞吐SLA。RCU 的定义如下，对于一个至多 4KB 的 item，一个 RCU 保证每秒做一次强一致读。同理，WCU 的定义是对于一个至多 4KB 的 item，一个 WCU 保证每秒做一次写操作。将一个表的所有的 partition 的 RCU 和 WCU 求和，即为这个表的总吞吐SLA。举个例子，一个表有4个partition，每个partition如果申请了800 RCU和WCU，那这张表的整体RCU和WCU就是3200，即，这张表应该要保证每秒能进行3200次的读操作和写操作。乍一看，这个SLA依然是用户的权利。但精髓的是，DynamoDB通过严格的throttling机制，同时也限制了这个表的读写上限为3200 QPS。如此，这张表的3200 QPS也变成了用户的义务SLA。即，用户必须遵守义务SLA（当然，DynamoDB是通过技术手段确保了用户必须去遵守），才能享受权利SLA，比如稳定性几个9，返回延时保证在单毫秒级别等等。</p><p>&nbsp;</p><p>这真的是一个非常精妙的设计！通过严格遵守义务SLA，把复杂系统里的很多不确定性因素都避免了。当每个用户都定义好了义务SLA，就不会再出现意外的流量激增（traffic spike）（当然， DynamoDB也引入了一些新颖的设计，来解决这种临时的流量激增，但这不在本文的讨论范围内），因为所有用户的义务SLA的总和就是最大吞吐需求。有了明确的需求，系统可以提前做好充裕的资源分配，也不用担心这些资源会不够。只有当需求（义务SLA）改变的时候，才需要新增资源。</p><p>&nbsp;</p><p></p><h2>Force用户严格遵守义务SLA</h2><p></p><p>多租户系统的一个非常大的挑战就是，一个bad player可能会导致整体服务不稳定从而影响其他租户。这就违反了多租户系统的第一设计原则：不同租户理论上不应该知道其他租户的存在。杜绝bad player出现的最好的方式就是，扼杀在萌芽中。有效的技术手段就是active地throttling（限流），确保用户就不能变成一个bad player。DynamoDB也是这么去做的。</p><p>&nbsp;</p><p></p><h1>其他的多租户系统设计实践</h1><p></p><p>如果能严格遵守上述的设计原则，其他的设计会变得更水到渠成。这里，也总结一下多租户系统的一些其他设计原则：</p><p>做好租户隔离：实施数据分区策略，如单独的数据库、单独的模式或带有租户标识符列的共享模式，以确保数据隐私和安全。此外，应用严格的访问控制和租户上下文感知数据访问，以保护租户数据。设计好可水平扩展性（horizontal scaling）：可水平扩展是多租户系统的关键，必须要能够做到。你可以依赖分布式系统设计来完成，也可以通过申请独立资源，为每个租户独立部署（当然这个方法比较原始）。确保系统可以增加更多资源以适应不断增加的工作负载。通过分布式和云原生来统一部署的好处在于，可以做到动态地扩缩容，也能根据不同租户的业务属性不同，做好削峰填谷，以确保最佳性能和资源利用。定制化和可扩展性：开发支持租户定制、扩展的模块化和灵活的架构。使用可配置设置、插件和基于 API 的界面，允许租户根据其独特要求定制应用程序，而不影响整个系统的稳定性或性能。集中式管理：实施集中式管理系统，用于应用程序更新、安全补丁和维护任务。这简化了管理，减少了开销，并确保所有租户同时受益于改进和修复。可观察性和监控：完善的可观测性属于基本操作。实施全面的监控和可观察性工具，以跟踪应用程序性能、资源使用和潜在问题。使用日志、指标和跟踪解决方案，以获取应用程序健康状况并识别改进方案。计费和计量：设计透明公平的计费系统，准确追踪每个租户的资源使用和成本。实施计量和监控机制，捕获租户特定的使用数据并生成计费报告。</p><p>&nbsp;</p><p></p><h1>总结</h1><p></p><p>这期番外篇，依然是从DynamoDB服务引申出来，讨论了一下多租户系统设计的思考。如果你一定要从这篇文章中获得些什么，就是下面这两句话：提供一个稳定的，严格遵守SLA的服务，远比提供一个不稳定，但偶尔能超越预期的服务要对用户更友善。设计多租户系统时，除了和用户定义好权利SLA，也定义好义务SLA，并严格执行这些SLA。</p><p>&nbsp;</p><p></p><h1>内核杂谈微信群和知识星球</h1><p></p><p>内核杂谈有个微信群，大家会在上面讨论数据库相关话题。目前群人数快400人啦，所以已经不能分享群名片加入了，可以添加我的微信（zhongxiangu）或者是内核杂谈编辑的微信（wyp_34358），备注：内核杂谈。</p><p>&nbsp;</p><p>除了数据库内核的专题blog，我还会push自己分享每天看到的有趣的IT新闻，放在我的知识星球里（免费的，为爱发电），欢迎加入。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/70/70bf009e0765b8417a2908a94be2ec06.jpeg\" /></p><p></p><h5>相关阅读：</h5><p></p><p><a href=\"https://xie.infoq.cn/article/9472adf321bcce7bc4835eee6\">分享：从数据库开发者的视角，预测 5 个开发趋势</a>\"</p><p><a href=\"https://xie.infoq.cn/article/fb83fe3ef4cb38bb15e2b5e3d\">腾讯云数据库性能打破世界纪录 每分钟可处理 8.14 亿笔交易</a>\"</p><p><a href=\"https://xie.infoq.cn/article/6b4823fedfe05fb494a4055a7\">从传统数据库痛点看分布式数据库选型问题</a>\"</p><p><a href=\"https://xie.infoq.cn/article/d22c59d43971c06c71adc6e7c\">开源面对面：浅谈数据库技术与人工智能的结合与实践</a>\"</p>",
    "publish_time": "2023-04-03 13:28:40",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "全球首个封禁ChatGPT的国家：OpenAI涉嫌数据泄露，如不整改将罚2000万欧元",
    "url": "https://www.infoq.cn/article/0Ajci2Edm9HHZ0O7kKRt",
    "summary": "<p></p><blockquote>由于意大利是首个宣布禁用 ChatGPT 的发达国家，也有声音认为，意大利此举或许会引发连锁反应。</blockquote><p></p><p></p><h2>意大利宣布禁用 ChatGPT</h2><p></p><p></p><p>据路透社报道，意大利数据保护局 Garante 在 3 月 31 日宣布暂时禁用 <a href=\"https://www.infoq.cn/theme/173\">ChatGPT</a>\"，并对其涉嫌违反隐私规则展开了调查。目前，<a href=\"https://www.infoq.cn/article/ZWixRo76hFsOw38tRHNF\">OpenAI</a>\" 已在意大利下线 ChatGPT，意大利也成为了全球首个封禁 ChatGPT 的国家（部分国家和地区在一开始就无法使用 ChatGPT。）</p><p></p><p>意大利数据保护局 Garante 认为，3 月 20 日 ChatGPT 平台出现了用户对话数据和付款服务支付信息丢失情况。此外平台没有就收集处理用户信息进行告知，缺乏大量收集和存储个人信息的法律依据。</p><p></p><p>意大利个人数据监管局（GPDP）指出，由于违反欧盟的《通用数据保护条例》（GDPR）和意大利自己的数据保护法，他们将立即对涉及意大利公民的“个人数据处理做临时限制”。</p><p></p><p>GPDP 在声明中强调，“我们发现，OpenAI 对其收集用户及各相关方数据的行为缺乏清晰说明。”另外，ChatGPT 对用户数据的处理还可能造成错误印象，“因为 ChatGPT 提供的信息并不一定与真实数据相对应。”</p><p></p><p>GPDP 还对 OpenAI 忽略用户年龄审查表达了担忧。作为微软的投资对象，OpenAI 曾提到其 ChatGPT 是专为 13 岁或以上的用户群体所设计。但这项服务在发布后并没有对用户做年龄验证，GPDP 认为“考虑到其发展程度和自我意识，未成年人在使用时可能接触到绝对不合适的答案。”</p><p></p><p>GPDP 提到，临时限制将适用于在意大利境内从相关各方处收集到的全部个人数据，这实质上就是封禁了 ChatGPT 服务。直到 OpenAI 能够证明其已经解决了 GPDP 发现的问题，封禁才会被解除。</p><p></p><p>OpenAI 表示，应 Garante 的要求，它已为意大利用户禁用了 ChatGPT。ChatGPT 网页上的一则通知称，该网站的所有者可能设置了限制，阻止用户访问该网站。OpenAI 补充说：“我们在训练我们的人工智能系统（如 ChatGPT）努力减少个人数据，因为我们希望我们的人工智能了解世界，而不是了解个人。”</p><p></p><p>此外，OpenAI 方面有 20 天时间对 GPDP 的其他指控做出回应，否则将面临高达 2000 万欧元（约合 2170 万美元）或全球年营业额 4% 的罚款（以较高者为准）。</p><p></p><p>由于意大利是首个宣布禁用 ChatGPT 的发达国家，也有声音认为，意大利此举或许会引发连锁反应。</p><p></p><h2>监管机构瞄准 AI</h2><p></p><p></p><p>事实上，这不是监管机构首次对涉嫌不当行为的 AI 采取行动。</p><p></p><p>据彭博社近日报道，美国联邦贸易委员会（FTC）建议提起诉讼，指控亚马逊的 <a href=\"https://www.infoq.cn/article/QNcQ16QQRGK7tQhOqeU9\">Alexa</a>\" 音箱在未经父母同意的情况下收集 13 岁以下儿童的信息，违反了《儿童在线隐私保护法》。司法部最早可能在 4 月代表联邦贸易委员会提起诉讼。</p><p></p><p>今年 2 月，意大利个人数据监管局（GPDP）也曾对 Replika 发出禁令。</p><p></p><p>Replika 是一款 AI 聊天机器人应用，用户不但能与之交谈，甚至可以将其设定为虚拟伴侣。GPDP 表示，他们担心 Replika 可能会令“仍处于发育阶段（即未成年人）”或“处于情绪脆弱状态”的个人陷入风险。之前也曾有媒体报道称，Replika 公司 CEO Eugenia Kuyda 承认这款应用愚弄过用户，让原本情绪稳定的个人误以为 Replika 具有感知能力、甚至与这款聊天机器人建立了情感关系。</p><p></p><p>意大利当局还认定 Replika 缺乏年龄验证机制，因此在今年 2 月宣布 Replika 违反了 GDPR 并以非法方式处理个人数据。</p><p></p><p>国际律师事务所 Ropes &amp; Gray 驻伦敦的隐私律师 Edward Machin 认为，ChatGPT 和 Replika 这类工具刚刚出现，人们很容易忽略其在“几周”之间就已经全面蹿红。</p><p></p><p>Machin 在一份声明中表示，大多数用户可能没有认真考虑过自己的数据被 OpenAI 用于训练会对其隐私造成哪些影响。“这里的问题是，对方没有向用户提供信息以确保做出明智的决定。另外，其实没有法理依据来支撑其处理用户数据的行为。”</p><p></p><p>Machin 强调，封禁 OpenAI 继续接触意大利民众的数据是 GPDP 所能采取的最有力的干预手段之一。“我认为欧洲各地的监管机构应该会感谢 GPDP 率先采取了这一措施，相信后续还会有更多国家决定跟进并发布类似的禁令。”</p><p></p><p>对于 ChatGPT 而言，最近正值多事之秋。除了面临来自意大利方面的压力，还要面临非营利组织人工智能与数字政策中心（CAIDP）的投诉。</p><p></p><p>据 The Verge 3 月 30 日报道，非营利组织人工智能与数字政策中心（CAIDP）向美国联邦贸易委员会（FTC）投诉，要求 FTC 调查 OpenAI 违反消费者保护规则的行为，该组织认为 GPT-4 具有偏见性、欺骗性、对隐私和公共安全构成风险。</p><p></p><p>CAIDP 认为，OpenAI 违反了 FTC 对人工智能产品的指导，并违反了 FTC 法案第 5 条，该法案禁止不公平和欺骗性的商业行为。CAIDP 敦促 FTC 对 OpenAI 进行调查，并暂停其大型语言模型的商业部署，包括 ChatGPT 的最新版本。</p><p></p><p>参考链接：</p><p><a href=\"https://www.theregister.com/2023/03/31/italy_bans_chatgpt_for_unlawful/\">https://www.theregister.com/2023/03/31/italy_bans_chatgpt_for_unlawful/</a>\"</p>",
    "publish_time": "2023-04-03 14:08:46",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]