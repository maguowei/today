[
  {
    "title": "避免成为“象牙塔”架构师：架构师和组织之间的关系",
    "url": "https://www.infoq.cn/article/T4PEt15NU2JUk1VWhTMv",
    "summary": "<p>在最近的访谈节目中，参与者讨论了<a href=\"https://youtu.be/2ezIiYHLXhc\">软件架构师与组织之间的关系</a>\"。他们详细描述了一个成功的架构师是如何影响他人的，他们可以深入细节，置身其中，也可以纵览全局，并在两种状态之间来回切换。</p><p>&nbsp;</p><p>微软公司副总裁<a href=\"https://www.linkedin.com/in/ulrichhomann/\">Uli Homann</a>\"说：</p><p>&nbsp;</p><p></p><blockquote>有时候，架构师被认为是象牙塔架构师，因为他们没有真正去参与一线的开发。他们不会明白压力来自哪里，现实是怎样的，只会告诉别人使用某种技术，却没有详细了解这意味着什么。&nbsp;我认为，高级架构师的目标是驱动努力的方向。当你身处战壕，你看见的是树，而不是森林。所以你需要在理解细节和纵观全局之间取得平衡，你需要知道我们仍然在正确的道路上还是已经在其他人都向右时却向左走了？&nbsp;避免陷入这种复杂的局面——人们不喜欢你或认为你只是在说而不是在做——的唯一方法就是“做”。你必须参与讨论，还得能够抽身回来。你看到了树的细节，然后还能确保树仍然位于森林之中，并根据你在战壕中所学到的知识更新企业架构策略。</blockquote><p></p><p>&nbsp;</p><p>Homann解释说，当架构师说了一些东西，这些东西实际上是有意义的，但在现实中变得不再有意义，这个时候就出现了脱节。如果反馈循环没有发生，架构就不会根据现实的反馈进行更新，从而偏离现实。“给出方向和策略是可以的，但之后要深入团队，让他们接受这些决定，并从谈话中了解你想要构建的东西是否真的有效。”</p><p>&nbsp;</p><p>微软首席架构师<a href=\"https://twitter.com/mougue\">Eric Charran</a>\"解释了为什么他认为软件架构师有时候应该是公职人员和有时候应该是社区组织者。作为一名公职人员，架构师的目标是帮助团队实现目标，包括亲自参与其中。“我能帮上什么忙？”是一个关键问题，“这里有一些有用的工具和技术”也是一个关键问题。作为社区组织者，架构师应该将他们所学到的知识传播到组织的其他部分，并适当地给团队一些赞扬。他说：“作为一名架构师，当团队开始站在我的肩膀上做事情时，我就成功了。”</p><p>&nbsp;</p><p>当主持人<a href=\"https://twitter.com/otterbook\">David Blank-Edelman</a>\"（微软资深云布道者）问到如何让人们听你话的时候，Charran回答说，人们想做好工作，如果他们看到你能帮助他们，他们就会听你的。他还说，人们不会根据事实做出决定，他们会做出情绪化的决定，并寻找事实来支持他们。“你必须愿意花时间帮助他们进入一种舒适的状态，让他们能够倾听你的观点。如果他们不愿意听你的观点，那么即使你可能是100%正确的，也只打赢了一半的仗。”</p><p>&nbsp;</p><p>Charran指出，如果架构师反复向同样的人解释同样的事情，他们应该只使用职位的权威，并成为“友好的投球者”。Homann补充说，架构师应该始终努力用外部证据来支持他们的建议，并指出，如果架构师自己无法打动人们，可以尝试通过其他人来打动他们。</p><p>&nbsp;</p><p>原文原文：</p><p><a href=\"https://www.infoq.com/news/2023/01/ivory-tower-architects/\">https://www.infoq.com/news/2023/01/ivory-tower-architects/</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/video/f8dUjceJYXNvdoEsISBD\">十年架构师锻造之路｜InfoQ 大会早班车第 10 期</a>\"</p><p><a href=\"https://www.infoq.cn/article/x5I9egrl31GuWjuBE9B5\">十四年架构师揭秘：要做架构师先要在鸟群中做好鸟</a>\"</p>",
    "publish_time": "2023-04-03 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "“诱骗”ChatGPT生成Win95系统密钥，1/3概率可激活；微软Teams落地国内；京东拟分拆旗下两公司上市｜AI一周资讯",
    "url": "https://www.infoq.cn/article/XVRINNYgprSOwajdgNii",
    "summary": "<p></p><blockquote>滴滴云3月31日起不再对外提供公有云服务；汽车雷达在无人陵园显示全是人，理想回应；腾讯副总裁郄小虎离职；京东拟分拆旗下两公司上市，股价暴涨......</blockquote><p></p><p></p><h2>资讯</h2><p></p><p></p><h4>滴滴云3月31日起不再对外提供公有云服务</h4><p></p><p></p><p>滴滴云宣布，由于产品线调整，将于2023年3月31日0:00起不再对外提供公有云服务。</p><p></p><p>滴滴云表示，如账户中仍有资源或余额，请在2023年6月30日24:00前及时进行资源备份迁移和提交退款申请。</p><p></p><p>据了解，滴滴云是滴滴出行的<a href=\"https://www.infoq.cn/article/2OTLSfjvdDCTy5bWCKvh\">云计算</a>\"服务，致力于为开发者提供简单快捷、高效稳定、高性价比、安全可靠的IT基础设施云服务。</p><p></p><h4>微软 Teams 国内版由世纪互联运营</h4><p></p><p>4月1日，<a href=\"https://www.infoq.cn/article/9wzrGiMTl8XClRgSfL9A\">微软</a>\"官方微信号宣布，旗下的办公协作应用Teams正式落地国内市场。</p><p></p><p>Microsoft Teams国内版将由世纪互联运营，Teams 会议室、Teams 应用商店、Teams 电话等更多功能将会陆续开启。</p><p></p><p>微软表示，为了更好满足跨国企业、大中型企业、创业团队等对于办公体验的不同需求，由世纪互联运营的Teams将作为Microsoft 365/Office 365组件，以不同服务订阅的形式提供给不同行业、不同需求的客户。</p><p></p><h4>主播“诱骗”ChatGPT 生成 Win95 系统密钥，1/3概率可激活</h4><p></p><p></p><p>4月1日，据IT之家报道，YouTube 频道 Enderman 在最新一期视频中，“诱骗”ChatGPT 生成可激活 Win95 系统的密钥。</p><p></p><p>该主播首先直接要求 <a href=\"https://archsummit.infoq.cn/2023/shanghai/track/1503\">ChatGPT</a>\" 生成 Win95 系统的密钥，理所当然地遭到了拒绝。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/57/577657f0fe2b2166d6db7167201ff1af.jpeg\" /></p><p></p><p>主播表示生成 Win95 密钥纯粹是出于好玩的目的，而且 Win95 的密钥生成机制也相当简单。该主播随后将 Win95 的密钥规则告诉 ChatGPT，然后通过调整一些语序和改进，生成了相应的密钥。</p><p></p><p>该主播随后在一台 Win95 虚拟机上随机测试了这些密钥，发现只有三分之一的密钥可以成功激活。</p><p></p><h4>汽车雷达在无人陵园显示全是人，理想回应</h4><p></p><p></p><p>日前，有车主在社交媒体发布视频称，自己的理想L9在空无一人的陵园道路上识别并标注出了数位行人。</p><p></p><p>3月29日，理想汽车方面就此回应称，“理想Max系列车型，使用激光雷达和视觉摄像头融合感知，受限于当前市场上传感器识别能力的局限性，车辆在某些场景下会出现显示异常，我们会在后续的OTA优化算法来加强识别能力。”</p><p></p><h4>腾讯副总裁郄小虎离职</h4><p></p><p></p><p>3月30日消息，据晚点LatePost报道，腾讯副总裁、PCG（平台与内容事业群）信息与服务线负责人郄小虎已离任。目前尚不清楚这位资深技术专家接下来的去向。郄小虎于 2020 年 9 月加入腾讯，任公司副总裁，负责 PCG 技术线相关职能。2021年12月接任 PCG 信息与服务线后，他管理着 QQ 浏览器、搜狗搜索、搜狗输入法等业务。郄小虎分管的业务将由腾讯副总裁、PCG 技术副总裁曾宇直接负责。曾宇于2002年加入腾讯，2012年升任公司副总裁，是腾讯资深的技术专家和管理者。</p><p></p><h4>任正非再次强调华为不造车，汽车设计不得使用华为/HUAWEI标志</h4><p></p><p></p><p>3月31日，据36氪报道，华为再次关于汽车业务发出决策公告。公告由华为创始人、董事长任正非署名发出，再次强调“<a href=\"https://www.infoq.cn/article/I0NcBrPUqHAgmaoKmeQF\">华为不造车”</a>\"，“有效期5年”。除此之外，任正非还对华为标志在汽车设计上的露出提出了严格要求。</p><p></p><p>“强调不能使用华为/HUAWEI出现在整车宣传和外观上。”消息人士告诉36氪，而且重点指出，“不能使用’华为问界’，’HUAWEI AITO’。”</p><p></p><h4>京东拟分拆旗下两公司上市，股价暴涨</h4><p></p><p></p><p>阿里日前宣布组织架构调整，未来子公司业务都有机会独立上市。</p><p></p><p>紧随其后，3月30日晚，<a href=\"https://www.infoq.cn/article/XZkteGNvhGPw4UGKMXZW\">京东</a>\"集团发布公告称，拟分拆旗下京东产发、京东工业于港交所主板独立上市。京东产发和京东工业随即向港交所递交A1申请文件，首次披露其业务构成及经营数据。受消息刺激，3月30日京东美股一度涨逾9%。</p><p></p><p>31日涨势延续到港股，早盘京东集团股价一度涨逾8%，最高报176.5港元，近9个交易日股价累计上涨超16%。</p><p></p><h4>美光计划裁员15%，实施高管减薪</h4><p></p><p></p><p>3月29日消息，据路透社报道，美光公司预计第3季度营收将暴跌60%，同时美光宣布，2023年裁员扩大到15%。数据显示，美光Q2营收同比下降约53%，至36.9亿美元，分析师预期为37.3亿美元；净亏损23亿美元，上年同期净利润22.6亿美元。由于芯片行业仍面临供过于求的困扰，美光预计营收将出现自2001年以来最严重的下滑。Mehrotra同时宣布，除了高阶主管减薪、全面停发2023会计年度奖金外，目前预期整体人力缩减比例将逼近15%。</p><p></p><h4>Databricks 开源 LLM，训练只需三个小时、30 美元</h4><p></p><p></p><p>据开源中国报道，大数据分析公司 Databricks Inc 近日也加入了生成式 AI 领域的竞争之中，发布了一个名为&nbsp;Dolly&nbsp;的开源大型语言模型，将模型命名为 Dolly 是为了向第一只克隆羊多莉致敬。</p><p></p><p>像 ChatGPT 和 Bard 这样的生成式 AI，它们使用的数据通常来自于在成千上万不同网站，使用的数据量十分惊人，而且想要使用这些数据训练 AI 还需要数以千计的强大 GPU 在背后提供支持。</p><p></p><p>Databricks 希望通过开源 <a href=\"https://www.databricks.com/blog/2023/03/24/hello-dolly-democratizing-magic-chatgpt-open-models.html\">Dolly </a>\"及其训练数据，让任何人都能开发出一个真正像人类的 AI，而无需投资数百万美元，也让这类 AI 不再是只有大型科技公司才能负担得起的东西，数以百万计的小公司也将能够从中受益。</p><p></p><p>除此之外，让各个小公司构建自己的模型，而不将数据通过 API 发送给专有模型背后的服务提供商，也可以保护小公司的敏感数据和专有的知识产权。此外，一些公司可能在模型质量、成本和期望行为方面有不同的权衡，这些公司也可以根据需求调整模型。</p><p></p><p>Dolly项目地址：<a href=\"https://www.databricks.com/blog/2023/03/24/hello-dolly-democratizing-magic-chatgpt-open-models.html\">https://www.databricks.com/blog/2023/03/24/hello-dolly-democratizing-magic-chatgpt-open-models.html</a>\"</p><p></p><p>Databricks 首席执行官 Ali Ghodsi 表示，Dolly 只需要非常少的数据和非常短的时间就能完成训练。</p><p></p><p></p><blockquote>只需 30 美元、一台服务器和三个小时，我们就能教 Dolly 开始进行人类级别的交互。</blockquote><p></p><p></p><h2>IT业界热评新闻</h2><p></p><p></p><h4>周鸿祎回应马斯克呼吁暂停GPT5研发：不发展才是最大的不安全</h4><p></p><p></p><p>3月30日，周鸿祎发长文回应马斯克呼吁暂停GPT-5的研发。周鸿祎表示，自己是做安全的，但我坚定地认为，不发展才是最大的不安全。“不管你愿不愿意，GPT 都将引领一场新的工业革命，意义超越互联网和 iPhone 的发明。它将带来生产力的大幅提升，进而提升国家竞争力。中国一定要迎头赶上。”</p><p></p><h4>消息称马斯克或最早4月来中国：特斯拉FSD有望落地</h4><p></p><p></p><p>3月31日消息，据财联社援引路透社报道，有消息人士称，<a href=\"https://www.infoq.cn/article/Sktl2hsqUBygTlDGRzOI\">特斯拉CEO埃隆·马斯克</a>\"或最早于4月份来中国。马斯克此行的目的暂时不得而知，不过近日倒是有不少汽车、科技博主明里暗里地表示，特斯拉的FSD驾驶系统或将在国内落地。</p><p></p><p>FSD，也就是Full Self-Drive的简称，中文名“完全自动驾驶能力”，目前在北美市场已经开放，且进行了长达一年多的测试，表现可圈可点，但在国内，由于相关政策的限制，特斯拉FSD一直未能落地。</p><p></p><p>在特斯拉官网上可以看到，FSD功能为选装，售价6.4万，包含基础版辅助驾驶和增强版自动辅助驾驶的全部功能，包括自动辅助导航驾驶、自动辅助变道、自动泊车、智能召唤，还拥有自动识别交通信号灯和停车标志并做出反应，在城市街道中自动辅助驾驶。</p><p></p><p>但需要注意的是，特斯拉同时还指出，目前可用的功能需要驾驶员主动进行监控，车辆尚未实现完全自动驾驶。上述功能的激活与使用将需要数十亿英里的行驶里程的论证，以达到远超人类驾驶员的可靠性；同时还有赖于行政审批（某些司法管辖区可能会需要更长的时间）。</p><p></p><p>不过以上均为猜测，具体情况有待进一步的确认，4月份<a href=\"https://www.infoq.cn/article/5LYIHLWuPVU8btDrfBut\">马斯克</a>\"来中国之后，一些疑问或将给出结果。</p><p></p>",
    "publish_time": "2023-04-03 09:44:52",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "三年回顾：JavaScript与TypeScript最新特性汇总",
    "url": "https://www.infoq.cn/article/SZZal8JbzaFq1O9YejCy",
    "summary": "<p></p><blockquote>全文 7739 字，建议收藏。本文涵盖了过去三年中发布的最新 JavaScript 和 TypeScript 特性，包括异步迭代器、nullish 合并、可选链、私有字段等等。对于每个特性，文章提供了简单的解释、示例代码以及使用场景，以便开发者能够更好地理解和应用这些新特性。同时，文章还介绍了如何在项目中使用这些特性，以及如何通过 polyfill 或者 Babel 等工具使旧的浏览器支持这些新特性。</blockquote><p></p><p></p><p>本文将带大家回顾过去三年（乃至更早）以来，JavaScript/ECMAScript 以及 TypeScript 经历的一系列功能变化。</p><p></p><p>当然，这里提到的很多功能也许跟大家的日常工作八竿子打不着。但关注功能的发展变化，应该能帮助您加深对这些语言的理解。</p><p></p><p>有很多 TypeScript 功能并没有被记录在内，因为它们总体上可以概括为“之前它的运作效果跟期望不同，但现在相同了”。所以如果大家之前对某些问题有所诟病，现在不妨重试一次。</p><p></p><p></p><h3>概述</h3><p></p><p></p><p>●&nbsp;&nbsp;JavaScript / ECMAScript (按时间排序)</p><p></p><p>●&nbsp;&nbsp;TypeScript (按时间排序)</p><p></p><p></p><h2>ECMAScript</h2><p></p><p></p><h3>更早（更早发布但仍然重要）</h3><p></p><p></p><p>●&nbsp;&nbsp;标记模板字面量：通过在模板字面量之前添加函数名，可以将函数传递至模板字面量和模板值的某些部分。这项功能有不少有趣的用途。</p><p></p><p><code lang=\"javascript\">// Let's say we want to write a way to log arbitrary strings containing a number, but format the number.\n// We can use tagged templates for that.\nfunction formatNumbers(strings: TemplateStringsArray, number: number): string {\n  return strings[0] + number.toFixed(2) + strings[1];\n}\nconsole.log(formatNumbers`This is the value: ${0}, it's important.`); // This is the value: 0.00, it's important.\n// Or if we wanted to \"translate\" (change to lowercase here) translation keys within strings.\nfunction translateKey(key: string): string {\n  return key.toLocaleLowerCase();\n}\nfunction translate(strings: TemplateStringsArray, ...expressions: string[]): string {\n  return strings.reduce((accumulator, currentValue, index) =&gt; accumulator + currentValue + translateKey(expressions[index] ?? ''), '');\n}\nconsole.log(translate`Hello, this is ${'NAME'} to say ${'MESSAGE'}.`); // Hello, this is name to say message.\n\n</code></p><p></p><p>●&nbsp;&nbsp;Symbols（之前被错误归类为 ES2022）：对象的唯一键：Symbol(“foo”) === Symbol(“foo”); // false。内部使用。</p><p></p><p><code lang=\"javascript\">const obj: { [index: string]: string } = {};\nconst symbolA = Symbol('a');\nconst symbolB = Symbol.for('b');\nconsole.log(symbolA.description); // \"a\"\nobj[symbolA] = 'a';\nobj[symbolB] = 'b';\nobj['c'] = 'c';\nobj.d = 'd';\nconsole.log(obj[symbolA]); // \"a\"\nconsole.log(obj[symbolB]); // \"b\"\n// The key cannot be accessed with any other symbols or without a symbol.\nconsole.log(obj[Symbol('a')]); // undefined\nconsole.log(obj['a']); // undefined\n// The keys are not enumerated when using for ... in.\nfor (const i in obj) {\n  console.log(i); // \"c\", \"d\"\n}\n</code></p><p></p><p></p><h3>ES2020</h3><p></p><p></p><p>●&nbsp;&nbsp;可选链：要访问一个可能未定义的对象的值（通过索引），可以通过在父对象名称后添加? 来使用可选链。可选链也可用于索引 ([…]) 或者函数调用。</p><p></p><p><code lang=\"typescript\">// PREVIOUSLY:\n// If we have an object variable (or any other structure) we don't know for certain is defined,\n// We can not easily access the property.\nconst object: { name: string } | undefined = Math.random() &gt; 0.5 ? undefined : { name: 'test' };\nconst value = object.name; // type error: 'object' is possibly 'undefined'.\n// We could first check if it is defined, but this hurts readability and gets complex for nested objects.\nconst objectOld: { name: string } | undefined = Math.random() &gt; 0.5 ? undefined : { name: 'test' };\nconst valueOld = objectOld ? objectOld.name : undefined;\n// NEW:\n// Instead we can use optional chaining.\nconst objectNew: { name: string } | undefined = Math.random() &gt; 0.5 ? undefined : { name: 'test' };\nconst valueNew = objectNew?.name;\n// This can also be used for indexing and functions.\nconst array: string[] | undefined = Math.random() &gt; 0.5 ? undefined : ['test'];\nconst item = array?.[0];\nconst func: (() =&gt; string) | undefined = Math.random() &gt; 0.5 ? undefined : () =&gt; 'test';\nconst result = func?.();\n</code></p><p></p><p>●&nbsp;&nbsp;import(): 动态导入，例如 import … from …，但在运行上且使用变量。</p><p></p><p><code lang=\"javascript\">let importModule;\nif (shouldImport) {\nimportModule = await import('./module.mjs');\n}\n</code></p><p></p><p>●&nbsp;&nbsp;String.matchAll: 获取正则表达式的多个匹配项，包括其捕获组，且不使用循环。</p><p></p><p><code lang=\"javascript\">const stringVar = 'testhello,testagain,';\n// PREVIOUSLY:\n// Only gets matches, but not their capture groups.\nconsole.log(stringVar.match(/test([\\w]+?),/g)); // [\"testhello,\", \"testagain,\"]\n// Only gets one match, including its capture groups.\nconst singleMatch = stringVar.match(/test([\\w]+?),/);\nif (singleMatch) {\n  console.log(singleMatch[0]); // \"testhello,\"\n  console.log(singleMatch[1]); // \"hello\"\n}\n// Gets the same result, but is very unintuitive (the exec method saves the last index).\n// Needs to be defined outside the loop (to save the state) and be global (/g),\n// otherwise this will produce an infinite loop.\nconst regex = /test([\\w]+?),/g;\nlet execMatch;\nwhile ((execMatch = regex.exec(stringVar)) !== null) {\n  console.log(execMatch[0]); // \"testhello,\", \"testagain,\"\n  console.log(execMatch[1]); // \"hello\", \"again\"\n}\n// NEW:\n// Regex needs to be global (/g), also doesn't make any sense otherwise.\nconst matchesIterator = stringVar.matchAll(/test([\\w]+?),/g);\n// Needs to be iterated or converted to an array (Array.from()), no direct indexing.\nfor (const match of matchesIterator) {\n  console.log(match[0]); // \"testhello,\", \"testagain,\"\n  console.log(match[1]); // \"hello\", \"again\"\n}\n</code></p><p></p><p>●&nbsp;&nbsp;Promise.allSettled(): 与 Promise.all() 类似，但需要等待所有 Promises 完成，且不会在第一次 reject/throw 时返回。它能让降低错误处理的难度。</p><p></p><p><code lang=\"javascript\">async function success1() {return 'a'}\nasync function success2() {return 'b'}\nasync function fail1() {throw 'fail 1'}\nasync function fail2() {throw 'fail 2'}\n// PREVIOUSLY:\nconsole.log(await Promise.all([success1(), success2()])); // [\"a\", \"b\"]\n// but:\ntry {\n  await Promise.all([success1(), success2(), fail1(), fail2()]);\n} catch (e) {\n  console.log(e); // \"fail 1\"\n}\n// Notice: We only catch one error and can't access the success values.\n// PREVIOUS FIX (really suboptimal):\nconsole.log(await Promise.all([ // [\"a\", \"b\", undefined, undefined]\n  success1().catch(e =&gt; { console.log(e); }),\n  success2().catch(e =&gt; { console.log(e); }),\n  fail1().catch(e =&gt; { console.log(e); }), // \"fail 1\"\n  fail2().catch(e =&gt; { console.log(e); })])); // \"fail 2\"\n// NEW:\nconst results = await Promise.allSettled([success1(), success2(), fail1(), fail2()]);\nconst sucessfulResults = results\n  .filter(result =&gt; result.status === 'fulfilled')\n  .map(result =&gt; (result as PromiseFulfilledResult).value);\nconsole.log(sucessfulResults); // [\"a\", \"b\"]\nresults.filter(result =&gt; result.status === 'rejected').forEach(error =&gt; {\n  console.log((error as PromiseRejectedResult).reason); // \"fail 1\", \"fail 2\"\n});\n// OR:\nfor (const result of results) {\n  if (result.status === 'fulfilled') {\n    console.log(result.value); // \"a\", \"b\"\n  } else if (result.status === 'rejected') {\n    console.log(result.reason); // \"fail 1\", \"fail 2\"\n  }\n}\n</code></p><p></p><p>●&nbsp;&nbsp;globalThis: 在全局上下文中访问变量，与环境无关（浏览器、NodeJS 等）。仍被视为较差实践，但在某些情况下是必要的。类似于浏览器上的 this。</p><p></p><p><code lang=\"javascript\">console.log(globalThis.Math); // Math Object\n</code></p><p></p><p>●import.meta: 在使用 ES-modules 时，获取当前模块的 URL import.meta.url。</p><p></p><p><code lang=\"javascript\">console.log(import.meta.url); // \"file://...\"\n</code></p><p></p><p>●&nbsp;&nbsp;export * as … from …: 轻松将默认值重新导出为子模块。</p><p></p><p><code lang=\"javascript\">export * as am from 'another-module'\nimport { am } from 'module'\n</code></p><p></p><p></p><h3>ES2021</h3><p></p><p></p><p>●&nbsp;&nbsp;String.replaceAll(): 替换掉某字符串内某一子字符串的所有实例，无需始终使用带有全局标志（/g）的正则表达式。</p><p></p><p><code lang=\"javascript\">const testString = 'hello/greetings everyone/everybody';\n// PREVIOUSLY:\n// Only replaces the first instance\nconsole.log(testString.replace('/', '|')); // 'hello|greetings everyone/everybody'\n// Instead a regex needed to be used, which is worse for performance and needs escaping.\n// Not the global flag (/g).\nconsole.log(testString.replace(/\\//g, '|')); // 'hello|greetings everyone|everybody'\n// NEW:\n// Using replaceAll this is much clearer and faster.\nconsole.log(testString.replaceAll('/', '|')); // 'hello|greetings everyone|everybody'\n</code></p><p></p><p>●&nbsp;&nbsp;Promise.any: 当只需要获取 promises 列表中的一个结果时，则返回第一个结果；仅在所有 promises 均被拒绝时才返回 AggregateError，而非立即拒绝的 Promise.race。</p><p></p><p><code lang=\"javascript\">async function success1() {return 'a'}\nasync function success2() {return 'b'}\nasync function fail1() {throw 'fail 1'}\nasync function fail2() {throw 'fail 2'}\n// PREVIOUSLY:\nconsole.log(await Promise.race([success1(), success2()])); // \"a\"\n// but:\ntry {\n  await Promise.race([fail1(), fail2(), success1(), success2()]);\n} catch (e) {\n  console.log(e); // \"fail 1\"\n}\n// Notice: We only catch one error and can't access the success value.\n// PREVIOUS FIX (really suboptimal):\nconsole.log(await Promise.race([ // \"a\"\n  fail1().catch(e =&gt; { console.log(e); }), // \"fail 1\"\n  fail2().catch(e =&gt; { console.log(e); }), // \"fail 2\"\n  success1().catch(e =&gt; { console.log(e); }),\n  success2().catch(e =&gt; { console.log(e); })]));\n// NEW:\nconsole.log(await Promise.any([fail1(), fail2(), success1(), success2()])); // \"a\"\n// And it only rejects when all promises reject and returns an AggregateError containing all the errors.\ntry {\n  await Promise.any([fail1(), fail2()]);\n} catch (e) {\n  console.log(e); // [AggregateError: All promises were rejected]\n  console.log(e.errors); // [\"fail 1\", \"fail 2\"]\n}\n</code></p><p></p><p>●&nbsp;&nbsp;Nullish coalescing assignment (??=): 仅在之前为 “nullish”（null 或 undefined）时才分配值。</p><p></p><p><code lang=\"javascript\">let x1 = undefined;\nlet x2 = 'a';\nconst getNewValue = () =&gt; 'b';\n// Assigns the new value to x1, because undefined is nullish.\nx1 ??= 'b';\nconsole.log(x1) // \"b\"\n// Does not assign a new value to x2, because a string is not nullish.\n// Also note: getNewValue() is never executed.\nx2 ??= getNewValue();\nconsole.log(x1) // \"a\"\n</code></p><p></p><p>●&nbsp;&nbsp;Logical and assignment (&amp;&amp;=): 仅在之前为“truhty”（true 或可以转换为 true 的值）时才分配值。</p><p></p><p><code lang=\"javascript\">let x1 = undefined;\nlet x2 = 'a';\nconst getNewValue = () =&gt; 'b';\n// Does not assign a new value to x1, because undefined is not truthy.\n// Also note: getNewValue() is never executed.\nx1 &amp;&amp;= getNewValue();\nconsole.log(x1) // undefined\n// Assigns a new value to x2, because a string is truthy.\nx2 &amp;&amp;= 'b';\nconsole.log(x1) // \"b\"\n</code></p><p></p><p>●&nbsp;&nbsp;Logical or assignment (||=): 仅在之前为“falsy”（false 或转换为 false）时才分配值。</p><p></p><p><code lang=\"javascript\">let x1 = undefined;\nlet x2 = 'a';\nconst getNewValue = () =&gt; 'b';\n// Assigns the new value to x1, because undefined is falsy.\nx1 ||= 'b';\nconsole.log(x1) // \"b\"\n// Does not assign a new value to x2, because a string is not falsy.\n// Also note: getNewValue() is never executed.\nx2 ||= getNewValue();\nconsole.log(x1) // \"a\"\n</code></p><p></p><p>●&nbsp;&nbsp;WeakRef: 保留对一个对象的“weak”引用，但不阻止对象被垃圾回收。</p><p></p><p><code lang=\"cs\">const ref = new WeakRef(element);\n// Get the value, if the object/element still exists and was not garbage-collected.\nconst value = ref.deref;\nconsole.log(value); // undefined\n// Looks like the object does not exist anymore.\n</code></p><p></p><p>●&nbsp;&nbsp;数字分隔符 (_): 使用 _ 分隔数字以提高可读性。不会对功能造成影响。</p><p></p><p><code lang=\"cs\">const int = 1_000_000_000;\nconst float = 1_000_000_000.999_999_999;\nconst max = 9_223_372_036_854_775_807n;\nconst binary = 0b1011_0101_0101;\nconst octal = 0o1234_5670;\nconst hex = 0xD0_E0_F0;\n</code></p><p></p><p></p><h3>ES2022</h3><p></p><p></p><p>●&nbsp;&nbsp;#private: 通过以 # 开头的命名，使类成员（属性和方法）私有，即只能通过类本身进行访问。其无法被删除或动态分配。任何不正确行为都会导致 JavaScript（注意，不是 TypeScript）语法错误。不推荐在 TypeScript 项目中这样做，而应用直接使用 private 关键字。</p><p></p><p><code lang=\"cs\">class ClassWithPrivateField {\n#privateField;\n#anotherPrivateField = 4;\nconstructor() {\nthis.#privateField = 42; // Valid\nthis.#privateField; // Syntax error\nthis.#undeclaredField = 444; // Syntax error\nconsole.log(this.#anotherPrivateField); // 4\n}\n}\nconst instance = new ClassWithPrivateField();\ninstance.#privateField === 42; // Syntax error\n</code></p><p></p><p>●&nbsp;&nbsp;静态类成员: 将任意类字段（属性和方法）标记为静态。</p><p></p><p><code lang=\"javascript\">class Logger {\nstatic id = 'Logger1';\nstatic type = 'GenericLogger';\nstatic log(message: string | Error) {\nconsole.log(message);\n}\n}\nclass ErrorLogger extends Logger {\nstatic type = 'ErrorLogger';\nstatic qualifiedType;\nstatic log(e: Error) {\nreturn super.log(e.toString());\n}\n}\nconsole.log(Logger.type); // \"GenericLogger\"\nLogger.log('Test'); // \"Test\"\n// The instantiation of static-only classes is useless and only done here for demonstration purposes.\nconst log = new Logger();\nErrorLogger.log(new Error('Test')); // Error: \"Test\" (not affected by instantiation of the parent)\nconsole.log(ErrorLogger.type); // \"ErrorLogger\"\nconsole.log(ErrorLogger.qualifiedType); // undefined\nconsole.log(ErrorLogger.id); // \"Logger1\"\n// This throws because log() is not an instance method but a static method.\nconsole.log(log.log()); // log.log is not a function\n</code></p><p></p><p>●&nbsp;&nbsp;类中的静态初始化块: 类初始化时运行的块，基本属于静态成员的“构造函数”。</p><p></p><p><code lang=\"javascript\">class Test {\nstatic staticProperty1 = 'Property 1';\nstatic staticProperty2;\nstatic {\nthis.staticProperty2 = 'Property 2';\n}\n}\nconsole.log(Test.staticProperty1); // \"Property 1\"\nconsole.log(Test.staticProperty2); // \"Property 2\"\n</code></p><p></p><p>●&nbsp;&nbsp;导入断言（非标准，在 V8 中实现）：以 import … from … assert { type: ‘json’ }的形式对导入类型做断言，可用于在不解析 JSON 的前提下将其导入。</p><p></p><p><code lang=\"typescript\">import json from './foo.json' assert { type: 'json' };\nconsole.log(json.answer); // 42\n</code></p><p></p><p>●&nbsp;&nbsp;RegExp 匹配索引：获取正则表达式匹配和捕获组的开始和结束索引。适用于 RegExp.exec(), String.match() 和 String.matchAll()。</p><p></p><p><code lang=\"javascript\">const matchObj = /(test+)(hello+)/d.exec('start-testesthello-stop');\n// PREVIOUSLY:\nconsole.log(matchObj?.index);\n// NEW:\nif (matchObj) {\n// Start and end index of entire match (before we only had the start).\nconsole.log(matchObj.indices[0]); // [9, 18]\n// Start and end indexes of capture groups.\nconsole.log(matchObj.indices[1]); // [9, 13]\nconsole.log(matchObj.indices[2]); // [13, 18]\n}\n</code></p><p></p><p>●&nbsp;&nbsp;负索引 (.at(-1)): 在索引数组或字符串时，可以使用 at 从末尾开始索引。相当于 arr[arr.length - 1)</p><p></p><p><code lang=\"javascript\">console.log([4, 5].at(-1)) // 5\n</code></p><p></p><p>●&nbsp;&nbsp;hasOwn: 推荐使用的新方法，用于查找对象具有哪些属性，用于替代 obj.hasOwnProperty()。在某些特殊情况下效果更好。</p><p></p><p><code lang=\"javascript\">const obj = { name: 'test' };\nconsole.log(Object.hasOwn(obj, 'name')); // true\nconsole.log(Object.hasOwn(obj, 'gender')); // false\n</code></p><p></p><p>●&nbsp;&nbsp;错误原因（Error cause）: 现在可以为错误指定可选原因，允许在重新抛出时指定原始错误。</p><p></p><p><code lang=\"javascript\">try {\ntry {\nconnectToDatabase();\n} catch (err) {\nthrow new Error('Connecting to database failed.', { cause: err });\n}\n} catch (err) {\nconsole.log(err.cause); // ReferenceError: connectToDatabase is not defined\n}\n</code></p><p></p><p></p><h3>之后（已可在 TypeScript 4.9 中使用）</h3><p></p><p></p><p>●&nbsp;&nbsp;Auto-Accessor: 自动将属性设为私有，并为其创建 get/set 访问器。</p><p></p><p><code lang=\"typescript\">class Person {\naccessor name: string;\nconstructor(name: string) {\nthis.name = name;\nconsole.log(this.name) // 'test'\n}\n}\nconst person = new Person('test');\n</code></p><p></p><p></p><h2>TypeScript</h2><p></p><p></p><h3>基础（进一步介绍上下文）</h3><p></p><p></p><p>●&nbsp;&nbsp;泛型: 将类型传递至其他类型，负责在对类型进行泛化后仍保证类型安全。应始终优先使用泛型，而非 any 或 unknown。</p><p></p><p><code lang=\"php\">// WITHOUT:\nfunction getFirstUnsafe(list: any[]): any {\nreturn list[0];\n}\nconst firstUnsafe = getFirstUnsafe(['test']); // typed as any\n// WITH:\nfunction getFirst(list: Type[]): Type {\nreturn list[0];\n}\nconst first = getFirst(['test']); // typed as string\n// In this case the parameter can even be dropped because it is inferred from the argument.\nconst firstInferred = getFirst(['test']); // typed as string\n// The types accepted as generics can also be limited using `extends`. The Type is also usually shortened to T.\nclass List {\nprivate list: T[] = [];\nget(key: number): T {\nreturn this.list[key];\n}\npush(value: T): void {\nthis.list.push(value);\n}\n}\nconst list = new List();\nlist.push(9); // Type error: Argument of type 'number' is not assignable to parameter of type 'string'.\nconst booleanList = new List(); // Type error: Type 'boolean' does not satisfy the constraint 'string | number'.\n</code></p><p></p><p></p><h3>更早（更早发布但仍然重要）</h3><p></p><p></p><p>●&nbsp;&nbsp;实用程序类型: TypeScript 中包含多种实用程序类型，这里解释其中最重要的几种。</p><p></p><p><code lang=\"typescript\">interface Test {\n  name: string;\n  age: number;\n}\n// The Partial utility type makes all properties optional.\ntype TestPartial = Partial; // typed as { name?: string | undefined; age?: number | undefined; }\n// The Required utility type does the opposite.\ntype TestRequired = Required; // typed as { name: string; age: number; }\n// The Readonly utility type makes all properties readonly.\ntype TestReadonly = Readonly; // typed as { readonly name: string; readonly age: string }\n// The Record utility type allows the simple definition of objects/maps/dictionaries. It is preferred to index signatures whenever possible.\nconst config: Record = { option: false, anotherOption: true };\n// The Pick utility type gets only the specified properties.\ntype TestLess = Pick; // typed as { name: string; }\ntype TestBoth = Pick; // typed as { name: string; age: string; }\n// The Omit utility type ignores the specified properties.type\ntype TestFewer = Omit; // typed as { age: string; }\ntype TestNone = Omit; // typed as {}\n// The Parameters utility type gets the parameters of a function type.\nfunction doSmth(value: string, anotherValue: number): string {\n  return 'test';\n}\ntype Params = Parameters; // typed as [value: string, anotherValue: number]\n// The ReturnType utility type gets the return type of a function type.\ntype Return = ReturnType; // typed as string\n// There are many more, some of which are introduced further down.\n</code></p><p></p><p>●&nbsp;&nbsp;条件类型: 根据某种类型是否匹配 / 扩展另一种类型，来对类型做有条件设置。可以按照 JavaScript 中条件（三元）运算符的方式理解。</p><p></p><p><code lang=\"typescript\">// Only extracts the array type if it is an array, otherwise returns the same type.\ntype Flatten = T extends any[] ? T[number] : T;\n// Extracts out the element type.\ntype Str = Flatten; // typed as string\n// Leaves the type alone.\ntype Num = Flatten; // typed as number\n</code></p><p></p><p>●&nbsp;&nbsp;使用条件类型进行推断: 并非所有泛型类型都需要由用户指定，有些也可以从代码中推断得出。要实现基于类型推断的条件逻辑，必须有 infer 关键字，它会以某种方式定义临时推断类型变量。</p><p></p><p><code lang=\"typescript\">// Starting with the previous example, this can be written more cleanly.\ntype FlattenOld = T extends any[] ? T[number] : T;\n// Instead of indexing the array, we can just infer the Item type from the array.\ntype Flatten = T extends (infer Item)[] ? Item : T;\n// If we wanted to write a type that gets the return type of a function and otherwise is undefined, we could also infer that.\ntype GetReturnType = Type extends (...args: any[]) =&gt; infer Return ? Return : undefined;\ntype Num = GetReturnType&lt;() =&gt; number&gt;; // typed as number\ntype Str = GetReturnType&lt;(x: string) =&gt; string&gt;; // typed as string\ntype Bools = GetReturnType&lt;(a: boolean, b: boolean) =&gt; void&gt;; // typed as undefined\n</code></p><p></p><p>●&nbsp;&nbsp;元组可选元素与其余元素: 使用 ? 声明元组中的可选元素，使用 … 声明元组中的其余元素。</p><p></p><p><code lang=\"typescript\">// If we don't yet know how long a tuple is going to be, but it's at least one, we can specify optional types using `?`.\nconst list: [number, number?, boolean?] = [];\nlist[0] // typed as number\nlist[1] // typed as number | undefined\nlist[2] // typed as boolean | undefined\nlist[3] // Type error: Tuple type '[number, (number | undefined)?, (boolean | undefined)?]' of length '3' has no element at index '3'.\n// We could also base the tuple on an existing type.\n// If we want to pad an array at the start, we could do that using the rest operator `...`.\nfunction padStart(arr: T, pad: string): [string, ...T] {\n  return [pad, ...arr];\n}\nconst padded = padStart([1, 2], 'test'); // typed as [string, number, number]\n</code></p><p></p><p>●&nbsp;&nbsp;抽象类和方法: 类和类中的各方法可以被声明为 abstract，以防止其被实例化。</p><p></p><p><code lang=\"java\">abstract class Animal {\n  abstract makeSound(): void;\n  move(): void {\n    console.log('roaming the earth...');\n  }\n}\n// Abstract methods need to be implemented when extended.\nclass Cat extends Animal {} // Compile error: Non-abstract class 'Cat' does not implement inherited abstract member 'makeSound' from class 'Animal'.\nclass Dog extends Animal {\n  makeSound() {\n    console.log('woof');\n  }\n}\n// Abstract classes cannot be instantiated (like Interfaces), and abstract methods cannot be called.\nnew Animal(); // Compile error: Cannot create an instance of an abstract class.\nconst dog = new Dog().makeSound(); // \"woof\"\n</code></p><p></p><p>●&nbsp;&nbsp;构造函数签名: 在类声明之外，定义构造函数的类型。在大多数情况下不应使用，建议用抽象类代替。</p><p></p><p><code lang=\"typescript\">interface MyInterface {\n  name: string;\n}\ninterface ConstructsMyInterface {\n  new(name: string): MyInterface;\n}\nclass Test implements MyInterface {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\nclass AnotherTest {\n  age: number;\n}\nfunction makeObj(n: ConstructsMyInterface) {\n    return new n('hello!');\n}\nconst obj = makeObj(Test); // typed as Test\nconst anotherObj = makeObj(AnotherTest); // Type error: Argument of type 'typeof AnotherTest' is not assignable to parameter of type 'ConstructsMyInterface'.\n</code></p><p></p><p>●&nbsp;&nbsp;ConstructorParameters Utility 类型: 属于 TypeScript 辅助函数，能够根据构造函数类型（但不是类）获取构造函数参数。</p><p></p><p><code lang=\"typescript\">// What if we wanted to get the constructor argument for our makeObj function.\ninterface MyInterface {\n  name: string;\n}\ninterface ConstructsMyInterface {\n  new(name: string): MyInterface;\n}\nclass Test implements MyInterface {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\nfunction makeObj(test: ConstructsMyInterface, ...args: ConstructorParameters) {\n  return new test(...args);\n}\nmakeObj(Test); // Type error: Expected 2 arguments, but got 1.\nconst obj = makeObj(Test, 'test'); // typed as Test\n</code></p><p></p><p></p><h3>TypeScript 4.0</h3><p></p><p></p><p>●&nbsp;&nbsp;可变元组类型: 元组中的其余元素现在是通用的，且允许使用多个其余元素。</p><p></p><p><code lang=\"typescript\">// What if we had a function that combines two tuples of undefined length and types? How can we define the return type?\n// PREVIOUSLY:\n// We could write some overloads.\ndeclare function concat(arr1: [], arr2: []): [];\ndeclare function concat<a>(arr1: [A], arr2: []): [A];\ndeclare function concat<a>(arr1: [A], arr2: [B]): [A, B];\ndeclare function concat<a>(arr1: [A], arr2: [B, C]): [A, B, C];\ndeclare function concat<a>(arr1: [A], arr2: [B, C, D]): [A, B, C, D];\ndeclare function concat<a>(arr1: [A, B], arr2: []): [A, B];\ndeclare function concat<a>(arr1: [A, B], arr2: [C]): [A, B, C];\ndeclare function concat<a>(arr1: [A, B], arr2: [C, D]): [A, B, C, D];\ndeclare function concat<a>(arr1: [A, B], arr2: [C, D, E]): [A, B, C, D, E];\ndeclare function concat<a>(arr1: [A, B, C], arr2: []): [A, B, C];\ndeclare function concat<a>(arr1: [A, B, C], arr2: [D]): [A, B, C, D];\ndeclare function concat<a>(arr1: [A, B, C], arr2: [D, E]): [A, B, C, D, E];\ndeclare function concat<a>(arr1: [A, B, C], arr2: [D, E, F]): [A, B, C, D, E, F];\n// Even just for three items each, this is really suboptimal.\n// Instead we could combine the types.\ndeclare function concatBetter(arr1: T[], arr2: U[]): (T | U)[];\n// But this types to (T | U)[]\n// NEW:\n// With variadic tuple types, we can define it easily and keep the information about the length.\ndeclare function concatNew(arr1: T, arr2: U): [...T, ...U];\nconst tuple = concatNew([23, 'hey', false] as [number, string, boolean], [5, 99, 20] as [number, number, number]);\nconsole.log(tuple[0]); // 23\nconst element: number = tuple[1]; // Type error: Type 'string' is not assignable to type 'number'.\nconsole.log(tuple[6]); // Type error: Tuple type '[23, \"hey\", false, 5, 99, 20]' of length '6' has no element at index '6'.\n</a></code></p><p></p><p><a>●&nbsp;&nbsp;标记元组元素: 元组元素现可被命名为 [start: number, end: number] 的形式。如果命名其中一个元素，则所有元素必须均被命名。</a></p><p></p><p><a><code lang=\"typescript\">type Foo = [first: number, second?: string, ...rest: any[]];\n// This allows the arguments to be named correctly here, it also shows up in the editor.\ndeclare function someFunc(...args: Foo);\n</code></a></p><p></p><p><a>●&nbsp;&nbsp;从构造函数推断类属性: 在构造函数中设置属性时，现可推断其类型，不再需要手动设置。</a></p><p></p><p><a><code lang=\"typescript\">class Animal {\n// No need to set types when they are assigned in the constructor.\nname;\nconstructor(name: string) {\nthis.name = name;\nconsole.log(this.name); // typed as string\n}\n}\n</code></a></p><p></p><p><a>●JSDoc @deprecated 支持: TypeScript 现可识别 JSDoc/TSDoc @deprecated 标签。</a></p><p></p><p><a><code lang=\"typescript\">/** @deprecated message */\ntype Test = string;\nconst test: Test = 'dfadsf'; // Type error: 'Test' is deprecated.\n</code></a></p><p></p><p></p><h3><a>TypeScript 4.1</a></h3><p></p><p></p><p><a>●&nbsp;&nbsp;模板字面量类型: 在定义字面量类型时，可以通过 ${Type}等模板指定类型。这样可以构造复杂的字符串类型，例如将多个字符串字面量组合起来。</a></p><p></p><p><a><code lang=\"typescript\">type VerticalDirection = 'top' | 'bottom';\ntype HorizontalDirection = 'left' | 'right';\ntype Direction = `${VerticalDirection} ${HorizontalDirection}`;\nconst dir1: Direction = 'top left';\nconst dir2: Direction = 'left'; // Type error: Type '\"left\"' is not assignable to type '\"top left\" | \"top right\" | \"bottom left\" | \"bottom right\"'.\nconst dir3: Direction = 'left top'; // Type error: Type '\"left top\"' is not assignable to type '\"top left\" | \"top right\" | \"bottom left\" | \"bottom right\"'.\n// This can also be combined with generics and the new utility types.\ndeclare function makeId(first: T, second: U): `${Capitalize}-${Lowercase<u>}`;\n</u></code></a></p><p></p><p><a><u>●&nbsp;&nbsp;在映射类型中重新映射键: 为已映射的类型重新分配类型，但仍使用其值，例如 [K in keyof T as NewKeyType]: T[K]。</u></a></p><p></p><p><a><u><code lang=\"typescript\">// Let's say we wanted to reformat an object but prepend its IDs with an underscore.\nconst obj = { value1: 0, value2: 1, value3: 3 };\nconst newObj: { [Property in keyof typeof obj as `_${Property}`]: number }; // typed as { _value1: number; _value2: number; value3: number; }\n</code></u></a></p><p></p><p><a><u>●&nbsp;&nbsp;递归条件类型: 在定义之内使用条件类型，这种类型允许以有条件方式解包无限嵌套值。</u></a></p><p></p><p><a><u><code lang=\"typescript\">type Awaited = T extends PromiseLike ? Awaited<u> : T;\ntype P1 = Awaited; // typed as string\ntype P2 = Awaited&gt;; // typed as string\ntype P3 = Awaited&gt;&gt;; // typed as string\n</u></code></u></a></p><p></p><p><a><u><u>●&nbsp;&nbsp;JSDOC @see 标签的编辑器支持: JSDoc/TSDoc @see variable/type/link 标签现可在编辑器中受到支持。</u></u></a></p><p></p><p><a><u><u><code lang=\"cs\">const originalValue = 1;\n/**\n* Copy of another value\n* @see originalValue\n*/\nconst value = originalValue;\n</code></u></u></a></p><p></p><p><a><u><u>●&nbsp;&nbsp;tsc — explainFiles: &nbsp;--explainFiles 选项可被 TypeScript CLI 用于解释哪些文件是编译的一部分、为什么会这样。这一点对于调试非常重要。警告：对于大型项目或较为复杂的设置，这会生成大量输出，建议改用 tsc --explainFiles | less 或其他类似功能。</u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">tsc --explainFiles\n&lt;<output><=\"\" code=\"\"></output></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;解构变量可被显式标记为未使用: 在解构时，可使用下划线将变量标记为未使用，从而防止 TypeScript 抛出“未使用的变量”错误。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"javascript\">const [_first, second] = [3, 5];\nconsole.log(second);\n// Or even shorter\nconst [_, value] = [3, 5];\nconsole.log(value);\n</code></code></u></u></a></p><p></p><p></p><h3><a><u><u><code lang=\"javascript\">TypeScript 4.3</code></u></u></a></h3><p></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;属性上的单独写入类型: 在定义 set/get 访问器时，write/set 类型现可不同于 read/get 类型。意味着设置器能够接受相同值的多种格式。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">class Test {\nprivate _value: number;\nget value(): number {\nreturn this._value;\n}\nset value(value: number | string) {\nif (typeof value === 'number') {\nthis._value = value;\nreturn;\n}\nthis._value = parseInt(value, 10);\n}\n}\n</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;override: 使用 override，会将继承的类方法显式标记为覆写。因此当父类发生变化时，TypeScript 会提醒父方法已不存在，从而实现更安全的复杂继承模式。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">class Parent {\ngetName(): string {\nreturn 'name';\n}\n}\nclass NewParent {\ngetFirstName(): string {\nreturn 'name';\n}\n}\nclass Test extends Parent {\noverride getName(): string {\nreturn 'test';\n}\n}\nclass NewTest extends NewParent {\noverride getName(): string { // Type error: This member cannot have an 'override' modifier because it is not declared in the base class 'NewParent'.\nreturn 'test';\n}\n}\n</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;静态索引签名: 在类上使用静态属性时，现在也可以使用 static [propName: string]: string 设置索引签名。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">// PREVIOUSLY:\nclass Test {}\nTest.test = ''; // Type error: Property 'test' does not exist on type 'typeof Test'.\n// NEW:\nclass NewTest {\nstatic [key: string]: string;\n}\nNewTest.test = '';\n</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">●对JSDOC@link标签提供编辑器支持: JSDoc/TSDoc {@link variable/type/link} 内联标签现可在编辑器中显示和解析。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">const originalValue = 1;\n/**\n* Copy of {@link originalValue}\n*/\nconst value = originalValue;\n</code></code></u></u></a></p><p></p><p></p><h3><a><u><u><code lang=\"javascript\">TypeScript 4.4</code></u></u></a></h3><p></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;精确的可选属性类型 ( — exactOptionalPropertyTypes): 使用编译器标志 --exactOptionalPropertyTypes 时（或在 tsconfig.json 中），隐式允许 undefined（例如 property?: string）的属性将不允许被分配为 undefined。相反，undefined 必须经过明确许可，例如 property: string | undefined。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"typescript\">class Test {\nname?: string;\nage: number | undefined;\n}\nconst test = new Test();\ntest.name = 'test'; // Type error: Option 'exactOptionalPropertyTypes' cannot be specified without specifying option 'strictNullChecks'.\ntest.age = 0;\n</code></code></u></u></a></p><p></p><p></p><h3><a><u><u><code lang=\"javascript\">TypeScript 4.5</code></u></u></a></h3><p></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;Awaited 类型与 Promise 改进: 新的 Awaited&lt;&gt;实用程序类型能从无限嵌套的 Promises 中提取值类型（类似于 await 对该值的操作）。这也改进了 Promise.all() 的类型推断。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"typescript\">// Let's say we want to have a generic awaited value.\n// We can use the Awaited utility type for this (its source code was part of a previous example),\n// so infinitely nested Promises all resolve to their value.\ntype P1 = Awaited; // typed as string\ntype P2 = Awaited&gt;; // typed as string\ntype P3 = Awaited&gt;&gt;; // typed as string\n</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;导入名称上的类型修饰符: 在普通（非 import type）导入语句中，关键字 type 可用于表示该值只应在类型编译时导入（且可以去除）。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"typescript\">// PREVIOUSLY:\n// The optimal way to import types is to use the `import type` keyword to prevent them from actually being imported after compilation.\nimport { something } from './file';\nimport type { SomeType } from './file';\n// This needs two import statements for the same file.\n// NEW:\n// Now this can be combined into one statement.\nimport { something, type SomeType } from './file';\n</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;const 断言: 在将常量定义为 as const 时，即可将其准确归类为字面量类型。这项功能有多种用例，可以轻松进行准确分类。此功能还会令对象和数组成为 readonly，防止常量对象发生突变。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"typescript\">// PREVIOUSLY:\n// The optimal way to import types is to use the `import type` keyword to prevent them from actually being imported after compilation.\nimport { something } from './file';\nimport type { SomeType } from './file';\n// This needs two import statements for the same file.\n// NEW:\n// Now this can be combined into one statement.\nimport { something, type SomeType } from './file';\n</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;类中各方法的片段补全: 当一个类继承多个方法类型时，编辑器现可为各类型提供建议片段。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><img src=\"https://static001.geekbang.org/wechat/images/df/df5368d7cf6f2edd8a771e40cbf2218a.gif\" /></code></u></u></a></p><p></p><p></p><h3><a><u><u><code lang=\"javascript\">TypeScript 4.6</code></u></u></a></h3><p></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;索引访问推断改进：当直接在键内直接索引一个类型时，如果该类型位于同一对象上，现在其准确率会更高。这也是 TypeScript 现代化特性的良好体现。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"typescript\">interface AllowedTypes {\n'number': number;\n'string': string;\n'boolean': boolean;\n}\n// The Record specifies the kind and value type from the allowed types.\ntype UnionRecord = { [Key in AllowedKeys]:\n{\nkind: Key;\nvalue: AllowedTypes[Key];\nlogValue: (value: AllowedTypes[Key]) =&gt; void;\n}\n}[AllowedKeys];\n// The function logValue only accepts the value of the Record.\nfunction processRecord(record: UnionRecord) {\nrecord.logValue(record.value);\n}\nprocessRecord({\nkind: 'string',\nvalue: 'hello!',\n// The value used to implicitly have the type string | number | boolean,\n// but now is correctly inferred to just string.\nlogValue: value =&gt; {\nconsole.log(value.toUpperCase());\n}\n});\n</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">●&nbsp;&nbsp;TypeScript Trace Analyzer ( — generateTrace): &nbsp;--generateTrace</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\">选项可在 TypeScript CLI 当中用于生成一个文件，其中包含关于类型检查和编译过程的详情信息。这有助于优化复杂类型。</code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">tsc --generateTrace trace\ncat trace/trace.json\n&lt;<output><<output><=\"\" code=\"\"></output></code></code></u></u></a></p><p></p><p></p><h3><a><u><u><code lang=\"javascript\"><code lang=\"cs\">TypeScript 4.7</code></code></u></u></a></h3><p></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;在 Node.js 中支持 ECMAScript 模块: 在使用 ES Modules 替代 CommonJS 时，TypeScript 现可支持指定默认值。具体指定在 tsconfig.json 中实现。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><code lang=\"javascript\">...\n\"compilerOptions\": [\n...\n\"module\": \"es2020\"\n]\n...\n</code></code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;package.json 中的类型: &nbsp;package.json 中的 type 字段可被设定为\"module\"，以供 ES Modules 使用 node.js。在大多数情况下，这种方式对 TypeScript 已经足够，不需要前面提到的编译器选项。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><code lang=\"javascript\">...\n\"type\": \"module\"\n...\n</code></code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;实例化表达式: 实例化表达式允许在引用一个值时，指定类型参数。这样可以在不创建包装器的前提下，收窄泛型类型。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><code lang=\"php\">class List {\nprivate list: T[] = [];\nget(key: number): T {\nreturn this.list[key];\n}\npush(value: T): void {\nthis.list.push(value);\n}\n}\nfunction makeList(items: T[]): List {\nconst list = new List();\nitems.forEach(item =&gt; list.push(item));\nreturn list;\n}\n// Let's say we want to have a function that creates a list but only allows certain values.\n// PREVIOUSLY:\n// We need to manually define a wrapper function and pass the argument.\nfunction makeStringList(text: string[]) {\nreturn makeList(text);\n}\n// NEW:\n// Using instantiation expressions, this is much easier.\nconst makeNumberList = makeList;\n</code></code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;扩展对推断类型变量的约束: 在条件类型中推断类型变量时，现在可以使用 extends 直接将其收窄 / 约束。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><code lang=\"typescript\">// Let's say we want to type a type that only gets the first element of an array if it's a string.\n// We can use conditional types for this.\n// PREVIOUSLY:\ntype FirstIfStringOld =\nT extends [infer S, ...unknown[]]\n? S extends string ? S : never\n: never;\n// But this needs two nested conditional types. We can also do it in one.\ntype FirstIfString =\nT extends [string, ...unknown[]]\n// Grab the first type out of `T`\n? T[0]\n: never;\n// This is still suboptimal because we need to index the array for the correct type.\n// NEW:\n// Using extends Constraints on infer Type Variables, this can be declared a lot easier.\ntype FirstIfStringNew =\nT extends [infer S extends string, ...unknown[]]\n? S\n: never;\n// Note that the typing worked the same before, this is just a cleaner syntax.\ntype A = FirstIfStringNew&lt;[string, number, number]&gt;; // typed as string\ntype B = FirstIfStringNew&lt;[\"hello\", number, number]&gt;; // typed as \"hello\"\ntype C = FirstIfStringNew&lt;[\"hello\" | \"world\", boolean]&gt;; // typed as \"hello\" | \"world\"\ntype D = FirstIfStringNew&lt;[boolean, number, string]&gt;; // typed as never\n</code></code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;类型参数的可选变体注释: 泛型在检查是否“匹配”时可以有不同行为，例如对 getter 和 setter，对是否允许继承的判断是相反的。为了明确起见，现在用户可以明确指定。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><code lang=\"javascript\">// Let's say we have an interface / a class that extends another one.\ninterface Animal {\nanimalStuff: any;\n}\ninterface Dog extends Animal {\ndogStuff: any;\n}\n// And we have some generic \"getter\" and \"setter\".\ntype Getter = () =&gt; T;\ntype Setter = (value: T) =&gt; void;\n// If we want to find out if Getter matches Getter or Setter matches Setter, this depends on the covariance.\nfunction useAnimalGetter(getter: Getter) {\ngetter();\n}\n// Now we can pass a Getter into the function.\nuseAnimalGetter((() =&gt; ({ animalStuff: 0 }) as Animal));\n// This obviously works.\n// But what if we want to use a Getter which returns a Dog instead?\nuseAnimalGetter((() =&gt; ({ animalStuff: 0, dogStuff: 0 }) as Dog));\n// This works as well because a Dog is also an Animal.\nfunction useDogGetter(getter: Getter) {\ngetter();\n}\n// If we try the same for the useDogGetter function we will not get the same behavior.\nuseDogGetter((() =&gt; ({ animalStuff: 0 }) as Animal)); // Type error: Property 'dogStuff' is missing in type 'Animal' but required in type 'Dog'.\n// This does not work, because a Dog is expected, not just an Animal.\nuseDogGetter((() =&gt; ({ animalStuff: 0, dogStuff: 0 }) as Dog));\n// This, however, works.\n// Intuitively we would maybe expect the Setters to behave the same, but they don't.\nfunction setAnimalSetter(setter: Setter, value: Animal) {\nsetter(value);\n}\n// If we pass a Setter of the same type it still works.\nsetAnimalSetter((value: Animal) =&gt; {}, { animalStuff: 0 });\nfunction setDogSetter(setter: Setter, value: Dog) {\nsetter(value);\n}\n// Same here.\nsetDogSetter((value: Dog) =&gt; {}, { animalStuff: 0, dogStuff: 0 });\n// But if we pass a Dog Setter into the setAnimalSetter function, the behavior is reversed from the Getters.\nsetAnimalSetter((value: Dog) =&gt; {}, { animalStuff: 0, dogStuff: 0 }); // Type error: Argument of type '(value: Dog) =&gt; void' is not assignable to parameter of type 'Setter'.\n// This time it works the other way around.\nsetDogSetter((value: Animal) =&gt; {}, { animalStuff: 0, dogStuff: 0 });\n// NEW:\n// To signal this to TypeScript (not needed but helpful for readability), use the new Optional Variance Annotations for Type Parameters.\ntype GetterNew = () =&gt; T;\ntype SetterNew = (value: T) =&gt; void;\n</code></code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;使用 moduleSuffixes 实现分辨率自定义: 在使用具有自定义文件后缀的环境时（例如，.ios 用于原生应用构建），现在您可以为 TypeScript 指定这些后缀以正确对导入进行解析。具体指定在 tsconfig.json 中实现。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><code lang=\"python\">...\n\"compilerOptions\": [\n...\n\"module\": [\".ios\", \".native\", \"\"]\n]\n...\nimport * as foo from './foo';\n// This first checks ./foo.ios.ts, ./foo.native.ts, and finally ./foo.ts.\n</code></code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;在编辑器内转到源定义: 在编辑器中，开放新的“转到源定义”菜单项。其功能类似于“转到定义”，但更多指向.ts 和 .js 文件，而非类型定义 (.d.ts)。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><img src=\"https://static001.geekbang.org/wechat/images/cb/cb8e6717c99bfa77c1b952143edeca25.gif\" /></code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><img src=\"https://static001.geekbang.org/wechat/images/aa/aafcc6a9f17ce3871708f31e0eb83f21.gif\" /></code></code></u></u></a></p><p></p><p></p><h3><a><u><u><code lang=\"javascript\"><code lang=\"cs\">TypeScript 4.9</code></code></u></u></a></h3><p></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;satisfies 运算符: satisfies 运算符允许检查与类型间的兼容性，且无需实际分配该类型。这样可以在保持兼容性的同时，获得更准确的类型推断。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><code lang=\"typescript\">// PREVIOUSLY:\n// Let's say we have an object/map/dictionary which stores various items and their colors.\nconst obj = {\nfireTruck: [255, 0, 0],\nbush: '#00ff00',\nocean: [0, 0, 255]\n} // typed as { fireTruck: number[]; bush: string; ocean: number[]; }\n// This implicitly types the properties so we can operate on the arrays and the string.\nconst rgb1 = obj.fireTruck[0]; // typed as number\nconst hex = obj.bush; // typed as string\n// Let's say we only want to allow certain objects.\n// We could use a Record type.\nconst oldObj: Record = {\nfireTruck: [255, 0, 0],\nbush: '#00ff00',\nocean: [0, 0, 255]\n} // typed as Record\n// But now we lose the typings of the properties.\nconst oldRgb1 = oldObj.fireTruck[0]; // typed as string | number\nconst oldHex = oldObj.bush; // typed as string | number\n// NEW:\n// With the satisfies keyword we can check compatibility with a type without actually assigning it.\nconst newObj = {\nfireTruck: [255, 0, 0],\nbush: '#00ff00',\nocean: [0, 0, 255]\n} satisfies Record // typed as { fireTruck: [number, number, number]; bush: string; ocean: [number, number, number]; }\n// And we still have the typings of the properties, the array even got more accurate by becoming a tuple.\nconst newRgb1 = newObj.fireTruck[0]; // typed as number\nconst newRgb4 = newObj.fireTruck[3]; // Type error: Tuple type '[number, number, number]' of length '3' has no element at index '3'.\nconst newHex = newObj.bush; // typed as string\n</code></code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\">●&nbsp;&nbsp;编辑器中的“删除未使用的导入”与“排序导入”命令: 在编辑器中，新命令（及自动修复）“删除未使用的导入”和“排序导入”让导入管理更加轻松易行。</code></code></u></u></a></p><p></p><p><a><u><u><code lang=\"javascript\"><code lang=\"cs\"><img src=\"https://static001.geekbang.org/wechat/images/cf/cf9486e812b0cf2c6b1bab06ece29c8b.gif\" /></code></code></u></u></a></p><p></p><p></p><h5><a><u><u><code lang=\"javascript\"><code lang=\"cs\">原文链接：</code></code></u></u></a></h5><p></p><p><u><u><code lang=\"javascript\"><code lang=\"cs\"><a href=\"https://medium.com/@LinusSchlumberger/all-javascript-and-typescript-features-of-the-last-3-years-629c57e73e42\">https://medium.com/@LinusSchlumberger/all-javascript-and-typescript-features-of-the-last-3-years-629c57e73e42</a>\"</code></code></u></u></p><p></p><p></p><h5><u><u><code lang=\"javascript\"><code lang=\"cs\">相关阅读：</code></code></u></u></h5><p></p><p><u><u><code lang=\"javascript\"><code lang=\"cs\"><a href=\"https://xie.infoq.cn/article/6ff79700fb3bfa972c1beebf3\">TypeScript 与 JavaScript：你应该知道的区别</a>\"</code></code></u></u></p><p><u><u><code lang=\"javascript\"><code lang=\"cs\"><a href=\"https://www.infoq.cn/article/CBb3RhvCHflT42ppOLkR\">JavaScript 框架太多了？相反，是太少了</a>\"</code></code></u></u></p><p><u><u><code lang=\"javascript\"><code lang=\"cs\"><a href=\"https://xie.infoq.cn/article/e976363d22c7ffd126d9b6eb1\">最佳的 18 个 JAVASCRIPT 前端开发框架和库</a>\"</code></code></u></u></p><p><u><u><code lang=\"javascript\"><code lang=\"cs\"><a href=\"https://www.infoq.cn/article/ds994KySqo868U3e8s4N\">我踩过了 TypeScript 的坑，只想告诉你快来</a>\"</code></code></u></u></p>",
    "publish_time": "2023-04-03 12:34:50",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]