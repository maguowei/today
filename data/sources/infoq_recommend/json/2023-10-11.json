[
  {
    "title": "Java近期新闻：JDK 21、面向JDK 21的GraalVM、Apache Pinot 1.0和Eclipse Epicyro 3.0",
    "url": "https://www.infoq.cn/article/0hhqSZ0mg99KVNwGtzmG",
    "summary": "<p></p><h4>OpenJDK</h4><p></p><p>Oracle的编程语言设计师<a href=\"https://www.linkedin.com/in/dansmithjava/\">Daniel Smith</a>\"提交了<a href=\"https://openjdk.org/jeps/8316779\">值对象存储增强（预览）（Value Object Storage Enhancements (Preview)）</a>\"。在Valhalla项目下，该JEP在字段和数组组件中引入了值对象的空限制（null-restricted）存储。 “这些变量被初始化为类的初始实例，并拒绝写入空值。它们可以通过紧凑、扁平化的对象编码进行优化”。&nbsp;</p><p></p><p></p><h4>JDK 21</h4><p></p><p>Oracle<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-September/008267.html\">发布了</a>\"Java编程语言和虚拟机的<a href=\"https://jdk.java.net/21\">21</a>\"版本，其中包括15个JEP的最终特性集。关于该版本的更多信息，请参阅InfoQ的<a href=\"https://www.infoq.com/news/2023/09/java21-released/\">新闻报道</a>\"。</p><p></p><p></p><h4>JDK 22</h4><p></p><p>JDK 22早期访问版本的<a href=\"https://github.com/openjdk/jdk/releases/tag/jdk-22%2B16\">Build 16</a>\"发布，该版本是对Build 15的<a href=\"https://github.com/openjdk/jdk/compare/jdk-22%2B15...jdk-22%2B16\">更新</a>\"，包含对各种<a href=\"https://bugs.openjdk.org/issues/?jql=project%20%3D%20JDK%20AND%20fixversion%20%3D%2022%20and%20%22resolved%20in%20build%22%20%3D%20b16%20order%20by%20component%2C%20subcomponent\">问题</a>\"的修复。有关该版本的更多详情，请参阅<a href=\"https://jdk.java.net/22/release-notes\">发布说明</a>\"。</p><p>&nbsp;</p><p>Oracle的Java平台组的首席架构师<a href=\"https://www.linkedin.com/in/markreinhold\">Mark Reinhold</a>\"对<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-September/008256.html\">提议</a>\"的JDK 22发布计划没有异议，并<a href=\"https://mail.openjdk.org/pipermail/jdk-dev/2023-September/008269.html\">宣布了</a>\"如下的最终发布计划：</p><p>Rampdown第一阶段（fork主线）：2023年12月7日Rampdown第二阶段：2024年1月18日初始候选版本：2024年2月8日最终候选版本：2024年2月22正式发布：2024年3月19日</p><p>&nbsp;</p><p>对于<a href=\"https://openjdk.org/projects/jdk/22/\">JDK 22</a>\"，鼓励开发人员通过<a href=\"https://bugreport.java.com/bugreport/\">Java缺陷数据库</a>\"报告缺陷。</p><p></p><p></p><h4>GraalVM</h4><p></p><p>在发布<a href=\"https://www.infoq.com/news/2023/09/java21-released/\">JDK 21</a>\"的同时，Oracle Labs还发布了面向JDK 21的GraalVM。新特性包括：完全支持JDK 21；通过Profile-Guided Optimizations增强了性能；采用了新的应用程序级别的策略加快了编译时间；通过新的CLI选项--parallelism和--color改善了开发人员的体验，这两个选项分别用来在构建时指定线程数和输出颜色。关于该版本的更多详情，请参阅<a href=\"https://github.com/graalvm/graalvm-ce-builds/releases/tag/jdk-21.0.0\">发布说明</a>\"。InfoQ后续将会发布更详细的新闻报道。</p><p>&nbsp;</p><p>在通往1.0版本的过程中，Oracle Labs发布了<a href=\"https://github.com/graalvm/native-build-tools/blob/master/README.md\">Native Build Tools</a>\"的<a href=\"https://github.com/graalvm/native-build-tools/releases/tag/0.9.27\">0.9.27</a>\"版本，这是一个由插件组成的GraalVM项目，用于实现与GraalVM Native Image的互操作性。这个最新版本为面向JDK 21的GraalVM 提供了错误修复和功能增强。有关此版本的更多详情，请参阅<a href=\"https://github.com/graalvm/native-build-tools/compare/0.9.26...0.9.27\">变更日志</a>\"。&nbsp;</p><p></p><p></p><h4>Amazon Corretto</h4><p></p><p>亚马逊云科技<a href=\"https://aws.amazon.com/about-aws/whats-new/2023/09/amazon-corretto-21-generally-available/\">发布了</a>\"&nbsp;Amazon Corretto 21，这是他们的OpenJDK 21的下游发行版，可以在Linux、Windows和macOS上使用。开发人员可以在该<a href=\"https://docs.aws.amazon.com/corretto/latest/corretto-21-ug/downloads-list.html\">站点</a>\"下载这一最新版本。</p><p></p><p></p><h4>BellSoft Liberica JDK</h4><p></p><p>同样，BellSoft也<a href=\"https://bell-sw.com/blog/liberica-jdk-21-lts-release-a-lasting-foundation-for-your-java-application/\">发布了</a>\"Liberica JDK 21，这是他们的OpenJDK 21的下游发行版。开发人员可以在该<a href=\"https://bell-sw.com/pages/downloads/#/java-21-current\">站点</a>\"下载这一最新版本。</p><p></p><p></p><h4>Spring Framework</h4><p></p><p><a href=\"https://spring.io/projects/spring-boot\">Spring Boot&nbsp;</a>\"3.2.0的第三个里程碑版本提供了缺陷修复、依赖关系升级和新特性，比如，在Spring for Apache Pulsar的配置中添加了ConnectionDetails接口和@ServiceConnection注解；提供RestClientBuilderConfigurer类的实例，以便于将Spring Boot的默认配置应用于自定义的RestClient.Builder接口；移除对WebFlux插装（instrumentation）的已废弃&nbsp;ServerHttpObservationFilter类的使用。关于该版本的更多详情，请参阅<a href=\"https://github.com/spring-projects/spring-boot/releases/tag/v3.2.0-M3\">发布说明</a>\"。</p><p>&nbsp;</p><p>同样，Spring Boot的<a href=\"https://spring.io/blog/2023/09/21/spring-boot-3-1-4-available-now\">3.1.4</a>\"、<a href=\"https://spring.io/blog/2023/09/21/spring-boot-3-0-11-available-now\">3.0.11</a>\"和<a href=\"https://spring.io/blog/2023/09/21/spring-boot-2-7-16-available-now\">2.7.16</a>\"版本也对文档进行了更新和依赖性升级，为JavaVersion枚举类增加了TWENTY_ONE枚举常量，并修复了一些值得注意的缺陷，例如，在使用metadata-url查询时，Saml2RelyingPartyAutoConfiguration类会忽略在sign-request属性中设置的值；DomainSocket类中的文件描述符和套接字泄露；在使用WelcomePageHandlerMapping类的时候，无效的Accept请求HTTP头信息会产生HTTP 500&nbsp;<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500\">Internal Server Error</a>\"。关于这些版本的更多详情，请参阅<a href=\"https://github.com/spring-projects/spring-boot/releases/tag/v3.1.4\">3.1.4版本</a>\"、<a href=\"https://github.com/spring-projects/spring-boot/releases/tag/v3.0.11\">3.0.11版本</a>\"和<a href=\"https://github.com/spring-projects/spring-boot/releases/tag/v2.7.16\">2.7.16版本</a>\"的发布说明。</p><p>&nbsp;</p><p><a href=\"https://spring.io/projects/spring-integration\">Spring Integration</a>\"&nbsp;6.2.0的<a href=\"https://spring.io/blog/2023/09/20/spring-integration-6-2-0-milestone-3-available\">第三个里程碑版本</a>\"包含了依赖性升级和值得关注的变更，例如，重构KafkaMessageDrivenChannelAdapter类，便于将来的维护，以避免代码重复；为LockRegistry接口添加新的重载executeLocked()方法，以遵循最佳实践以及JdbcTemplate、RestTemplate和JmsTemplate类中人们所熟知的模式；支持DefaultSftpSessionFactory类的自定义实例。有关该版本的更多详情，请参阅<a href=\"https://github.com/spring-projects/spring-integration/releases/tag/v6.2.0-M3\">发布说明</a>\"。</p><p>&nbsp;</p><p><a href=\"https://spring.io/projects/spring-batch\">Spring Batch</a>\"&nbsp;5.1.0的<a href=\"https://spring.io/blog/2023/09/20/spring-batch-5-1-0-m3-available-now\">第三个里程碑版本</a>\"提供了缺陷修复、文档改进和新特性，比如，使用@EnableBatchProcessing注解和DefaultBatchConfiguration自动配置JobRegistryBeanPostProcessor类，以改进JobRegistry接口的job注册；通过@EnableBatchProcessing注解中的新参数指定数据库类型；在JdbcJobInstanceDao类中提供自定义JobKeyGenerator接口。有关该版本的更多详情，请参阅<a href=\"https://github.com/spring-projects/spring-batch/releases/tag/v5.1.0-M3\">发布说明</a>\"。</p><p>&nbsp;</p><p><a href=\"https://spring.io/projects/spring-cloud-dataflow\">Spring Cloud Dataflow</a>\"&nbsp;2.11.0的<a href=\"https://spring.io/blog/2023/09/21/spring-cloud-dataflow-2-11-0-released\">发布</a>\"提供了缺陷修复、依赖性升级并支持基于Spring Boot 3.x的流式应用、基于Spring Cloud Task 3.x的任务应用以及基于Spring Batch 5.x的批处理应用。此外，还升级了Kubernetes&nbsp;batch/v1&nbsp;cron job，这样开发人员就可以使用Kubernetes 1.25.0及以上版本。关于该版本的更多详情，请参阅<a href=\"https://github.com/spring-cloud/spring-cloud-dataflow/releases/tag/v2.11.0\">发布说明</a>\"。</p><p>&nbsp;</p><p><a href=\"https://spring.io/projects/spring-security\">Spring Security</a>\"的6.2.0-M1、6.1.4、6.0.7和5.8.7版本<a href=\"https://spring.io/blog/2023/09/18/spring-security-5-8-7-6-0-7-6-1-4-6-2-0-m1-released-including-fixes-for-cve\">发布</a>\"，修复了CVE-2023-34042，<a href=\"https://spring.io/security/cve-2023-34042\">对spring-security.xsd错误的授权（Incorrect Permission Assignment for spring-security.xsd）</a>\"，在该漏洞中，spring-security-config&nbsp;JAR压缩包中的spring-security.xsd文件是随意可写的，这可能会导致漏洞。建议开发人员升级到这些版本。有关这些版本的更多信息，请参阅<a href=\"https://github.com/spring-projects/spring-security/releases/tag/6.2.0-M3\">6.2.0-M1版本</a>\"、<a href=\"https://github.com/spring-projects/spring-security/releases/tag/6.1.4\">6.1.4版本</a>\"、<a href=\"https://github.com/spring-projects/spring-security/releases/tag/6.0.7\">6.0.7版本</a>\"和<a href=\"https://github.com/spring-projects/spring-security/releases/tag/5.8.7\">5.8.7版本</a>\"的发布说明。</p><p>&nbsp;</p><p><a href=\"https://spring.io/projects/spring-graphql\">Spring for GraphQL</a>\"的1.2.3、1.1.6和1.0.5版本<a href=\"https://spring.io/blog/2023/09/19/spring-for-graphql-1-0-5-1-1-6-1-2-3-released\">发布</a>\"，提供了缺陷修复、文档改进、依赖性升级和新特性，包括使用ConnectionTypeDefinitionConfigurer类访问访问对象类型扩展（以补充对象类型）；当Java&nbsp;Principal接口的实例不存在且未声明为Optional时，会触发Spring Security&nbsp;AuthenticationCredentialsNotFoundException，以要求进行身份验证；增强GraphQL请求体检查以防止出现HTTP 500&nbsp;Internal Server Error。这些版本分别可以与Spring Boot 3.1.4、3.0.11和2.7.16版本协同使用。关于这些版本的更多详情，请参阅<a href=\"https://github.com/spring-projects/spring-graphql/releases/tag/v1.2.3\">1.2.3版本</a>\"、<a href=\"https://github.com/spring-projects/spring-graphql/releases/tag/v1.1.6\">1.1.6版本</a>\"和<a href=\"https://github.com/spring-projects/spring-graphql/releases/tag/v1.0.5\">1.0.5版本</a>\"的发布说明。</p><p>&nbsp;</p><p><a href=\"https://spring.io/projects/spring-authorization-server\">Spring Authorization Server</a>\"&nbsp;1.2.0的第一个<a href=\"https://spring.io/blog/2023/09/19/spring-authorization-server-1-2-0-m1-available-now\">里程碑版本</a>\"包含了缺陷修复、依赖性升级和新特性，例如，注入自定义元数据以改善客户端注册功能；为OIDC提供者配置响应新提供了代码质询方法（code challenge method）；使用CodeVerifierAuthenticator类改善了日志功能。关于该版本的更多详情，请参阅<a href=\"https://github.com/spring-projects/spring-authorization-server/releases/tag/1.2.0-M1\">发布说明</a>\"。</p><p>&nbsp;</p><p><a href=\"https://spring.io/projects/spring-pulsar\">Spring for Apache Pulsar</a>\"&nbsp;1.0.0的<a href=\"https://spring.io/blog/2023/09/18/spring-for-apache-pulsar-1-0-0-m2-available-now\">第二个里程碑版本</a>\"包含了如下值得关注的变更：能够为PulsarAdministration、DefaultPulsarConsumerFactory、DefaultPulsarReaderFactory和DefaultReactivePulsarSenderFactory类添加多个customizer；将缓存提供者模块的源文件从默认的spring.pulsar.core包移至具有特定模块名称的包中，以避免与Java模块系统发生混淆。关于该版本的更多详情，请参阅<a href=\"https://github.com/spring-projects/spring-pulsar/releases/tag/v1.0.0-M2\">发布说明</a>\"。</p><p>&nbsp;</p><p><a href=\"https://spring.io/projects/spring-modulith\">Spring Modulith</a>\"的1.1.0-M1和1.0.1版本<a href=\"https://spring.io/blog/2023/09/21/spring-modulith-1-1-m1-and-1-0-1-released\">发布</a>\"，提供了缺陷修复、文档改善、依赖性升级和新特性，例如，支持通过注册@ApplicationEventListener将领域事件外部化到消息中间件中（Kafka、AMQP、JMS等）；新的Neo4j事件发布仓库；新的CompletedEventPublications、IncompleteEventPublications和EventPublicationRepository接口，用于改善对已完成和未完成事件发布的处理。关于这些版本的更多详情，请参阅<a href=\"https://github.com/spring-projects/spring-modulith/releases/tag/1.1.0-M1\">1.1.0-M1版本</a>\"和<a href=\"https://github.com/spring-projects/spring-modulith/releases/tag/1.0.1\">1.0.1版本</a>\"的发布说明。</p><p>&nbsp;</p><p></p><h4>Quarkus</h4><p></p><p><a href=\"https://quarkus.io/\">Quarkus</a>\"&nbsp;3.4.1发布了对Redis 7.2的支持，以及对<a href=\"https://quarkus.io/guides/flyway\">Flyway</a>\"扩展支持的更改，其中包括：通过将quarkus.flyway.enabled属性设置为false，可以禁用Flyway扩展的自动配置；通过将quarkus.flyway.active和quarkus.flyway..active属性分别设置为false，可以将特定数据源和某个名称的数据源设置为非活跃状态。关于该版本的更多详情，请参阅<a href=\"https://github.com/quarkusio/quarkus/releases/tag/3.4.1\">更新日志</a>\"。</p><p></p><p></p><h4>Open Liberty</h4><p></p><p>IBM<a href=\"https://openliberty.io/blog/2023/09/19/23.0.0.9.html\">发布</a>\"了<a href=\"https://openliberty.io/\">Open Liberty</a>\"&nbsp;23.0.0.9版本，该版本提供了对以下内容的支持：需要Jakarta EE 10的Spring Boot 3.0、Spring Security 6.x以及名为springBoot3的新<a href=\"https://openliberty.io/docs/latest/reference/command/server-create.html#_options\">服务器模板</a>\"；支持使用OpenID Connect令牌端点的私钥JWT认证，以及将LTPA或JWT cookie路径设置为应用程序上下文根的能力，以便于为不同的应用程序提供不同的LTPA和JWT令牌。</p><p></p><p></p><h4>Micronaut</h4><p></p><p>Micronaut基金会<a href=\"https://micronaut.io/2023/09/22/micronaut-framework-4-1-2-released/\">发布</a>\"了<a href=\"https://micronaut.io/\">Micronaut</a>\"的4.1.2版本，其中包括<a href=\"https://github.com/micronaut-projects/micronaut-core/releases/tag/v4.1.6\">Micronaut Core 4.1.6</a>\"以及对<a href=\"https://micronaut-projects.github.io/micronaut-data/latest/guide/\">Micronaut Data</a>\"模块的更新。关于该版本更多的详情，请参阅<a href=\"https://github.com/micronaut-projects/micronaut-platform/releases/tag/v4.1.2\">发布说明</a>\"。</p><p></p><p></p><h4>Hibernate</h4><p></p><p><a href=\"https://hibernate.org/orm/\">Hibernate ORM</a>\"的6.3.1.Final和6.2.9.Final版本发布，其中包含已知缺陷的修正以及查询方法和查找器（finder）方法的改善。关于这些版本的更多详情，请参阅<a href=\"https://hibernate.atlassian.net/issues/?jql=project%20%3D%20HHH%20AND%20fixVersion%20%3D%2032188\">6.3.1.Final版本</a>\"和<a href=\"https://hibernate.atlassian.net/issues/?jql=project%20%3D%20HHH%20AND%20fixVersion%20%3D%2032192\">6.2.9.Final版本</a>\"的发布说明。</p><p></p><p></p><h4>Eclipse基金会</h4><p></p><p>在OmniFishEE<a href=\"https://twitter.com/OmniFishEE/status/1702263849984885156\">推出</a>\"后不久，<a href=\"https://github.com/eclipse-ee4j/epicyro/blob/main/README.md\">Eclipse Epicyro</a>\"&nbsp;3.0作为<a href=\"https://jakarta.ee/specifications/authentication/3.0/\">Jakarta Authentication 3.0</a>\"规范的独立实现正式发布。这个新项目会为认证机制定义一个通用的底层SPI，即与调用者和容器环境交互以获取调用者凭证的控制器，并将经过认证的身份标识（比如名称和组）传递给容器。</p><p>&nbsp;</p><p></p><h4>Apache软件基金会</h4><p></p><p>实时分布式OLAP数据存储<a href=\"https://pinot.apache.org/\">Apache Pinot</a>\"&nbsp;1.0.0版本<a href=\"https://www.mail-archive.com/announce@apache.org/msg08513.html\">发布</a>\"，提供了缺陷修复、功能增强和新特性，例如，在OVER()子句中使用ORDER BY子句实现Window Functions<a href=\"https://docs.pinot.apache.org/users/user-guide-query\">查询</a>\"运行时的初步支持；如果使用LIMIT子句，SortOperator类的执行将提前终止；对基于分区的叶子阶段处理的支持。关于该版本的更多详情，请参阅<a href=\"https://github.com/apache/pinot/releases/tag/release-1.0.0\">发布说明</a>\"。InfoQ将继续跟进，以提供更详细的新闻报道。</p><p>&nbsp;</p><p></p><h4>OpenXava</h4><p></p><p><a href=\"https://openxava.org/\">OpenXava</a>\"&nbsp;7.1.6<a href=\"https://openxava.org/blog/openxava-7.1.6-released\">发布了</a>\"一些值得注意的功能修复，比如，改进了@ElementCollection和@DescriptionsList注解之间的交互；如果列表中包含baseCondition参数和IFilter接口的实例，则使用@Tab注解对列表进行过滤或排序后的分组将会失败；如果应用程序位于代理背后，则IForwardAction接口的实例将无效。关于该版本的更多详情，请参阅<a href=\"https://github.com/openxava/openxava/releases/tag/7.1.6\">发布说明</a>\"。</p><p></p><p></p><h4>Gradle</h4><p></p><p><a href=\"https://gradle.org/\">Gradle</a>\"&nbsp;8.4的第一个<a href=\"https://github.com/gradle/gradle/releases/tag/v8.4.0-RC1\">发布候选版本</a>\"提供了如下功能：鉴于Kotlin尚不支持JDK 21，因此仅在编译、测试和运行Gradle项目时提供了对JDK 21的初步支持；改进了在Windows操作系统上的编译；简化了使用ConfigurationContainer接口创建以角色为中心的Configuration接口实例的方法；改进了对<a href=\"https://docs.gradle.org/8.4-rc-1/userguide/kotlin_dsl.html\">Kotlin DSL</a>\"的支持。关于该版本的更多详情，请参阅<a href=\"https://docs.gradle.org/8.4-rc-1/release-notes.html\">发布说明</a>\"。</p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2023/09/java-news-roundup-sep18-2023/\">Java News Roundup: JDK 21, GraalVM for JDK 21, Apache Pinot 1.0, Eclipse Epicyro 3.0</a>\"</p>",
    "publish_time": "2023-10-11 00:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "KafkaFlow入门指南：构建可扩展的Kafka事件驱动应用",
    "url": "https://www.infoq.cn/article/Fzwavj3qHfpOt0Gk7sU5",
    "summary": "<p>在本文中，我们将会探讨KafkaFlow提供提供的特性。如果你正在使用.NET构建Apache Kafka生产者和消费者，那么本文将会介绍如何借助KafkaFlow来简化你的生活。</p><p></p><h2>为何要关注它？</h2><p></p><p></p><p>KafkaFlow为Confluent .NET Kafka客户端提供了一个抽象层。它使得使用、维护和测试Kafka消费者和生产者均更加容易。</p><p></p><p>假设你要为市场营销活动创建一个客户端目录（Client Catalog）。我们需要一项服务来消费那些捕获新客户端的消息。当开始设计所需的服务时，你会发现现有的服务在如何消费消息方面并不一致。</p><p></p><p>常见的情形是，团队在解决一些简单的问题（如优雅关机）时，往往会陷入困境。你会发现整个组织有四种不同的JSON序列化器实现，这只是挑战之一。</p><p></p><p>采用KafkaFlow这样的框架能够简化流程并加快开发周期。KafkaFlow拥有一系列旨在提升开发人员体验的特性：</p><p></p><p>中间件（Middleware）：KafkaFlow允许开发人员创建中间件来处理消息，从而实现对Kafka生产者/消费者管道的更多控制和定制。处理器（Handler）：引入了处理器的概念，允许开发人员将主题中的消息处理转发给专用消息类型的处理器。反序列化算法（Deserialization Algorithms）：提供了一套开箱即用的序列化和反序列化算法。多线程消费者：提供了保证消息处理顺序的多线程功能，有助于优化系统资源的使用。管理API和仪表盘：提供了API和仪表盘来管理消费者和消费者群组，可以在运行时进行暂停、恢复或倒回偏移。消费者限流：提供了一种简便的方式，为主题的消费提供优先级。接下来，我们探讨一下这些特性，看看它们在解决类似问题方面的潜力。</p><p></p><h2>KafkaFlow生产者：简化消息的生成</h2><p></p><p></p><p>我们从消息的生产者开始。</p><p></p><p>向Kafka中生成消息并不是什么高难的火箭科学。即便如此，KafkaFlow还是为Confluent的.NET Kafka客户端的生产者接口提供了更高级别的抽象，从而能够简化代码并提升可维护性。</p><p></p><p>下面是一个如何使用KafkaFlow生产者发送消息的样例：</p><p></p><p><code lang=\"java\">await _producers[\"my-topic-events\"]\n    .ProduceAsync(\"my-topic\", message.Id.ToString(), message);\n</code></p><p></p><p>这样，我们就可以向Kafka生成消息，而无需直接处理序列化或底层Kafka客户端的其他复杂问题。不仅如此，定义和管理生产者还可以通过服务配置上的流畅接口（Fluent Interface）轻松实现。</p><p></p><p><code lang=\"java\">services.AddKafka(kafka =&gt; kafka\n    .AddCluster(cluster =&gt; cluster\n        .WithBrokers(new[] { \"host:9092\" })\n        .AddProducer(\n            \"product-events\",\n            producer =&gt;\n                producer\n            ...\n        )\n    )\n);\n</code></p><p></p><p>生产者往往很简单，但也有一些常见的问题需要解决，比如压缩或序列化。我们来探讨一下。</p><p></p><h2>在KafkaFlow中自定义序列化/反序列化</h2><p></p><p></p><p>在Apache Kafka中，一个很有吸引力的特性就是与数据格式无关。但是，这就将责任转移给了生产者和消费者。如果考虑不周全，可能会导致在整个系统中出现由多种方式实现同一种结果的现象。因此，序列化显然是一个由客户端框架处理的用例。</p><p></p><p>KafkaFlow具有适用于JSON、Protobuf甚至Avro的序列化器。只需将它们添加到中间件配置中就可以使用。</p><p></p><p><code lang=\"java\">.AddProducer(producer =&gt; producer\n       ...\n       .AddMiddlewares(middlewares =&gt; middleware\n           ...\n           .AddSerializer()\n       )\n)\n</code></p><p></p><p>鉴于我们可以为消息使用自定义的序列化器/反序列化器，所以这个列表并不局限于这三种。虽然Confluent的.NET Kafka客户端已经支持自定义序列化/反序列化，但KafkaFlow通过提供更优雅的处理方式简化了这一过程。举例来说，要使用自定义序列化器，我们可以这样做：</p><p></p><p><code lang=\"java\">public class MySerializer : ISerializer\n{\n       public Task SerializeAsync(object message, Stream output, ISerializerContext context)\n       {\n             // 序列化逻辑在这里\n       }\n\n       public async Task DeserializeAsync(Stream input, Type type, ISerializerContext context)\n       {\n             // 反序列化逻辑在这里\n       }\n}\n\n// 在设置Kafka消费者/生产者的时候，注册自定义的序列化器\n\n.AddProducer(producer =&gt; producer\n       ...\n       .AddMiddlewares(middlewares =&gt; middleware\n          ...\n          .AddSerializer()\n       )\n)\n<p></p><p></p><h2>KafkaFlow中的消息处理</h2><p></p><p></p><p>消费者带来了大量的问题和可能性。第一个问题就是“如何处理消息？”</p><p></p><p>我们从最简单的方式开始。随着像MediatR这样的库的出现，CQRS和Meditor模式得到了普及，.NET开发人员习惯于将消息处理器与请求/消息接收器解耦。KafkaFlow将同样的原则引入到了Kafka消费者中。</p><p></p><p>KafkaFlow消息处理器允许开发人员定义特定的逻辑来处理来自Kafka主题的消息。按照设计，KafkaFlow的消息处理器结构能够更好地分离关注点，并使代码更整洁、更易于维护。</p><p></p><p>如下是一个消息处理器的示例：</p><p></p><p><code lang=\"java\">public class MyMessageHandler : IMessageHandler\n{\n    public Task Handle(IMessageContext context, MyMessageType message)\n    {\n        // 消息处理逻辑在这里\n    }\n}\n</code></p><p></p><p>这个处理器可以在消费者配置中进行注册：</p><p></p><p><code lang=\"java\">.AddConsumer(consumer =&gt; consumer\n...\n       .AddMiddlewares(middlewares =&gt; middlewares\n           ...\n             .AddTypedHandlers(handlers =&gt; handlers\n                     .AddHandler()\n              )\n       )\n)\n</code></p><p></p><p>通过这种方式，可以轻松地将消费者和处理器分开，从而提升了可维护性和可测性。如果你的微服务只处理具有一种消息类型的一个主题，这可能会显得引入了不必要的复杂性。在这种情况下，你可以使用中间件。</p><p></p><h3>KafkaFlow中的中间件</h3><p></p><p></p><p>KafkaFlow是面向中间件的。你可能已经注意到，在消息处理器的代码片段中提到了“中间件”。所以，你可能会问什么是中间件。</p><p></p><p>中间件使得类型化处理器（Typed Handler）成为可能。消息会被传递到一个中间件管道，该管道将会被依次调用。如果你使用过MediatR管道的话，可能会对这一概念有所了解。此外，中间件还可以用来进行一系列的转换。换句话说，给定的中间件可以将传入的消息转换到下一个中间件。</p><p></p><p>KafkaFlow中的中间件封装了处理消息的逻辑。管道是可扩展的，允许开发人员在消息处理管道中添加行为。</p><p></p><p>如下是一个中间件的样例：</p><p></p><p><code lang=\"java\">public class MyMiddleware : IMessageMiddleware\n{\n    public async Task Invoke(IMessageContext context, MiddlewareDelegate next)\n    {\n         // 预处理逻辑位于这里          \n        await next(context);          \n         // 后处理逻辑位于这里       \n    }\n}\n</code></p><p></p><p>要使用该中间件，可以在消费者配置中进行注册：</p><p></p><p><code lang=\"java\">.AddConsumer(consumer =&gt; consumer\n       ...\n       .AddMiddlewares(middlewares =&gt; middlewares\n             ...\n             .Add()\n         )\n)   \n</code></p><p></p><p>通过这种方式，开发人员就可以在消息处理管道中插入自定义逻辑，从而提供灵活性和控制力。类型化处理器是中间件的一种形式。所以，你甚至可以在没有类型化处理器的情况下处理消息，实现自己的中间件，或者也可以使用中间件来构建消息管道，在处理消息之前执行校验、丰富化等操作。</p><p></p><h2>在KafkaFlow中处理并发</h2><p></p><p></p><p>一旦开始思考基础设施的效率，你就会发现许多Kafka消费者没有得到充分利用。最常见的实现方式是单线程的，这限制了资源的利用率。因此，当我们需要扩展的时候，只能进行横向扩展，以保持所需的吞吐量。</p><p></p><p>KafkaFlow为实现基础设施的高效率带来了另外一种可选方案。KafkaFlow让开发人员可以控制单个消费者可以并发处理多少消息。它使用了Worker的理念，这些Worker可以协同消费一个主题。这一功能能够让你优化Kafka消费者，使其更好地匹配系统的能力。</p><p></p><p>如下是一个如何为消费者设置并发worker数量的样例：</p><p></p><p><code lang=\"plain\">.AddConsumer(consumer =&gt; consumer\n.Topic(\"topic-name\")\n       .WithGroupId(\"sample-group\")\n       .WithBufferSize(100)\n       .WithWorkersCount(10) // 设置worker的数量\n       .AddMiddlewares(middlewares =&gt; middlewares\n        ...\n        )\n)\n</code></p><p></p><p>即便有并发worker，KafkaFlow也能确保顺序。</p><p></p><h2>批处理</h2><p></p><p></p><p>随着规模的扩大，你将会面临延迟和吞吐量之间的权衡。为了解决这个问题，KafkaFlow有一个重要的特性，叫做“批量消费”。这个特性满足了以批量方式消费和处理来自Kafka的消息时对效率和性能的要求。在需要一起处理一组消息，而不是单个处理消息的场景下，该特性发挥着重要作用。</p><p></p><h3>什么是批量消费？</h3><p></p><p></p><p>在批量消费方式中，系统不是在收到消息后对其进行原子性地处理，而是将多条消息分组，然后一次性地对其进行处理。这种方法在处理大量数据时更为有效，尤其是在消息相互独立的情况下。批量执行操作会提高整体性能。</p><p></p><h3>KafkaFlow的批量消费方式</h3><p></p><p></p><p>KafkaFlow利用中间件系统提供批量处理功能。批量处理中间件能够让你根据批量大小或时间跨度（timespan）对消息进行分组。一旦达到其中的某个条件，中间件就会将这组消息转发给下一个中间件。</p><p></p><p><code lang=\"java\">services.AddKafka(kafka =&gt; kafka\n    .AddCluster(cluster =&gt; cluster\n        .WithBrokers(new[] { \"host:9092\" })\n        .AddConsumer(\n            consumerBuilder =&gt; consumerBuilder\n            ...\n            .AddMiddlewares(\n                middlewares =&gt; middlewares\n                    ...\n                    .BatchConsume(100, TimeSpan.FromSeconds(10))\n                    .Add()\n            )\n        )\n    )\n);\n</code></p><p></p><h3>批量消费对性能的影响</h3><p></p><p></p><p>通过批量处理，开发人员可以在基于Kafka的应用程序中实现更高的吞吐量。它可以加快处理速度，因为与启动和完成每个处理任务相关的开销会大大减少。这将全面提升系统的性能。</p><p></p><p>同时，这种方式还能减少网络I/O操作，因为数据是以更大的分块获取的，这能够进一步提高处理速度，尤其是在需要关注网络延迟的系统中。</p><p></p><h2>KafkaFlow的消费者管理</h2><p></p><p></p><p>KafkaFlow还简化了Kafka消费者管理相关的任务。通过KafkaFlow的管理API，我们可以启动、停止、暂停消费者以及倒回偏移（rewind offset）。</p><p></p><p>管理API可以在编程接口、REST API或Dashboard UI中使用。</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/kafkaflow-dotnet-framework/en/resources/48figure-1-1693906634283.jpg\" /></p><p></p><p>KafkaFlow的管理仪表盘</p><p></p><h2>消费者限流</h2><p></p><p></p><p>通常，底层技术可能无法像Kafka消费者那样以相同的方式应对高负载期。这会带来稳定性的问题，而这正是限流的用武之地。</p><p></p><p>消费者限流是一种管理消息消费的方式，它能够使应用程序根据指标动态调整消息消费的速度。</p><p></p><h3>优先级</h3><p></p><p></p><p>假设你正在运行一个应用程序，希望将原子操作和批量操作分隔到不同的消费者和主题中。与批量操作相比，你可能更愿意优先处理原子操作。按照传统方式，由于消息生成的速度可能存在差异，所以管理这种差异化可能很具挑战性。</p><p></p><p>在这种情况下，消费者限流就很有价值了，它允许我们监控那些负责原子操作的消费者的滞后（lag）情况。根据这一指标，我们可以对处理批量操作的消费者实施限流，确保优先处理原子操作。</p><p></p><p>那结果是什么呢？高效、灵活和优化的消费流程。</p><p></p><p>借助KafkaFlow的流畅接口，为消费者添加限流功能是非常简单的。下面是一个简单的样例：</p><p></p><p><code lang=\"java\">.AddConsumer(\n    consumer =&gt; consumer\n        .Topic(\"bulk-topic\")\n        .WithName(\"bulkConsumer\")\n        .AddMiddlewares(\n            middlewares =&gt; middlewares\n                .ThrottleConsumer(\n                    t =&gt; t\n                        .ByOtherConsumersLag(\"singleConsumer\")\n                        .WithInterval(TimeSpan.FromSeconds(5))\n                        .AddAction(a =&gt; a.AboveThreshold(10).ApplyDelay(100))\n                        .AddAction(a =&gt; a.AboveThreshold(100).ApplyDelay(1_000))\n                        .AddAction(a =&gt; a.AboveThreshold(1_000).ApplyDelay(10_000)))\n                .AddSerializer()\n        )\n)\n</code></p><p></p><h2>KafkaFlow：展望未来</h2><p></p><p></p><p>目前，KafkaFlow在Kafka的基础上提供了一个健壮的、对开发人员友好的抽象，简化了使用.NET构建实时数据处理应用程序的过程。但是，与其他活跃的开源项目一样，KafkaFlow也在不断演进和完善。</p><p></p><p>从<a href=\"https://github.com/Farfetch/kafkaflow/issues?q=is%3Aissue+milestone%3Av3.0.0+is%3Aopen\">项目目前的发展轨迹来看</a>\"，我们可以预测几个方面的发展方向。例如，KafkaFlow可能会进一步增强其中间件系统，为消息处理提供更多的控制权和灵活性。我们可能还会看到更广泛的管理API，为开发人员提供对Kafka集群更大的控制权。</p><p></p><p>由于设计上的可扩展性，我们可以期待KafkaFlow社区会不断壮大，带来更多的贡献、创新特性、扩展和支持。随着越来越多的开发人员和组织采用KafkaFlow，我们会看到学习资源、教程、案例和其他社区内容不断涌现，这些内容可以帮助新用户入门，也可以帮助现有的用户从库中学习更多的知识。</p><p></p><h2>结论</h2><p></p><p></p><p>KafkaFlow是一个便利、对开发人员友好的工具，它简化了在.NET中使用Kafka的工作。在开发人员体验和可用性方面，它均表现出色。该框架的设计非常适合整洁、可读性强的代码。在Apache Kafka上构建应用程序时，KafkaFlow通过中间件、消息处理器以及对复杂问题的抽象，实现了清晰的分离，这有助于保持代码库的可管理性和可理解性。</p><p></p><p>除此之外，围绕KafkaFlow的社区在不断壮大。如果你正在使用Kafka并希望提高生产力和可靠性，那KafkaFlow绝对值得考虑。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/kafkaflow-dotnet-framework/\">Building Kafka Event-Driven Applications with KafkaFlow</a>\"</p></code></p>",
    "publish_time": "2023-10-11 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "广告创意领域中AIGC的应用 | InfoQ《极客有约》",
    "url": "https://www.infoq.cn/article/p56ceAHvdxwtkZN9d7ct",
    "summary": "<p>大模型出现后，许多大佬、专家都表示过“值得考虑用大模型重新构建所有行业和产品”类似观点。具体到各个行业，那么能利用大模型哪些能力解决什么样的问题，落地时存在哪些挑战，都是值得探讨的话题。</p>\n<p>本次《极客有约》我们将围绕广告创意领域中AIGC的应用，聊点真实的落地的难处。</p>",
    "publish_time": "2023-10-11 10:36:13",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]