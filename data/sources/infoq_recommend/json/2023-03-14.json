[
  {
    "title": "基于契约的开发：通过明确需求优化软件开发流程",
    "url": "https://www.infoq.cn/article/g6D7e4ki76V3dRBWkrrK",
    "summary": "<p>独立开发和部署单个微服务的能力是成功采用微服务策略最关键的指标。然而，大多数团队在部署微服务之前必须经历大量的集成测试。这是因为集成测试已经成为识别微服务之间兼容性问题的必要条件，因为单元和组件或API测试没有覆盖微服务之间的交互。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/15/1501bd86ea9dbb41a22fc9fceb57e36e.png\" /></p><p></p><p>&nbsp;</p><p>首先，集成测试是一种发现兼容性问题的后期反馈机制。修复这些问题的成本随着发现时间的推移而成倍增加（如上图底部的热图所示）。</p><p>&nbsp;</p><p>此外，这可能会导致客户端和服务端团队做大量的返工工作，严重影响特性交付的可预测性，因为团队不得不兼顾常规的特性开发和集成错误修复。</p><p>&nbsp;</p><p>集成环境可能非常脆弱。由于两个组件或服务之间的兼容性问题，即使是单个中断的交互也会导致整个环境受到损害，这意味着即使是其他不相关的功能和微服务也无法测试。</p><p>&nbsp;</p><p>这给生产交付造成了阻碍，即使是对关键问题的修复，而且会让整个交付过程陷入停顿，我们称之为“集成地狱”。</p><p>&nbsp;</p><p></p><h2>集成测试——了解这头野兽</h2><p></p><p>&nbsp;</p><p>在终结集成测试之前，我们先来了解它到底是什么。这个词经常被用在不恰当的地方。</p><p>&nbsp;</p><p>测试应用程序不仅仅是测试每个函数、类或组件的逻辑。应用程序的功能是这些单独的逻辑片段与其对应部分交互产生的结果。如果两个组件之间的服务边界或API没有理清楚，就会导致通常所说的集成问题。例如，如果函数A只使用一个参数调用函数B，而函数B需要两个必填的参数，那么这两个函数之间就存在集成或兼容性问题。这种快速的反馈有助于我们尽早纠正并立即解决问题。</p><p>&nbsp;</p><p>然而，当我们在微服务级别（服务边界位于HTTP、消息传递或事件级别）识别兼容性问题时，单元和组件或API测试都无法立即识别出任何偏离或违反服务边界的行为。微服务必须与所有实际对应的服务一起测试，才能验证是否存在中断的交互。这些被广泛地（在某种程度上错误地）归类为集成测试。</p><p>&nbsp;</p><p>集成测试这个词被用来描述很多类型的检查：</p><p>&nbsp;</p><p>两个或多个组件之间的兼容性；工作流测试——涉及交互编排的整个功能；与其他依赖项（如存储、消息传递基础设施等）的交互；还有更多，生产基础设施的端到端测试除外。</p><p>&nbsp;</p><p>需要明确说明的是，当我们说终结“集成测试”时，我们说的是消除对“集成测试”的依赖，不要将其作为识别微服务之间兼容性问题的唯一方法。但其他东西，例如工作流测试，可能仍然是必要的。</p><p></p><h2>确定拐点——知道从哪里下手</h2><p></p><p>&nbsp;</p><p>当所有代码都属于一个单体，方法签名可能就可以作为服务边界的API规范。我们可以通过编译时检查等机制强制执行方法签名检查，从而为开发人员提供早期反馈。</p><p>&nbsp;</p><p>然而，当一个服务的组件被拆分为多个微服务，服务边界变为接口（如HTTP REST API）时，这种早期的反馈就不会有了。在之前作为方法签名进行文档化的API规范现在需要被显式地文档化，描述清楚正确的调用方法。如果API文档不是机器可解析的，还可能会导致团队之间的沟通混乱。</p><p>&nbsp;</p><p>如果没有良好文档化的服务边界：</p><p>&nbsp;</p><p>只能使用近似模拟的服务端来构建客户端，而手动模拟和存根技术通常会导致存根过期的问题，即存根无法真正表示服务端。对于服务端来说，无法模拟客户端。</p><p>&nbsp;</p><p>这意味着我们必须采用缓慢的串行化开发风格，即在开始开发另一个组件之前必须等待其中一个组件构建完成。如果需要快速发布特性，这就不是一种高效的方法。</p><p>&nbsp;</p><p>转向微服务后，我们失去了两个关键的能力：</p><p>&nbsp;</p><p>清楚地表示两个组件之间服务边界的API规范；强制执行描述服务边界的API规范。</p><p>&nbsp;</p><p>我们需要另一种方法来弥补这两方面的缺失。</p><p></p><h2>API规范</h2><p></p><p>&nbsp;</p><p>如果想要恢复清晰且按照机器可解析的方式来表示API签名的能力，采用API规范标准（如OpenAPI或AsyncAPI）就变得至关重要。虽然这增加了开发人员创建和维护这些规范的工作量，但利大于弊。</p><p>&nbsp;</p><p>尽管如此，API规范，顾名思义，也只是有助于描述API签名。在开发过程中，为了获得早期的反馈，又该如何强制执行它们呢？这一部分仍然是缺失的。</p><p></p><h2>代码/文档生成——无效且不可持续</h2><p></p><p>&nbsp;</p><p>我们可以认为，我们可以通过代码生成技术来生成和维护API规范。从表面上看，如果代码是基于规范生成的，就不会偏离规范。</p><p>&nbsp;</p><p>然而，这里存在一些难点：</p><p>&nbsp;</p><p>正在进行中的开发——大多数代码生成工具/技术为服务器端和客户端代码生成脚手架，并要求我们在这个脚手架/模板中填写业务逻辑。问题是，当规范发生变化时，我们通常需要重新生成脚手架，从旧版本的代码中提取业务逻辑，并再次粘贴到新的脚手架中，这增加了犯人为错误的可能性。数据类型不匹配——代码生成工具/技术必须支持每一种编程语言。在多语言环境中，生成的脚手架在不同编程语言之间的数据类型（或其他东西）可能不一致。如果我们为一种编程语言生成文档（基于服务端代码生成API规范），然后利用生成的规范进一步为客户端代码生成脚手架，这将进一步加剧这种情况的恶化。</p><p>&nbsp;</p><p>数据类型不匹配——代码生成工具/技术必须支持每一种编程语言。在多语言环境中，生成的脚手架在不同编程语言之间的数据类型（或其他东西）可能不一致。如果我们为一种编程语言生成文档（基于服务端代码生成API规范），然后利用生成的规范进一步为客户端代码生成脚手架，这将进一步加剧这种情况的恶化。</p><p>&nbsp;</p><p>总的来说，代码生成和文档生成只能满足有限的场景。虽然它们最初可能通过生成代码为团队提供快捷的构建应用程序的方法，但这种技术的持续成本会让团队不堪重负。</p><p>&nbsp;</p><p>因此，我们需要另一种方法来执行API规范。</p><p></p><h2>契约驱动开发——API规范作为可执行契约</h2><p></p><p>&nbsp;</p><p>方法签名可以由编译器强制执行，在开发人员偏离方法签名时向他们提供早期反馈。那么API也能实现类似的效果吗？</p><p>&nbsp;</p><p>契约测试就是实现这种效果的一种尝试。<a href=\"https://docs.pact.io/\">Pact.io的文档</a>\"中写道：</p><p>&nbsp;</p><p></p><blockquote>契约测试是一种测试集成点的技术，它会单独检查每个应用程序，确保它们发送或接收的消息符合记录在“契约”中的内容。</blockquote><p></p><p>&nbsp;</p><p>不过需要注意的是，契约测试本身也包含了几种方式，例如客户端驱动的契约测试（<a href=\"https://pact.io/\">Pact.io</a>\"）、服务端驱动的契约测试（生产者契约测试方法中的<a href=\"https://spring.io/projects/spring-cloud-contract\">Spring云契约</a>\"）、双向契约测试（<a href=\"https://pactflow.io/\">Pactflow.io</a>\"）等等。在大多数这些测试方法中，API契约是独立于API规范的文档。例如，在Pact.io中，JSON就是API契约。Spring云契约也有用于定义契约的DSL。与其维护两个不同的工件（可能会导致不同步），不如利用API规范本身作为API契约，在开发人员偏离API规范导致客户端出现问题时为他们提供早期反馈，这样会不会更好？</p><p>&nbsp;</p><p><a href=\"https://specmatic.in/\">Specmatic</a>\"就是这样做的。Specmatic是一个开源的基于契约驱动开发的工具。它将客户端和服务端之间的交互划分为独立可验证的单元。考虑下面两个微服务之间的交互，目前只在更大级别的测试环境中进行验证。</p><p>&nbsp;</p><p><code lang=\"null\">ServiceA &lt;-&gt; ServiceB</code></p><p>&nbsp;</p><p>CDD可以将这种交互分解成连续的组成部分：</p><p>&nbsp;</p><p><code lang=\"null\">ServiceA &lt;-&gt; Contract as Stub {API spec of ServiceB}\n             Contract as Test {API spec of ServiceB} &lt;-&gt; ServiceB</code></p><p>&nbsp;</p><p>现在我们来仔细研究一下。</p><p>&nbsp;</p><p>左边：ServiceA =&gt; <a href=\"https://specmatic.in/#contract-as-stub\">Contract as Stub</a>\"我们为客户端（ServiceA）模拟服务端（ServiceB），这样客户端应用程序开发就可以独立于服务端进行。由于Contract as Stub（智能Mock）是基于双方约定的API规范，因此能够真正作为服务端（ServiceB）的Mock，它会在客户端（ServiceA）调用API并偏离API规范时给出反馈/抛出错误。右边：<a href=\"https://specmatic.in/#contract-as-test\">Contract as Test</a>\" =&gt; ServiceB为服务端（ServiceB）模拟客户端（ServiceA），并验证响应是否符合双方约定的API规范。Contract as Test将在服务端（ServiceB）应用程序开发人员偏离规范时立即向他们提供反馈。</p><p>&nbsp;</p><p>既然我们可以在组件级别让客户端（ServiceA）和服务端（ServiceB）应用程序遵守API规范，同时又可以独立构建，那么就没有必要将它们部署在一起来测试它们的交互。这样我们就不需要再依赖集成测试来识别兼容性问题。</p><p>&nbsp;</p><p><a href=\"https://specmatic.in/\">Specmatic</a>\"就是这样利用API规范作为<a href=\"https://specmatic.in/#executable-contracts\">可执行契约</a>\"。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/1d/1d4b65ae3b3faa062a53b314ce9a1494.png\" /></p><p></p><p></p><h2>契约即代码</h2><p></p><p>&nbsp;</p><p>这里的关键是API规范本身，它可以让API提供者和使用者分离并独立地驱动各自组件的开发和部署，同时保持所有组件的一致性。</p><p>&nbsp;</p><p>为了成功地进行契约驱动开发，我们需要采用API优先的方法，即API提供者和使用者需要先协作设计和记录API规范。这意味着他们需要使用现代的可视化编辑器之一，如Swagger、Postman、Stoplight等来编写API规范，在开始独立构建各自的部分之前专注于API设计，并确保所有利益相关者保持同步。</p><p>&nbsp;</p><p>习惯于基于代码生成API规范的团队可能会对这种先编写API规范的反向流程感到不适应。CDD需要类似测试驱动开发的心态转变。在进行测试驱动开发时，我们需要通过先手写测试来指导/驱动代码设计。类似地，在CDD中，我们需要先手工编写API规范，然后使用Specmatic等工具将它们转换为可执行的契约测试。</p><p>&nbsp;</p><p>我发现，对于基于代码生成API规范的方法来说，API设计处于次要地位，变得更像是事后的想法，或者是偏向于客户端或服务端。此外，由于发布时间的压力，在采用API规范优先的方式时，我们能够并行独立开发客户端和服务端组件，而基于代码生成API规范这种方式是不可能做到这一点的（客户端必须等待服务端代码完成并生成了规范）。</p><p>&nbsp;</p><p>在就公共API规范达成了共识之后，让这些API规范有一个单一的真实来源就变得非常重要。如果这些规范出现了多个副本，会导致客户端和服务端团队在实现方面出现分歧。</p><p>&nbsp;</p><p>CDD建立在三个基础支柱之上。“契约即存根（Contract as Stub）”和“契约即测试（Contract as Test）”让客户端和服务端团队保持一致，但将一切联系在一起的粘合剂是第三个支柱——“<a href=\"https://specmatic.in/#contract-as-code\">中央契约存储库</a>\"”。</p><p>&nbsp;</p><p>API规范是机器可解析的代码，所以还有什么地方比版本控制系统更适合存储它们的呢？将它们存储在版本控制系统（如Git）中，我们就可以通过添加Pull/Merge请求过程来为它们的构建过程增加一些严格性。理想情况下，Pull/Merge请求应该包括以下步骤：</p><p>&nbsp;</p><p>语法检查，确保一致性；<a href=\"https://specmatic.in/#backward-compatibility\">向后兼容性</a>\"检查，确定是否有任何重大变更；最后的评审和合并。</p><p>&nbsp;</p><p>强烈建议将规范存储在同一个中心位置，这适用于大多数情况（甚至是大型企业）。除非绝对有必要，否则不建议跨多个存储库存储规范。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/33/33ad3c54b25ca7a4fe03e186a2e61d53.png\" /></p><p></p><p>&nbsp;</p><p>等到规范被存储到了中央存储库中，它们就可以被：</p><p>&nbsp;</p><p>客户端和服务端团队使用，分别进行独立的开发；发布到API网关。</p><p></p><h2>集成测试的终结</h2><p></p><p>&nbsp;</p><p>我们已经消除了对通过集成测试来识别应用程序兼容性问题的需求，那么系统测试和工作流测试呢？</p><p>&nbsp;</p><p>CDD为更大级别的测试环境铺平了道路，因为所有兼容性问题都在开发的更早阶段（在本地和CI等环境中）被识别出来，在这些环境中修复问题的成本要低得多。我们可以通过系统测试和工作流测试在稳定的更大级别的环境中验证复杂的编排问题。另外，由于我们已经不需要通过集成测试来识别兼容性问题，在更大级别的环境中测试套件的总体运行时间也缩短了。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/47/4766b5a4916e83a558b3caa59f785364.png\" /></p><p></p><p>&nbsp;</p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/contract-driven-development/\">https://www.infoq.com/articles/contract-driven-development/</a>\"</p>",
    "publish_time": "2023-03-14 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]