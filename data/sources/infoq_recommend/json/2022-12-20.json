[
  {
    "title": "Spring Boot 3和Spring Framework 6使用Java 17和Jakarta EE 9，并支持基于GraalVM的原生Java",
    "url": "https://www.infoq.cn/article/iCQ44j3XyAEl2FgHSPQy",
    "summary": "<p>VMware<a href=\"https://spring.io/blog/2022/11/16/spring-framework-6-0-goes-ga\">发布</a>\"了人们期待已久的<a href=\"https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-Spring-Framework-6.x/\">Spring Framework 6</a>\"和Spring Boot 3。在Spring Framework 5发布五年之后，这些版本发布开启了Spring生态系统的新篇章。Spring Framework 6需要Java 17和Jakarta EE 9，并兼容<a href=\"https://www.infoq.com/news/2022/09/jakarta-ee-10-updates\">最近发布的</a>\"&nbsp;Jakarta EE 10。它还通过Micrometer嵌入了可观测性，支持跟踪和度量。Spring Boot 3需要Spring Framework 6。它内置支持通过GraalVM Native Image的静态预先（Ahead-of-Time，AOT）编译创建原生可执行文件。</p><p></p><p>VMware的软件工程高级总监Michael Minella告诉InfoQ：</p><p></p><p></p><blockquote>Spring采取的方法是让Spring开发者在现有的专业知识基础上获取原生编译的收益，而无需进行大量的变更，这在整个生态系统中是独一无二的。</blockquote><p></p><p></p><p>VMware在SpringOne 2021会议上<a href=\"https://www.infoq.com/news/2021/09/spring-6-spring-boot-3-overhaul\">宣布</a>\"了Spring Framework 6和Spring Boot 3。从2010年以来，这是Spring Framework第一次在上一个主发布版本两年后（2020年的5.3版本），而不是一年后发布更新。在最近的一次采访中，Java Champion和Spring开发人员倡导者Josh Long在讨论Spring Framework 6开发时间延长时表示：</p><p></p><p></p><blockquote>“对于我们这些框架开发者来说，迁移至Jakarta EE是很有挑战性的”，“可观测性工作也涉及很多的地方”，“与GraalVM Native Image的预先（Ahead-of-Time，AOT）编译相关的工作[...]至少从2019年开始就以某种形式展开了”。</blockquote><p></p><p></p><p>关于这两个版本相关内容的更多信息，请参见对<a href=\"https://www.infoq.cn/article/ATGFHsJa5HqNroEuNBLd\">Josh Long的采访</a>\"。</p><p></p><p>支持Jakarta EE 10使得Spring Framework 6能够兼容最新的web服务器，比如Tomcat 10.1、Jetty 11和Undertow 2.3。Spring Framework 6还简化了HTTP请求，这是通过将它们定义在所谓的HTTP接口中实现的，它类似于Spring Data JPA通过资源库（repository）接口简化了数据库查询。借助RFC 7807问题详情，HTTP错误信息也会更有帮助。</p><p></p><p>作为一个预览特性，Spring Framework 6可以使用Java 19中<a href=\"https://www.infoq.com/articles/java-virtual-threads\">来自Loom项目的虚拟线程</a>\"。虚拟线程及其相关的结构化并发API简化了Java中的并发编程，使其运行更加高效。与<a href=\"https://www.youtube.com/watch?v=9si7gK94gLo&amp;t=1163s\">Oracle不同</a>\"，Spring认为虚拟线程是<a href=\"https://spring.io/blog/2022/10/11/embracing-virtual-threads\">对反应式编程的补充</a>\"，而不是要取代它。</p><p></p><p>在Spring Framework 6中值得注意的依赖升级包括Kotlin 1.7、Hibernate ORM 6.1、用于JSON和XML解析的Jackson 2.14以及用于反应式数据库访问的R2DBC 1.0。</p><p></p><p>正如InfoQ去年<a href=\"https://www.infoq.com/news/2021/09/spring-6-spring-boot-3-overhaul\">报道</a>\"的那样，Spring Framework 6最初是计划包含对Java Platform Module System（JPMS）的支持的，但这从未实现过。对JPMS的支持<a href=\"https://www.infoq.com/news/2022/10/spring-boot-3-jax-london\">进行了推迟</a>\"：</p><p></p><p></p><blockquote>Spring Framework 6.0强烈关注AOT和GraalVM原生镜像，以优化基于Spring的应用的部署。[...]今年以来，对它[模块支持]的需求非常少。[...]更深入的模块系统调整仍然是我们为Spring Framework 6.x所制定的长期技术战略的一部分。</blockquote><p></p><p></p><p>OpenJDK的Leyden项目<a href=\"https://www.infoq.com/news/2022/06/project-leyden-delays-aot\">计划优化Java</a>\"，并依赖于JPMS和jlink连接工具。如果没有JPMS支持，Spring应用将无法使用这些优化。</p><p></p><p>Spring Boot 3的亮点是支持生成原生可执行文件。这些可执行文件启动更快，使用的内存更少，容器镜像更小，而且更安全。这使得Java在云中更有竞争力。Quarkus、Micronaut和Helidon这些框架使原生可执行文件在Java中流行了起来。InfoQ最近就这个话题发表了<a href=\"https://www.infoq.com/articles/native-compilations-boosts-java/\">六篇系列文章</a>\"。当开发人员的机器上安装了GraalVM Native Image编译器后，用Spring Boot 3创建一个原生可执行文件只需运行./mvnw -Pnative package或./gradlew nativeCompile即可。更多细节可以在参阅这篇<a href=\"https://spring.io/blog/2022/09/26/native-support-in-spring-boot-3-0-0-m5\">博客文章</a>\"。</p><p></p><p>Jakarta EE 9将Java命名空间从javax.*改为jakarta.*。如果现有的Spring和Spring Boot应用程序导入了Jakarta EE类型，如注解、校验或JPA，就需要对其进行修改。这就是为什么最近推出的<a href=\"https://www.infoq.com/news/2022/09/spring-boot-migrator/\">Spring Boot Migrator</a>\"项目正在“致力于从Spring Boot 2.7自动升级到Spring Boot 3.0”。</p><p>VMware缩短了Spring Framework 6的商业和开源支持期限。正如VMware的Spring Framework项目负责人Juergen Hoeller所说：</p><p></p><p></p><blockquote>我们期望人们更快地升级到最新的6.x特性版本。</blockquote><p></p><p></p><p>而Spring Boot 3.0的免费支持期限仍为一年。</p><p></p><p>VMware将在2023年1月24日至26日的虚拟SpringOne会议上讨论其新版本，SpringOne<a href=\"https://springone.io/2022/faq\">原计划</a>\"于2022年12月举行线下的会议。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2022/11/spring-6-spring-boot-3-launch/\">Spring Boot 3 and Spring Framework 6 Use Java 17 and Jakarta EE 9, Support Native Java with GraalVM</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/ATGFHsJa5HqNroEuNBLd\">对话Spring大神：Spring 生态系统的新时代来了！</a>\"</p><p><a href=\"https://www.infoq.cn/article/5VMP2p3hLyEKpYIILxLr\">Spring Boot 3将于2022年11月发布，延迟了对Java模块系统的支持</a>\"</p><p><a href=\"https://www.infoq.cn/article/M8Tcely7QZhZYx4od2t1\">Spring Boot Migrator简介</a>\"</p>",
    "publish_time": "2022-12-20 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "痴迷编程、厌倦低效和内斗，传奇程序员、VR大神John Carmack离开Meta",
    "url": "https://www.infoq.cn/article/mtSBetU41lqzApIKT67h",
    "summary": "<p>上周，科技圈又传出重要人事变动消息：前 Meta CTO、传奇程序员 约翰·卡马克（John Carmack） 宣布辞去 Meta 顾问CTO一职，结束其十年的 VR 旅程。</p><p>&nbsp;</p><p>卡马克在公司内部 Workplace 论坛上发布了他离开的决定，信中明确表达了对 Meta 运营效率低下以及公司内部斗争严重情形的失望。</p><p>&nbsp;</p><p>“我们做出了一些非常接近正确方向的东西，”卡马克在辞职信中说，“问题是我们的效率。”卡马克表示，Meta 拥有多到离谱的人力和资源，但一直在不断地自我破坏和浪费，看到最终销售的产品中 GPU 利用率只有5% ，这个数字让人痛苦，觉得受到了严重的冒犯。</p><p>&nbsp;</p><p>“团队运转效率只达到能让我满意的标准的一半。在 Meta 工作对我来说是一场斗争，虽然我在公司最高层有发言权，自认为能推动某些事的发展，但显然我的说服力还是不够。我已经厌倦了这一切，要去专心运营自己的创业公司了。”</p><p>&nbsp;</p><p>卡马克认为自己有能力推动技术并交付产品，但不屑于去做“斗争”：“我本可以在 Oculus 被收购后搬到门洛帕克，与领导层进行长期斗争，但我忙于编程，讨厌并不擅长这样的斗争。”总的来说，就是“厌倦了低效和内斗”。</p><p>&nbsp;</p><p>Meta 的前身 Facebook，于 2014 年收购了 Oculus。尽管 Oculus 是市场上最著名和最受欢迎的 VR 耳机之一，但 Meta 最后将其品牌名称改为了Meta Quest。Oculus 由<a href=\"https://www.businessinsider.com/palmer-luckey-blasts-facebook-terrible-metaverse-product-oculus-2022-10\">Palmer Luckey</a>\"于 2012 年创立，卡马克于 2013 年加入 Oculus，在 Meta 收购 Oculus 后成为 Meta CTO。2019 年 11 月卡马克宣布辞去 CTO 一职，仅担任“顾问 CTO”，但仍对产品开发工作有一定发言权。</p><p>&nbsp;</p><p></p><h2>一直以来都对 VR 的进步感到失望</h2><p></p><p>&nbsp;</p><p>卡马克一直是 VR 技术的忠实信徒，虽然在周五的辞职信中他写道“VR 可以为世界上大多数人带来价值，没有人比 Meta 更适合做这件事”，但实际上他一直对Meta的效率和发展感到不满。</p><p>&nbsp;</p><p>作为 Oculus 的前首席技术官，卡马克在虚拟世界及其耳机方面为 Facebook 提供建议，并且是VR技术的推动者。他在 VR 领域有着巨大的影响力，曾推动了三星 Gear VR 和 Oculus Quest 等设备的实际应用以及下一代技术的发展。他以每年在 Oculus Connect 会议上激情四射、极客范儿十足的主题演讲而闻名，他对 VR 发展的预判也一直以来都被视为该行业技术成就和未来挑战的关键“晴雨表”。</p><p>&nbsp;</p><p>2019年，他还发表了一篇《Gear VR》的“悼词”，称这款已经停产的产品是一个“错失的机会”。在同年接受 VR 大奖终身成就奖的一段视频中，他直言：“我真的对我们在 VR 领域所取得的进展感到非常不满意。”</p><p>&nbsp;</p><p>而在今年 10 月份的 Meta 开发者大会上，谈到公司的发展速度时，他再次承认自己在在技术进步和耳机基本功能方面的进步速度上，表现得“脾气暴躁”。他说，听到 Meta 内部人员发现 Quest 2 耳机非常不可靠，以致于拒绝将其用于工作或向公司外部人员演示时，他感到很沮丧。</p><p>&nbsp;</p><p>他在这次大会的主题演讲中指出，“Quest 的基本可用性确实需要改进”，“我们的应用启动时间很慢，我们的过渡也很不稳定。我们需要让它变得更好…… 启动要快得多。”</p><p>&nbsp;</p><p>卡马克在2019年底宣布卸任 Oculus 首席技术官，并创立了通用人工智能公司 Keen Technologies ，该公司于今年获得 2000 万美元的融资。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/7c/7c70d03dd74e88d256fc17d50ff2d850.png\" /></p><p></p><p>&nbsp;</p><p>当时有观点认为，Facebook 内部在关于 VR 的发展方向上存在着大量冲突，这可能是促使卡马克卸任Oculus 首席技术官的原因。</p><p>&nbsp;</p><p></p><h2>开挂的传奇程序员</h2><p></p><p>&nbsp;</p><p>卡马克被业内称为“传奇程序员”。</p><p>&nbsp;</p><p>卡马克是自学的编程，在大一的时候，就因编写游戏而小有名气。1990年，一家名为Softdisk的软件公司找到了在读大二的卡马克，邀请他加入一起开发游戏。一年之后，卡马克离开了 Softdisk，创办了 id Software，随后主导研发了《毁灭战士》、《雷神之锤》、《德军总部》等引发轰动效应的电子游戏，并凭借这“三部曲”开创了第一人称射击游戏，改变了 PC 动作游戏的定义。</p><p>&nbsp;</p><p>2010 年，由于在游戏界的突出贡献及开发的全球首款 3D 射击游戏《德军总部 3D》，该年度游戏开发者大会的精英选择奖咨询委员会授予卡马克“游戏开发者终身成就奖”。《德军总部 3D》采用了他独创的 3D 游戏引擎。</p><p>&nbsp;</p><p>除此之外，卡马克还喜欢研究火箭发射，他自己投资成立了一个名为“犰狳宇航”的私人太空飞行研发团队。不过因为缺乏资金，该项目在 2013 年宣告失败。有人曾做过统计，卡马克累计为他这个兴趣爱好投入了 800 多万美元和 12 年宝贵光阴。后来在谈及此事时，卡马克有些惋惜，“我当然很失望，虽然我还能张罗 200 万美元再试一次，但明智的老婆大人阻止了我。”</p><p>&nbsp;</p><p>卡马克虽然现在已经年过50，但一直非常痴迷于编程。他还曾用一周的时间，用C++徒手写了一遍“CNN神经网络”代码。</p><p>&nbsp;</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/da/da8b1f91c38ba53573ddd0d4ba501c0d.png\" /></p><p></p><p>&nbsp;</p><p>只要他喜欢，他就认为其他任何事情都不是难点，他曾说过：</p><p>&nbsp;</p><p></p><blockquote>在信息时代，客观障碍已不复存在，所谓障碍都是主观上的。如果你想动手开发什么全新的技术，你不需要几百万美元的资金，你只需要在冰箱里放满比萨和可乐，再有一台便宜的计算机，和为之献身的决心。我们在地板上睡过，我们从河水中趟过。</blockquote><p></p><p>&nbsp;</p><p>参考链接：</p><p><a href=\"https://www.businessinsider.com/john-carmack-meta-consulting-cto-virtual-reality-leaving-2022-12\">https://www.businessinsider.com/john-carmack-meta-consulting-cto-virtual-reality-leaving-2022-12</a>\"</p><p><a href=\"https://www.facebook.com/100006735798590/posts/i-resigned-from-my-position-as-an-executive-consultant-for-vr-with-meta-my-inter/3467566940144465/\">https://www.facebook.com/100006735798590/posts/i-resigned-from-my-position-as-an-executive-consultant-for-vr-with-meta-my-inter/3467566940144465/</a>\"</p><p><a href=\"https://www.infoq.cn/article/PppvXCGoEzedii0zUx4H\">https://www.infoq.cn/article/PppvXCGoEzedii0zUx4H</a>\"</p>",
    "publish_time": "2022-12-20 10:49:19",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "从 0 到 1 的降本增效保姆级指南，这次你一定不能错过！",
    "url": "https://www.infoq.cn/article/lc1cFARfEppvpdewbAbE",
    "summary": "<p>即将到来的 2023 年，对于各行各业的企业来说都是充满挑战的一年。多家专业分析机构都给出了全球经济面临衰退的预测，市场态势普遍由增量竞争转为存量竞争。另一方面，国内疫情防控战略转变后，劳动力市场与消费市场将不可避免地迎来冲击。依据国外经验，新形势下线下消费需要经历相当长的时间才能恢复繁荣，更多消费者会转向线上渠道购买商品和服务，消费欲望也会显著缩减。在 To B 层面，业务人员更难与客户面对面交流、上门服务，许多业务和服务需求也要通过线上渠道完成。</p><p></p><p>复杂的外部环境变化对企业自身的运营水平提出了更高的要求。为应对增长的线上业务，企业需要加大基础设施投入，构建完善的 IT 运维环境，同时通过自动化等手段减轻人工压力，使企业在人员不足的情况下依旧能够保障业务的正常运行。</p><p></p><p>在这样的背景下，企业需要立刻转变传统观念，构建完整上云计划，将现有业务和技术架构迅速迁移至云端，才能有效应对线上挑战，通过云端架构实现降本增效目标，帮助企业渡过困难时期。然而，在开支缩减的大趋势下，怎样充分运用有限资金与人力资源，寻找上云捷径并快速取得成效是摆在管理者与技术团队面前的一大难题。</p><p></p><p></p><h2>一、从中后台到前台，企业上云要有全链路解决方案</h2><p></p><p></p><p>在云端数字化转型的浪潮中，通过转型取得可观收益的企业，往往都有以下共性——定制适合自身的上云方案；合理安排上云项目优先级；选择优秀的合作伙伴。其中，制定上云规划是转型的第一步，也是决定上云成败的关键所在。</p><p></p><p>企业上云一般有三大路径选项：自研、结合外部服务商升级已有架构、选择外部标准产品服务搭建全套云端架构。自研路径适合规模较大、资金实力雄厚的厂商，初创公司等缺乏历史沉淀的企业往往会选择完全依赖外部服务商的选项。相比之下，更多企业经营多年来已经建立了一定规模的 IT 基础架构，拥有相应的技术团队、流程与实践。这些企业更希望上云规划可以充分利用过去的投入，能够与现有的技术和业务流程平滑兼容过渡。新采购的云端基础设施产品和服务应该有着较低的学习门槛，让技术团队无需大量扩充也能顺利使用。</p><p></p><p>另一方面，云计算对于很多传统企业来说仍然是新鲜事物。无论是上层管理者还是技术部门领导都对云计算缺乏清晰的认知。这就导致很多企业在上云前缺乏清晰的规划，转型方案要么盲目追求大而全，要么束手束脚、行动缓慢。由于缺乏经验和专家指导，企业上云过程经常被突发奇想的决策牵着走，\"走一步算一步”，更不可能做到为企业现实环境和自身条件量身定制。</p><p></p><p>很多企业已经意识到了上述问题，对上云的紧迫性与自身能力的不足都有了相当程度的客观认识。决策层开始意识到，与优秀的云厂商深度合作来打造云端规划，是企业成功实现云端转型的必经道路。高水平的云厂商不仅能够提供业界领先的云计算产品与服务矩阵，更重要的是他们可以将自身服务各行业客户的经验总结并提炼成大量优秀实践，从而为每一位客户定制一条效费比最高的路径。当企业遇到障碍时，云厂商经验丰富的服务团队也能带来及时的帮助，帮助客户快速跨越瓶颈、应对风险。</p><p></p><p>在众多云厂商之中，华为云凭借深厚的技术底蕴、丰富的行业服务经历、平易近人的定价模式与一流的服务支持力量，赢得了金融、电信、政务、互联网、教育、零售、物流、工业制造、医疗健康等数十个行业数百万的企业客户。总结了大量客户的数字化转型落地实践成果后，华为云从旗下 220 多项云服务和 210 多项解决方案中，精选出了 9 大产品系列和 6 大解决方案，为企业上云提供了一套覆盖技术、业务、运维各部门需求的全链路规划。</p><p></p><p>企业上云，首先要构建云端基础设施。传统的本地服务器与单体服务无法适应云时代，线下数据库也需要迁移至云端以充分利用云计算能力。华为云提供了弹性云服务器 ECS，企业可随时在云端自助获取高性能计算服务，所有服务器均支持弹性伸缩。用户可通过 Web 页面或开放 API，同时管理数百甚至数千个弹性云服务器实例，并通过灵活的计费模式尽量节约成本。面对企业的数据库需求，华为云打造了 GaussDB、云数据库 RDS、文档数据库 DDS 等 10 款关系型、非关系型云数据库产品，以及多款数据库生态工具，使企业充分享受云端数据库的灵活扩展、高性能、低维护成本等优势。企业数据云原生化后，即可利用华为云的大数据解决方案完成计算、搜索与分析、数据可视化、数据治理与开发等任务，以较低的成本充分挖掘海量数据价值，创造新的业务收益。</p><p></p><p>有了云原生基础设施，企业网站、应用和业务上云均可通过华为云提供的上云解决方案快速迁移至云端。华为云的支持团队将与客户的开发、测试和运维团队充分合作，解决应用上云过程中的技术栈升级、流程变化等问题。面对企业非常关心的云端安全性主题，华为云则给出了云安全产品和网站安全一揽子解决方案，可全方位保护云端应用服务、云工作负载和数据资产，使企业 IT 部门能够实时掌握系统安全态势，应对潜在风险。</p><p></p><p>对于直接面向终端消费者与客户的企业而言，华为云提供的内容分发网络 CDN 产品系列与下载加速解决方案是提升用户线上体验的利器。企业可以凭借华为云 CDN 网络的高性能与一流覆盖水平为用户带来更低延时，下载加速方案则能显著缩短用户获取内容时的等待时间，提升用户满意度并降低流失率。为了有效控制企业云端服务的支出，华为云又提供了网络节省计划，可以节省最高 50% 的带宽费用，避免多余的成本开支和浪费情况。</p><p></p><p>企业内部的运营、业务和管理团队在疫情新常态下更需要完善的线上交流和支持环境。为此，华为云给出了云会议、云桌面产品，帮助企业建立高效率的线上办公、云端协作体系，从而大幅提升运营效率，对抗疫情带来的风险。华为云的时习知在线学堂还能有效应对云端协作、居家办公体系下员工的培训需求，IT 部门只需 10 分钟就可以建立一个线上学堂，灵活满足人力资源部门的各类要求。除此之外，华为云还提供 SparkPack 企业级 ERP 解决方案，帮助制造、零售企业简单轻松的启动数字化转型，实现“研产供销服管” 全业务增效体系，在应对变幻莫测的市场竞争时，能在成本与效率上拥有更大的底气。</p><p></p><p>以上产品和方案通过组合应用，可以覆盖绝大多数行业的应用场景。企业决策层可以根据自身需要选择部分或全部选项，走出最佳的上云路线。华为云还利用自身作为非数字原生企业数字化转型成功经验和丰富的客户数字化转型实践经验，构建了数字化诊断治理专家服务，为广大非互联网企业提供手把手指导和建议，是国内云厂商中独家提供，为企业的云端转型全过程保驾护航。</p><p></p><p></p><h2>二、降本增效，上云路上要关注三大重点</h2><p></p><p></p><p>在上云规划中，企业有限的投入要达到最大收益，一定需要区分轻重缓急，对重点领域优先投入，从而快速见效，为上云的长期过程打好基础。尤其在经济形势扑朔迷离的当下，制定合理的上云任务优先级更是决定企业上云成败的关键要素。华为云结合众多客户的实践经验，为企业上云总结出了三个需要重点关注的上云方案与产品：云会议、网络安全与下载加速。</p><p></p><p>上述三大重点的共性是保障企业内外部用户的优质体验。为内部用户带来高水平的体验意味着更高的工作效率、更低的成本支出与更少的错误和问题。外部用户获得优质体验则能为企业带来更多业务收益，使前期的产品和服务研发投入获得最大回报。换句话说，这三大项目重点可以让企业迅速从业务侧看到上云成效，这也是管理者最希望看到的结果。</p><p></p><p><a href=\"https://www.infoq.cn/article/8TTGkRGdOOUjHOKwSED2\">华为云</a>\"会议产品结合了华为云会议宝等全系列智能协作终端，为客户提供全场景端云协同视频会议解决方案，满足跨地区、跨企业、跨终端的智能沟通协作需求。云会议支持用户使用手机、PC、Mac 设备多端接入，随时随地参加线上协作。云会议还融合了直播体验，结合硬件终端和协作大屏，能够构建超过 5000 人的实时在线互动环境。云会议的 API 和 SDK 则带来了与企业服务集成的能力，进一步完善云端协作生态。最后，华为云还提供了“会前预防、会中保障、会后总结”的保障服务，保证参会者拥有最佳的线上互动效果。</p><p></p><p>华为云会议能够快速帮助员工构建居家办公、随处办公环境，有效节约办公场所开支、出差费用，使企业能够在复杂环境下维持高效运营能力。在云会议帮助下，企业在复杂环境中也能持续开展业务，按期向客户交付产品，与客户建立稳定的反馈渠道。</p><p></p><p>运营能力得到保障后，企业在交付产品后就需要考虑如何为终端用户带来稳定的应用服务。网络安全与下载加速两大要素就是这一领域的关键所在。</p><p></p><p>网络安全是确保企业业务持续性的关键能力，低成本、高水平的网络安全解决方案可以让企业在竞争中建立业务优势，避免随处可见的数据泄露、黑客攻击、线上欺诈等风险，使企业上云免除后顾之忧。华为云的网站安全方案包含 DDoS 高防 AAD、Anti-DDoS 流量清洗、Web 应用防火墙 WAF、云防火墙 CFW 等产品，在网络和应用层有效应对 DDoS 攻击、识别恶意请求特征、防御未知威胁并管控网络流量。网站安全方案支持按需弹性扩容，并结合了深度学习技术增强防护能力，保障企业线上站点和应用持续稳定运行，防范敏感数据的泄露和恶意利用风险。</p><p></p><p>有了持续稳定的应用，下一步就是提升应用的用户端体验。对于<a href=\"https://www.infoq.cn/article/FgogdjehRCRt9QjD4fMG\">企业</a>\"线上业务应用而言，下载加速是改善用户使用感受的必要选项。用户获取线上内容的延迟直接影响业务成交率，为此需要能够一键部署、自由伸缩、服务稳定的下载加速方案，让企业开发运维团队将更多精力放在核心产品研发改进上。华为云的下载加速解决方案结合了动态加速与静态加速技术，利用覆盖全球的近 3000 节点、150Tbps 的带宽能力为各类型业务保驾护航，下载加速方案具备智能路由、动静分离、协议优化、安全加速、私有协议加速等特性，支持各大主流运营商，为企业分布在全球各地的用户提供高速、稳定的业务访问体验。</p><p></p><p>从内部运营到终端用户体验，华为云的三大产品方案能够打通业务全链路，帮助企业迈出全面上云转型的关键第一步。通过三大项目的改造升级，企业能够迅速获得上云收益，实实在在看到成本下降、业务收益增长的成果。在这一过程中，管理和技术团队还能充分熟悉上云转型涉及的各种流程、费用和人员需求，为接下来进一步上云的规划做好准备。取得第一阶段的成功后，企业接下来的上云之路自然能走的更顺利，各部门和人员也会对转型规划充满信心和期待。</p><p></p><p></p><h2>三、抢占上云高地，增强竞争力从现在做起</h2><p></p><p></p><p>企业上云之路并不平坦，也绝非一日之功，但企业不需要为此踌躇不前，而是应该从痛点入手选择适合自己的上云路径。复杂的内外部环境虽然为上云转型设置了很多障碍，但从另一方面来说这也是推动企业变革的最大动力。</p><p></p><p>企业决策层需要意识到，企业上云的根本目标是提升竞争力，为用户带来更好的体验，获得更大的业务收益。如果为了一时的成本节约而取消或暂缓上云进程，结果会对企业的长期前景带来巨大的伤害。相反，早日完成上云规划能够让企业在市场上建立先手优势，从而应对市场低迷时期的风险与挑战，为下一波繁荣浪潮积蓄更多能量。</p><p></p><p>一旦开启上云进程，企业就需要选择优秀的合作伙伴。像<a href=\"https://www.infoq.cn/article/absyH0TSbOjZGChkUz3w\">华为</a>\"云这样实力雄厚的云厂商是不错的选择，企业可以通过他们定制满足自身需求的上云方案，从容应对上云道路上的种种障碍，并迅速看到上云带来的降本增效的成果。</p><p></p><p>总之，未来，每一家企业都应该重新审视自身对云端数字化转型的态度、规划与期望。抢占上云高地、增强企业竞争力不应该停留在会议文件和宣传口号上，而需要企业上下通力合作，共同做出实际行动。</p><p></p><p></p><p>看前方，也要注意脚下。现时已至 2022 年末，千行百业也迎来了忙碌的采购高峰期，各企业对于云产品的需求格外旺盛。为了能够帮大家搭上今年最后一波上云好时机，华为云推出“华为云双 12 营销季”活动。12 月 9 日 -12 月 31 日，华为云准备了九大热门产品和六大热门解决方案的超值优惠，全方位满足企业不同阶段、多种场景的上云、用云需求，让企业尽享“实惠更实用”的云产品及服务，一起来看看吧↓</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d6/d6869dc5099af8f86f47b8e7f2a3f472.png\" /></p><p></p>",
    "publish_time": "2022-12-20 14:06:57",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "「Go工具箱」一文读懂主流web框架中路由的实现原理",
    "url": "https://www.infoq.cn/article/0c2d65a7c72147dc457af5007",
    "summary": "<p>大家好，我是渔夫子。本号新推出「Go工具箱」系列，意在给大家分享使用go语言编写的、实用的、好玩的工具。同时了解其底层的实现原理，以便更深入地了解Go语言。</p><p></p><h2>一、什么是路由</h2><p></p><p>路由，就是url地址到业务处理代码的映射。当用户输入一个url地址时，服务器该知道该用户返回什么内容。比如，当用户点击登录时，服务器应该做登录相关的事情，并给用户返回登录成功或失败的页面。当用户点击退出时，服务器应该做和退出相关的事情（比如清理用户登录的数据），并返回给用户退出之后的页面。</p><p></p><p>一个url到一个具体的处理函数之间的映射叫做一条路由。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/6d/6decf088ea6d29afbee3c19acc63c4de.png\" /></p><p></p><p>多条路由组成路由表。路由表主要用于路由查找，根据不同的路由表的组织形式，可以有不同的查找方法。最简单的路由表就是使用map。直接以key-value的形式进行匹配即可。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/e9/e98393a4afcc24a509f1d169d8360fad.png\" /></p><p></p><p>给定一个url，找到对应的处理函数的过程叫做路由查找。路由器就是用来管理路由表以及进行路由查找的。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/0b/0bda1fefe4d9adbf3a91bc13466c85c0.png\" /></p><p></p><p>所以，在web系统中一个路由系统由路由、路由表、路由匹配三部分功能组成。</p><p></p><h2>二、基于映射表的路由实现</h2><p></p><p>go内建标准包net/http中路由的实现是基于映射表实现的。也是最简单的路由实现。本节我们就来看来http请求的处理流程以及内建包默认的路由实现原理。</p><p></p><h3>2.1 http的处理流程</h3><p></p><p>首先，我们来看下http包是如何处理请求的。通过以下代码我们就能启动一个http服务，并处理请求：</p><p></p><p><code lang=\"go\">import (\n  \"net/http\"\n)\n\nfunc main() {\n    // 指定路由\n  http.Handle(\"/\", &amp;HomeHandler{})\n\n  // 启动http服务\n  http.ListenAndServe(\":8000\", nil)\n}\n\ntype HomeHandler struct {}\n\n// 实现ServeHTTP\nfunc (h *HomeHandler) ServeHTTP(response http.ResponseWriter, request *http.Request) {\n  response.Write([]byte(\"Hello World\"))\n}\n</code></p><p></p><p>当我们输入http://localhost:8000/的时候，就会走到HomeHandler的ServeHTTP方法，并返回Hello World。</p><p></p><p>那这里为什么要给HomeHandler定义ServeHTTP方法呢？或者说为什么会走到ServeHTTP方法中呢？</p><p></p><p>我们顺着http.ListenAndServe方法的定义：</p><p></p><p><code lang=\"go\">func ListenAndServe(addr string, handler Handler) error\n</code></p><p></p><p>发现第二个参数是个Handler类型，而Handler是一个定义了ServeHTTP方法的接口类型：</p><p></p><p><code lang=\"go\">type Handler interface {\n  ServeHTTP(ResponseWriter, *Request)\n}\n</code></p><p></p><p>似乎有了一点点关联，HomeHandler类型也实现了ServeHTTP方法。但我们在main函数中调用http.ListenAndServe(\":8000\", nil)的时候第二个参数传递的是nil，那HomeHandler里的ServeHTTP方法又是如何被找到的呢？</p><p></p><p>我们接着再顺着源码一层一层的找下去可以发现，在/src/net/http/server.go的第1930行有这么一段代码：</p><p></p><p><code lang=\"go\">serverHandler{c.server}.ServeHTTP(w, w.req)\n</code></p><p></p><p>有个serverHandler结构体，包装了c.server。这里的c是建立的http连接，而c.server就是在http.ListenAndServe(\":8000\", nil)函数中创建的server对象：</p><p></p><p><code lang=\"go\">func ListenAndServe(addr string, handler Handler) error {\n  server := &amp;Server{Addr: addr, Handler: handler}\n  return server.ListenAndServe()\n}\n</code></p><p></p><p>server中的Handler就是http.ListenAndServe(\":8000\", nil)传递进来的nil。</p><p></p><p>好，我们进入 serverHandler{c.server}.ServeHTTP(w, w.req)函数中再次查看，就可以发现如下代码：</p><p></p><p><code lang=\"go\">func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {\n  handler := sh.srv.Handler\n  if handler == nil {\n    handler = DefaultServeMux\n  }\n  ...\n\n  handler.ServeHTTP(rw, req)\n}\n</code></p><p></p><p>/src/net/http/server.go的第2859行到2862行，就是获取到server中的Handler，如果是nil，则使用默认的DefaultServeMux，然后调用了hander.ServeHTTP方法。</p><p></p><p>继续再看DefaultServeMux中的ServeHTTP方法，在/src/net/http/server.go中的第2416行，发现有一行h,_ := mux.Handler(r)和h.ServeHTTP方法。这就是通过请求的路径查找到对应的handler，然后调用该handler的ServeHTTP方法。</p><p></p><p><code lang=\"go\">func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {\n  if r.RequestURI == \"*\" {\n    if r.ProtoAtLeast(1, 1) {\n      w.Header().Set(\"Connection\", \"close\")\n    }\n    w.WriteHeader(StatusBadRequest)\n    return\n  }\n  h, _ := mux.Handler(r)\n  h.ServeHTTP(w, r)\n}\n</code></p><p></p><p>在一开始的实例中，就是我们的HomeHandler的ServeHTTP方法。也就是说ServeHTTP方法是net/http包中规定好了要调用的，所以每一个页面处理函数都必须实现ServeHTTP方法。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/3f/3fbdd90a8e46985436c34a1b85437e1b.png\" /></p><p></p><p>同时也说明，net/http包中的路由是在DefaultServeMux对象中实现的，该对象是一个ServeMux结构体类型，接下来我们看ServeMux路由的具体实现。</p><p></p><h3>2.2 net/http包中路由的实现</h3><p></p><p>在net/http包中实现路由的机构提是ServeMux，其结构定义如下。</p><p></p><p><code lang=\"go\">type ServeMux struct {\n  mu    sync.RWMutex\n  m     map[string]muxEntry\n  es    []muxEntry // slice of entries sorted from longest to shortest.\n  hosts bool       // whether any patterns contain hostnames\n}\n</code></p><p></p><p>结构体字段很简单，我们重点看m变量，是一个map类型，即key-value结构，就是我们所说的路由表。key就是路由的路径，value是一个muxEntry对象，muxEntry结构如下：</p><p></p><p><code lang=\"go\">type muxEntry struct {\n  h       Handler\n  pattern string\n}\n</code></p><p></p><p>pattern是对应的路径，h就是对应的处理函数。当我们调用http.Handle(\"/\", &amp;HomeHandler{})�进行路由注册时候，实质上就是将路径和HomeHandler对象构建成一个muxEntry对象，然后加入到ServeMux的m中。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/31/313d217de66f573f0f295a13bd62d3ca.png\" /></p><p></p><p>接下来我们再看路由的查找，既然路由表是有map实现的，那么路由的查找过程自然就是通过路径从map中查找对应的muxEntry，然后获取对应的handler即可。该实现就是在/src/net/http/server.go中的第2416行的mux.Handler(r)进行的。</p><p></p><p>以上就是net/http包中自己路由的实现。非常简单，同时也意味着功能有限。比如不能对路由进行分组、不能限定路由的请求方法（GET、POST或其他）、不能对路由加中间件等等。 这也就给第三方包提供了再次实现的机会。</p><p></p><h2>三、基于正则表达式的路由实现</h2><p></p><p></p><h3>3.1 gorilla/mux包简介</h3><p></p><p>该包是基于正则表达式实现的路由。该路由支持分组、restful风格路径的定义、绑定路由请求的方法（GET、POST等）、限定路径使用http还是https协议等功能。我们看下其基本情况。</p><p></p><p></p><p></p><h3>3.2 基本使用</h3><p></p><p>由于该包支持的路由规则比较多，所以我们先从最简单的例子开始看一下基本使用，然后再通过分析其实现原理看各种规则是如何支持的。</p><p></p><p><code lang=\"go\">package main\n\nimport (\n  \"fmt\"\n  \"net/http\"\n\n  \"github.com/gorilla/mux\"\n)\nfunc main() {\n  r := mux.NewRouter()\n  r.HandleFunc(\"/\", HomeHandler)\n  r.HandleFunc(\"/products\", ProductsHandler)\n  //定义restful风格的路径，例如/product/12345\n  r.HandleFunc(\"/product/{id:[0-9]+}\", ProductHandler)\n\n  http.ListenAndServe(\":8000\", r)\n}\n\nfunc HomeHandler(response http.ResponseWriter, request *http.Request) {\n  response.Write([]byte(\"Hi, this is Home page\"))\n}\n\nfunc ProductsHandler(response http.ResponseWriter, request *http.Request) {\n  response.Write([]byte(\"Hi, this is Product page\"))\n}\n\nfunc ProductHandler(response http.ResponseWriter, request *http.Request) {\n  vars := mux.Vars(request)\n    // 获取产品的ID值。\n  id := vars[\"id\"]\n\n  response.Write([]byte(\"Hi, this is product:\" + id))\n}\n</code></p><p></p><h3>3.3 实现原理分析</h3><p></p><p>首先我们通过mux.NewRouter()方法返回了一个Router结构体对象。该结构体对象也实现了ServeHTTP方法，在该方法中实现了对路由的匹配和转发。所以覆盖作为http.ListenAndServe的第二个参数，替代了默认的路由分发对象DefaultServeMux。以下展示了Router的ServeHTTP方法对路由的匹配和分发部分的代码，其他代码省略。</p><p></p><p><code lang=\"go\">func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n    ...\n  var match RouteMatch\n  var handler http.Handler\n    // 路由匹配\n  if r.Match(req, &amp;match) {\n    handler = match.Handler\n    req = requestWithVars(req, match.Vars)\n    req = requestWithRoute(req, match.Route)\n  }\n\n  ...\n    \n  // 路由分发\n  handler.ServeHTTP(w, req)\n}\n</code></p><p></p><p>本质上是和默认的路由分发器DefaultServeMux的实现是一样的。不同的是路由的管理以及匹配上。</p><p></p><p>接下来我们看下Router结构体。如下：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d0/d03836d9ccfb7e93bba1e54793c04908.png\" /></p><p></p><p>这里我们只列出来核心的字段，省略了一些辅助字段。这里有几个主要的字段：</p><p></p><p>Router中的routes：Route切片类型，角色是路由表，存储所有的路由。**Route：**一个具体的路由，handler字段存储的是具体的处理函数，同时每个路由的路径是在最后的routeRegexp结构体中的。**matchers字段：**切片类型，存储了该路由下的所有要匹配的规则。matchers的类型是一个matcher接口，定义了Match方法。其中routeRegexp结构体实现了该方法，所以一个routeRegexp实例就是一个matcher。**routeRegexp结构体：**该结构体代表了路由中具体的路径的匹配规则。将路由中的路径转换成对应的正则表达式，存储与regexp字段中。</p><p></p><p>routeRegexp结构体中的主要字段分别如下：</p><p></p><p>**template：**保存的是路由的路径模版。比如r.HandleFunc(\"/product/{id:[0-9]+}\", ProductHandler)中，则是\"/product/{id:[0-9]+}\"**regexpType：**正则类型，目前支持regexpTypePath、regexpTypeHost、regexpTypePrefix、regexpTypeQuery四种类型。比如r.HandleFunc(\"/product/{id:[0-9]+}\", ProductHandler)就是路径匹配regexpTypePath。而r.Host(\"www.example.com\")就是域名匹配regexpTypeHost。稍后我们会一一介绍。**regexp：**是根据路由中的模版路径构造出来的正则表达式。以\"/product/{id:[0-9]+}\"为例，最终构造的正则表达式是 ^/product/(?P[0-9]+)$�reverse：**varsN：**是路径模式中花括号{}中的变量个数。以\"/product/{id:[0-9]+}\"为例，varsN则等于[]{\"id\"}。**varsR：**是路径模式中每个花括号{}对应的正则表达式。以\"/product/{id:[0-9]+}\"为例，varsR则等于[]{\"^[0-9]+$\"}。如果路由中是设置r.HandleFunc(\"/product/{id}\", ProductHandler)，varsR的元素则是[]{\"^[^/]+�\"}的正则表达式。</p><p></p><p>根据路由表及路由的结构，具体的路由匹配查找基本过程如下：第一步，从Router.routes开始依次循环第二步，从每个路由中的matchers中循环，看请求的路径是否符合matchers中的每一项规则，如果都匹配，则说明找到了该路由，否则继续步骤1。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/4f/4f13aaad7c30f54713ae1a2d6246335a.png\" /></p><p></p><p>接下来，我们看看该路由是如何支持各种功能的。</p><p></p><h3>3.4 路由支持的功能及对应的正则</h3><p></p><p></p><h4>3.4.1 匹配特定域名或子域名</h4><p></p><p><code lang=\"go\">r := mux.NewRouter()\n// Only matches if domain is \"www.example.com\".\nr.Host(\"www.example.com\")\n// Matches a dynamic subdomain.\nr.Host(\"{subdomain:[a-z]+}.example.com\")\n</code></p><p></p><p>我们先看r.Host(\"www.example.com\")的路由。在routeRegexp结构体中，regexp值会是正则表达式\"^www\\.example\\.com$，regexpType字段是regexpTypeHost。同时赋值给routeRegexpGroup中的host字段。</p><p></p><p>从路由表Router.routes中依次匹配本次请求的时候，发现route.regexpType字段是域名的正则，则从请求中获取当前的host，然后跟routeRegexp.regexp正则表达式进行匹配。如果匹配成功则继续匹配后面的路由，否则直接匹配失败。</p><p></p><p>再来看匹配子域名r.Host(\"{subdomain:[a-z]+}.example.com\")的情况。在routeRegexp结构体中，regexp值会是正则表达式\"^(?P[a-z]+)\\.example\\.com$，regexpType字段是regexpTypeHost。同时赋值给routeRegexpGroup中的host字段。匹配过程和上述过程一样，不再重复介绍。</p><p></p><h4>3.4.2 给路径增加前缀</h4><p></p><p><code lang=\"go\">r.PathPrefix(\"/products/\")\n</code></p><p></p><p>顾名思义，就是只有路径中是以/products为前缀的才能匹配到该路由。该路由的设置最终编译成的正则表达式是^/products。这里注意该表达式中结尾并没有结尾符号 $。其匹配过程和上述一致。</p><p></p><h4>3.4.3 限制路由的请求方法（GET、POST等）</h4><p></p><p><code lang=\"go\">r.Methods(\"GET\", \"POST\")\n</code></p><p></p><p>对请求方法的限制 是不经过正则，而是将允许的方法（GET、POST）转换成一个methodMatcher�类型，该类型本质上是一个字符串切片，并且实现了Match方法，也就是matcher接口。然后将其加入到该路由的matchers中，在路由匹配时看当前的请求是否满足该路由的这条规则。其定义如下：</p><p></p><p><code lang=\"go\">type methodMatcher []string\n\nfunc (m methodMatcher) Match(r *http.Request, match *RouteMatch) bool {\n  return matchInArray(m, r.Method)\n}\n</code></p><p></p><h4>3.4.4 支持路由分组</h4><p></p><p><code lang=\"go\">userRouter := r.PathPrefix(\"/user\").Subrouter()\nuserRouter.HandleFunc(\"/info\", HomeHandler)\n</code></p><p></p><p>通过.Subrouter()函数就能实现一个子路由表，在该子路由表下注册的所有路由都会遵循子路由上的公共设置，比如前缀。如上述例子/info的完整路径就是/user/info指向HomeHandler。</p><p></p><p>我们查看Subrouter函数的源码，实际上是新建了一个Router结构体，而Router结构体实现了Match函数，即matcher，所以也会将该matcher加入到r.PathPrefix这个路由的matchers中。相当于在路由中有建了一个专属的路由表。以下是Router的Match函数实现，我们看到循环到该matcher时，循环子路由表的routes，再对每个子路由依次进行匹配：</p><p></p><p><code lang=\"go\">func (r *Router) Match(req *http.Request, match *RouteMatch) bool {\n  for _, route := range r.routes {\n    if route.Match(req, match) {\n      // Build middleware chain if no error was found\n      if match.MatchErr == nil {\n        for i := len(r.middlewares) - 1; i &gt;= 0; i-- {\n          match.Handler = r.middlewares[i].Middleware(match.Handler)\n        }\n      }\n      return true\n    }\n  }\n    ...//省略代码\n}\n</code></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/af/af0de5eb3bb8661f72d7268d326090d9.png\" /></p><p></p><h4>3.4.5 支持中间件</h4><p></p><p><code lang=\"go\">//  定义中间件\nfunc loggingMiddleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        // Do stuff here\n        log.Println(r.RequestURI)\n        // Call the next handler, which can be another middleware in the chain, or the final handler.\n        next.ServeHTTP(w, r)\n    })\n}\n\nr := mux.NewRouter()\nr.HandleFunc(\"/\", HomeHandler)\n// 使用中间件\nr.Use(loggingMiddleware)\n\nfunc HomeHandler(response http.ResponseWriter, request *http.Request) {\n  response.Write([]byte(\"Hi, this is Home page\"))\n}\n</code></p><p></p><p>在该示例中，首先定义了一个中间件loggingMIddleware，然后使用Use函数将中间件加入到了Router中。</p><p></p><p>中间件的实现原理实际上是将原本要执行的handler包装到中间件的handler中。先执行中间件的handler逻辑，然后再执行原本的handler。以上述代码为例，会将HomeHandler传递给loggingMiddleware的next参数。执行的时候从第4行开始执行，最后才是第7行，即HomeHandler的代码逻辑。如下图：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/97/974599287da84687de5da02db4d4222c.png\" /></p><p></p><p>接下来我们看看中间件是如何实现一层层包裹的。</p><p></p><p>我们先看r.Use函数的定义:</p><p></p><p><code lang=\"go\">func (r *Router) Use(mwf ...MiddlewareFunc) {\n  for _, fn := range mwf {\n    r.middlewares = append(r.middlewares, fn)\n  }\n}\n</code></p><p></p><p>发现中间件的类型是MiddlewareFunc，该类型的定义如下：</p><p></p><p><code lang=\"go\">type MiddlewareFunc func(http.Handler) http.Handler\n</code></p><p></p><p>中间件本质上是一个函数类型，输入和输出都是一个http.Handler，同时MiddlewareFunc中实现了一个Middleware�的方法：</p><p></p><p><code lang=\"go\">func (mw MiddlewareFunc) Middleware(handler http.Handler) http.Handler {\n  return mw(handler)\n}\n</code></p><p></p><p>我们再看路由匹配时，执行中间件的逻辑：</p><p></p><p><code lang=\"go\">func (r *Router) Match(req *http.Request, match *RouteMatch) bool {\n  for _, route := range r.routes {\n    if route.Match(req, match) {\n      // Build middleware chain if no error was found\n      if match.MatchErr == nil {\n        for i := len(r.middlewares) - 1; i &gt;= 0; i-- {\n          match.Handler = r.middlewares[i].Middleware(match.Handler)\n        }\n      }\n      return true\n    }\n  }\n    ...//省略代码\n}\n</code></p><p></p><p>在第7行，执行中间件的Middleware函数。以r.HandleFunc(\"/\", HomeHandler)使用loggingMiddleware中间件为例，match.Handler是HomeHandler，loggingMiddleware.Middleware即为loogingMIddleware(HomeHandler)，该函数返回的是一个新的handler：</p><p></p><p><code lang=\"go\">http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        // Do stuff here\n        log.Println(r.RequestURI)\n        // Call the next handler, which can be another middleware in the chain, or the final handler.\n        next.ServeHTTP(w, r)\n})\n</code></p><p></p><p>那么，在具体执行的时候，就是先执行该handler的业务逻辑，即log.Println(r.RequestURI)，然后执行next.ServerHTTP逻辑，即HomeHandler.ServeHTTP的逻辑。</p><p></p><p>这就是中间件对handler的包装及执行过程。其他更多功能可自行查看gorilla/mux包的源码。</p><p></p><h2>4 基于tries结构的路由实现</h2><p></p><p></p><h3>4.1 gin框架中的路由</h3><p></p><p>大名鼎鼎的gin框架采用的就是前缀树结构实现的路由。我们先来看一下gin框架中路由是如何定义的。</p><p></p><p><code lang=\"go\">package main\n\nimport (\n  \"github.com/gin-gonic/gin\"\n)\nfunc main() {\n  g := gin.New()\n  \n  g.POST(\"/abc/info\", InfoHandler)\n  g.POST(\"/abc/info/detail\", InfoHandler)\n  g.POST(\"/abc/list\", HomeHandler)\n  g.Run(\":8000\")\n}\n\nfunc HomeHandler(ctx *gin.Context) {\n  ctx.Writer.Write([]byte(\"Hi, this is Home page\"))\n}\n\nfunc InfoHandler(ctx *gin.Context) {\n  ctx.Writer.Write([]byte(\"Hi, this is info\"))\n}\n</code></p><p></p><p>很简单，首先通过gin.New()初始化一个gin对象g，然后通过g.POST或g.GET等方法就可以注册路由。很明显，路由注册过程也限制了请求的方法。 当然，还有一个方法是允许任何请求方法都能访问该路径的，就是Any：</p><p></p><p><code lang=\"go\">g.Any(\"/\", HomeHandler)\n</code></p><p></p><p>Any方法本质上是定义了一组方法名，然后依次调用对应的方法将该路由进行注册，如下：</p><p></p><p><code lang=\"go\">var  anyMethods = []string{\n    http.MethodGet, http.MethodPost, http.MethodPut, http.MethodPatch,\n    http.MethodHead, http.MethodOptions, http.MethodDelete, http.MethodConnect,\n    http.MethodTrace,\n  }\n\n// Any registers a route that matches all the HTTP methods.\n// GET, POST, PUT, PATCH, HEAD, OPTIONS, DELETE, CONNECT, TRACE.\nfunc (group *RouterGroup) Any(relativePath string, handlers ...HandlerFunc) IRoutes {\n  for _, method := range anyMethods {\n    group.handle(method, relativePath, handlers)\n  }\n\n  return group.returnObj()\n}\n</code></p><p></p><p>接下来，我们分析下路由实现以及匹配的过程。</p><p></p><h3>4.2 前缀树路由的实现原理</h3><p></p><p>相比较map/hash字典实现的优点：利用字符串公共前缀来减少查询时间，减少无谓的字符串比较</p><p></p><h4>4.2.1 路由中限制请求方法的实现</h4><p></p><p>我们先看gin框架中的路由是如何对请求方法做限制的。 在gin框架中，路由树的构建是基于方法的。每种方法一棵路由树。如下：</p><p></p><p><code lang=\"go\">type methodTree struct {\n  method string\n  root   *node\n}\n\ntype methodTrees []methodTree\n</code></p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ad/ad3c820a8c6cbb62704d59796bf40927.png\" /></p><p></p><p>例如，上述示例中的g.POST(\"/abc/info\", InfoHandler)路由，只会注册到POST方法的路由树中。若通过GET方法请求该路径，则在搜索的时候，在GET方法的路由树中就找不到该路由。这样就起到了通过路由限制请求方法的作用。</p><p></p><p>而g.Any方法注册的路由，相当于在所有的方法路由中都注册了一遍，因此，使用任何方法都能找到对应的路由。</p><p></p><h4>4.2.2 路由树节点的数据结构</h4><p></p><p><img src=\"https://static001.geekbang.org/infoq/b1/b147889ed160783df17d31acea619d57.png\" /></p><p></p><p>前缀树中的路由都是基于这个node数据结构来进行构建的。其中包含了一个路由中的基本元素：路径fullPath、对应的处理函数handlers。其中handlers包含了中间件处理函数，因此这里使用一个handlersChain表示。</p><p></p><p>另外一个关键字段是children，具有相同路径前缀的子节点通过children节点来构成父、子关系。</p><p></p><p>接下来我们路由树是如何基于node节点进行构建的。</p><p></p><h4>4.2.3 路由树的构建</h4><p></p><p>首先，我们看第一个路由的注册。</p><p></p><p><code lang=\"go\">  g.POST(\"/abc/info\", InfoHandler)\n</code></p><p></p><p>因为是第一个路由注册，路由树是空的。所以直接构建一个node节点，然后将该node节点作为POST方法路由树的根节点插入即可。如下图：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ab/ab2cd3446fec7cc526bed195a8f7c771.png\" /></p><p></p><p>好，我们接着看接着注册第二个路由：</p><p></p><p><code lang=\"go\">  g.POST(\"/abc/info/detail\", DetailHandler)\n</code></p><p></p><p>我们发现，这个路由的特点是和路由\"/abc/info\"有共同的前缀，所以会将该路由作为第一个路由的子节点放到children中。如下图：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/65/652ef39044e3f6dde0f9740c0e0593fd.png\" /></p><p></p><p>这里主要有三个变化：一个是根节点的priority由1变成了2；一个是children中多了一个子节点路由；最后一个是indices字段的值变成了\"/\"，这个是第一个子节点的path字段的第一个字符，用于匹配时索引使用。在子节点中，要注意的是path的值，因为前缀是\"/abc/info\"了，所以这里path是\"/detail\"。但fullPath依然是注册时完整的路径。</p><p></p><p>接下来，我们再注册第三个路由：</p><p></p><p><code lang=\"go\">  g.POST(\"/abc/list\", ListHandler)\n</code></p><p></p><p>这个路由的特点是和前两个路由有共同的前缀\"/abc/\"，所以首先会将现在的根节点进行拆分，拆分成\"/abc/\" 和\"info\"。而info和原来的\"/abc/info/detail\" 又有共同的前缀info，所以原来的\"/abc/info/detail\"就变成了info的子节点。而\"/abc/list\"除去前缀\"/abc/\"后，剩余\"list\"子节点，作为\"/abc/\"的子节点。如下：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/ba/ba55d2e6246676bf96c1175a9d4038ef.png\" /></p><p></p><p>那么，按节点组成的路由树就如下所示：</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/d4/d4917411671d346791c6ccddf86f9278.png\" /></p><p></p><p>这里，我们首先看根节点的变化：</p><p></p><p>handlers变为nil。因为该节点不是一个具体的路径，只是一个前缀，所以具体的handler下移到了子节点info节点。path变为了前缀\"/abc/\"。indices字段值变为了\"il\"，其中i是第一个子节点中path字段的第一个字符，l是第二个子节点中path字段的第一个字符。priority字段变成3：代表从自身开始及子节点共有4个。children字段变成了两个直接子节点。fullPath字段变为了\"/abc/\"。</p><p></p><p>其次，是从原根节点中拆分出一个info节点。最后是detail节点成为info节点的子节点。</p><p></p><p>以上就是路由树的构建过程。更细节的构造，有兴趣的同学可以查看源码进一步了解。</p><p></p><h2>5 总结</h2><p></p><p>本文总结了3中路由的实现。路由本质上就是将请求的路径和对应的处理函数一一对应。通过路径查找到处理函数的过程。不同框架基于不同的数据结构实现了路由表以及匹配过程。希望本文对大家理解web框架的路由有所帮助。</p><p></p><p>---特别推荐---</p><p>特别推荐：一个专注go项目实战、项目中踩坑经验及避坑指南、各种好玩的go工具的公众号，「Go学堂」，专注实用性，非常值得大家关注。点击下方公众号卡片，直接关注。关注送《100个go常见的错误》pdf文档。</p>",
    "publish_time": "2022-12-20 08:46:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "NGINX Sprint China 2022",
    "url": "https://www.infoq.cn/article/Qd24ym3Ga9wf07v0Ebbb",
    "summary": "<p>NGINX Sprint China 2022 是一年一度 NGINX Sprint 全球线上大会的本地分支版本，也是 F5 NGINX 中国区全年最盛大的旗舰会议。在上午的议程中，来自全球各地的十几位顶尖技术专家将与你分享最热门的行业趋势以及 NGINX 的最新动态，并探讨与 NGINX 以及更多热门开源项目相关的行业案例和最佳实践。</p>\n<h2><strong>你将获得</strong></h2>\n<ul>\n<li>通过主题演讲了解NGINX构建并扩展现代应用的愿景，以及我们如何通过开源工具将这样的愿景带入生活。</li>\n<li>跟随社区领袖了解最新的行业趋势和热门观点，我们的技术专家也将分享 NGINX的最新动态和最热产品。</li>\n<li>通过现场演示和动手实操深入探索 NGINX 的技术细节和最佳实践，并且可以通过聊天区与社区中的开发者和技术爱好者实时交流互动。</li>\n</ul>",
    "publish_time": "2022-12-20 16:37:17",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "颠覆开发模式的创新发布背后，我看见了云计算的下一个十年",
    "url": "https://www.infoq.cn/article/os4Ol63uVtOokdWQmpOZ",
    "summary": "<p>2022，在云计算的历史上是非常特殊的一年。基础设施加速创新和迭代、Serverless 迎来里程碑式的更新、数据实现 Zero ETL 集成且数据治理能力显著升级、人工智能持续加成被应用到更加丰富的场景...... 开发者的开发模式因为这些 <a href=\"https://www.infoq.cn/article/0O8eBz5ZJAbO3EiTbYwR\">re:Invent </a>\"创新的推动将产生颠覆式的改变，云计算也即将开启下一个十年的全新篇章。</p><p></p><p>在今年年末、re:Invent 中国行城市巡展活动开启前夕这个关键的时间节点，InfoQ 总编辑王一鹏独家专访了亚马逊云科技大中华区解决方案架构部总监代闻。本次专访不仅仅聚焦于最新发布的产品及服务，同时也从技术的实践与落地、创新与需求等多维度视角出发，代闻以其作为亚马逊云科技产品创新“领航员”的独特视角，向我们剖析了亚马逊云科技能够持续不断保持创新的动力所在，透过这次的深度对话，相信大家能够更加清晰地认识云计算的现阶段发展及未来趋势。</p><p></p><p></p><p></p><p></p><h2>云基础架构的构建之路</h2><p></p><p></p><p>InfoQ：本次 re:Invent 大会 Nitro v5 、Graviton 3E 系列芯片是很多人期待的发布，那么，对行业有何意义，我们应该如何去理解现在整个云计算产业在硬件方面的更新？</p><p></p><p>代闻：<a href=\"https://www.infoq.cn/article/4TZBTcJ6JGCjWKoCh1Cu\">Nitro v5 、Graviton 3E </a>\"系列芯片的发布反映出当前的一个大趋势 —— 想提供一流的云服务，一定要具备底层硬件能力。只有通过底层充足的支撑和不断的创新，才能满足客户在云计算方面的需求。当然，创新不是凭空而来的，是由需求推动的。之前在技术圈子经常会说：好的软件工程师会给自己设计硬件。其实在云的时代也一样，一个优秀的云厂商，它在满足客户需求的时候，哪些是应该软件来做，哪些是应该硬件来做，需要良好的规划和路线。大家现在看到的 Nitro v5、 Graviton 3E，就是亚马逊云科技在这样的思路上，一直不断往前迭代的重大更新。</p><p></p><p>Nitro v5 进一步印证了硬件支撑虚拟化的技术路线，同时把安全做得更加牢靠。Graviton 3E 是在 ARM CPU 的这条路上又一个比较有里程碑意义的发布。之前有很多的机构都讲过，ARM 在数据中心里边的占比会越来越高，而亚马逊云科技真正把这个事情做出来，而且实现了量产，而且可以支撑客户的生产业务。到现在 Graviton 3E 其实是第四次发布，印证了 ARM 不仅仅是一个可选项，它现在变成我们要降本增效、要满足更多高性能场景的很重要的选项。</p><p></p><p>InfoQ：云计算已经步入硬件主导性能提升的时代了吗？这种说法是正确的吗？</p><p></p><p>代闻：我可能不是从这个角度来看这个事情。云，其实是个服务，为了提供服务，你得有软件、有硬件、有算法，以及后台运营等等。硬件不是为了创新而创新，是因为用通用的硬件加软件优化的方式已经不够高效了，或者是内部底层功能做起来不够灵活了，跟不上创新速度了，所以反过来才做的硬件。</p><p></p><p>亚马逊云科技数据中心内部，最开始的时候也是用的商用的路由器交换机，后来是因为对于带宽、对于控制层面的灵活性有更高的诉求，亚马逊云科技就把内部的交换机全部应用了 SDN 技术，把整个平台构建起来。所以，不能说硬件的创新成为现在云计算的主流，而是我们可以通过硬件创新的方式，更好地满足客户的需求。除了硬件以外，还有软件方面的能力，我们很多时候在看云或者看产品的时候，往往会陷入到少数几个性能指标里，因为这个可能是最抓眼球或者是最便于理解的，但其实实际客户使用的时候，有很多的功能性需求的。如果亚马逊云科技只有底层的硬件，没有软件支撑，是不行的。所以，硬件创新是走到现在这个阶段里边非常重要的一环，但是它不是唯一的维度。</p><p></p><p>InfoQ：C7gn 和 HPC7g 都是服务密集型工作负载的实例，这是否说明云计算下一阶段的主要技术攻坚方向会聚焦于自然科学、工程、气象这些领域？</p><p></p><p>代闻：在我看来，现在在 HPC 领域里边的很多基准测试程序，体现在云计算的环境里边，是证明了在这个方向的上限能力。这个上限就决定了底层的基础设施的能力。无论这次发布的 Nitro v5、Graviton 3E ，还是重新把很多底层的通信用 SRD 的协议重新做部署。其实这就是拿 HPC 场景证明了云计算本身的能力。</p><p></p><p>在客户侧，我们看到近年来 HPC 在云上面是可以得到非常好的支撑，尤其是随着自动驾驶、药物研发投入需求增加，亚马逊云科技的产品研发团队就会比较切实地从用户需求出发来反推新的产品方向，进一步做底层创新，对这些场景加以支撑。从自动驾驶和药物研发，到欧洲粒子对撞实验室，都有过非常多的 HPC 的场景，但是之前从密度上来讲没有现在这么高，这两年虽然场景还是那些场景，但是，需求密度大大增加了，伴随着需求增加而进行的这些创新就可以提供更好的业务支撑和加速。</p><p></p><p></p><h2>Serverless 化全面改造</h2><p></p><p></p><p>InfoQ：前几个问题主要跟代闻老师聊了关于 Infra 的发布，以及对于云计算行业来说有着什么样的意义。接下来想聊一下 Serverless。本次 re:Invent 发布了 Amazon Lambda SnapStart，能否为我们解读下这一发布对行业的价值，以及是如何实现的？</p><p></p><p>代闻：亚马逊云科技对于无服务器的计算环境的投入是非常早的，其实在 Amazon Lambda 刚出来的时候，很多人不太看好，因为跟多年以前的 Runtime 托管非常像。并且，在 Lambda 推出的 2014 年，那个时候大家讲的更多得还是从虚拟机到容器。但是亚马逊云科技当时坚持认为，以后无服务器和容器都会占据非常重要的位置。</p><p></p><p>其实我认为无服务器，更多的是一种计算环境的体现，或者是从用户角度来判定“我”需要一个什么样的计算服务或者是一个平台服务。在最开始的时候，我们狭义上的 Serverless 是 Amazon Lambda，来运行我们自己的代码。后来，开发者想要把第三方软件或服务也能够 Serverless 化（以同样获得弹性、免运维等益处），现在才看到了诸如 EMR Serverless、Aurora Serverless、Redshift Serverless、OpenSearch Serverless 等产品形态的的出现，同时第三方软件服务的 Serverless 版本也逐渐成为标配。</p><p></p><p>具体回到 Amazon Lambda 里，亚马逊云科技一直在不断地把 Amazon Lambda 的使用边界拓宽。在最开始的时候，冷启动，甚至是在 VPC 的访问方面都有一些限制。后来你会看到它一步一步地去做增强，一部分是性能方面，一部分是功能需求方面。</p><p></p><p>功能需求方面，一开始 Amazon Lambda 的开发环境都成问题，本地开发环境也不太友好，但现在整个的工具链是非常成熟的。性能方面，从最开始的发布到 Firecracker microVM 技术的引进，再到现在的 &nbsp;Amazon Lambda SnapStart ，它是把运行环境里边的内存和磁盘做镜像， 把初始运行环境 Cache (缓存) 起来。当你要运行代码的时候，它立马能够从 Cache 源中恢复出运行环境，来做迅速地扩展。以前冷启动是不能适应这种有负载抖动的场景的，现在它可以无缝地扩展、收缩。这样一来，能够让大家更加专注在应用代码的编写上面并将适用边界拓展到更加有挑战性的场景里面去。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/78/788796535b7c4c34ae61301b80dec209.png\" /></p><p></p><p>InfoQ：能否为我们聊聊亚马逊云科技是如何针对云产品，推进 Serverless 化全面改造的？</p><p></p><p>代闻：一方面是用户的需求，另外一方面从技术上分析。Serverless 第一步是最基本的计算环境 &nbsp;Serverless，第二步，第三方代码能不能托管进去？所以在技术方面，有了 &nbsp;Serverless 的便利性以后，下一步就是平台软件的 Serverless &nbsp;化。现在的平台软件里数据相关的软件比较多。数据库也好，数据分析软件也好，本质上就是一个系统，它自己就是一个平台软件，既然代码运行环境可以 Serverless 化，把这个技术应用到平台软件，就很自然的推动了 Serverless 化全面改造。</p><p></p><p>InfoQ：所以代闻老师觉得我们现在 Serverless 的实践整体进展到什么样的阶段？它距离我们未来的一个理想目标大概还有多远？</p><p></p><p>代闻：当我们谈一个产品或者技术的未来，我们需要先设定多大的时间维度。其实很多产品的创新是持续性的，是一步一步往前推进的。我们对于不同的客户，不同的工作负载提供了不同的工具，客户自己会选择最合适的产品，而且每个产品都有自己的参考架构。有的客户业务场景适合全部用 Serverless ，有的场景可能发现还是容器或者虚拟机这样的方式会更适合。然后，当用户发现 Serverless 的使用在他们的业务场景里还是有限制的时候，新的需求就会产生，反推我们做下一个迭代。所以云服务创新很关键的一点是，真正的从用户的需求出发，来反推技术的演进，而不是关门站在技术的制高点上面，研究出一个工具，让大家一定要用。</p><p></p><h2>云如何成为创新时代的核心</h2><p></p><p></p><p>InfoQ：在 re:Invent 上，亚马逊高级副总裁、CTO Werner Vogels 发布了许多对开发者有重大意义的产品，Amazon Step Functions Distributed Map 为何会聚焦并发数量的变化，是我们基于什么样的需求来做的产品迭代？</p><p></p><p>代闻：整个的云计算历程是始于开发者和一些初创公司的，然后再被大的企业接受、在企业领域应用和创新。开发者是云计算功能、性能不断地做创新，一直能往下走的一个非常重要的引擎。在整个的亚马逊的版图里，开发者是非常非常重要的，也是能保障亚马逊云科技的产品、服务，最后的落地能力足够强的很重要的保障。</p><p></p><p>再回到具体的特点中，Amazon Step Functions Distributed Map 可以看作是在云原生的环境下，对于开发者提供的更加有利的一个工具。说到云原生，什么是云原生？云原生是程序从第一天就是在云上跑的，根本不需要考虑如果放在机房里面是怎么样。比如，现在有 100 万个日志文件在 Amazon S3 上面，想要对文件里边的某一个字符进行更改。这个时候就要对很多的日志文件，同时进行更改操作，需要有非常大的并发。如果没有 Amazon Step Functions Distributed Map 就需要 Launch 一个大数据的服务，然后通过数据处理来做，但现在有了 Amazon Step Functions Distributed Map &nbsp;以后，就可以屏蔽底层的复杂度、非常轻松地来实现这个处理。这样一来，就可以真正地进一步完善云原生环境里边的开发体验。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/2c/2c2384deeaf13b56a4e09a9be80ad64b.png\" /></p><p></p><p>云原生影响的不只是我们程序的运算环境，还会影响到开发者的默认前提。云原生时代的开发者，他的需求包括对于工具的抽象程度，其实和以前是不一样的。我们需要把工具做足够好的抽象，让大家在云原生状态下进一步地聚焦在业务上面，不用关心底层逻辑。云原生，它是相对概念。刚上云的时候，云原生可能指的是弹性、高可用这些，但走到现在，可能是平台、操作、数据处理等。云原生不是绝对的，因为云服务本身的边界在不断变宽、变多，云原生是相对于什么时候的云原生，十年前的云原生还是现在云原生，是不太一样的。</p><p></p><p>InfoQ：代闻老师这个回答非常生动地解释了云原生对开发者的影响到底是什么。我自己在看 Amazon Step Functions 发布的时候，其实我一直在纠结概念上的区别，就是低代码。Amazon &nbsp;Step Functions 过去的应用情况如何，和流行的低代码理念的核心区别是什么？</p><p></p><p>代闻：低代码也是相对概念，是一个过程。低代码可以以发展进程式的方式来理解。Amazon Step Functions 也有一个叫 Workflow Studio 的低代码可视化工具。Amazon Step Functions 一整套工具集与低代码有相同的实现目的，即能够把一些重复的、晦涩难懂的工作用更加简易的、可视化的方式实现，所以，如果站在更高层面上，把低代码看作是技术往下一代演进的一个过程，那么 Amazon Step Functions &nbsp;和低代码就是在同一个维度上面的，更何况 Step Function Workflow Studio 本身就是一个低代码类的产品。</p><p></p><p>InfoQ：Amazon CodeCatalyst 也是个很有意思的发布，现在研发管理的 SaaS 和软件有很多，Amazon CodeCatalyst 的核心特色是什么？</p><p></p><p>代闻：Amazon CodeCatalyst 更多的是关注云原生的开发环境。在我看来 Amazon CodeCatalyst 的特色主要有两点。第一，它覆盖到了开发的整个生命周期。从最开始的规划，到软件架构的设计，再到底层的系统架构的采用，再到编码，其实都是可以在这个平台里边来完成的。第二，开发环境和协作环境都是在云端完成的，这样一来，对于内部协作的统一性，开发的便利性，都能得到很好的保障。每一次新的服务发布以后，就是新的领域或者一个新的方向的开始，我相信 Amazon CodeCatalyst 在接下来也会接收到很多用户的输入，让它不断迭代。同时 CodeCatalyst 也兼容很多合作伙伴产品，大家会一起前行。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/a9/a9d9c37610fb2809bb42805568414068.png\" /></p><p></p><p>InfoQ：结合 Werner 这几款产品的发布，能否为我们解读下亚马逊云科技如何理解开发者当下面临的困难？</p><p></p><p>代闻：<a href=\"https://www.infoq.cn/article/wYhCKfgNMY0UXt4cUWlf\">Werner Keynote</a>\" 里边最开始谈的是并行以及异步，他认为，异步是并行很重要的支撑。Werner &nbsp;Keynote 谈到在现代的软件开发架构下，如何构建一个松耦合的高并发系统，这正是现在很多的开发者会遇到的问题。虽然微服务已经提出很长的时间，但是大多数企业依然需要让软件架构往前演进。其关键在于，首先是能够把握住业务需求，第二，是要有好的设计原则、并且遵循设计原则，进而灵活的支撑业务需求。去年， Werner 也分享了他的 API 设计的原则，但是真的落地的时候，由于种种原因，大家还是会遇到很多困难。</p><p></p><p>亚马逊看到了这些难点，然后针对很多共性需求开发了一系列抽象服务，屏蔽底层实现的复杂度，让更多中小企业和开发者可以轻松推进软件架构演进，实现云原生。例如，Amazon Step Functions Distributed Map 就是这样一个服务，对于大规模并发的数据处理，开发者不用再自己实现并发机制，在云原生的环境里更加专注业务需求。</p><p></p><p>InfoQ：从 2022 的时间点来看，当下云计算处于什么阶段，未来趋势如何？</p><p></p><p>代闻：这取决于我们从多大的历史维度看这个问题。因为云服务本身是一个服务，服务的本身是要帮助使用者、客户实现自己的业务目标。技术实现来源于需求，反过来，有新的技术以后又能够进一步拓宽边界和可能性，客户又可以在新的方向去试验，一起把推动云计算向前发展。如果一定要找一个维度来看云计算处在什么阶段，那么，从现在企业的 IT Spending 来看，它还是早期的。</p><p></p><p>以上内容根据采访视频整理，以视频内容为准</p><p></p><p>为了将 2022 亚马逊云科技 re:Invent 全球大会的精华内容和体验带给中国众多云计算爱好者，亚马逊云科技将于 12 月 20 日开启<a href=\"https://dev.amazoncloud.cn/\"> 2022 re:Invent 中国行城市巡展活动</a>\"，实现“全球盛会，中国共享”！</p>",
    "publish_time": "2022-12-20 17:03:15",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  },
  {
    "title": "数字化转型到了要结果的时候，容器拿什么兑现？",
    "url": "https://www.infoq.cn/article/f5XCDCbtJuBYfkFzUReL",
    "summary": "<p>最近两到三年，随着基础软件的不断完善，数字化转型的概念“越提越凶”，企业也不再是面对一堆的数字化工具无从下手，而是越来越注重成果和价值，这也得益于众多管理工具、分析工具等的成熟，让企业在数字化转型过程中投入的成本越来越透明、可控。</p><p>&nbsp;</p><p>云计算在企业数字化转型中起到的作用则被广泛认可，尤以云原生更甚。根据IDC的预测，到2025年，全球近三分之二的企业将成为软件生产商，超过90%的应用程序为云原生应用程序。在中国，超过一半的中国500强企业将成为软件生产商，超过90%的应用程序为云原生应用程序。</p><p>&nbsp;</p><p>云原生应用正在变得越来越普及，而企业对云原生化之后的结果和价值更为重视。云原生转型的投入产出比是多少？降本增效的结果是什么？是否还有进一步优化的空间？是否达到了预期结果？这些是企业急需算清楚的账，也是<a href=\"https://kubesphere.cloud/docs/kse/release-notes/v3-3-1/\">青云KubeSphere企业版3.3</a>\"想要解决的问题之一。</p><p>&nbsp;</p><p><img src=\"https://static001.geekbang.org/infoq/c8/c8a1155baeb0add450054fdb2f9689a1.png\" /></p><p></p><h1>KubeSphere企业版3.3：不仅是算账，更重要的是数字化运营能力建设</h1><p></p><p>&nbsp;</p><p>2018年7月，青云在Cloud Insight Conference云计算峰会上开源了全新的<a href=\"https://s.geekbang.org/search/c=0/k=%E5%AE%B9%E5%99%A8/t=\">容器</a>\"平台——KubeSphere，帮助企业快速低成本管理容器。</p><p>&nbsp;</p><p>开源至今，KubeSphere社区用户覆盖了全球100多个国家和地区，GitHub上Star数超过11400个，下载量近百万，开发贡献者超300人。KubeSphere已经名副其实成为全球三大主流开源容器平台之一。这个过程中，青云也对上游社区做了诸多贡献，覆盖存储、网络、<a href=\"https://s.geekbang.org/search/c=0/k=DevOps/t=\">DevOps</a>\"、负载均衡等方面。</p><p>&nbsp;</p><p>随着越来越多的企业在生产环境部署KubeSphere，青云收到了客户大量商业化的服务和能力的需求，逐渐衍生出KubeSphere企业版，支持大量商业功能，包括跨数据中心的同城灾备、异地同城应用级别双活、平台级别灾备、应用级别灾备、微服务框架、业务转型等，帮助企业客户落地云原生。</p><p>&nbsp;</p><p>那么，KubeSphere企业版本次发布的3.3版本具体是如何帮助企业具备数字化运营能力的？</p><p>&nbsp;</p><p>根据青云科技KubeSphere容器平台产品经理张文浩介绍，3.3版本上线了全新的可观测中心，其可以将分散在各集群的数据汇总同步到一起，也可以通过自定义范围配置指定汇总数据范围，将数据“化零为整”；可以定向统计集群数据，分门别类；多集群告警统一管理分发，一步到位。</p><p></p><p><img src=\"https://static001.geekbang.org/infoq/41/4183e2d1bfc581ccfcf029f8287f5a6a.png\" /></p><p>KubeSphere&nbsp;企业版3.3 可观测中心</p><p></p><p>以上这些都是结果，可量化云原生转型的结果。通过这些数据，企业可以清楚了解到所投入资源带来的收益。除了结果，企业更需要的是建议，是更好地完成云原生转型的建议，区别于其他通过设置各类监控指标而为了监控而监控的产品，3.3版本的可观测中心通过监控页面帮助企业对配额、资源状态做到精细化管理，并提前预警，达到给建议的目的。</p><p>&nbsp;</p><p>除了上述偏向运维侧的更新，3.3版本在开发者侧也做了很多工作。开源多年，KubeSphere对云原生领域的开发者群体来说俨然是一个成熟的产品，每一个工作领域都提供了相应的工具，并在易用性层面取得了诸多进展。</p><p>&nbsp;</p><p>为了帮助对云原生转型尚不熟悉的开发者，3.3版本释放了多套双引擎能力：微服务治理层面的Istio+Spring Cloud双引擎，新增的Spring Cloud引擎主要针对Java技术栈的开发者，可以选用熟悉的语言工具“无痛”转型；CI/CD持续部署层面是Jenkins+Argo CD双引擎，CI层面3.3版本全面拥抱GitOps，不仅停留在工具层面，更多是将其融合进了KubeSphere本身的多租户、权限管理、统一多租户打通等流程中，实现了高度统一化处理，方便开发者尝试。</p><p>&nbsp;</p><p>此外，3.3版本新增了飞书作为通知接收渠道，并更新了租户级镜像仓库，在存储层面对权限管理做深度打磨，新增了PVC自动扩容，达到企业预设的额度后可自动扩容。同时，为了适应企业内部的行政结构，3.3版本新增了集群管理员对权限进行了精细划分。</p><p>&nbsp;</p><p>值得注意的是，KubeSphere企业版对云原生数据库的支持，从3.2版本的支持ClickHouse、MySQL以及PostgreSQL三款新增到3.3版本的九款主流的中间件和数据库支持，操作层面也可完成一键化部署，应用层面支持可视化参数配置，整体与KubeSphere可拆合。</p><p></p><h1>未来蓝图：KubeSphere LuBan架构即将上线</h1><p></p><p></p><p>根据青云科技KubeSphere云原生产品负责人于爽介绍，KubeSphere&nbsp;企业版4.0正在打磨之中，其将基于KubeSphere&nbsp;LuBan架构进行构建，以LuBan架构为产品内核，实现平台模块化。</p><p>&nbsp;</p><p>在KubeSphere快速迭代的四年时间，客户诉求也在不断改变，逐渐不再需要固定形态的产品，转而追求通过更丰富的插件来解决问题。在KubeSphere现有的应用中心内，开发者已经体验到了青云及其合作伙伴开发的组件，这在某种程度上可以解决一些问题，但带来的体验仍旧是割裂的，客户还需要跳出KubeSphere才能体验这些能力。</p><p>&nbsp;</p><p>为此，4.0版本实现了最大程度的可插拔，提供热插拔的插件式微内核架构和插件中心，可以更好地服务不同的客户需求。通过KubeSphere LuBan架构，任何组件后端API均可以动态嵌入KubeSphere中，任何第三方组件前端也可以动态嵌入到KubeSphere前端，同时，插件中心能够提供满足各种场景和需求的企业级插件。这样，企业不需要等待KubeSphere的版本迭代，就能真正实现有价值的云原生操作系统。</p><p>&nbsp;</p><p>2022年，KubeSphere已经帮助众多企业和开发者顺利完成云原生转型。以中金国际为例，其借助青云全栈的云计算能力，上层通过KubeSphere打通多集群管理，底层整合了青云企业云平台的计算资源、存储资源、灾备解决方案以及应用商店等能力，形成了适合业务特点的中金苍穹容器平台，实现了第一阶段的数字化转型。未来，青云将会与其一起在统一的云原生基础设施层之上进行更多场景的迭代和优化，包括微服务场景、DevOps场景等。</p><p>&nbsp;</p><p>而预计在明年Q1，随着LuBan Alpha版本的发布，未来一段时间将会有更多企业通过与青云联手将KubeSphere部署在企业内部而获得转型成功。</p><p></p><h1>一切都是社区和开发者的</h1><p></p><p>&nbsp;</p><p>最后，于爽强调开源依旧是KubeSphere非常重要的战略，未来也将承诺持续保证其100%开源。在发版节奏上，KubeSphere会基于当前的V3版本持续迭代较长一段时间，4.0版本目前已经在规划中，将会逐步开源，面向社区优先提供免费安装包下载使用的方式。</p><p>&nbsp;</p><p>此外，团队会将优秀的商业功能逐渐贡献给开源社区，最终一切都将是社区和开发者的。</p>",
    "publish_time": "2022-12-20 18:41:21",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]