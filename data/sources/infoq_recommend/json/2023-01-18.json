[
  {
    "title": "Spring Authorization Server 1.0提供了OAuth 2.1和OpenID Connect 1.0实现",
    "url": "https://www.infoq.cn/article/aVZBQSZYiCA5PhzA3EDy",
    "summary": "<p>在向Java社区<a href=\"https://spring.io/blog/2020/04/15/announcing-the-spring-authorization-server\">推出</a>\"两年半之后，VMWare<a href=\"https://spring.io/blog/2022/11/22/spring-authorization-server-1-0-is-now-ga\">发布</a>\"了Spring Authorization Server 1.0。 <a href=\"https://spring.io/projects/spring-authorization-server\">Spring Authorization Server</a>\"项目构建在<a href=\"https://spring.io/projects/spring-security/\">Spring Security</a>\"之上，支持创建<a href=\"https://openid.net/connect/\">OpenID Connect 1.0</a>\" Identity Provider和<a href=\"https://oauth.net/2.1/\">OAuth 2.1</a>\" Authorization Server。该项目取代了业已不再维护的<a href=\"https://spring.io/projects/spring-security-oauth/\">Spring Security OAuth</a>\"项目。</p><p></p><p>Spring Authorization Server也基于<a href=\"https://www.infoq.com/news/2022/11/spring-6-spring-boot-3-launch/\">Spring Framework 6.0</a>\"，需要使用Java 17作为最低版本。该项目支持<a href=\"https://docs.spring.io/spring-authorization-server/docs/current/reference/html/overview.html#feature-list\">特征列表</a>\"中描述的Authorization Grants、Token Format、Client Authentication和Protocol Endpoints。</p><p></p><p>有个示例应用阐述了使用<a href=\"https://start.spring.io/\">Spring Initializr</a>\"创建Spring Boot应用的基本配置。该示例应用是基于REST的，需要在**pom.xml**文件中包含_spring-boot-starter-web_依赖：</p><p></p><p><code lang=\"text\">dependency&gt;\n    org.springframework.boot\n    spring-boot-starter-web\n\n</code></p><p></p><p>为了阐述登录功能，请考虑如下创建REST端点的样例：</p><p></p><p><code lang=\"java\">@RestController\npublic class TimeController {\n\n    @GetMapping(\"/time\")\n    public String retrieveTime() {\n        DateTimeFormatter dateTimeFormatter =    \n            DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n        LocalTime localTime = LocalTime.now();\n        return dateTimeFormatter.format(localTime);\n    }\n}\n</code></p><p></p><p>一个基础的Spring Boot应用类用来启动应用与前文创建的REST端点：</p><p></p><p><code lang=\"java\">@SpringBootApplication\npublic class TimeApplication {\n\n    public static void main(String[] args) {\n     SpringApplication.run(TimeApplication.class, args);\n    }\n}\n</code></p><p></p><p>在启动应用之后，打开<a href=\"http://localhost:8080/time\">http://localhost:8080/time</a>\" URL，将会显示当前时间：</p><p></p><p><code lang=\"text\">21:00:34\n</code></p><p></p><p>现在，我们添加Spring Authorization Server依赖：</p><p></p><p><code lang=\"java\">\n    org.springframework.security\n    spring-security-oauth2-authorization-server\n    1.0.0\n\n</code></p><p></p><p>当再次启动应用后，日志中会打印出密码，例如：</p><p></p><p><code lang=\"java\">Using generated security password: d73d5904-25a1-44ed-91e1-a32c4c5aedb8\n</code></p><p></p><p>现在，当访问<a href=\"http://localhost:8080/time\">http://localhost:8080/time</a>\"时，请求会重定向到<a href=\"http://localhost:8080/login\">http://localhost:8080/login</a>\"，并展示如下所示的页面：</p><p></p><p><img src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/news/2022/12/spring-authorization-server-1-0/en/resources/1Login-1671654888951.png\" /></p><p></p><p>我们使用默认的用户名_user_以及打印出的密码登录之后，请求会被重定向到<a href=\"http://localhost:8080/time?continue\">http://localhost:8080/time?continue</a>\"，并再次显示当前时间。</p><p></p><p><a href=\"https://docs.spring.io/spring-authorization-server/docs/current/reference/html/getting-started.html#developing-your-first-application\">“开发第一个样例”</a>\"文档详细介绍了Spring Authorization Server需要的几个**<a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html\">@Bean</a>\"组件，它们应该定义在带有<a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html\">@Configuration</a>\"**注解的类中。第一个bean用来定义OAuth2 <a href=\"https://docs.spring.io/spring-authorization-server/docs/current/reference/html/protocol-endpoints.html\">Protocol Endpoint</a>\"：</p><p></p><p><code lang=\"java\">@Bean\n@Order(1)\npublic SecurityFilterChain protocolFilterChain(HttpSecurity http)\n    throws Exception {\n    OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http);\n    http\n        .exceptionHandling((exceptions) -&gt; exceptions\n        .authenticationEntryPoint(\n            new LoginUrlAuthenticationEntryPoint(\"/login\"))\n        )\n        .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt)\n        .getConfigurer(OAuth2AuthorizationServerConfigurer.class)\n        .oidc(Customizer.withDefaults());\n\n        return http.build();\n}\n</code></p><p></p><p>第二个bean用来定义Spring Security <a href=\"https://docs.spring.io/spring-security/reference/servlet/authentication/index.html\">Authentication</a>\"：</p><p></p><p><code lang=\"java\">@Bean\n@Order(2)\npublic SecurityFilterChain authenticationFilterChain(HttpSecurity http) throws Exception {\n    http\n    .authorizeHttpRequests((authorize) -&gt; authorize\n        .anyRequest().authenticated()\n    )\n    .formLogin(Customizer.withDefaults());\n\n    return http.build();\n}\n</code></p><p></p><p>在真正的产品中，我们应该使用合理的方案来存储用户，但是在这个简单的样例中，用户_james_和密码_gosling_存储在了内存中：</p><p></p><p><code lang=\"java\">@Bean\npublic UserDetailsService userDetailsService() {\n    UserDetails userDetails = User.withDefaultPasswordEncoder()\n        .username(\"james\")\n        .password(\"gosling\")\n        .roles(\"FOUNDER\")\n        .build();\n\n    return new InMemoryUserDetailsManager(userDetails);\n}\n</code></p><p></p><p>新的客户端使用**<a href=\"https://docs.spring.io/spring-authorization-server/docs/current/reference/html/core-model-components.html#registered-client-repository\">RegisteredClientRepository</a>\"**注册在了内存中：</p><p></p><p><code lang=\"java\">@Bean\npublic RegisteredClientRepository registeredClientRepository() {\n    RegisteredClient registeredClient =            \n        RegisteredClient.withId(UUID.randomUUID().toString())\n        .clientId(\"id\")\n        .clientSecret(\"secret\")\n        .clientAuthenticationMethod(\n            ClientAuthenticationMethod.CLIENT_SECRET_BASIC)\n        .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)\n        .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)\n        .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)\n        .redirectUri(\n          \"http://127.0.0.1:8080/login/oauth2/code/messaging-client-oidc\")\n        .redirectUri(\"http://127.0.0.1:8080/authorized\")\n        .scope(OidcScopes.OPENID)\n        .scope(OidcScopes.PROFILE)\n        .scope(\"message.read\")\n        .scope(\"message.write\")\n        .clientSettings(\n            ClientSettings.builder()\n            .requireAuthorizationConsent(true).build())\n        .build();\n\n  return new InMemoryRegisteredClientRepository(registeredClient);\n}\n</code></p><p></p><p>访问令牌会使用如下的bean进行签名，它会使用**com.nimbusds.jose.jwk.RSAKey，而不是java.security.interfaces.RSAKey**：</p><p></p><p><code lang=\"java\">@Bean\npublic JWKSource jwkSource() {\n    KeyPair keyPair = generateRsaKey();\n    RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();\n    RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();\n    RSAKey rsaKey = new RSAKey.Builder(publicKey)\n        .privateKey(privateKey)\n        .keyID(UUID.randomUUID().toString())\n        .build();\n    JWKSet jwkSet = new JWKSet(rsaKey);\n    return new ImmutableJWKSet&lt;&gt;(jwkSet);\n}\n\nprivate static KeyPair generateRsaKey() {\n    KeyPair keyPair;\n    try {\n        KeyPairGenerator keyPairGenerator =                     \n            KeyPairGenerator.getInstance(\"RSA\");\n        keyPairGenerator.initialize(2048);\n        keyPair = keyPairGenerator.generateKeyPair();\n    }\n    catch (Exception ex) {\n        throw new IllegalStateException(ex);\n    }\n    return keyPair;\n}\n</code></p><p></p><p><a href=\"https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/jwt/JwtDecoder.html\">JwtDecoder</a>\"会用来解码已签名的访问令牌，它会使用com.nimbusds.jose.proc.SecurityContext，而不是**org.springframework.security.core.context.SecurityContext**：</p><p></p><p><code lang=\"java\">@Bean\npublic JwtDecoder jwtDecoder(JWKSource jwkSource) {\n    return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource);\n}\n</code></p><p></p><p>最后，**<a href=\"https://docs.spring.io/spring-authorization-server/docs/current/reference/html/configuration-model.html#configuring-authorization-server-settings\">AuthorizationServerSettings</a>\"**会用来配置OAuth2认证服务器：</p><p></p><p><code lang=\"java\">@Bean\npublic AuthorizationServerSettings authorizationServerSettings() {\n    return AuthorizationServerSettings.builder().build();\n}\n</code></p><p></p><p>现在，当浏览<a href=\"http://localhost:8080/time\">http://localhost:8080/time</a>\"时，可以使用用户名_james_和密码_gosling_来查看当前的时间。在遵循这些步骤后，该应用可以扩展为使用各种OAuth2和OpenID Connect 1.0功能，如令牌。</p><p></p><p>有多个视频对Spring Authorization Server进行了详细解释，例如Spring Security团队的核心提交者<a href=\"https://www.linkedin.com/in/joegrandja/\">Joe Grandja</a>\"在旧金山JUG上做了<a href=\"https://www.youtube.com/watch?v=3NliXoTcPSo\">Spring Authorization Server入门</a>\"的演讲，<a href=\"https://www.manning.com/books/spring-security-in-action\">Spring Security in Action</a>\"的作者<a href=\"https://twitter.com/laurspilca\">Laurentiu Spilca</a>\"在Spring I/O上介绍了<a href=\"https://www.youtube.com/watch?v=DaUGKnA7aro\">如何使用Spring Security实现OAuth 2认证服务器</a>\"。</p><p></p><p>该项目是基于<a href=\"https://tanzu.vmware.com/support/oss\">VMware Tanzu开源软件支持</a>\"策略发布的，这意味着主要版本的支持时间长达三年。另外，VMware还提供24/7的<a href=\"https://tanzu.vmware.com/spring-runtime\">商业支持</a>\"。</p><p></p><p>更多信息可以参考<a href=\"https://docs.spring.io/spring-authorization-server/docs/current/reference/html/getting-started.html\">入门指南</a>\"、<a href=\"https://docs.spring.io/spring-authorization-server/docs/current/reference/html/\">参考</a>\"文档和GitHub上的<a href=\"https://github.com/spring-projects/spring-authorization-server/tree/main/samples\">示例</a>\"。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/news/2022/12/spring-authorization-server-1-0/\">Spring Authorization Server 1.0 Provides Oauth 2.1 and OpenID Connect 1.0 Implementations</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/09IBGv9JggKY4PNAIyPD\">一文看懂OAuth 2.0 (附实践案例)</a>\"</p><p><a href=\"https://www.infoq.cn/article/eUvhTtYf3JMfakMm8cmN\">OAuth 2.0与OpenID Connect协议的完整指南</a>\"</p>",
    "publish_time": "2023-01-18 08:00:00",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]