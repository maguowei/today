[
  {
    "title": "三步实现Lambda向Kubernetes大迁移",
    "url": "https://www.infoq.cn/article/AhfmZfWjvUAmap5lcTAI",
    "summary": "<p><a href=\"https://en.wikipedia.org/wiki/Infrastructure_as_code\">基础设施即代码（IaC）</a>\"的世界已经掀起了云原生的风暴，如今配置云服务和应用程序时，它已成为一种通用的最佳实践。当云操作呈指数级增长时（这在当今基于SaaS和云托管的按需应用程序中发生得相当快），对于仍在利用ClickOps的公司来说，很快就会崩溃，ClickOps通过手动配置，但这在云应用程序中会造成漂移。</p><p></p><p>值得注意的是，虽然IaC是一种最佳实践，并提供了许多好处（包括避免漂移），当我们需要进行重大的基础设施迁移时，我们看到了它的真正价值。我们发现，由于我们很早就利用了IaC的强大功能，并在配置方面与最佳实践保持一致，因此以前复杂的迁移过程变得简单多了。（还记得像VeloStrata和CloudEndure这样的公司吗？它们就是为此目的而建立的吗？）当我们谈论云和供应商锁定时，我们已经了解到如何打包、配置和部署应用程序会直接影响它们的可移植性和可扩展性。</p><p></p><p>在本文中，我想分享我们在Firefly的工作，将作业从Serverless迁移到Kubernetes Job的伟大旅程、经验教训、以及帮助我们以最小的痛苦实现这一目标的技术。</p><p></p><h1>第一站：Lambda事件</h1><p></p><p></p><p>Serverless（无服务器）正在成为许多新兴甚至成熟公司的热门选择架构，因为它提供了云的所有好处——规模、可扩展性、弹性——以及最小管理和维护开销的附加值。它不仅速度快、可扩展，而且构建起来还非常有趣。</p><p></p><p><a href=\"https://aws.amazon.com/lambda/\">Lambda</a>\"、函数、连接它们的服务以及基于事件的架构是开发人员试验和快速迭代之前复杂架构的游乐场。对于专为此类工作而构建的<a href=\"https://developer.hashicorp.com/terraform/intro\">Terraform</a>\"和<a href=\"https://developer.hashicorp.com/terraform/language/modules\">Terraform Modules</a>\"来说尤为如此。突然之间即可通过lambda运行程序在数小时内构建支持大规模、并发操作的基础设施，这过去至少需要几天甚至几周。</p><p></p><p>然而，随着时间的推移，我们开始遇到事件驱动架构和设计方面的问题。 由于我们的数据和流正常工作所需的服务种类繁多——API网关、SQS、SNS、S3、事件桥等，事件的数量及其输入/输出开始增加。这就是我们开始触及已知的<a href=\"https://stackoverflow.com/questions/74193863/lambda-timeout-after-10s-both-in-serverless-offline-and-online\">Serverless超时墙</a>\"的地方。由于Serverless本质上是短暂的运行时，它基本上只有一个15分钟的任务完成窗口。如果任务没有及时完成，就会失败。</p><p></p><p>我们开始意识到，蜜月期可能已经结束了，我们需要根据用例和操作的具体性质来重新思考我们的基础设施选择。当你走上微服务的道路时——在我们的案例中，我们选择了利用<a href=\"https://go.dev/tour/concurrency/1\">Go例程</a>\"来实现多线程服务（所以我们谈论的是很多服务），你通常会开始失去对正在运行的作业和服务数量的控制。</p><p></p><p>我们“微服务统治一切！”的心态，在以前我们认为它是令人难以置信的可扩展性的标志，但现在是我们崩溃的根源。我们试图通过添加限制来解决超时问题，但这大大减慢了我们的流程（对SaaS公司来说这不是一件好事），这当然不是我们所希望的结果。当我们增加集群时，这带来了巨大的成本影响，这对于一家初创公司来说也不是理想的选择。</p><p></p><p>技术债的累积使我们开始考虑我们的选择——重写还是迁移？如果不进行重大改革，我们还可以考虑或利用哪些其他技术呢？</p><p></p><h1>第二站：停靠在ECS</h1><p></p><p></p><p>我们旅程的下一站是<a href=\"https://aws.amazon.com/ecs/\">ECS（Elastic Container Service，弹性容器服务</a>\"）。选择ECS实际上是我们最初选择将应用程序打包并部署到Serverless的副产品。我们选择将所有的应用程序进行docker化，并通过Terraform进行配置。这种早期的选择最终使我们能够选择我们的架构和基础设施。</p><p></p><p>我们决定尝试一下ECS，主要是因为它的分析能力，以及处理任务、事件和作业时没有时间限制，就像Serverless一样。</p><p></p><p>ECS的优势在于它的控制机制——这是它的核心功能，AWS在其中管理任务调度、优先级、在何处以及何时运行。然而，对我们来说，这也是一把双刃剑。</p><p></p><p>特定事件的性质要求我们在任务调度方面有更大的控制权，比如更细粒度的优先级排序、任务排序、基于预定义的指标和阈值推动动态配置，而不仅仅是编程限制，还需更具动态性并利用遥测数据的限制。例如，如果我们有一个特定的帐户或租户正在使系统超载或向系统发送垃圾邮件，我们可以更动态地限制该事件，并更好地控制每个租户的自定义配置。</p><p></p><p>当我们分析这种情况时，我们意识到缺少的是一台“计算机”，或者说是Kubernetes世界中的操作（operator）。（这是一篇关于如何编写第一个Kubernetes操作的好文章，在这里你可以了解更多详细信息）。</p><p></p><h1>第三站：回到Kubernetes作业的旅程中</h1><p></p><p></p><p>回到使用容器化lambda的选择上，我们意识到，由于这个选择，我们并没有局限于基于AWS的基础设施，突然间，一个开放的社区标准选项出现了，这对我们和我们的需求来说是正确的选择。</p><p></p><p>如果我们想看看迁移到Kubernetes的好处，有很多需要考虑的因素：</p><p>有了Kubernetes作业（job），就有了一个可以实现更动态配置的操作（operator）作为一家以IaC为先的公司，<a href=\"https://helm.sh/\">Helm</a>\"是配置应用程序的绝佳方式在无限规模上进行更大、更细粒度的分析、限制和配置</p><p></p><p>对我们来说，能够手动配置和管理CPU和内存分配，以及通过深度分析对其进行定制和自动化，这一好处是非常重要的。特别是当我们谈论由具有高度不同使用行为的各种客户端组成的规模时，其中一个租户可以运行两个小时，而其他租户只能运行三秒。因此，这种可定制性对我们来说是一个关键特性，也是最终让我们确信这一举措的关键。</p><p></p><p>接下来是检查应用程序的不同层，以了解这种迁移的复杂性。</p><p></p><h2>如何将Lambda转换为Kubernetes作业？</h2><p></p><p></p><p>现在是我们进行哲学思考的时候了。最终，什么是lambda？这是一种需要使用特定配置并一次性完成的作业，该配置运行一组worker来完成作业。这让我们顿悟，这听起来很像……K8s的作业。</p><p></p><p>我们的容器化lambda和完全编码的配置使我们能够重用运行时和配置，在不同环境之间移动只需进行很少的调整。让我们来看看其中的一些关键元素。</p><p></p><h3>网络</h3><p></p><p></p><p>绝大多数网络要素都是通过容器化来覆盖的，包括安全组等等。另一方面，如果网络未配置为代码或定义不明确，那么可能会发现服务之间的通信崩溃。确保所有安全组及其资源，从VPC到其他任何东西，都得到了正确的配置，可以确保更加无缝的过渡，这本质上是民主化基础设施选择的基础。</p><p></p><h3>权限和外部配置</h3><p></p><p></p><p>另一个可以促成或破坏这种迁移的关键方面是权限和访问控制。Serverless（AWS）、ECS和Kubernetes与<a href=\"https://docs.aws.amazon.com/IAM/latest/UserGuide/id.html\">IAM角色</a>\"一起工作时，问题只在于如何设计角色，使流不会中断，然后就可以轻松地跨环境移植它们。通过这种方式，我们可以确保流程不会在过渡中中断。会存在一些小的更改和优化，例如配置信任关系； 但是，这比从头开始配置所有权限要好的多。</p><p></p><p>更改IAM角色的信任关系：</p><p><code lang=\"null\">{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Principal\": {\n                \"Service\": \"lambda.amazonaws.com\"\n            },\n            \"Action\": \"sts:AssumeRole\"\n        }\n    ]\n}\n</code></p><p></p><p>这使其可移植且可重复使用：</p><p><code lang=\"null\">{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"\",\n            \"Effect\": \"Allow\",\n            \"Principal\": {\n                \"Federated\": \"arn:aws:iam::123456789:oidc-provider/oidc.eks.us-east-1.amazonaws.com/id/XXXXXXXXXXXXXXXXX\"\n            },\n            \"Action\": \"sts:AssumeRoleWithWebIdentity\"\n        }\n    ]\n}\n</code></p><p></p><p>我们需要确保所涉及的其他更改也在Kubernetes部署中将环境变量转换成了configmap格式。这样，就可以连接到首选的运行时和环境上了。</p><p></p><h3>令人不快的运行时流</h3><p></p><p></p><p>这并不意味着不会存在另人不快的流。Docker并不是万能的，在某些情况下会出现兼容性问题，例如基础镜像可能会随着服务的不同而变化，或者在不同的操作系统发行版本之间发生变化，此外还有Linux问题，比如文件目录中的依赖关系。</p><p></p><p>然而，我们可以通过使用尽可能多的抽象来构建自己的Docker镜像和依赖关系，从而克服这些挑战。例如，在单独的构建器镜像中编译我们的Golang应用程序，并在目标镜像中使用它，或者在具有显式引用的结构中管理我们的环境变量，以避免依赖任何运行时为我们注入，这些都是避免运行时问题的良好实践。</p><p></p><h2>蓝/绿部署</h2><p></p><p></p><p>那么最终的发布是什么样的呢？虽然有一些停机时间，但这并不重要。我们团队选择了蓝/绿的方法来进行部署，并对此进行了密切监控，以确保所有数据都能正常接收，迁移也能顺利进行。</p><p></p><p>在我们进一步深入探讨之前，先简单介绍一下监控和日志记录。这是在部署任何内容之前需要确保正确迁移的另一个方面。当涉及到监控时，我们需要确保正确地转换了一些元素。如果我们之前监控过lambda，那么现在就需要将它们转换为监控集群和pod。我们需要验证日志是否能正常发送和到达——CloudWatch与fluentd。</p><p></p><p>一旦我们把所有这些都准备好了，就可以按照蓝/绿部署来重新路由我们的流量了。我们通过SQS将一些事件流路由到新的基础设施，并进行持续的完整性检查，以确保业务逻辑没有中断，一切都在传输，并且监控和日志记录都在正常工作。一旦我们检查了这个流程，并在没有任何中断的情况下将流量从以前的基础设施缓慢增加到新的基础设施上，我们的迁移就已经完成了。</p><p></p><p>这可能需要几个小时或几天的时间，具体时间取决于部署规模以及操作、SLA、数据等的敏感程度。唯一明确的建议是要确保我们有适当的可见性来了解它是否在有效地工作。</p><p></p><p>原文链接：</p><p><a href=\"https://www.infoq.com/articles/lambda-migration-k8s-jobs/\">https://www.infoq.com/articles/lambda-migration-k8s-jobs/</a>\"</p><p></p><p>相关阅读：</p><p><a href=\"https://www.infoq.cn/article/INZSfZJfHU5BR6buJXcT\">更便捷地迁移+开发：3年时间，鲲鹏 DevKit真的做到了</a>\"</p><p><a href=\"https://www.infoq.cn/article/hSHcmyE9R5HPhuNj7mSP\">迁移至云端：真的像看上去那样让人望而生畏吗？</a>\"</p><p><a href=\"https://www.infoq.cn/article/hH21bwuEudJFL93PNSh3\">使用 Rspack 构建真实开源项目，实测迁移成本和性能收益</a>\"</p>",
    "publish_time": "2023-05-30 10:04:18",
    "source": {
      "name": "infoq_recommend",
      "desc": "InfoQ推荐",
      "icon": "https://raw.githubusercontent.com/maguowei/today/master/imgs/icon/infoq.png"
    }
  }
]